
/tmp/arduino-sketch-21BED060D8BEF2BE08AA427E888308EF/motor_control.ino.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <_VectorsFlash>:
HardwareSerial 	*HardwareSerial::s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
uint8_t 		HardwareSerial::s_count_serials_with_serial_events = 0;

// simple helper function that add us to the list of Serial ports that have
// their own serialEvent code defined that needs to be called at yield.
void HardwareSerial::addToSerialEventsList() {
       0:	00 00 03 20 d1 01 00 00 a5 57 00 00 5d 57 00 00     ... .....W..]W..
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
		if (s_serials_with_serial_events[i] == this) return; // already in the list.
      10:	5d 57 00 00 5d 57 00 00 5d 57 00 00 5d 57 00 00     ]W..]W..]W..]W..
      20:	5d 57 00 00 5d 57 00 00 5d 57 00 00 a5 57 00 00     ]W..]W..]W...W..
	}

	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
      30:	a5 57 00 00 5d 57 00 00 31 6e 00 00 35 6e 00 00     .W..]W..1n..5n..
uint8_t 		HardwareSerial::s_count_serials_with_serial_events = 0;

// simple helper function that add us to the list of Serial ports that have
// their own serialEvent code defined that needs to be called at yield.
void HardwareSerial::addToSerialEventsList() {
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
      40:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..
      50:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..
      60:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..
      70:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..
      80:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..
      90:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..
      a0:	15 55 00 00 21 55 00 00 a5 57 00 00 a5 57 00 00     .U..!U...W...W..
      b0:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..
      c0:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..
      d0:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..
      e0:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..
      f0:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..
     100:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..
     110:	a5 57 00 00 55 61 00 00 a5 57 00 00 a5 57 00 00     .W..Ua...W...W..
     120:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..
     130:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..
     140:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..
     150:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..
     160:	a5 57 00 00 a5 57 00 00 2d 55 00 00 a5 57 00 00     .W...W..-U...W..
     170:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..
     180:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..
     190:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..
     1a0:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..
     1b0:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..
     1c0:	a5 57 00 00 a5 57 00 00 a5 57 00 00 a5 57 00 00     .W...W...W...W..

000001d0 <ResetHandler>:
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d0:	4b5c      	ldr	r3, [pc, #368]	; (344 <ResetHandler+0x174>)
     1d2:	f24c 5220 	movw	r2, #50464	; 0xc520
#else
// hopefully all others fit into startup section (below 0x400)
__attribute__ ((section(".startup"),optimize("-Os")))
#endif
void ResetHandler(void)
{
     1d6:	b510      	push	{r4, lr}
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d8:	801a      	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
     1da:	f64d 1228 	movw	r2, #55592	; 0xd928
     1de:	801a      	strh	r2, [r3, #0]
	__asm__ volatile ("nop");
     1e0:	bf00      	nop
	__asm__ volatile ("nop");
     1e2:	bf00      	nop
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
     1e4:	f005 fae2 	bl	57ac <startup_early_hook>
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1e8:	4b57      	ldr	r3, [pc, #348]	; (348 <ResetHandler+0x178>)
     1ea:	f04f 6230 	mov.w	r2, #184549376	; 0xb000000
     1ee:	601a      	str	r2, [r3, #0]
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
     1f0:	4a56      	ldr	r2, [pc, #344]	; (34c <ResetHandler+0x17c>)
     1f2:	609a      	str	r2, [r3, #8]
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
     1f4:	4a56      	ldr	r2, [pc, #344]	; (350 <ResetHandler+0x180>)
     1f6:	60da      	str	r2, [r3, #12]
	SIM_SCGC4 = SIM_SCGC4_USBOTG | 0xF0000030;
	SIM_SCGC5 = 0x00003F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_ADC0 | SIM_SCGC6_TPM0 | SIM_SCGC6_TPM1 | SIM_SCGC6_TPM2 | SIM_SCGC6_FTFL;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SCB_CPACR = 0x00F00000;
     1f8:	4b56      	ldr	r3, [pc, #344]	; (354 <ResetHandler+0x184>)
     1fa:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
     1fe:	601a      	str	r2, [r3, #0]
#endif
#if defined(__MK66FX1M0__)
	LMEM_PCCCR = 0x85000003;
     200:	4b55      	ldr	r3, [pc, #340]	; (358 <ResetHandler+0x188>)
     202:	4a56      	ldr	r2, [pc, #344]	; (35c <ResetHandler+0x18c>)
     204:	601a      	str	r2, [r3, #0]
		RTC_SR = 0;
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
     206:	4b56      	ldr	r3, [pc, #344]	; (360 <ResetHandler+0x190>)
     208:	781a      	ldrb	r2, [r3, #0]
     20a:	0711      	lsls	r1, r2, #28
     20c:	d503      	bpl.n	216 <ResetHandler+0x46>
     20e:	781a      	ldrb	r2, [r3, #0]
     210:	f042 0208 	orr.w	r2, r2, #8
     214:	701a      	strb	r2, [r3, #0]

    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     216:	4b53      	ldr	r3, [pc, #332]	; (364 <ResetHandler+0x194>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     218:	4953      	ldr	r1, [pc, #332]	; (368 <ResetHandler+0x198>)
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;

    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     21a:	22aa      	movs	r2, #170	; 0xaa
     21c:	701a      	strb	r2, [r3, #0]
     21e:	4a53      	ldr	r2, [pc, #332]	; (36c <ResetHandler+0x19c>)
     220:	4b53      	ldr	r3, [pc, #332]	; (370 <ResetHandler+0x1a0>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     222:	428b      	cmp	r3, r1
     224:	d204      	bcs.n	230 <ResetHandler+0x60>
     226:	f852 0f04 	ldr.w	r0, [r2, #4]!
     22a:	f843 0b04 	str.w	r0, [r3], #4
     22e:	e7f8      	b.n	222 <ResetHandler+0x52>
     230:	4b50      	ldr	r3, [pc, #320]	; (374 <ResetHandler+0x1a4>)
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
     232:	4951      	ldr	r1, [pc, #324]	; (378 <ResetHandler+0x1a8>)
     234:	2200      	movs	r2, #0
     236:	428b      	cmp	r3, r1
     238:	d202      	bcs.n	240 <ResetHandler+0x70>
     23a:	f843 2b04 	str.w	r2, [r3], #4
     23e:	e7fa      	b.n	236 <ResetHandler+0x66>

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
     240:	494e      	ldr	r1, [pc, #312]	; (37c <ResetHandler+0x1ac>)
     242:	4a4f      	ldr	r2, [pc, #316]	; (380 <ResetHandler+0x1b0>)
     244:	2300      	movs	r3, #0
     246:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
     24a:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
     24e:	3301      	adds	r3, #1
     250:	2b74      	cmp	r3, #116	; 0x74
     252:	d1f8      	bne.n	246 <ResetHandler+0x76>
     254:	4b4b      	ldr	r3, [pc, #300]	; (384 <ResetHandler+0x1b4>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
     256:	4a4c      	ldr	r2, [pc, #304]	; (388 <ResetHandler+0x1b8>)
     258:	2180      	movs	r1, #128	; 0x80
     25a:	f803 1b01 	strb.w	r1, [r3], #1
     25e:	4293      	cmp	r3, r2
     260:	d1fb      	bne.n	25a <ResetHandler+0x8a>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
     262:	4b4a      	ldr	r3, [pc, #296]	; (38c <ResetHandler+0x1bc>)
     264:	4a45      	ldr	r2, [pc, #276]	; (37c <ResetHandler+0x1ac>)
     266:	601a      	str	r2, [r3, #0]
	//  C6[PLLS] bit is written to 0
	//  C2[LP] bit is written to 1
#else
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
     268:	4b49      	ldr	r3, [pc, #292]	; (390 <ResetHandler+0x1c0>)
     26a:	228a      	movs	r2, #138	; 0x8a
     26c:	701a      	strb	r2, [r3, #0]
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
     26e:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
     272:	2224      	movs	r2, #36	; 0x24
     274:	705a      	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
     276:	22a0      	movs	r2, #160	; 0xa0
     278:	701a      	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
     27a:	799a      	ldrb	r2, [r3, #6]
     27c:	0792      	lsls	r2, r2, #30
     27e:	d5fc      	bpl.n	27a <ResetHandler+0xaa>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
     280:	799a      	ldrb	r2, [r3, #6]
     282:	06d4      	lsls	r4, r2, #27
     284:	d4fc      	bmi.n	280 <ResetHandler+0xb0>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     286:	4a43      	ldr	r2, [pc, #268]	; (394 <ResetHandler+0x1c4>)
     288:	7993      	ldrb	r3, [r2, #6]
     28a:	f003 030c 	and.w	r3, r3, #12
     28e:	2b08      	cmp	r3, #8
     290:	d1fa      	bne.n	288 <ResetHandler+0xb8>
	//   C2[LP] bit is written to 1
  #else
	// if we need faster than the crystal, turn on the PLL
   #if defined(__MK66FX1M0__)
    #if F_CPU > 120000000
	SMC_PMCTRL = SMC_PMCTRL_RUNM(3); // enter HSRUN mode
     292:	4b41      	ldr	r3, [pc, #260]	; (398 <ResetHandler+0x1c8>)
     294:	2260      	movs	r2, #96	; 0x60
     296:	701a      	strb	r2, [r3, #0]
	while (SMC_PMSTAT != SMC_PMSTAT_HSRUN) ; // wait for HSRUN
     298:	3302      	adds	r3, #2
     29a:	781a      	ldrb	r2, [r3, #0]
     29c:	2a80      	cmp	r2, #128	; 0x80
     29e:	d1fc      	bne.n	29a <ResetHandler+0xca>
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(11);
    #elif F_CPU == 192000000
	MCG_C5 = MCG_C5_PRDIV0(0);
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(8);
    #elif F_CPU == 180000000
	MCG_C5 = MCG_C5_PRDIV0(1);
     2a0:	4b3c      	ldr	r3, [pc, #240]	; (394 <ResetHandler+0x1c4>)
     2a2:	2201      	movs	r2, #1
     2a4:	711a      	strb	r2, [r3, #4]
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(29);
     2a6:	225d      	movs	r2, #93	; 0x5d
     2a8:	715a      	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     2aa:	799a      	ldrb	r2, [r3, #6]
     2ac:	0690      	lsls	r0, r2, #26
     2ae:	d5fc      	bpl.n	2aa <ResetHandler+0xda>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     2b0:	7999      	ldrb	r1, [r3, #6]
     2b2:	4a38      	ldr	r2, [pc, #224]	; (394 <ResetHandler+0x1c4>)
     2b4:	0649      	lsls	r1, r1, #25
     2b6:	d5fb      	bpl.n	2b0 <ResetHandler+0xe0>
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(3);
#elif F_CPU == 180000000
	// config divisors: 180 MHz core, 60 MHz bus, 25.7 MHz flash, USB = IRC48M
	#if F_BUS == 60000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(2) | SIM_CLKDIV1_OUTDIV4(6);
     2b8:	4b38      	ldr	r3, [pc, #224]	; (39c <ResetHandler+0x1cc>)
     2ba:	4939      	ldr	r1, [pc, #228]	; (3a0 <ResetHandler+0x1d0>)
     2bc:	6019      	str	r1, [r3, #0]
	#elif F_BUS == 90000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(6);
	#else
	#error "This F_CPU & F_BUS combination is not supported"
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(0);
     2be:	2100      	movs	r1, #0
     2c0:	6059      	str	r1, [r3, #4]
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     2c2:	2320      	movs	r3, #32
     2c4:	7013      	strb	r3, [r2, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     2c6:	7993      	ldrb	r3, [r2, #6]
     2c8:	f003 030c 	and.w	r3, r3, #12
     2cc:	2b0c      	cmp	r3, #12
     2ce:	d1fa      	bne.n	2c6 <ResetHandler+0xf6>
	// now we're in PEE mode
	// trace is CPU clock, CLKOUT=OSCERCLK0
	#if defined(KINETISK)
	#if F_CPU == 256000000 || F_CPU == 216000000 || F_CPU == 180000000
	// USB uses IRC48
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
     2d0:	4b34      	ldr	r3, [pc, #208]	; (3a4 <ResetHandler+0x1d4>)
     2d2:	4a35      	ldr	r2, [pc, #212]	; (3a8 <ResetHandler+0x1d8>)
     2d4:	601a      	str	r2, [r3, #0]
#endif

#if defined(__MK66FX1M0__)
	// If the RTC oscillator isn't enabled, get it started.  For Teensy 3.6
	// we don't do this early.  See comment above about slow rising power.
	if (!(RTC_CR & RTC_CR_OSCE)) {
     2d6:	4a35      	ldr	r2, [pc, #212]	; (3ac <ResetHandler+0x1dc>)
     2d8:	4c35      	ldr	r4, [pc, #212]	; (3b0 <ResetHandler+0x1e0>)
     2da:	6813      	ldr	r3, [r2, #0]
     2dc:	f413 7380 	ands.w	r3, r3, #256	; 0x100
     2e0:	d103      	bne.n	2ea <ResetHandler+0x11a>
		RTC_SR = 0;
     2e2:	6023      	str	r3, [r4, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
     2e4:	f44f 53a8 	mov.w	r3, #5376	; 0x1500
     2e8:	6013      	str	r3, [r2, #0]
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     2ea:	4b32      	ldr	r3, [pc, #200]	; (3b4 <ResetHandler+0x1e4>)
     2ec:	4a32      	ldr	r2, [pc, #200]	; (3b8 <ResetHandler+0x1e8>)
     2ee:	601a      	str	r2, [r3, #0]
	SYST_CVR = 0;
     2f0:	2200      	movs	r2, #0
     2f2:	605a      	str	r2, [r3, #4]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     2f4:	2207      	movs	r2, #7
     2f6:	f843 2c04 	str.w	r2, [r3, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     2fa:	4a30      	ldr	r2, [pc, #192]	; (3bc <ResetHandler+0x1ec>)
     2fc:	f8c3 2d0c 	str.w	r2, [r3, #3340]	; 0xd0c

	//init_pins();
	__enable_irq();
     300:	b662      	cpsie	i

	_init_Teensyduino_internal_();
     302:	f005 fdb9 	bl	5e78 <_init_Teensyduino_internal_>

#if defined(KINETISK)
	// RTC initialization
	if (RTC_SR & RTC_SR_TIF) {
     306:	6823      	ldr	r3, [r4, #0]
     308:	07da      	lsls	r2, r3, #31
     30a:	d505      	bpl.n	318 <ResetHandler+0x148>
		// compiled-in time will be stale.  Write a special
		// flag into the VBAT register file indicating the
		// RTC is set with known-stale time and should be
		// updated when fresh time is known.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     30c:	482c      	ldr	r0, [pc, #176]	; (3c0 <ResetHandler+0x1f0>)
     30e:	f005 fb7f 	bl	5a10 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
     312:	4b2c      	ldr	r3, [pc, #176]	; (3c4 <ResetHandler+0x1f4>)
     314:	4a2c      	ldr	r2, [pc, #176]	; (3c8 <ResetHandler+0x1f8>)
     316:	601a      	str	r2, [r3, #0]
	}
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
     318:	4b2c      	ldr	r3, [pc, #176]	; (3cc <ResetHandler+0x1fc>)
     31a:	781b      	ldrb	r3, [r3, #0]
     31c:	065b      	lsls	r3, r3, #25
     31e:	d509      	bpl.n	334 <ResetHandler+0x164>
     320:	4c28      	ldr	r4, [pc, #160]	; (3c4 <ResetHandler+0x1f4>)
     322:	4b29      	ldr	r3, [pc, #164]	; (3c8 <ResetHandler+0x1f8>)
     324:	6822      	ldr	r2, [r4, #0]
     326:	429a      	cmp	r2, r3
     328:	d104      	bne.n	334 <ResetHandler+0x164>
		// Our compiled-in time will be very fresh, so set
		// the RTC with this, and clear the VBAT resister file
		// data so we don't mess with the time after it's been
		// set well.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     32a:	4825      	ldr	r0, [pc, #148]	; (3c0 <ResetHandler+0x1f0>)
     32c:	f005 fb70 	bl	5a10 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0;
     330:	2300      	movs	r3, #0
     332:	6023      	str	r3, [r4, #0]
	}
#endif

	__libc_init_array();
     334:	f007 fc76 	bl	7c24 <__libc_init_array>

	startup_late_hook();
     338:	f005 fa3e 	bl	57b8 <startup_late_hook>
	main();
     33c:	f006 fe00 	bl	6f40 <main>
     340:	e7fe      	b.n	340 <ResetHandler+0x170>
     342:	bf00      	nop
     344:	4005200e 	.word	0x4005200e
     348:	40048030 	.word	0x40048030
     34c:	00043f82 	.word	0x00043f82
     350:	2b000001 	.word	0x2b000001
     354:	e000ed88 	.word	0xe000ed88
     358:	e0082000 	.word	0xe0082000
     35c:	85000003 	.word	0x85000003
     360:	4007d002 	.word	0x4007d002
     364:	4007e000 	.word	0x4007e000
     368:	1fff141c 	.word	0x1fff141c
     36c:	00009724 	.word	0x00009724
     370:	1fff0730 	.word	0x1fff0730
     374:	1fff1420 	.word	0x1fff1420
     378:	1fff2c60 	.word	0x1fff2c60
     37c:	1fff0200 	.word	0x1fff0200
     380:	00000000 	.word	0x00000000
     384:	e000e400 	.word	0xe000e400
     388:	e000e464 	.word	0xe000e464
     38c:	e000ed08 	.word	0xe000ed08
     390:	40065000 	.word	0x40065000
     394:	40064000 	.word	0x40064000
     398:	4007e001 	.word	0x4007e001
     39c:	40048044 	.word	0x40048044
     3a0:	02060000 	.word	0x02060000
     3a4:	40048004 	.word	0x40048004
     3a8:	000710c0 	.word	0x000710c0
     3ac:	4003d010 	.word	0x4003d010
     3b0:	4003d014 	.word	0x4003d014
     3b4:	e000e014 	.word	0xe000e014
     3b8:	0002bf1f 	.word	0x0002bf1f
     3bc:	20200000 	.word	0x20200000
     3c0:	620d3263 	.word	0x620d3263
     3c4:	4003e01c 	.word	0x4003e01c
     3c8:	5a94c3a5 	.word	0x5a94c3a5
     3cc:	4007f000 	.word	0x4007f000
     3d0:	ffffffff 	.word	0xffffffff
     3d4:	ffffffff 	.word	0xffffffff
     3d8:	ffffffff 	.word	0xffffffff
     3dc:	ffffffff 	.word	0xffffffff
     3e0:	ffffffff 	.word	0xffffffff
     3e4:	ffffffff 	.word	0xffffffff
     3e8:	ffffffff 	.word	0xffffffff
     3ec:	ffffffff 	.word	0xffffffff
     3f0:	ffffffff 	.word	0xffffffff
     3f4:	ffffffff 	.word	0xffffffff
     3f8:	ffffffff 	.word	0xffffffff
     3fc:	ffffffff 	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	ffffffff ffffffff ffffffff fffff9de     ................

00000410 <__do_global_dtors_aux>:
     410:	b510      	push	{r4, lr}
     412:	4c05      	ldr	r4, [pc, #20]	; (428 <__do_global_dtors_aux+0x18>)
     414:	7823      	ldrb	r3, [r4, #0]
     416:	b933      	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
     418:	4b04      	ldr	r3, [pc, #16]	; (42c <__do_global_dtors_aux+0x1c>)
     41a:	b113      	cbz	r3, 422 <__do_global_dtors_aux+0x12>
     41c:	4804      	ldr	r0, [pc, #16]	; (430 <__do_global_dtors_aux+0x20>)
     41e:	f3af 8000 	nop.w
     422:	2301      	movs	r3, #1
     424:	7023      	strb	r3, [r4, #0]
     426:	bd10      	pop	{r4, pc}
     428:	1fff1420 	.word	0x1fff1420
     42c:	00000000 	.word	0x00000000
     430:	00009728 	.word	0x00009728

00000434 <frame_dummy>:
     434:	4b08      	ldr	r3, [pc, #32]	; (458 <frame_dummy+0x24>)
     436:	b510      	push	{r4, lr}
     438:	b11b      	cbz	r3, 442 <frame_dummy+0xe>
     43a:	4908      	ldr	r1, [pc, #32]	; (45c <frame_dummy+0x28>)
     43c:	4808      	ldr	r0, [pc, #32]	; (460 <frame_dummy+0x2c>)
     43e:	f3af 8000 	nop.w
     442:	4808      	ldr	r0, [pc, #32]	; (464 <frame_dummy+0x30>)
     444:	6803      	ldr	r3, [r0, #0]
     446:	b903      	cbnz	r3, 44a <frame_dummy+0x16>
     448:	bd10      	pop	{r4, pc}
     44a:	4b07      	ldr	r3, [pc, #28]	; (468 <frame_dummy+0x34>)
     44c:	2b00      	cmp	r3, #0
     44e:	d0fb      	beq.n	448 <frame_dummy+0x14>
     450:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     454:	4718      	bx	r3
     456:	bf00      	nop
     458:	00000000 	.word	0x00000000
     45c:	1fff1424 	.word	0x1fff1424
     460:	00009728 	.word	0x00009728
     464:	1fff141c 	.word	0x1fff141c
     468:	00000000 	.word	0x00000000

0000046c <std_msgs::Time::serialize(unsigned char*) const>:
    l += 7;
    message_out[l++] = 255 - (chk % 256);

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
     46c:	6843      	ldr	r3, [r0, #4]
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
     46e:	700b      	strb	r3, [r1, #0]
     470:	6843      	ldr	r3, [r0, #4]
     472:	0a1b      	lsrs	r3, r3, #8
     474:	704b      	strb	r3, [r1, #1]
  imu_gyro.z = gyro_Z;
  IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
  imu_mag.y = my;
  imu_mag.z = mz;
     476:	88c3      	ldrh	r3, [r0, #6]
  imu_gyro.x = gyro_X;
  imu_gyro.y = gyro_Y;
  imu_gyro.z = gyro_Z;
  IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
     478:	708b      	strb	r3, [r1, #2]
     47a:	79c3      	ldrb	r3, [r0, #7]
  imu_mag.y = my;
  imu_mag.z = mz;
     47c:	70cb      	strb	r3, [r1, #3]
     47e:	6883      	ldr	r3, [r0, #8]
     480:	710b      	strb	r3, [r1, #4]
  imu_gyro.y = gyro_Y;
  imu_gyro.z = gyro_Z;
  IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
  imu_mag.y = my;
     482:	6883      	ldr	r3, [r0, #8]
     484:	0a1b      	lsrs	r3, r3, #8
  imu_gyro.x = gyro_X;
  imu_gyro.y = gyro_Y;
  imu_gyro.z = gyro_Z;
  IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
     486:	714b      	strb	r3, [r1, #5]
     488:	8943      	ldrh	r3, [r0, #10]
     48a:	718b      	strb	r3, [r1, #6]
  imu_mag.y = my;
     48c:	7ac3      	ldrb	r3, [r0, #11]
     48e:	71cb      	strb	r3, [r1, #7]
  imu_gyro.x = gyro_X;
  imu_gyro.y = gyro_Y;
  imu_gyro.z = gyro_Z;
  IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
     490:	2008      	movs	r0, #8
     492:	4770      	bx	lr

00000494 <std_msgs::Time::deserialize(unsigned char*)>:
  imu_mag.y = my;
  imu_mag.z = mz;
     494:	780b      	ldrb	r3, [r1, #0]
     496:	6043      	str	r3, [r0, #4]
    msg_(msg),
    endpoint_(endpoint) {};

  int publish(const Msg * msg)
  {
    return nh_->publish(id_, msg);
     498:	784a      	ldrb	r2, [r1, #1]
  imu_gyro.x = gyro_X;
  imu_gyro.y = gyro_Y;
  imu_gyro.z = gyro_Z;
  IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
     49a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  imu_mag.y = my;
     49e:	6043      	str	r3, [r0, #4]
     4a0:	788a      	ldrb	r2, [r1, #2]
     4a2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  imu_gyro.x = gyro_X;
  imu_gyro.y = gyro_Y;
  imu_gyro.z = gyro_Z;
  IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
     4a6:	6043      	str	r3, [r0, #4]
  imu_mag.y = my;
  imu_mag.z = mz;
     4a8:	78ca      	ldrb	r2, [r1, #3]
     4aa:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  imu_gyro.y = gyro_Y;
  imu_gyro.z = gyro_Z;
  IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
  imu_mag.y = my;
     4ae:	6043      	str	r3, [r0, #4]
     4b0:	790b      	ldrb	r3, [r1, #4]
  imu_mag.z = mz;
     4b2:	6083      	str	r3, [r0, #8]
     4b4:	794a      	ldrb	r2, [r1, #5]
  imu_gyro.y = gyro_Y;
  imu_gyro.z = gyro_Z;
  IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
  imu_mag.y = my;
     4b6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
     4ba:	6083      	str	r3, [r0, #8]
     4bc:	798a      	ldrb	r2, [r1, #6]
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
     4be:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
     4c2:	6083      	str	r3, [r0, #8]
     4c4:	79ca      	ldrb	r2, [r1, #7]
     4c6:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
     4ca:	6083      	str	r3, [r0, #8]
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
     4cc:	2008      	movs	r0, #8
     4ce:	4770      	bx	lr

000004d0 <std_msgs::Time::getType()>:

    int16_t exp = ((val >> 23) & 255);
     4d0:	4800      	ldr	r0, [pc, #0]	; (4d4 <std_msgs::Time::getType()+0x4>)
     4d2:	4770      	bx	lr
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
     4d4:	00009090 	.word	0x00009090

000004d8 <std_msgs::Time::getMD5()>:
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
     4d8:	4800      	ldr	r0, [pc, #0]	; (4dc <std_msgs::Time::getMD5()+0x4>)

    if (exp == 255)
     4da:	4770      	bx	lr
     4dc:	000090a0 	.word	0x000090a0

000004e0 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)>:
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
     4e0:	b5f0      	push	{r4, r5, r6, r7, lr}
     4e2:	460c      	mov	r4, r1
    {
      exp += 1023 - 127; // Normal case
     4e4:	780a      	ldrb	r2, [r1, #0]
     4e6:	8082      	strh	r2, [r0, #4]
     4e8:	4606      	mov	r6, r0
     4ea:	f814 0f01 	ldrb.w	r0, [r4, #1]!
     4ee:	2300      	movs	r3, #0
     4f0:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
     4f4:	80b2      	strh	r2, [r6, #4]
     4f6:	461a      	mov	r2, r3
     4f8:	f814 0f01 	ldrb.w	r0, [r4, #1]!
     4fc:	4098      	lsls	r0, r3
     4fe:	3308      	adds	r3, #8
     500:	2b20      	cmp	r3, #32
     502:	ea42 0200 	orr.w	r2, r2, r0
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
     506:	d1f7      	bne.n	4f8 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x18>
     508:	1d97      	adds	r7, r2, #6
     50a:	2f06      	cmp	r7, #6
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
     50c:	d958      	bls.n	5c0 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0xe0>
     50e:	f101 0e05 	add.w	lr, r1, #5
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
     512:	1d55      	adds	r5, r2, #5
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     514:	4673      	mov	r3, lr
     516:	194c      	adds	r4, r1, r5
     518:	f813 0f01 	ldrb.w	r0, [r3, #1]!
     51c:	f803 0c01 	strb.w	r0, [r3, #-1]
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
     520:	42a3      	cmp	r3, r4
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     522:	d1f9      	bne.n	518 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x38>
     524:	2300      	movs	r3, #0
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
     526:	554b      	strb	r3, [r1, r5]
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
     528:	4618      	mov	r0, r3
     52a:	440d      	add	r5, r1
    *(outbuffer++) = (mantissa >> 3) & 0xff;
     52c:	f8c6 e008 	str.w	lr, [r6, #8]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
     530:	f815 4f01 	ldrb.w	r4, [r5, #1]!
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     534:	4084      	lsls	r4, r0
     536:	3008      	adds	r0, #8
    *(outbuffer++) = 0;
     538:	2820      	cmp	r0, #32
     53a:	ea43 0304 	orr.w	r3, r3, r4
    *(outbuffer++) = 0;
     53e:	d1f7      	bne.n	530 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x50>
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
     540:	1d38      	adds	r0, r7, #4
     542:	4403      	add	r3, r0

    if (exp == 255)
     544:	4283      	cmp	r3, r0
     546:	d909      	bls.n	55c <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x7c>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
     548:	3209      	adds	r2, #9
     54a:	440a      	add	r2, r1
     54c:	4604      	mov	r4, r0
    {
      exp += 1023 - 127; // Normal case
     54e:	3401      	adds	r4, #1
     550:	f812 5f01 	ldrb.w	r5, [r2, #1]!
     554:	f802 5c01 	strb.w	r5, [r2, #-1]
     558:	42a3      	cmp	r3, r4
     55a:	d8f8      	bhi.n	54e <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x6e>
     55c:	3801      	subs	r0, #1
     55e:	18cf      	adds	r7, r1, r3
     560:	2400      	movs	r4, #0
     562:	4408      	add	r0, r1
     564:	f807 4c01 	strb.w	r4, [r7, #-1]
     568:	4622      	mov	r2, r4
     56a:	60f0      	str	r0, [r6, #12]
     56c:	f817 5b01 	ldrb.w	r5, [r7], #1
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
     570:	4095      	lsls	r5, r2
     572:	3208      	adds	r2, #8
     574:	2a20      	cmp	r2, #32
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
     576:	ea44 0405 	orr.w	r4, r4, r5
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
     57a:	d1f7      	bne.n	56c <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x8c>
     57c:	1d18      	adds	r0, r3, #4
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     57e:	4404      	add	r4, r0
     580:	42a0      	cmp	r0, r4
     582:	d209      	bcs.n	598 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0xb8>
     584:	3303      	adds	r3, #3
     586:	440b      	add	r3, r1
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
     588:	4602      	mov	r2, r0
     58a:	3201      	adds	r2, #1
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     58c:	f813 5f01 	ldrb.w	r5, [r3, #1]!
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
     590:	f803 5c01 	strb.w	r5, [r3, #-1]
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
     594:	42a2      	cmp	r2, r4
    *(outbuffer++) = (mantissa >> 3) & 0xff;
     596:	d3f8      	bcc.n	58a <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0xaa>
     598:	190d      	adds	r5, r1, r4
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
     59a:	3801      	subs	r0, #1
     59c:	4408      	add	r0, r1
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     59e:	2300      	movs	r3, #0
     5a0:	f805 3c01 	strb.w	r3, [r5, #-1]
    *(outbuffer++) = 0;
     5a4:	6130      	str	r0, [r6, #16]
    *(outbuffer++) = 0;
     5a6:	78a8      	ldrb	r0, [r5, #2]
     5a8:	786b      	ldrb	r3, [r5, #1]
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
     5aa:	5d0a      	ldrb	r2, [r1, r4]
     5ac:	78ed      	ldrb	r5, [r5, #3]

    if (exp == 255)
     5ae:	0401      	lsls	r1, r0, #16
     5b0:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
     5b4:	4313      	orrs	r3, r2
     5b6:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
    {
      exp += 1023 - 127; // Normal case
     5ba:	1d20      	adds	r0, r4, #4
     5bc:	6173      	str	r3, [r6, #20]
     5be:	bdf0      	pop	{r4, r5, r6, r7, pc}
     5c0:	1d55      	adds	r5, r2, #5
     5c2:	f101 0e05 	add.w	lr, r1, #5
     5c6:	e7ad      	b.n	524 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x44>

000005c8 <rosserial_msgs::TopicInfo::getType()>:
     5c8:	4800      	ldr	r0, [pc, #0]	; (5cc <rosserial_msgs::TopicInfo::getType()+0x4>)
     5ca:	4770      	bx	lr
     5cc:	000090c4 	.word	0x000090c4

000005d0 <rosserial_msgs::TopicInfo::getMD5()>:
     5d0:	4800      	ldr	r0, [pc, #0]	; (5d4 <rosserial_msgs::TopicInfo::getMD5()+0x4>)
     5d2:	4770      	bx	lr
     5d4:	000090e0 	.word	0x000090e0

000005d8 <rosserial_msgs::Log::deserialize(unsigned char*)>:
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
     5d8:	780b      	ldrb	r3, [r1, #0]
     5da:	b4f0      	push	{r4, r5, r6, r7}
     5dc:	7103      	strb	r3, [r0, #4]
     5de:	2300      	movs	r3, #0
    {
      *(outbuffer - 1) |= 0x80;
     5e0:	4606      	mov	r6, r0
     5e2:	460c      	mov	r4, r1
     5e4:	461d      	mov	r5, r3
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
     5e6:	f814 2f01 	ldrb.w	r2, [r4, #1]!
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
     5ea:	409a      	lsls	r2, r3
     5ec:	3308      	adds	r3, #8

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
     5ee:	2b20      	cmp	r3, #32
    message_out[1] = PROTOCOL_VER;
     5f0:	ea45 0502 	orr.w	r5, r5, r2
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     5f4:	d1f7      	bne.n	5e6 <rosserial_msgs::Log::deserialize(unsigned char*)+0xe>
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
     5f6:	1d68      	adds	r0, r5, #5
     5f8:	2805      	cmp	r0, #5
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     5fa:	f101 0704 	add.w	r7, r1, #4
    message_out[2] = (uint8_t)((uint16_t)l & 255);
     5fe:	d908      	bls.n	612 <rosserial_msgs::Log::deserialize(unsigned char*)+0x3a>
     600:	1d2c      	adds	r4, r5, #4
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
     602:	463b      	mov	r3, r7

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
     604:	440c      	add	r4, r1
     606:	f813 2f01 	ldrb.w	r2, [r3, #1]!
    message_out[1] = PROTOCOL_VER;
     60a:	f803 2c01 	strb.w	r2, [r3, #-1]
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
     60e:	429c      	cmp	r4, r3
    message_out[6] = (uint8_t)((int16_t)id >> 8);
     610:	d1f9      	bne.n	606 <rosserial_msgs::Log::deserialize(unsigned char*)+0x2e>
     612:	440d      	add	r5, r1
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
     614:	2300      	movs	r3, #0
     616:	712b      	strb	r3, [r5, #4]
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
     618:	60b7      	str	r7, [r6, #8]
     61a:	bcf0      	pop	{r4, r5, r6, r7}

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
     61c:	4770      	bx	lr
     61e:	bf00      	nop

00000620 <rosserial_msgs::Log::getType()>:
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     620:	4800      	ldr	r0, [pc, #0]	; (624 <rosserial_msgs::Log::getType()+0x4>)
     622:	4770      	bx	lr
    *(outbuffer++) = 0;
     624:	00009104 	.word	0x00009104

00000628 <rosserial_msgs::Log::getMD5()>:
    *(outbuffer++) = 0;
     628:	4800      	ldr	r0, [pc, #0]	; (62c <rosserial_msgs::Log::getMD5()+0x4>)
     62a:	4770      	bx	lr
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
     62c:	00009118 	.word	0x00009118

00000630 <rosserial_msgs::RequestParamResponse::getType()>:
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
     630:	4800      	ldr	r0, [pc, #0]	; (634 <rosserial_msgs::RequestParamResponse::getType()+0x4>)
     632:	4770      	bx	lr
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
     634:	000093e4 	.word	0x000093e4

00000638 <rosserial_msgs::RequestParamResponse::getMD5()>:
     638:	4800      	ldr	r0, [pc, #0]	; (63c <rosserial_msgs::RequestParamResponse::getMD5()+0x4>)
     63a:	4770      	bx	lr
     63c:	0000913c 	.word	0x0000913c

00000640 <std_msgs::Int16::serialize(unsigned char*) const>:
     640:	f9b0 3004 	ldrsh.w	r3, [r0, #4]
     644:	700b      	strb	r3, [r1, #0]
     646:	f3c3 2207 	ubfx	r2, r3, #8, #8
     64a:	704a      	strb	r2, [r1, #1]
     64c:	2002      	movs	r0, #2
     64e:	4770      	bx	lr

00000650 <std_msgs::Int16::deserialize(unsigned char*)>:
     650:	784a      	ldrb	r2, [r1, #1]
     652:	780b      	ldrb	r3, [r1, #0]
     654:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
     658:	8083      	strh	r3, [r0, #4]
     65a:	2002      	movs	r0, #2
     65c:	4770      	bx	lr
     65e:	bf00      	nop

00000660 <std_msgs::Int16::getType()>:
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
     660:	4800      	ldr	r0, [pc, #0]	; (664 <std_msgs::Int16::getType()+0x4>)
      chk += message_out[i];
     662:	4770      	bx	lr
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
     664:	00009160 	.word	0x00009160

00000668 <std_msgs::Int16::getMD5()>:
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
     668:	4800      	ldr	r0, [pc, #0]	; (66c <std_msgs::Int16::getMD5()+0x4>)
     66a:	4770      	bx	lr
     66c:	00009170 	.word	0x00009170

00000670 <std_msgs::Float32::serialize(unsigned char*) const>:
      iostream->begin(baud_);
    }

    int read(){return iostream->read();};
    void write(uint8_t* data, int length){
      iostream->write(data, length);
     670:	6843      	ldr	r3, [r0, #4]
     672:	700b      	strb	r3, [r1, #0]
     674:	b410      	push	{r4}

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
     676:	0c18      	lsrs	r0, r3, #16
     678:	0a1c      	lsrs	r4, r3, #8
     67a:	0e1a      	lsrs	r2, r3, #24
     67c:	704c      	strb	r4, [r1, #1]
     67e:	7088      	strb	r0, [r1, #2]
     680:	70ca      	strb	r2, [r1, #3]
     682:	2004      	movs	r0, #4
     684:	f85d 4b04 	ldr.w	r4, [sp], #4
     688:	4770      	bx	lr
     68a:	bf00      	nop

0000068c <std_msgs::Float32::deserialize(unsigned char*)>:
  imu_mag.z = mz;
  IMU_data_mag.publish(&imu_mag);
  measured_angle = atan2(my - mag_y_cal, mx - mag_x_cal) * 180 / pi;
     68c:	b410      	push	{r4}
     68e:	784c      	ldrb	r4, [r1, #1]
     690:	780a      	ldrb	r2, [r1, #0]
     692:	788b      	ldrb	r3, [r1, #2]
     694:	78c9      	ldrb	r1, [r1, #3]
     696:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
     69a:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
     69e:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
     6a2:	6043      	str	r3, [r0, #4]
     6a4:	f85d 4b04 	ldr.w	r4, [sp], #4
     6a8:	2004      	movs	r0, #4
     6aa:	4770      	bx	lr

000006ac <std_msgs::Float32::getType()>:
     6ac:	4800      	ldr	r0, [pc, #0]	; (6b0 <std_msgs::Float32::getType()+0x4>)
     6ae:	4770      	bx	lr
     6b0:	00009194 	.word	0x00009194

000006b4 <std_msgs::Float32::getMD5()>:
     6b4:	4800      	ldr	r0, [pc, #0]	; (6b8 <std_msgs::Float32::getMD5()+0x4>)
     6b6:	4770      	bx	lr
     6b8:	000091a8 	.word	0x000091a8

000006bc <geometry_msgs::Vector3::getType()>:
     6bc:	4800      	ldr	r0, [pc, #0]	; (6c0 <geometry_msgs::Vector3::getType()+0x4>)
     6be:	4770      	bx	lr
     6c0:	000091cc 	.word	0x000091cc

000006c4 <geometry_msgs::Vector3::getMD5()>:
     6c4:	4800      	ldr	r0, [pc, #0]	; (6c8 <geometry_msgs::Vector3::getMD5()+0x4>)
     6c6:	4770      	bx	lr
     6c8:	000091e4 	.word	0x000091e4

000006cc <geometry_msgs::Quaternion::getType()>:
     6cc:	4800      	ldr	r0, [pc, #0]	; (6d0 <geometry_msgs::Quaternion::getType()+0x4>)
     6ce:	4770      	bx	lr
     6d0:	00009208 	.word	0x00009208

000006d4 <geometry_msgs::Quaternion::getMD5()>:
  data_measured_angle.x = mx;
     6d4:	4800      	ldr	r0, [pc, #0]	; (6d8 <geometry_msgs::Quaternion::getMD5()+0x4>)
  data_measured_angle.y = reference_angle;
     6d6:	4770      	bx	lr
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
  imu_mag.y = my;
  imu_mag.z = mz;
  IMU_data_mag.publish(&imu_mag);
  measured_angle = atan2(my - mag_y_cal, mx - mag_x_cal) * 180 / pi;
     6d8:	00009224 	.word	0x00009224

000006dc <geometry_msgs::Twist::getType()>:
     6dc:	4800      	ldr	r0, [pc, #0]	; (6e0 <geometry_msgs::Twist::getType()+0x4>)
  data_measured_angle.x = mx;
  data_measured_angle.y = reference_angle;
     6de:	4770      	bx	lr
     6e0:	00009248 	.word	0x00009248

000006e4 <geometry_msgs::Twist::getMD5()>:
     6e4:	4800      	ldr	r0, [pc, #0]	; (6e8 <geometry_msgs::Twist::getMD5()+0x4>)
     6e6:	4770      	bx	lr
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
  imu_mag.y = my;
  imu_mag.z = mz;
  IMU_data_mag.publish(&imu_mag);
  measured_angle = atan2(my - mag_y_cal, mx - mag_x_cal) * 180 / pi;
     6e8:	0000925c 	.word	0x0000925c

000006ec <ros::Subscriber<std_msgs::Int16, void>::callback(unsigned char*)>:
  data_measured_angle.x = mx;
     6ec:	b410      	push	{r4}
     6ee:	780b      	ldrb	r3, [r1, #0]
     6f0:	784c      	ldrb	r4, [r1, #1]
     6f2:	6942      	ldr	r2, [r0, #20]
     6f4:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
  data_measured_angle.y = reference_angle;
     6f8:	8203      	strh	r3, [r0, #16]
     6fa:	f85d 4b04 	ldr.w	r4, [sp], #4
  data_measured_angle.z = measured_angle;
     6fe:	300c      	adds	r0, #12
  imu_mag.x = mx;
  imu_mag.y = my;
  imu_mag.z = mz;
  IMU_data_mag.publish(&imu_mag);
  measured_angle = atan2(my - mag_y_cal, mx - mag_x_cal) * 180 / pi;
  data_measured_angle.x = mx;
     700:	4710      	bx	r2
     702:	bf00      	nop

00000704 <ros::Subscriber<std_msgs::Int16, void>::getEndpointType()>:
     704:	6980      	ldr	r0, [r0, #24]
     706:	4770      	bx	lr

00000708 <ros::Subscriber<std_msgs::Int16, void>::getMsgType()>:
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
     708:	4800      	ldr	r0, [pc, #0]	; (70c <ros::Subscriber<std_msgs::Int16, void>::getMsgType()+0x4>)
     70a:	4770      	bx	lr
     70c:	00009160 	.word	0x00009160

00000710 <ros::Subscriber<std_msgs::Int16, void>::getMsgMD5()>:
     710:	4800      	ldr	r0, [pc, #0]	; (714 <ros::Subscriber<std_msgs::Int16, void>::getMsgMD5()+0x4>)
     712:	4770      	bx	lr
     714:	00009170 	.word	0x00009170

00000718 <ros::Subscriber<geometry_msgs::Twist, void>::getEndpointType()>:
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
     718:	6b40      	ldr	r0, [r0, #52]	; 0x34

    int16_t exp = ((val >> 23) & 255);
     71a:	4770      	bx	lr

0000071c <ros::Subscriber<geometry_msgs::Twist, void>::getMsgType()>:
     71c:	4800      	ldr	r0, [pc, #0]	; (720 <ros::Subscriber<geometry_msgs::Twist, void>::getMsgType()+0x4>)
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
     71e:	4770      	bx	lr
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
     720:	00009248 	.word	0x00009248

00000724 <ros::Subscriber<geometry_msgs::Twist, void>::getMsgMD5()>:

    if (exp == 255)
     724:	4800      	ldr	r0, [pc, #0]	; (728 <ros::Subscriber<geometry_msgs::Twist, void>::getMsgMD5()+0x4>)
     726:	4770      	bx	lr
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
     728:	0000925c 	.word	0x0000925c

0000072c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::connected()>:
     72c:	f890 04f8 	ldrb.w	r0, [r0, #1272]	; 0x4f8
    {
      exp += 1023 - 127; // Normal case
     730:	4770      	bx	lr
     732:	bf00      	nop

00000734 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const>:
     734:	6843      	ldr	r3, [r0, #4]
     736:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     73a:	700b      	strb	r3, [r1, #0]
     73c:	6843      	ldr	r3, [r0, #4]
     73e:	0a1b      	lsrs	r3, r3, #8
     740:	704b      	strb	r3, [r1, #1]
     742:	88c3      	ldrh	r3, [r0, #6]
     744:	708b      	strb	r3, [r1, #2]
     746:	79c3      	ldrb	r3, [r0, #7]
     748:	70cb      	strb	r3, [r1, #3]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
     74a:	6843      	ldr	r3, [r0, #4]
     74c:	2b00      	cmp	r3, #0
     74e:	f000 8085 	beq.w	85c <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0x128>
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
     752:	460a      	mov	r2, r1
     754:	2500      	movs	r5, #0
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
     756:	2604      	movs	r6, #4
     758:	68c3      	ldr	r3, [r0, #12]
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     75a:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
     75e:	7113      	strb	r3, [r2, #4]
     760:	0c1c      	lsrs	r4, r3, #16
     762:	0a1f      	lsrs	r7, r3, #8
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
     764:	0e1b      	lsrs	r3, r3, #24
     766:	7194      	strb	r4, [r2, #6]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     768:	7157      	strb	r7, [r2, #5]
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
     76a:	71d3      	strb	r3, [r2, #7]
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
     76c:	6843      	ldr	r3, [r0, #4]
     76e:	3501      	adds	r5, #1
    *(outbuffer++) = (mantissa >> 3) & 0xff;
     770:	42ab      	cmp	r3, r5
     772:	4634      	mov	r4, r6
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
     774:	f102 0204 	add.w	r2, r2, #4
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     778:	f106 0604 	add.w	r6, r6, #4
    *(outbuffer++) = 0;
     77c:	d8ec      	bhi.n	758 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0x24>
     77e:	f104 0208 	add.w	r2, r4, #8
    *(outbuffer++) = 0;
     782:	f104 0a05 	add.w	sl, r4, #5
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
     786:	f104 0906 	add.w	r9, r4, #6

    if (exp == 255)
     78a:	f104 0807 	add.w	r8, r4, #7
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
     78e:	f104 0c09 	add.w	ip, r4, #9
    {
      exp += 1023 - 127; // Normal case
     792:	f104 0e0a 	add.w	lr, r4, #10
     796:	f104 050b 	add.w	r5, r4, #11
     79a:	4617      	mov	r7, r2
     79c:	340c      	adds	r4, #12
     79e:	6903      	ldr	r3, [r0, #16]
     7a0:	558b      	strb	r3, [r1, r6]
     7a2:	6903      	ldr	r3, [r0, #16]
     7a4:	0a1b      	lsrs	r3, r3, #8
     7a6:	f801 300a 	strb.w	r3, [r1, sl]
     7aa:	8a43      	ldrh	r3, [r0, #18]
     7ac:	f801 3009 	strb.w	r3, [r1, r9]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
     7b0:	7cc3      	ldrb	r3, [r0, #19]
     7b2:	f801 3008 	strb.w	r3, [r1, r8]
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
     7b6:	6903      	ldr	r3, [r0, #16]
     7b8:	b1f3      	cbz	r3, 7f8 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0xc4>
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
     7ba:	eb01 0e07 	add.w	lr, r1, r7
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     7be:	4675      	mov	r5, lr
     7c0:	2200      	movs	r2, #0
     7c2:	6983      	ldr	r3, [r0, #24]
     7c4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
     7c8:	f80e 3022 	strb.w	r3, [lr, r2, lsl #2]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     7cc:	0c1c      	lsrs	r4, r3, #16
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
     7ce:	0a1e      	lsrs	r6, r3, #8
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
     7d0:	0e1b      	lsrs	r3, r3, #24
     7d2:	70ac      	strb	r4, [r5, #2]
    *(outbuffer++) = (mantissa >> 3) & 0xff;
     7d4:	706e      	strb	r6, [r5, #1]
     7d6:	70eb      	strb	r3, [r5, #3]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
     7d8:	6903      	ldr	r3, [r0, #16]
     7da:	3201      	adds	r2, #1
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     7dc:	4293      	cmp	r3, r2
     7de:	463c      	mov	r4, r7
    *(outbuffer++) = 0;
     7e0:	f105 0504 	add.w	r5, r5, #4
    *(outbuffer++) = 0;
     7e4:	f107 0704 	add.w	r7, r7, #4
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
     7e8:	d8eb      	bhi.n	7c2 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0x8e>
     7ea:	f104 0c05 	add.w	ip, r4, #5

    if (exp == 255)
     7ee:	f104 0e06 	add.w	lr, r4, #6
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
     7f2:	1de5      	adds	r5, r4, #7
    {
      exp += 1023 - 127; // Normal case
     7f4:	463a      	mov	r2, r7
     7f6:	3408      	adds	r4, #8
     7f8:	69c3      	ldr	r3, [r0, #28]
     7fa:	548b      	strb	r3, [r1, r2]
     7fc:	69c3      	ldr	r3, [r0, #28]
     7fe:	0a1b      	lsrs	r3, r3, #8
     800:	f801 300c 	strb.w	r3, [r1, ip]
     804:	8bc3      	ldrh	r3, [r0, #30]
     806:	f801 300e 	strb.w	r3, [r1, lr]
     80a:	7fc3      	ldrb	r3, [r0, #31]
     80c:	554b      	strb	r3, [r1, r5]
     80e:	69c3      	ldr	r3, [r0, #28]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
     810:	b30b      	cbz	r3, 856 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0x122>
     812:	460f      	mov	r7, r1
     814:	4680      	mov	r8, r0
     816:	2600      	movs	r6, #0
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     818:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     81c:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
     820:	f008 f98e 	bl	8b40 <strlen>
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
     824:	00b1      	lsls	r1, r6, #2
    *(outbuffer++) = (mantissa >> 3) & 0xff;
     826:	4605      	mov	r5, r0
     828:	193a      	adds	r2, r7, r4
    *(outbuffer++) = (mantissa >> 11) & 0xff;
     82a:	2300      	movs	r3, #0
     82c:	fa25 f003 	lsr.w	r0, r5, r3
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
     830:	3308      	adds	r3, #8
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
     832:	2b20      	cmp	r3, #32
    message_out[5] = (uint8_t)((int16_t)id & 255);
     834:	f802 0b01 	strb.w	r0, [r2], #1
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     838:	d1f8      	bne.n	82c <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0xf8>
    message_out[6] = (uint8_t)((int16_t)id >> 8);
     83a:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
    *(outbuffer++) = 0;
     83e:	3404      	adds	r4, #4
     840:	1938      	adds	r0, r7, r4
    *(outbuffer++) = 0;
     842:	5859      	ldr	r1, [r3, r1]
     844:	462a      	mov	r2, r5
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     846:	f004 feb5 	bl	55b4 <memcpy>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
     84a:	f8d8 301c 	ldr.w	r3, [r8, #28]
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
     84e:	3601      	adds	r6, #1
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
     850:	42b3      	cmp	r3, r6
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
     852:	442c      	add	r4, r5
     854:	d8e0      	bhi.n	818 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0xe4>
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
     856:	4620      	mov	r0, r4
     858:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
     85c:	2208      	movs	r2, #8
    message_out[1] = PROTOCOL_VER;
     85e:	4617      	mov	r7, r2
     860:	240c      	movs	r4, #12
    message_out[2] = (uint8_t)((uint16_t)l & 255);
     862:	250b      	movs	r5, #11
     864:	f04f 0e0a 	mov.w	lr, #10
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
     868:	f04f 0c09 	mov.w	ip, #9
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
     86c:	f04f 0807 	mov.w	r8, #7
     870:	f04f 0906 	mov.w	r9, #6
     874:	f04f 0a05 	mov.w	sl, #5
     878:	2604      	movs	r6, #4
     87a:	e790      	b.n	79e <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0x6a>

0000087c <rosserial_msgs::Log::serialize(unsigned char*) const>:
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
     87c:	b570      	push	{r4, r5, r6, lr}
      chk += message_out[i];
     87e:	7903      	ldrb	r3, [r0, #4]
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
     880:	700b      	strb	r3, [r1, #0]
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
     882:	4606      	mov	r6, r0
     884:	6880      	ldr	r0, [r0, #8]
     886:	460d      	mov	r5, r1
     888:	f008 f95a 	bl	8b40 <strlen>
     88c:	462a      	mov	r2, r5
     88e:	4604      	mov	r4, r0
     890:	2300      	movs	r3, #0

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
     892:	fa24 f103 	lsr.w	r1, r4, r3
     896:	3308      	adds	r3, #8
     898:	2b20      	cmp	r3, #32
     89a:	f802 1f01 	strb.w	r1, [r2, #1]!
  data_measured_angle.y = reference_angle;
  data_measured_angle.z = measured_angle;
  measured_angle_pub.publish(&data_measured_angle);

}
     89e:	d1f8      	bne.n	892 <rosserial_msgs::Log::serialize(unsigned char*) const+0x16>
     8a0:	68b1      	ldr	r1, [r6, #8]
     8a2:	1d68      	adds	r0, r5, #5
     8a4:	4622      	mov	r2, r4
     8a6:	f004 fe85 	bl	55b4 <memcpy>
     8aa:	1d60      	adds	r0, r4, #5
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     8ac:	bd70      	pop	{r4, r5, r6, pc}
     8ae:	bf00      	nop

000008b0 <rosserial_msgs::TopicInfo::serialize(unsigned char*) const>:
     8b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
     8b2:	8883      	ldrh	r3, [r0, #4]
      while (!(mantissa & 0x800000))
     8b4:	700b      	strb	r3, [r1, #0]
     8b6:	8883      	ldrh	r3, [r0, #4]
     8b8:	0a1b      	lsrs	r3, r3, #8
     8ba:	704b      	strb	r3, [r1, #1]
     8bc:	4606      	mov	r6, r0
     8be:	6880      	ldr	r0, [r0, #8]
     8c0:	460d      	mov	r5, r1
      {
          mantissa <<= 1;
     8c2:	f008 f93d 	bl	8b40 <strlen>
     8c6:	0e03      	lsrs	r3, r0, #24
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     8c8:	0a01      	lsrs	r1, r0, #8
     8ca:	0c02      	lsrs	r2, r0, #16
     8cc:	716b      	strb	r3, [r5, #5]
     8ce:	70a8      	strb	r0, [r5, #2]
     8d0:	712a      	strb	r2, [r5, #4]
     8d2:	70e9      	strb	r1, [r5, #3]
     8d4:	4602      	mov	r2, r0
     8d6:	4604      	mov	r4, r0
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     8d8:	68b1      	ldr	r1, [r6, #8]
     8da:	1da8      	adds	r0, r5, #6
     8dc:	f004 fe6a 	bl	55b4 <memcpy>
     8e0:	68f0      	ldr	r0, [r6, #12]
     8e2:	f008 f92d 	bl	8b40 <strlen>
     8e6:	1d61      	adds	r1, r4, #5
     8e8:	4602      	mov	r2, r0
     8ea:	4429      	add	r1, r5
     8ec:	3406      	adds	r4, #6
     8ee:	2300      	movs	r3, #0
     8f0:	fa22 f003 	lsr.w	r0, r2, r3
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     8f4:	3308      	adds	r3, #8
     8f6:	2b20      	cmp	r3, #32
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
     8f8:	f801 0f01 	strb.w	r0, [r1, #1]!
      while (!(mantissa & 0x800000))
     8fc:	d1f8      	bne.n	8f0 <rosserial_msgs::TopicInfo::serialize(unsigned char*) const+0x40>
     8fe:	3404      	adds	r4, #4
     900:	1928      	adds	r0, r5, r4
     902:	68f1      	ldr	r1, [r6, #12]
     904:	4414      	add	r4, r2
      {
          mantissa <<= 1;
     906:	f004 fe55 	bl	55b4 <memcpy>
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     90a:	6930      	ldr	r0, [r6, #16]
     90c:	f008 f918 	bl	8b40 <strlen>
     910:	192a      	adds	r2, r5, r4
     912:	4607      	mov	r7, r0
     914:	2300      	movs	r3, #0
     916:	fa27 f103 	lsr.w	r1, r7, r3
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     91a:	3308      	adds	r3, #8
     91c:	2b20      	cmp	r3, #32
     91e:	f802 1b01 	strb.w	r1, [r2], #1
     922:	d1f8      	bne.n	916 <rosserial_msgs::TopicInfo::serialize(unsigned char*) const+0x66>
     924:	3404      	adds	r4, #4
     926:	1928      	adds	r0, r5, r4
     928:	463a      	mov	r2, r7
     92a:	6931      	ldr	r1, [r6, #16]
     92c:	f004 fe42 	bl	55b4 <memcpy>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     930:	1938      	adds	r0, r7, r4
     932:	6973      	ldr	r3, [r6, #20]
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
     934:	542b      	strb	r3, [r5, r0]
      while (!(mantissa & 0x800000))
     936:	4405      	add	r5, r0
     938:	0a19      	lsrs	r1, r3, #8
     93a:	0c1a      	lsrs	r2, r3, #16
     93c:	0e1b      	lsrs	r3, r3, #24
     93e:	7069      	strb	r1, [r5, #1]
     940:	70aa      	strb	r2, [r5, #2]
     942:	70eb      	strb	r3, [r5, #3]
      {
          mantissa <<= 1;
     944:	3004      	adds	r0, #4
     946:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00000948 <usb_serial_class::write(unsigned char const*, unsigned int)>:
     948:	4608      	mov	r0, r1
     94a:	4611      	mov	r1, r2
     94c:	f006 b94a 	b.w	6be4 <usb_serial_write>

00000950 <usb_serial_class::read()>:
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
     950:	f006 b8e2 	b.w	6b18 <usb_serial_getchar>

00000954 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)>:
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     954:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     958:	780a      	ldrb	r2, [r1, #0]
     95a:	784b      	ldrb	r3, [r1, #1]
     95c:	788c      	ldrb	r4, [r1, #2]
     95e:	4605      	mov	r5, r0
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     960:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
     964:	78c8      	ldrb	r0, [r1, #3]
     966:	460e      	mov	r6, r1
     968:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
     96c:	6869      	ldr	r1, [r5, #4]
     96e:	ea43 6400 	orr.w	r4, r3, r0, lsl #24
     972:	428c      	cmp	r4, r1
     974:	b083      	sub	sp, #12
     976:	f200 80ba 	bhi.w	aee <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x19a>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     97a:	606c      	str	r4, [r5, #4]
     97c:	2c00      	cmp	r4, #0
     97e:	f000 80bf 	beq.w	b00 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x1ac>
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     982:	f105 0908 	add.w	r9, r5, #8
     986:	4634      	mov	r4, r6
     988:	2700      	movs	r7, #0
     98a:	f04f 0804 	mov.w	r8, #4
     98e:	79a1      	ldrb	r1, [r4, #6]
      {
          mantissa <<= 1;
     990:	7963      	ldrb	r3, [r4, #5]
     992:	7922      	ldrb	r2, [r4, #4]
     994:	f894 e007 	ldrb.w	lr, [r4, #7]
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     998:	68e8      	ldr	r0, [r5, #12]
     99a:	0409      	lsls	r1, r1, #16
     99c:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
     9a0:	4313      	orrs	r3, r2
     9a2:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     9a6:	60ab      	str	r3, [r5, #8]
     9a8:	eb00 0087 	add.w	r0, r0, r7, lsl #2
     9ac:	2204      	movs	r2, #4
     9ae:	4649      	mov	r1, r9
     9b0:	f004 fe00 	bl	55b4 <memcpy>
     9b4:	686b      	ldr	r3, [r5, #4]
     9b6:	3701      	adds	r7, #1
     9b8:	42bb      	cmp	r3, r7
     9ba:	4642      	mov	r2, r8
     9bc:	f104 0404 	add.w	r4, r4, #4
     9c0:	f108 0804 	add.w	r8, r8, #4
     9c4:	d8e3      	bhi.n	98e <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x3a>
     9c6:	f102 0708 	add.w	r7, r2, #8
     9ca:	4641      	mov	r1, r8
     9cc:	46b9      	mov	r9, r7
     9ce:	f102 0e05 	add.w	lr, r2, #5
     9d2:	1d90      	adds	r0, r2, #6
     9d4:	1dd3      	adds	r3, r2, #7
     9d6:	f102 0b09 	add.w	fp, r2, #9
     9da:	f102 080a 	add.w	r8, r2, #10
     9de:	f102 0a0b 	add.w	sl, r2, #11
     9e2:	f102 040c 	add.w	r4, r2, #12
     9e6:	5c30      	ldrb	r0, [r6, r0]
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     9e8:	f816 200e 	ldrb.w	r2, [r6, lr]
     9ec:	5c71      	ldrb	r1, [r6, r1]
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
     9ee:	f816 e003 	ldrb.w	lr, [r6, r3]
      while (!(mantissa & 0x800000))
     9f2:	692b      	ldr	r3, [r5, #16]
     9f4:	0400      	lsls	r0, r0, #16
     9f6:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
     9fa:	430a      	orrs	r2, r1
     9fc:	ea42 620e 	orr.w	r2, r2, lr, lsl #24
      {
          mantissa <<= 1;
     a00:	429a      	cmp	r2, r3
     a02:	f200 8092 	bhi.w	b2a <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x1d6>
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     a06:	612a      	str	r2, [r5, #16]
     a08:	b34a      	cbz	r2, a5e <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x10a>
     a0a:	f105 0a14 	add.w	sl, r5, #20
     a0e:	eb06 0709 	add.w	r7, r6, r9
     a12:	f04f 0800 	mov.w	r8, #0
     a16:	78b9      	ldrb	r1, [r7, #2]
     a18:	787b      	ldrb	r3, [r7, #1]
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     a1a:	783a      	ldrb	r2, [r7, #0]
     a1c:	78fc      	ldrb	r4, [r7, #3]
     a1e:	69a8      	ldr	r0, [r5, #24]
     a20:	0409      	lsls	r1, r1, #16
     a22:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
     a26:	4313      	orrs	r3, r2
     a28:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
     a2c:	616b      	str	r3, [r5, #20]
     a2e:	eb00 0088 	add.w	r0, r0, r8, lsl #2
     a32:	2204      	movs	r2, #4
     a34:	4651      	mov	r1, sl
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     a36:	f004 fdbd 	bl	55b4 <memcpy>
     a3a:	692b      	ldr	r3, [r5, #16]
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
     a3c:	f108 0801 	add.w	r8, r8, #1
      while (!(mantissa & 0x800000))
     a40:	4543      	cmp	r3, r8
     a42:	464c      	mov	r4, r9
     a44:	f107 0704 	add.w	r7, r7, #4
     a48:	f109 0904 	add.w	r9, r9, #4
      {
          mantissa <<= 1;
     a4c:	d8e3      	bhi.n	a16 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0xc2>
     a4e:	f104 0b05 	add.w	fp, r4, #5
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     a52:	f104 0806 	add.w	r8, r4, #6
     a56:	f104 0a07 	add.w	sl, r4, #7
     a5a:	464f      	mov	r7, r9
     a5c:	3408      	adds	r4, #8
     a5e:	f816 2008 	ldrb.w	r2, [r6, r8]
     a62:	f816 000b 	ldrb.w	r0, [r6, fp]
     a66:	5df3      	ldrb	r3, [r6, r7]
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     a68:	f816 700a 	ldrb.w	r7, [r6, sl]
     a6c:	69e9      	ldr	r1, [r5, #28]
     a6e:	0412      	lsls	r2, r2, #16
     a70:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
     a74:	4313      	orrs	r3, r2
     a76:	ea43 6707 	orr.w	r7, r3, r7, lsl #24
     a7a:	428f      	cmp	r7, r1
     a7c:	d84f      	bhi.n	b1e <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x1ca>
     a7e:	61ef      	str	r7, [r5, #28]
     a80:	b38f      	cbz	r7, ae6 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x192>
     a82:	f04f 0900 	mov.w	r9, #0
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     a86:	46c8      	mov	r8, r9
     a88:	f105 0720 	add.w	r7, r5, #32
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     a8c:	2300      	movs	r3, #0
     a8e:	469e      	mov	lr, r3
     a90:	1931      	adds	r1, r6, r4
     a92:	f811 2b01 	ldrb.w	r2, [r1], #1
     a96:	409a      	lsls	r2, r3
     a98:	3308      	adds	r3, #8
      {
          mantissa <<= 1;
     a9a:	2b20      	cmp	r3, #32
     a9c:	ea4e 0e02 	orr.w	lr, lr, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     aa0:	d1f7      	bne.n	a92 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x13e>
     aa2:	1d20      	adds	r0, r4, #4
     aa4:	4486      	add	lr, r0
     aa6:	4570      	cmp	r0, lr
     aa8:	d209      	bcs.n	abe <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x16a>
     aaa:	1ce3      	adds	r3, r4, #3
     aac:	4433      	add	r3, r6
     aae:	4602      	mov	r2, r0
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     ab0:	3201      	adds	r2, #1
     ab2:	f813 1f01 	ldrb.w	r1, [r3, #1]!
     ab6:	f803 1c01 	strb.w	r1, [r3, #-1]
     aba:	4572      	cmp	r2, lr
     abc:	d3f8      	bcc.n	ab0 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x15c>
     abe:	eb06 020e 	add.w	r2, r6, lr
     ac2:	1e43      	subs	r3, r0, #1
     ac4:	f802 8c01 	strb.w	r8, [r2, #-1]
     ac8:	6a68      	ldr	r0, [r5, #36]	; 0x24
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     aca:	4433      	add	r3, r6
     acc:	622b      	str	r3, [r5, #32]
     ace:	eb00 0089 	add.w	r0, r0, r9, lsl #2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     ad2:	2204      	movs	r2, #4
     ad4:	4639      	mov	r1, r7
     ad6:	4674      	mov	r4, lr
     ad8:	f004 fd6c 	bl	55b4 <memcpy>
     adc:	69eb      	ldr	r3, [r5, #28]
     ade:	f109 0901 	add.w	r9, r9, #1
      {
          mantissa <<= 1;
     ae2:	454b      	cmp	r3, r9
     ae4:	d8d2      	bhi.n	a8c <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x138>
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     ae6:	4620      	mov	r0, r4
     ae8:	b003      	add	sp, #12
     aea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     aee:	00a1      	lsls	r1, r4, #2
     af0:	68e8      	ldr	r0, [r5, #12]
     af2:	f007 fc3d 	bl	8370 <realloc>
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     af6:	606c      	str	r4, [r5, #4]
     af8:	60e8      	str	r0, [r5, #12]
     afa:	2c00      	cmp	r4, #0
     afc:	f47f af41 	bne.w	982 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x2e>
     b00:	2708      	movs	r7, #8
     b02:	46b9      	mov	r9, r7
     b04:	240c      	movs	r4, #12
     b06:	f04f 0a0b 	mov.w	sl, #11
     b0a:	f04f 080a 	mov.w	r8, #10
     b0e:	f04f 0b09 	mov.w	fp, #9
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     b12:	2307      	movs	r3, #7
     b14:	2006      	movs	r0, #6
     b16:	f04f 0e05 	mov.w	lr, #5
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     b1a:	2104      	movs	r1, #4
     b1c:	e763      	b.n	9e6 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x92>
     b1e:	00b9      	lsls	r1, r7, #2
     b20:	6a68      	ldr	r0, [r5, #36]	; 0x24
     b22:	f007 fc25 	bl	8370 <realloc>
     b26:	6268      	str	r0, [r5, #36]	; 0x24
      {
          mantissa <<= 1;
     b28:	e7a9      	b.n	a7e <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x12a>
     b2a:	0091      	lsls	r1, r2, #2
     b2c:	69a8      	ldr	r0, [r5, #24]
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     b2e:	9201      	str	r2, [sp, #4]
     b30:	f007 fc1e 	bl	8370 <realloc>
     b34:	9a01      	ldr	r2, [sp, #4]
     b36:	61a8      	str	r0, [r5, #24]
     b38:	e765      	b.n	a06 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0xb2>
     b3a:	bf00      	nop

00000b3c <geometry_msgs::Twist::serialize(unsigned char*) const>:
     b3c:	edd0 7a02 	vldr	s15, [r0, #8]
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     b40:	ee17 3a90 	vmov	r3, s15
     b44:	f3c3 52c7 	ubfx	r2, r3, #23, #8
     b48:	2aff      	cmp	r2, #255	; 0xff
     b4a:	b4f0      	push	{r4, r5, r6, r7}
     b4c:	f3c3 0316 	ubfx	r3, r3, #0, #23
     b50:	f000 81fd 	beq.w	f4e <geometry_msgs::Twist::serialize(unsigned char*) const+0x412>
     b54:	2a00      	cmp	r2, #0
     b56:	f000 8112 	beq.w	d7e <geometry_msgs::Twist::serialize(unsigned char*) const+0x242>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     b5a:	f502 7260 	add.w	r2, r2, #896	; 0x380
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
     b5e:	0cdc      	lsrs	r4, r3, #19
      while (!(mantissa & 0x800000))
     b60:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
     b64:	015e      	lsls	r6, r3, #5
     b66:	f3c3 07c7 	ubfx	r7, r3, #3, #8
     b6a:	b2e4      	uxtb	r4, r4
     b6c:	f3c2 1207 	ubfx	r2, r2, #4, #8
      {
          mantissa <<= 1;
     b70:	b2f6      	uxtb	r6, r6
     b72:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     b76:	eef5 7ac0 	vcmpe.f32	s15, #0.0
     b7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     b7e:	f04f 0500 	mov.w	r5, #0
     b82:	bf48      	it	mi
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     b84:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
     b88:	714b      	strb	r3, [r1, #5]
     b8a:	71ca      	strb	r2, [r1, #7]
     b8c:	70ce      	strb	r6, [r1, #3]
     b8e:	710f      	strb	r7, [r1, #4]
     b90:	718c      	strb	r4, [r1, #6]
     b92:	700d      	strb	r5, [r1, #0]
     b94:	704d      	strb	r5, [r1, #1]
     b96:	708d      	strb	r5, [r1, #2]
     b98:	edd0 7a03 	vldr	s15, [r0, #12]
     b9c:	ee17 3a90 	vmov	r3, s15
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     ba0:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
     ba4:	2aff      	cmp	r2, #255	; 0xff
      while (!(mantissa & 0x800000))
     ba6:	f3c3 0316 	ubfx	r3, r3, #0, #23
     baa:	f000 81c5 	beq.w	f38 <geometry_msgs::Twist::serialize(unsigned char*) const+0x3fc>
     bae:	2a00      	cmp	r2, #0
     bb0:	f000 8103 	beq.w	dba <geometry_msgs::Twist::serialize(unsigned char*) const+0x27e>
      {
          mantissa <<= 1;
     bb4:	f502 7260 	add.w	r2, r2, #896	; 0x380
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     bb8:	0cdc      	lsrs	r4, r3, #19
     bba:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
     bbe:	015e      	lsls	r6, r3, #5
     bc0:	f3c3 07c7 	ubfx	r7, r3, #3, #8
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     bc4:	b2e4      	uxtb	r4, r4
     bc6:	f3c2 1207 	ubfx	r2, r2, #4, #8
     bca:	b2f6      	uxtb	r6, r6
     bcc:	f3c3 23c7 	ubfx	r3, r3, #11, #8
     bd0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
     bd4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     bd8:	f04f 0500 	mov.w	r5, #0
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     bdc:	bf48      	it	mi
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
     bde:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
      while (!(mantissa & 0x800000))
     be2:	734b      	strb	r3, [r1, #13]
     be4:	73ca      	strb	r2, [r1, #15]
     be6:	72ce      	strb	r6, [r1, #11]
     be8:	730f      	strb	r7, [r1, #12]
     bea:	738c      	strb	r4, [r1, #14]
      {
          mantissa <<= 1;
     bec:	720d      	strb	r5, [r1, #8]
     bee:	724d      	strb	r5, [r1, #9]
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     bf0:	728d      	strb	r5, [r1, #10]
     bf2:	edd0 7a04 	vldr	s15, [r0, #16]
     bf6:	ee17 3a90 	vmov	r3, s15
     bfa:	f3c3 52c7 	ubfx	r2, r3, #23, #8
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     bfe:	2aff      	cmp	r2, #255	; 0xff
     c00:	f3c3 0316 	ubfx	r3, r3, #0, #23
     c04:	f000 8177 	beq.w	ef6 <geometry_msgs::Twist::serialize(unsigned char*) const+0x3ba>
     c08:	2a00      	cmp	r2, #0
     c0a:	f000 814d 	beq.w	ea8 <geometry_msgs::Twist::serialize(unsigned char*) const+0x36c>
     c0e:	f502 7260 	add.w	r2, r2, #896	; 0x380
     c12:	0cdc      	lsrs	r4, r3, #19
     c14:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
     c18:	015e      	lsls	r6, r3, #5
     c1a:	f3c3 07c7 	ubfx	r7, r3, #3, #8
     c1e:	b2e4      	uxtb	r4, r4
     c20:	f3c2 1207 	ubfx	r2, r2, #4, #8
     c24:	b2f6      	uxtb	r6, r6
     c26:	f3c3 23c7 	ubfx	r3, r3, #11, #8
     c2a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
     c2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     c32:	f04f 0500 	mov.w	r5, #0
     c36:	bf48      	it	mi
     c38:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
     c3c:	754b      	strb	r3, [r1, #21]
     c3e:	75ca      	strb	r2, [r1, #23]
     c40:	74ce      	strb	r6, [r1, #19]
     c42:	750f      	strb	r7, [r1, #20]
     c44:	758c      	strb	r4, [r1, #22]
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
     c46:	740d      	strb	r5, [r1, #16]
     c48:	744d      	strb	r5, [r1, #17]
     c4a:	748d      	strb	r5, [r1, #18]
     c4c:	edd0 7a06 	vldr	s15, [r0, #24]
     c50:	ee17 3a90 	vmov	r3, s15
     c54:	f3c3 52c7 	ubfx	r2, r3, #23, #8
     c58:	2aff      	cmp	r2, #255	; 0xff
     c5a:	f3c3 0316 	ubfx	r3, r3, #0, #23
     c5e:	f000 813f 	beq.w	ee0 <geometry_msgs::Twist::serialize(unsigned char*) const+0x3a4>
     c62:	2a00      	cmp	r2, #0
     c64:	f000 8103 	beq.w	e6e <geometry_msgs::Twist::serialize(unsigned char*) const+0x332>
     c68:	f502 7260 	add.w	r2, r2, #896	; 0x380
     c6c:	0cdc      	lsrs	r4, r3, #19
     c6e:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
     c72:	015e      	lsls	r6, r3, #5
     c74:	f3c3 07c7 	ubfx	r7, r3, #3, #8
     c78:	b2e4      	uxtb	r4, r4
     c7a:	f3c2 1207 	ubfx	r2, r2, #4, #8
     c7e:	b2f6      	uxtb	r6, r6
     c80:	f3c3 23c7 	ubfx	r3, r3, #11, #8
     c84:	eef5 7ac0 	vcmpe.f32	s15, #0.0
     c88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     c8c:	f04f 0500 	mov.w	r5, #0
     c90:	bf48      	it	mi
     c92:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
     c96:	774b      	strb	r3, [r1, #29]
     c98:	77ca      	strb	r2, [r1, #31]
     c9a:	76ce      	strb	r6, [r1, #27]
     c9c:	770f      	strb	r7, [r1, #28]
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     c9e:	778c      	strb	r4, [r1, #30]
     ca0:	760d      	strb	r5, [r1, #24]
     ca2:	764d      	strb	r5, [r1, #25]
     ca4:	768d      	strb	r5, [r1, #26]
     ca6:	edd0 7a07 	vldr	s15, [r0, #28]
     caa:	ee17 3a90 	vmov	r3, s15
     cae:	f3c3 52c7 	ubfx	r2, r3, #23, #8
     cb2:	2aff      	cmp	r2, #255	; 0xff
     cb4:	f3c3 0316 	ubfx	r3, r3, #0, #23
     cb8:	f000 8133 	beq.w	f22 <geometry_msgs::Twist::serialize(unsigned char*) const+0x3e6>
     cbc:	2a00      	cmp	r2, #0
     cbe:	f000 80b8 	beq.w	e32 <geometry_msgs::Twist::serialize(unsigned char*) const+0x2f6>
     cc2:	f502 7260 	add.w	r2, r2, #896	; 0x380
     cc6:	0cdc      	lsrs	r4, r3, #19
     cc8:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
     ccc:	015e      	lsls	r6, r3, #5
     cce:	f3c3 07c7 	ubfx	r7, r3, #3, #8
     cd2:	b2e4      	uxtb	r4, r4
     cd4:	f3c2 1207 	ubfx	r2, r2, #4, #8
     cd8:	b2f6      	uxtb	r6, r6
     cda:	f3c3 23c7 	ubfx	r3, r3, #11, #8
     cde:	eef5 7ac0 	vcmpe.f32	s15, #0.0
     ce2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     ce6:	f04f 0500 	mov.w	r5, #0
     cea:	bf48      	it	mi
     cec:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
     cf0:	f881 3025 	strb.w	r3, [r1, #37]	; 0x25
     cf4:	f881 2027 	strb.w	r2, [r1, #39]	; 0x27
     cf8:	f881 6023 	strb.w	r6, [r1, #35]	; 0x23
     cfc:	f881 7024 	strb.w	r7, [r1, #36]	; 0x24
     d00:	f881 4026 	strb.w	r4, [r1, #38]	; 0x26
     d04:	f881 5020 	strb.w	r5, [r1, #32]
     d08:	f881 5021 	strb.w	r5, [r1, #33]	; 0x21
     d0c:	f881 5022 	strb.w	r5, [r1, #34]	; 0x22
     d10:	edd0 7a08 	vldr	s15, [r0, #32]
     d14:	ee17 3a90 	vmov	r3, s15
     d18:	f3c3 52c7 	ubfx	r2, r3, #23, #8
     d1c:	2aff      	cmp	r2, #255	; 0xff
     d1e:	f3c3 0316 	ubfx	r3, r3, #0, #23
     d22:	f000 80f3 	beq.w	f0c <geometry_msgs::Twist::serialize(unsigned char*) const+0x3d0>
     d26:	2a00      	cmp	r2, #0
     d28:	d065      	beq.n	df6 <geometry_msgs::Twist::serialize(unsigned char*) const+0x2ba>
     d2a:	f502 7260 	add.w	r2, r2, #896	; 0x380
     d2e:	0cd8      	lsrs	r0, r3, #19
     d30:	ea40 1002 	orr.w	r0, r0, r2, lsl #4
     d34:	015d      	lsls	r5, r3, #5
     d36:	f3c3 06c7 	ubfx	r6, r3, #3, #8
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
     d3a:	b2c0      	uxtb	r0, r0
     d3c:	f3c2 1207 	ubfx	r2, r2, #4, #8
     d40:	b2ed      	uxtb	r5, r5
     d42:	f3c3 23c7 	ubfx	r3, r3, #11, #8
     d46:	eef5 7ac0 	vcmpe.f32	s15, #0.0
     d4a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     d4e:	f04f 0400 	mov.w	r4, #0
     d52:	bf48      	it	mi
     d54:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
     d58:	f881 502b 	strb.w	r5, [r1, #43]	; 0x2b
     d5c:	f881 602c 	strb.w	r6, [r1, #44]	; 0x2c
     d60:	f881 002e 	strb.w	r0, [r1, #46]	; 0x2e
     d64:	f881 4028 	strb.w	r4, [r1, #40]	; 0x28
     d68:	f881 4029 	strb.w	r4, [r1, #41]	; 0x29
     d6c:	f881 402a 	strb.w	r4, [r1, #42]	; 0x2a
     d70:	2030      	movs	r0, #48	; 0x30
     d72:	f881 302d 	strb.w	r3, [r1, #45]	; 0x2d
     d76:	f881 202f 	strb.w	r2, [r1, #47]	; 0x2f
     d7a:	bcf0      	pop	{r4, r5, r6, r7}
     d7c:	4770      	bx	lr
     d7e:	2b00      	cmp	r3, #0
     d80:	f000 8109 	beq.w	f96 <geometry_msgs::Twist::serialize(unsigned char*) const+0x45a>
     d84:	005b      	lsls	r3, r3, #1
     d86:	021c      	lsls	r4, r3, #8
     d88:	f100 810d 	bmi.w	fa6 <geometry_msgs::Twist::serialize(unsigned char*) const+0x46a>
     d8c:	f44f 7260 	mov.w	r2, #896	; 0x380
     d90:	3a01      	subs	r2, #1
     d92:	005b      	lsls	r3, r3, #1
     d94:	b294      	uxth	r4, r2
     d96:	021f      	lsls	r7, r3, #8
     d98:	b222      	sxth	r2, r4
     d9a:	d5f9      	bpl.n	d90 <geometry_msgs::Twist::serialize(unsigned char*) const+0x254>
     d9c:	0124      	lsls	r4, r4, #4
     d9e:	b2e4      	uxtb	r4, r4
     da0:	f3c2 1206 	ubfx	r2, r2, #4, #7
     da4:	f3c3 0316 	ubfx	r3, r3, #0, #23
     da8:	015e      	lsls	r6, r3, #5
     daa:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
     dae:	f3c3 07c7 	ubfx	r7, r3, #3, #8
     db2:	b2f6      	uxtb	r6, r6
     db4:	f3c3 23c7 	ubfx	r3, r3, #11, #8
     db8:	e6dd      	b.n	b76 <geometry_msgs::Twist::serialize(unsigned char*) const+0x3a>
     dba:	2b00      	cmp	r3, #0
     dbc:	f000 80e6 	beq.w	f8c <geometry_msgs::Twist::serialize(unsigned char*) const+0x450>
     dc0:	005b      	lsls	r3, r3, #1
     dc2:	021e      	lsls	r6, r3, #8
     dc4:	f100 80f2 	bmi.w	fac <geometry_msgs::Twist::serialize(unsigned char*) const+0x470>
     dc8:	f44f 7260 	mov.w	r2, #896	; 0x380
     dcc:	3a01      	subs	r2, #1
     dce:	005b      	lsls	r3, r3, #1
     dd0:	b294      	uxth	r4, r2
     dd2:	021d      	lsls	r5, r3, #8
     dd4:	b222      	sxth	r2, r4
     dd6:	d5f9      	bpl.n	dcc <geometry_msgs::Twist::serialize(unsigned char*) const+0x290>
     dd8:	0124      	lsls	r4, r4, #4
     dda:	b2e4      	uxtb	r4, r4
     ddc:	f3c2 1206 	ubfx	r2, r2, #4, #7
     de0:	f3c3 0316 	ubfx	r3, r3, #0, #23
     de4:	015e      	lsls	r6, r3, #5
     de6:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
     dea:	f3c3 07c7 	ubfx	r7, r3, #3, #8
     dee:	b2f6      	uxtb	r6, r6
     df0:	f3c3 23c7 	ubfx	r3, r3, #11, #8
     df4:	e6ec      	b.n	bd0 <geometry_msgs::Twist::serialize(unsigned char*) const+0x94>
     df6:	2b00      	cmp	r3, #0
     df8:	f000 80c3 	beq.w	f82 <geometry_msgs::Twist::serialize(unsigned char*) const+0x446>
     dfc:	005b      	lsls	r3, r3, #1
     dfe:	021d      	lsls	r5, r3, #8
     e00:	f100 80d7 	bmi.w	fb2 <geometry_msgs::Twist::serialize(unsigned char*) const+0x476>
     e04:	f44f 7260 	mov.w	r2, #896	; 0x380
     e08:	3a01      	subs	r2, #1
     e0a:	005b      	lsls	r3, r3, #1
     e0c:	b290      	uxth	r0, r2
     e0e:	021c      	lsls	r4, r3, #8
     e10:	b202      	sxth	r2, r0
     e12:	d5f9      	bpl.n	e08 <geometry_msgs::Twist::serialize(unsigned char*) const+0x2cc>
     e14:	0100      	lsls	r0, r0, #4
     e16:	b2c0      	uxtb	r0, r0
     e18:	f3c2 1206 	ubfx	r2, r2, #4, #7
     e1c:	f3c3 0316 	ubfx	r3, r3, #0, #23
     e20:	015d      	lsls	r5, r3, #5
     e22:	ea40 40d3 	orr.w	r0, r0, r3, lsr #19
     e26:	f3c3 06c7 	ubfx	r6, r3, #3, #8
     e2a:	b2ed      	uxtb	r5, r5
     e2c:	f3c3 23c7 	ubfx	r3, r3, #11, #8
     e30:	e789      	b.n	d46 <geometry_msgs::Twist::serialize(unsigned char*) const+0x20a>
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     e32:	2b00      	cmp	r3, #0
     e34:	f000 80a0 	beq.w	f78 <geometry_msgs::Twist::serialize(unsigned char*) const+0x43c>
     e38:	005b      	lsls	r3, r3, #1
     e3a:	021f      	lsls	r7, r3, #8
     e3c:	f100 80bc 	bmi.w	fb8 <geometry_msgs::Twist::serialize(unsigned char*) const+0x47c>
     e40:	f44f 7260 	mov.w	r2, #896	; 0x380
     e44:	3a01      	subs	r2, #1
     e46:	005b      	lsls	r3, r3, #1
     e48:	b294      	uxth	r4, r2
     e4a:	021e      	lsls	r6, r3, #8
     e4c:	b222      	sxth	r2, r4
     e4e:	d5f9      	bpl.n	e44 <geometry_msgs::Twist::serialize(unsigned char*) const+0x308>
     e50:	0124      	lsls	r4, r4, #4
     e52:	b2e4      	uxtb	r4, r4
     e54:	f3c2 1206 	ubfx	r2, r2, #4, #7
     e58:	f3c3 0316 	ubfx	r3, r3, #0, #23
     e5c:	015e      	lsls	r6, r3, #5
     e5e:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
     e62:	f3c3 07c7 	ubfx	r7, r3, #3, #8
     e66:	b2f6      	uxtb	r6, r6
     e68:	f3c3 23c7 	ubfx	r3, r3, #11, #8
     e6c:	e737      	b.n	cde <geometry_msgs::Twist::serialize(unsigned char*) const+0x1a2>
     e6e:	2b00      	cmp	r3, #0
     e70:	d07d      	beq.n	f6e <geometry_msgs::Twist::serialize(unsigned char*) const+0x432>
     e72:	005b      	lsls	r3, r3, #1
     e74:	021e      	lsls	r6, r3, #8
     e76:	f100 80a2 	bmi.w	fbe <geometry_msgs::Twist::serialize(unsigned char*) const+0x482>
     e7a:	f44f 7260 	mov.w	r2, #896	; 0x380
     e7e:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
     e80:	005b      	lsls	r3, r3, #1
     e82:	b294      	uxth	r4, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     e84:	021d      	lsls	r5, r3, #8
     e86:	b222      	sxth	r2, r4
     e88:	d5f9      	bpl.n	e7e <geometry_msgs::Twist::serialize(unsigned char*) const+0x342>
     e8a:	0124      	lsls	r4, r4, #4
     e8c:	b2e4      	uxtb	r4, r4
     e8e:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     e92:	f3c3 0316 	ubfx	r3, r3, #0, #23
     e96:	015e      	lsls	r6, r3, #5
     e98:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
     e9c:	f3c3 07c7 	ubfx	r7, r3, #3, #8
     ea0:	b2f6      	uxtb	r6, r6
     ea2:	f3c3 23c7 	ubfx	r3, r3, #11, #8
     ea6:	e6ed      	b.n	c84 <geometry_msgs::Twist::serialize(unsigned char*) const+0x148>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     ea8:	2b00      	cmp	r3, #0
     eaa:	d05b      	beq.n	f64 <geometry_msgs::Twist::serialize(unsigned char*) const+0x428>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
     eac:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
     eae:	021c      	lsls	r4, r3, #8
     eb0:	d476      	bmi.n	fa0 <geometry_msgs::Twist::serialize(unsigned char*) const+0x464>
     eb2:	f44f 7260 	mov.w	r2, #896	; 0x380
     eb6:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
     eb8:	005b      	lsls	r3, r3, #1
     eba:	b294      	uxth	r4, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     ebc:	021f      	lsls	r7, r3, #8
     ebe:	b222      	sxth	r2, r4
     ec0:	d5f9      	bpl.n	eb6 <geometry_msgs::Twist::serialize(unsigned char*) const+0x37a>
     ec2:	0124      	lsls	r4, r4, #4
     ec4:	b2e4      	uxtb	r4, r4
     ec6:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     eca:	f3c3 0316 	ubfx	r3, r3, #0, #23
     ece:	015e      	lsls	r6, r3, #5
     ed0:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
     ed4:	f3c3 07c7 	ubfx	r7, r3, #3, #8
     ed8:	b2f6      	uxtb	r6, r6
     eda:	f3c3 23c7 	ubfx	r3, r3, #11, #8
     ede:	e6a4      	b.n	c2a <geometry_msgs::Twist::serialize(unsigned char*) const+0xee>
     ee0:	015e      	lsls	r6, r3, #5
     ee2:	0cdc      	lsrs	r4, r3, #19
     ee4:	f3c3 07c7 	ubfx	r7, r3, #3, #8
     ee8:	b2f6      	uxtb	r6, r6
     eea:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
     eee:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
     ef2:	227f      	movs	r2, #127	; 0x7f
     ef4:	e6c6      	b.n	c84 <geometry_msgs::Twist::serialize(unsigned char*) const+0x148>
     ef6:	015e      	lsls	r6, r3, #5
     ef8:	0cdc      	lsrs	r4, r3, #19
     efa:	f3c3 07c7 	ubfx	r7, r3, #3, #8
     efe:	b2f6      	uxtb	r6, r6
     f00:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
     f04:	f3c3 23c7 	ubfx	r3, r3, #11, #8
     f08:	227f      	movs	r2, #127	; 0x7f
     f0a:	e68e      	b.n	c2a <geometry_msgs::Twist::serialize(unsigned char*) const+0xee>
     f0c:	015d      	lsls	r5, r3, #5
     f0e:	0cd8      	lsrs	r0, r3, #19
     f10:	f3c3 06c7 	ubfx	r6, r3, #3, #8
     f14:	b2ed      	uxtb	r5, r5
     f16:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
     f1a:	f3c3 23c7 	ubfx	r3, r3, #11, #8
     f1e:	227f      	movs	r2, #127	; 0x7f
     f20:	e711      	b.n	d46 <geometry_msgs::Twist::serialize(unsigned char*) const+0x20a>
     f22:	015e      	lsls	r6, r3, #5
     f24:	0cdc      	lsrs	r4, r3, #19
     f26:	f3c3 07c7 	ubfx	r7, r3, #3, #8
     f2a:	b2f6      	uxtb	r6, r6
     f2c:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
     f30:	f3c3 23c7 	ubfx	r3, r3, #11, #8
     f34:	227f      	movs	r2, #127	; 0x7f
     f36:	e6d2      	b.n	cde <geometry_msgs::Twist::serialize(unsigned char*) const+0x1a2>
     f38:	015e      	lsls	r6, r3, #5
     f3a:	0cdc      	lsrs	r4, r3, #19
     f3c:	f3c3 07c7 	ubfx	r7, r3, #3, #8
     f40:	b2f6      	uxtb	r6, r6
     f42:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
     f46:	f3c3 23c7 	ubfx	r3, r3, #11, #8
     f4a:	227f      	movs	r2, #127	; 0x7f
     f4c:	e640      	b.n	bd0 <geometry_msgs::Twist::serialize(unsigned char*) const+0x94>
     f4e:	015e      	lsls	r6, r3, #5
     f50:	0cdc      	lsrs	r4, r3, #19
     f52:	f3c3 07c7 	ubfx	r7, r3, #3, #8
     f56:	b2f6      	uxtb	r6, r6
     f58:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
     f5c:	f3c3 23c7 	ubfx	r3, r3, #11, #8
     f60:	227f      	movs	r2, #127	; 0x7f
     f62:	e608      	b.n	b76 <geometry_msgs::Twist::serialize(unsigned char*) const+0x3a>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     f64:	461a      	mov	r2, r3
     f66:	461c      	mov	r4, r3
     f68:	461f      	mov	r7, r3
     f6a:	461e      	mov	r6, r3
     f6c:	e65d      	b.n	c2a <geometry_msgs::Twist::serialize(unsigned char*) const+0xee>
     f6e:	461a      	mov	r2, r3
     f70:	461c      	mov	r4, r3
     f72:	461f      	mov	r7, r3
     f74:	461e      	mov	r6, r3
     f76:	e685      	b.n	c84 <geometry_msgs::Twist::serialize(unsigned char*) const+0x148>
     f78:	461a      	mov	r2, r3
     f7a:	461c      	mov	r4, r3
     f7c:	461f      	mov	r7, r3
     f7e:	461e      	mov	r6, r3
     f80:	e6ad      	b.n	cde <geometry_msgs::Twist::serialize(unsigned char*) const+0x1a2>
     f82:	461a      	mov	r2, r3
     f84:	4618      	mov	r0, r3
     f86:	461e      	mov	r6, r3
     f88:	461d      	mov	r5, r3
     f8a:	e6dc      	b.n	d46 <geometry_msgs::Twist::serialize(unsigned char*) const+0x20a>
     f8c:	461a      	mov	r2, r3
     f8e:	461c      	mov	r4, r3
     f90:	461f      	mov	r7, r3
     f92:	461e      	mov	r6, r3
     f94:	e61c      	b.n	bd0 <geometry_msgs::Twist::serialize(unsigned char*) const+0x94>
     f96:	461a      	mov	r2, r3
     f98:	461c      	mov	r4, r3
     f9a:	461f      	mov	r7, r3
     f9c:	461e      	mov	r6, r3
     f9e:	e5ea      	b.n	b76 <geometry_msgs::Twist::serialize(unsigned char*) const+0x3a>
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     fa0:	4614      	mov	r4, r2
     fa2:	2238      	movs	r2, #56	; 0x38
     fa4:	e791      	b.n	eca <geometry_msgs::Twist::serialize(unsigned char*) const+0x38e>
     fa6:	4614      	mov	r4, r2
     fa8:	2238      	movs	r2, #56	; 0x38
     faa:	e6fb      	b.n	da4 <geometry_msgs::Twist::serialize(unsigned char*) const+0x268>
     fac:	4614      	mov	r4, r2
     fae:	2238      	movs	r2, #56	; 0x38
     fb0:	e716      	b.n	de0 <geometry_msgs::Twist::serialize(unsigned char*) const+0x2a4>
     fb2:	4610      	mov	r0, r2
     fb4:	2238      	movs	r2, #56	; 0x38
     fb6:	e731      	b.n	e1c <geometry_msgs::Twist::serialize(unsigned char*) const+0x2e0>
     fb8:	4614      	mov	r4, r2
     fba:	2238      	movs	r2, #56	; 0x38
     fbc:	e74c      	b.n	e58 <geometry_msgs::Twist::serialize(unsigned char*) const+0x31c>
     fbe:	4614      	mov	r4, r2
     fc0:	2238      	movs	r2, #56	; 0x38
     fc2:	e766      	b.n	e92 <geometry_msgs::Twist::serialize(unsigned char*) const+0x356>

00000fc4 <geometry_msgs::Vector3::serialize(unsigned char*) const>:
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      offset += serializeAvrFloat64(outbuffer + offset, this->x);
     fc4:	edd0 7a01 	vldr	s15, [r0, #4]
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
     fc8:	ee17 3a90 	vmov	r3, s15

    int16_t exp = ((val >> 23) & 255);
     fcc:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
     fd0:	2aff      	cmp	r2, #255	; 0xff
      y(0),
      z(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
     fd2:	b4f0      	push	{r4, r5, r6, r7}
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
     fd4:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
     fd8:	f000 80e6 	beq.w	11a8 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x1e4>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
     fdc:	2a00      	cmp	r2, #0
     fde:	d078      	beq.n	10d2 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x10e>
    {
      exp += 1023 - 127; // Normal case
     fe0:	f502 7260 	add.w	r2, r2, #896	; 0x380
     fe4:	0cdc      	lsrs	r4, r3, #19
     fe6:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
     fea:	015e      	lsls	r6, r3, #5
     fec:	f3c3 07c7 	ubfx	r7, r3, #3, #8
     ff0:	b2e4      	uxtb	r4, r4
     ff2:	f3c2 1207 	ubfx	r2, r2, #4, #8
     ff6:	b2f6      	uxtb	r6, r6
     ff8:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
     ffc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    1000:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    1004:	f04f 0500 	mov.w	r5, #0
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    1008:	bf48      	it	mi
    100a:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    100e:	714b      	strb	r3, [r1, #5]
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    1010:	71ca      	strb	r2, [r1, #7]
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    1012:	70ce      	strb	r6, [r1, #3]
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    1014:	710f      	strb	r7, [r1, #4]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    1016:	718c      	strb	r4, [r1, #6]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    1018:	700d      	strb	r5, [r1, #0]
    *(outbuffer++) = 0;
    101a:	704d      	strb	r5, [r1, #1]
    *(outbuffer++) = 0;
    101c:	708d      	strb	r5, [r1, #2]
    {
      int offset = 0;
      offset += serializeAvrFloat64(outbuffer + offset, this->x);
      offset += serializeAvrFloat64(outbuffer + offset, this->y);
    101e:	edd0 7a02 	vldr	s15, [r0, #8]
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    1022:	ee17 3a90 	vmov	r3, s15

    int16_t exp = ((val >> 23) & 255);
    1026:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    102a:	2aff      	cmp	r2, #255	; 0xff
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    102c:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    1030:	f000 80af 	beq.w	1192 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x1ce>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    1034:	2a00      	cmp	r2, #0
    1036:	d069      	beq.n	110c <geometry_msgs::Vector3::serialize(unsigned char*) const+0x148>
    {
      exp += 1023 - 127; // Normal case
    1038:	f502 7260 	add.w	r2, r2, #896	; 0x380
    103c:	0cdc      	lsrs	r4, r3, #19
    103e:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
    1042:	015e      	lsls	r6, r3, #5
    1044:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    1048:	b2e4      	uxtb	r4, r4
    104a:	f3c2 1207 	ubfx	r2, r2, #4, #8
    104e:	b2f6      	uxtb	r6, r6
    1050:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    1054:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    1058:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    105c:	f04f 0500 	mov.w	r5, #0
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    1060:	bf48      	it	mi
    1062:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    1066:	734b      	strb	r3, [r1, #13]
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    1068:	73ca      	strb	r2, [r1, #15]
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    106a:	72ce      	strb	r6, [r1, #11]
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    106c:	730f      	strb	r7, [r1, #12]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    106e:	738c      	strb	r4, [r1, #14]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    1070:	720d      	strb	r5, [r1, #8]
    *(outbuffer++) = 0;
    1072:	724d      	strb	r5, [r1, #9]
    *(outbuffer++) = 0;
    1074:	728d      	strb	r5, [r1, #10]
      offset += serializeAvrFloat64(outbuffer + offset, this->z);
    1076:	edd0 7a03 	vldr	s15, [r0, #12]
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    107a:	ee17 3a90 	vmov	r3, s15

    int16_t exp = ((val >> 23) & 255);
    107e:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    1082:	2aff      	cmp	r2, #255	; 0xff
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    1084:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    1088:	d078      	beq.n	117c <geometry_msgs::Vector3::serialize(unsigned char*) const+0x1b8>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    108a:	2a00      	cmp	r2, #0
    108c:	d05a      	beq.n	1144 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x180>
    {
      exp += 1023 - 127; // Normal case
    108e:	f502 7260 	add.w	r2, r2, #896	; 0x380
    1092:	0cd8      	lsrs	r0, r3, #19
    1094:	ea40 1002 	orr.w	r0, r0, r2, lsl #4
    1098:	015d      	lsls	r5, r3, #5
    109a:	f3c3 06c7 	ubfx	r6, r3, #3, #8
    109e:	b2c0      	uxtb	r0, r0
    10a0:	f3c2 1207 	ubfx	r2, r2, #4, #8
    10a4:	b2ed      	uxtb	r5, r5
    10a6:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    10aa:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    10ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    10b2:	f04f 0400 	mov.w	r4, #0
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    10b6:	bf48      	it	mi
    10b8:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    10bc:	74cd      	strb	r5, [r1, #19]
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    10be:	750e      	strb	r6, [r1, #20]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    10c0:	7588      	strb	r0, [r1, #22]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    10c2:	740c      	strb	r4, [r1, #16]
    *(outbuffer++) = 0;
    10c4:	744c      	strb	r4, [r1, #17]
    *(outbuffer++) = 0;
    10c6:	748c      	strb	r4, [r1, #18]
      return offset;
    }
    10c8:	2018      	movs	r0, #24
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    10ca:	754b      	strb	r3, [r1, #21]
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    10cc:	75ca      	strb	r2, [r1, #23]
    10ce:	bcf0      	pop	{r4, r5, r6, r7}
    10d0:	4770      	bx	lr
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    10d2:	2b00      	cmp	r3, #0
    10d4:	d07d      	beq.n	11d2 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x20e>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    10d6:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    10d8:	021e      	lsls	r6, r3, #8
    10da:	f100 8082 	bmi.w	11e2 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x21e>
    10de:	f44f 7260 	mov.w	r2, #896	; 0x380
    10e2:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    10e4:	005b      	lsls	r3, r3, #1
    10e6:	b294      	uxth	r4, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    10e8:	021d      	lsls	r5, r3, #8
    10ea:	b222      	sxth	r2, r4
    10ec:	d5f9      	bpl.n	10e2 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x11e>
    10ee:	0124      	lsls	r4, r4, #4
    10f0:	b2e4      	uxtb	r4, r4
    10f2:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    10f6:	f3c3 0316 	ubfx	r3, r3, #0, #23
    10fa:	015e      	lsls	r6, r3, #5
    10fc:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
    1100:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    1104:	b2f6      	uxtb	r6, r6
    1106:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    110a:	e777      	b.n	ffc <geometry_msgs::Vector3::serialize(unsigned char*) const+0x38>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    110c:	2b00      	cmp	r3, #0
    110e:	d05b      	beq.n	11c8 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x204>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    1110:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    1112:	021f      	lsls	r7, r3, #8
    1114:	d468      	bmi.n	11e8 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x224>
    1116:	f44f 7260 	mov.w	r2, #896	; 0x380
    111a:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    111c:	005b      	lsls	r3, r3, #1
    111e:	b294      	uxth	r4, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    1120:	021e      	lsls	r6, r3, #8
    1122:	b222      	sxth	r2, r4
    1124:	d5f9      	bpl.n	111a <geometry_msgs::Vector3::serialize(unsigned char*) const+0x156>
    1126:	0124      	lsls	r4, r4, #4
    1128:	b2e4      	uxtb	r4, r4
    112a:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    112e:	f3c3 0316 	ubfx	r3, r3, #0, #23
    1132:	015e      	lsls	r6, r3, #5
    1134:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
    1138:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    113c:	b2f6      	uxtb	r6, r6
    113e:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    1142:	e787      	b.n	1054 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x90>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    1144:	2b00      	cmp	r3, #0
    1146:	d03a      	beq.n	11be <geometry_msgs::Vector3::serialize(unsigned char*) const+0x1fa>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    1148:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    114a:	021d      	lsls	r5, r3, #8
    114c:	d446      	bmi.n	11dc <geometry_msgs::Vector3::serialize(unsigned char*) const+0x218>
    114e:	f44f 7260 	mov.w	r2, #896	; 0x380
    1152:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    1154:	005b      	lsls	r3, r3, #1
    1156:	b290      	uxth	r0, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    1158:	021c      	lsls	r4, r3, #8
    115a:	b202      	sxth	r2, r0
    115c:	d5f9      	bpl.n	1152 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x18e>
    115e:	0100      	lsls	r0, r0, #4
    1160:	b2c0      	uxtb	r0, r0
    1162:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    1166:	f3c3 0316 	ubfx	r3, r3, #0, #23
    116a:	015d      	lsls	r5, r3, #5
    116c:	ea40 40d3 	orr.w	r0, r0, r3, lsr #19
    1170:	f3c3 06c7 	ubfx	r6, r3, #3, #8
    1174:	b2ed      	uxtb	r5, r5
    1176:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    117a:	e796      	b.n	10aa <geometry_msgs::Vector3::serialize(unsigned char*) const+0xe6>
    117c:	015d      	lsls	r5, r3, #5
    117e:	0cd8      	lsrs	r0, r3, #19
    1180:	f3c3 06c7 	ubfx	r6, r3, #3, #8
    1184:	b2ed      	uxtb	r5, r5
    1186:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
    118a:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    118e:	227f      	movs	r2, #127	; 0x7f
    1190:	e78b      	b.n	10aa <geometry_msgs::Vector3::serialize(unsigned char*) const+0xe6>
    1192:	015e      	lsls	r6, r3, #5
    1194:	0cdc      	lsrs	r4, r3, #19
    1196:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    119a:	b2f6      	uxtb	r6, r6
    119c:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    11a0:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    11a4:	227f      	movs	r2, #127	; 0x7f
    11a6:	e755      	b.n	1054 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x90>
    11a8:	015e      	lsls	r6, r3, #5
    11aa:	0cdc      	lsrs	r4, r3, #19
    11ac:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    11b0:	b2f6      	uxtb	r6, r6
    11b2:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    11b6:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    11ba:	227f      	movs	r2, #127	; 0x7f
    11bc:	e71e      	b.n	ffc <geometry_msgs::Vector3::serialize(unsigned char*) const+0x38>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    11be:	461a      	mov	r2, r3
    11c0:	4618      	mov	r0, r3
    11c2:	461e      	mov	r6, r3
    11c4:	461d      	mov	r5, r3
    11c6:	e770      	b.n	10aa <geometry_msgs::Vector3::serialize(unsigned char*) const+0xe6>
    11c8:	461a      	mov	r2, r3
    11ca:	461c      	mov	r4, r3
    11cc:	461f      	mov	r7, r3
    11ce:	461e      	mov	r6, r3
    11d0:	e740      	b.n	1054 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x90>
    11d2:	461a      	mov	r2, r3
    11d4:	461c      	mov	r4, r3
    11d6:	461f      	mov	r7, r3
    11d8:	461e      	mov	r6, r3
    11da:	e70f      	b.n	ffc <geometry_msgs::Vector3::serialize(unsigned char*) const+0x38>
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    11dc:	4610      	mov	r0, r2
    11de:	2238      	movs	r2, #56	; 0x38
    11e0:	e7c1      	b.n	1166 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x1a2>
    11e2:	4614      	mov	r4, r2
    11e4:	2238      	movs	r2, #56	; 0x38
    11e6:	e786      	b.n	10f6 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x132>
    11e8:	4614      	mov	r4, r2
    11ea:	2238      	movs	r2, #56	; 0x38
    11ec:	e79f      	b.n	112e <geometry_msgs::Vector3::serialize(unsigned char*) const+0x16a>
    11ee:	bf00      	nop

000011f0 <geometry_msgs::Quaternion::serialize(unsigned char*) const>:
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      offset += serializeAvrFloat64(outbuffer + offset, this->x);
    11f0:	edd0 7a01 	vldr	s15, [r0, #4]
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    11f4:	ee17 3a90 	vmov	r3, s15

    int16_t exp = ((val >> 23) & 255);
    11f8:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    11fc:	2aff      	cmp	r2, #255	; 0xff
      z(0),
      w(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
    11fe:	b4f0      	push	{r4, r5, r6, r7}
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    1200:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    1204:	f000 8140 	beq.w	1488 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x298>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    1208:	2a00      	cmp	r2, #0
    120a:	f000 80a8 	beq.w	135e <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x16e>
    {
      exp += 1023 - 127; // Normal case
    120e:	f502 7260 	add.w	r2, r2, #896	; 0x380
    1212:	0cdc      	lsrs	r4, r3, #19
    1214:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
    1218:	015e      	lsls	r6, r3, #5
    121a:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    121e:	b2e4      	uxtb	r4, r4
    1220:	f3c2 1207 	ubfx	r2, r2, #4, #8
    1224:	b2f6      	uxtb	r6, r6
    1226:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    122a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    122e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    1232:	f04f 0500 	mov.w	r5, #0
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    1236:	bf48      	it	mi
    1238:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    123c:	714b      	strb	r3, [r1, #5]
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    123e:	71ca      	strb	r2, [r1, #7]
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    1240:	70ce      	strb	r6, [r1, #3]
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    1242:	710f      	strb	r7, [r1, #4]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    1244:	718c      	strb	r4, [r1, #6]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    1246:	700d      	strb	r5, [r1, #0]
    *(outbuffer++) = 0;
    1248:	704d      	strb	r5, [r1, #1]
    *(outbuffer++) = 0;
    124a:	708d      	strb	r5, [r1, #2]
    {
      int offset = 0;
      offset += serializeAvrFloat64(outbuffer + offset, this->x);
      offset += serializeAvrFloat64(outbuffer + offset, this->y);
    124c:	edd0 7a02 	vldr	s15, [r0, #8]
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    1250:	ee17 3a90 	vmov	r3, s15

    int16_t exp = ((val >> 23) & 255);
    1254:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    1258:	2aff      	cmp	r2, #255	; 0xff
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    125a:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    125e:	f000 8108 	beq.w	1472 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x282>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    1262:	2a00      	cmp	r2, #0
    1264:	f000 8099 	beq.w	139a <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x1aa>
    {
      exp += 1023 - 127; // Normal case
    1268:	f502 7260 	add.w	r2, r2, #896	; 0x380
    126c:	0cdc      	lsrs	r4, r3, #19
    126e:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
    1272:	015e      	lsls	r6, r3, #5
    1274:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    1278:	b2e4      	uxtb	r4, r4
    127a:	f3c2 1207 	ubfx	r2, r2, #4, #8
    127e:	b2f6      	uxtb	r6, r6
    1280:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    1284:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    1288:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    128c:	f04f 0500 	mov.w	r5, #0
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    1290:	bf48      	it	mi
    1292:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    1296:	734b      	strb	r3, [r1, #13]
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    1298:	73ca      	strb	r2, [r1, #15]
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    129a:	72ce      	strb	r6, [r1, #11]
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    129c:	730f      	strb	r7, [r1, #12]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    129e:	738c      	strb	r4, [r1, #14]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    12a0:	720d      	strb	r5, [r1, #8]
    *(outbuffer++) = 0;
    12a2:	724d      	strb	r5, [r1, #9]
    *(outbuffer++) = 0;
    12a4:	728d      	strb	r5, [r1, #10]
      offset += serializeAvrFloat64(outbuffer + offset, this->z);
    12a6:	edd0 7a03 	vldr	s15, [r0, #12]
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    12aa:	ee17 3a90 	vmov	r3, s15

    int16_t exp = ((val >> 23) & 255);
    12ae:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    12b2:	2aff      	cmp	r2, #255	; 0xff
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    12b4:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    12b8:	f000 80d0 	beq.w	145c <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x26c>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    12bc:	2a00      	cmp	r2, #0
    12be:	f000 80a6 	beq.w	140e <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x21e>
    {
      exp += 1023 - 127; // Normal case
    12c2:	f502 7260 	add.w	r2, r2, #896	; 0x380
    12c6:	0cdc      	lsrs	r4, r3, #19
    12c8:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
    12cc:	015e      	lsls	r6, r3, #5
    12ce:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    12d2:	b2e4      	uxtb	r4, r4
    12d4:	f3c2 1207 	ubfx	r2, r2, #4, #8
    12d8:	b2f6      	uxtb	r6, r6
    12da:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    12de:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    12e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    12e6:	f04f 0500 	mov.w	r5, #0
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    12ea:	bf48      	it	mi
    12ec:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    12f0:	754b      	strb	r3, [r1, #21]
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    12f2:	75ca      	strb	r2, [r1, #23]
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    12f4:	74ce      	strb	r6, [r1, #19]
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    12f6:	750f      	strb	r7, [r1, #20]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    12f8:	758c      	strb	r4, [r1, #22]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    12fa:	740d      	strb	r5, [r1, #16]
    *(outbuffer++) = 0;
    12fc:	744d      	strb	r5, [r1, #17]
    *(outbuffer++) = 0;
    12fe:	748d      	strb	r5, [r1, #18]
      offset += serializeAvrFloat64(outbuffer + offset, this->w);
    1300:	edd0 7a04 	vldr	s15, [r0, #16]
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    1304:	ee17 3a90 	vmov	r3, s15

    int16_t exp = ((val >> 23) & 255);
    1308:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    130c:	2aff      	cmp	r2, #255	; 0xff
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    130e:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    1312:	f000 8098 	beq.w	1446 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x256>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    1316:	2a00      	cmp	r2, #0
    1318:	d05d      	beq.n	13d6 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x1e6>
    {
      exp += 1023 - 127; // Normal case
    131a:	f502 7260 	add.w	r2, r2, #896	; 0x380
    131e:	0cd8      	lsrs	r0, r3, #19
    1320:	ea40 1002 	orr.w	r0, r0, r2, lsl #4
    1324:	015d      	lsls	r5, r3, #5
    1326:	f3c3 06c7 	ubfx	r6, r3, #3, #8
    132a:	b2c0      	uxtb	r0, r0
    132c:	f3c2 1207 	ubfx	r2, r2, #4, #8
    1330:	b2ed      	uxtb	r5, r5
    1332:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    1336:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    133a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    133e:	f04f 0400 	mov.w	r4, #0
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    1342:	bf48      	it	mi
    1344:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    1348:	76cd      	strb	r5, [r1, #27]
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    134a:	770e      	strb	r6, [r1, #28]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    134c:	7788      	strb	r0, [r1, #30]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    134e:	760c      	strb	r4, [r1, #24]
    *(outbuffer++) = 0;
    1350:	764c      	strb	r4, [r1, #25]
    *(outbuffer++) = 0;
    1352:	768c      	strb	r4, [r1, #26]
      return offset;
    }
    1354:	2020      	movs	r0, #32
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    1356:	774b      	strb	r3, [r1, #29]
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    1358:	77ca      	strb	r2, [r1, #31]
    135a:	bcf0      	pop	{r4, r5, r6, r7}
    135c:	4770      	bx	lr
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    135e:	2b00      	cmp	r3, #0
    1360:	f000 80ac 	beq.w	14bc <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x2cc>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    1364:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    1366:	021c      	lsls	r4, r3, #8
    1368:	f100 80b0 	bmi.w	14cc <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x2dc>
    136c:	f44f 7260 	mov.w	r2, #896	; 0x380
    1370:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    1372:	005b      	lsls	r3, r3, #1
    1374:	b294      	uxth	r4, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    1376:	021f      	lsls	r7, r3, #8
    1378:	b222      	sxth	r2, r4
    137a:	d5f9      	bpl.n	1370 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x180>
    137c:	0124      	lsls	r4, r4, #4
    137e:	b2e4      	uxtb	r4, r4
    1380:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    1384:	f3c3 0316 	ubfx	r3, r3, #0, #23
    1388:	015e      	lsls	r6, r3, #5
    138a:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
    138e:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    1392:	b2f6      	uxtb	r6, r6
    1394:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    1398:	e747      	b.n	122a <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x3a>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    139a:	2b00      	cmp	r3, #0
    139c:	f000 8089 	beq.w	14b2 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x2c2>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    13a0:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    13a2:	021e      	lsls	r6, r3, #8
    13a4:	f100 8095 	bmi.w	14d2 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x2e2>
    13a8:	f44f 7260 	mov.w	r2, #896	; 0x380
    13ac:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    13ae:	005b      	lsls	r3, r3, #1
    13b0:	b294      	uxth	r4, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    13b2:	021d      	lsls	r5, r3, #8
    13b4:	b222      	sxth	r2, r4
    13b6:	d5f9      	bpl.n	13ac <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x1bc>
    13b8:	0124      	lsls	r4, r4, #4
    13ba:	b2e4      	uxtb	r4, r4
    13bc:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    13c0:	f3c3 0316 	ubfx	r3, r3, #0, #23
    13c4:	015e      	lsls	r6, r3, #5
    13c6:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
    13ca:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    13ce:	b2f6      	uxtb	r6, r6
    13d0:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    13d4:	e756      	b.n	1284 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x94>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    13d6:	2b00      	cmp	r3, #0
    13d8:	d066      	beq.n	14a8 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x2b8>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    13da:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    13dc:	021d      	lsls	r5, r3, #8
    13de:	d47b      	bmi.n	14d8 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x2e8>
    13e0:	f44f 7260 	mov.w	r2, #896	; 0x380
    13e4:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    13e6:	005b      	lsls	r3, r3, #1
    13e8:	b290      	uxth	r0, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    13ea:	021c      	lsls	r4, r3, #8
    13ec:	b202      	sxth	r2, r0
    13ee:	d5f9      	bpl.n	13e4 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x1f4>
    13f0:	0100      	lsls	r0, r0, #4
    13f2:	b2c0      	uxtb	r0, r0
    13f4:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    13f8:	f3c3 0316 	ubfx	r3, r3, #0, #23
    13fc:	015d      	lsls	r5, r3, #5
    13fe:	ea40 40d3 	orr.w	r0, r0, r3, lsr #19
    1402:	f3c3 06c7 	ubfx	r6, r3, #3, #8
    1406:	b2ed      	uxtb	r5, r5
    1408:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    140c:	e793      	b.n	1336 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x146>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    140e:	2b00      	cmp	r3, #0
    1410:	d045      	beq.n	149e <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x2ae>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    1412:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    1414:	021f      	lsls	r7, r3, #8
    1416:	d456      	bmi.n	14c6 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x2d6>
    1418:	f44f 7260 	mov.w	r2, #896	; 0x380
    141c:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    141e:	005b      	lsls	r3, r3, #1
    1420:	b294      	uxth	r4, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    1422:	021e      	lsls	r6, r3, #8
    1424:	b222      	sxth	r2, r4
    1426:	d5f9      	bpl.n	141c <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x22c>
    1428:	0124      	lsls	r4, r4, #4
    142a:	b2e4      	uxtb	r4, r4
    142c:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    1430:	f3c3 0316 	ubfx	r3, r3, #0, #23
    1434:	015e      	lsls	r6, r3, #5
    1436:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
    143a:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    143e:	b2f6      	uxtb	r6, r6
    1440:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    1444:	e74b      	b.n	12de <geometry_msgs::Quaternion::serialize(unsigned char*) const+0xee>
    1446:	015d      	lsls	r5, r3, #5
    1448:	0cd8      	lsrs	r0, r3, #19
    144a:	f3c3 06c7 	ubfx	r6, r3, #3, #8
    144e:	b2ed      	uxtb	r5, r5
    1450:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
    1454:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    1458:	227f      	movs	r2, #127	; 0x7f
    145a:	e76c      	b.n	1336 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x146>
    145c:	015e      	lsls	r6, r3, #5
    145e:	0cdc      	lsrs	r4, r3, #19
    1460:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    1464:	b2f6      	uxtb	r6, r6
    1466:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    146a:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    146e:	227f      	movs	r2, #127	; 0x7f
    1470:	e735      	b.n	12de <geometry_msgs::Quaternion::serialize(unsigned char*) const+0xee>
    1472:	015e      	lsls	r6, r3, #5
    1474:	0cdc      	lsrs	r4, r3, #19
    1476:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    147a:	b2f6      	uxtb	r6, r6
    147c:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    1480:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    1484:	227f      	movs	r2, #127	; 0x7f
    1486:	e6fd      	b.n	1284 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x94>
    1488:	015e      	lsls	r6, r3, #5
    148a:	0cdc      	lsrs	r4, r3, #19
    148c:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    1490:	b2f6      	uxtb	r6, r6
    1492:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    1496:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    149a:	227f      	movs	r2, #127	; 0x7f
    149c:	e6c5      	b.n	122a <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x3a>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    149e:	461a      	mov	r2, r3
    14a0:	461c      	mov	r4, r3
    14a2:	461f      	mov	r7, r3
    14a4:	461e      	mov	r6, r3
    14a6:	e71a      	b.n	12de <geometry_msgs::Quaternion::serialize(unsigned char*) const+0xee>
    14a8:	461a      	mov	r2, r3
    14aa:	4618      	mov	r0, r3
    14ac:	461e      	mov	r6, r3
    14ae:	461d      	mov	r5, r3
    14b0:	e741      	b.n	1336 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x146>
    14b2:	461a      	mov	r2, r3
    14b4:	461c      	mov	r4, r3
    14b6:	461f      	mov	r7, r3
    14b8:	461e      	mov	r6, r3
    14ba:	e6e3      	b.n	1284 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x94>
    14bc:	461a      	mov	r2, r3
    14be:	461c      	mov	r4, r3
    14c0:	461f      	mov	r7, r3
    14c2:	461e      	mov	r6, r3
    14c4:	e6b1      	b.n	122a <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x3a>
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    14c6:	4614      	mov	r4, r2
    14c8:	2238      	movs	r2, #56	; 0x38
    14ca:	e7b1      	b.n	1430 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x240>
    14cc:	4614      	mov	r4, r2
    14ce:	2238      	movs	r2, #56	; 0x38
    14d0:	e758      	b.n	1384 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x194>
    14d2:	4614      	mov	r4, r2
    14d4:	2238      	movs	r2, #56	; 0x38
    14d6:	e773      	b.n	13c0 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x1d0>
    14d8:	4610      	mov	r0, r2
    14da:	2238      	movs	r2, #56	; 0x38
    14dc:	e78c      	b.n	13f8 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x208>
    14de:	bf00      	nop

000014e0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.9] [clone .constprop.11]>:
      }
    }
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
    14e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    14e2:	b085      	sub	sp, #20
      enum { ERROR = 3 };
      enum { FATAL = 4 };

    Log():
      level(0),
      msg("")
    14e4:	4b2d      	ldr	r3, [pc, #180]	; (159c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.9] [clone .constprop.11]+0xbc>)
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    14e6:	6802      	ldr	r2, [r0, #0]
    14e8:	9301      	str	r3, [sp, #4]
protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    14ea:	492d      	ldr	r1, [pc, #180]	; (15a0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.9] [clone .constprop.11]+0xc0>)
    14ec:	9103      	str	r1, [sp, #12]

protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    14ee:	2303      	movs	r3, #3
    14f0:	f88d 3008 	strb.w	r3, [sp, #8]
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    14f4:	6814      	ldr	r4, [r2, #0]
    14f6:	4a2b      	ldr	r2, [pc, #172]	; (15a4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.9] [clone .constprop.11]+0xc4>)
    14f8:	4294      	cmp	r4, r2
    14fa:	d140      	bne.n	157e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.9] [clone .constprop.11]+0x9e>
  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
      arr[i] = (var >> (8 * i));
    14fc:	2400      	movs	r4, #0
    14fe:	2238      	movs	r2, #56	; 0x38
    1500:	4605      	mov	r5, r0
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    1502:	f880 3223 	strb.w	r3, [r0, #547]	; 0x223
    1506:	f880 2224 	strb.w	r2, [r0, #548]	; 0x224
    150a:	f880 4225 	strb.w	r4, [r0, #549]	; 0x225
    150e:	f880 4226 	strb.w	r4, [r0, #550]	; 0x226
    1512:	f880 4227 	strb.w	r4, [r0, #551]	; 0x227
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    1516:	f500 700a 	add.w	r0, r0, #552	; 0x228
    151a:	f004 f84b 	bl	55b4 <memcpy>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    151e:	27ff      	movs	r7, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    1520:	203d      	movs	r0, #61	; 0x3d
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    1522:	23c2      	movs	r3, #194	; 0xc2
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    1524:	26fe      	movs	r6, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    1526:	2107      	movs	r1, #7
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    1528:	f885 021e 	strb.w	r0, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    152c:	f885 3220 	strb.w	r3, [r5, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    1530:	f885 421f 	strb.w	r4, [r5, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    1534:	f885 4222 	strb.w	r4, [r5, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    1538:	4622      	mov	r2, r4

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    153a:	f885 721c 	strb.w	r7, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    153e:	f885 621d 	strb.w	r6, [r5, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    1542:	f885 1221 	strb.w	r1, [r5, #545]	; 0x221
    1546:	f205 2321 	addw	r3, r5, #545	; 0x221
    154a:	f205 205f 	addw	r0, r5, #607	; 0x25f
    154e:	e001      	b.n	1554 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.9] [clone .constprop.11]+0x74>
    1550:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    1554:	4283      	cmp	r3, r0
      chk += message_out[i];
    1556:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    1558:	d1fa      	bne.n	1550 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.9] [clone .constprop.11]+0x70>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    155a:	43d2      	mvns	r2, r2
    155c:	686c      	ldr	r4, [r5, #4]
    155e:	f885 2260 	strb.w	r2, [r5, #608]	; 0x260
    1562:	6823      	ldr	r3, [r4, #0]
    1564:	4a10      	ldr	r2, [pc, #64]	; (15a8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.9] [clone .constprop.11]+0xc8>)
    1566:	685b      	ldr	r3, [r3, #4]
    1568:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    156a:	f505 7007 	add.w	r0, r5, #540	; 0x21c
    156e:	d10d      	bne.n	158c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.9] [clone .constprop.11]+0xac>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    1570:	2145      	movs	r1, #69	; 0x45
    1572:	f005 fb37 	bl	6be4 <usb_serial_write>
    else
    {
      logerror("Message from device dropped: message larger than buffer.");
      return -1;
    }
  }
    1576:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    157a:	b005      	add	sp, #20
    157c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    157e:	aa01      	add	r2, sp, #4
    1580:	2107      	movs	r1, #7
    1582:	47a0      	blx	r4
    else
    {
      logerror("Message from device dropped: message larger than buffer.");
      return -1;
    }
  }
    1584:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1588:	b005      	add	sp, #20
    158a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    158c:	4601      	mov	r1, r0
    158e:	2245      	movs	r2, #69	; 0x45
    1590:	4620      	mov	r0, r4
    1592:	4798      	blx	r3
    1594:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1598:	b005      	add	sp, #20
    159a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    159c:	00008fac 	.word	0x00008fac
    15a0:	00009280 	.word	0x00009280
    15a4:	000026ed 	.word	0x000026ed
    15a8:	00000949 	.word	0x00000949

000015ac <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)>:
    endpoint_(endpoint)
  {
    topic_ = topic_name;
  };

  virtual void callback(unsigned char* data) override
    15ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    15b0:	f891 e007 	ldrb.w	lr, [r1, #7]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    15b4:	790e      	ldrb	r6, [r1, #4]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    15b6:	798b      	ldrb	r3, [r1, #6]
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    15b8:	794f      	ldrb	r7, [r1, #5]
    15ba:	4605      	mov	r5, r0
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    15bc:	ea4f 120e 	mov.w	r2, lr, lsl #4

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    15c0:	78c8      	ldrb	r0, [r1, #3]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    15c2:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    15c6:	0136      	lsls	r6, r6, #4
    15c8:	460c      	mov	r4, r1
    15ca:	ea46 1010 	orr.w	r0, r6, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    15ce:	0519      	lsls	r1, r3, #20

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    15d0:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    15d4:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    15d8:	ea40 3007 	orr.w	r0, r0, r7, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    15dc:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    15e0:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    15e2:	ea41 0100 	orr.w	r1, r1, r0
    15e6:	b082      	sub	sp, #8
  {
    msg.deserialize(data);
    15e8:	f105 070c 	add.w	r7, r5, #12

    virtual int deserialize(unsigned char *inbuffer) override
    {
      int offset = 0;
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->x));
    15ec:	f105 0014 	add.w	r0, r5, #20

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    15f0:	f000 81a1 	beq.w	1936 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x38a>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    15f4:	f240 467e 	movw	r6, #1150	; 0x47e
    15f8:	42b3      	cmp	r3, r6
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    15fa:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    15fc:	d943      	bls.n	1686 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0xda>
    15fe:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1602:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1604:	f02e 0e7f 	bic.w	lr, lr, #127	; 0x7f
    1608:	4313      	orrs	r3, r2
    160a:	ae02      	add	r6, sp, #8
    160c:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
    1610:	f846 3d04 	str.w	r3, [r6, #-4]!

    memcpy(f, &val, sizeof(val));
    1614:	2204      	movs	r2, #4
    1616:	4631      	mov	r1, r6
    1618:	f003 ffcc 	bl	55b4 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    161c:	f894 c00f 	ldrb.w	ip, [r4, #15]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1620:	f894 e00c 	ldrb.w	lr, [r4, #12]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1624:	7ba3      	ldrb	r3, [r4, #14]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    1626:	7ae0      	ldrb	r0, [r4, #11]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1628:	f894 800d 	ldrb.w	r8, [r4, #13]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    162c:	ea4f 120c 	mov.w	r2, ip, lsl #4
    1630:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1634:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1638:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    163a:	ea4e 1010 	orr.w	r0, lr, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    163e:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    1642:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1646:	ea40 3008 	orr.w	r0, r0, r8, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    164a:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    164e:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1650:	ea41 0100 	orr.w	r1, r1, r0
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->y));
    1654:	f105 0018 	add.w	r0, r5, #24

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1658:	f000 8164 	beq.w	1924 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x378>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    165c:	f240 4e7e 	movw	lr, #1150	; 0x47e
    1660:	4573      	cmp	r3, lr
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1662:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1664:	d81f      	bhi.n	16a6 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0xfa>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1666:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    166a:	f300 819a 	bgt.w	19a2 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x3f6>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    166e:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1672:	f340 81a9 	ble.w	19c8 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x41c>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1676:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    167a:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    167c:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1680:	40d1      	lsrs	r1, r2
    1682:	2200      	movs	r2, #0
    1684:	e150      	b.n	1928 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x37c>
    else if (exp - 1023 > 127)
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1686:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    168a:	f300 816f 	bgt.w	196c <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x3c0>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    168e:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1692:	f340 8193 	ble.w	19bc <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x410>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1696:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    169a:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    169c:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    16a0:	40d1      	lsrs	r1, r2
    16a2:	2200      	movs	r2, #0
    16a4:	e149      	b.n	193a <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x38e>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    16a6:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    16aa:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    16ac:	f02c 0c7f 	bic.w	ip, ip, #127	; 0x7f
    16b0:	4313      	orrs	r3, r2
    16b2:	ea43 630c 	orr.w	r3, r3, ip, lsl #24

    memcpy(f, &val, sizeof(val));
    16b6:	2204      	movs	r2, #4
    16b8:	4631      	mov	r1, r6
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    16ba:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    16bc:	f003 ff7a 	bl	55b4 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    16c0:	f894 c017 	ldrb.w	ip, [r4, #23]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    16c4:	f894 e014 	ldrb.w	lr, [r4, #20]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    16c8:	7da3      	ldrb	r3, [r4, #22]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    16ca:	7ce0      	ldrb	r0, [r4, #19]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    16cc:	f894 8015 	ldrb.w	r8, [r4, #21]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    16d0:	ea4f 120c 	mov.w	r2, ip, lsl #4
    16d4:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    16d8:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    16dc:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    16de:	ea4e 1010 	orr.w	r0, lr, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    16e2:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    16e6:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    16ea:	ea40 3008 	orr.w	r0, r0, r8, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    16ee:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    16f2:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    16f4:	ea41 0100 	orr.w	r1, r1, r0
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->z));
    16f8:	f105 001c 	add.w	r0, r5, #28

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    16fc:	f000 8109 	beq.w	1912 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x366>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1700:	f240 4e7e 	movw	lr, #1150	; 0x47e
    1704:	4573      	cmp	r3, lr
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1706:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1708:	d80f      	bhi.n	172a <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x17e>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    170a:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    170e:	f300 8136 	bgt.w	197e <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x3d2>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1712:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1716:	f340 8153 	ble.w	19c0 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x414>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    171a:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    171e:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    1720:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1724:	40d1      	lsrs	r1, r2
    1726:	2200      	movs	r2, #0
    1728:	e0f5      	b.n	1916 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x36a>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    172a:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    172e:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1730:	f02c 0c7f 	bic.w	ip, ip, #127	; 0x7f
    1734:	4313      	orrs	r3, r2
    1736:	ea43 630c 	orr.w	r3, r3, ip, lsl #24

    memcpy(f, &val, sizeof(val));
    173a:	2204      	movs	r2, #4
    173c:	4631      	mov	r1, r6
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    173e:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    1740:	f003 ff38 	bl	55b4 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1744:	f894 c01f 	ldrb.w	ip, [r4, #31]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1748:	f894 e01c 	ldrb.w	lr, [r4, #28]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    174c:	7fa3      	ldrb	r3, [r4, #30]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    174e:	7ee0      	ldrb	r0, [r4, #27]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1750:	f894 801d 	ldrb.w	r8, [r4, #29]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1754:	ea4f 120c 	mov.w	r2, ip, lsl #4
    1758:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    175c:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1760:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1762:	ea4e 1010 	orr.w	r0, lr, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1766:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    176a:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    176e:	ea40 3008 	orr.w	r0, r0, r8, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1772:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1776:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1778:	ea41 0100 	orr.w	r1, r1, r0
    }

    virtual int deserialize(unsigned char *inbuffer) override
    {
      int offset = 0;
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->x));
    177c:	f105 0024 	add.w	r0, r5, #36	; 0x24

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1780:	f000 80be 	beq.w	1900 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x354>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1784:	f240 4e7e 	movw	lr, #1150	; 0x47e
    1788:	4573      	cmp	r3, lr
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    178a:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    178c:	d80f      	bhi.n	17ae <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x202>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    178e:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    1792:	f300 80fd 	bgt.w	1990 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x3e4>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1796:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    179a:	f340 8113 	ble.w	19c4 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x418>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    179e:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    17a2:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    17a4:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    17a8:	40d1      	lsrs	r1, r2
    17aa:	2200      	movs	r2, #0
    17ac:	e0aa      	b.n	1904 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x358>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    17ae:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    17b2:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    17b4:	f02c 0c7f 	bic.w	ip, ip, #127	; 0x7f
    17b8:	4313      	orrs	r3, r2
    17ba:	ea43 630c 	orr.w	r3, r3, ip, lsl #24

    memcpy(f, &val, sizeof(val));
    17be:	2204      	movs	r2, #4
    17c0:	4631      	mov	r1, r6
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    17c2:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    17c4:	f003 fef6 	bl	55b4 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    17c8:	f894 c027 	ldrb.w	ip, [r4, #39]	; 0x27
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    17cc:	f894 e024 	ldrb.w	lr, [r4, #36]	; 0x24
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    17d0:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    17d4:	f894 0023 	ldrb.w	r0, [r4, #35]	; 0x23
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    17d8:	f894 8025 	ldrb.w	r8, [r4, #37]	; 0x25
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    17dc:	ea4f 120c 	mov.w	r2, ip, lsl #4
    17e0:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    17e4:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    17e8:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    17ea:	ea4e 1010 	orr.w	r0, lr, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    17ee:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    17f2:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    17f6:	ea40 3008 	orr.w	r0, r0, r8, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    17fa:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    17fe:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1800:	ea41 0100 	orr.w	r1, r1, r0
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->y));
    1804:	f105 0028 	add.w	r0, r5, #40	; 0x28

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1808:	d071      	beq.n	18ee <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x342>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    180a:	f240 4e7e 	movw	lr, #1150	; 0x47e
    180e:	4573      	cmp	r3, lr
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1810:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1812:	d80f      	bhi.n	1834 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x288>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1814:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    1818:	f300 809f 	bgt.w	195a <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x3ae>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    181c:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1820:	f340 80ca 	ble.w	19b8 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x40c>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1824:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    1828:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    182a:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    182e:	40d1      	lsrs	r1, r2
    1830:	2200      	movs	r2, #0
    1832:	e05e      	b.n	18f2 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x346>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1834:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1838:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    183a:	f02c 0c7f 	bic.w	ip, ip, #127	; 0x7f
    183e:	4313      	orrs	r3, r2
    1840:	ea43 630c 	orr.w	r3, r3, ip, lsl #24

    memcpy(f, &val, sizeof(val));
    1844:	2204      	movs	r2, #4
    1846:	4631      	mov	r1, r6
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1848:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    184a:	f003 feb3 	bl	55b4 <memcpy>
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    184e:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1852:	f894 e02f 	ldrb.w	lr, [r4, #47]	; 0x2f

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1856:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    185a:	f894 002b 	ldrb.w	r0, [r4, #43]	; 0x2b
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    185e:	f894 c02d 	ldrb.w	ip, [r4, #45]	; 0x2d
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1862:	0114      	lsls	r4, r2, #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1864:	ea4f 120e 	mov.w	r2, lr, lsl #4
    1868:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    186c:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    186e:	ea44 1010 	orr.w	r0, r4, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1872:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    1876:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    187a:	ea40 300c 	orr.w	r0, r0, ip, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    187e:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1882:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1884:	ea41 0100 	orr.w	r1, r1, r0
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->z));
    1888:	f105 002c 	add.w	r0, r5, #44	; 0x2c

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    188c:	d026      	beq.n	18dc <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x330>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    188e:	f240 447e 	movw	r4, #1150	; 0x47e
    1892:	42a3      	cmp	r3, r4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1894:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1896:	d80e      	bhi.n	18b6 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x30a>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1898:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    189c:	dc54      	bgt.n	1948 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x39c>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    189e:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    18a2:	f340 8087 	ble.w	19b4 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x408>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    18a6:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    18aa:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    18ac:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    18b0:	40d1      	lsrs	r1, r2
    18b2:	2200      	movs	r2, #0
    18b4:	e014      	b.n	18e0 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x334>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    18b6:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    18ba:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    18bc:	f02e 0e7f 	bic.w	lr, lr, #127	; 0x7f
    18c0:	4313      	orrs	r3, r2
    18c2:	ea43 630e 	orr.w	r3, r3, lr, lsl #24

    memcpy(f, &val, sizeof(val));
    18c6:	4631      	mov	r1, r6
    18c8:	2204      	movs	r2, #4
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    18ca:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    18cc:	f003 fe72 	bl	55b4 <memcpy>
    this->cb_(msg);
    18d0:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    18d2:	4638      	mov	r0, r7
  }
    18d4:	b002      	add	sp, #8
    18d6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  };

  virtual void callback(unsigned char* data) override
  {
    msg.deserialize(data);
    this->cb_(msg);
    18da:	4718      	bx	r3

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    18dc:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    18e0:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    18e4:	4299      	cmp	r1, r3
    18e6:	d036      	beq.n	1956 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x3aa>
    18e8:	1c4b      	adds	r3, r1, #1
    18ea:	085b      	lsrs	r3, r3, #1
    18ec:	e7e6      	b.n	18bc <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x310>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    18ee:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    18f2:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    18f6:	4299      	cmp	r1, r3
    18f8:	d036      	beq.n	1968 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x3bc>
    18fa:	1c4b      	adds	r3, r1, #1
    18fc:	085b      	lsrs	r3, r3, #1
    18fe:	e79c      	b.n	183a <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x28e>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1900:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    1904:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1908:	4299      	cmp	r1, r3
    190a:	d048      	beq.n	199e <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x3f2>
    190c:	1c4b      	adds	r3, r1, #1
    190e:	085b      	lsrs	r3, r3, #1
    1910:	e750      	b.n	17b4 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x208>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1912:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    1916:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    191a:	4299      	cmp	r1, r3
    191c:	d036      	beq.n	198c <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x3e0>
    191e:	1c4b      	adds	r3, r1, #1
    1920:	085b      	lsrs	r3, r3, #1
    1922:	e705      	b.n	1730 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x184>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1924:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    1928:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    192c:	4299      	cmp	r1, r3
    192e:	d03f      	beq.n	19b0 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x404>
    1930:	1c4b      	adds	r3, r1, #1
    1932:	085b      	lsrs	r3, r3, #1
    1934:	e6ba      	b.n	16ac <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x100>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1936:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    193a:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    193e:	4299      	cmp	r1, r3
    1940:	d01b      	beq.n	197a <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x3ce>
    1942:	1c4b      	adds	r3, r1, #1
    1944:	085b      	lsrs	r3, r3, #1
    1946:	e65d      	b.n	1604 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x58>
    1948:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    194c:	05da      	lsls	r2, r3, #23
    194e:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1952:	4299      	cmp	r1, r3
    1954:	d1c8      	bne.n	18e8 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x33c>
    1956:	4b1d      	ldr	r3, [pc, #116]	; (19cc <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x420>)
    1958:	e7b0      	b.n	18bc <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x310>
    195a:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    195e:	05da      	lsls	r2, r3, #23
    1960:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1964:	4299      	cmp	r1, r3
    1966:	d1c8      	bne.n	18fa <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x34e>
    1968:	4b18      	ldr	r3, [pc, #96]	; (19cc <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x420>)
    196a:	e766      	b.n	183a <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x28e>
    196c:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    1970:	05da      	lsls	r2, r3, #23
    1972:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1976:	4299      	cmp	r1, r3
    1978:	d1e3      	bne.n	1942 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x396>
    197a:	4b14      	ldr	r3, [pc, #80]	; (19cc <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x420>)
    197c:	e642      	b.n	1604 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x58>
    197e:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    1982:	05da      	lsls	r2, r3, #23
    1984:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1988:	4299      	cmp	r1, r3
    198a:	d1c8      	bne.n	191e <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x372>
    198c:	4b0f      	ldr	r3, [pc, #60]	; (19cc <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x420>)
    198e:	e6cf      	b.n	1730 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x184>
    1990:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    1994:	05da      	lsls	r2, r3, #23
    1996:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    199a:	4299      	cmp	r1, r3
    199c:	d1b6      	bne.n	190c <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x360>
    199e:	4b0b      	ldr	r3, [pc, #44]	; (19cc <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x420>)
    19a0:	e708      	b.n	17b4 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x208>
    19a2:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    19a6:	05da      	lsls	r2, r3, #23
    19a8:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    19ac:	4299      	cmp	r1, r3
    19ae:	d1bf      	bne.n	1930 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x384>
    19b0:	4b06      	ldr	r3, [pc, #24]	; (19cc <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x420>)
    19b2:	e67b      	b.n	16ac <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x100>
    }
    else if (exp - 1023 >= -126)
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    19b4:	2200      	movs	r2, #0
    19b6:	e793      	b.n	18e0 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x334>
    19b8:	2200      	movs	r2, #0
    19ba:	e79a      	b.n	18f2 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x346>
    19bc:	2200      	movs	r2, #0
    19be:	e7bc      	b.n	193a <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x38e>
    19c0:	2200      	movs	r2, #0
    19c2:	e7a8      	b.n	1916 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x36a>
    19c4:	2200      	movs	r2, #0
    19c6:	e79d      	b.n	1904 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x358>
    19c8:	2200      	movs	r2, #0
    19ca:	e7ad      	b.n	1928 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x37c>
    19cc:	007fffff 	.word	0x007fffff

000019d0 <geometry_msgs::Twist::deserialize(unsigned char*)>:
      offset += this->linear.serialize(outbuffer + offset);
      offset += this->angular.serialize(outbuffer + offset);
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
    19d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    19d2:	79cf      	ldrb	r7, [r1, #7]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    19d4:	790d      	ldrb	r5, [r1, #4]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    19d6:	798b      	ldrb	r3, [r1, #6]
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    19d8:	f891 e005 	ldrb.w	lr, [r1, #5]
    19dc:	4606      	mov	r6, r0
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    19de:	013a      	lsls	r2, r7, #4

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    19e0:	78c8      	ldrb	r0, [r1, #3]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    19e2:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    19e6:	012d      	lsls	r5, r5, #4
    19e8:	460c      	mov	r4, r1
    19ea:	ea45 1010 	orr.w	r0, r5, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    19ee:	0519      	lsls	r1, r3, #20

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    19f0:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    19f4:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    19f8:	ea40 300e 	orr.w	r0, r0, lr, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    19fc:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1a00:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1a02:	ea41 0100 	orr.w	r1, r1, r0
    1a06:	b083      	sub	sp, #12
    }

    virtual int deserialize(unsigned char *inbuffer) override
    {
      int offset = 0;
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->x));
    1a08:	f106 0008 	add.w	r0, r6, #8

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1a0c:	f000 8196 	beq.w	1d3c <geometry_msgs::Twist::deserialize(unsigned char*)+0x36c>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1a10:	f240 457e 	movw	r5, #1150	; 0x47e
    1a14:	42ab      	cmp	r3, r5
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1a16:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1a18:	d941      	bls.n	1a9e <geometry_msgs::Twist::deserialize(unsigned char*)+0xce>
    1a1a:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1a1e:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1a20:	f027 077f 	bic.w	r7, r7, #127	; 0x7f
    1a24:	4313      	orrs	r3, r2
    1a26:	ad02      	add	r5, sp, #8
    1a28:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
    1a2c:	f845 3d04 	str.w	r3, [r5, #-4]!

    memcpy(f, &val, sizeof(val));
    1a30:	2204      	movs	r2, #4
    1a32:	4629      	mov	r1, r5
    1a34:	f003 fdbe 	bl	55b4 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1a38:	f894 e00f 	ldrb.w	lr, [r4, #15]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1a3c:	7b27      	ldrb	r7, [r4, #12]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1a3e:	7ba3      	ldrb	r3, [r4, #14]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    1a40:	7ae0      	ldrb	r0, [r4, #11]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1a42:	f894 c00d 	ldrb.w	ip, [r4, #13]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1a46:	ea4f 120e 	mov.w	r2, lr, lsl #4
    1a4a:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1a4e:	013f      	lsls	r7, r7, #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1a50:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1a52:	ea47 1010 	orr.w	r0, r7, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1a56:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    1a5a:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1a5e:	ea40 300c 	orr.w	r0, r0, ip, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1a62:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1a66:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1a68:	ea41 0100 	orr.w	r1, r1, r0
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->y));
    1a6c:	f106 000c 	add.w	r0, r6, #12

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1a70:	f000 815b 	beq.w	1d2a <geometry_msgs::Twist::deserialize(unsigned char*)+0x35a>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1a74:	f240 477e 	movw	r7, #1150	; 0x47e
    1a78:	42bb      	cmp	r3, r7
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1a7a:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1a7c:	d81f      	bhi.n	1abe <geometry_msgs::Twist::deserialize(unsigned char*)+0xee>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1a7e:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    1a82:	f300 8191 	bgt.w	1da8 <geometry_msgs::Twist::deserialize(unsigned char*)+0x3d8>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1a86:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1a8a:	f340 81a0 	ble.w	1dce <geometry_msgs::Twist::deserialize(unsigned char*)+0x3fe>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1a8e:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    1a92:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    1a94:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1a98:	40d1      	lsrs	r1, r2
    1a9a:	2200      	movs	r2, #0
    1a9c:	e147      	b.n	1d2e <geometry_msgs::Twist::deserialize(unsigned char*)+0x35e>
    else if (exp - 1023 > 127)
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1a9e:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    1aa2:	f300 8166 	bgt.w	1d72 <geometry_msgs::Twist::deserialize(unsigned char*)+0x3a2>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1aa6:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1aaa:	f340 818a 	ble.w	1dc2 <geometry_msgs::Twist::deserialize(unsigned char*)+0x3f2>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1aae:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    1ab2:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    1ab4:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1ab8:	40d1      	lsrs	r1, r2
    1aba:	2200      	movs	r2, #0
    1abc:	e140      	b.n	1d40 <geometry_msgs::Twist::deserialize(unsigned char*)+0x370>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1abe:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1ac2:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1ac4:	f02e 0e7f 	bic.w	lr, lr, #127	; 0x7f
    1ac8:	4313      	orrs	r3, r2
    1aca:	ea43 630e 	orr.w	r3, r3, lr, lsl #24

    memcpy(f, &val, sizeof(val));
    1ace:	2204      	movs	r2, #4
    1ad0:	4629      	mov	r1, r5
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1ad2:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    1ad4:	f003 fd6e 	bl	55b4 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1ad8:	f894 e017 	ldrb.w	lr, [r4, #23]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1adc:	7d27      	ldrb	r7, [r4, #20]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1ade:	7da3      	ldrb	r3, [r4, #22]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    1ae0:	7ce0      	ldrb	r0, [r4, #19]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1ae2:	f894 c015 	ldrb.w	ip, [r4, #21]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1ae6:	ea4f 120e 	mov.w	r2, lr, lsl #4
    1aea:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1aee:	013f      	lsls	r7, r7, #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1af0:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1af2:	ea47 1010 	orr.w	r0, r7, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1af6:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    1afa:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1afe:	ea40 300c 	orr.w	r0, r0, ip, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1b02:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1b06:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1b08:	ea41 0100 	orr.w	r1, r1, r0
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->z));
    1b0c:	f106 0010 	add.w	r0, r6, #16

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1b10:	f000 8102 	beq.w	1d18 <geometry_msgs::Twist::deserialize(unsigned char*)+0x348>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1b14:	f240 477e 	movw	r7, #1150	; 0x47e
    1b18:	42bb      	cmp	r3, r7
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1b1a:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1b1c:	d80f      	bhi.n	1b3e <geometry_msgs::Twist::deserialize(unsigned char*)+0x16e>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1b1e:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    1b22:	f300 812f 	bgt.w	1d84 <geometry_msgs::Twist::deserialize(unsigned char*)+0x3b4>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1b26:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1b2a:	f340 814c 	ble.w	1dc6 <geometry_msgs::Twist::deserialize(unsigned char*)+0x3f6>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1b2e:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    1b32:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    1b34:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1b38:	40d1      	lsrs	r1, r2
    1b3a:	2200      	movs	r2, #0
    1b3c:	e0ee      	b.n	1d1c <geometry_msgs::Twist::deserialize(unsigned char*)+0x34c>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1b3e:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1b42:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1b44:	f02e 0e7f 	bic.w	lr, lr, #127	; 0x7f
    1b48:	4313      	orrs	r3, r2
    1b4a:	ea43 630e 	orr.w	r3, r3, lr, lsl #24

    memcpy(f, &val, sizeof(val));
    1b4e:	2204      	movs	r2, #4
    1b50:	4629      	mov	r1, r5
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1b52:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    1b54:	f003 fd2e 	bl	55b4 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1b58:	f894 e01f 	ldrb.w	lr, [r4, #31]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1b5c:	7f27      	ldrb	r7, [r4, #28]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1b5e:	7fa3      	ldrb	r3, [r4, #30]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    1b60:	7ee0      	ldrb	r0, [r4, #27]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1b62:	f894 c01d 	ldrb.w	ip, [r4, #29]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1b66:	ea4f 120e 	mov.w	r2, lr, lsl #4
    1b6a:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1b6e:	013f      	lsls	r7, r7, #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1b70:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1b72:	ea47 1010 	orr.w	r0, r7, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1b76:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    1b7a:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1b7e:	ea40 300c 	orr.w	r0, r0, ip, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1b82:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1b86:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1b88:	ea41 0100 	orr.w	r1, r1, r0
    }

    virtual int deserialize(unsigned char *inbuffer) override
    {
      int offset = 0;
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->x));
    1b8c:	f106 0018 	add.w	r0, r6, #24

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1b90:	f000 80b9 	beq.w	1d06 <geometry_msgs::Twist::deserialize(unsigned char*)+0x336>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1b94:	f240 477e 	movw	r7, #1150	; 0x47e
    1b98:	42bb      	cmp	r3, r7
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1b9a:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1b9c:	d80f      	bhi.n	1bbe <geometry_msgs::Twist::deserialize(unsigned char*)+0x1ee>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1b9e:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    1ba2:	f300 80f8 	bgt.w	1d96 <geometry_msgs::Twist::deserialize(unsigned char*)+0x3c6>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1ba6:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1baa:	f340 810e 	ble.w	1dca <geometry_msgs::Twist::deserialize(unsigned char*)+0x3fa>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1bae:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    1bb2:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    1bb4:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1bb8:	40d1      	lsrs	r1, r2
    1bba:	2200      	movs	r2, #0
    1bbc:	e0a5      	b.n	1d0a <geometry_msgs::Twist::deserialize(unsigned char*)+0x33a>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1bbe:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1bc2:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1bc4:	f02e 0e7f 	bic.w	lr, lr, #127	; 0x7f
    1bc8:	4313      	orrs	r3, r2
    1bca:	ea43 630e 	orr.w	r3, r3, lr, lsl #24

    memcpy(f, &val, sizeof(val));
    1bce:	2204      	movs	r2, #4
    1bd0:	4629      	mov	r1, r5
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1bd2:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    1bd4:	f003 fcee 	bl	55b4 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1bd8:	f894 e027 	ldrb.w	lr, [r4, #39]	; 0x27
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1bdc:	f894 7024 	ldrb.w	r7, [r4, #36]	; 0x24
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1be0:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    1be4:	f894 0023 	ldrb.w	r0, [r4, #35]	; 0x23
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1be8:	f894 c025 	ldrb.w	ip, [r4, #37]	; 0x25
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1bec:	ea4f 120e 	mov.w	r2, lr, lsl #4
    1bf0:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1bf4:	013f      	lsls	r7, r7, #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1bf6:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1bf8:	ea47 1010 	orr.w	r0, r7, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1bfc:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    1c00:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1c04:	ea40 300c 	orr.w	r0, r0, ip, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1c08:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1c0c:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1c0e:	ea41 0100 	orr.w	r1, r1, r0
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->y));
    1c12:	f106 001c 	add.w	r0, r6, #28

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1c16:	d06d      	beq.n	1cf4 <geometry_msgs::Twist::deserialize(unsigned char*)+0x324>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1c18:	f240 477e 	movw	r7, #1150	; 0x47e
    1c1c:	42bb      	cmp	r3, r7
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1c1e:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1c20:	d80f      	bhi.n	1c42 <geometry_msgs::Twist::deserialize(unsigned char*)+0x272>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1c22:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    1c26:	f300 809b 	bgt.w	1d60 <geometry_msgs::Twist::deserialize(unsigned char*)+0x390>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1c2a:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1c2e:	f340 80c6 	ble.w	1dbe <geometry_msgs::Twist::deserialize(unsigned char*)+0x3ee>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1c32:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    1c36:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    1c38:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1c3c:	40d1      	lsrs	r1, r2
    1c3e:	2200      	movs	r2, #0
    1c40:	e05a      	b.n	1cf8 <geometry_msgs::Twist::deserialize(unsigned char*)+0x328>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1c42:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1c46:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1c48:	f02e 0e7f 	bic.w	lr, lr, #127	; 0x7f
    1c4c:	4313      	orrs	r3, r2
    1c4e:	ea43 630e 	orr.w	r3, r3, lr, lsl #24

    memcpy(f, &val, sizeof(val));
    1c52:	2204      	movs	r2, #4
    1c54:	4629      	mov	r1, r5
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1c56:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    1c58:	f003 fcac 	bl	55b4 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1c5c:	f894 702f 	ldrb.w	r7, [r4, #47]	; 0x2f
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1c60:	f894 002c 	ldrb.w	r0, [r4, #44]	; 0x2c

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    1c64:	f894 102b 	ldrb.w	r1, [r4, #43]	; 0x2b
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1c68:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1c6c:	f894 e02d 	ldrb.w	lr, [r4, #45]	; 0x2d
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1c70:	013a      	lsls	r2, r7, #4
    1c72:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1c76:	0100      	lsls	r0, r0, #4
    1c78:	ea40 1011 	orr.w	r0, r0, r1, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1c7c:	0519      	lsls	r1, r3, #20

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1c7e:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    1c82:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1c86:	ea40 340e 	orr.w	r4, r0, lr, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1c8a:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1c8e:	4293      	cmp	r3, r2
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->z));
    1c90:	f106 0020 	add.w	r0, r6, #32

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1c94:	ea41 0104 	orr.w	r1, r1, r4

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1c98:	d023      	beq.n	1ce2 <geometry_msgs::Twist::deserialize(unsigned char*)+0x312>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1c9a:	f240 447e 	movw	r4, #1150	; 0x47e
    1c9e:	42a3      	cmp	r3, r4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1ca0:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1ca2:	d80e      	bhi.n	1cc2 <geometry_msgs::Twist::deserialize(unsigned char*)+0x2f2>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1ca4:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    1ca8:	dc51      	bgt.n	1d4e <geometry_msgs::Twist::deserialize(unsigned char*)+0x37e>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1caa:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1cae:	f340 8084 	ble.w	1dba <geometry_msgs::Twist::deserialize(unsigned char*)+0x3ea>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1cb2:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    1cb6:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    1cb8:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1cbc:	40d1      	lsrs	r1, r2
    1cbe:	2200      	movs	r2, #0
    1cc0:	e011      	b.n	1ce6 <geometry_msgs::Twist::deserialize(unsigned char*)+0x316>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1cc2:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1cc6:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1cc8:	f027 077f 	bic.w	r7, r7, #127	; 0x7f
    1ccc:	4313      	orrs	r3, r2
    1cce:	ea43 6307 	orr.w	r3, r3, r7, lsl #24

    memcpy(f, &val, sizeof(val));
    1cd2:	4629      	mov	r1, r5
    1cd4:	2204      	movs	r2, #4
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1cd6:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    1cd8:	f003 fc6c 	bl	55b4 <memcpy>
    {
      int offset = 0;
      offset += this->linear.deserialize(inbuffer + offset);
      offset += this->angular.deserialize(inbuffer + offset);
     return offset;
    }
    1cdc:	2030      	movs	r0, #48	; 0x30
    1cde:	b003      	add	sp, #12
    1ce0:	bdf0      	pop	{r4, r5, r6, r7, pc}

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1ce2:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    1ce6:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1cea:	4299      	cmp	r1, r3
    1cec:	d036      	beq.n	1d5c <geometry_msgs::Twist::deserialize(unsigned char*)+0x38c>
    1cee:	1c4b      	adds	r3, r1, #1
    1cf0:	085b      	lsrs	r3, r3, #1
    1cf2:	e7e9      	b.n	1cc8 <geometry_msgs::Twist::deserialize(unsigned char*)+0x2f8>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1cf4:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    1cf8:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1cfc:	4299      	cmp	r1, r3
    1cfe:	d036      	beq.n	1d6e <geometry_msgs::Twist::deserialize(unsigned char*)+0x39e>
    1d00:	1c4b      	adds	r3, r1, #1
    1d02:	085b      	lsrs	r3, r3, #1
    1d04:	e7a0      	b.n	1c48 <geometry_msgs::Twist::deserialize(unsigned char*)+0x278>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1d06:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    1d0a:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1d0e:	4299      	cmp	r1, r3
    1d10:	d048      	beq.n	1da4 <geometry_msgs::Twist::deserialize(unsigned char*)+0x3d4>
    1d12:	1c4b      	adds	r3, r1, #1
    1d14:	085b      	lsrs	r3, r3, #1
    1d16:	e755      	b.n	1bc4 <geometry_msgs::Twist::deserialize(unsigned char*)+0x1f4>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1d18:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    1d1c:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1d20:	4299      	cmp	r1, r3
    1d22:	d036      	beq.n	1d92 <geometry_msgs::Twist::deserialize(unsigned char*)+0x3c2>
    1d24:	1c4b      	adds	r3, r1, #1
    1d26:	085b      	lsrs	r3, r3, #1
    1d28:	e70c      	b.n	1b44 <geometry_msgs::Twist::deserialize(unsigned char*)+0x174>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1d2a:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    1d2e:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1d32:	4299      	cmp	r1, r3
    1d34:	d03f      	beq.n	1db6 <geometry_msgs::Twist::deserialize(unsigned char*)+0x3e6>
    1d36:	1c4b      	adds	r3, r1, #1
    1d38:	085b      	lsrs	r3, r3, #1
    1d3a:	e6c3      	b.n	1ac4 <geometry_msgs::Twist::deserialize(unsigned char*)+0xf4>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1d3c:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    1d40:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1d44:	4299      	cmp	r1, r3
    1d46:	d01b      	beq.n	1d80 <geometry_msgs::Twist::deserialize(unsigned char*)+0x3b0>
    1d48:	1c4b      	adds	r3, r1, #1
    1d4a:	085b      	lsrs	r3, r3, #1
    1d4c:	e668      	b.n	1a20 <geometry_msgs::Twist::deserialize(unsigned char*)+0x50>
    1d4e:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    1d52:	05da      	lsls	r2, r3, #23
    1d54:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1d58:	4299      	cmp	r1, r3
    1d5a:	d1c8      	bne.n	1cee <geometry_msgs::Twist::deserialize(unsigned char*)+0x31e>
    1d5c:	4b1d      	ldr	r3, [pc, #116]	; (1dd4 <geometry_msgs::Twist::deserialize(unsigned char*)+0x404>)
    1d5e:	e7b3      	b.n	1cc8 <geometry_msgs::Twist::deserialize(unsigned char*)+0x2f8>
    1d60:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    1d64:	05da      	lsls	r2, r3, #23
    1d66:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1d6a:	4299      	cmp	r1, r3
    1d6c:	d1c8      	bne.n	1d00 <geometry_msgs::Twist::deserialize(unsigned char*)+0x330>
    1d6e:	4b19      	ldr	r3, [pc, #100]	; (1dd4 <geometry_msgs::Twist::deserialize(unsigned char*)+0x404>)
    1d70:	e76a      	b.n	1c48 <geometry_msgs::Twist::deserialize(unsigned char*)+0x278>
    1d72:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    1d76:	05da      	lsls	r2, r3, #23
    1d78:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1d7c:	4299      	cmp	r1, r3
    1d7e:	d1e3      	bne.n	1d48 <geometry_msgs::Twist::deserialize(unsigned char*)+0x378>
    1d80:	4b14      	ldr	r3, [pc, #80]	; (1dd4 <geometry_msgs::Twist::deserialize(unsigned char*)+0x404>)
    1d82:	e64d      	b.n	1a20 <geometry_msgs::Twist::deserialize(unsigned char*)+0x50>
    1d84:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    1d88:	05da      	lsls	r2, r3, #23
    1d8a:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1d8e:	4299      	cmp	r1, r3
    1d90:	d1c8      	bne.n	1d24 <geometry_msgs::Twist::deserialize(unsigned char*)+0x354>
    1d92:	4b10      	ldr	r3, [pc, #64]	; (1dd4 <geometry_msgs::Twist::deserialize(unsigned char*)+0x404>)
    1d94:	e6d6      	b.n	1b44 <geometry_msgs::Twist::deserialize(unsigned char*)+0x174>
    1d96:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    1d9a:	05da      	lsls	r2, r3, #23
    1d9c:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1da0:	4299      	cmp	r1, r3
    1da2:	d1b6      	bne.n	1d12 <geometry_msgs::Twist::deserialize(unsigned char*)+0x342>
    1da4:	4b0b      	ldr	r3, [pc, #44]	; (1dd4 <geometry_msgs::Twist::deserialize(unsigned char*)+0x404>)
    1da6:	e70d      	b.n	1bc4 <geometry_msgs::Twist::deserialize(unsigned char*)+0x1f4>
    1da8:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    1dac:	05da      	lsls	r2, r3, #23
    1dae:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1db2:	4299      	cmp	r1, r3
    1db4:	d1bf      	bne.n	1d36 <geometry_msgs::Twist::deserialize(unsigned char*)+0x366>
    1db6:	4b07      	ldr	r3, [pc, #28]	; (1dd4 <geometry_msgs::Twist::deserialize(unsigned char*)+0x404>)
    1db8:	e684      	b.n	1ac4 <geometry_msgs::Twist::deserialize(unsigned char*)+0xf4>
    }
    else if (exp - 1023 >= -126)
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1dba:	2200      	movs	r2, #0
    1dbc:	e793      	b.n	1ce6 <geometry_msgs::Twist::deserialize(unsigned char*)+0x316>
    1dbe:	2200      	movs	r2, #0
    1dc0:	e79a      	b.n	1cf8 <geometry_msgs::Twist::deserialize(unsigned char*)+0x328>
    1dc2:	2200      	movs	r2, #0
    1dc4:	e7bc      	b.n	1d40 <geometry_msgs::Twist::deserialize(unsigned char*)+0x370>
    1dc6:	2200      	movs	r2, #0
    1dc8:	e7a8      	b.n	1d1c <geometry_msgs::Twist::deserialize(unsigned char*)+0x34c>
    1dca:	2200      	movs	r2, #0
    1dcc:	e79d      	b.n	1d0a <geometry_msgs::Twist::deserialize(unsigned char*)+0x33a>
    1dce:	2200      	movs	r2, #0
    1dd0:	e7ad      	b.n	1d2e <geometry_msgs::Twist::deserialize(unsigned char*)+0x35e>
    1dd2:	bf00      	nop
    1dd4:	007fffff 	.word	0x007fffff

00001dd8 <geometry_msgs::Vector3::deserialize(unsigned char*)>:
      offset += serializeAvrFloat64(outbuffer + offset, this->y);
      offset += serializeAvrFloat64(outbuffer + offset, this->z);
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
    1dd8:	b5f0      	push	{r4, r5, r6, r7, lr}
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1dda:	79cf      	ldrb	r7, [r1, #7]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1ddc:	790d      	ldrb	r5, [r1, #4]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1dde:	798b      	ldrb	r3, [r1, #6]
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1de0:	f891 e005 	ldrb.w	lr, [r1, #5]
    1de4:	4606      	mov	r6, r0
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1de6:	013a      	lsls	r2, r7, #4

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    1de8:	78c8      	ldrb	r0, [r1, #3]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1dea:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1dee:	012d      	lsls	r5, r5, #4
    1df0:	460c      	mov	r4, r1
    1df2:	ea45 1010 	orr.w	r0, r5, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1df6:	0519      	lsls	r1, r3, #20

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1df8:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    1dfc:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1e00:	ea40 300e 	orr.w	r0, r0, lr, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1e04:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1e08:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1e0a:	ea41 0100 	orr.w	r1, r1, r0
    1e0e:	b083      	sub	sp, #12
    {
      int offset = 0;
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->x));
    1e10:	f106 0004 	add.w	r0, r6, #4

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1e14:	f000 80b2 	beq.w	1f7c <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1a4>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1e18:	f240 457e 	movw	r5, #1150	; 0x47e
    1e1c:	42ab      	cmp	r3, r5
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1e1e:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1e20:	d940      	bls.n	1ea4 <geometry_msgs::Vector3::deserialize(unsigned char*)+0xcc>
    1e22:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1e26:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1e28:	f027 077f 	bic.w	r7, r7, #127	; 0x7f
    1e2c:	4313      	orrs	r3, r2
    1e2e:	ad02      	add	r5, sp, #8
    1e30:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
    1e34:	f845 3d04 	str.w	r3, [r5, #-4]!

    memcpy(f, &val, sizeof(val));
    1e38:	2204      	movs	r2, #4
    1e3a:	4629      	mov	r1, r5
    1e3c:	f003 fbba 	bl	55b4 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1e40:	f894 e00f 	ldrb.w	lr, [r4, #15]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1e44:	7b27      	ldrb	r7, [r4, #12]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1e46:	7ba3      	ldrb	r3, [r4, #14]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    1e48:	7ae0      	ldrb	r0, [r4, #11]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1e4a:	f894 c00d 	ldrb.w	ip, [r4, #13]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1e4e:	ea4f 120e 	mov.w	r2, lr, lsl #4
    1e52:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1e56:	013f      	lsls	r7, r7, #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1e58:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1e5a:	ea47 1010 	orr.w	r0, r7, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1e5e:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    1e62:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1e66:	ea40 300c 	orr.w	r0, r0, ip, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1e6a:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1e6e:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1e70:	ea41 0100 	orr.w	r1, r1, r0
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->y));
    1e74:	f106 0008 	add.w	r0, r6, #8

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1e78:	d077      	beq.n	1f6a <geometry_msgs::Vector3::deserialize(unsigned char*)+0x192>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1e7a:	f240 477e 	movw	r7, #1150	; 0x47e
    1e7e:	42bb      	cmp	r3, r7
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1e80:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1e82:	d81e      	bhi.n	1ec2 <geometry_msgs::Vector3::deserialize(unsigned char*)+0xea>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1e84:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    1e88:	f300 8093 	bgt.w	1fb2 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1da>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1e8c:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1e90:	f340 8098 	ble.w	1fc4 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1ec>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1e94:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    1e98:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    1e9a:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1e9e:	40d1      	lsrs	r1, r2
    1ea0:	2200      	movs	r2, #0
    1ea2:	e064      	b.n	1f6e <geometry_msgs::Vector3::deserialize(unsigned char*)+0x196>
    else if (exp - 1023 > 127)
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1ea4:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    1ea8:	dc7a      	bgt.n	1fa0 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1c8>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1eaa:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1eae:	f340 808d 	ble.w	1fcc <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1f4>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1eb2:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    1eb6:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    1eb8:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1ebc:	40d1      	lsrs	r1, r2
    1ebe:	2200      	movs	r2, #0
    1ec0:	e05e      	b.n	1f80 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1a8>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1ec2:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1ec6:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1ec8:	f02e 0e7f 	bic.w	lr, lr, #127	; 0x7f
    1ecc:	4313      	orrs	r3, r2
    1ece:	ea43 630e 	orr.w	r3, r3, lr, lsl #24

    memcpy(f, &val, sizeof(val));
    1ed2:	2204      	movs	r2, #4
    1ed4:	4629      	mov	r1, r5
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1ed6:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    1ed8:	f003 fb6c 	bl	55b4 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1edc:	7de7      	ldrb	r7, [r4, #23]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1ede:	7d20      	ldrb	r0, [r4, #20]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    1ee0:	7ce1      	ldrb	r1, [r4, #19]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1ee2:	7da3      	ldrb	r3, [r4, #22]
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1ee4:	f894 e015 	ldrb.w	lr, [r4, #21]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1ee8:	013a      	lsls	r2, r7, #4
    1eea:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1eee:	0100      	lsls	r0, r0, #4
    1ef0:	ea40 1011 	orr.w	r0, r0, r1, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1ef4:	0519      	lsls	r1, r3, #20

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1ef6:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    1efa:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1efe:	ea40 340e 	orr.w	r4, r0, lr, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1f02:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1f06:	4293      	cmp	r3, r2
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->z));
    1f08:	f106 000c 	add.w	r0, r6, #12

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1f0c:	ea41 0104 	orr.w	r1, r1, r4

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1f10:	d022      	beq.n	1f58 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x180>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1f12:	f240 447e 	movw	r4, #1150	; 0x47e
    1f16:	42a3      	cmp	r3, r4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1f18:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1f1a:	d80d      	bhi.n	1f38 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x160>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1f1c:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    1f20:	dc35      	bgt.n	1f8e <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1b6>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1f22:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1f26:	dd4f      	ble.n	1fc8 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1f0>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1f28:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    1f2c:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    1f2e:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1f32:	40d1      	lsrs	r1, r2
    1f34:	2200      	movs	r2, #0
    1f36:	e011      	b.n	1f5c <geometry_msgs::Vector3::deserialize(unsigned char*)+0x184>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1f38:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1f3c:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1f3e:	f027 077f 	bic.w	r7, r7, #127	; 0x7f
    1f42:	4313      	orrs	r3, r2
    1f44:	ea43 6307 	orr.w	r3, r3, r7, lsl #24

    memcpy(f, &val, sizeof(val));
    1f48:	4629      	mov	r1, r5
    1f4a:	2204      	movs	r2, #4
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1f4c:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    1f4e:	f003 fb31 	bl	55b4 <memcpy>
     return offset;
    }
    1f52:	2018      	movs	r0, #24
    1f54:	b003      	add	sp, #12
    1f56:	bdf0      	pop	{r4, r5, r6, r7, pc}

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1f58:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    1f5c:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1f60:	4299      	cmp	r1, r3
    1f62:	d01b      	beq.n	1f9c <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1c4>
    1f64:	1c4b      	adds	r3, r1, #1
    1f66:	085b      	lsrs	r3, r3, #1
    1f68:	e7e9      	b.n	1f3e <geometry_msgs::Vector3::deserialize(unsigned char*)+0x166>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1f6a:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    1f6e:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1f72:	4299      	cmp	r1, r3
    1f74:	d024      	beq.n	1fc0 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1e8>
    1f76:	1c4b      	adds	r3, r1, #1
    1f78:	085b      	lsrs	r3, r3, #1
    1f7a:	e7a5      	b.n	1ec8 <geometry_msgs::Vector3::deserialize(unsigned char*)+0xf0>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1f7c:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    1f80:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1f84:	4299      	cmp	r1, r3
    1f86:	d012      	beq.n	1fae <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1d6>
    1f88:	1c4b      	adds	r3, r1, #1
    1f8a:	085b      	lsrs	r3, r3, #1
    1f8c:	e74c      	b.n	1e28 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x50>
    1f8e:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    1f92:	05da      	lsls	r2, r3, #23
    1f94:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1f98:	4299      	cmp	r1, r3
    1f9a:	d1e3      	bne.n	1f64 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x18c>
    1f9c:	4b0c      	ldr	r3, [pc, #48]	; (1fd0 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1f8>)
    1f9e:	e7ce      	b.n	1f3e <geometry_msgs::Vector3::deserialize(unsigned char*)+0x166>
    1fa0:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    1fa4:	05da      	lsls	r2, r3, #23
    1fa6:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1faa:	4299      	cmp	r1, r3
    1fac:	d1ec      	bne.n	1f88 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1b0>
    1fae:	4b08      	ldr	r3, [pc, #32]	; (1fd0 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1f8>)
    1fb0:	e73a      	b.n	1e28 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x50>
    1fb2:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    1fb6:	05da      	lsls	r2, r3, #23
    1fb8:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1fbc:	4299      	cmp	r1, r3
    1fbe:	d1da      	bne.n	1f76 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x19e>
    1fc0:	4b03      	ldr	r3, [pc, #12]	; (1fd0 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1f8>)
    1fc2:	e781      	b.n	1ec8 <geometry_msgs::Vector3::deserialize(unsigned char*)+0xf0>
    }
    else if (exp - 1023 >= -126)
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1fc4:	2200      	movs	r2, #0
    1fc6:	e7d2      	b.n	1f6e <geometry_msgs::Vector3::deserialize(unsigned char*)+0x196>
    1fc8:	2200      	movs	r2, #0
    1fca:	e7c7      	b.n	1f5c <geometry_msgs::Vector3::deserialize(unsigned char*)+0x184>
    1fcc:	2200      	movs	r2, #0
    1fce:	e7d7      	b.n	1f80 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1a8>
    1fd0:	007fffff 	.word	0x007fffff
    1fd4:	ffffffff 	.word	0xffffffff

00001fd8 <encoder_count_chage_right()>:
  result = result / sizeof(the_input_array);
  return result;
}


void encoder_count_chage_right() {
    1fd8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  delta_time_right =  double(micros()) / 1000000 - old_time_right;
    1fdc:	f003 fed6 	bl	5d8c <micros>
    1fe0:	4d79      	ldr	r5, [pc, #484]	; (21c8 <encoder_count_chage_right()+0x1f0>)
    1fe2:	f8df 8220 	ldr.w	r8, [pc, #544]	; 2204 <encoder_count_chage_right()+0x22c>
  old_time_right = double(micros()) / 1000000;
  int right_count_tick;
  if (encoder_counter_right < counts_per_revolution && encoder_counter_right > -counts_per_revolution) {
    1fe6:	f8df 9220 	ldr.w	r9, [pc, #544]	; 2208 <encoder_count_chage_right()+0x230>
  return result;
}


void encoder_count_chage_right() {
  delta_time_right =  double(micros()) / 1000000 - old_time_right;
    1fea:	f005 fa8d 	bl	7508 <__aeabi_ui2d>
    1fee:	a374      	add	r3, pc, #464	; (adr r3, 21c0 <encoder_count_chage_right()+0x1e8>)
    1ff0:	e9d3 2300 	ldrd	r2, r3, [r3]
    1ff4:	f005 fc28 	bl	7848 <__aeabi_ddiv>
    1ff8:	e9d5 2300 	ldrd	r2, r3, [r5]
    1ffc:	f005 f946 	bl	728c <__aeabi_dsub>
    2000:	e9c8 0100 	strd	r0, r1, [r8]
  old_time_right = double(micros()) / 1000000;
    2004:	f003 fec2 	bl	5d8c <micros>
    2008:	f005 fa7e 	bl	7508 <__aeabi_ui2d>
    200c:	a36c      	add	r3, pc, #432	; (adr r3, 21c0 <encoder_count_chage_right()+0x1e8>)
    200e:	e9d3 2300 	ldrd	r2, r3, [r3]
    2012:	f005 fc19 	bl	7848 <__aeabi_ddiv>
  int right_count_tick;
  if (encoder_counter_right < counts_per_revolution && encoder_counter_right > -counts_per_revolution) {
    2016:	e9d9 6700 	ldrd	r6, r7, [r9]
}


void encoder_count_chage_right() {
  delta_time_right =  double(micros()) / 1000000 - old_time_right;
  old_time_right = double(micros()) / 1000000;
    201a:	e9c5 0100 	strd	r0, r1, [r5]
  int right_count_tick;
  if (encoder_counter_right < counts_per_revolution && encoder_counter_right > -counts_per_revolution) {
    201e:	2200      	movs	r2, #0
    2020:	4b6a      	ldr	r3, [pc, #424]	; (21cc <encoder_count_chage_right()+0x1f4>)
    2022:	4630      	mov	r0, r6
    2024:	4639      	mov	r1, r7
    2026:	f005 fd57 	bl	7ad8 <__aeabi_dcmplt>
    202a:	b138      	cbz	r0, 203c <encoder_count_chage_right()+0x64>
    202c:	2200      	movs	r2, #0
    202e:	4b68      	ldr	r3, [pc, #416]	; (21d0 <encoder_count_chage_right()+0x1f8>)
    2030:	4630      	mov	r0, r6
    2032:	4639      	mov	r1, r7
    2034:	f005 fd6e 	bl	7b14 <__aeabi_dcmpgt>
    2038:	2800      	cmp	r0, #0
    203a:	d17e      	bne.n	213a <encoder_count_chage_right()+0x162>
    203c:	4b65      	ldr	r3, [pc, #404]	; (21d4 <encoder_count_chage_right()+0x1fc>)
    203e:	edd3 7a00 	vldr	s15, [r3]
      encoder_counter_right = encoder_counter_right - 1;
      right_count_tick += -1;
      current_omega_right = -count_to_rad / delta_time_right;
    }
  }
  if (current_omega_right < 20 && current_omega_right > -20) {
    2042:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
    2046:	eef4 7ac7 	vcmpe.f32	s15, s14
    204a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    204e:	d45a      	bmi.n	2106 <encoder_count_chage_right()+0x12e>
    2050:	4d61      	ldr	r5, [pc, #388]	; (21d8 <encoder_count_chage_right()+0x200>)
    2052:	4b62      	ldr	r3, [pc, #392]	; (21dc <encoder_count_chage_right()+0x204>)
    2054:	4e62      	ldr	r6, [pc, #392]	; (21e0 <encoder_count_chage_right()+0x208>)
    2056:	68d8      	ldr	r0, [r3, #12]
    2058:	6899      	ldr	r1, [r3, #8]
    205a:	6807      	ldr	r7, [r0, #0]
    array_push(speed_array_right, current_omega_right);
  }

  right_tick.data = right_count_tick;
    205c:	4a61      	ldr	r2, [pc, #388]	; (21e4 <encoder_count_chage_right()+0x20c>)
    205e:	683b      	ldr	r3, [r7, #0]
    2060:	8094      	strh	r4, [r2, #4]
    2062:	42b3      	cmp	r3, r6
    2064:	f040 808c 	bne.w	2180 <encoder_count_chage_right()+0x1a8>
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    2068:	2963      	cmp	r1, #99	; 0x63
    206a:	dd02      	ble.n	2072 <encoder_count_chage_right()+0x9a>
    206c:	f890 34f8 	ldrb.w	r3, [r0, #1272]	; 0x4f8
    2070:	b37b      	cbz	r3, 20d2 <encoder_count_chage_right()+0xfa>
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    2072:	f341 2607 	sbfx	r6, r1, #8, #8
    2076:	b2f3      	uxtb	r3, r6

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    2078:	fa53 f381 	uxtab	r3, r3, r1
        int16_t real;
        uint16_t base;
      } u_data;
      u_data.real = this->data;
      *(outbuffer + offset + 0) = (u_data.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_data.base >> (8 * 1)) & 0xFF;
    207c:	f3c4 2207 	ubfx	r2, r4, #8, #8
    2080:	fa53 f384 	uxtab	r3, r3, r4
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    2084:	4413      	add	r3, r2
    2086:	43db      	mvns	r3, r3
      union {
        int16_t real;
        uint16_t base;
      } u_data;
      u_data.real = this->data;
      *(outbuffer + offset + 0) = (u_data.base >> (8 * 0)) & 0xFF;
    2088:	f880 4223 	strb.w	r4, [r0, #547]	; 0x223
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    208c:	f880 1221 	strb.w	r1, [r0, #545]	; 0x221
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    2090:	f880 3225 	strb.w	r3, [r0, #549]	; 0x225
      *(outbuffer + offset + 1) = (u_data.base >> (8 * 1)) & 0xFF;
    2094:	f880 2224 	strb.w	r2, [r0, #548]	; 0x224
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    2098:	2402      	movs	r4, #2
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    209a:	23fd      	movs	r3, #253	; 0xfd
    209c:	6842      	ldr	r2, [r0, #4]
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    209e:	f880 421e 	strb.w	r4, [r0, #542]	; 0x21e

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    20a2:	f04f 0eff 	mov.w	lr, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    20a6:	27fe      	movs	r7, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    20a8:	2100      	movs	r1, #0
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    20aa:	f880 6222 	strb.w	r6, [r0, #546]	; 0x222

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    20ae:	f880 e21c 	strb.w	lr, [r0, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    20b2:	f880 721d 	strb.w	r7, [r0, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    20b6:	f880 121f 	strb.w	r1, [r0, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    20ba:	f880 3220 	strb.w	r3, [r0, #544]	; 0x220
    20be:	6813      	ldr	r3, [r2, #0]
    20c0:	4c49      	ldr	r4, [pc, #292]	; (21e8 <encoder_count_chage_right()+0x210>)
    20c2:	685b      	ldr	r3, [r3, #4]
    20c4:	42a3      	cmp	r3, r4
    l += 7;
    message_out[l++] = 255 - (chk % 256);

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    20c6:	f500 7007 	add.w	r0, r0, #540	; 0x21c
    20ca:	d15b      	bne.n	2184 <encoder_count_chage_right()+0x1ac>
    20cc:	210a      	movs	r1, #10
    20ce:	f004 fd89 	bl	6be4 <usb_serial_write>
    20d2:	4b46      	ldr	r3, [pc, #280]	; (21ec <encoder_count_chage_right()+0x214>)
    20d4:	ed95 6a00 	vldr	s12, [r5]
  result = result / sizeof(the_input_array);
  return result;
}


void encoder_count_chage_right() {
    20d8:	ed9f 7a45 	vldr	s14, [pc, #276]	; 21f0 <encoder_count_chage_right()+0x218>
    20dc:	f103 0210 	add.w	r2, r3, #16
}

float averaging_array(long the_input_array[]) {
  float result = 0;
  for (int x = 0; x < sizeof(the_input_array); x++) {
    result = result + (the_input_array[x] / float_to_long_factor);
    20e0:	ecf3 7a01 	vldmia	r3!, {s15}
    20e4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  the_input_array[0] = data * float_to_long_factor;
}

float averaging_array(long the_input_array[]) {
  float result = 0;
  for (int x = 0; x < sizeof(the_input_array); x++) {
    20e8:	429a      	cmp	r2, r3
    result = result + (the_input_array[x] / float_to_long_factor);
    20ea:	eec7 6a86 	vdiv.f32	s13, s15, s12
    20ee:	ee37 7a26 	vadd.f32	s14, s14, s13
  the_input_array[0] = data * float_to_long_factor;
}

float averaging_array(long the_input_array[]) {
  float result = 0;
  for (int x = 0; x < sizeof(the_input_array); x++) {
    20f2:	d1f5      	bne.n	20e0 <encoder_count_chage_right()+0x108>
    array_push(speed_array_right, current_omega_right);
  }

  right_tick.data = right_count_tick;
  right_tick_pub.publish(&right_tick);
  average_omega_right = averaging_array(speed_array_right);
    20f4:	eef5 7a00 	vmov.f32	s15, #80	; 0x3e800000  0.250
    20f8:	ee27 7a27 	vmul.f32	s14, s14, s15
    20fc:	4b3d      	ldr	r3, [pc, #244]	; (21f4 <encoder_count_chage_right()+0x21c>)
    20fe:	ed83 7a00 	vstr	s14, [r3]
}
    2102:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      encoder_counter_right = encoder_counter_right - 1;
      right_count_tick += -1;
      current_omega_right = -count_to_rad / delta_time_right;
    }
  }
  if (current_omega_right < 20 && current_omega_right > -20) {
    2106:	eebb 7a04 	vmov.f32	s14, #180	; 0xc1a00000 -20.0
    210a:	eef4 7ac7 	vcmpe.f32	s15, s14
    210e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr

void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
  }
  the_input_array[0] = data * float_to_long_factor;
    2112:	4d31      	ldr	r5, [pc, #196]	; (21d8 <encoder_count_chage_right()+0x200>)
      encoder_counter_right = encoder_counter_right - 1;
      right_count_tick += -1;
      current_omega_right = -count_to_rad / delta_time_right;
    }
  }
  if (current_omega_right < 20 && current_omega_right > -20) {
    2114:	dd9d      	ble.n	2052 <encoder_count_chage_right()+0x7a>

void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
  }
  the_input_array[0] = data * float_to_long_factor;
    2116:	ed95 7a00 	vldr	s14, [r5]



void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
    211a:	4b34      	ldr	r3, [pc, #208]	; (21ec <encoder_count_chage_right()+0x214>)
  }
  the_input_array[0] = data * float_to_long_factor;
    211c:	ee67 7a87 	vmul.f32	s15, s15, s14



void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
    2120:	681a      	ldr	r2, [r3, #0]
    2122:	6858      	ldr	r0, [r3, #4]
    2124:	6899      	ldr	r1, [r3, #8]
    2126:	605a      	str	r2, [r3, #4]
  }
  the_input_array[0] = data * float_to_long_factor;
    2128:	eefd 7ae7 	vcvt.s32.f32	s15, s15



void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
    212c:	68da      	ldr	r2, [r3, #12]
    212e:	6098      	str	r0, [r3, #8]
    2130:	60d9      	str	r1, [r3, #12]
  }
  the_input_array[0] = data * float_to_long_factor;
    2132:	edc3 7a00 	vstr	s15, [r3]



void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
    2136:	611a      	str	r2, [r3, #16]
    2138:	e78b      	b.n	2052 <encoder_count_chage_right()+0x7a>
void encoder_count_chage_right() {
  delta_time_right =  double(micros()) / 1000000 - old_time_right;
  old_time_right = double(micros()) / 1000000;
  int right_count_tick;
  if (encoder_counter_right < counts_per_revolution && encoder_counter_right > -counts_per_revolution) {
    if (direction_indicator_right == 1) {
    213a:	4b2f      	ldr	r3, [pc, #188]	; (21f8 <encoder_count_chage_right()+0x220>)
    213c:	681b      	ldr	r3, [r3, #0]
    213e:	2b01      	cmp	r3, #1
    2140:	d025      	beq.n	218e <encoder_count_chage_right()+0x1b6>
      encoder_counter_right++;
      right_count_tick += 1;
      current_omega_right = count_to_rad / delta_time_right;
    }
    if (direction_indicator_right == 0) {
    2142:	2b00      	cmp	r3, #0
    2144:	f47f af7a 	bne.w	203c <encoder_count_chage_right()+0x64>
      encoder_counter_right = encoder_counter_right - 1;
    2148:	2200      	movs	r2, #0
    214a:	4b2c      	ldr	r3, [pc, #176]	; (21fc <encoder_count_chage_right()+0x224>)
    214c:	4630      	mov	r0, r6
    214e:	4639      	mov	r1, r7
    2150:	f005 f89c 	bl	728c <__aeabi_dsub>
      right_count_tick += -1;
      current_omega_right = -count_to_rad / delta_time_right;
    2154:	4b2a      	ldr	r3, [pc, #168]	; (2200 <encoder_count_chage_right()+0x228>)
    2156:	681c      	ldr	r4, [r3, #0]
    2158:	685b      	ldr	r3, [r3, #4]
    215a:	f103 4500 	add.w	r5, r3, #2147483648	; 0x80000000
      encoder_counter_right++;
      right_count_tick += 1;
      current_omega_right = count_to_rad / delta_time_right;
    }
    if (direction_indicator_right == 0) {
      encoder_counter_right = encoder_counter_right - 1;
    215e:	e9c9 0100 	strd	r0, r1, [r9]
      right_count_tick += -1;
      current_omega_right = -count_to_rad / delta_time_right;
    2162:	e9d8 2300 	ldrd	r2, r3, [r8]
    2166:	4620      	mov	r0, r4
    2168:	4629      	mov	r1, r5
    216a:	f005 fb6d 	bl	7848 <__aeabi_ddiv>
    216e:	f005 fd03 	bl	7b78 <__aeabi_d2f>
    2172:	4b18      	ldr	r3, [pc, #96]	; (21d4 <encoder_count_chage_right()+0x1fc>)
    2174:	ee07 0a90 	vmov	s15, r0
      right_count_tick += 1;
      current_omega_right = count_to_rad / delta_time_right;
    }
    if (direction_indicator_right == 0) {
      encoder_counter_right = encoder_counter_right - 1;
      right_count_tick += -1;
    2178:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
      current_omega_right = -count_to_rad / delta_time_right;
    217c:	6018      	str	r0, [r3, #0]
    217e:	e760      	b.n	2042 <encoder_count_chage_right()+0x6a>
    2180:	4798      	blx	r3
    2182:	e7a6      	b.n	20d2 <encoder_count_chage_right()+0xfa>
    2184:	4601      	mov	r1, r0
    2186:	4610      	mov	r0, r2
    2188:	220a      	movs	r2, #10
    218a:	4798      	blx	r3
    218c:	e7a1      	b.n	20d2 <encoder_count_chage_right()+0xfa>
  delta_time_right =  double(micros()) / 1000000 - old_time_right;
  old_time_right = double(micros()) / 1000000;
  int right_count_tick;
  if (encoder_counter_right < counts_per_revolution && encoder_counter_right > -counts_per_revolution) {
    if (direction_indicator_right == 1) {
      encoder_counter_right++;
    218e:	2200      	movs	r2, #0
    2190:	4b1a      	ldr	r3, [pc, #104]	; (21fc <encoder_count_chage_right()+0x224>)
      right_count_tick += 1;
      current_omega_right = count_to_rad / delta_time_right;
    2192:	4c1b      	ldr	r4, [pc, #108]	; (2200 <encoder_count_chage_right()+0x228>)
  delta_time_right =  double(micros()) / 1000000 - old_time_right;
  old_time_right = double(micros()) / 1000000;
  int right_count_tick;
  if (encoder_counter_right < counts_per_revolution && encoder_counter_right > -counts_per_revolution) {
    if (direction_indicator_right == 1) {
      encoder_counter_right++;
    2194:	4630      	mov	r0, r6
    2196:	4639      	mov	r1, r7
    2198:	f005 f87a 	bl	7290 <__adddf3>
      right_count_tick += 1;
      current_omega_right = count_to_rad / delta_time_right;
    219c:	e9d8 2300 	ldrd	r2, r3, [r8]
  delta_time_right =  double(micros()) / 1000000 - old_time_right;
  old_time_right = double(micros()) / 1000000;
  int right_count_tick;
  if (encoder_counter_right < counts_per_revolution && encoder_counter_right > -counts_per_revolution) {
    if (direction_indicator_right == 1) {
      encoder_counter_right++;
    21a0:	e9c9 0100 	strd	r0, r1, [r9]
      right_count_tick += 1;
      current_omega_right = count_to_rad / delta_time_right;
    21a4:	e9d4 0100 	ldrd	r0, r1, [r4]
    21a8:	f005 fb4e 	bl	7848 <__aeabi_ddiv>
    21ac:	f005 fce4 	bl	7b78 <__aeabi_d2f>
    21b0:	4b08      	ldr	r3, [pc, #32]	; (21d4 <encoder_count_chage_right()+0x1fc>)
    21b2:	ee07 0a90 	vmov	s15, r0
  old_time_right = double(micros()) / 1000000;
  int right_count_tick;
  if (encoder_counter_right < counts_per_revolution && encoder_counter_right > -counts_per_revolution) {
    if (direction_indicator_right == 1) {
      encoder_counter_right++;
      right_count_tick += 1;
    21b6:	2401      	movs	r4, #1
      current_omega_right = count_to_rad / delta_time_right;
    21b8:	6018      	str	r0, [r3, #0]
    21ba:	e742      	b.n	2042 <encoder_count_chage_right()+0x6a>
    21bc:	f3af 8000 	nop.w
    21c0:	00000000 	.word	0x00000000
    21c4:	412e8480 	.word	0x412e8480
    21c8:	1fff1d30 	.word	0x1fff1d30
    21cc:	409e0000 	.word	0x409e0000
    21d0:	c09e0000 	.word	0xc09e0000
    21d4:	1fff1d2c 	.word	0x1fff1d2c
    21d8:	1fff0818 	.word	0x1fff0818
    21dc:	1fff1458 	.word	0x1fff1458
    21e0:	000026ed 	.word	0x000026ed
    21e4:	1fff1cdc 	.word	0x1fff1cdc
    21e8:	00000949 	.word	0x00000949
    21ec:	1fff228c 	.word	0x1fff228c
    21f0:	00000000 	.word	0x00000000
    21f4:	1fff146c 	.word	0x1fff146c
    21f8:	1fff2288 	.word	0x1fff2288
    21fc:	3ff00000 	.word	0x3ff00000
    2200:	1fff0810 	.word	0x1fff0810
    2204:	1fff1450 	.word	0x1fff1450
    2208:	1fff1d20 	.word	0x1fff1d20
    220c:	ffffffff 	.word	0xffffffff

00002210 <encoder_count_chage_left()>:
  right_tick.data = right_count_tick;
  right_tick_pub.publish(&right_tick);
  average_omega_right = averaging_array(speed_array_right);
}

void encoder_count_chage_left() {
    2210:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  delta_time_left = double(micros()) / 1000000 - old_time_left;
    2214:	f003 fdba 	bl	5d8c <micros>
    2218:	4d79      	ldr	r5, [pc, #484]	; (2400 <encoder_count_chage_left()+0x1f0>)
    221a:	f8df 8220 	ldr.w	r8, [pc, #544]	; 243c <encoder_count_chage_left()+0x22c>
  old_time_left = double(micros()) / 1000000;
  int left_count_tick;
  if (encoder_counter_left < counts_per_revolution && encoder_counter_left > -counts_per_revolution) {
    221e:	f8df 9220 	ldr.w	r9, [pc, #544]	; 2440 <encoder_count_chage_left()+0x230>
  right_tick_pub.publish(&right_tick);
  average_omega_right = averaging_array(speed_array_right);
}

void encoder_count_chage_left() {
  delta_time_left = double(micros()) / 1000000 - old_time_left;
    2222:	f005 f971 	bl	7508 <__aeabi_ui2d>
    2226:	a374      	add	r3, pc, #464	; (adr r3, 23f8 <encoder_count_chage_left()+0x1e8>)
    2228:	e9d3 2300 	ldrd	r2, r3, [r3]
    222c:	f005 fb0c 	bl	7848 <__aeabi_ddiv>
    2230:	e9d5 2300 	ldrd	r2, r3, [r5]
    2234:	f005 f82a 	bl	728c <__aeabi_dsub>
    2238:	e9c8 0100 	strd	r0, r1, [r8]
  old_time_left = double(micros()) / 1000000;
    223c:	f003 fda6 	bl	5d8c <micros>
    2240:	f005 f962 	bl	7508 <__aeabi_ui2d>
    2244:	a36c      	add	r3, pc, #432	; (adr r3, 23f8 <encoder_count_chage_left()+0x1e8>)
    2246:	e9d3 2300 	ldrd	r2, r3, [r3]
    224a:	f005 fafd 	bl	7848 <__aeabi_ddiv>
  int left_count_tick;
  if (encoder_counter_left < counts_per_revolution && encoder_counter_left > -counts_per_revolution) {
    224e:	e9d9 6700 	ldrd	r6, r7, [r9]
  average_omega_right = averaging_array(speed_array_right);
}

void encoder_count_chage_left() {
  delta_time_left = double(micros()) / 1000000 - old_time_left;
  old_time_left = double(micros()) / 1000000;
    2252:	e9c5 0100 	strd	r0, r1, [r5]
  int left_count_tick;
  if (encoder_counter_left < counts_per_revolution && encoder_counter_left > -counts_per_revolution) {
    2256:	2200      	movs	r2, #0
    2258:	4b6a      	ldr	r3, [pc, #424]	; (2404 <encoder_count_chage_left()+0x1f4>)
    225a:	4630      	mov	r0, r6
    225c:	4639      	mov	r1, r7
    225e:	f005 fc3b 	bl	7ad8 <__aeabi_dcmplt>
    2262:	b138      	cbz	r0, 2274 <encoder_count_chage_left()+0x64>
    2264:	2200      	movs	r2, #0
    2266:	4b68      	ldr	r3, [pc, #416]	; (2408 <encoder_count_chage_left()+0x1f8>)
    2268:	4630      	mov	r0, r6
    226a:	4639      	mov	r1, r7
    226c:	f005 fc52 	bl	7b14 <__aeabi_dcmpgt>
    2270:	2800      	cmp	r0, #0
    2272:	d17e      	bne.n	2372 <encoder_count_chage_left()+0x162>
    2274:	4b65      	ldr	r3, [pc, #404]	; (240c <encoder_count_chage_left()+0x1fc>)
    2276:	edd3 7a00 	vldr	s15, [r3]
      encoder_counter_left = encoder_counter_left - 1;
      left_count_tick += -1;
      current_omega_left = -count_to_rad / delta_time_left;
    }
  }
  if (current_omega_left < 20 && current_omega_left > -20) {
    227a:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
    227e:	eef4 7ac7 	vcmpe.f32	s15, s14
    2282:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    2286:	d45a      	bmi.n	233e <encoder_count_chage_left()+0x12e>
    2288:	4d61      	ldr	r5, [pc, #388]	; (2410 <encoder_count_chage_left()+0x200>)
    228a:	4b62      	ldr	r3, [pc, #392]	; (2414 <encoder_count_chage_left()+0x204>)
    228c:	4e62      	ldr	r6, [pc, #392]	; (2418 <encoder_count_chage_left()+0x208>)
    228e:	68d8      	ldr	r0, [r3, #12]
    2290:	6899      	ldr	r1, [r3, #8]
    2292:	6807      	ldr	r7, [r0, #0]
    array_push(speed_array_left, current_omega_left);
  }

  left_tick.data = left_count_tick;
    2294:	4a61      	ldr	r2, [pc, #388]	; (241c <encoder_count_chage_left()+0x20c>)
    2296:	683b      	ldr	r3, [r7, #0]
    2298:	8094      	strh	r4, [r2, #4]
    229a:	42b3      	cmp	r3, r6
    229c:	f040 808c 	bne.w	23b8 <encoder_count_chage_left()+0x1a8>
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    22a0:	2963      	cmp	r1, #99	; 0x63
    22a2:	dd02      	ble.n	22aa <encoder_count_chage_left()+0x9a>
    22a4:	f890 34f8 	ldrb.w	r3, [r0, #1272]	; 0x4f8
    22a8:	b37b      	cbz	r3, 230a <encoder_count_chage_left()+0xfa>
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    22aa:	f341 2607 	sbfx	r6, r1, #8, #8
    22ae:	b2f3      	uxtb	r3, r6

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    22b0:	fa53 f381 	uxtab	r3, r3, r1
    22b4:	f3c4 2207 	ubfx	r2, r4, #8, #8
    22b8:	fa53 f384 	uxtab	r3, r3, r4
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    22bc:	4413      	add	r3, r2
    22be:	43db      	mvns	r3, r3
      union {
        int16_t real;
        uint16_t base;
      } u_data;
      u_data.real = this->data;
      *(outbuffer + offset + 0) = (u_data.base >> (8 * 0)) & 0xFF;
    22c0:	f880 4223 	strb.w	r4, [r0, #547]	; 0x223
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    22c4:	f880 1221 	strb.w	r1, [r0, #545]	; 0x221
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    22c8:	f880 3225 	strb.w	r3, [r0, #549]	; 0x225
      *(outbuffer + offset + 1) = (u_data.base >> (8 * 1)) & 0xFF;
    22cc:	f880 2224 	strb.w	r2, [r0, #548]	; 0x224
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    22d0:	2402      	movs	r4, #2
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    22d2:	23fd      	movs	r3, #253	; 0xfd
    22d4:	6842      	ldr	r2, [r0, #4]
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    22d6:	f880 421e 	strb.w	r4, [r0, #542]	; 0x21e

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    22da:	f04f 0eff 	mov.w	lr, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    22de:	27fe      	movs	r7, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    22e0:	2100      	movs	r1, #0
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    22e2:	f880 6222 	strb.w	r6, [r0, #546]	; 0x222

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    22e6:	f880 e21c 	strb.w	lr, [r0, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    22ea:	f880 721d 	strb.w	r7, [r0, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    22ee:	f880 121f 	strb.w	r1, [r0, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    22f2:	f880 3220 	strb.w	r3, [r0, #544]	; 0x220
    22f6:	6813      	ldr	r3, [r2, #0]
    22f8:	4c49      	ldr	r4, [pc, #292]	; (2420 <encoder_count_chage_left()+0x210>)
    22fa:	685b      	ldr	r3, [r3, #4]
    22fc:	42a3      	cmp	r3, r4
    l += 7;
    message_out[l++] = 255 - (chk % 256);

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    22fe:	f500 7007 	add.w	r0, r0, #540	; 0x21c
    2302:	d15b      	bne.n	23bc <encoder_count_chage_left()+0x1ac>
    2304:	210a      	movs	r1, #10
    2306:	f004 fc6d 	bl	6be4 <usb_serial_write>
    230a:	4b46      	ldr	r3, [pc, #280]	; (2424 <encoder_count_chage_left()+0x214>)
    230c:	ed95 6a00 	vldr	s12, [r5]
  right_tick.data = right_count_tick;
  right_tick_pub.publish(&right_tick);
  average_omega_right = averaging_array(speed_array_right);
}

void encoder_count_chage_left() {
    2310:	ed9f 7a45 	vldr	s14, [pc, #276]	; 2428 <encoder_count_chage_left()+0x218>
    2314:	f103 0210 	add.w	r2, r3, #16
}

float averaging_array(long the_input_array[]) {
  float result = 0;
  for (int x = 0; x < sizeof(the_input_array); x++) {
    result = result + (the_input_array[x] / float_to_long_factor);
    2318:	ecf3 7a01 	vldmia	r3!, {s15}
    231c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  the_input_array[0] = data * float_to_long_factor;
}

float averaging_array(long the_input_array[]) {
  float result = 0;
  for (int x = 0; x < sizeof(the_input_array); x++) {
    2320:	429a      	cmp	r2, r3
    result = result + (the_input_array[x] / float_to_long_factor);
    2322:	eec7 6a86 	vdiv.f32	s13, s15, s12
    2326:	ee37 7a26 	vadd.f32	s14, s14, s13
  the_input_array[0] = data * float_to_long_factor;
}

float averaging_array(long the_input_array[]) {
  float result = 0;
  for (int x = 0; x < sizeof(the_input_array); x++) {
    232a:	d1f5      	bne.n	2318 <encoder_count_chage_left()+0x108>
  }

  left_tick.data = left_count_tick;
  left_tick_pub.publish(&left_tick);

  average_omega_left = averaging_array(speed_array_left);
    232c:	eef5 7a00 	vmov.f32	s15, #80	; 0x3e800000  0.250
    2330:	ee27 7a27 	vmul.f32	s14, s14, s15
    2334:	4b3d      	ldr	r3, [pc, #244]	; (242c <encoder_count_chage_left()+0x21c>)
    2336:	ed83 7a00 	vstr	s14, [r3]
}
    233a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      encoder_counter_left = encoder_counter_left - 1;
      left_count_tick += -1;
      current_omega_left = -count_to_rad / delta_time_left;
    }
  }
  if (current_omega_left < 20 && current_omega_left > -20) {
    233e:	eebb 7a04 	vmov.f32	s14, #180	; 0xc1a00000 -20.0
    2342:	eef4 7ac7 	vcmpe.f32	s15, s14
    2346:	eef1 fa10 	vmrs	APSR_nzcv, fpscr

void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
  }
  the_input_array[0] = data * float_to_long_factor;
    234a:	4d31      	ldr	r5, [pc, #196]	; (2410 <encoder_count_chage_left()+0x200>)
      encoder_counter_left = encoder_counter_left - 1;
      left_count_tick += -1;
      current_omega_left = -count_to_rad / delta_time_left;
    }
  }
  if (current_omega_left < 20 && current_omega_left > -20) {
    234c:	dd9d      	ble.n	228a <encoder_count_chage_left()+0x7a>

void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
  }
  the_input_array[0] = data * float_to_long_factor;
    234e:	ed95 7a00 	vldr	s14, [r5]



void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
    2352:	4b34      	ldr	r3, [pc, #208]	; (2424 <encoder_count_chage_left()+0x214>)
  }
  the_input_array[0] = data * float_to_long_factor;
    2354:	ee67 7a87 	vmul.f32	s15, s15, s14



void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
    2358:	681a      	ldr	r2, [r3, #0]
    235a:	6858      	ldr	r0, [r3, #4]
    235c:	6899      	ldr	r1, [r3, #8]
    235e:	605a      	str	r2, [r3, #4]
  }
  the_input_array[0] = data * float_to_long_factor;
    2360:	eefd 7ae7 	vcvt.s32.f32	s15, s15



void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
    2364:	68da      	ldr	r2, [r3, #12]
    2366:	6098      	str	r0, [r3, #8]
    2368:	60d9      	str	r1, [r3, #12]
  }
  the_input_array[0] = data * float_to_long_factor;
    236a:	edc3 7a00 	vstr	s15, [r3]



void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
    236e:	611a      	str	r2, [r3, #16]
    2370:	e78b      	b.n	228a <encoder_count_chage_left()+0x7a>
void encoder_count_chage_left() {
  delta_time_left = double(micros()) / 1000000 - old_time_left;
  old_time_left = double(micros()) / 1000000;
  int left_count_tick;
  if (encoder_counter_left < counts_per_revolution && encoder_counter_left > -counts_per_revolution) {
    if (direction_indicator_left == 1) {
    2372:	4b2f      	ldr	r3, [pc, #188]	; (2430 <encoder_count_chage_left()+0x220>)
    2374:	681b      	ldr	r3, [r3, #0]
    2376:	2b01      	cmp	r3, #1
    2378:	d025      	beq.n	23c6 <encoder_count_chage_left()+0x1b6>
      encoder_counter_left++;
      left_count_tick += 1;
      current_omega_left = count_to_rad / delta_time_left;
    }
    if (direction_indicator_left == 0) {
    237a:	2b00      	cmp	r3, #0
    237c:	f47f af7a 	bne.w	2274 <encoder_count_chage_left()+0x64>
      encoder_counter_left = encoder_counter_left - 1;
    2380:	2200      	movs	r2, #0
    2382:	4b2c      	ldr	r3, [pc, #176]	; (2434 <encoder_count_chage_left()+0x224>)
    2384:	4630      	mov	r0, r6
    2386:	4639      	mov	r1, r7
    2388:	f004 ff80 	bl	728c <__aeabi_dsub>
      left_count_tick += -1;
      current_omega_left = -count_to_rad / delta_time_left;
    238c:	4b2a      	ldr	r3, [pc, #168]	; (2438 <encoder_count_chage_left()+0x228>)
    238e:	681c      	ldr	r4, [r3, #0]
    2390:	685b      	ldr	r3, [r3, #4]
    2392:	f103 4500 	add.w	r5, r3, #2147483648	; 0x80000000
      encoder_counter_left++;
      left_count_tick += 1;
      current_omega_left = count_to_rad / delta_time_left;
    }
    if (direction_indicator_left == 0) {
      encoder_counter_left = encoder_counter_left - 1;
    2396:	e9c9 0100 	strd	r0, r1, [r9]
      left_count_tick += -1;
      current_omega_left = -count_to_rad / delta_time_left;
    239a:	e9d8 2300 	ldrd	r2, r3, [r8]
    239e:	4620      	mov	r0, r4
    23a0:	4629      	mov	r1, r5
    23a2:	f005 fa51 	bl	7848 <__aeabi_ddiv>
    23a6:	f005 fbe7 	bl	7b78 <__aeabi_d2f>
    23aa:	4b18      	ldr	r3, [pc, #96]	; (240c <encoder_count_chage_left()+0x1fc>)
    23ac:	ee07 0a90 	vmov	s15, r0
      left_count_tick += 1;
      current_omega_left = count_to_rad / delta_time_left;
    }
    if (direction_indicator_left == 0) {
      encoder_counter_left = encoder_counter_left - 1;
      left_count_tick += -1;
    23b0:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
      current_omega_left = -count_to_rad / delta_time_left;
    23b4:	6018      	str	r0, [r3, #0]
    23b6:	e760      	b.n	227a <encoder_count_chage_left()+0x6a>
    23b8:	4798      	blx	r3
    23ba:	e7a6      	b.n	230a <encoder_count_chage_left()+0xfa>
    23bc:	4601      	mov	r1, r0
    23be:	4610      	mov	r0, r2
    23c0:	220a      	movs	r2, #10
    23c2:	4798      	blx	r3
    23c4:	e7a1      	b.n	230a <encoder_count_chage_left()+0xfa>
  delta_time_left = double(micros()) / 1000000 - old_time_left;
  old_time_left = double(micros()) / 1000000;
  int left_count_tick;
  if (encoder_counter_left < counts_per_revolution && encoder_counter_left > -counts_per_revolution) {
    if (direction_indicator_left == 1) {
      encoder_counter_left++;
    23c6:	2200      	movs	r2, #0
    23c8:	4b1a      	ldr	r3, [pc, #104]	; (2434 <encoder_count_chage_left()+0x224>)
      left_count_tick += 1;
      current_omega_left = count_to_rad / delta_time_left;
    23ca:	4c1b      	ldr	r4, [pc, #108]	; (2438 <encoder_count_chage_left()+0x228>)
  delta_time_left = double(micros()) / 1000000 - old_time_left;
  old_time_left = double(micros()) / 1000000;
  int left_count_tick;
  if (encoder_counter_left < counts_per_revolution && encoder_counter_left > -counts_per_revolution) {
    if (direction_indicator_left == 1) {
      encoder_counter_left++;
    23cc:	4630      	mov	r0, r6
    23ce:	4639      	mov	r1, r7
    23d0:	f004 ff5e 	bl	7290 <__adddf3>
      left_count_tick += 1;
      current_omega_left = count_to_rad / delta_time_left;
    23d4:	e9d8 2300 	ldrd	r2, r3, [r8]
  delta_time_left = double(micros()) / 1000000 - old_time_left;
  old_time_left = double(micros()) / 1000000;
  int left_count_tick;
  if (encoder_counter_left < counts_per_revolution && encoder_counter_left > -counts_per_revolution) {
    if (direction_indicator_left == 1) {
      encoder_counter_left++;
    23d8:	e9c9 0100 	strd	r0, r1, [r9]
      left_count_tick += 1;
      current_omega_left = count_to_rad / delta_time_left;
    23dc:	e9d4 0100 	ldrd	r0, r1, [r4]
    23e0:	f005 fa32 	bl	7848 <__aeabi_ddiv>
    23e4:	f005 fbc8 	bl	7b78 <__aeabi_d2f>
    23e8:	4b08      	ldr	r3, [pc, #32]	; (240c <encoder_count_chage_left()+0x1fc>)
    23ea:	ee07 0a90 	vmov	s15, r0
  old_time_left = double(micros()) / 1000000;
  int left_count_tick;
  if (encoder_counter_left < counts_per_revolution && encoder_counter_left > -counts_per_revolution) {
    if (direction_indicator_left == 1) {
      encoder_counter_left++;
      left_count_tick += 1;
    23ee:	2401      	movs	r4, #1
      current_omega_left = count_to_rad / delta_time_left;
    23f0:	6018      	str	r0, [r3, #0]
    23f2:	e742      	b.n	227a <encoder_count_chage_left()+0x6a>
    23f4:	f3af 8000 	nop.w
    23f8:	00000000 	.word	0x00000000
    23fc:	412e8480 	.word	0x412e8480
    2400:	1fff2a60 	.word	0x1fff2a60
    2404:	409e0000 	.word	0x409e0000
    2408:	c09e0000 	.word	0xc09e0000
    240c:	1fff2adc 	.word	0x1fff2adc
    2410:	1fff0818 	.word	0x1fff0818
    2414:	1fff1d38 	.word	0x1fff1d38
    2418:	000026ed 	.word	0x000026ed
    241c:	1fff2ad4 	.word	0x1fff2ad4
    2420:	00000949 	.word	0x00000949
    2424:	1fff1488 	.word	0x1fff1488
    2428:	00000000 	.word	0x00000000
    242c:	1fff1c7c 	.word	0x1fff1c7c
    2430:	1fff1d50 	.word	0x1fff1d50
    2434:	3ff00000 	.word	0x3ff00000
    2438:	1fff0810 	.word	0x1fff0810
    243c:	1fff2ab0 	.word	0x1fff2ab0
    2440:	1fff1470 	.word	0x1fff1470

00002444 <geometry_msgs::Quaternion::deserialize(unsigned char*)>:

    virtual int deserialize(unsigned char *inbuffer) override
    2444:	b5f0      	push	{r4, r5, r6, r7, lr}
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    2446:	79cf      	ldrb	r7, [r1, #7]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    2448:	790d      	ldrb	r5, [r1, #4]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    244a:	798b      	ldrb	r3, [r1, #6]
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    244c:	f891 e005 	ldrb.w	lr, [r1, #5]
    2450:	4606      	mov	r6, r0
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    2452:	013a      	lsls	r2, r7, #4

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    2454:	78c8      	ldrb	r0, [r1, #3]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    2456:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    245a:	012d      	lsls	r5, r5, #4
    245c:	460c      	mov	r4, r1
    245e:	ea45 1010 	orr.w	r0, r5, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    2462:	0519      	lsls	r1, r3, #20

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    2464:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    2468:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    246c:	ea40 300e 	orr.w	r0, r0, lr, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    2470:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    2474:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    2476:	ea41 0100 	orr.w	r1, r1, r0
    247a:	b083      	sub	sp, #12
    {
      int offset = 0;
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->x));
    247c:	f106 0004 	add.w	r0, r6, #4

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    2480:	f000 80fc 	beq.w	267c <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x238>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    2484:	f240 457e 	movw	r5, #1150	; 0x47e
    2488:	42ab      	cmp	r3, r5
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    248a:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    248c:	d941      	bls.n	2512 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0xce>
    248e:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    2492:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    2494:	f027 077f 	bic.w	r7, r7, #127	; 0x7f
    2498:	4313      	orrs	r3, r2
    249a:	ad02      	add	r5, sp, #8
    249c:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
    24a0:	f845 3d04 	str.w	r3, [r5, #-4]!

    memcpy(f, &val, sizeof(val));
    24a4:	2204      	movs	r2, #4
    24a6:	4629      	mov	r1, r5
    24a8:	f003 f884 	bl	55b4 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    24ac:	f894 e00f 	ldrb.w	lr, [r4, #15]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    24b0:	7b27      	ldrb	r7, [r4, #12]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    24b2:	7ba3      	ldrb	r3, [r4, #14]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    24b4:	7ae0      	ldrb	r0, [r4, #11]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    24b6:	f894 c00d 	ldrb.w	ip, [r4, #13]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    24ba:	ea4f 120e 	mov.w	r2, lr, lsl #4
    24be:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    24c2:	013f      	lsls	r7, r7, #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    24c4:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    24c6:	ea47 1010 	orr.w	r0, r7, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    24ca:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    24ce:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    24d2:	ea40 300c 	orr.w	r0, r0, ip, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    24d6:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    24da:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    24dc:	ea41 0100 	orr.w	r1, r1, r0
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->y));
    24e0:	f106 0008 	add.w	r0, r6, #8

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    24e4:	f000 80c1 	beq.w	266a <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x226>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    24e8:	f240 477e 	movw	r7, #1150	; 0x47e
    24ec:	42bb      	cmp	r3, r7
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    24ee:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    24f0:	d81f      	bhi.n	2532 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0xee>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    24f2:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    24f6:	f300 80dc 	bgt.w	26b2 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x26e>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    24fa:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    24fe:	f340 80ee 	ble.w	26de <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x29a>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    2502:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    2506:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    2508:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    250c:	40d1      	lsrs	r1, r2
    250e:	2200      	movs	r2, #0
    2510:	e0ad      	b.n	266e <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x22a>
    else if (exp - 1023 > 127)
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    2512:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    2516:	f300 80d5 	bgt.w	26c4 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x280>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    251a:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    251e:	f340 80e0 	ble.w	26e2 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x29e>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    2522:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    2526:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    2528:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    252c:	40d1      	lsrs	r1, r2
    252e:	2200      	movs	r2, #0
    2530:	e0a6      	b.n	2680 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x23c>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    2532:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    2536:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    2538:	f02e 0e7f 	bic.w	lr, lr, #127	; 0x7f
    253c:	4313      	orrs	r3, r2
    253e:	ea43 630e 	orr.w	r3, r3, lr, lsl #24

    memcpy(f, &val, sizeof(val));
    2542:	2204      	movs	r2, #4
    2544:	4629      	mov	r1, r5
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    2546:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    2548:	f003 f834 	bl	55b4 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    254c:	f894 e017 	ldrb.w	lr, [r4, #23]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    2550:	7d27      	ldrb	r7, [r4, #20]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    2552:	7da3      	ldrb	r3, [r4, #22]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    2554:	7ce0      	ldrb	r0, [r4, #19]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    2556:	f894 c015 	ldrb.w	ip, [r4, #21]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    255a:	ea4f 120e 	mov.w	r2, lr, lsl #4
    255e:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    2562:	013f      	lsls	r7, r7, #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    2564:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    2566:	ea47 1010 	orr.w	r0, r7, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    256a:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    256e:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    2572:	ea40 300c 	orr.w	r0, r0, ip, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    2576:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    257a:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    257c:	ea41 0100 	orr.w	r1, r1, r0
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->z));
    2580:	f106 000c 	add.w	r0, r6, #12

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    2584:	d068      	beq.n	2658 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x214>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    2586:	f240 477e 	movw	r7, #1150	; 0x47e
    258a:	42bb      	cmp	r3, r7
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    258c:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    258e:	d80f      	bhi.n	25b0 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x16c>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    2590:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    2594:	f300 8084 	bgt.w	26a0 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x25c>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    2598:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    259c:	f340 809d 	ble.w	26da <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x296>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    25a0:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    25a4:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    25a6:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    25aa:	40d1      	lsrs	r1, r2
    25ac:	2200      	movs	r2, #0
    25ae:	e055      	b.n	265c <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x218>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    25b0:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    25b4:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    25b6:	f02e 0e7f 	bic.w	lr, lr, #127	; 0x7f
    25ba:	4313      	orrs	r3, r2
    25bc:	ea43 630e 	orr.w	r3, r3, lr, lsl #24

    memcpy(f, &val, sizeof(val));
    25c0:	2204      	movs	r2, #4
    25c2:	4629      	mov	r1, r5
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    25c4:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    25c6:	f002 fff5 	bl	55b4 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    25ca:	7fe7      	ldrb	r7, [r4, #31]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    25cc:	7f20      	ldrb	r0, [r4, #28]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    25ce:	7ee1      	ldrb	r1, [r4, #27]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    25d0:	7fa3      	ldrb	r3, [r4, #30]
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    25d2:	f894 e01d 	ldrb.w	lr, [r4, #29]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    25d6:	013a      	lsls	r2, r7, #4
    25d8:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    25dc:	0100      	lsls	r0, r0, #4
    25de:	ea40 1011 	orr.w	r0, r0, r1, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    25e2:	0519      	lsls	r1, r3, #20

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    25e4:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    25e8:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    25ec:	ea40 340e 	orr.w	r4, r0, lr, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    25f0:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    25f4:	4293      	cmp	r3, r2
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->w));
    25f6:	f106 0010 	add.w	r0, r6, #16

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    25fa:	ea41 0104 	orr.w	r1, r1, r4

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    25fe:	d022      	beq.n	2646 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x202>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    2600:	f240 447e 	movw	r4, #1150	; 0x47e
    2604:	42a3      	cmp	r3, r4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    2606:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    2608:	d80d      	bhi.n	2626 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x1e2>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    260a:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    260e:	dc3e      	bgt.n	268e <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x24a>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    2610:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    2614:	dd5f      	ble.n	26d6 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x292>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    2616:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    261a:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    261c:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    2620:	40d1      	lsrs	r1, r2
    2622:	2200      	movs	r2, #0
    2624:	e011      	b.n	264a <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x206>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    2626:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    262a:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    262c:	f027 077f 	bic.w	r7, r7, #127	; 0x7f
    2630:	4313      	orrs	r3, r2
    2632:	ea43 6307 	orr.w	r3, r3, r7, lsl #24

    memcpy(f, &val, sizeof(val));
    2636:	4629      	mov	r1, r5
    2638:	2204      	movs	r2, #4
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    263a:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    263c:	f002 ffba 	bl	55b4 <memcpy>
     return offset;
    }
    2640:	2020      	movs	r0, #32
    2642:	b003      	add	sp, #12
    2644:	bdf0      	pop	{r4, r5, r6, r7, pc}

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    2646:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    264a:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    264e:	4299      	cmp	r1, r3
    2650:	d024      	beq.n	269c <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x258>
    2652:	1c4b      	adds	r3, r1, #1
    2654:	085b      	lsrs	r3, r3, #1
    2656:	e7e9      	b.n	262c <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x1e8>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    2658:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    265c:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    2660:	4299      	cmp	r1, r3
    2662:	d024      	beq.n	26ae <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x26a>
    2664:	1c4b      	adds	r3, r1, #1
    2666:	085b      	lsrs	r3, r3, #1
    2668:	e7a5      	b.n	25b6 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x172>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    266a:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    266e:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    2672:	4299      	cmp	r1, r3
    2674:	d024      	beq.n	26c0 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x27c>
    2676:	1c4b      	adds	r3, r1, #1
    2678:	085b      	lsrs	r3, r3, #1
    267a:	e75d      	b.n	2538 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0xf4>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    267c:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    2680:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    2684:	4299      	cmp	r1, r3
    2686:	d024      	beq.n	26d2 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x28e>
    2688:	1c4b      	adds	r3, r1, #1
    268a:	085b      	lsrs	r3, r3, #1
    268c:	e702      	b.n	2494 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x50>
    268e:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    2692:	05da      	lsls	r2, r3, #23
    2694:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    2698:	4299      	cmp	r1, r3
    269a:	d1da      	bne.n	2652 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x20e>
    269c:	4b12      	ldr	r3, [pc, #72]	; (26e8 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x2a4>)
    269e:	e7c5      	b.n	262c <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x1e8>
    26a0:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    26a4:	05da      	lsls	r2, r3, #23
    26a6:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    26aa:	4299      	cmp	r1, r3
    26ac:	d1da      	bne.n	2664 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x220>
    26ae:	4b0e      	ldr	r3, [pc, #56]	; (26e8 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x2a4>)
    26b0:	e781      	b.n	25b6 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x172>
    26b2:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    26b6:	05da      	lsls	r2, r3, #23
    26b8:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    26bc:	4299      	cmp	r1, r3
    26be:	d1da      	bne.n	2676 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x232>
    26c0:	4b09      	ldr	r3, [pc, #36]	; (26e8 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x2a4>)
    26c2:	e739      	b.n	2538 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0xf4>
    26c4:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    26c8:	05da      	lsls	r2, r3, #23
    26ca:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    26ce:	4299      	cmp	r1, r3
    26d0:	d1da      	bne.n	2688 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x244>
    26d2:	4b05      	ldr	r3, [pc, #20]	; (26e8 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x2a4>)
    26d4:	e6de      	b.n	2494 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x50>
    }
    else if (exp - 1023 >= -126)
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    26d6:	2200      	movs	r2, #0
    26d8:	e7b7      	b.n	264a <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x206>
    26da:	2200      	movs	r2, #0
    26dc:	e7be      	b.n	265c <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x218>
    26de:	2200      	movs	r2, #0
    26e0:	e7c5      	b.n	266e <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x22a>
    26e2:	2200      	movs	r2, #0
    26e4:	e7cc      	b.n	2680 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x23c>
    26e6:	bf00      	nop
    26e8:	007fffff 	.word	0x007fffff

000026ec <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)>:
      }
    }
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
    26ec:	b5f0      	push	{r4, r5, r6, r7, lr}
  {
    if (id >= 100 && !configured_)
    26ee:	2963      	cmp	r1, #99	; 0x63
      }
    }
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
    26f0:	b085      	sub	sp, #20
  {
    if (id >= 100 && !configured_)
    26f2:	dd03      	ble.n	26fc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x10>
    26f4:	f890 44f8 	ldrb.w	r4, [r0, #1272]	; 0x4f8
    26f8:	2c00      	cmp	r4, #0
    26fa:	d046      	beq.n	278a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x9e>
      return 0;

    /* serialize message */
    int l = msg->serialize(message_out + 7);
    26fc:	6813      	ldr	r3, [r2, #0]
    26fe:	4605      	mov	r5, r0
    2700:	460f      	mov	r7, r1
    2702:	4610      	mov	r0, r2
    2704:	681b      	ldr	r3, [r3, #0]
    2706:	f205 2123 	addw	r1, r5, #547	; 0x223
    270a:	4798      	blx	r3

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    270c:	b2c2      	uxtb	r2, r0
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    270e:	f3c0 2107 	ubfx	r1, r0, #8, #8
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    2712:	1856      	adds	r6, r2, r1
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    2714:	f885 221e 	strb.w	r2, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    2718:	f347 2207 	sbfx	r2, r7, #8, #8
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    271c:	43f6      	mvns	r6, r6

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    271e:	23ff      	movs	r3, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    2720:	f04f 0efe 	mov.w	lr, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    2724:	b2fc      	uxtb	r4, r7
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    2726:	f885 2222 	strb.w	r2, [r5, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    272a:	1c42      	adds	r2, r0, #1
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    272c:	f885 6220 	strb.w	r6, [r5, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    2730:	f885 121f 	strb.w	r1, [r5, #543]	; 0x21f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    2734:	f885 321c 	strb.w	r3, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    2738:	f885 e21d 	strb.w	lr, [r5, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    273c:	f885 4221 	strb.w	r4, [r5, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    2740:	db0d      	blt.n	275e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x72>
    2742:	f200 2122 	addw	r1, r0, #546	; 0x222
    2746:	4429      	add	r1, r5
    2748:	f205 2321 	addw	r3, r5, #545	; 0x221
    274c:	2200      	movs	r2, #0
    274e:	e001      	b.n	2754 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x68>
    2750:	f813 4f01 	ldrb.w	r4, [r3, #1]!
    2754:	428b      	cmp	r3, r1
      chk += message_out[i];
    2756:	4422      	add	r2, r4
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    2758:	d1fa      	bne.n	2750 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x64>
    275a:	43d3      	mvns	r3, r2
    275c:	b2db      	uxtb	r3, r3
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    275e:	182a      	adds	r2, r5, r0
    2760:	f100 0408 	add.w	r4, r0, #8

    if (l <= OUTPUT_SIZE)
    2764:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    2768:	f882 3223 	strb.w	r3, [r2, #547]	; 0x223

    if (l <= OUTPUT_SIZE)
    276c:	dc17      	bgt.n	279e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0xb2>
    276e:	686a      	ldr	r2, [r5, #4]
    2770:	4e35      	ldr	r6, [pc, #212]	; (2848 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x15c>)
    2772:	6813      	ldr	r3, [r2, #0]
    2774:	685b      	ldr	r3, [r3, #4]
    2776:	42b3      	cmp	r3, r6
    {
      hardware_.write(message_out, l);
    2778:	f505 7007 	add.w	r0, r5, #540	; 0x21c
    277c:	d108      	bne.n	2790 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0xa4>
    277e:	4621      	mov	r1, r4
    2780:	f004 fa30 	bl	6be4 <usb_serial_write>
    2784:	4620      	mov	r0, r4
    else
    {
      logerror("Message from device dropped: message larger than buffer.");
      return -1;
    }
  }
    2786:	b005      	add	sp, #20
    2788:	bdf0      	pop	{r4, r5, r6, r7, pc}
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
      return 0;
    278a:	4620      	mov	r0, r4
    else
    {
      logerror("Message from device dropped: message larger than buffer.");
      return -1;
    }
  }
    278c:	b005      	add	sp, #20
    278e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2790:	4601      	mov	r1, r0
    2792:	4610      	mov	r0, r2
    2794:	4622      	mov	r2, r4
    2796:	4798      	blx	r3
    2798:	4620      	mov	r0, r4
    279a:	b005      	add	sp, #20
    279c:	bdf0      	pop	{r4, r5, r6, r7, pc}
      enum { ERROR = 3 };
      enum { FATAL = 4 };

    Log():
      level(0),
      msg("")
    279e:	4a2b      	ldr	r2, [pc, #172]	; (284c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x160>)
protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    27a0:	492b      	ldr	r1, [pc, #172]	; (2850 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x164>)
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    27a2:	682b      	ldr	r3, [r5, #0]
    27a4:	9201      	str	r2, [sp, #4]

protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    27a6:	2003      	movs	r0, #3
    27a8:	f88d 0008 	strb.w	r0, [sp, #8]
    l.msg = (char*)msg;
    27ac:	9103      	str	r1, [sp, #12]
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    27ae:	681b      	ldr	r3, [r3, #0]
    27b0:	4a28      	ldr	r2, [pc, #160]	; (2854 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x168>)
    27b2:	4293      	cmp	r3, r2
    27b4:	d13f      	bne.n	2836 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x14a>
  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
      arr[i] = (var >> (8 * i));
    27b6:	2400      	movs	r4, #0
    27b8:	2238      	movs	r2, #56	; 0x38
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    27ba:	f885 0223 	strb.w	r0, [r5, #547]	; 0x223
    27be:	f885 2224 	strb.w	r2, [r5, #548]	; 0x224
    27c2:	f885 4225 	strb.w	r4, [r5, #549]	; 0x225
    27c6:	f885 4226 	strb.w	r4, [r5, #550]	; 0x226
    27ca:	f885 4227 	strb.w	r4, [r5, #551]	; 0x227
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    27ce:	f505 700a 	add.w	r0, r5, #552	; 0x228
    27d2:	f002 feef 	bl	55b4 <memcpy>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    27d6:	27ff      	movs	r7, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    27d8:	203d      	movs	r0, #61	; 0x3d
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    27da:	23c2      	movs	r3, #194	; 0xc2
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    27dc:	26fe      	movs	r6, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    27de:	2107      	movs	r1, #7
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    27e0:	f885 021e 	strb.w	r0, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    27e4:	f885 3220 	strb.w	r3, [r5, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    27e8:	f885 421f 	strb.w	r4, [r5, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    27ec:	f885 4222 	strb.w	r4, [r5, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    27f0:	4622      	mov	r2, r4

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    27f2:	f885 721c 	strb.w	r7, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    27f6:	f885 621d 	strb.w	r6, [r5, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    27fa:	f885 1221 	strb.w	r1, [r5, #545]	; 0x221
    27fe:	f205 2321 	addw	r3, r5, #545	; 0x221
    2802:	f205 205f 	addw	r0, r5, #607	; 0x25f
    2806:	e001      	b.n	280c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x120>
    2808:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    280c:	4298      	cmp	r0, r3
      chk += message_out[i];
    280e:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    2810:	d1fa      	bne.n	2808 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x11c>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    2812:	43d2      	mvns	r2, r2
    2814:	6868      	ldr	r0, [r5, #4]
    2816:	f885 2260 	strb.w	r2, [r5, #608]	; 0x260
    281a:	6803      	ldr	r3, [r0, #0]
    281c:	4a0a      	ldr	r2, [pc, #40]	; (2848 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x15c>)
    281e:	685b      	ldr	r3, [r3, #4]
    2820:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    2822:	f505 7107 	add.w	r1, r5, #540	; 0x21c
    2826:	d10b      	bne.n	2840 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x154>
    2828:	4608      	mov	r0, r1
    282a:	2145      	movs	r1, #69	; 0x45
    282c:	f004 f9da 	bl	6be4 <usb_serial_write>
    2830:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    2834:	e7a7      	b.n	2786 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x9a>
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    2836:	4628      	mov	r0, r5
    2838:	aa01      	add	r2, sp, #4
    283a:	2107      	movs	r1, #7
    283c:	4798      	blx	r3
    283e:	e7f7      	b.n	2830 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x144>
    2840:	2245      	movs	r2, #69	; 0x45
    2842:	4798      	blx	r3
    2844:	e7f4      	b.n	2830 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x144>
    2846:	bf00      	nop
    2848:	00000949 	.word	0x00000949
    284c:	00008fac 	.word	0x00008fac
    2850:	00009280 	.word	0x00009280
    2854:	000026ed 	.word	0x000026ed

00002858 <setPWM(int, int)>:
  float pwm = a*pow(x,2)+b*x+c;
  int pwm_int = pwm;
  return pwm_int;
}

void setPWM(int pwm_right, int pwm_left) {
    2858:	b570      	push	{r4, r5, r6, lr}
  //setting the correct direction of the motor
  direction_indicator_right = 0;
  direction_indicator_left = 0;
    285a:	4a1e      	ldr	r2, [pc, #120]	; (28d4 <setPWM(int, int)+0x7c>)
  return pwm_int;
}

void setPWM(int pwm_right, int pwm_left) {
  //setting the correct direction of the motor
  direction_indicator_right = 0;
    285c:	4e1e      	ldr	r6, [pc, #120]	; (28d8 <setPWM(int, int)+0x80>)
    285e:	2300      	movs	r3, #0
  direction_indicator_left = 0;
  if(pwm_right > 0){
    2860:	1e05      	subs	r5, r0, #0
  return pwm_int;
}

void setPWM(int pwm_right, int pwm_left) {
  //setting the correct direction of the motor
  direction_indicator_right = 0;
    2862:	6033      	str	r3, [r6, #0]
  direction_indicator_left = 0;
    2864:	6013      	str	r3, [r2, #0]
  if(pwm_right > 0){
    direction_indicator_right = 1;
    2866:	bfc8      	it	gt
    2868:	2301      	movgt	r3, #1
  float pwm = a*pow(x,2)+b*x+c;
  int pwm_int = pwm;
  return pwm_int;
}

void setPWM(int pwm_right, int pwm_left) {
    286a:	460c      	mov	r4, r1
  //setting the correct direction of the motor
  direction_indicator_right = 0;
  direction_indicator_left = 0;
  if(pwm_right > 0){
    direction_indicator_right = 1;
    286c:	bfc8      	it	gt
    286e:	6033      	strgt	r3, [r6, #0]
  }
  if(pwm_left > 0){
    2870:	2900      	cmp	r1, #0
    direction_indicator_left = 1;
  }
  digitalWrite(right_motor_ina, pwm_right >= 0);
    2872:	ea6f 0105 	mvn.w	r1, r5
  direction_indicator_left = 0;
  if(pwm_right > 0){
    direction_indicator_right = 1;
  }
  if(pwm_left > 0){
    direction_indicator_left = 1;
    2876:	bfc8      	it	gt
    2878:	2301      	movgt	r3, #1
  }
  digitalWrite(right_motor_ina, pwm_right >= 0);
    287a:	ea4f 71d1 	mov.w	r1, r1, lsr #31
    287e:	f04f 001e 	mov.w	r0, #30
  direction_indicator_left = 0;
  if(pwm_right > 0){
    direction_indicator_right = 1;
  }
  if(pwm_left > 0){
    direction_indicator_left = 1;
    2882:	bfc8      	it	gt
    2884:	6013      	strgt	r3, [r2, #0]
  }
  digitalWrite(right_motor_ina, pwm_right >= 0);
    2886:	f003 fa75 	bl	5d74 <digitalWrite>
  digitalWrite(right_motor_inb, pwm_right < 0);
    288a:	0fe9      	lsrs	r1, r5, #31
    288c:	201c      	movs	r0, #28
    288e:	f003 fa71 	bl	5d74 <digitalWrite>
  digitalWrite(left_motor_ina, pwm_left >= 0);
    2892:	43e1      	mvns	r1, r4
    2894:	0fc9      	lsrs	r1, r1, #31
    2896:	2027      	movs	r0, #39	; 0x27
    2898:	f003 fa6c 	bl	5d74 <digitalWrite>
  digitalWrite(left_motor_inb, pwm_left < 0);
    289c:	0fe1      	lsrs	r1, r4, #31
    289e:	2025      	movs	r0, #37	; 0x25
    28a0:	f003 fa68 	bl	5d74 <digitalWrite>
  //setting the value of the motor
  pwm_right = abs(pwm_right);
    28a4:	ea85 71e5 	eor.w	r1, r5, r5, asr #31
    28a8:	eba1 71e5 	sub.w	r1, r1, r5, asr #31
  pwm_left = abs(pwm_left);
    28ac:	2c00      	cmp	r4, #0
    28ae:	bfb8      	it	lt
    28b0:	4264      	neglt	r4, r4
    pwm_left = 255;
  }
  if (pwm_right > 255) {
    pwm_right = 255;
  }
  analogWrite(right_motor_pwm, pwm_right);
    28b2:	29ff      	cmp	r1, #255	; 0xff
    28b4:	bfa8      	it	ge
    28b6:	21ff      	movge	r1, #255	; 0xff
    28b8:	201d      	movs	r0, #29
    28ba:	f003 f8bb 	bl	5a34 <analogWrite>
  analogWrite(left_motor_pwm, pwm_left);
    28be:	2cff      	cmp	r4, #255	; 0xff
    28c0:	4621      	mov	r1, r4
    28c2:	f04f 0026 	mov.w	r0, #38	; 0x26
    28c6:	bfa8      	it	ge
    28c8:	21ff      	movge	r1, #255	; 0xff
}
    28ca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  }
  if (pwm_right > 255) {
    pwm_right = 255;
  }
  analogWrite(right_motor_pwm, pwm_right);
  analogWrite(left_motor_pwm, pwm_left);
    28ce:	f003 b8b1 	b.w	5a34 <analogWrite>
    28d2:	bf00      	nop
    28d4:	1fff1d50 	.word	0x1fff1d50
    28d8:	1fff2288 	.word	0x1fff2288

000028dc <RGB_led_set(String const&)>:
    //output_number = map(encoder_count,-counts_per_revolution, counts_per_revolution, -2*pi, 2*pi);
  }
  return output_number;
}

void RGB_led_set(const String& color) {
    28dc:	b510      	push	{r4, lr}
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	//unsigned char equals(const __FlashStringHelper *pgmstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
    28de:	4971      	ldr	r1, [pc, #452]	; (2aa4 <RGB_led_set(String const&)+0x1c8>)
    28e0:	4604      	mov	r4, r0
    28e2:	f004 fb17 	bl	6f14 <String::equals(char const*) const>
  if (color == "red" || color == "Red" || color == "RED") {
    28e6:	2800      	cmp	r0, #0
    28e8:	d07a      	beq.n	29e0 <RGB_led_set(String const&)+0x104>
    digitalWrite(RGB_led_green, HIGH);
    28ea:	2101      	movs	r1, #1
    28ec:	2002      	movs	r0, #2
    28ee:	f003 fa41 	bl	5d74 <digitalWrite>
    digitalWrite(RGB_led_blue, HIGH);
    28f2:	2101      	movs	r1, #1
    28f4:	2003      	movs	r0, #3
    28f6:	f003 fa3d 	bl	5d74 <digitalWrite>
    digitalWrite(RGB_led_red, LOW);
    28fa:	2100      	movs	r1, #0
    28fc:	2004      	movs	r0, #4
    28fe:	f003 fa39 	bl	5d74 <digitalWrite>
    2902:	4969      	ldr	r1, [pc, #420]	; (2aa8 <RGB_led_set(String const&)+0x1cc>)
    2904:	4620      	mov	r0, r4
    2906:	f004 fb05 	bl	6f14 <String::equals(char const*) const>
  }
  if (color == "green" || color == "Green" || color == "GREEN") {
    290a:	2800      	cmp	r0, #0
    290c:	f000 80bb 	beq.w	2a86 <RGB_led_set(String const&)+0x1aa>
    digitalWrite(RGB_led_green, LOW);
    2910:	2100      	movs	r1, #0
    2912:	2002      	movs	r0, #2
    2914:	f003 fa2e 	bl	5d74 <digitalWrite>
    digitalWrite(RGB_led_blue, HIGH);
    2918:	2101      	movs	r1, #1
    291a:	2003      	movs	r0, #3
    291c:	f003 fa2a 	bl	5d74 <digitalWrite>
    digitalWrite(RGB_led_red, HIGH);
    2920:	2101      	movs	r1, #1
    2922:	2004      	movs	r0, #4
    2924:	f003 fa26 	bl	5d74 <digitalWrite>
    2928:	4960      	ldr	r1, [pc, #384]	; (2aac <RGB_led_set(String const&)+0x1d0>)
    292a:	4620      	mov	r0, r4
    292c:	f004 faf2 	bl	6f14 <String::equals(char const*) const>
  }
  if (color == "blue" || color == "Blue" || color == "BLUE") {
    2930:	2800      	cmp	r0, #0
    2932:	f000 8099 	beq.w	2a68 <RGB_led_set(String const&)+0x18c>
    digitalWrite(RGB_led_green, HIGH);
    2936:	2101      	movs	r1, #1
    2938:	2002      	movs	r0, #2
    293a:	f003 fa1b 	bl	5d74 <digitalWrite>
    digitalWrite(RGB_led_blue, LOW);
    293e:	2100      	movs	r1, #0
    2940:	2003      	movs	r0, #3
    2942:	f003 fa17 	bl	5d74 <digitalWrite>
    digitalWrite(RGB_led_red, HIGH);
    2946:	2101      	movs	r1, #1
    2948:	2004      	movs	r0, #4
    294a:	f003 fa13 	bl	5d74 <digitalWrite>
    294e:	4958      	ldr	r1, [pc, #352]	; (2ab0 <RGB_led_set(String const&)+0x1d4>)
    2950:	4620      	mov	r0, r4
    2952:	f004 fadf 	bl	6f14 <String::equals(char const*) const>
  }
  if (color == "cyan" || color == "Cyan" || color == "CYAN") {
    2956:	2800      	cmp	r0, #0
    2958:	d078      	beq.n	2a4c <RGB_led_set(String const&)+0x170>
    digitalWrite(RGB_led_green, LOW);
    295a:	2100      	movs	r1, #0
    295c:	2002      	movs	r0, #2
    295e:	f003 fa09 	bl	5d74 <digitalWrite>
    digitalWrite(RGB_led_blue, LOW);
    2962:	2100      	movs	r1, #0
    2964:	2003      	movs	r0, #3
    2966:	f003 fa05 	bl	5d74 <digitalWrite>
    digitalWrite(RGB_led_red, HIGH);
    296a:	2101      	movs	r1, #1
    296c:	2004      	movs	r0, #4
    296e:	f003 fa01 	bl	5d74 <digitalWrite>
    2972:	4950      	ldr	r1, [pc, #320]	; (2ab4 <RGB_led_set(String const&)+0x1d8>)
    2974:	4620      	mov	r0, r4
    2976:	f004 facd 	bl	6f14 <String::equals(char const*) const>
  }
  if (color == "purple" || color == "Purple" || color == "PURPLE") {
    297a:	2800      	cmp	r0, #0
    297c:	d059      	beq.n	2a32 <RGB_led_set(String const&)+0x156>
    digitalWrite(RGB_led_green, HIGH);
    297e:	2101      	movs	r1, #1
    2980:	2002      	movs	r0, #2
    2982:	f003 f9f7 	bl	5d74 <digitalWrite>
    digitalWrite(RGB_led_blue, LOW);
    2986:	2100      	movs	r1, #0
    2988:	2003      	movs	r0, #3
    298a:	f003 f9f3 	bl	5d74 <digitalWrite>
    digitalWrite(RGB_led_red, LOW);
    298e:	2100      	movs	r1, #0
    2990:	2004      	movs	r0, #4
    2992:	f003 f9ef 	bl	5d74 <digitalWrite>
    2996:	4948      	ldr	r1, [pc, #288]	; (2ab8 <RGB_led_set(String const&)+0x1dc>)
    2998:	4620      	mov	r0, r4
    299a:	f004 fabb 	bl	6f14 <String::equals(char const*) const>
  }
  if (color == "orange" || color == "Orange" || color == "ORANGE") {
    299e:	2800      	cmp	r0, #0
    29a0:	d03a      	beq.n	2a18 <RGB_led_set(String const&)+0x13c>
    digitalWrite(RGB_led_green, LOW);
    29a2:	2100      	movs	r1, #0
    29a4:	2002      	movs	r0, #2
    29a6:	f003 f9e5 	bl	5d74 <digitalWrite>
    digitalWrite(RGB_led_blue, HIGH);
    29aa:	2101      	movs	r1, #1
    29ac:	2003      	movs	r0, #3
    29ae:	f003 f9e1 	bl	5d74 <digitalWrite>
    digitalWrite(RGB_led_red, LOW);
    29b2:	2100      	movs	r1, #0
    29b4:	2004      	movs	r0, #4
    29b6:	f003 f9dd 	bl	5d74 <digitalWrite>
    29ba:	4940      	ldr	r1, [pc, #256]	; (2abc <RGB_led_set(String const&)+0x1e0>)
    29bc:	4620      	mov	r0, r4
    29be:	f004 faa9 	bl	6f14 <String::equals(char const*) const>
  }
  if (color == "white " || color == "White" || color == "WHITE") {
    29c2:	b1e0      	cbz	r0, 29fe <RGB_led_set(String const&)+0x122>
    digitalWrite(RGB_led_green, LOW);
    29c4:	2100      	movs	r1, #0
    29c6:	2002      	movs	r0, #2
    29c8:	f003 f9d4 	bl	5d74 <digitalWrite>
    digitalWrite(RGB_led_blue, LOW);
    29cc:	2100      	movs	r1, #0
    29ce:	2003      	movs	r0, #3
    29d0:	f003 f9d0 	bl	5d74 <digitalWrite>
    digitalWrite(RGB_led_red, LOW);
    29d4:	2100      	movs	r1, #0
    29d6:	2004      	movs	r0, #4
  }
}
    29d8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    digitalWrite(RGB_led_red, LOW);
  }
  if (color == "white " || color == "White" || color == "WHITE") {
    digitalWrite(RGB_led_green, LOW);
    digitalWrite(RGB_led_blue, LOW);
    digitalWrite(RGB_led_red, LOW);
    29dc:	f003 b9ca 	b.w	5d74 <digitalWrite>
    29e0:	4937      	ldr	r1, [pc, #220]	; (2ac0 <RGB_led_set(String const&)+0x1e4>)
    29e2:	4620      	mov	r0, r4
    29e4:	f004 fa96 	bl	6f14 <String::equals(char const*) const>
  }
  return output_number;
}

void RGB_led_set(const String& color) {
  if (color == "red" || color == "Red" || color == "RED") {
    29e8:	2800      	cmp	r0, #0
    29ea:	f47f af7e 	bne.w	28ea <RGB_led_set(String const&)+0xe>
    29ee:	4935      	ldr	r1, [pc, #212]	; (2ac4 <RGB_led_set(String const&)+0x1e8>)
    29f0:	4620      	mov	r0, r4
    29f2:	f004 fa8f 	bl	6f14 <String::equals(char const*) const>
    29f6:	2800      	cmp	r0, #0
    29f8:	f47f af77 	bne.w	28ea <RGB_led_set(String const&)+0xe>
    29fc:	e781      	b.n	2902 <RGB_led_set(String const&)+0x26>
    29fe:	4932      	ldr	r1, [pc, #200]	; (2ac8 <RGB_led_set(String const&)+0x1ec>)
    2a00:	4620      	mov	r0, r4
    2a02:	f004 fa87 	bl	6f14 <String::equals(char const*) const>
  if (color == "orange" || color == "Orange" || color == "ORANGE") {
    digitalWrite(RGB_led_green, LOW);
    digitalWrite(RGB_led_blue, HIGH);
    digitalWrite(RGB_led_red, LOW);
  }
  if (color == "white " || color == "White" || color == "WHITE") {
    2a06:	2800      	cmp	r0, #0
    2a08:	d1dc      	bne.n	29c4 <RGB_led_set(String const&)+0xe8>
    2a0a:	4620      	mov	r0, r4
    2a0c:	492f      	ldr	r1, [pc, #188]	; (2acc <RGB_led_set(String const&)+0x1f0>)
    2a0e:	f004 fa81 	bl	6f14 <String::equals(char const*) const>
    2a12:	2800      	cmp	r0, #0
    2a14:	d1d6      	bne.n	29c4 <RGB_led_set(String const&)+0xe8>
    2a16:	bd10      	pop	{r4, pc}
    2a18:	492d      	ldr	r1, [pc, #180]	; (2ad0 <RGB_led_set(String const&)+0x1f4>)
    2a1a:	4620      	mov	r0, r4
    2a1c:	f004 fa7a 	bl	6f14 <String::equals(char const*) const>
  if (color == "purple" || color == "Purple" || color == "PURPLE") {
    digitalWrite(RGB_led_green, HIGH);
    digitalWrite(RGB_led_blue, LOW);
    digitalWrite(RGB_led_red, LOW);
  }
  if (color == "orange" || color == "Orange" || color == "ORANGE") {
    2a20:	2800      	cmp	r0, #0
    2a22:	d1be      	bne.n	29a2 <RGB_led_set(String const&)+0xc6>
    2a24:	492b      	ldr	r1, [pc, #172]	; (2ad4 <RGB_led_set(String const&)+0x1f8>)
    2a26:	4620      	mov	r0, r4
    2a28:	f004 fa74 	bl	6f14 <String::equals(char const*) const>
    2a2c:	2800      	cmp	r0, #0
    2a2e:	d1b8      	bne.n	29a2 <RGB_led_set(String const&)+0xc6>
    2a30:	e7c3      	b.n	29ba <RGB_led_set(String const&)+0xde>
    2a32:	4929      	ldr	r1, [pc, #164]	; (2ad8 <RGB_led_set(String const&)+0x1fc>)
    2a34:	4620      	mov	r0, r4
    2a36:	f004 fa6d 	bl	6f14 <String::equals(char const*) const>
  if (color == "cyan" || color == "Cyan" || color == "CYAN") {
    digitalWrite(RGB_led_green, LOW);
    digitalWrite(RGB_led_blue, LOW);
    digitalWrite(RGB_led_red, HIGH);
  }
  if (color == "purple" || color == "Purple" || color == "PURPLE") {
    2a3a:	2800      	cmp	r0, #0
    2a3c:	d19f      	bne.n	297e <RGB_led_set(String const&)+0xa2>
    2a3e:	4927      	ldr	r1, [pc, #156]	; (2adc <RGB_led_set(String const&)+0x200>)
    2a40:	4620      	mov	r0, r4
    2a42:	f004 fa67 	bl	6f14 <String::equals(char const*) const>
    2a46:	2800      	cmp	r0, #0
    2a48:	d199      	bne.n	297e <RGB_led_set(String const&)+0xa2>
    2a4a:	e7a4      	b.n	2996 <RGB_led_set(String const&)+0xba>
    2a4c:	4924      	ldr	r1, [pc, #144]	; (2ae0 <RGB_led_set(String const&)+0x204>)
    2a4e:	4620      	mov	r0, r4
    2a50:	f004 fa60 	bl	6f14 <String::equals(char const*) const>
  if (color == "blue" || color == "Blue" || color == "BLUE") {
    digitalWrite(RGB_led_green, HIGH);
    digitalWrite(RGB_led_blue, LOW);
    digitalWrite(RGB_led_red, HIGH);
  }
  if (color == "cyan" || color == "Cyan" || color == "CYAN") {
    2a54:	2800      	cmp	r0, #0
    2a56:	d180      	bne.n	295a <RGB_led_set(String const&)+0x7e>
    2a58:	4922      	ldr	r1, [pc, #136]	; (2ae4 <RGB_led_set(String const&)+0x208>)
    2a5a:	4620      	mov	r0, r4
    2a5c:	f004 fa5a 	bl	6f14 <String::equals(char const*) const>
    2a60:	2800      	cmp	r0, #0
    2a62:	f47f af7a 	bne.w	295a <RGB_led_set(String const&)+0x7e>
    2a66:	e784      	b.n	2972 <RGB_led_set(String const&)+0x96>
    2a68:	491f      	ldr	r1, [pc, #124]	; (2ae8 <RGB_led_set(String const&)+0x20c>)
    2a6a:	4620      	mov	r0, r4
    2a6c:	f004 fa52 	bl	6f14 <String::equals(char const*) const>
  if (color == "green" || color == "Green" || color == "GREEN") {
    digitalWrite(RGB_led_green, LOW);
    digitalWrite(RGB_led_blue, HIGH);
    digitalWrite(RGB_led_red, HIGH);
  }
  if (color == "blue" || color == "Blue" || color == "BLUE") {
    2a70:	2800      	cmp	r0, #0
    2a72:	f47f af60 	bne.w	2936 <RGB_led_set(String const&)+0x5a>
    2a76:	491d      	ldr	r1, [pc, #116]	; (2aec <RGB_led_set(String const&)+0x210>)
    2a78:	4620      	mov	r0, r4
    2a7a:	f004 fa4b 	bl	6f14 <String::equals(char const*) const>
    2a7e:	2800      	cmp	r0, #0
    2a80:	f47f af59 	bne.w	2936 <RGB_led_set(String const&)+0x5a>
    2a84:	e763      	b.n	294e <RGB_led_set(String const&)+0x72>
    2a86:	491a      	ldr	r1, [pc, #104]	; (2af0 <RGB_led_set(String const&)+0x214>)
    2a88:	4620      	mov	r0, r4
    2a8a:	f004 fa43 	bl	6f14 <String::equals(char const*) const>
  if (color == "red" || color == "Red" || color == "RED") {
    digitalWrite(RGB_led_green, HIGH);
    digitalWrite(RGB_led_blue, HIGH);
    digitalWrite(RGB_led_red, LOW);
  }
  if (color == "green" || color == "Green" || color == "GREEN") {
    2a8e:	2800      	cmp	r0, #0
    2a90:	f47f af3e 	bne.w	2910 <RGB_led_set(String const&)+0x34>
    2a94:	4917      	ldr	r1, [pc, #92]	; (2af4 <RGB_led_set(String const&)+0x218>)
    2a96:	4620      	mov	r0, r4
    2a98:	f004 fa3c 	bl	6f14 <String::equals(char const*) const>
    2a9c:	2800      	cmp	r0, #0
    2a9e:	f47f af37 	bne.w	2910 <RGB_led_set(String const&)+0x34>
    2aa2:	e741      	b.n	2928 <RGB_led_set(String const&)+0x4c>
    2aa4:	000092bc 	.word	0x000092bc
    2aa8:	000092c8 	.word	0x000092c8
    2aac:	000092e0 	.word	0x000092e0
    2ab0:	000092f8 	.word	0x000092f8
    2ab4:	00009310 	.word	0x00009310
    2ab8:	00009328 	.word	0x00009328
    2abc:	00009340 	.word	0x00009340
    2ac0:	000092c0 	.word	0x000092c0
    2ac4:	000092c4 	.word	0x000092c4
    2ac8:	00009348 	.word	0x00009348
    2acc:	00009350 	.word	0x00009350
    2ad0:	00009330 	.word	0x00009330
    2ad4:	00009338 	.word	0x00009338
    2ad8:	00009318 	.word	0x00009318
    2adc:	00009320 	.word	0x00009320
    2ae0:	00009300 	.word	0x00009300
    2ae4:	00009308 	.word	0x00009308
    2ae8:	000092e8 	.word	0x000092e8
    2aec:	000092f0 	.word	0x000092f0
    2af0:	000092d0 	.word	0x000092d0
    2af4:	000092d8 	.word	0x000092d8

00002af8 <start_up_hi(std_msgs::Int16&)>:

  //speed_pub.publish(&wheel_speed);
  setPWM(pwm_procent_right, pwm_procent_left);
}

void start_up_hi(std_msgs::Int16& num){
    2af8:	b510      	push	{r4, lr}
  hi = num.data;
    2afa:	f9b0 3004 	ldrsh.w	r3, [r0, #4]
    2afe:	4c0f      	ldr	r4, [pc, #60]	; (2b3c <start_up_hi(std_msgs::Int16&)+0x44>)
  if (hi == 1){
    2b00:	2b01      	cmp	r3, #1

  //speed_pub.publish(&wheel_speed);
  setPWM(pwm_procent_right, pwm_procent_left);
}

void start_up_hi(std_msgs::Int16& num){
    2b02:	b084      	sub	sp, #16
  hi = num.data;
    2b04:	6023      	str	r3, [r4, #0]
  if (hi == 1){
    2b06:	d00c      	beq.n	2b22 <start_up_hi(std_msgs::Int16&)+0x2a>
    RGB_led_set("green");
  }
  if (hi == 0){
    2b08:	b94b      	cbnz	r3, 2b1e <start_up_hi(std_msgs::Int16&)+0x26>
    RGB_led_set("red");
    2b0a:	490d      	ldr	r1, [pc, #52]	; (2b40 <start_up_hi(std_msgs::Int16&)+0x48>)
    2b0c:	4668      	mov	r0, sp
    2b0e:	f004 f9ed 	bl	6eec <String::String(char const*)>
    2b12:	4668      	mov	r0, sp
    2b14:	f7ff fee2 	bl	28dc <RGB_led_set(String const&)>
    2b18:	4668      	mov	r0, sp
    2b1a:	f004 f9a7 	bl	6e6c <String::~String()>
  }
}
    2b1e:	b004      	add	sp, #16
    2b20:	bd10      	pop	{r4, pc}
}

void start_up_hi(std_msgs::Int16& num){
  hi = num.data;
  if (hi == 1){
    RGB_led_set("green");
    2b22:	4908      	ldr	r1, [pc, #32]	; (2b44 <start_up_hi(std_msgs::Int16&)+0x4c>)
    2b24:	4668      	mov	r0, sp
    2b26:	f004 f9e1 	bl	6eec <String::String(char const*)>
    2b2a:	4668      	mov	r0, sp
    2b2c:	f7ff fed6 	bl	28dc <RGB_led_set(String const&)>
    2b30:	4668      	mov	r0, sp
    2b32:	f004 f99b 	bl	6e6c <String::~String()>
    2b36:	6823      	ldr	r3, [r4, #0]
    2b38:	e7e6      	b.n	2b08 <start_up_hi(std_msgs::Int16&)+0x10>
    2b3a:	bf00      	nop
    2b3c:	1fff1ca0 	.word	0x1fff1ca0
    2b40:	000092bc 	.word	0x000092bc
    2b44:	000092c8 	.word	0x000092c8

00002b48 <wheel_speed_set(double, double, bool)>:
  }
  analogWrite(right_motor_pwm, pwm_right);
  analogWrite(left_motor_pwm, pwm_left);
}

void wheel_speed_set(double input_vel_x, double input_omega, bool tele_op){
    2b48:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    2b4c:	b089      	sub	sp, #36	; 0x24
  double error_omega_left;
  double control_right;
  double control_left;

  if (tele_op = true){
    RGB_led_set("blue");
    2b4e:	493c      	ldr	r1, [pc, #240]	; (2c40 <wheel_speed_set(double, double, bool)+0xf8>)

    previous_time = current_time;
    last_error_right = error_omega_right;
    last_error_left = error_omega_left;
  }
  wheel_speed.x = average_omega_right;
    2b50:	4c3c      	ldr	r4, [pc, #240]	; (2c44 <wheel_speed_set(double, double, bool)+0xfc>)
  double error_omega_left;
  double control_right;
  double control_left;

  if (tele_op = true){
    RGB_led_set("blue");
    2b52:	a804      	add	r0, sp, #16
  }
  analogWrite(right_motor_pwm, pwm_right);
  analogWrite(left_motor_pwm, pwm_left);
}

void wheel_speed_set(double input_vel_x, double input_omega, bool tele_op){
    2b54:	ed8d 1b00 	vstr	d1, [sp]
    2b58:	ed8d 0b02 	vstr	d0, [sp, #8]
  double error_omega_left;
  double control_right;
  double control_left;

  if (tele_op = true){
    RGB_led_set("blue");
    2b5c:	f004 f9c6 	bl	6eec <String::String(char const*)>
    2b60:	a804      	add	r0, sp, #16
    2b62:	f7ff febb 	bl	28dc <RGB_led_set(String const&)>
    2b66:	a804      	add	r0, sp, #16
    2b68:	f004 f980 	bl	6e6c <String::~String()>

    vel_x_goal = input_vel_x * 75;
    2b6c:	ed9d 0b02 	vldr	d0, [sp, #8]
    2b70:	a32f      	add	r3, pc, #188	; (adr r3, 2c30 <wheel_speed_set(double, double, bool)+0xe8>)
    2b72:	e9d3 2300 	ldrd	r2, r3, [r3]
    2b76:	ec51 0b10 	vmov	r0, r1, d0
    2b7a:	f004 fd3b 	bl	75f4 <__aeabi_dmul>
    goal_omega = input_omega * 50;
    2b7e:	ed9d 1b00 	vldr	d1, [sp]
  double control_left;

  if (tele_op = true){
    RGB_led_set("blue");

    vel_x_goal = input_vel_x * 75;
    2b82:	4606      	mov	r6, r0
    2b84:	460f      	mov	r7, r1
    goal_omega = input_omega * 50;
    2b86:	2200      	movs	r2, #0
    2b88:	ec51 0b11 	vmov	r0, r1, d1
    2b8c:	4b2e      	ldr	r3, [pc, #184]	; (2c48 <wheel_speed_set(double, double, bool)+0x100>)
    2b8e:	f004 fd31 	bl	75f4 <__aeabi_dmul>
    2b92:	4680      	mov	r8, r0
    2b94:	4689      	mov	r9, r1
    goal_omega_right = vel_x_goal + goal_omega;
    goal_omega_left = vel_x_goal - goal_omega;
    pwm_procent_right = int(map(goal_omega_right, 0, 100, 0, 255));
    2b96:	4602      	mov	r2, r0
    2b98:	460b      	mov	r3, r1
    2b9a:	4630      	mov	r0, r6
    2b9c:	4639      	mov	r1, r7
    2b9e:	f004 fb77 	bl	7290 <__adddf3>
    2ba2:	a325      	add	r3, pc, #148	; (adr r3, 2c38 <wheel_speed_set(double, double, bool)+0xf0>)
    2ba4:	e9d3 2300 	ldrd	r2, r3, [r3]
    2ba8:	f004 fd24 	bl	75f4 <__aeabi_dmul>
    2bac:	2200      	movs	r2, #0
    2bae:	4b27      	ldr	r3, [pc, #156]	; (2c4c <wheel_speed_set(double, double, bool)+0x104>)
    2bb0:	f004 fe4a 	bl	7848 <__aeabi_ddiv>
    2bb4:	2200      	movs	r2, #0
    2bb6:	2300      	movs	r3, #0
    2bb8:	f004 fb6a 	bl	7290 <__adddf3>
    2bbc:	f004 ffb4 	bl	7b28 <__aeabi_d2iz>
    2bc0:	f8df e0a0 	ldr.w	lr, [pc, #160]	; 2c64 <wheel_speed_set(double, double, bool)+0x11c>
    2bc4:	4605      	mov	r5, r0
    2bc6:	f8ce 5000 	str.w	r5, [lr]
    pwm_procent_left = int(map(goal_omega_left, 0, 100, 0, 255));
    2bca:	4642      	mov	r2, r8
    2bcc:	464b      	mov	r3, r9
    2bce:	4630      	mov	r0, r6
    2bd0:	4639      	mov	r1, r7
    2bd2:	f004 fb5b 	bl	728c <__aeabi_dsub>
    2bd6:	a318      	add	r3, pc, #96	; (adr r3, 2c38 <wheel_speed_set(double, double, bool)+0xf0>)
    2bd8:	e9d3 2300 	ldrd	r2, r3, [r3]
    2bdc:	f004 fd0a 	bl	75f4 <__aeabi_dmul>
    2be0:	2200      	movs	r2, #0
    2be2:	4b1a      	ldr	r3, [pc, #104]	; (2c4c <wheel_speed_set(double, double, bool)+0x104>)
    2be4:	f004 fe30 	bl	7848 <__aeabi_ddiv>
    2be8:	2200      	movs	r2, #0
    2bea:	2300      	movs	r3, #0
    2bec:	f004 fb50 	bl	7290 <__adddf3>
    2bf0:	f004 ff9a 	bl	7b28 <__aeabi_d2iz>

    previous_time = current_time;
    last_error_right = error_omega_right;
    last_error_left = error_omega_left;
  }
  wheel_speed.x = average_omega_right;
    2bf4:	4a16      	ldr	r2, [pc, #88]	; (2c50 <wheel_speed_set(double, double, bool)+0x108>)
  wheel_speed.y = average_omega_left;
    2bf6:	4b17      	ldr	r3, [pc, #92]	; (2c54 <wheel_speed_set(double, double, bool)+0x10c>)
  wheel_speed.z = encoder_counter_right;
    2bf8:	4917      	ldr	r1, [pc, #92]	; (2c58 <wheel_speed_set(double, double, bool)+0x110>)

    previous_time = current_time;
    last_error_right = error_omega_right;
    last_error_left = error_omega_left;
  }
  wheel_speed.x = average_omega_right;
    2bfa:	6812      	ldr	r2, [r2, #0]
  wheel_speed.y = average_omega_left;
    2bfc:	681b      	ldr	r3, [r3, #0]

    previous_time = current_time;
    last_error_right = error_omega_right;
    last_error_left = error_omega_left;
  }
  wheel_speed.x = average_omega_right;
    2bfe:	6062      	str	r2, [r4, #4]
    vel_x_goal = input_vel_x * 75;
    goal_omega = input_omega * 50;
    goal_omega_right = vel_x_goal + goal_omega;
    goal_omega_left = vel_x_goal - goal_omega;
    pwm_procent_right = int(map(goal_omega_right, 0, 100, 0, 255));
    pwm_procent_left = int(map(goal_omega_left, 0, 100, 0, 255));
    2c00:	4606      	mov	r6, r0
    2c02:	4816      	ldr	r0, [pc, #88]	; (2c5c <wheel_speed_set(double, double, bool)+0x114>)
    previous_time = current_time;
    last_error_right = error_omega_right;
    last_error_left = error_omega_left;
  }
  wheel_speed.x = average_omega_right;
  wheel_speed.y = average_omega_left;
    2c04:	60a3      	str	r3, [r4, #8]
    vel_x_goal = input_vel_x * 75;
    goal_omega = input_omega * 50;
    goal_omega_right = vel_x_goal + goal_omega;
    goal_omega_left = vel_x_goal - goal_omega;
    pwm_procent_right = int(map(goal_omega_right, 0, 100, 0, 255));
    pwm_procent_left = int(map(goal_omega_left, 0, 100, 0, 255));
    2c06:	6006      	str	r6, [r0, #0]
    last_error_right = error_omega_right;
    last_error_left = error_omega_left;
  }
  wheel_speed.x = average_omega_right;
  wheel_speed.y = average_omega_left;
  wheel_speed.z = encoder_counter_right;
    2c08:	e9d1 0100 	ldrd	r0, r1, [r1]
    2c0c:	f004 ffb4 	bl	7b78 <__aeabi_d2f>
  wheel_speed.w = encoder_counter_left;
    2c10:	4b13      	ldr	r3, [pc, #76]	; (2c60 <wheel_speed_set(double, double, bool)+0x118>)
    last_error_right = error_omega_right;
    last_error_left = error_omega_left;
  }
  wheel_speed.x = average_omega_right;
  wheel_speed.y = average_omega_left;
  wheel_speed.z = encoder_counter_right;
    2c12:	60e0      	str	r0, [r4, #12]
  wheel_speed.w = encoder_counter_left;
    2c14:	e9d3 0100 	ldrd	r0, r1, [r3]
    2c18:	f004 ffae 	bl	7b78 <__aeabi_d2f>

  //speed_pub.publish(&wheel_speed);
  setPWM(pwm_procent_right, pwm_procent_left);
    2c1c:	4631      	mov	r1, r6
    last_error_left = error_omega_left;
  }
  wheel_speed.x = average_omega_right;
  wheel_speed.y = average_omega_left;
  wheel_speed.z = encoder_counter_right;
  wheel_speed.w = encoder_counter_left;
    2c1e:	6120      	str	r0, [r4, #16]

  //speed_pub.publish(&wheel_speed);
  setPWM(pwm_procent_right, pwm_procent_left);
    2c20:	4628      	mov	r0, r5
    2c22:	f7ff fe19 	bl	2858 <setPWM(int, int)>
}
    2c26:	b009      	add	sp, #36	; 0x24
    2c28:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    2c2c:	f3af 8000 	nop.w
    2c30:	00000000 	.word	0x00000000
    2c34:	4052c000 	.word	0x4052c000
    2c38:	00000000 	.word	0x00000000
    2c3c:	406fe000 	.word	0x406fe000
    2c40:	000092e0 	.word	0x000092e0
    2c44:	1fff2a98 	.word	0x1fff2a98
    2c48:	40490000 	.word	0x40490000
    2c4c:	40590000 	.word	0x40590000
    2c50:	1fff146c 	.word	0x1fff146c
    2c54:	1fff1c7c 	.word	0x1fff1c7c
    2c58:	1fff1d20 	.word	0x1fff1d20
    2c5c:	1fff1d28 	.word	0x1fff1d28
    2c60:	1fff1470 	.word	0x1fff1470
    2c64:	1fff1d4c 	.word	0x1fff1d4c

00002c68 <cmd_velocity(geometry_msgs::Twist&)>:
  if (hi == 0){
    RGB_led_set("red");
  }
}

void cmd_velocity(geometry_msgs::Twist& cmd_goal) {
    2c68:	b510      	push	{r4, lr}
    2c6a:	4604      	mov	r4, r0
    2c6c:	b082      	sub	sp, #8
  double goal_vel_x = cmd_goal.linear.x;
    2c6e:	6880      	ldr	r0, [r0, #8]
    2c70:	f004 fc6c 	bl	754c <__aeabi_f2d>
    2c74:	e9cd 0100 	strd	r0, r1, [sp]
  double goal_omega = cmd_goal.angular.z;
    2c78:	6a20      	ldr	r0, [r4, #32]
    2c7a:	f004 fc67 	bl	754c <__aeabi_f2d>
  if (cmd_goal.angular.x == 0 || cmd_goal.angular.x == -0){ // here if this is true that means that the robot is being teleoperated
    2c7e:	edd4 7a06 	vldr	s15, [r4, #24]
    bool_tele_op_toggel = true;
    2c82:	4b09      	ldr	r3, [pc, #36]	; (2ca8 <cmd_velocity(geometry_msgs::Twist&)+0x40>)
}

void cmd_velocity(geometry_msgs::Twist& cmd_goal) {
  double goal_vel_x = cmd_goal.linear.x;
  double goal_omega = cmd_goal.angular.z;
  if (cmd_goal.angular.x == 0 || cmd_goal.angular.x == -0){ // here if this is true that means that the robot is being teleoperated
    2c84:	eef5 7a40 	vcmp.f32	s15, #0.0
    2c88:	ed9d 0b00 	vldr	d0, [sp]
  }
}

void cmd_velocity(geometry_msgs::Twist& cmd_goal) {
  double goal_vel_x = cmd_goal.linear.x;
  double goal_omega = cmd_goal.angular.z;
    2c8c:	ec41 0b11 	vmov	d1, r0, r1
  if (cmd_goal.angular.x == 0 || cmd_goal.angular.x == -0){ // here if this is true that means that the robot is being teleoperated
    2c90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    bool_tele_op_toggel = true;
    2c94:	bf0c      	ite	eq
    2c96:	2001      	moveq	r0, #1
  }
  else{
    bool_tele_op_toggel = false;
    2c98:	2000      	movne	r0, #0
    2c9a:	7018      	strb	r0, [r3, #0]
  }
  //if(tele_op_toggel == 0.5 || tele_op_toggel == -0.5){
  //  bool_tele_op_toggel = !bool_tele_op_toggel;
  //}
  wheel_speed_set(goal_vel_x, goal_omega, bool_tele_op_toggel);
}
    2c9c:	b002      	add	sp, #8
    2c9e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    bool_tele_op_toggel = false;
  }
  //if(tele_op_toggel == 0.5 || tele_op_toggel == -0.5){
  //  bool_tele_op_toggel = !bool_tele_op_toggel;
  //}
  wheel_speed_set(goal_vel_x, goal_omega, bool_tele_op_toggel);
    2ca2:	f7ff bf51 	b.w	2b48 <wheel_speed_set(double, double, bool)>
    2ca6:	bf00      	nop
    2ca8:	1fff080c 	.word	0x1fff080c

00002cac <setup>:

// Subscribers //
ros::Subscriber<geometry_msgs::Twist> sub_cmd_vel("cmd_vel", &cmd_velocity);
ros::Subscriber<std_msgs::Int16> start_up("stat_up_done", &start_up_hi);

void setup() {
    2cac:	b530      	push	{r4, r5, lr}
    2cae:	2108      	movs	r1, #8
    2cb0:	b085      	sub	sp, #20
    2cb2:	488d      	ldr	r0, [pc, #564]	; (2ee8 <setup+0x23c>)

  /* Start serial, initialize buffers */
  void initNode()
  {
    hardware_.init();
    mode_ = 0;
    2cb4:	4d8d      	ldr	r5, [pc, #564]	; (2eec <setup+0x240>)
    2cb6:	f003 ff95 	bl	6be4 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    2cba:	488d      	ldr	r0, [pc, #564]	; (2ef0 <setup+0x244>)
    2cbc:	f004 f8c2 	bl	6e44 <Print::println()>
    2cc0:	2400      	movs	r4, #0
  Serial.begin(9600);
  Serial.println("Start up");
  nh.initNode();
  pinMode(RGB_led_green, OUTPUT);
    2cc2:	2101      	movs	r1, #1
    2cc4:	2002      	movs	r0, #2
    2cc6:	f8c5 44e4 	str.w	r4, [r5, #1252]	; 0x4e4
    bytes_ = 0;
    2cca:	f8c5 44e8 	str.w	r4, [r5, #1256]	; 0x4e8
    index_ = 0;
    2cce:	f8c5 44f0 	str.w	r4, [r5, #1264]	; 0x4f0
    topic_ = 0;
    2cd2:	f8c5 44ec 	str.w	r4, [r5, #1260]	; 0x4ec
    2cd6:	f003 f853 	bl	5d80 <pinMode>
  pinMode(RGB_led_blue, OUTPUT);
    2cda:	2101      	movs	r1, #1
    2cdc:	2003      	movs	r0, #3
    2cde:	f003 f84f 	bl	5d80 <pinMode>
  pinMode(RGB_led_red, OUTPUT);
    2ce2:	2101      	movs	r1, #1
    2ce4:	2004      	movs	r0, #4
    2ce6:	f003 f84b 	bl	5d80 <pinMode>
  pinMode(right_motor_pwm, OUTPUT);
    2cea:	2101      	movs	r1, #1
    2cec:	201d      	movs	r0, #29
    2cee:	f003 f847 	bl	5d80 <pinMode>
  pinMode(right_motor_ina, OUTPUT);
    2cf2:	2101      	movs	r1, #1
    2cf4:	201e      	movs	r0, #30
    2cf6:	f003 f843 	bl	5d80 <pinMode>
  pinMode(right_motor_inb, OUTPUT);
    2cfa:	2101      	movs	r1, #1
    2cfc:	201c      	movs	r0, #28
    2cfe:	f003 f83f 	bl	5d80 <pinMode>
  pinMode(right_encoder_a, INPUT_PULLUP);
    2d02:	2102      	movs	r1, #2
    2d04:	2018      	movs	r0, #24
    2d06:	f003 f83b 	bl	5d80 <pinMode>
  pinMode(right_encoder_b, INPUT_PULLUP);
    2d0a:	2102      	movs	r1, #2
    2d0c:	2019      	movs	r0, #25
    2d0e:	f003 f837 	bl	5d80 <pinMode>
  pinMode(left_motor_pwm, OUTPUT);
    2d12:	2101      	movs	r1, #1
    2d14:	2026      	movs	r0, #38	; 0x26
    2d16:	f003 f833 	bl	5d80 <pinMode>
  pinMode(left_motor_ina, OUTPUT);
    2d1a:	2101      	movs	r1, #1
    2d1c:	2027      	movs	r0, #39	; 0x27
    2d1e:	f003 f82f 	bl	5d80 <pinMode>
  pinMode(left_motor_inb, OUTPUT);
    2d22:	2101      	movs	r1, #1
    2d24:	2025      	movs	r0, #37	; 0x25
    2d26:	f003 f82b 	bl	5d80 <pinMode>
  pinMode(left_encoder_a, INPUT_PULLUP);
    2d2a:	2102      	movs	r1, #2
    2d2c:	2021      	movs	r0, #33	; 0x21
    2d2e:	f003 f827 	bl	5d80 <pinMode>
  pinMode(left_encoder_b, INPUT_PULLUP);
    2d32:	2102      	movs	r1, #2
    2d34:	2022      	movs	r0, #34	; 0x22
    2d36:	f003 f823 	bl	5d80 <pinMode>
  attachInterrupt(digitalPinToInterrupt(right_encoder_a), encoder_count_chage_right, CHANGE);
    2d3a:	2204      	movs	r2, #4
    2d3c:	496d      	ldr	r1, [pc, #436]	; (2ef4 <setup+0x248>)
    2d3e:	2018      	movs	r0, #24
    2d40:	f002 fdea 	bl	5918 <attachInterrupt>
  attachInterrupt(digitalPinToInterrupt(right_encoder_b), encoder_count_chage_right, CHANGE);
    2d44:	2204      	movs	r2, #4
    2d46:	496b      	ldr	r1, [pc, #428]	; (2ef4 <setup+0x248>)
    2d48:	2019      	movs	r0, #25
    2d4a:	f002 fde5 	bl	5918 <attachInterrupt>
  attachInterrupt(digitalPinToInterrupt(left_encoder_a), encoder_count_chage_left, CHANGE);
    2d4e:	2204      	movs	r2, #4
    2d50:	4969      	ldr	r1, [pc, #420]	; (2ef8 <setup+0x24c>)
    2d52:	2021      	movs	r0, #33	; 0x21
    2d54:	f002 fde0 	bl	5918 <attachInterrupt>
  attachInterrupt(digitalPinToInterrupt(left_encoder_b), encoder_count_chage_left, CHANGE);
    2d58:	2204      	movs	r2, #4
    2d5a:	4967      	ldr	r1, [pc, #412]	; (2ef8 <setup+0x24c>)
    2d5c:	2022      	movs	r0, #34	; 0x22
    2d5e:	f002 fddb 	bl	5918 <attachInterrupt>
  RGB_led_set("white");
    2d62:	4966      	ldr	r1, [pc, #408]	; (2efc <setup+0x250>)
    2d64:	4668      	mov	r0, sp
    2d66:	f004 f8c1 	bl	6eec <String::String(char const*)>
    2d6a:	4668      	mov	r0, sp
    2d6c:	f7ff fdb6 	bl	28dc <RGB_led_set(String const&)>
    2d70:	4668      	mov	r0, sp
    2d72:	f004 f87b 	bl	6e6c <String::~String()>
    2d76:	f205 427c 	addw	r2, r5, #1148	; 0x47c
  }

  /* Register a new subscriber */
  bool subscribe(Subscriber_& s)
  {
    for (int i = 0; i < MAX_SUBSCRIBERS; i++)
    2d7a:	4623      	mov	r3, r4
    2d7c:	4611      	mov	r1, r2
    2d7e:	e002      	b.n	2d86 <setup+0xda>
    2d80:	3301      	adds	r3, #1
    2d82:	2b19      	cmp	r3, #25
    2d84:	d00a      	beq.n	2d9c <setup+0xf0>
    {
      if (subscribers[i] == 0) // empty slot
    2d86:	f851 0f04 	ldr.w	r0, [r1, #4]!
    2d8a:	2800      	cmp	r0, #0
    2d8c:	d1f8      	bne.n	2d80 <setup+0xd4>
      {
        subscribers[i] = &s;
    2d8e:	f503 7090 	add.w	r0, r3, #288	; 0x120
    2d92:	495b      	ldr	r1, [pc, #364]	; (2f00 <setup+0x254>)
    2d94:	f845 1020 	str.w	r1, [r5, r0, lsl #2]
        s.id_ = i + 100;
    2d98:	3364      	adds	r3, #100	; 0x64
    2d9a:	604b      	str	r3, [r1, #4]
  }

  /* Register a new subscriber */
  bool subscribe(Subscriber_& s)
  {
    for (int i = 0; i < MAX_SUBSCRIBERS; i++)
    2d9c:	2300      	movs	r3, #0
    2d9e:	e002      	b.n	2da6 <setup+0xfa>
    2da0:	3301      	adds	r3, #1
    2da2:	2b19      	cmp	r3, #25
    2da4:	d00a      	beq.n	2dbc <setup+0x110>
    {
      if (subscribers[i] == 0) // empty slot
    2da6:	f852 1f04 	ldr.w	r1, [r2, #4]!
    2daa:	2900      	cmp	r1, #0
    2dac:	d1f8      	bne.n	2da0 <setup+0xf4>
      {
        subscribers[i] = &s;
    2dae:	f503 7190 	add.w	r1, r3, #288	; 0x120
    2db2:	4a54      	ldr	r2, [pc, #336]	; (2f04 <setup+0x258>)
    2db4:	f845 2021 	str.w	r2, [r5, r1, lsl #2]
        s.id_ = i + 100;
    2db8:	3364      	adds	r3, #100	; 0x64
    2dba:	6053      	str	r3, [r2, #4]
    2dbc:	4a52      	ldr	r2, [pc, #328]	; (2f08 <setup+0x25c>)
   */

  /* Register a new publisher */
  bool advertise(Publisher & p)
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    2dbe:	2300      	movs	r3, #0
  }

  /* Register a new subscriber */
  bool subscribe(Subscriber_& s)
  {
    for (int i = 0; i < MAX_SUBSCRIBERS; i++)
    2dc0:	4611      	mov	r1, r2
    2dc2:	e002      	b.n	2dca <setup+0x11e>
   */

  /* Register a new publisher */
  bool advertise(Publisher & p)
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    2dc4:	3301      	adds	r3, #1
    2dc6:	2b19      	cmp	r3, #25
    2dc8:	d00b      	beq.n	2de2 <setup+0x136>
    {
      if (publishers[i] == 0) // empty slot
    2dca:	f851 0f04 	ldr.w	r0, [r1, #4]!
    2dce:	2800      	cmp	r0, #0
    2dd0:	d1f8      	bne.n	2dc4 <setup+0x118>
      {
        publishers[i] = &p;
    2dd2:	494e      	ldr	r1, [pc, #312]	; (2f0c <setup+0x260>)
    2dd4:	eb05 0083 	add.w	r0, r5, r3, lsl #2
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    2dd8:	337d      	adds	r3, #125	; 0x7d
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] == 0) // empty slot
      {
        publishers[i] = &p;
    2dda:	f8c0 141c 	str.w	r1, [r0, #1052]	; 0x41c
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    2dde:	608b      	str	r3, [r1, #8]
        p.nh_ = this;
    2de0:	60cd      	str	r5, [r1, #12]
   */

  /* Register a new publisher */
  bool advertise(Publisher & p)
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    2de2:	4949      	ldr	r1, [pc, #292]	; (2f08 <setup+0x25c>)
    2de4:	2300      	movs	r3, #0
    2de6:	e002      	b.n	2dee <setup+0x142>
    2de8:	3301      	adds	r3, #1
    2dea:	2b19      	cmp	r3, #25
    2dec:	d00b      	beq.n	2e06 <setup+0x15a>
    {
      if (publishers[i] == 0) // empty slot
    2dee:	f851 0f04 	ldr.w	r0, [r1, #4]!
    2df2:	2800      	cmp	r0, #0
    2df4:	d1f8      	bne.n	2de8 <setup+0x13c>
      {
        publishers[i] = &p;
    2df6:	4946      	ldr	r1, [pc, #280]	; (2f10 <setup+0x264>)
    2df8:	eb05 0083 	add.w	r0, r5, r3, lsl #2
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    2dfc:	337d      	adds	r3, #125	; 0x7d
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] == 0) // empty slot
      {
        publishers[i] = &p;
    2dfe:	f8c0 141c 	str.w	r1, [r0, #1052]	; 0x41c
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    2e02:	608b      	str	r3, [r1, #8]
        p.nh_ = this;
    2e04:	60cd      	str	r5, [r1, #12]
   */

  /* Register a new publisher */
  bool advertise(Publisher & p)
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    2e06:	4940      	ldr	r1, [pc, #256]	; (2f08 <setup+0x25c>)
    2e08:	2300      	movs	r3, #0
    2e0a:	e002      	b.n	2e12 <setup+0x166>
    2e0c:	3301      	adds	r3, #1
    2e0e:	2b19      	cmp	r3, #25
    2e10:	d00b      	beq.n	2e2a <setup+0x17e>
    {
      if (publishers[i] == 0) // empty slot
    2e12:	f851 0f04 	ldr.w	r0, [r1, #4]!
    2e16:	2800      	cmp	r0, #0
    2e18:	d1f8      	bne.n	2e0c <setup+0x160>
      {
        publishers[i] = &p;
    2e1a:	493e      	ldr	r1, [pc, #248]	; (2f14 <setup+0x268>)
    2e1c:	eb05 0083 	add.w	r0, r5, r3, lsl #2
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    2e20:	337d      	adds	r3, #125	; 0x7d
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] == 0) // empty slot
      {
        publishers[i] = &p;
    2e22:	f8c0 141c 	str.w	r1, [r0, #1052]	; 0x41c
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    2e26:	608b      	str	r3, [r1, #8]
        p.nh_ = this;
    2e28:	60cd      	str	r5, [r1, #12]
   */

  /* Register a new publisher */
  bool advertise(Publisher & p)
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    2e2a:	4937      	ldr	r1, [pc, #220]	; (2f08 <setup+0x25c>)
    2e2c:	2300      	movs	r3, #0
    2e2e:	e002      	b.n	2e36 <setup+0x18a>
    2e30:	3301      	adds	r3, #1
    2e32:	2b19      	cmp	r3, #25
    2e34:	d00b      	beq.n	2e4e <setup+0x1a2>
    {
      if (publishers[i] == 0) // empty slot
    2e36:	f851 0f04 	ldr.w	r0, [r1, #4]!
    2e3a:	2800      	cmp	r0, #0
    2e3c:	d1f8      	bne.n	2e30 <setup+0x184>
      {
        publishers[i] = &p;
    2e3e:	4936      	ldr	r1, [pc, #216]	; (2f18 <setup+0x26c>)
    2e40:	eb05 0083 	add.w	r0, r5, r3, lsl #2
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    2e44:	337d      	adds	r3, #125	; 0x7d
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] == 0) // empty slot
      {
        publishers[i] = &p;
    2e46:	f8c0 141c 	str.w	r1, [r0, #1052]	; 0x41c
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    2e4a:	608b      	str	r3, [r1, #8]
        p.nh_ = this;
    2e4c:	60cd      	str	r5, [r1, #12]
   */

  /* Register a new publisher */
  bool advertise(Publisher & p)
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    2e4e:	492e      	ldr	r1, [pc, #184]	; (2f08 <setup+0x25c>)
    2e50:	2300      	movs	r3, #0
    2e52:	e002      	b.n	2e5a <setup+0x1ae>
    2e54:	3301      	adds	r3, #1
    2e56:	2b19      	cmp	r3, #25
    2e58:	d00b      	beq.n	2e72 <setup+0x1c6>
    {
      if (publishers[i] == 0) // empty slot
    2e5a:	f851 0f04 	ldr.w	r0, [r1, #4]!
    2e5e:	2800      	cmp	r0, #0
    2e60:	d1f8      	bne.n	2e54 <setup+0x1a8>
      {
        publishers[i] = &p;
    2e62:	492e      	ldr	r1, [pc, #184]	; (2f1c <setup+0x270>)
    2e64:	eb05 0083 	add.w	r0, r5, r3, lsl #2
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    2e68:	337d      	adds	r3, #125	; 0x7d
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] == 0) // empty slot
      {
        publishers[i] = &p;
    2e6a:	f8c0 141c 	str.w	r1, [r0, #1052]	; 0x41c
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    2e6e:	608b      	str	r3, [r1, #8]
        p.nh_ = this;
    2e70:	60cd      	str	r5, [r1, #12]
   */

  /* Register a new publisher */
  bool advertise(Publisher & p)
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    2e72:	4925      	ldr	r1, [pc, #148]	; (2f08 <setup+0x25c>)
    2e74:	2300      	movs	r3, #0
    2e76:	e002      	b.n	2e7e <setup+0x1d2>
    2e78:	3301      	adds	r3, #1
    2e7a:	2b19      	cmp	r3, #25
    2e7c:	d00b      	beq.n	2e96 <setup+0x1ea>
    {
      if (publishers[i] == 0) // empty slot
    2e7e:	f851 0f04 	ldr.w	r0, [r1, #4]!
    2e82:	2800      	cmp	r0, #0
    2e84:	d1f8      	bne.n	2e78 <setup+0x1cc>
      {
        publishers[i] = &p;
    2e86:	4926      	ldr	r1, [pc, #152]	; (2f20 <setup+0x274>)
    2e88:	eb05 0083 	add.w	r0, r5, r3, lsl #2
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    2e8c:	337d      	adds	r3, #125	; 0x7d
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] == 0) // empty slot
      {
        publishers[i] = &p;
    2e8e:	f8c0 141c 	str.w	r1, [r0, #1052]	; 0x41c
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    2e92:	608b      	str	r3, [r1, #8]
        p.nh_ = this;
    2e94:	60cd      	str	r5, [r1, #12]
   */

  /* Register a new publisher */
  bool advertise(Publisher & p)
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    2e96:	491c      	ldr	r1, [pc, #112]	; (2f08 <setup+0x25c>)
    2e98:	2300      	movs	r3, #0
    2e9a:	e002      	b.n	2ea2 <setup+0x1f6>
    2e9c:	3301      	adds	r3, #1
    2e9e:	2b19      	cmp	r3, #25
    2ea0:	d00b      	beq.n	2eba <setup+0x20e>
    {
      if (publishers[i] == 0) // empty slot
    2ea2:	f851 0f04 	ldr.w	r0, [r1, #4]!
    2ea6:	2800      	cmp	r0, #0
    2ea8:	d1f8      	bne.n	2e9c <setup+0x1f0>
      {
        publishers[i] = &p;
    2eaa:	491e      	ldr	r1, [pc, #120]	; (2f24 <setup+0x278>)
    2eac:	eb05 0083 	add.w	r0, r5, r3, lsl #2
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    2eb0:	337d      	adds	r3, #125	; 0x7d
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] == 0) // empty slot
      {
        publishers[i] = &p;
    2eb2:	f8c0 141c 	str.w	r1, [r0, #1052]	; 0x41c
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    2eb6:	608b      	str	r3, [r1, #8]
        p.nh_ = this;
    2eb8:	60cd      	str	r5, [r1, #12]
   */

  /* Register a new publisher */
  bool advertise(Publisher & p)
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    2eba:	2300      	movs	r3, #0
    2ebc:	e002      	b.n	2ec4 <setup+0x218>
    2ebe:	3301      	adds	r3, #1
    2ec0:	2b19      	cmp	r3, #25
    2ec2:	d00b      	beq.n	2edc <setup+0x230>
    {
      if (publishers[i] == 0) // empty slot
    2ec4:	f852 1f04 	ldr.w	r1, [r2, #4]!
    2ec8:	2900      	cmp	r1, #0
    2eca:	d1f8      	bne.n	2ebe <setup+0x212>
      {
        publishers[i] = &p;
    2ecc:	4a16      	ldr	r2, [pc, #88]	; (2f28 <setup+0x27c>)
    2ece:	eb05 0183 	add.w	r1, r5, r3, lsl #2
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    2ed2:	337d      	adds	r3, #125	; 0x7d
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] == 0) // empty slot
      {
        publishers[i] = &p;
    2ed4:	f8c1 241c 	str.w	r2, [r1, #1052]	; 0x41c
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    2ed8:	6093      	str	r3, [r2, #8]
        p.nh_ = this;
    2eda:	60d5      	str	r5, [r2, #12]
  //Wire.begin();
  //Wire.beginTransmission(MPU_addr);
  //Wire.write(0x6B);  // PWR_MGMT_1 register
  //Wire.write(0);     // set to zero (wakes up the MPU-6050)
  //Wire.endTransmission(true);
  accelgyro.initialize();
    2edc:	4813      	ldr	r0, [pc, #76]	; (2f2c <setup+0x280>)
    2ede:	f002 fb2f 	bl	5540 <MPU9250::initialize()>
  //Serial.println("Testing device connections...");
  //Serial.println(accelgyro.testConnection() ? "MPU9250 connection successful" : "MPU9250 connection failed");

}
    2ee2:	b005      	add	sp, #20
    2ee4:	bd30      	pop	{r4, r5, pc}
    2ee6:	bf00      	nop
    2ee8:	00009358 	.word	0x00009358
    2eec:	1fff1d54 	.word	0x1fff1d54
    2ef0:	1fff0b24 	.word	0x1fff0b24
    2ef4:	00001fd9 	.word	0x00001fd9
    2ef8:	00002211 	.word	0x00002211
    2efc:	00009364 	.word	0x00009364
    2f00:	1fff1ca4 	.word	0x1fff1ca4
    2f04:	1fff2a7c 	.word	0x1fff2a7c
    2f08:	1fff216c 	.word	0x1fff216c
    2f0c:	1fff1458 	.word	0x1fff1458
    2f10:	1fff1d38 	.word	0x1fff1d38
    2f14:	1fff2a68 	.word	0x1fff2a68
    2f18:	1fff1d0c 	.word	0x1fff1d0c
    2f1c:	1fff1c68 	.word	0x1fff1c68
    2f20:	1fff1ce4 	.word	0x1fff1ce4
    2f24:	1fff1cf8 	.word	0x1fff1cf8
    2f28:	1fff2ac0 	.word	0x1fff2ac0
    2f2c:	1fff1c58 	.word	0x1fff1c58

00002f30 <loop>:

void loop() {
    2f30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  //if(millis() > time_now + period){
    //time_now = millis();

  wheel_speed.x = average_omega_right;
  wheel_speed.y = average_omega_left;
    2f34:	4abb      	ldr	r2, [pc, #748]	; (3224 <loop+0x2f4>)
  //Serial.println(reference_angle);

  //if(millis() > time_now + period){
    //time_now = millis();

  wheel_speed.x = average_omega_right;
    2f36:	49bc      	ldr	r1, [pc, #752]	; (3228 <loop+0x2f8>)
    2f38:	4cbc      	ldr	r4, [pc, #752]	; (322c <loop+0x2fc>)
  wheel_speed.y = average_omega_left;
  wheel_speed.z = encoder_counter_right;
    2f3a:	4bbd      	ldr	r3, [pc, #756]	; (3230 <loop+0x300>)
  //Serial.println("Testing device connections...");
  //Serial.println(accelgyro.testConnection() ? "MPU9250 connection successful" : "MPU9250 connection failed");

}

void loop() {
    2f3c:	ed2d 8b04 	vpush	{d8-d9}

  //if(millis() > time_now + period){
    //time_now = millis();

  wheel_speed.x = average_omega_right;
  wheel_speed.y = average_omega_left;
    2f40:	edd2 8a00 	vldr	s17, [r2]
  //Serial.println(reference_angle);

  //if(millis() > time_now + period){
    //time_now = millis();

  wheel_speed.x = average_omega_right;
    2f44:	ed91 9a00 	vldr	s18, [r1]
  wheel_speed.y = average_omega_left;
    2f48:	edc4 8a02 	vstr	s17, [r4, #8]
  wheel_speed.z = encoder_counter_right;
    2f4c:	e9d3 0100 	ldrd	r0, r1, [r3]
  //Serial.println("Testing device connections...");
  //Serial.println(accelgyro.testConnection() ? "MPU9250 connection successful" : "MPU9250 connection failed");

}

void loop() {
    2f50:	b091      	sub	sp, #68	; 0x44
  //Serial.println(reference_angle);

  //if(millis() > time_now + period){
    //time_now = millis();

  wheel_speed.x = average_omega_right;
    2f52:	ed84 9a01 	vstr	s18, [r4, #4]
  wheel_speed.y = average_omega_left;
  wheel_speed.z = encoder_counter_right;
    2f56:	f004 fe0f 	bl	7b78 <__aeabi_d2f>
  wheel_speed.w = encoder_counter_left;
    2f5a:	4bb6      	ldr	r3, [pc, #728]	; (3234 <loop+0x304>)
  //if(millis() > time_now + period){
    //time_now = millis();

  wheel_speed.x = average_omega_right;
  wheel_speed.y = average_omega_left;
  wheel_speed.z = encoder_counter_right;
    2f5c:	60e0      	str	r0, [r4, #12]
    2f5e:	ee08 0a10 	vmov	s16, r0
  wheel_speed.w = encoder_counter_left;
    2f62:	e9d3 0100 	ldrd	r0, r1, [r3]
    2f66:	f004 fe07 	bl	7b78 <__aeabi_d2f>
    2f6a:	4bb3      	ldr	r3, [pc, #716]	; (3238 <loop+0x308>)
    2f6c:	4ab3      	ldr	r2, [pc, #716]	; (323c <loop+0x30c>)
    2f6e:	6899      	ldr	r1, [r3, #8]
    2f70:	ee07 0a90 	vmov	s15, r0
    2f74:	68d8      	ldr	r0, [r3, #12]
    2f76:	6803      	ldr	r3, [r0, #0]
    2f78:	edc4 7a04 	vstr	s15, [r4, #16]
    2f7c:	681b      	ldr	r3, [r3, #0]
    2f7e:	4293      	cmp	r3, r2
    2f80:	f040 830b 	bne.w	359a <loop+0x66a>
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    2f84:	2963      	cmp	r1, #99	; 0x63
    2f86:	dd04      	ble.n	2f92 <loop+0x62>
    2f88:	f890 34f8 	ldrb.w	r3, [r0, #1272]	; 0x4f8
    2f8c:	2b00      	cmp	r3, #0
    2f8e:	f000 80f8 	beq.w	3182 <loop+0x252>
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    2f92:	ee19 3a10 	vmov	r3, s18

    int16_t exp = ((val >> 23) & 255);
    2f96:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    2f9a:	2aff      	cmp	r2, #255	; 0xff
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    2f9c:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    2fa0:	f000 8306 	beq.w	35b0 <loop+0x680>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    2fa4:	2a00      	cmp	r2, #0
    2fa6:	f000 82db 	beq.w	3560 <loop+0x630>
    {
      exp += 1023 - 127; // Normal case
    2faa:	f502 7260 	add.w	r2, r2, #896	; 0x380
    2fae:	0114      	lsls	r4, r2, #4
    2fb0:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
    2fb4:	015e      	lsls	r6, r3, #5
    2fb6:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    2fba:	b2e4      	uxtb	r4, r4
    2fbc:	f3c2 1207 	ubfx	r2, r2, #4, #8
    2fc0:	b2f6      	uxtb	r6, r6
    2fc2:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    2fc6:	eeb5 9ac0 	vcmpe.f32	s18, #0.0
    2fca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    2fce:	f880 3228 	strb.w	r3, [r0, #552]	; 0x228
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    2fd2:	ee18 3a90 	vmov	r3, s17
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    2fd6:	bf48      	it	mi
    2fd8:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    2fdc:	f880 222a 	strb.w	r2, [r0, #554]	; 0x22a
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    2fe0:	f3c3 52c7 	ubfx	r2, r3, #23, #8
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    2fe4:	2500      	movs	r5, #0
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    2fe6:	2aff      	cmp	r2, #255	; 0xff
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    2fe8:	f880 6226 	strb.w	r6, [r0, #550]	; 0x226
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    2fec:	f880 7227 	strb.w	r7, [r0, #551]	; 0x227
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    2ff0:	f880 4229 	strb.w	r4, [r0, #553]	; 0x229
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    2ff4:	f880 5223 	strb.w	r5, [r0, #547]	; 0x223
    *(outbuffer++) = 0;
    2ff8:	f880 5224 	strb.w	r5, [r0, #548]	; 0x224
    *(outbuffer++) = 0;
    2ffc:	f880 5225 	strb.w	r5, [r0, #549]	; 0x225
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    3000:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    3004:	f000 830e 	beq.w	3624 <loop+0x6f4>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    3008:	2a00      	cmp	r2, #0
    300a:	f000 828c 	beq.w	3526 <loop+0x5f6>
    {
      exp += 1023 - 127; // Normal case
    300e:	f502 7260 	add.w	r2, r2, #896	; 0x380
    3012:	0cdc      	lsrs	r4, r3, #19
    3014:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
    3018:	015e      	lsls	r6, r3, #5
    301a:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    301e:	b2e4      	uxtb	r4, r4
    3020:	f3c2 1207 	ubfx	r2, r2, #4, #8
    3024:	b2f6      	uxtb	r6, r6
    3026:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    302a:	eef5 8ac0 	vcmpe.f32	s17, #0.0
    302e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    3032:	f880 3230 	strb.w	r3, [r0, #560]	; 0x230
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    3036:	ee18 3a10 	vmov	r3, s16
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    303a:	bf48      	it	mi
    303c:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    3040:	f880 2232 	strb.w	r2, [r0, #562]	; 0x232
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    3044:	f3c3 52c7 	ubfx	r2, r3, #23, #8
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    3048:	2500      	movs	r5, #0
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    304a:	2aff      	cmp	r2, #255	; 0xff
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    304c:	f880 622e 	strb.w	r6, [r0, #558]	; 0x22e
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    3050:	f880 722f 	strb.w	r7, [r0, #559]	; 0x22f
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    3054:	f880 4231 	strb.w	r4, [r0, #561]	; 0x231
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    3058:	f880 522b 	strb.w	r5, [r0, #555]	; 0x22b
    *(outbuffer++) = 0;
    305c:	f880 522c 	strb.w	r5, [r0, #556]	; 0x22c
    *(outbuffer++) = 0;
    3060:	f880 522d 	strb.w	r5, [r0, #557]	; 0x22d
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    3064:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    3068:	f000 82d1 	beq.w	360e <loop+0x6de>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    306c:	2a00      	cmp	r2, #0
    306e:	f000 823d 	beq.w	34ec <loop+0x5bc>
    {
      exp += 1023 - 127; // Normal case
    3072:	f502 7260 	add.w	r2, r2, #896	; 0x380
    3076:	0cdc      	lsrs	r4, r3, #19
    3078:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
    307c:	015e      	lsls	r6, r3, #5
    307e:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    3082:	b2e4      	uxtb	r4, r4
    3084:	f3c2 1207 	ubfx	r2, r2, #4, #8
    3088:	b2f6      	uxtb	r6, r6
    308a:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    308e:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
    3092:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    3096:	f880 3238 	strb.w	r3, [r0, #568]	; 0x238
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    309a:	ee17 3a90 	vmov	r3, s15
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    309e:	bf48      	it	mi
    30a0:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    30a4:	f880 223a 	strb.w	r2, [r0, #570]	; 0x23a
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    30a8:	f3c3 52c7 	ubfx	r2, r3, #23, #8
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    30ac:	2500      	movs	r5, #0
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    30ae:	2aff      	cmp	r2, #255	; 0xff
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    30b0:	f880 6236 	strb.w	r6, [r0, #566]	; 0x236
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    30b4:	f880 7237 	strb.w	r7, [r0, #567]	; 0x237
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    30b8:	f880 4239 	strb.w	r4, [r0, #569]	; 0x239
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    30bc:	f880 5233 	strb.w	r5, [r0, #563]	; 0x233
    *(outbuffer++) = 0;
    30c0:	f880 5234 	strb.w	r5, [r0, #564]	; 0x234
    *(outbuffer++) = 0;
    30c4:	f880 5235 	strb.w	r5, [r0, #565]	; 0x235
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    30c8:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    30cc:	f000 8294 	beq.w	35f8 <loop+0x6c8>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    30d0:	2a00      	cmp	r2, #0
    30d2:	f000 81ed 	beq.w	34b0 <loop+0x580>
    {
      exp += 1023 - 127; // Normal case
    30d6:	f502 7260 	add.w	r2, r2, #896	; 0x380
    30da:	0cdc      	lsrs	r4, r3, #19
    30dc:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
    30e0:	015e      	lsls	r6, r3, #5
    30e2:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    30e6:	b2e4      	uxtb	r4, r4
    30e8:	f3c2 1207 	ubfx	r2, r2, #4, #8
    30ec:	b2f6      	uxtb	r6, r6
    30ee:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    30f2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    30f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    30fa:	f04f 0500 	mov.w	r5, #0
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    30fe:	bf48      	it	mi
    3100:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    3104:	f880 623e 	strb.w	r6, [r0, #574]	; 0x23e
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    3108:	f880 723f 	strb.w	r7, [r0, #575]	; 0x23f
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    310c:	f880 3240 	strb.w	r3, [r0, #576]	; 0x240
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    3110:	f880 4241 	strb.w	r4, [r0, #577]	; 0x241
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3114:	23df      	movs	r3, #223	; 0xdf
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3116:	b2cc      	uxtb	r4, r1
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    3118:	f880 523b 	strb.w	r5, [r0, #571]	; 0x23b
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    311c:	f341 2107 	sbfx	r1, r1, #8, #8
    *(outbuffer++) = 0;
    3120:	f880 523c 	strb.w	r5, [r0, #572]	; 0x23c
    *(outbuffer++) = 0;
    3124:	f880 523d 	strb.w	r5, [r0, #573]	; 0x23d
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    3128:	f880 2242 	strb.w	r2, [r0, #578]	; 0x242

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    312c:	27ff      	movs	r7, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    312e:	26fe      	movs	r6, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3130:	2520      	movs	r5, #32
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3132:	2200      	movs	r2, #0
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3134:	f880 3220 	strb.w	r3, [r0, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3138:	f880 1222 	strb.w	r1, [r0, #546]	; 0x222

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    313c:	f880 721c 	strb.w	r7, [r0, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    3140:	f880 621d 	strb.w	r6, [r0, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3144:	f880 521e 	strb.w	r5, [r0, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3148:	f880 221f 	strb.w	r2, [r0, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    314c:	f880 4221 	strb.w	r4, [r0, #545]	; 0x221
    3150:	f200 2321 	addw	r3, r0, #545	; 0x221
    3154:	f200 2142 	addw	r1, r0, #578	; 0x242
    3158:	e001      	b.n	315e <loop+0x22e>
    315a:	f813 4f01 	ldrb.w	r4, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    315e:	428b      	cmp	r3, r1
      chk += message_out[i];
    3160:	4422      	add	r2, r4
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3162:	d1fa      	bne.n	315a <loop+0x22a>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3164:	43d2      	mvns	r2, r2
    3166:	6844      	ldr	r4, [r0, #4]
    3168:	f880 2243 	strb.w	r2, [r0, #579]	; 0x243
    316c:	6823      	ldr	r3, [r4, #0]
    316e:	4a34      	ldr	r2, [pc, #208]	; (3240 <loop+0x310>)
    3170:	685b      	ldr	r3, [r3, #4]
    3172:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    3174:	f500 7007 	add.w	r0, r0, #540	; 0x21c
    3178:	f040 825f 	bne.w	363a <loop+0x70a>
    317c:	2128      	movs	r1, #40	; 0x28
    317e:	f003 fd31 	bl	6be4 <usb_serial_write>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3182:	4f30      	ldr	r7, [pc, #192]	; (3244 <loop+0x314>)

  virtual int spinOnce() override
  {
    /* restart if timed out */
    uint32_t c_time = hardware_.time();
    if ((c_time - last_sync_receive_time) > (SYNC_SECONDS * 2200))
    3184:	4c30      	ldr	r4, [pc, #192]	; (3248 <loop+0x318>)
    3186:	683b      	ldr	r3, [r7, #0]
    3188:	9305      	str	r3, [sp, #20]
	return ret;
    318a:	9e05      	ldr	r6, [sp, #20]
    318c:	f8d4 3500 	ldr.w	r3, [r4, #1280]	; 0x500
    3190:	f642 22f8 	movw	r2, #11000	; 0x2af8
    3194:	1af3      	subs	r3, r6, r3
    3196:	4293      	cmp	r3, r2
    {
      configured_ = false;
    3198:	bf84      	itt	hi
    319a:	2300      	movhi	r3, #0
    319c:	f884 34f8 	strbhi.w	r3, [r4, #1272]	; 0x4f8
    }

    /* reset if message has timed out */
    if (mode_ != MODE_FIRST_FF)
    31a0:	f8d4 34e4 	ldr.w	r3, [r4, #1252]	; 0x4e4
    31a4:	4a28      	ldr	r2, [pc, #160]	; (3248 <loop+0x318>)
    31a6:	b133      	cbz	r3, 31b6 <loop+0x286>
    {
      if (c_time > last_msg_timeout_time)
    31a8:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
    31ac:	429e      	cmp	r6, r3
      {
        mode_ = MODE_FIRST_FF;
    31ae:	bf84      	itt	hi
    31b0:	2300      	movhi	r3, #0
    31b2:	f8c2 34e4 	strhi.w	r3, [r2, #1252]	; 0x4e4
    31b6:	f8df 8094 	ldr.w	r8, [pc, #148]	; 324c <loop+0x31c>
        }
      }
      int data = hardware_.read();
      if (data < 0)
        break;
      checksum_ += data;
    31ba:	4d23      	ldr	r5, [pc, #140]	; (3248 <loop+0x318>)

    /* while available buffer, read data */
    while (true)
    {
      // If a timeout has been specified, check how long spinOnce has been running.
      if (spin_timeout_ > 0)
    31bc:	69a2      	ldr	r2, [r4, #24]
    31be:	b12a      	cbz	r2, 31cc <loop+0x29c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    31c0:	683b      	ldr	r3, [r7, #0]
    31c2:	9309      	str	r3, [sp, #36]	; 0x24
	return ret;
    31c4:	9b09      	ldr	r3, [sp, #36]	; 0x24
      {
        // If the maximum processing timeout has been exceeded, exit with error.
        // The next spinOnce can continue where it left off, or optionally
        // based on the application in use, the hardware buffer could be flushed
        // and start fresh.
        if ((hardware_.time() - c_time) > spin_timeout_)
    31c6:	1b9b      	subs	r3, r3, r6
    31c8:	429a      	cmp	r2, r3
    31ca:	d323      	bcc.n	3214 <loop+0x2e4>
    31cc:	6860      	ldr	r0, [r4, #4]
      delay(3000); 
#endif
      iostream->begin(baud_);
    }

    int read(){return iostream->read();};
    31ce:	6803      	ldr	r3, [r0, #0]
    31d0:	695b      	ldr	r3, [r3, #20]
    31d2:	4543      	cmp	r3, r8
    31d4:	f040 8088 	bne.w	32e8 <loop+0x3b8>
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    31d8:	f003 fc9e 	bl	6b18 <usb_serial_getchar>
          // Exit the spin, processing timeout exceeded.
          return SPIN_TIMEOUT;
        }
      }
      int data = hardware_.read();
      if (data < 0)
    31dc:	2800      	cmp	r0, #0
    31de:	f2c0 8087 	blt.w	32f0 <loop+0x3c0>
        break;
      checksum_ += data;
    31e2:	f8d4 34f4 	ldr.w	r3, [r4, #1268]	; 0x4f4
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    31e6:	f8d4 24e4 	ldr.w	r2, [r4, #1252]	; 0x4e4
        }
      }
      int data = hardware_.read();
      if (data < 0)
        break;
      checksum_ += data;
    31ea:	f8df e05c 	ldr.w	lr, [pc, #92]	; 3248 <loop+0x318>
    31ee:	4403      	add	r3, r0
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    31f0:	2a07      	cmp	r2, #7
        }
      }
      int data = hardware_.read();
      if (data < 0)
        break;
      checksum_ += data;
    31f2:	f8c4 34f4 	str.w	r3, [r4, #1268]	; 0x4f4
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    31f6:	d064      	beq.n	32c2 <loop+0x392>
        message_in[index_++] = data;
        bytes_--;
        if (bytes_ == 0)                 /* is message complete? if so, checksum */
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_FIRST_FF)
    31f8:	bb52      	cbnz	r2, 3250 <loop+0x320>
      {
        if (data == 0xff)
    31fa:	28ff      	cmp	r0, #255	; 0xff
    31fc:	f000 80c7 	beq.w	338e <loop+0x45e>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3200:	683b      	ldr	r3, [r7, #0]
    3202:	9308      	str	r3, [sp, #32]
	return ret;
    3204:	9b08      	ldr	r3, [sp, #32]
        {
          mode_++;
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
        }
        else if (hardware_.time() - c_time > (SYNC_SECONDS * 1000))
    3206:	f241 3188 	movw	r1, #5000	; 0x1388
    320a:	1b9b      	subs	r3, r3, r6
    320c:	428b      	cmp	r3, r1
    320e:	d9d5      	bls.n	31bc <loop+0x28c>
        {
          /* We have been stuck in spinOnce too long, return error */
          configured_ = false;
    3210:	f88e 24f8 	strb.w	r2, [lr, #1272]	; 0x4f8
  speed_pub.publish(&wheel_speed);
  nh.spinOnce();
  //}
  delay(100);
    3214:	2064      	movs	r0, #100	; 0x64
    3216:	f002 fddd 	bl	5dd4 <delay>
  }
    321a:	b011      	add	sp, #68	; 0x44
    321c:	ecbd 8b04 	vpop	{d8-d9}
    3220:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3224:	1fff1c7c 	.word	0x1fff1c7c
    3228:	1fff146c 	.word	0x1fff146c
    322c:	1fff2a98 	.word	0x1fff2a98
    3230:	1fff1d20 	.word	0x1fff1d20
    3234:	1fff1470 	.word	0x1fff1470
    3238:	1fff1d0c 	.word	0x1fff1d0c
    323c:	000026ed 	.word	0x000026ed
    3240:	00000949 	.word	0x00000949
    3244:	1fff2ae4 	.word	0x1fff2ae4
    3248:	1fff1d54 	.word	0x1fff1d54
    324c:	00000951 	.word	0x00000951
          return SPIN_TIMEOUT;
        }
      }
      else if (mode_ == MODE_PROTOCOL_VER)
    3250:	2a01      	cmp	r2, #1
    3252:	f000 80a4 	beq.w	339e <loop+0x46e>
          mode_ = MODE_FIRST_FF;
          if (configured_ == false)
            requestSyncTime();  /* send a msg back showing our protocol version */
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
    3256:	2a02      	cmp	r2, #2
    3258:	f000 80ea 	beq.w	3430 <loop+0x500>
        bytes_ = data;
        index_ = 0;
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
    325c:	2a03      	cmp	r2, #3
    325e:	f000 80f2 	beq.w	3446 <loop+0x516>
      {
        bytes_ += data << 8;
        mode_++;
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
    3262:	2a04      	cmp	r2, #4
    3264:	f000 80f9 	beq.w	345a <loop+0x52a>
        if ((checksum_ % 256) == 255)
          mode_++;
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
    3268:	2a05      	cmp	r2, #5
    326a:	f000 8106 	beq.w	347a <loop+0x54a>
      {
        topic_ = data;
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
    326e:	2a06      	cmp	r2, #6
    3270:	f000 810b 	beq.w	348a <loop+0x55a>
        topic_ += data << 8;
        mode_ = MODE_MESSAGE;
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
    3274:	2a08      	cmp	r2, #8
    3276:	d1a1      	bne.n	31bc <loop+0x28c>
      {
        mode_ = MODE_FIRST_FF;
        if ((checksum_ % 256) == 255)
    3278:	4ac9      	ldr	r2, [pc, #804]	; (35a0 <loop+0x670>)
    327a:	401a      	ands	r2, r3
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
    327c:	2300      	movs	r3, #0
        if ((checksum_ % 256) == 255)
    327e:	429a      	cmp	r2, r3
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
    3280:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
        if ((checksum_ % 256) == 255)
    3284:	f2c0 81de 	blt.w	3644 <loop+0x714>
    3288:	2aff      	cmp	r2, #255	; 0xff
    328a:	d197      	bne.n	31bc <loop+0x28c>
        {
          if (topic_ == TopicInfo::ID_PUBLISHER)
    328c:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
    3290:	f8df a310 	ldr.w	sl, [pc, #784]	; 35a4 <loop+0x674>
    3294:	2b00      	cmp	r3, #0
    3296:	f000 832c 	beq.w	38f2 <loop+0x9c2>
            negotiateTopics();
            last_sync_time = c_time;
            last_sync_receive_time = c_time;
            return SPIN_ERR;
          }
          else if (topic_ == TopicInfo::ID_TIME)
    329a:	2b0a      	cmp	r3, #10
    329c:	f000 82e8 	beq.w	3870 <loop+0x940>
          {
            syncTime(message_in);
          }
          else if (topic_ == TopicInfo::ID_PARAMETER_REQUEST)
    32a0:	2b06      	cmp	r3, #6
    32a2:	f000 81dc 	beq.w	365e <loop+0x72e>
          {
            req_param_resp.deserialize(message_in);
            param_received = true;
          }
          else if (topic_ == TopicInfo::ID_TX_STOP)
    32a6:	2b0b      	cmp	r3, #11
    32a8:	f000 81d5 	beq.w	3656 <loop+0x726>
          {
            configured_ = false;
          }
          else
          {
            if (subscribers[topic_ - 100])
    32ac:	33bc      	adds	r3, #188	; 0xbc
    32ae:	f855 0023 	ldr.w	r0, [r5, r3, lsl #2]
    32b2:	2800      	cmp	r0, #0
    32b4:	d082      	beq.n	31bc <loop+0x28c>
              subscribers[topic_ - 100]->callback(message_in);
    32b6:	6803      	ldr	r3, [r0, #0]
    32b8:	f10a 011c 	add.w	r1, sl, #28
    32bc:	681b      	ldr	r3, [r3, #0]
    32be:	4798      	blx	r3
    32c0:	e77c      	b.n	31bc <loop+0x28c>
      if (data < 0)
        break;
      checksum_ += data;
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
      {
        message_in[index_++] = data;
    32c2:	f8d5 24f0 	ldr.w	r2, [r5, #1264]	; 0x4f0
        bytes_--;
    32c6:	f8d5 34e8 	ldr.w	r3, [r5, #1256]	; 0x4e8
      if (data < 0)
        break;
      checksum_ += data;
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
      {
        message_in[index_++] = data;
    32ca:	18a9      	adds	r1, r5, r2
        bytes_--;
    32cc:	3b01      	subs	r3, #1
      if (data < 0)
        break;
      checksum_ += data;
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
      {
        message_in[index_++] = data;
    32ce:	3201      	adds	r2, #1
    32d0:	7708      	strb	r0, [r1, #28]
    32d2:	f8c5 24f0 	str.w	r2, [r5, #1264]	; 0x4f0
        bytes_--;
    32d6:	f8c5 34e8 	str.w	r3, [r5, #1256]	; 0x4e8
        if (bytes_ == 0)                 /* is message complete? if so, checksum */
    32da:	2b00      	cmp	r3, #0
    32dc:	f47f af6e 	bne.w	31bc <loop+0x28c>
          mode_ = MODE_MSG_CHECKSUM;
    32e0:	2308      	movs	r3, #8
    32e2:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    32e6:	e769      	b.n	31bc <loop+0x28c>
    32e8:	4798      	blx	r3
          // Exit the spin, processing timeout exceeded.
          return SPIN_TIMEOUT;
        }
      }
      int data = hardware_.read();
      if (data < 0)
    32ea:	2800      	cmp	r0, #0
    32ec:	f6bf af79 	bge.w	31e2 <loop+0x2b2>
        }
      }
    }

    /* occasionally sync time */
    if (configured_ && ((c_time - last_sync_time) > (SYNC_SECONDS * 500)))
    32f0:	f894 34f8 	ldrb.w	r3, [r4, #1272]	; 0x4f8
    32f4:	48ab      	ldr	r0, [pc, #684]	; (35a4 <loop+0x674>)
    32f6:	2b00      	cmp	r3, #0
    32f8:	d08c      	beq.n	3214 <loop+0x2e4>
    32fa:	f8d0 34fc 	ldr.w	r3, [r0, #1276]	; 0x4fc
    32fe:	f640 12c4 	movw	r2, #2500	; 0x9c4
    3302:	1af3      	subs	r3, r6, r3
    3304:	4293      	cmp	r3, r2
    3306:	d985      	bls.n	3214 <loop+0x2e4>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3308:	23ff      	movs	r3, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    330a:	21fe      	movs	r1, #254	; 0xfe
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->data.sec >> (8 * 0)) & 0xFF;
    330c:	2200      	movs	r2, #0

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    330e:	f880 321c 	strb.w	r3, [r0, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    3312:	f880 121d 	strb.w	r1, [r0, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3316:	23f7      	movs	r3, #247	; 0xf7
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3318:	2508      	movs	r5, #8
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    331a:	210a      	movs	r1, #10
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    331c:	f880 3220 	strb.w	r3, [r0, #544]	; 0x220
    3320:	f880 2223 	strb.w	r2, [r0, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->data.sec >> (8 * 1)) & 0xFF;
    3324:	f880 2224 	strb.w	r2, [r0, #548]	; 0x224
      *(outbuffer + offset + 2) = (this->data.sec >> (8 * 2)) & 0xFF;
    3328:	f880 2225 	strb.w	r2, [r0, #549]	; 0x225
      *(outbuffer + offset + 3) = (this->data.sec >> (8 * 3)) & 0xFF;
    332c:	f880 2226 	strb.w	r2, [r0, #550]	; 0x226
      offset += sizeof(this->data.sec);
      *(outbuffer + offset + 0) = (this->data.nsec >> (8 * 0)) & 0xFF;
    3330:	f880 2227 	strb.w	r2, [r0, #551]	; 0x227
      *(outbuffer + offset + 1) = (this->data.nsec >> (8 * 1)) & 0xFF;
    3334:	f880 2228 	strb.w	r2, [r0, #552]	; 0x228
      *(outbuffer + offset + 2) = (this->data.nsec >> (8 * 2)) & 0xFF;
    3338:	f880 2229 	strb.w	r2, [r0, #553]	; 0x229
      *(outbuffer + offset + 3) = (this->data.nsec >> (8 * 3)) & 0xFF;
    333c:	f880 222a 	strb.w	r2, [r0, #554]	; 0x22a

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3340:	f880 221f 	strb.w	r2, [r0, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3344:	f880 2222 	strb.w	r2, [r0, #546]	; 0x222
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3348:	f880 521e 	strb.w	r5, [r0, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    334c:	f880 1221 	strb.w	r1, [r0, #545]	; 0x221
    3350:	f200 2321 	addw	r3, r0, #545	; 0x221
    3354:	f200 202a 	addw	r0, r0, #554	; 0x22a
    3358:	e001      	b.n	335e <loop+0x42e>
    335a:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    335e:	4283      	cmp	r3, r0
      chk += message_out[i];
    3360:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3362:	d1fa      	bne.n	335a <loop+0x42a>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3364:	43d2      	mvns	r2, r2
    3366:	6860      	ldr	r0, [r4, #4]
    3368:	f884 222b 	strb.w	r2, [r4, #555]	; 0x22b
    void write(uint8_t* data, int length){
      iostream->write(data, length);
    336c:	6803      	ldr	r3, [r0, #0]
    336e:	4a8e      	ldr	r2, [pc, #568]	; (35a8 <loop+0x678>)
    3370:	685b      	ldr	r3, [r3, #4]
    3372:	4293      	cmp	r3, r2
    3374:	f040 816b 	bne.w	364e <loop+0x71e>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    3378:	2110      	movs	r1, #16
    337a:	488c      	ldr	r0, [pc, #560]	; (35ac <loop+0x67c>)
    337c:	f003 fc32 	bl	6be4 <usb_serial_write>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3380:	683b      	ldr	r3, [r7, #0]
    3382:	930d      	str	r3, [sp, #52]	; 0x34
	return ret;
    3384:	9b0d      	ldr	r3, [sp, #52]	; 0x34

    /* occasionally sync time */
    if (configured_ && ((c_time - last_sync_time) > (SYNC_SECONDS * 500)))
    {
      requestSyncTime();
      last_sync_time = c_time;
    3386:	f8c4 64fc 	str.w	r6, [r4, #1276]	; 0x4fc

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    rt_time = hardware_.time();
    338a:	60e3      	str	r3, [r4, #12]
    338c:	e742      	b.n	3214 <loop+0x2e4>
      }
      else if (mode_ == MODE_FIRST_FF)
      {
        if (data == 0xff)
        {
          mode_++;
    338e:	2201      	movs	r2, #1
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
    3390:	f106 0314 	add.w	r3, r6, #20
      }
      else if (mode_ == MODE_FIRST_FF)
      {
        if (data == 0xff)
        {
          mode_++;
    3394:	f8c5 24e4 	str.w	r2, [r5, #1252]	; 0x4e4
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
    3398:	f8c5 3504 	str.w	r3, [r5, #1284]	; 0x504
    339c:	e70e      	b.n	31bc <loop+0x28c>
          return SPIN_TIMEOUT;
        }
      }
      else if (mode_ == MODE_PROTOCOL_VER)
      {
        if (data == PROTOCOL_VER)
    339e:	28fe      	cmp	r0, #254	; 0xfe
    33a0:	d067      	beq.n	3472 <loop+0x542>
          mode_++;
        }
        else
        {
          mode_ = MODE_FIRST_FF;
          if (configured_ == false)
    33a2:	f895 24f8 	ldrb.w	r2, [r5, #1272]	; 0x4f8
        {
          mode_++;
        }
        else
        {
          mode_ = MODE_FIRST_FF;
    33a6:	2300      	movs	r3, #0
    33a8:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
          if (configured_ == false)
    33ac:	2a00      	cmp	r2, #0
    33ae:	f47f af05 	bne.w	31bc <loop+0x28c>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    33b2:	23ff      	movs	r3, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    33b4:	21fe      	movs	r1, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    33b6:	2008      	movs	r0, #8

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    33b8:	f885 321c 	strb.w	r3, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    33bc:	f885 121d 	strb.w	r1, [r5, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    33c0:	23f7      	movs	r3, #247	; 0xf7
    message_out[5] = (uint8_t)((int16_t)id & 255);
    33c2:	210a      	movs	r1, #10
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    33c4:	f885 3220 	strb.w	r3, [r5, #544]	; 0x220
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->data.sec >> (8 * 0)) & 0xFF;
    33c8:	f885 2223 	strb.w	r2, [r5, #547]	; 0x223
    33cc:	f20e 2321 	addw	r3, lr, #545	; 0x221
      *(outbuffer + offset + 1) = (this->data.sec >> (8 * 1)) & 0xFF;
    33d0:	f885 2224 	strb.w	r2, [r5, #548]	; 0x224
      *(outbuffer + offset + 2) = (this->data.sec >> (8 * 2)) & 0xFF;
    33d4:	f885 2225 	strb.w	r2, [r5, #549]	; 0x225
      *(outbuffer + offset + 3) = (this->data.sec >> (8 * 3)) & 0xFF;
    33d8:	f885 2226 	strb.w	r2, [r5, #550]	; 0x226
      offset += sizeof(this->data.sec);
      *(outbuffer + offset + 0) = (this->data.nsec >> (8 * 0)) & 0xFF;
    33dc:	f885 2227 	strb.w	r2, [r5, #551]	; 0x227
      *(outbuffer + offset + 1) = (this->data.nsec >> (8 * 1)) & 0xFF;
    33e0:	f885 2228 	strb.w	r2, [r5, #552]	; 0x228
      *(outbuffer + offset + 2) = (this->data.nsec >> (8 * 2)) & 0xFF;
    33e4:	f885 2229 	strb.w	r2, [r5, #553]	; 0x229
      *(outbuffer + offset + 3) = (this->data.nsec >> (8 * 3)) & 0xFF;
    33e8:	f885 222a 	strb.w	r2, [r5, #554]	; 0x22a

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    33ec:	f885 221f 	strb.w	r2, [r5, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    33f0:	f885 2222 	strb.w	r2, [r5, #546]	; 0x222
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    33f4:	f885 021e 	strb.w	r0, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    33f8:	f885 1221 	strb.w	r1, [r5, #545]	; 0x221
    33fc:	f20e 2e2a 	addw	lr, lr, #554	; 0x22a
    3400:	e001      	b.n	3406 <loop+0x4d6>
    3402:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3406:	4573      	cmp	r3, lr
      chk += message_out[i];
    3408:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    340a:	d1fa      	bne.n	3402 <loop+0x4d2>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    340c:	43d2      	mvns	r2, r2
    340e:	6860      	ldr	r0, [r4, #4]
    3410:	f884 222b 	strb.w	r2, [r4, #555]	; 0x22b
    3414:	6803      	ldr	r3, [r0, #0]
    3416:	4a64      	ldr	r2, [pc, #400]	; (35a8 <loop+0x678>)
    3418:	685b      	ldr	r3, [r3, #4]
    341a:	4293      	cmp	r3, r2
    341c:	d144      	bne.n	34a8 <loop+0x578>
    341e:	2110      	movs	r1, #16
    3420:	4862      	ldr	r0, [pc, #392]	; (35ac <loop+0x67c>)
    3422:	f003 fbdf 	bl	6be4 <usb_serial_write>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3426:	683b      	ldr	r3, [r7, #0]
    3428:	9307      	str	r3, [sp, #28]
	return ret;
    342a:	9b07      	ldr	r3, [sp, #28]

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    rt_time = hardware_.time();
    342c:	60e3      	str	r3, [r4, #12]
    342e:	e6c5      	b.n	31bc <loop+0x28c>
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
        index_ = 0;
    3430:	2200      	movs	r2, #0
        mode_++;
    3432:	2303      	movs	r3, #3
            requestSyncTime();  /* send a msg back showing our protocol version */
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
    3434:	f8c5 04e8 	str.w	r0, [r5, #1256]	; 0x4e8
        index_ = 0;
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
    3438:	f8c5 04f4 	str.w	r0, [r5, #1268]	; 0x4f4
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
        index_ = 0;
    343c:	f8c5 24f0 	str.w	r2, [r5, #1264]	; 0x4f0
        mode_++;
    3440:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
    3444:	e6ba      	b.n	31bc <loop+0x28c>
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
      {
        bytes_ += data << 8;
    3446:	f8d5 34e8 	ldr.w	r3, [r5, #1256]	; 0x4e8
    344a:	eb03 2000 	add.w	r0, r3, r0, lsl #8
        mode_++;
    344e:	2304      	movs	r3, #4
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
      {
        bytes_ += data << 8;
    3450:	f8c5 04e8 	str.w	r0, [r5, #1256]	; 0x4e8
        mode_++;
    3454:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
    3458:	e6b0      	b.n	31bc <loop+0x28c>
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
      {
        if ((checksum_ % 256) == 255)
    345a:	4a51      	ldr	r2, [pc, #324]	; (35a0 <loop+0x670>)
    345c:	401a      	ands	r2, r3
    345e:	2a00      	cmp	r2, #0
    3460:	f2c0 80c5 	blt.w	35ee <loop+0x6be>
    3464:	2aff      	cmp	r2, #255	; 0xff
          mode_++;
    3466:	bf0c      	ite	eq
    3468:	2305      	moveq	r3, #5
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
    346a:	2300      	movne	r3, #0
    346c:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    3470:	e6a4      	b.n	31bc <loop+0x28c>
      }
      else if (mode_ == MODE_PROTOCOL_VER)
      {
        if (data == PROTOCOL_VER)
        {
          mode_++;
    3472:	2302      	movs	r3, #2
    3474:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
    3478:	e6a0      	b.n	31bc <loop+0x28c>
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
        mode_++;
    347a:	2306      	movs	r3, #6
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
    347c:	f8c5 04ec 	str.w	r0, [r5, #1260]	; 0x4ec
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
    3480:	f8c5 04f4 	str.w	r0, [r5, #1268]	; 0x4f4
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
        mode_++;
    3484:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
    3488:	e698      	b.n	31bc <loop+0x28c>
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    348a:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
        mode_ = MODE_MESSAGE;
        if (bytes_ == 0)
    348e:	f8d5 24e8 	ldr.w	r2, [r5, #1256]	; 0x4e8
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    3492:	eb03 2300 	add.w	r3, r3, r0, lsl #8
        mode_ = MODE_MESSAGE;
    3496:	2107      	movs	r1, #7
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    3498:	f8c5 34ec 	str.w	r3, [r5, #1260]	; 0x4ec
        mode_ = MODE_MESSAGE;
    349c:	f8c5 14e4 	str.w	r1, [r5, #1252]	; 0x4e4
        if (bytes_ == 0)
    34a0:	2a00      	cmp	r2, #0
    34a2:	f43f af1d 	beq.w	32e0 <loop+0x3b0>
    34a6:	e689      	b.n	31bc <loop+0x28c>
    34a8:	2210      	movs	r2, #16
    34aa:	4940      	ldr	r1, [pc, #256]	; (35ac <loop+0x67c>)
    34ac:	4798      	blx	r3
    34ae:	e7ba      	b.n	3426 <loop+0x4f6>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    34b0:	2b00      	cmp	r3, #0
    34b2:	f000 8088 	beq.w	35c6 <loop+0x696>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    34b6:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    34b8:	021f      	lsls	r7, r3, #8
    34ba:	f100 8211 	bmi.w	38e0 <loop+0x9b0>
    34be:	f44f 7260 	mov.w	r2, #896	; 0x380
    34c2:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    34c4:	005b      	lsls	r3, r3, #1
    34c6:	b294      	uxth	r4, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    34c8:	021e      	lsls	r6, r3, #8
    34ca:	b222      	sxth	r2, r4
    34cc:	d5f9      	bpl.n	34c2 <loop+0x592>
    34ce:	0124      	lsls	r4, r4, #4
    34d0:	b2e4      	uxtb	r4, r4
    34d2:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    34d6:	f3c3 0316 	ubfx	r3, r3, #0, #23
    34da:	015e      	lsls	r6, r3, #5
    34dc:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
    34e0:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    34e4:	b2f6      	uxtb	r6, r6
    34e6:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    34ea:	e602      	b.n	30f2 <loop+0x1c2>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    34ec:	2b00      	cmp	r3, #0
    34ee:	d079      	beq.n	35e4 <loop+0x6b4>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    34f0:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    34f2:	021e      	lsls	r6, r3, #8
    34f4:	f100 81f1 	bmi.w	38da <loop+0x9aa>
    34f8:	f44f 7260 	mov.w	r2, #896	; 0x380
    34fc:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    34fe:	005b      	lsls	r3, r3, #1
    3500:	b294      	uxth	r4, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    3502:	021d      	lsls	r5, r3, #8
    3504:	b222      	sxth	r2, r4
    3506:	d5f9      	bpl.n	34fc <loop+0x5cc>
    3508:	0124      	lsls	r4, r4, #4
    350a:	b2e4      	uxtb	r4, r4
    350c:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    3510:	f3c3 0316 	ubfx	r3, r3, #0, #23
    3514:	015e      	lsls	r6, r3, #5
    3516:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
    351a:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    351e:	b2f6      	uxtb	r6, r6
    3520:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    3524:	e5b3      	b.n	308e <loop+0x15e>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    3526:	2b00      	cmp	r3, #0
    3528:	d057      	beq.n	35da <loop+0x6aa>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    352a:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    352c:	021c      	lsls	r4, r3, #8
    352e:	f100 81da 	bmi.w	38e6 <loop+0x9b6>
    3532:	f44f 7260 	mov.w	r2, #896	; 0x380
    3536:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    3538:	005b      	lsls	r3, r3, #1
    353a:	b294      	uxth	r4, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    353c:	021f      	lsls	r7, r3, #8
    353e:	b222      	sxth	r2, r4
    3540:	d5f9      	bpl.n	3536 <loop+0x606>
    3542:	0124      	lsls	r4, r4, #4
    3544:	b2e4      	uxtb	r4, r4
    3546:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    354a:	f3c3 0316 	ubfx	r3, r3, #0, #23
    354e:	015e      	lsls	r6, r3, #5
    3550:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
    3554:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    3558:	b2f6      	uxtb	r6, r6
    355a:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    355e:	e564      	b.n	302a <loop+0xfa>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    3560:	2b00      	cmp	r3, #0
    3562:	d035      	beq.n	35d0 <loop+0x6a0>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    3564:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    3566:	021e      	lsls	r6, r3, #8
    3568:	f100 81c0 	bmi.w	38ec <loop+0x9bc>
    356c:	f44f 7260 	mov.w	r2, #896	; 0x380
    3570:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    3572:	005b      	lsls	r3, r3, #1
    3574:	b294      	uxth	r4, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    3576:	021d      	lsls	r5, r3, #8
    3578:	b222      	sxth	r2, r4
    357a:	d5f9      	bpl.n	3570 <loop+0x640>
    357c:	0124      	lsls	r4, r4, #4
    357e:	b2e4      	uxtb	r4, r4
    3580:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    3584:	f3c3 0316 	ubfx	r3, r3, #0, #23
    3588:	015e      	lsls	r6, r3, #5
    358a:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
    358e:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    3592:	b2f6      	uxtb	r6, r6
    3594:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    3598:	e515      	b.n	2fc6 <loop+0x96>
    359a:	4622      	mov	r2, r4
    359c:	4798      	blx	r3
    359e:	e5f0      	b.n	3182 <loop+0x252>
    35a0:	800000ff 	.word	0x800000ff
    35a4:	1fff1d54 	.word	0x1fff1d54
    35a8:	00000949 	.word	0x00000949
    35ac:	1fff1f70 	.word	0x1fff1f70
    35b0:	015e      	lsls	r6, r3, #5
    35b2:	0cdc      	lsrs	r4, r3, #19
    35b4:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    35b8:	b2f6      	uxtb	r6, r6
    35ba:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    35be:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    35c2:	227f      	movs	r2, #127	; 0x7f
    35c4:	e4ff      	b.n	2fc6 <loop+0x96>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    35c6:	461a      	mov	r2, r3
    35c8:	461c      	mov	r4, r3
    35ca:	461f      	mov	r7, r3
    35cc:	461e      	mov	r6, r3
    35ce:	e590      	b.n	30f2 <loop+0x1c2>
    35d0:	461a      	mov	r2, r3
    35d2:	461c      	mov	r4, r3
    35d4:	461f      	mov	r7, r3
    35d6:	461e      	mov	r6, r3
    35d8:	e4f5      	b.n	2fc6 <loop+0x96>
    35da:	461a      	mov	r2, r3
    35dc:	461c      	mov	r4, r3
    35de:	461f      	mov	r7, r3
    35e0:	461e      	mov	r6, r3
    35e2:	e522      	b.n	302a <loop+0xfa>
    35e4:	461a      	mov	r2, r3
    35e6:	461c      	mov	r4, r3
    35e8:	461f      	mov	r7, r3
    35ea:	461e      	mov	r6, r3
    35ec:	e54f      	b.n	308e <loop+0x15e>
        bytes_ += data << 8;
        mode_++;
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
      {
        if ((checksum_ % 256) == 255)
    35ee:	3a01      	subs	r2, #1
    35f0:	f062 02ff 	orn	r2, r2, #255	; 0xff
    35f4:	3201      	adds	r2, #1
    35f6:	e735      	b.n	3464 <loop+0x534>
    35f8:	015e      	lsls	r6, r3, #5
    35fa:	0cdc      	lsrs	r4, r3, #19
    35fc:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    3600:	b2f6      	uxtb	r6, r6
    3602:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    3606:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    360a:	227f      	movs	r2, #127	; 0x7f
    360c:	e571      	b.n	30f2 <loop+0x1c2>
    360e:	015e      	lsls	r6, r3, #5
    3610:	0cdc      	lsrs	r4, r3, #19
    3612:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    3616:	b2f6      	uxtb	r6, r6
    3618:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    361c:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    3620:	227f      	movs	r2, #127	; 0x7f
    3622:	e534      	b.n	308e <loop+0x15e>
    3624:	015e      	lsls	r6, r3, #5
    3626:	0cdc      	lsrs	r4, r3, #19
    3628:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    362c:	b2f6      	uxtb	r6, r6
    362e:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    3632:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    3636:	227f      	movs	r2, #127	; 0x7f
    3638:	e4f7      	b.n	302a <loop+0xfa>
    363a:	4601      	mov	r1, r0
    363c:	2228      	movs	r2, #40	; 0x28
    363e:	4620      	mov	r0, r4
    3640:	4798      	blx	r3
    3642:	e59e      	b.n	3182 <loop+0x252>
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
        if ((checksum_ % 256) == 255)
    3644:	3a01      	subs	r2, #1
    3646:	f062 02ff 	orn	r2, r2, #255	; 0xff
    364a:	3201      	adds	r2, #1
    364c:	e61c      	b.n	3288 <loop+0x358>
    364e:	2210      	movs	r2, #16
    3650:	49bd      	ldr	r1, [pc, #756]	; (3948 <loop+0xa18>)
    3652:	4798      	blx	r3
    3654:	e694      	b.n	3380 <loop+0x450>
            req_param_resp.deserialize(message_in);
            param_received = true;
          }
          else if (topic_ == TopicInfo::ID_TX_STOP)
          {
            configured_ = false;
    3656:	2300      	movs	r3, #0
    3658:	f885 34f8 	strb.w	r3, [r5, #1272]	; 0x4f8
    365c:	e5ae      	b.n	31bc <loop+0x28c>
    {
      int offset = 0;
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    365e:	f8d5 901c 	ldr.w	r9, [r5, #28]
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
    3662:	f8d5 3510 	ldr.w	r3, [r5, #1296]	; 0x510
    3666:	4599      	cmp	r9, r3
    3668:	d907      	bls.n	367a <loop+0x74a>
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
    366a:	ea4f 0189 	mov.w	r1, r9, lsl #2
    366e:	f8d5 0518 	ldr.w	r0, [r5, #1304]	; 0x518
    3672:	f004 fe7d 	bl	8370 <realloc>
    3676:	f8c5 0518 	str.w	r0, [r5, #1304]	; 0x518
      ints_length = ints_lengthT;
    367a:	f8c4 9510 	str.w	r9, [r4, #1296]	; 0x510
      for( uint32_t i = 0; i < ints_length; i++){
    367e:	f1b9 0f00 	cmp.w	r9, #0
    3682:	f000 8337 	beq.w	3cf4 <loop+0xdc4>
    3686:	f8df a2dc 	ldr.w	sl, [pc, #732]	; 3964 <loop+0xa34>
    368a:	f04f 0904 	mov.w	r9, #4
    368e:	f04f 0b00 	mov.w	fp, #0
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
    3692:	f89a 1022 	ldrb.w	r1, [sl, #34]	; 0x22
    3696:	f89a 3021 	ldrb.w	r3, [sl, #33]	; 0x21
    369a:	f89a 2020 	ldrb.w	r2, [sl, #32]
    369e:	f89a e023 	ldrb.w	lr, [sl, #35]	; 0x23
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
    36a2:	f8d4 0518 	ldr.w	r0, [r4, #1304]	; 0x518
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
    36a6:	0409      	lsls	r1, r1, #16
    36a8:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
    36ac:	4313      	orrs	r3, r2
    36ae:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
    36b2:	eb00 008b 	add.w	r0, r0, fp, lsl #2
    36b6:	49a5      	ldr	r1, [pc, #660]	; (394c <loop+0xa1c>)
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
    36b8:	f8c4 3514 	str.w	r3, [r4, #1300]	; 0x514
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
    36bc:	2204      	movs	r2, #4
    36be:	f001 ff79 	bl	55b4 <memcpy>
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
      ints_length = ints_lengthT;
      for( uint32_t i = 0; i < ints_length; i++){
    36c2:	f8d4 3510 	ldr.w	r3, [r4, #1296]	; 0x510
    36c6:	f10b 0b01 	add.w	fp, fp, #1
    36ca:	455b      	cmp	r3, fp
    36cc:	4649      	mov	r1, r9
    36ce:	f10a 0a04 	add.w	sl, sl, #4
    36d2:	f109 0904 	add.w	r9, r9, #4
    36d6:	d8dc      	bhi.n	3692 <loop+0x762>
    36d8:	1d4b      	adds	r3, r1, #5
    36da:	f101 0a08 	add.w	sl, r1, #8
    36de:	f101 000b 	add.w	r0, r1, #11
    36e2:	9302      	str	r3, [sp, #8]
    36e4:	f101 0e06 	add.w	lr, r1, #6
    36e8:	f101 0c07 	add.w	ip, r1, #7
    36ec:	f101 0309 	add.w	r3, r1, #9
    36f0:	f101 020a 	add.w	r2, r1, #10
    36f4:	310c      	adds	r1, #12
    36f6:	46d3      	mov	fp, sl
    36f8:	9000      	str	r0, [sp, #0]
    36fa:	9101      	str	r1, [sp, #4]
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
    36fc:	9902      	ldr	r1, [sp, #8]
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    36fe:	44a6      	add	lr, r4
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
    3700:	4421      	add	r1, r4
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    3702:	44a1      	add	r9, r4
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    3704:	f89e e01c 	ldrb.w	lr, [lr, #28]
    3708:	7f09      	ldrb	r1, [r1, #28]
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    370a:	f899 001c 	ldrb.w	r0, [r9, #28]
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    370e:	44a4      	add	ip, r4
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    3710:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
    3714:	ea4e 2e01 	orr.w	lr, lr, r1, lsl #8
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    3718:	f89c c01c 	ldrb.w	ip, [ip, #28]
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
    371c:	f8d4 151c 	ldr.w	r1, [r4, #1308]	; 0x51c
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    3720:	ea4e 0e00 	orr.w	lr, lr, r0
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    3724:	ea4e 690c 	orr.w	r9, lr, ip, lsl #24
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
    3728:	4589      	cmp	r9, r1
    372a:	d90b      	bls.n	3744 <loop+0x814>
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
    372c:	ea4f 0189 	mov.w	r1, r9, lsl #2
    3730:	f8d5 0524 	ldr.w	r0, [r5, #1316]	; 0x524
    3734:	9303      	str	r3, [sp, #12]
    3736:	9202      	str	r2, [sp, #8]
    3738:	f004 fe1a 	bl	8370 <realloc>
    373c:	9b03      	ldr	r3, [sp, #12]
    373e:	9a02      	ldr	r2, [sp, #8]
    3740:	f8c5 0524 	str.w	r0, [r5, #1316]	; 0x524
      floats_length = floats_lengthT;
    3744:	f8c4 951c 	str.w	r9, [r4, #1308]	; 0x51c
      for( uint32_t i = 0; i < floats_length; i++){
    3748:	f1b9 0f00 	cmp.w	r9, #0
    374c:	f000 82be 	beq.w	3ccc <loop+0xd9c>
    3750:	4b7f      	ldr	r3, [pc, #508]	; (3950 <loop+0xa20>)
    3752:	eb05 0a0b 	add.w	sl, r5, fp
    3756:	f04f 0900 	mov.w	r9, #0
      } u_st_floats;
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    375a:	f89a 101e 	ldrb.w	r1, [sl, #30]
    375e:	f89a 001d 	ldrb.w	r0, [sl, #29]
    3762:	f89a 201c 	ldrb.w	r2, [sl, #28]
    3766:	f89a e01f 	ldrb.w	lr, [sl, #31]
      this->st_floats = u_st_floats.real;
    376a:	9300      	str	r3, [sp, #0]
      } u_st_floats;
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    376c:	0409      	lsls	r1, r1, #16
    376e:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
    3772:	430a      	orrs	r2, r1
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    3774:	f8d4 0524 	ldr.w	r0, [r4, #1316]	; 0x524
    3778:	4975      	ldr	r1, [pc, #468]	; (3950 <loop+0xa20>)
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
    377a:	ea42 6e0e 	orr.w	lr, r2, lr, lsl #24
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    377e:	eb00 0089 	add.w	r0, r0, r9, lsl #2
    3782:	2204      	movs	r2, #4
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
    3784:	f8c3 e000 	str.w	lr, [r3]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    3788:	f001 ff14 	bl	55b4 <memcpy>
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
      floats_length = floats_lengthT;
      for( uint32_t i = 0; i < floats_length; i++){
    378c:	f8d4 251c 	ldr.w	r2, [r4, #1308]	; 0x51c
    3790:	9b00      	ldr	r3, [sp, #0]
    3792:	f109 0901 	add.w	r9, r9, #1
    3796:	454a      	cmp	r2, r9
    3798:	4659      	mov	r1, fp
    379a:	f10a 0a04 	add.w	sl, sl, #4
    379e:	f10b 0b04 	add.w	fp, fp, #4
    37a2:	d8da      	bhi.n	375a <loop+0x82a>
    37a4:	1dc8      	adds	r0, r1, #7
    37a6:	46da      	mov	sl, fp
    37a8:	1d4b      	adds	r3, r1, #5
    37aa:	1d8a      	adds	r2, r1, #6
    37ac:	9000      	str	r0, [sp, #0]
    37ae:	f101 0908 	add.w	r9, r1, #8
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    37b2:	4422      	add	r2, r4
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
    37b4:	4423      	add	r3, r4
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    37b6:	7f11      	ldrb	r1, [r2, #28]
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    37b8:	9a00      	ldr	r2, [sp, #0]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    37ba:	7f18      	ldrb	r0, [r3, #28]
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
    37bc:	f8d4 3528 	ldr.w	r3, [r4, #1320]	; 0x528
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    37c0:	44a2      	add	sl, r4
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    37c2:	4422      	add	r2, r4
    37c4:	4696      	mov	lr, r2
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    37c6:	0409      	lsls	r1, r1, #16
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    37c8:	f89a 201c 	ldrb.w	r2, [sl, #28]
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    37cc:	f89e a01c 	ldrb.w	sl, [lr, #28]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    37d0:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
    37d4:	430a      	orrs	r2, r1
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    37d6:	ea42 6a0a 	orr.w	sl, r2, sl, lsl #24
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
    37da:	459a      	cmp	sl, r3
    37dc:	d907      	bls.n	37ee <loop+0x8be>
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
    37de:	ea4f 018a 	mov.w	r1, sl, lsl #2
    37e2:	f8d5 0530 	ldr.w	r0, [r5, #1328]	; 0x530
    37e6:	f004 fdc3 	bl	8370 <realloc>
    37ea:	f8c5 0530 	str.w	r0, [r5, #1328]	; 0x530
      strings_length = strings_lengthT;
    37ee:	f8c4 a528 	str.w	sl, [r4, #1320]	; 0x528
      for( uint32_t i = 0; i < strings_length; i++){
    37f2:	f1ba 0f00 	cmp.w	sl, #0
    37f6:	d037      	beq.n	3868 <loop+0x938>
    37f8:	f04f 0a00 	mov.w	sl, #0
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    37fc:	46d3      	mov	fp, sl
    37fe:	f109 011c 	add.w	r1, r9, #28
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
      uint32_t length_st_strings;
      arrToVar(length_st_strings, (inbuffer + offset));
    3802:	2300      	movs	r3, #0
    3804:	4421      	add	r1, r4

  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    3806:	469e      	mov	lr, r3
    for (size_t i = 0; i < sizeof(V); i++)
      var |= (arr[i] << (8 * i));
    3808:	f811 2b01 	ldrb.w	r2, [r1], #1
    380c:	409a      	lsls	r2, r3
    380e:	3308      	adds	r3, #8
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
    3810:	2b20      	cmp	r3, #32
      var |= (arr[i] << (8 * i));
    3812:	ea4e 0e02 	orr.w	lr, lr, r2
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
    3816:	d1f7      	bne.n	3808 <loop+0x8d8>
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
    3818:	f109 0004 	add.w	r0, r9, #4
    381c:	4486      	add	lr, r0
    381e:	4586      	cmp	lr, r0
    3820:	d909      	bls.n	3836 <loop+0x906>
    3822:	f109 031f 	add.w	r3, r9, #31
    3826:	4423      	add	r3, r4
    3828:	4602      	mov	r2, r0
    382a:	3201      	adds	r2, #1
          inbuffer[k-1]=inbuffer[k];
    382c:	7859      	ldrb	r1, [r3, #1]
    382e:	f803 1b01 	strb.w	r1, [r3], #1
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
      uint32_t length_st_strings;
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
    3832:	4596      	cmp	lr, r2
    3834:	d8f9      	bhi.n	382a <loop+0x8fa>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    3836:	eb04 020e 	add.w	r2, r4, lr
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    383a:	4946      	ldr	r1, [pc, #280]	; (3954 <loop+0xa24>)
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    383c:	f882 b01b 	strb.w	fp, [r2, #27]
      this->st_strings = (char *)(inbuffer + offset-1);
    3840:	1e43      	subs	r3, r0, #1
    3842:	f5a1 62a2 	sub.w	r2, r1, #1296	; 0x510
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    3846:	f8d4 0530 	ldr.w	r0, [r4, #1328]	; 0x530
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
    384a:	4413      	add	r3, r2
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    384c:	eb00 008a 	add.w	r0, r0, sl, lsl #2
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
    3850:	f8c4 352c 	str.w	r3, [r4, #1324]	; 0x52c
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    3854:	2204      	movs	r2, #4
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
    3856:	46f1      	mov	r9, lr
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    3858:	f001 feac 	bl	55b4 <memcpy>
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
    385c:	f8d4 3528 	ldr.w	r3, [r4, #1320]	; 0x528
    3860:	f10a 0a01 	add.w	sl, sl, #1
    3864:	4553      	cmp	r3, sl
    3866:	d8ca      	bhi.n	37fe <loop+0x8ce>
            syncTime(message_in);
          }
          else if (topic_ == TopicInfo::ID_PARAMETER_REQUEST)
          {
            req_param_resp.deserialize(message_in);
            param_received = true;
    3868:	2301      	movs	r3, #1
    386a:	f884 3508 	strb.w	r3, [r4, #1288]	; 0x508
    386e:	e4a5      	b.n	31bc <loop+0x28c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3870:	683b      	ldr	r3, [r7, #0]
    3872:	930a      	str	r3, [sp, #40]	; 0x28
	return ret;
    3874:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  }

  void syncTime(uint8_t * data)
  {
    std_msgs::Time t;
    uint32_t offset = hardware_.time() - rt_time;
    3876:	68ea      	ldr	r2, [r5, #12]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3878:	6839      	ldr	r1, [r7, #0]
    387a:	910c      	str	r1, [sp, #48]	; 0x30
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    387c:	4936      	ldr	r1, [pc, #216]	; (3958 <loop+0xa28>)
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    387e:	6a28      	ldr	r0, [r5, #32]
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    3880:	f8df c0e4 	ldr.w	ip, [pc, #228]	; 3968 <loop+0xa38>
	return ret;
    3884:	f8dd 9030 	ldr.w	r9, [sp, #48]	; 0x30
  }

  void syncTime(uint8_t * data)
  {
    std_msgs::Time t;
    uint32_t offset = hardware_.time() - rt_time;
    3888:	1a9b      	subs	r3, r3, r2
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    388a:	fba1 1e03 	umull	r1, lr, r1, r3
    388e:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    3892:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    3896:	4484      	add	ip, r0
    3898:	4830      	ldr	r0, [pc, #192]	; (395c <loop+0xa2c>)
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    389a:	69ea      	ldr	r2, [r5, #28]
    389c:	fb01 331e 	mls	r3, r1, lr, r3
    38a0:	fb00 cc03 	mla	ip, r0, r3, ip
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    38a4:	4b2c      	ldr	r3, [pc, #176]	; (3958 <loop+0xa28>)
    38a6:	fba3 3b09 	umull	r3, fp, r3, r9
    38aa:	ea4f 1b9b 	mov.w	fp, fp, lsr #6
    38ae:	3a01      	subs	r2, #1
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    38b0:	fb01 911b 	mls	r1, r1, fp, r9
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    38b4:	4472      	add	r2, lr
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    38b6:	fb00 c311 	mls	r3, r0, r1, ip
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    38ba:	ebcb 0202 	rsb	r2, fp, r2
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    normalizeSecNSec(sec_offset, nsec_offset);
    38be:	f10a 0114 	add.w	r1, sl, #20
    38c2:	f10a 0010 	add.w	r0, sl, #16

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    38c6:	616b      	str	r3, [r5, #20]
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    38c8:	612a      	str	r2, [r5, #16]
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    normalizeSecNSec(sec_offset, nsec_offset);
    38ca:	f001 fe5f 	bl	558c <ros::normalizeSecNSec(unsigned long&, unsigned long&)>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    38ce:	683b      	ldr	r3, [r7, #0]
    38d0:	930b      	str	r3, [sp, #44]	; 0x2c
	return ret;
    38d2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    t.deserialize(data);
    t.data.sec += offset / 1000;
    t.data.nsec += (offset % 1000) * 1000000UL;

    this->setNow(t.data);
    last_sync_receive_time = hardware_.time();
    38d4:	f8c5 3500 	str.w	r3, [r5, #1280]	; 0x500
    38d8:	e470      	b.n	31bc <loop+0x28c>
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    38da:	4614      	mov	r4, r2
    38dc:	2238      	movs	r2, #56	; 0x38
    38de:	e617      	b.n	3510 <loop+0x5e0>
    38e0:	4614      	mov	r4, r2
    38e2:	2238      	movs	r2, #56	; 0x38
    38e4:	e5f7      	b.n	34d6 <loop+0x5a6>
    38e6:	4614      	mov	r4, r2
    38e8:	2238      	movs	r2, #56	; 0x38
    38ea:	e62e      	b.n	354a <loop+0x61a>
    38ec:	4614      	mov	r4, r2
    38ee:	2238      	movs	r2, #56	; 0x38
    38f0:	e648      	b.n	3584 <loop+0x654>
    38f2:	469b      	mov	fp, r3
  {
    if (id >= 100 && !configured_)
      return 0;

    /* serialize message */
    int l = msg->serialize(message_out + 7);
    38f4:	f20a 2123 	addw	r1, sl, #547	; 0x223
    public:
      typedef ros::Time _data_type;
      _data_type data;

    Time():
      data()
    38f8:	4b19      	ldr	r3, [pc, #100]	; (3960 <loop+0xa30>)
    38fa:	930d      	str	r3, [sp, #52]	; 0x34
    38fc:	a80d      	add	r0, sp, #52	; 0x34
    38fe:	4691      	mov	r9, r2
class Time
{
public:
  uint32_t sec, nsec;

  Time() : sec(0), nsec(0) {}
    3900:	f8cd b038 	str.w	fp, [sp, #56]	; 0x38
    3904:	f8cd b03c 	str.w	fp, [sp, #60]	; 0x3c
    3908:	f7fc fdb0 	bl	46c <std_msgs::Time::serialize(unsigned char*) const>

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    390c:	b2c1      	uxtb	r1, r0
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    390e:	f3c0 2207 	ubfx	r2, r0, #8, #8
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3912:	188b      	adds	r3, r1, r2
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    3914:	25fe      	movs	r5, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3916:	43db      	mvns	r3, r3
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3918:	f88a 121e 	strb.w	r1, [sl, #542]	; 0x21e
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    391c:	f88a 521d 	strb.w	r5, [sl, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3920:	210a      	movs	r1, #10
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3922:	1c45      	adds	r5, r0, #1

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3924:	f88a 921c 	strb.w	r9, [sl, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3928:	f88a b222 	strb.w	fp, [sl, #546]	; 0x222
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    392c:	f88a 3220 	strb.w	r3, [sl, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3930:	f88a 221f 	strb.w	r2, [sl, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3934:	f88a 1221 	strb.w	r1, [sl, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3938:	db21      	blt.n	397e <loop+0xa4e>
    393a:	f200 2222 	addw	r2, r0, #546	; 0x222
    393e:	4452      	add	r2, sl
    3940:	465b      	mov	r3, fp
    3942:	f20a 2a21 	addw	sl, sl, #545	; 0x221
    3946:	e013      	b.n	3970 <loop+0xa40>
    3948:	1fff1f70 	.word	0x1fff1f70
    394c:	1fff2268 	.word	0x1fff2268
    3950:	1fff2274 	.word	0x1fff2274
    3954:	1fff2280 	.word	0x1fff2280
    3958:	10624dd3 	.word	0x10624dd3
    395c:	000f4240 	.word	0x000f4240
    3960:	00008f7c 	.word	0x00008f7c
    3964:	1fff1d54 	.word	0x1fff1d54
    3968:	3b9aca00 	.word	0x3b9aca00
    396c:	f81a 1f01 	ldrb.w	r1, [sl, #1]!
    3970:	4592      	cmp	sl, r2
      chk += message_out[i];
    3972:	440b      	add	r3, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3974:	d1fa      	bne.n	396c <loop+0xa3c>
    3976:	ea6f 0903 	mvn.w	r9, r3
    397a:	fa5f f989 	uxtb.w	r9, r9
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    397e:	1823      	adds	r3, r4, r0
    3980:	f100 0208 	add.w	r2, r0, #8

    if (l <= OUTPUT_SIZE)
    3984:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3988:	f883 9223 	strb.w	r9, [r3, #547]	; 0x223
    398c:	49d1      	ldr	r1, [pc, #836]	; (3cd4 <loop+0xda4>)

    if (l <= OUTPUT_SIZE)
    398e:	f300 8211 	bgt.w	3db4 <loop+0xe84>
    3992:	6848      	ldr	r0, [r1, #4]
    3994:	6803      	ldr	r3, [r0, #0]
    3996:	f501 7107 	add.w	r1, r1, #540	; 0x21c
    399a:	685b      	ldr	r3, [r3, #4]
    399c:	4798      	blx	r3
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    399e:	683b      	ldr	r3, [r7, #0]
    39a0:	9306      	str	r3, [sp, #24]
    39a2:	4fcd      	ldr	r7, [pc, #820]	; (3cd8 <loop+0xda8>)
	return ret;
    39a4:	9b06      	ldr	r3, [sp, #24]

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    rt_time = hardware_.time();
    39a6:	60e3      	str	r3, [r4, #12]
    39a8:	f107 0364 	add.w	r3, r7, #100	; 0x64
    39ac:	9300      	str	r3, [sp, #0]
      memcpy(outbuffer + offset, this->message_type, length_message_type);
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    39ae:	f5a7 6583 	sub.w	r5, r7, #1048	; 0x418
  {
    rosserial_msgs::TopicInfo ti;
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
    39b2:	f857 3f04 	ldr.w	r3, [r7, #4]!
    39b6:	2b00      	cmp	r3, #0
    39b8:	f000 80b8 	beq.w	3b2c <loop+0xbfc>
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    39bc:	6858      	ldr	r0, [r3, #4]
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
    39be:	689a      	ldr	r2, [r3, #8]
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    39c0:	6801      	ldr	r1, [r0, #0]
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
    39c2:	9201      	str	r2, [sp, #4]
        ti.topic_name = (char *) publishers[i]->topic_;
    39c4:	f8d3 b000 	ldr.w	fp, [r3]
        ti.message_type = (char *) publishers[i]->msg_->getType();
    39c8:	688b      	ldr	r3, [r1, #8]
    39ca:	4798      	blx	r3
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    39cc:	683b      	ldr	r3, [r7, #0]
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    39ce:	4682      	mov	sl, r0
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    39d0:	6858      	ldr	r0, [r3, #4]
    39d2:	6803      	ldr	r3, [r0, #0]
    39d4:	68db      	ldr	r3, [r3, #12]
    39d6:	4798      	blx	r3
    39d8:	683b      	ldr	r3, [r7, #0]
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    39da:	9a01      	ldr	r2, [sp, #4]
    39dc:	f8d3 8010 	ldr.w	r8, [r3, #16]
    39e0:	f1b8 0f63 	cmp.w	r8, #99	; 0x63
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    39e4:	4681      	mov	r9, r0
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    39e6:	dd04      	ble.n	39f2 <loop+0xac2>
    39e8:	f894 34f8 	ldrb.w	r3, [r4, #1272]	; 0x4f8
    39ec:	2b00      	cmp	r3, #0
    39ee:	f000 809d 	beq.w	3b2c <loop+0xbfc>

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    39f2:	f3c2 2307 	ubfx	r3, r2, #8, #8
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    39f6:	f884 2223 	strb.w	r2, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    39fa:	f884 3224 	strb.w	r3, [r4, #548]	; 0x224
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    39fe:	4658      	mov	r0, fp
    3a00:	f005 f89e 	bl	8b40 <strlen>
    3a04:	4603      	mov	r3, r0
  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
      arr[i] = (var >> (8 * i));
    3a06:	ea4f 6e13 	mov.w	lr, r3, lsr #24
    3a0a:	0a02      	lsrs	r2, r0, #8
    3a0c:	0c00      	lsrs	r0, r0, #16
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
    3a0e:	4659      	mov	r1, fp
    3a10:	f884 3225 	strb.w	r3, [r4, #549]	; 0x225
    3a14:	f884 2226 	strb.w	r2, [r4, #550]	; 0x226
    3a18:	f884 0227 	strb.w	r0, [r4, #551]	; 0x227
    3a1c:	461a      	mov	r2, r3
    3a1e:	f884 e228 	strb.w	lr, [r4, #552]	; 0x228
    3a22:	48ae      	ldr	r0, [pc, #696]	; (3cdc <loop+0xdac>)
    3a24:	9301      	str	r3, [sp, #4]
    3a26:	f001 fdc5 	bl	55b4 <memcpy>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
    3a2a:	4650      	mov	r0, sl
    3a2c:	f005 f888 	bl	8b40 <strlen>
    3a30:	9b01      	ldr	r3, [sp, #4]
    3a32:	4602      	mov	r2, r0
    3a34:	f203 2029 	addw	r0, r3, #553	; 0x229
    3a38:	4420      	add	r0, r4
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
    3a3a:	3306      	adds	r3, #6
      uint32_t length_message_type = strlen(this->message_type);
    3a3c:	2100      	movs	r1, #0
    3a3e:	fa22 fe01 	lsr.w	lr, r2, r1
    3a42:	3108      	adds	r1, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3a44:	2920      	cmp	r1, #32
      arr[i] = (var >> (8 * i));
    3a46:	f800 eb01 	strb.w	lr, [r0], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3a4a:	d1f8      	bne.n	3a3e <loop+0xb0e>
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    3a4c:	48a4      	ldr	r0, [pc, #656]	; (3ce0 <loop+0xdb0>)
    3a4e:	3304      	adds	r3, #4
    3a50:	4651      	mov	r1, sl
    3a52:	4418      	add	r0, r3
      offset += length_message_type;
    3a54:	eb02 0a03 	add.w	sl, r2, r3
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    3a58:	f001 fdac 	bl	55b4 <memcpy>
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
    3a5c:	4648      	mov	r0, r9
    3a5e:	f005 f86f 	bl	8b40 <strlen>
    3a62:	f20a 2223 	addw	r2, sl, #547	; 0x223
    3a66:	4683      	mov	fp, r0
    3a68:	4422      	add	r2, r4
    3a6a:	2300      	movs	r3, #0
      arr[i] = (var >> (8 * i));
    3a6c:	fa2b f103 	lsr.w	r1, fp, r3
    3a70:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3a72:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
    3a74:	f802 1b01 	strb.w	r1, [r2], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3a78:	d1f8      	bne.n	3a6c <loop+0xb3c>
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    3a7a:	4b99      	ldr	r3, [pc, #612]	; (3ce0 <loop+0xdb0>)
    3a7c:	f10a 0a04 	add.w	sl, sl, #4
    3a80:	4649      	mov	r1, r9
    3a82:	eb03 000a 	add.w	r0, r3, sl
    3a86:	465a      	mov	r2, fp
    3a88:	f001 fd94 	bl	55b4 <memcpy>
      offset += length_md5sum;
    3a8c:	eb0b 000a 	add.w	r0, fp, sl
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
    3a90:	f100 0e04 	add.w	lr, r0, #4
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    3a94:	1821      	adds	r1, r4, r0
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3a96:	fa5f f98e 	uxtb.w	r9, lr
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3a9a:	f3ce 2c07 	ubfx	ip, lr, #8, #8
    3a9e:	2200      	movs	r2, #0
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    3aa0:	2302      	movs	r3, #2
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3aa2:	eb09 0b0c 	add.w	fp, r9, ip
    3aa6:	f881 3224 	strb.w	r3, [r1, #548]	; 0x224
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    3aaa:	f881 2223 	strb.w	r2, [r1, #547]	; 0x223
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
    3aae:	f881 2225 	strb.w	r2, [r1, #549]	; 0x225
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
    3ab2:	f881 2226 	strb.w	r2, [r1, #550]	; 0x226
    3ab6:	ea6f 0b0b 	mvn.w	fp, fp
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3aba:	fa5f f188 	uxtb.w	r1, r8

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3abe:	23ff      	movs	r3, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    3ac0:	f04f 0afe 	mov.w	sl, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3ac4:	f348 2807 	sbfx	r8, r8, #8, #8

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3ac8:	f1be 3fff 	cmp.w	lr, #4294967295	; 0xffffffff
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3acc:	f884 b220 	strb.w	fp, [r4, #544]	; 0x220
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3ad0:	f884 921e 	strb.w	r9, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3ad4:	f884 c21f 	strb.w	ip, [r4, #543]	; 0x21f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3ad8:	f884 321c 	strb.w	r3, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    3adc:	f884 a21d 	strb.w	sl, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3ae0:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3ae4:	f884 8222 	strb.w	r8, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3ae8:	db0b      	blt.n	3b02 <loop+0xbd2>
    3aea:	f200 2026 	addw	r0, r0, #550	; 0x226
    3aee:	4b7d      	ldr	r3, [pc, #500]	; (3ce4 <loop+0xdb4>)
    3af0:	4428      	add	r0, r5
    3af2:	e001      	b.n	3af8 <loop+0xbc8>
    3af4:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    3af8:	4283      	cmp	r3, r0
      chk += message_out[i];
    3afa:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3afc:	d1fa      	bne.n	3af4 <loop+0xbc4>
    3afe:	43d3      	mvns	r3, r2
    3b00:	b2db      	uxtb	r3, r3
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3b02:	eb04 010e 	add.w	r1, r4, lr
    3b06:	f10e 0208 	add.w	r2, lr, #8

    if (l <= OUTPUT_SIZE)
    3b0a:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3b0e:	f881 3223 	strb.w	r3, [r1, #547]	; 0x223

    if (l <= OUTPUT_SIZE)
    3b12:	f300 8153 	bgt.w	3dbc <loop+0xe8c>
    3b16:	6868      	ldr	r0, [r5, #4]
    3b18:	4973      	ldr	r1, [pc, #460]	; (3ce8 <loop+0xdb8>)
    3b1a:	6803      	ldr	r3, [r0, #0]
    3b1c:	685b      	ldr	r3, [r3, #4]
    3b1e:	428b      	cmp	r3, r1
    3b20:	f040 80fa 	bne.w	3d18 <loop+0xde8>
    3b24:	4611      	mov	r1, r2
    3b26:	4871      	ldr	r0, [pc, #452]	; (3cec <loop+0xdbc>)
    3b28:	f003 f85c 	bl	6be4 <usb_serial_write>

  void negotiateTopics()
  {
    rosserial_msgs::TopicInfo ti;
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    3b2c:	9b00      	ldr	r3, [sp, #0]
    3b2e:	429f      	cmp	r7, r3
    3b30:	f47f af3f 	bne.w	39b2 <loop+0xa82>
    3b34:	f8df b1b8 	ldr.w	fp, [pc, #440]	; 3cf0 <loop+0xdc0>
      memcpy(outbuffer + offset, this->message_type, length_message_type);
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    3b38:	9601      	str	r6, [sp, #4]
    3b3a:	f5ab 659c 	sub.w	r5, fp, #1248	; 0x4e0
    3b3e:	461e      	mov	r6, r3
        publish(publishers[i]->getEndpointType(), &ti);
      }
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
    3b40:	f856 0f04 	ldr.w	r0, [r6, #4]!
    3b44:	2800      	cmp	r0, #0
    3b46:	f000 80b4 	beq.w	3cb2 <loop+0xd82>
      {
        ti.topic_id = subscribers[i]->id_;
    3b4a:	e890 000c 	ldmia.w	r0, {r2, r3}
    3b4e:	9300      	str	r3, [sp, #0]
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
    3b50:	6892      	ldr	r2, [r2, #8]
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
    3b52:	f8d0 a008 	ldr.w	sl, [r0, #8]
        ti.message_type = (char *) subscribers[i]->getMsgType();
    3b56:	4790      	blx	r2
    3b58:	4681      	mov	r9, r0
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
    3b5a:	6830      	ldr	r0, [r6, #0]
    3b5c:	6802      	ldr	r2, [r0, #0]
    3b5e:	68d2      	ldr	r2, [r2, #12]
    3b60:	4790      	blx	r2
    3b62:	4680      	mov	r8, r0
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
    3b64:	6830      	ldr	r0, [r6, #0]
    3b66:	6802      	ldr	r2, [r0, #0]
    3b68:	6852      	ldr	r2, [r2, #4]
    3b6a:	4790      	blx	r2
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    3b6c:	2863      	cmp	r0, #99	; 0x63
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
    3b6e:	4607      	mov	r7, r0
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    3b70:	9b00      	ldr	r3, [sp, #0]
    3b72:	dd04      	ble.n	3b7e <loop+0xc4e>
    3b74:	f894 24f8 	ldrb.w	r2, [r4, #1272]	; 0x4f8
    3b78:	2a00      	cmp	r2, #0
    3b7a:	f000 809a 	beq.w	3cb2 <loop+0xd82>

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    3b7e:	f3c3 2207 	ubfx	r2, r3, #8, #8
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    3b82:	f884 3223 	strb.w	r3, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    3b86:	f884 2224 	strb.w	r2, [r4, #548]	; 0x224
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    3b8a:	4650      	mov	r0, sl
    3b8c:	f004 ffd8 	bl	8b40 <strlen>
    3b90:	4603      	mov	r3, r0
      arr[i] = (var >> (8 * i));
    3b92:	ea4f 6e13 	mov.w	lr, r3, lsr #24
    3b96:	0a02      	lsrs	r2, r0, #8
    3b98:	0c00      	lsrs	r0, r0, #16
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
    3b9a:	4651      	mov	r1, sl
    3b9c:	f884 3225 	strb.w	r3, [r4, #549]	; 0x225
    3ba0:	f884 2226 	strb.w	r2, [r4, #550]	; 0x226
    3ba4:	f884 0227 	strb.w	r0, [r4, #551]	; 0x227
    3ba8:	461a      	mov	r2, r3
    3baa:	f884 e228 	strb.w	lr, [r4, #552]	; 0x228
    3bae:	484b      	ldr	r0, [pc, #300]	; (3cdc <loop+0xdac>)
    3bb0:	9300      	str	r3, [sp, #0]
    3bb2:	f001 fcff 	bl	55b4 <memcpy>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
    3bb6:	4648      	mov	r0, r9
    3bb8:	f004 ffc2 	bl	8b40 <strlen>
    3bbc:	9b00      	ldr	r3, [sp, #0]
    3bbe:	4602      	mov	r2, r0
    3bc0:	f203 2029 	addw	r0, r3, #553	; 0x229
    3bc4:	4420      	add	r0, r4
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
    3bc6:	3306      	adds	r3, #6
      uint32_t length_message_type = strlen(this->message_type);
    3bc8:	2100      	movs	r1, #0
    3bca:	fa22 fe01 	lsr.w	lr, r2, r1
    3bce:	3108      	adds	r1, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3bd0:	2920      	cmp	r1, #32
      arr[i] = (var >> (8 * i));
    3bd2:	f800 eb01 	strb.w	lr, [r0], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3bd6:	d1f8      	bne.n	3bca <loop+0xc9a>
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    3bd8:	4841      	ldr	r0, [pc, #260]	; (3ce0 <loop+0xdb0>)
    3bda:	3304      	adds	r3, #4
    3bdc:	4649      	mov	r1, r9
    3bde:	4418      	add	r0, r3
      offset += length_message_type;
    3be0:	eb02 0903 	add.w	r9, r2, r3
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    3be4:	f001 fce6 	bl	55b4 <memcpy>
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
    3be8:	4640      	mov	r0, r8
    3bea:	f004 ffa9 	bl	8b40 <strlen>
    3bee:	f209 2223 	addw	r2, r9, #547	; 0x223
    3bf2:	4682      	mov	sl, r0
    3bf4:	4422      	add	r2, r4
    3bf6:	2300      	movs	r3, #0
      arr[i] = (var >> (8 * i));
    3bf8:	fa2a f103 	lsr.w	r1, sl, r3
    3bfc:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3bfe:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
    3c00:	f802 1b01 	strb.w	r1, [r2], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3c04:	d1f8      	bne.n	3bf8 <loop+0xcc8>
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    3c06:	4b36      	ldr	r3, [pc, #216]	; (3ce0 <loop+0xdb0>)
    3c08:	f109 0904 	add.w	r9, r9, #4
    3c0c:	4641      	mov	r1, r8
    3c0e:	eb03 0009 	add.w	r0, r3, r9
    3c12:	4652      	mov	r2, sl
    3c14:	f001 fcce 	bl	55b4 <memcpy>
      offset += length_md5sum;
    3c18:	eb0a 0009 	add.w	r0, sl, r9
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
    3c1c:	f100 0e04 	add.w	lr, r0, #4
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3c20:	fa5f f88e 	uxtb.w	r8, lr
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3c24:	f3ce 2c07 	ubfx	ip, lr, #8, #8
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    3c28:	eb04 0900 	add.w	r9, r4, r0
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3c2c:	eb08 010c 	add.w	r1, r8, ip
    3c30:	2200      	movs	r2, #0
    3c32:	43c9      	mvns	r1, r1
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    3c34:	2302      	movs	r3, #2
    3c36:	f889 3224 	strb.w	r3, [r9, #548]	; 0x224
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    3c3a:	f889 2223 	strb.w	r2, [r9, #547]	; 0x223
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
    3c3e:	f889 2225 	strb.w	r2, [r9, #549]	; 0x225
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
    3c42:	f889 2226 	strb.w	r2, [r9, #550]	; 0x226

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3c46:	23ff      	movs	r3, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    3c48:	f04f 09fe 	mov.w	r9, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3c4c:	f884 1220 	strb.w	r1, [r4, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3c50:	f1be 3fff 	cmp.w	lr, #4294967295	; 0xffffffff
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3c54:	b2f9      	uxtb	r1, r7
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3c56:	f347 2707 	sbfx	r7, r7, #8, #8
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3c5a:	f884 821e 	strb.w	r8, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3c5e:	f884 c21f 	strb.w	ip, [r4, #543]	; 0x21f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3c62:	f884 321c 	strb.w	r3, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    3c66:	f884 921d 	strb.w	r9, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3c6a:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3c6e:	f884 7222 	strb.w	r7, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3c72:	db0b      	blt.n	3c8c <loop+0xd5c>
    3c74:	f200 2026 	addw	r0, r0, #550	; 0x226
    3c78:	4b1a      	ldr	r3, [pc, #104]	; (3ce4 <loop+0xdb4>)
    3c7a:	4428      	add	r0, r5
    3c7c:	e001      	b.n	3c82 <loop+0xd52>
    3c7e:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    3c82:	4283      	cmp	r3, r0
      chk += message_out[i];
    3c84:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3c86:	d1fa      	bne.n	3c7e <loop+0xd4e>
    3c88:	43d3      	mvns	r3, r2
    3c8a:	b2db      	uxtb	r3, r3
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3c8c:	eb04 010e 	add.w	r1, r4, lr
    3c90:	f10e 0208 	add.w	r2, lr, #8

    if (l <= OUTPUT_SIZE)
    3c94:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3c98:	f881 3223 	strb.w	r3, [r1, #547]	; 0x223

    if (l <= OUTPUT_SIZE)
    3c9c:	dc42      	bgt.n	3d24 <loop+0xdf4>
    3c9e:	6868      	ldr	r0, [r5, #4]
    3ca0:	4911      	ldr	r1, [pc, #68]	; (3ce8 <loop+0xdb8>)
    3ca2:	6803      	ldr	r3, [r0, #0]
    3ca4:	685b      	ldr	r3, [r3, #4]
    3ca6:	428b      	cmp	r3, r1
    3ca8:	d139      	bne.n	3d1e <loop+0xdee>
    3caa:	4611      	mov	r1, r2
    3cac:	480f      	ldr	r0, [pc, #60]	; (3cec <loop+0xdbc>)
    3cae:	f002 ff99 	bl	6be4 <usb_serial_write>
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
        ti.buffer_size = OUTPUT_SIZE;
        publish(publishers[i]->getEndpointType(), &ti);
      }
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    3cb2:	455e      	cmp	r6, fp
    3cb4:	f47f af44 	bne.w	3b40 <loop+0xc10>
    3cb8:	9e01      	ldr	r6, [sp, #4]
        {
          if (topic_ == TopicInfo::ID_PUBLISHER)
          {
            requestSyncTime();
            negotiateTopics();
            last_sync_time = c_time;
    3cba:	f8c4 64fc 	str.w	r6, [r4, #1276]	; 0x4fc
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
      }
    }
    configured_ = true;
    3cbe:	2301      	movs	r3, #1
          if (topic_ == TopicInfo::ID_PUBLISHER)
          {
            requestSyncTime();
            negotiateTopics();
            last_sync_time = c_time;
            last_sync_receive_time = c_time;
    3cc0:	f8c4 6500 	str.w	r6, [r4, #1280]	; 0x500
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
      }
    }
    configured_ = true;
    3cc4:	f884 34f8 	strb.w	r3, [r4, #1272]	; 0x4f8
    3cc8:	f7ff baa4 	b.w	3214 <loop+0x2e4>
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
      floats_length = floats_lengthT;
      for( uint32_t i = 0; i < floats_length; i++){
    3ccc:	f8dd 9004 	ldr.w	r9, [sp, #4]
    3cd0:	e56f      	b.n	37b2 <loop+0x882>
    3cd2:	bf00      	nop
    3cd4:	1fff1d54 	.word	0x1fff1d54
    3cd8:	1fff216c 	.word	0x1fff216c
    3cdc:	1fff1f7d 	.word	0x1fff1f7d
    3ce0:	1fff1f77 	.word	0x1fff1f77
    3ce4:	1fff1f75 	.word	0x1fff1f75
    3ce8:	00000949 	.word	0x00000949
    3cec:	1fff1f70 	.word	0x1fff1f70
    3cf0:	1fff2234 	.word	0x1fff2234
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
      ints_length = ints_lengthT;
      for( uint32_t i = 0; i < ints_length; i++){
    3cf4:	220b      	movs	r2, #11
    3cf6:	230c      	movs	r3, #12
    3cf8:	f04f 0a08 	mov.w	sl, #8
    3cfc:	2105      	movs	r1, #5
    3cfe:	e88d 000c 	stmia.w	sp, {r2, r3}
    3d02:	46d3      	mov	fp, sl
    3d04:	220a      	movs	r2, #10
    3d06:	2309      	movs	r3, #9
    3d08:	f04f 0c07 	mov.w	ip, #7
    3d0c:	f04f 0e06 	mov.w	lr, #6
    3d10:	9102      	str	r1, [sp, #8]
    3d12:	f04f 0904 	mov.w	r9, #4
    3d16:	e4f1      	b.n	36fc <loop+0x7cc>
    3d18:	494e      	ldr	r1, [pc, #312]	; (3e54 <loop+0xf24>)
    3d1a:	4798      	blx	r3
    3d1c:	e706      	b.n	3b2c <loop+0xbfc>
    3d1e:	494d      	ldr	r1, [pc, #308]	; (3e54 <loop+0xf24>)
    3d20:	4798      	blx	r3
    3d22:	e7c6      	b.n	3cb2 <loop+0xd82>
    3d24:	4f4c      	ldr	r7, [pc, #304]	; (3e58 <loop+0xf28>)
    3d26:	f8df e134 	ldr.w	lr, [pc, #308]	; 3e5c <loop+0xf2c>
    3d2a:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    3d2c:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    3d30:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    3d32:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    3d36:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    3d38:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    3d3c:	e897 0003 	ldmia.w	r7, {r0, r1}
      arr[i] = (var >> (8 * i));
    3d40:	2300      	movs	r3, #0
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    3d42:	2703      	movs	r7, #3
    3d44:	2238      	movs	r2, #56	; 0x38
    3d46:	f885 7223 	strb.w	r7, [r5, #547]	; 0x223
    3d4a:	f885 2224 	strb.w	r2, [r5, #548]	; 0x224
    3d4e:	f885 3225 	strb.w	r3, [r5, #549]	; 0x225
    3d52:	f885 3226 	strb.w	r3, [r5, #550]	; 0x226
    3d56:	f885 3227 	strb.w	r3, [r5, #551]	; 0x227

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3d5a:	f04f 08ff 	mov.w	r8, #255	; 0xff
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    3d5e:	e88e 0003 	stmia.w	lr, {r0, r1}
    message_out[1] = PROTOCOL_VER;
    3d62:	f04f 0cfe 	mov.w	ip, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3d66:	273d      	movs	r7, #61	; 0x3d
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3d68:	f04f 09c2 	mov.w	r9, #194	; 0xc2
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3d6c:	2107      	movs	r1, #7

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3d6e:	f885 321f 	strb.w	r3, [r5, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3d72:	f885 3222 	strb.w	r3, [r5, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    3d76:	461a      	mov	r2, r3
    3d78:	f1ae 0037 	sub.w	r0, lr, #55	; 0x37
    3d7c:	f10e 0307 	add.w	r3, lr, #7

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3d80:	f885 821c 	strb.w	r8, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    3d84:	f885 c21d 	strb.w	ip, [r5, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3d88:	f885 721e 	strb.w	r7, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3d8c:	f885 9220 	strb.w	r9, [r5, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3d90:	f885 1221 	strb.w	r1, [r5, #545]	; 0x221
    3d94:	e001      	b.n	3d9a <loop+0xe6a>
    3d96:	f810 1f01 	ldrb.w	r1, [r0, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3d9a:	4283      	cmp	r3, r0
      chk += message_out[i];
    3d9c:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3d9e:	d1fa      	bne.n	3d96 <loop+0xe66>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3da0:	43d3      	mvns	r3, r2
    3da2:	6860      	ldr	r0, [r4, #4]
    3da4:	f884 3260 	strb.w	r3, [r4, #608]	; 0x260
    3da8:	6803      	ldr	r3, [r0, #0]
    3daa:	492a      	ldr	r1, [pc, #168]	; (3e54 <loop+0xf24>)
    3dac:	685b      	ldr	r3, [r3, #4]
    3dae:	2245      	movs	r2, #69	; 0x45
    3db0:	4798      	blx	r3
    3db2:	e77e      	b.n	3cb2 <loop+0xd82>
    3db4:	4608      	mov	r0, r1
    3db6:	f7fd fb93 	bl	14e0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.9] [clone .constprop.11]>
    3dba:	e5f0      	b.n	399e <loop+0xa6e>
    3dbc:	f8df c098 	ldr.w	ip, [pc, #152]	; 3e58 <loop+0xf28>
    3dc0:	f8df e098 	ldr.w	lr, [pc, #152]	; 3e5c <loop+0xf2c>
    3dc4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    3dc8:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    3dcc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    3dd0:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    3dd4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    3dd8:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    3ddc:	e89c 0003 	ldmia.w	ip, {r0, r1}
    3de0:	2300      	movs	r3, #0
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    3de2:	f04f 0803 	mov.w	r8, #3
    3de6:	f04f 0c38 	mov.w	ip, #56	; 0x38

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3dea:	22ff      	movs	r2, #255	; 0xff
    3dec:	f885 8223 	strb.w	r8, [r5, #547]	; 0x223
    3df0:	f885 c224 	strb.w	ip, [r5, #548]	; 0x224
    message_out[1] = PROTOCOL_VER;
    3df4:	f04f 08fe 	mov.w	r8, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3df8:	f04f 0c3d 	mov.w	ip, #61	; 0x3d
    3dfc:	f885 3225 	strb.w	r3, [r5, #549]	; 0x225
    3e00:	f885 3226 	strb.w	r3, [r5, #550]	; 0x226
    3e04:	f885 3227 	strb.w	r3, [r5, #551]	; 0x227
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    3e08:	e88e 0003 	stmia.w	lr, {r0, r1}
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3e0c:	20c2      	movs	r0, #194	; 0xc2

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3e0e:	f885 221c 	strb.w	r2, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3e12:	2207      	movs	r2, #7
    3e14:	f1ae 0137 	sub.w	r1, lr, #55	; 0x37

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3e18:	f885 321f 	strb.w	r3, [r5, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3e1c:	f885 3222 	strb.w	r3, [r5, #546]	; 0x222
    3e20:	f10e 0e07 	add.w	lr, lr, #7
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    3e24:	f885 821d 	strb.w	r8, [r5, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3e28:	f885 c21e 	strb.w	ip, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3e2c:	f885 0220 	strb.w	r0, [r5, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3e30:	f885 2221 	strb.w	r2, [r5, #545]	; 0x221
    3e34:	e001      	b.n	3e3a <loop+0xf0a>
    3e36:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3e3a:	4571      	cmp	r1, lr
      chk += message_out[i];
    3e3c:	4413      	add	r3, r2
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3e3e:	d1fa      	bne.n	3e36 <loop+0xf06>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3e40:	43db      	mvns	r3, r3
    3e42:	6860      	ldr	r0, [r4, #4]
    3e44:	f884 3260 	strb.w	r3, [r4, #608]	; 0x260
    3e48:	6803      	ldr	r3, [r0, #0]
    3e4a:	4902      	ldr	r1, [pc, #8]	; (3e54 <loop+0xf24>)
    3e4c:	685b      	ldr	r3, [r3, #4]
    3e4e:	2245      	movs	r2, #69	; 0x45
    3e50:	4798      	blx	r3
    3e52:	e66b      	b.n	3b2c <loop+0xbfc>
    3e54:	1fff1f70 	.word	0x1fff1f70
    3e58:	00009280 	.word	0x00009280
    3e5c:	1fff1f7c 	.word	0x1fff1f7c

00003e60 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()>:
    bool v = advertise(srv.pub);
    bool w = subscribe(srv);
    return v && w;
  }

  void negotiateTopics()
    3e60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3e64:	b08d      	sub	sp, #52	; 0x34
    TopicInfo():
      topic_id(0),
      topic_name(""),
      message_type(""),
      md5sum(""),
      buffer_size(0)
    3e66:	4ac8      	ldr	r2, [pc, #800]	; (4188 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x328>)
    3e68:	4bc8      	ldr	r3, [pc, #800]	; (418c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x32c>)
    3e6a:	9206      	str	r2, [sp, #24]
    3e6c:	2200      	movs	r2, #0
    3e6e:	4604      	mov	r4, r0
    3e70:	f500 6683 	add.w	r6, r0, #1048	; 0x418
    3e74:	f200 457c 	addw	r5, r0, #1148	; 0x47c
    3e78:	f8ad 201c 	strh.w	r2, [sp, #28]
    3e7c:	920b      	str	r2, [sp, #44]	; 0x2c
    3e7e:	9308      	str	r3, [sp, #32]
    3e80:	9309      	str	r3, [sp, #36]	; 0x24
    3e82:	930a      	str	r3, [sp, #40]	; 0x28
  {
    rosserial_msgs::TopicInfo ti;
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
    3e84:	f856 3f04 	ldr.w	r3, [r6, #4]!
    3e88:	2b00      	cmp	r3, #0
    3e8a:	f000 80c2 	beq.w	4012 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    3e8e:	6858      	ldr	r0, [r3, #4]
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
    3e90:	681f      	ldr	r7, [r3, #0]
        ti.message_type = (char *) publishers[i]->msg_->getType();
    3e92:	6801      	ldr	r1, [r0, #0]
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
    3e94:	689a      	ldr	r2, [r3, #8]
        ti.topic_name = (char *) publishers[i]->topic_;
    3e96:	9708      	str	r7, [sp, #32]
        ti.message_type = (char *) publishers[i]->msg_->getType();
    3e98:	688b      	ldr	r3, [r1, #8]
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
    3e9a:	f8ad 201c 	strh.w	r2, [sp, #28]
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    3e9e:	4798      	blx	r3
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    3ea0:	6833      	ldr	r3, [r6, #0]
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    3ea2:	9009      	str	r0, [sp, #36]	; 0x24
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    3ea4:	6858      	ldr	r0, [r3, #4]
    3ea6:	6803      	ldr	r3, [r0, #0]
    3ea8:	68db      	ldr	r3, [r3, #12]
    3eaa:	4798      	blx	r3
        ti.buffer_size = OUTPUT_SIZE;
        publish(publishers[i]->getEndpointType(), &ti);
    3eac:	6823      	ldr	r3, [r4, #0]
    3eae:	6831      	ldr	r1, [r6, #0]
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    3eb0:	900a      	str	r0, [sp, #40]	; 0x28
        ti.buffer_size = OUTPUT_SIZE;
    3eb2:	f44f 7200 	mov.w	r2, #512	; 0x200
        publish(publishers[i]->getEndpointType(), &ti);
    3eb6:	681b      	ldr	r3, [r3, #0]
    3eb8:	f8d1 8010 	ldr.w	r8, [r1, #16]
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
        ti.buffer_size = OUTPUT_SIZE;
    3ebc:	920b      	str	r2, [sp, #44]	; 0x2c
    3ebe:	4ab4      	ldr	r2, [pc, #720]	; (4190 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x330>)
    3ec0:	4293      	cmp	r3, r2
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    3ec2:	4682      	mov	sl, r0
    3ec4:	f040 818c 	bne.w	41e0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x380>
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    3ec8:	f1b8 0f63 	cmp.w	r8, #99	; 0x63
    3ecc:	dd04      	ble.n	3ed8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x78>
    3ece:	f894 34f8 	ldrb.w	r3, [r4, #1272]	; 0x4f8
    3ed2:	2b00      	cmp	r3, #0
    3ed4:	f000 809d 	beq.w	4012 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    3ed8:	f8bd 301c 	ldrh.w	r3, [sp, #28]
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    3edc:	f8dd 9020 	ldr.w	r9, [sp, #32]
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    3ee0:	f884 3223 	strb.w	r3, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    3ee4:	0a1b      	lsrs	r3, r3, #8
    3ee6:	f884 3224 	strb.w	r3, [r4, #548]	; 0x224
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    3eea:	4648      	mov	r0, r9
    3eec:	f004 fe28 	bl	8b40 <strlen>
    3ef0:	4607      	mov	r7, r0
    3ef2:	0e3b      	lsrs	r3, r7, #24
    3ef4:	0c3a      	lsrs	r2, r7, #16
    3ef6:	0a00      	lsrs	r0, r0, #8
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
    3ef8:	4649      	mov	r1, r9
    3efa:	f884 3228 	strb.w	r3, [r4, #552]	; 0x228
    3efe:	f884 7225 	strb.w	r7, [r4, #549]	; 0x225
    3f02:	f884 0226 	strb.w	r0, [r4, #550]	; 0x226
    3f06:	f884 2227 	strb.w	r2, [r4, #551]	; 0x227
    3f0a:	f204 2029 	addw	r0, r4, #553	; 0x229
    3f0e:	463a      	mov	r2, r7
    3f10:	f001 fb50 	bl	55b4 <memcpy>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
    3f14:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
    3f18:	4658      	mov	r0, fp
    3f1a:	f004 fe11 	bl	8b40 <strlen>
      return 0;

    /* serialize message */
    int l = msg->serialize(message_out + 7);
    3f1e:	f204 2923 	addw	r9, r4, #547	; 0x223
    3f22:	1d79      	adds	r1, r7, #5
    3f24:	4602      	mov	r2, r0
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
    3f26:	3706      	adds	r7, #6
    3f28:	4449      	add	r1, r9
      uint32_t length_message_type = strlen(this->message_type);
    3f2a:	2300      	movs	r3, #0
    3f2c:	fa22 f003 	lsr.w	r0, r2, r3
    3f30:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3f32:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
    3f34:	f801 0f01 	strb.w	r0, [r1, #1]!

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3f38:	d1f8      	bne.n	3f2c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0xcc>
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    3f3a:	3704      	adds	r7, #4
    3f3c:	4659      	mov	r1, fp
    3f3e:	eb09 0007 	add.w	r0, r9, r7
      offset += length_message_type;
    3f42:	4417      	add	r7, r2
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    3f44:	f001 fb36 	bl	55b4 <memcpy>
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
    3f48:	4650      	mov	r0, sl
    3f4a:	f004 fdf9 	bl	8b40 <strlen>
    3f4e:	eb09 0307 	add.w	r3, r9, r7
    3f52:	4683      	mov	fp, r0
    3f54:	2200      	movs	r2, #0
      arr[i] = (var >> (8 * i));
    3f56:	fa2b f102 	lsr.w	r1, fp, r2
    3f5a:	3208      	adds	r2, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3f5c:	2a20      	cmp	r2, #32
      arr[i] = (var >> (8 * i));
    3f5e:	f803 1b01 	strb.w	r1, [r3], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3f62:	d1f8      	bne.n	3f56 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0xf6>
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    3f64:	3704      	adds	r7, #4
    3f66:	4651      	mov	r1, sl
    3f68:	eb09 0007 	add.w	r0, r9, r7
    3f6c:	465a      	mov	r2, fp
    3f6e:	f001 fb21 	bl	55b4 <memcpy>
      offset += length_md5sum;
    3f72:	eb0b 0307 	add.w	r3, fp, r7
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
    3f76:	1d1f      	adds	r7, r3, #4
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    3f78:	eb09 0103 	add.w	r1, r9, r3

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3f7c:	fa5f fa87 	uxtb.w	sl, r7
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3f80:	f3c7 2c07 	ubfx	ip, r7, #8, #8
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    3f84:	2200      	movs	r2, #0
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3f86:	eb0a 0e0c 	add.w	lr, sl, ip
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    3f8a:	f04f 0b02 	mov.w	fp, #2
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    3f8e:	f809 2003 	strb.w	r2, [r9, r3]
    3f92:	ea6f 0e0e 	mvn.w	lr, lr
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
    3f96:	708a      	strb	r2, [r1, #2]
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
    3f98:	70ca      	strb	r2, [r1, #3]
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    3f9a:	f881 b001 	strb.w	fp, [r1, #1]

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3f9e:	20ff      	movs	r0, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3fa0:	fa5f f188 	uxtb.w	r1, r8
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    3fa4:	f04f 09fe 	mov.w	r9, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3fa8:	f348 2807 	sbfx	r8, r8, #8, #8

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3fac:	f1b7 3fff 	cmp.w	r7, #4294967295	; 0xffffffff
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3fb0:	f884 e220 	strb.w	lr, [r4, #544]	; 0x220
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3fb4:	f884 a21e 	strb.w	sl, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3fb8:	f884 c21f 	strb.w	ip, [r4, #543]	; 0x21f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3fbc:	f884 021c 	strb.w	r0, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    3fc0:	f884 921d 	strb.w	r9, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3fc4:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3fc8:	f884 8222 	strb.w	r8, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3fcc:	f2c0 81b4 	blt.w	4338 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4d8>
    3fd0:	f203 2326 	addw	r3, r3, #550	; 0x226
    3fd4:	18e0      	adds	r0, r4, r3
    3fd6:	f204 2321 	addw	r3, r4, #545	; 0x221
    3fda:	e001      	b.n	3fe0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x180>
    3fdc:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    3fe0:	4298      	cmp	r0, r3
      chk += message_out[i];
    3fe2:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3fe4:	d1fa      	bne.n	3fdc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x17c>
    3fe6:	43d2      	mvns	r2, r2
    3fe8:	b2d2      	uxtb	r2, r2
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3fea:	19e3      	adds	r3, r4, r7
    3fec:	f107 0108 	add.w	r1, r7, #8

    if (l <= OUTPUT_SIZE)
    3ff0:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3ff4:	f883 2223 	strb.w	r2, [r3, #547]	; 0x223

    if (l <= OUTPUT_SIZE)
    3ff8:	f300 8106 	bgt.w	4208 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x3a8>
    3ffc:	6867      	ldr	r7, [r4, #4]
    3ffe:	4a65      	ldr	r2, [pc, #404]	; (4194 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x334>)
    4000:	683b      	ldr	r3, [r7, #0]
    4002:	685b      	ldr	r3, [r3, #4]
    4004:	4293      	cmp	r3, r2
    {
      hardware_.write(message_out, l);
    4006:	f504 7007 	add.w	r0, r4, #540	; 0x21c
    400a:	f040 80f3 	bne.w	41f4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x394>
    400e:	f002 fde9 	bl	6be4 <usb_serial_write>

  void negotiateTopics()
  {
    rosserial_msgs::TopicInfo ti;
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    4012:	42ae      	cmp	r6, r5
    4014:	f47f af36 	bne.w	3e84 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x24>
    4018:	f8df 9174 	ldr.w	r9, [pc, #372]	; 4190 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x330>
    401c:	f504 689c 	add.w	r8, r4, #1248	; 0x4e0
        publish(publishers[i]->getEndpointType(), &ti);
      }
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
    4020:	f855 0f04 	ldr.w	r0, [r5, #4]!
    4024:	2800      	cmp	r0, #0
    4026:	f000 80d2 	beq.w	41ce <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x36e>
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
    402a:	6881      	ldr	r1, [r0, #8]
        ti.message_type = (char *) subscribers[i]->getMsgType();
    402c:	6803      	ldr	r3, [r0, #0]
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
    402e:	6842      	ldr	r2, [r0, #4]
        ti.topic_name = (char *) subscribers[i]->topic_;
    4030:	9108      	str	r1, [sp, #32]
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
    4032:	f8ad 201c 	strh.w	r2, [sp, #28]
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
    4036:	689b      	ldr	r3, [r3, #8]
    4038:	4798      	blx	r3
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
    403a:	682b      	ldr	r3, [r5, #0]
    {
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
    403c:	9009      	str	r0, [sp, #36]	; 0x24
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
    403e:	681a      	ldr	r2, [r3, #0]
    4040:	4618      	mov	r0, r3
    4042:	68d3      	ldr	r3, [r2, #12]
    4044:	4798      	blx	r3
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
    4046:	682b      	ldr	r3, [r5, #0]
    4048:	6821      	ldr	r1, [r4, #0]
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
    404a:	900a      	str	r0, [sp, #40]	; 0x28
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
    404c:	681a      	ldr	r2, [r3, #0]
    404e:	680e      	ldr	r6, [r1, #0]
    4050:	6852      	ldr	r2, [r2, #4]
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
    4052:	f44f 7100 	mov.w	r1, #512	; 0x200
        publish(subscribers[i]->getEndpointType(), &ti);
    4056:	4618      	mov	r0, r3
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
    4058:	910b      	str	r1, [sp, #44]	; 0x2c
        publish(subscribers[i]->getEndpointType(), &ti);
    405a:	4790      	blx	r2
    405c:	454e      	cmp	r6, r9
    405e:	4607      	mov	r7, r0
    4060:	f040 80c3 	bne.w	41ea <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x38a>
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    4064:	2863      	cmp	r0, #99	; 0x63
    4066:	dd04      	ble.n	4072 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x212>
    4068:	f894 34f8 	ldrb.w	r3, [r4, #1272]	; 0x4f8
    406c:	2b00      	cmp	r3, #0
    406e:	f000 80ae 	beq.w	41ce <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x36e>
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    4072:	f8bd 301c 	ldrh.w	r3, [sp, #28]
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    4076:	9e08      	ldr	r6, [sp, #32]
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    4078:	f884 3223 	strb.w	r3, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    407c:	0a1b      	lsrs	r3, r3, #8
    407e:	f884 3224 	strb.w	r3, [r4, #548]	; 0x224
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    4082:	4630      	mov	r0, r6
    4084:	f004 fd5c 	bl	8b40 <strlen>
    4088:	4682      	mov	sl, r0
      arr[i] = (var >> (8 * i));
    408a:	ea4f 631a 	mov.w	r3, sl, lsr #24
    408e:	ea4f 421a 	mov.w	r2, sl, lsr #16
    4092:	0a00      	lsrs	r0, r0, #8
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
    4094:	4631      	mov	r1, r6
    4096:	f884 3228 	strb.w	r3, [r4, #552]	; 0x228
    409a:	f884 a225 	strb.w	sl, [r4, #549]	; 0x225
    409e:	f884 0226 	strb.w	r0, [r4, #550]	; 0x226
    40a2:	f884 2227 	strb.w	r2, [r4, #551]	; 0x227
    40a6:	f204 2029 	addw	r0, r4, #553	; 0x229
    40aa:	4652      	mov	r2, sl
    40ac:	f001 fa82 	bl	55b4 <memcpy>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
    40b0:	9909      	ldr	r1, [sp, #36]	; 0x24
    40b2:	9101      	str	r1, [sp, #4]
    40b4:	4608      	mov	r0, r1
    40b6:	f004 fd43 	bl	8b40 <strlen>
      return 0;

    /* serialize message */
    int l = msg->serialize(message_out + 7);
    40ba:	f204 2623 	addw	r6, r4, #547	; 0x223
    40be:	f10a 0205 	add.w	r2, sl, #5
    40c2:	9901      	ldr	r1, [sp, #4]
    40c4:	4683      	mov	fp, r0
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
    40c6:	f10a 0a06 	add.w	sl, sl, #6
    40ca:	4432      	add	r2, r6
      uint32_t length_message_type = strlen(this->message_type);
    40cc:	2300      	movs	r3, #0
    40ce:	fa2b f003 	lsr.w	r0, fp, r3
    40d2:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    40d4:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
    40d6:	f802 0f01 	strb.w	r0, [r2, #1]!

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    40da:	d1f8      	bne.n	40ce <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x26e>
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    40dc:	f10a 0a04 	add.w	sl, sl, #4
    40e0:	465a      	mov	r2, fp
    40e2:	eb06 000a 	add.w	r0, r6, sl
    40e6:	f001 fa65 	bl	55b4 <memcpy>
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
    40ea:	990a      	ldr	r1, [sp, #40]	; 0x28
    40ec:	9101      	str	r1, [sp, #4]
    40ee:	4608      	mov	r0, r1
    40f0:	f004 fd26 	bl	8b40 <strlen>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
      offset += length_message_type;
    40f4:	44d3      	add	fp, sl
      uint32_t length_md5sum = strlen(this->md5sum);
    40f6:	9901      	ldr	r1, [sp, #4]
    40f8:	4682      	mov	sl, r0
    40fa:	eb06 030b 	add.w	r3, r6, fp
    40fe:	2200      	movs	r2, #0
      arr[i] = (var >> (8 * i));
    4100:	fa2a f002 	lsr.w	r0, sl, r2
    4104:	3208      	adds	r2, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    4106:	2a20      	cmp	r2, #32
      arr[i] = (var >> (8 * i));
    4108:	f803 0b01 	strb.w	r0, [r3], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    410c:	d1f8      	bne.n	4100 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x2a0>
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    410e:	f10b 0b04 	add.w	fp, fp, #4
    4112:	eb06 000b 	add.w	r0, r6, fp
    4116:	4652      	mov	r2, sl
    4118:	f001 fa4c 	bl	55b4 <memcpy>
      offset += length_md5sum;
    411c:	eb0a 030b 	add.w	r3, sl, fp
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
    4120:	1d1a      	adds	r2, r3, #4
      offset += length_md5sum;
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
    4122:	990b      	ldr	r1, [sp, #44]	; 0x2c
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    4124:	54f1      	strb	r1, [r6, r3]

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    4126:	fa5f fc82 	uxtb.w	ip, r2
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    412a:	f3c2 2e07 	ubfx	lr, r2, #8, #8
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    412e:	441e      	add	r6, r3
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    4130:	eb0c 000e 	add.w	r0, ip, lr
    4134:	ea4f 2b11 	mov.w	fp, r1, lsr #8
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
    4138:	ea4f 4a11 	mov.w	sl, r1, lsr #16
    413c:	43c0      	mvns	r0, r0
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
    413e:	0e09      	lsrs	r1, r1, #24
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    4140:	f886 b001 	strb.w	fp, [r6, #1]
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
    4144:	f886 a002 	strb.w	sl, [r6, #2]
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
    4148:	70f1      	strb	r1, [r6, #3]

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    414a:	f04f 0bff 	mov.w	fp, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    414e:	b2f9      	uxtb	r1, r7
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    4150:	f04f 0afe 	mov.w	sl, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    4154:	f347 2707 	sbfx	r7, r7, #8, #8
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    4158:	f884 0220 	strb.w	r0, [r4, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    415c:	1c50      	adds	r0, r2, #1
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    415e:	f884 c21e 	strb.w	ip, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    4162:	f884 e21f 	strb.w	lr, [r4, #543]	; 0x21f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    4166:	f884 b21c 	strb.w	fp, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    416a:	f884 a21d 	strb.w	sl, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    416e:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    4172:	f884 7222 	strb.w	r7, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    4176:	db18      	blt.n	41aa <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x34a>
    4178:	f203 2326 	addw	r3, r3, #550	; 0x226
    417c:	18e6      	adds	r6, r4, r3
    417e:	2000      	movs	r0, #0
    4180:	f204 2321 	addw	r3, r4, #545	; 0x221
    4184:	e00a      	b.n	419c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x33c>
    4186:	bf00      	nop
    4188:	00008f94 	.word	0x00008f94
    418c:	000092b8 	.word	0x000092b8
    4190:	000026ed 	.word	0x000026ed
    4194:	00000949 	.word	0x00000949
    4198:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    419c:	42b3      	cmp	r3, r6
      chk += message_out[i];
    419e:	4408      	add	r0, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    41a0:	d1fa      	bne.n	4198 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x338>
    41a2:	ea6f 0b00 	mvn.w	fp, r0
    41a6:	fa5f fb8b 	uxtb.w	fp, fp
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    41aa:	18a3      	adds	r3, r4, r2
    41ac:	f102 0108 	add.w	r1, r2, #8

    if (l <= OUTPUT_SIZE)
    41b0:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    41b4:	f883 b223 	strb.w	fp, [r3, #547]	; 0x223

    if (l <= OUTPUT_SIZE)
    41b8:	dc71      	bgt.n	429e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x43e>
    41ba:	6866      	ldr	r6, [r4, #4]
    41bc:	4a65      	ldr	r2, [pc, #404]	; (4354 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4f4>)
    41be:	6833      	ldr	r3, [r6, #0]
    41c0:	685b      	ldr	r3, [r3, #4]
    41c2:	4293      	cmp	r3, r2
    {
      hardware_.write(message_out, l);
    41c4:	f504 7007 	add.w	r0, r4, #540	; 0x21c
    41c8:	d119      	bne.n	41fe <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x39e>
    41ca:	f002 fd0b 	bl	6be4 <usb_serial_write>
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
        ti.buffer_size = OUTPUT_SIZE;
        publish(publishers[i]->getEndpointType(), &ti);
      }
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    41ce:	45a8      	cmp	r8, r5
    41d0:	f47f af26 	bne.w	4020 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1c0>
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
      }
    }
    configured_ = true;
    41d4:	2301      	movs	r3, #1
    41d6:	f884 34f8 	strb.w	r3, [r4, #1272]	; 0x4f8
  }
    41da:	b00d      	add	sp, #52	; 0x34
    41dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
        ti.buffer_size = OUTPUT_SIZE;
        publish(publishers[i]->getEndpointType(), &ti);
    41e0:	4641      	mov	r1, r8
    41e2:	aa06      	add	r2, sp, #24
    41e4:	4620      	mov	r0, r4
    41e6:	4798      	blx	r3
    41e8:	e713      	b.n	4012 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
    41ea:	4601      	mov	r1, r0
    41ec:	aa06      	add	r2, sp, #24
    41ee:	4620      	mov	r0, r4
    41f0:	47b0      	blx	r6
    41f2:	e7ec      	b.n	41ce <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x36e>
    41f4:	460a      	mov	r2, r1
    41f6:	4601      	mov	r1, r0
    41f8:	4638      	mov	r0, r7
    41fa:	4798      	blx	r3
    41fc:	e709      	b.n	4012 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
    41fe:	460a      	mov	r2, r1
    4200:	4601      	mov	r1, r0
    4202:	4630      	mov	r0, r6
    4204:	4798      	blx	r3
    4206:	e7e2      	b.n	41ce <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x36e>
      enum { ERROR = 3 };
      enum { FATAL = 4 };

    Log():
      level(0),
      msg("")
    4208:	4a53      	ldr	r2, [pc, #332]	; (4358 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4f8>)
    420a:	9203      	str	r2, [sp, #12]

protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    420c:	2103      	movs	r1, #3
    l.msg = (char*)msg;
    420e:	4a53      	ldr	r2, [pc, #332]	; (435c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4fc>)
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    4210:	6823      	ldr	r3, [r4, #0]
protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    4212:	9205      	str	r2, [sp, #20]

protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    4214:	f88d 1010 	strb.w	r1, [sp, #16]
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    4218:	681b      	ldr	r3, [r3, #0]
    421a:	4a51      	ldr	r2, [pc, #324]	; (4360 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x500>)
    421c:	4293      	cmp	r3, r2
    421e:	f040 8086 	bne.w	432e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4ce>
      arr[i] = (var >> (8 * i));
    4222:	2700      	movs	r7, #0
    4224:	2238      	movs	r2, #56	; 0x38
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    4226:	f884 1223 	strb.w	r1, [r4, #547]	; 0x223
    422a:	f884 2224 	strb.w	r2, [r4, #548]	; 0x224
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    422e:	494b      	ldr	r1, [pc, #300]	; (435c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4fc>)
    4230:	f884 7225 	strb.w	r7, [r4, #549]	; 0x225
    4234:	f884 7226 	strb.w	r7, [r4, #550]	; 0x226
    4238:	f884 7227 	strb.w	r7, [r4, #551]	; 0x227
    423c:	f504 700a 	add.w	r0, r4, #552	; 0x228
    4240:	f001 f9b8 	bl	55b4 <memcpy>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    4244:	21ff      	movs	r1, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    4246:	203d      	movs	r0, #61	; 0x3d
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    4248:	23c2      	movs	r3, #194	; 0xc2
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    424a:	f04f 0efe 	mov.w	lr, #254	; 0xfe

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    424e:	f884 121c 	strb.w	r1, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    4252:	2107      	movs	r1, #7
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    4254:	f884 021e 	strb.w	r0, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    4258:	f884 3220 	strb.w	r3, [r4, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    425c:	f884 721f 	strb.w	r7, [r4, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    4260:	f884 7222 	strb.w	r7, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    4264:	463a      	mov	r2, r7
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    4266:	f884 e21d 	strb.w	lr, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    426a:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    426e:	f204 2321 	addw	r3, r4, #545	; 0x221
    4272:	f204 205f 	addw	r0, r4, #607	; 0x25f
    4276:	e001      	b.n	427c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x41c>
    4278:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    427c:	4298      	cmp	r0, r3
      chk += message_out[i];
    427e:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    4280:	d1fa      	bne.n	4278 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x418>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    4282:	43d2      	mvns	r2, r2
    4284:	6860      	ldr	r0, [r4, #4]
    4286:	f884 2260 	strb.w	r2, [r4, #608]	; 0x260
    428a:	6803      	ldr	r3, [r0, #0]
    428c:	4a31      	ldr	r2, [pc, #196]	; (4354 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4f4>)
    428e:	685b      	ldr	r3, [r3, #4]
    4290:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    4292:	f504 7107 	add.w	r1, r4, #540	; 0x21c
    4296:	d159      	bne.n	434c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4ec>
    4298:	4608      	mov	r0, r1
    429a:	2145      	movs	r1, #69	; 0x45
    429c:	e6b7      	b.n	400e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1ae>
      enum { ERROR = 3 };
      enum { FATAL = 4 };

    Log():
      level(0),
      msg("")
    429e:	4a2e      	ldr	r2, [pc, #184]	; (4358 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4f8>)
    42a0:	9203      	str	r2, [sp, #12]

protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    42a2:	2103      	movs	r1, #3
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    42a4:	6823      	ldr	r3, [r4, #0]
protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    42a6:	4a2d      	ldr	r2, [pc, #180]	; (435c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4fc>)
    42a8:	9205      	str	r2, [sp, #20]

protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    42aa:	f88d 1010 	strb.w	r1, [sp, #16]
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    42ae:	681b      	ldr	r3, [r3, #0]
    42b0:	454b      	cmp	r3, r9
    42b2:	d146      	bne.n	4342 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4e2>
    42b4:	2600      	movs	r6, #0
    42b6:	2238      	movs	r2, #56	; 0x38
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    42b8:	f884 1223 	strb.w	r1, [r4, #547]	; 0x223
    42bc:	f884 2224 	strb.w	r2, [r4, #548]	; 0x224
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    42c0:	4926      	ldr	r1, [pc, #152]	; (435c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4fc>)
    42c2:	f884 6225 	strb.w	r6, [r4, #549]	; 0x225
    42c6:	f884 6226 	strb.w	r6, [r4, #550]	; 0x226
    42ca:	f884 6227 	strb.w	r6, [r4, #551]	; 0x227
    42ce:	f504 700a 	add.w	r0, r4, #552	; 0x228
    42d2:	f001 f96f 	bl	55b4 <memcpy>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    42d6:	21ff      	movs	r1, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    42d8:	203d      	movs	r0, #61	; 0x3d
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    42da:	23c2      	movs	r3, #194	; 0xc2
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    42dc:	27fe      	movs	r7, #254	; 0xfe

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    42de:	f884 121c 	strb.w	r1, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    42e2:	2107      	movs	r1, #7
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    42e4:	f884 021e 	strb.w	r0, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    42e8:	f884 3220 	strb.w	r3, [r4, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    42ec:	f884 621f 	strb.w	r6, [r4, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    42f0:	f884 6222 	strb.w	r6, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    42f4:	4632      	mov	r2, r6
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    42f6:	f884 721d 	strb.w	r7, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    42fa:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    42fe:	f204 2321 	addw	r3, r4, #545	; 0x221
    4302:	f204 205f 	addw	r0, r4, #607	; 0x25f
    4306:	e001      	b.n	430c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4ac>
    4308:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    430c:	4283      	cmp	r3, r0
      chk += message_out[i];
    430e:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    4310:	d1fa      	bne.n	4308 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4a8>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    4312:	43d2      	mvns	r2, r2
    4314:	6860      	ldr	r0, [r4, #4]
    4316:	f884 2260 	strb.w	r2, [r4, #608]	; 0x260
    431a:	6803      	ldr	r3, [r0, #0]
    431c:	4a0d      	ldr	r2, [pc, #52]	; (4354 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4f4>)
    431e:	685b      	ldr	r3, [r3, #4]
    4320:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    4322:	f504 7107 	add.w	r1, r4, #540	; 0x21c
    4326:	d109      	bne.n	433c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4dc>
    4328:	4608      	mov	r0, r1
    432a:	2145      	movs	r1, #69	; 0x45
    432c:	e74d      	b.n	41ca <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x36a>
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    432e:	aa03      	add	r2, sp, #12
    4330:	2107      	movs	r1, #7
    4332:	4620      	mov	r0, r4
    4334:	4798      	blx	r3
    4336:	e66c      	b.n	4012 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    4338:	4602      	mov	r2, r0
    433a:	e656      	b.n	3fea <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x18a>
    433c:	2245      	movs	r2, #69	; 0x45
    433e:	4798      	blx	r3
    4340:	e745      	b.n	41ce <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x36e>
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    4342:	aa03      	add	r2, sp, #12
    4344:	2107      	movs	r1, #7
    4346:	4620      	mov	r0, r4
    4348:	4798      	blx	r3
    434a:	e740      	b.n	41ce <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x36e>
    434c:	2245      	movs	r2, #69	; 0x45
    434e:	4798      	blx	r3
    4350:	e65f      	b.n	4012 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
    4352:	bf00      	nop
    4354:	00000949 	.word	0x00000949
    4358:	00008fac 	.word	0x00008fac
    435c:	00009280 	.word	0x00009280
    4360:	000026ed 	.word	0x000026ed

00004364 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()>:
  /* This function goes in your loop() function, it handles
   *  serial input and callbacks for subscribers.
   */


  virtual int spinOnce() override
    4364:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4368:	4ebb      	ldr	r6, [pc, #748]	; (4658 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x2f4>)
    436a:	b093      	sub	sp, #76	; 0x4c
    436c:	6833      	ldr	r3, [r6, #0]
    436e:	9306      	str	r3, [sp, #24]
	return ret;
    4370:	9d06      	ldr	r5, [sp, #24]
  {
    /* restart if timed out */
    uint32_t c_time = hardware_.time();
    if ((c_time - last_sync_receive_time) > (SYNC_SECONDS * 2200))
    4372:	f8d0 3500 	ldr.w	r3, [r0, #1280]	; 0x500
    4376:	f642 22f8 	movw	r2, #11000	; 0x2af8
    437a:	1aeb      	subs	r3, r5, r3
    437c:	4293      	cmp	r3, r2
    {
      configured_ = false;
    437e:	bf84      	itt	hi
    4380:	2300      	movhi	r3, #0
    4382:	f880 34f8 	strbhi.w	r3, [r0, #1272]	; 0x4f8
    }

    /* reset if message has timed out */
    if (mode_ != MODE_FIRST_FF)
    4386:	f8d0 34e4 	ldr.w	r3, [r0, #1252]	; 0x4e4
  /* This function goes in your loop() function, it handles
   *  serial input and callbacks for subscribers.
   */


  virtual int spinOnce() override
    438a:	4604      	mov	r4, r0
    {
      configured_ = false;
    }

    /* reset if message has timed out */
    if (mode_ != MODE_FIRST_FF)
    438c:	b133      	cbz	r3, 439c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x38>
    {
      if (c_time > last_msg_timeout_time)
    438e:	f8d0 3504 	ldr.w	r3, [r0, #1284]	; 0x504
    4392:	42ab      	cmp	r3, r5
      {
        mode_ = MODE_FIRST_FF;
    4394:	bf3c      	itt	cc
    4396:	2300      	movcc	r3, #0
    4398:	f8c0 34e4 	strcc.w	r3, [r0, #1252]	; 0x4e4
    439c:	4faf      	ldr	r7, [pc, #700]	; (465c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x2f8>)

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    439e:	f8df 92d0 	ldr.w	r9, [pc, #720]	; 4670 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x30c>

    /* while available buffer, read data */
    while (true)
    {
      // If a timeout has been specified, check how long spinOnce has been running.
      if (spin_timeout_ > 0)
    43a2:	69a2      	ldr	r2, [r4, #24]
    43a4:	b132      	cbz	r2, 43b4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x50>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    43a6:	6833      	ldr	r3, [r6, #0]
    43a8:	9307      	str	r3, [sp, #28]
	return ret;
    43aa:	9b07      	ldr	r3, [sp, #28]
      {
        // If the maximum processing timeout has been exceeded, exit with error.
        // The next spinOnce can continue where it left off, or optionally
        // based on the application in use, the hardware buffer could be flushed
        // and start fresh.
        if ((hardware_.time() - c_time) > spin_timeout_)
    43ac:	1b5b      	subs	r3, r3, r5
    43ae:	429a      	cmp	r2, r3
    43b0:	f0c0 811b 	bcc.w	45ea <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x286>
    43b4:	6860      	ldr	r0, [r4, #4]
      delay(3000); 
#endif
      iostream->begin(baud_);
    }

    int read(){return iostream->read();};
    43b6:	6803      	ldr	r3, [r0, #0]
    43b8:	695b      	ldr	r3, [r3, #20]
    43ba:	42bb      	cmp	r3, r7
    43bc:	d166      	bne.n	448c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x128>
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    43be:	f002 fbab 	bl	6b18 <usb_serial_getchar>
          // Exit the spin, processing timeout exceeded.
          return SPIN_TIMEOUT;
        }
      }
      int data = hardware_.read();
      if (data < 0)
    43c2:	2800      	cmp	r0, #0
    43c4:	db65      	blt.n	4492 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x12e>
        break;
      checksum_ += data;
    43c6:	f8d4 34f4 	ldr.w	r3, [r4, #1268]	; 0x4f4
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    43ca:	f8d4 24e4 	ldr.w	r2, [r4, #1252]	; 0x4e4
        }
      }
      int data = hardware_.read();
      if (data < 0)
        break;
      checksum_ += data;
    43ce:	4403      	add	r3, r0
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    43d0:	2a07      	cmp	r2, #7
        }
      }
      int data = hardware_.read();
      if (data < 0)
        break;
      checksum_ += data;
    43d2:	f8c4 34f4 	str.w	r3, [r4, #1268]	; 0x4f4
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    43d6:	d047      	beq.n	4468 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x104>
        message_in[index_++] = data;
        bytes_--;
        if (bytes_ == 0)                 /* is message complete? if so, checksum */
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_FIRST_FF)
    43d8:	b982      	cbnz	r2, 43fc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x98>
      {
        if (data == 0xff)
    43da:	28ff      	cmp	r0, #255	; 0xff
    43dc:	d069      	beq.n	44b2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x14e>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    43de:	6833      	ldr	r3, [r6, #0]
    43e0:	9308      	str	r3, [sp, #32]
	return ret;
    43e2:	9b08      	ldr	r3, [sp, #32]
        {
          mode_++;
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
        }
        else if (hardware_.time() - c_time > (SYNC_SECONDS * 1000))
    43e4:	f241 3188 	movw	r1, #5000	; 0x1388
    43e8:	1b5b      	subs	r3, r3, r5
    43ea:	428b      	cmp	r3, r1
    43ec:	d9d9      	bls.n	43a2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
        {
          /* We have been stuck in spinOnce too long, return error */
          configured_ = false;
    43ee:	f884 24f8 	strb.w	r2, [r4, #1272]	; 0x4f8
          return SPIN_TIMEOUT;
    43f2:	f06f 0001 	mvn.w	r0, #1
      requestSyncTime();
      last_sync_time = c_time;
    }

    return SPIN_OK;
  }
    43f6:	b013      	add	sp, #76	; 0x4c
    43f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          /* We have been stuck in spinOnce too long, return error */
          configured_ = false;
          return SPIN_TIMEOUT;
        }
      }
      else if (mode_ == MODE_PROTOCOL_VER)
    43fc:	2a01      	cmp	r2, #1
    43fe:	d060      	beq.n	44c2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x15e>
          mode_ = MODE_FIRST_FF;
          if (configured_ == false)
            requestSyncTime();  /* send a msg back showing our protocol version */
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
    4400:	2a02      	cmp	r2, #2
    4402:	f000 80b6 	beq.w	4572 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x20e>
        bytes_ = data;
        index_ = 0;
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
    4406:	2a03      	cmp	r2, #3
    4408:	f000 80be 	beq.w	4588 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x224>
      {
        bytes_ += data << 8;
        mode_++;
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
    440c:	2a04      	cmp	r2, #4
    440e:	f000 80c5 	beq.w	459c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x238>
        if ((checksum_ % 256) == 255)
          mode_++;
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
    4412:	2a05      	cmp	r2, #5
    4414:	f000 80d2 	beq.w	45bc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x258>
      {
        topic_ = data;
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
    4418:	2a06      	cmp	r2, #6
    441a:	f000 80d7 	beq.w	45cc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x268>
        topic_ += data << 8;
        mode_ = MODE_MESSAGE;
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
    441e:	2a08      	cmp	r2, #8
    4420:	d1bf      	bne.n	43a2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
      {
        mode_ = MODE_FIRST_FF;
        if ((checksum_ % 256) == 255)
    4422:	4a8f      	ldr	r2, [pc, #572]	; (4660 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x2fc>)
    4424:	401a      	ands	r2, r3
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
    4426:	2300      	movs	r3, #0
        if ((checksum_ % 256) == 255)
    4428:	429a      	cmp	r2, r3
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
    442a:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
        if ((checksum_ % 256) == 255)
    442e:	f2c0 814d 	blt.w	46cc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x368>
    4432:	2aff      	cmp	r2, #255	; 0xff
    4434:	d1b5      	bne.n	43a2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
        {
          if (topic_ == TopicInfo::ID_PUBLISHER)
    4436:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
    443a:	2b00      	cmp	r3, #0
    443c:	f000 82d0 	beq.w	49e0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x67c>
            negotiateTopics();
            last_sync_time = c_time;
            last_sync_receive_time = c_time;
            return SPIN_ERR;
          }
          else if (topic_ == TopicInfo::ID_TIME)
    4440:	2b0a      	cmp	r3, #10
    4442:	f000 827a 	beq.w	493a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x5d6>
          {
            syncTime(message_in);
          }
          else if (topic_ == TopicInfo::ID_PARAMETER_REQUEST)
    4446:	2b06      	cmp	r3, #6
    4448:	f000 8153 	beq.w	46f2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x38e>
          {
            req_param_resp.deserialize(message_in);
            param_received = true;
          }
          else if (topic_ == TopicInfo::ID_TX_STOP)
    444c:	2b0b      	cmp	r3, #11
    444e:	f000 8142 	beq.w	46d6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x372>
          {
            configured_ = false;
          }
          else
          {
            if (subscribers[topic_ - 100])
    4452:	33bc      	adds	r3, #188	; 0xbc
    4454:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
    4458:	2800      	cmp	r0, #0
    445a:	d0a2      	beq.n	43a2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
              subscribers[topic_ - 100]->callback(message_in);
    445c:	6803      	ldr	r3, [r0, #0]
    445e:	f104 011c 	add.w	r1, r4, #28
    4462:	681b      	ldr	r3, [r3, #0]
    4464:	4798      	blx	r3
    4466:	e79c      	b.n	43a2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
      if (data < 0)
        break;
      checksum_ += data;
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
      {
        message_in[index_++] = data;
    4468:	f8d4 34f0 	ldr.w	r3, [r4, #1264]	; 0x4f0
    446c:	18e2      	adds	r2, r4, r3
    446e:	3301      	adds	r3, #1
    4470:	f8c4 34f0 	str.w	r3, [r4, #1264]	; 0x4f0
    4474:	7710      	strb	r0, [r2, #28]
        bytes_--;
    4476:	f8d4 34e8 	ldr.w	r3, [r4, #1256]	; 0x4e8
    447a:	3b01      	subs	r3, #1
    447c:	f8c4 34e8 	str.w	r3, [r4, #1256]	; 0x4e8
        if (bytes_ == 0)                 /* is message complete? if so, checksum */
    4480:	2b00      	cmp	r3, #0
    4482:	d18e      	bne.n	43a2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
          mode_ = MODE_MSG_CHECKSUM;
    4484:	2308      	movs	r3, #8
    4486:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    448a:	e78a      	b.n	43a2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
    448c:	4798      	blx	r3
          // Exit the spin, processing timeout exceeded.
          return SPIN_TIMEOUT;
        }
      }
      int data = hardware_.read();
      if (data < 0)
    448e:	2800      	cmp	r0, #0
    4490:	da99      	bge.n	43c6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x62>
        }
      }
    }

    /* occasionally sync time */
    if (configured_ && ((c_time - last_sync_time) > (SYNC_SECONDS * 500)))
    4492:	f894 04f8 	ldrb.w	r0, [r4, #1272]	; 0x4f8
    4496:	2800      	cmp	r0, #0
    4498:	d0ad      	beq.n	43f6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x92>
    449a:	f8d4 34fc 	ldr.w	r3, [r4, #1276]	; 0x4fc
    449e:	f640 12c4 	movw	r2, #2500	; 0x9c4
    44a2:	1aeb      	subs	r3, r5, r3
    44a4:	4293      	cmp	r3, r2
    44a6:	f200 80a5 	bhi.w	45f4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x290>
    {
      requestSyncTime();
      last_sync_time = c_time;
    }

    return SPIN_OK;
    44aa:	2000      	movs	r0, #0
  }
    44ac:	b013      	add	sp, #76	; 0x4c
    44ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      }
      else if (mode_ == MODE_FIRST_FF)
      {
        if (data == 0xff)
        {
          mode_++;
    44b2:	2201      	movs	r2, #1
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
    44b4:	f105 0314 	add.w	r3, r5, #20
      }
      else if (mode_ == MODE_FIRST_FF)
      {
        if (data == 0xff)
        {
          mode_++;
    44b8:	f8c4 24e4 	str.w	r2, [r4, #1252]	; 0x4e4
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
    44bc:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
    44c0:	e76f      	b.n	43a2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
          return SPIN_TIMEOUT;
        }
      }
      else if (mode_ == MODE_PROTOCOL_VER)
      {
        if (data == PROTOCOL_VER)
    44c2:	28fe      	cmp	r0, #254	; 0xfe
    44c4:	d076      	beq.n	45b4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x250>
          mode_++;
        }
        else
        {
          mode_ = MODE_FIRST_FF;
          if (configured_ == false)
    44c6:	f894 24f8 	ldrb.w	r2, [r4, #1272]	; 0x4f8
        {
          mode_++;
        }
        else
        {
          mode_ = MODE_FIRST_FF;
    44ca:	2300      	movs	r3, #0
    44cc:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
          if (configured_ == false)
    44d0:	2a00      	cmp	r2, #0
    44d2:	f47f af66 	bne.w	43a2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
    44d6:	4963      	ldr	r1, [pc, #396]	; (4664 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x300>)
   */

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    44d8:	6823      	ldr	r3, [r4, #0]
    44da:	910f      	str	r1, [sp, #60]	; 0x3c
    44dc:	681b      	ldr	r3, [r3, #0]
    44de:	4962      	ldr	r1, [pc, #392]	; (4668 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x304>)
    44e0:	9210      	str	r2, [sp, #64]	; 0x40
    44e2:	428b      	cmp	r3, r1
    44e4:	9211      	str	r2, [sp, #68]	; 0x44
    44e6:	f040 80e7 	bne.w	46b8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x354>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    44ea:	21ff      	movs	r1, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    44ec:	2008      	movs	r0, #8
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    44ee:	23f7      	movs	r3, #247	; 0xf7
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    44f0:	f04f 0efe 	mov.w	lr, #254	; 0xfe

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    44f4:	f884 121c 	strb.w	r1, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    44f8:	210a      	movs	r1, #10
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    44fa:	f884 021e 	strb.w	r0, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    44fe:	f884 3220 	strb.w	r3, [r4, #544]	; 0x220
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->data.sec >> (8 * 0)) & 0xFF;
    4502:	f884 2223 	strb.w	r2, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->data.sec >> (8 * 1)) & 0xFF;
    4506:	f884 2224 	strb.w	r2, [r4, #548]	; 0x224
      *(outbuffer + offset + 2) = (this->data.sec >> (8 * 2)) & 0xFF;
    450a:	f884 2225 	strb.w	r2, [r4, #549]	; 0x225
      *(outbuffer + offset + 3) = (this->data.sec >> (8 * 3)) & 0xFF;
    450e:	f884 2226 	strb.w	r2, [r4, #550]	; 0x226
      offset += sizeof(this->data.sec);
      *(outbuffer + offset + 0) = (this->data.nsec >> (8 * 0)) & 0xFF;
    4512:	f884 2227 	strb.w	r2, [r4, #551]	; 0x227
      *(outbuffer + offset + 1) = (this->data.nsec >> (8 * 1)) & 0xFF;
    4516:	f884 2228 	strb.w	r2, [r4, #552]	; 0x228
      *(outbuffer + offset + 2) = (this->data.nsec >> (8 * 2)) & 0xFF;
    451a:	f884 2229 	strb.w	r2, [r4, #553]	; 0x229
      *(outbuffer + offset + 3) = (this->data.nsec >> (8 * 3)) & 0xFF;
    451e:	f884 222a 	strb.w	r2, [r4, #554]	; 0x22a

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    4522:	f884 221f 	strb.w	r2, [r4, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    4526:	f884 2222 	strb.w	r2, [r4, #546]	; 0x222
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    452a:	f884 e21d 	strb.w	lr, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    452e:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    4532:	f204 2321 	addw	r3, r4, #545	; 0x221
    4536:	f204 202a 	addw	r0, r4, #554	; 0x22a
    453a:	e001      	b.n	4540 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x1dc>
    453c:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    4540:	4298      	cmp	r0, r3
      chk += message_out[i];
    4542:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    4544:	d1fa      	bne.n	453c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x1d8>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    4546:	43d2      	mvns	r2, r2
    4548:	f8d4 e004 	ldr.w	lr, [r4, #4]
    454c:	f884 222b 	strb.w	r2, [r4, #555]	; 0x22b
    void write(uint8_t* data, int length){
      iostream->write(data, length);
    4550:	f8de 3000 	ldr.w	r3, [lr]
    4554:	4a45      	ldr	r2, [pc, #276]	; (466c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x308>)
    4556:	685b      	ldr	r3, [r3, #4]
    4558:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    455a:	f504 7007 	add.w	r0, r4, #540	; 0x21c
    455e:	f040 80b0 	bne.w	46c2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x35e>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    4562:	2110      	movs	r1, #16
    4564:	f002 fb3e 	bl	6be4 <usb_serial_write>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4568:	6833      	ldr	r3, [r6, #0]
    456a:	9309      	str	r3, [sp, #36]	; 0x24
	return ret;
    456c:	9b09      	ldr	r3, [sp, #36]	; 0x24

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    rt_time = hardware_.time();
    456e:	60e3      	str	r3, [r4, #12]
    4570:	e717      	b.n	43a2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
        index_ = 0;
    4572:	2200      	movs	r2, #0
        mode_++;
    4574:	2303      	movs	r3, #3
            requestSyncTime();  /* send a msg back showing our protocol version */
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
    4576:	f8c4 04e8 	str.w	r0, [r4, #1256]	; 0x4e8
        index_ = 0;
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
    457a:	f8c4 04f4 	str.w	r0, [r4, #1268]	; 0x4f4
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
        index_ = 0;
    457e:	f8c4 24f0 	str.w	r2, [r4, #1264]	; 0x4f0
        mode_++;
    4582:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    4586:	e70c      	b.n	43a2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
      {
        bytes_ += data << 8;
    4588:	f8d4 34e8 	ldr.w	r3, [r4, #1256]	; 0x4e8
    458c:	eb03 2000 	add.w	r0, r3, r0, lsl #8
        mode_++;
    4590:	2304      	movs	r3, #4
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
      {
        bytes_ += data << 8;
    4592:	f8c4 04e8 	str.w	r0, [r4, #1256]	; 0x4e8
        mode_++;
    4596:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    459a:	e702      	b.n	43a2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
      {
        if ((checksum_ % 256) == 255)
    459c:	4a30      	ldr	r2, [pc, #192]	; (4660 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x2fc>)
    459e:	401a      	ands	r2, r3
    45a0:	2a00      	cmp	r2, #0
    45a2:	f2c0 8084 	blt.w	46ae <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x34a>
    45a6:	2aff      	cmp	r2, #255	; 0xff
          mode_++;
    45a8:	bf0c      	ite	eq
    45aa:	2305      	moveq	r3, #5
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
    45ac:	2300      	movne	r3, #0
    45ae:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    45b2:	e6f6      	b.n	43a2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
      }
      else if (mode_ == MODE_PROTOCOL_VER)
      {
        if (data == PROTOCOL_VER)
        {
          mode_++;
    45b4:	2302      	movs	r3, #2
    45b6:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    45ba:	e6f2      	b.n	43a2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
        mode_++;
    45bc:	2306      	movs	r3, #6
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
    45be:	f8c4 04ec 	str.w	r0, [r4, #1260]	; 0x4ec
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
    45c2:	f8c4 04f4 	str.w	r0, [r4, #1268]	; 0x4f4
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
        mode_++;
    45c6:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    45ca:	e6ea      	b.n	43a2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    45cc:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
        mode_ = MODE_MESSAGE;
        if (bytes_ == 0)
    45d0:	f8d4 24e8 	ldr.w	r2, [r4, #1256]	; 0x4e8
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    45d4:	eb03 2300 	add.w	r3, r3, r0, lsl #8
        mode_ = MODE_MESSAGE;
    45d8:	2107      	movs	r1, #7
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    45da:	f8c4 34ec 	str.w	r3, [r4, #1260]	; 0x4ec
        mode_ = MODE_MESSAGE;
    45de:	f8c4 14e4 	str.w	r1, [r4, #1252]	; 0x4e4
        if (bytes_ == 0)
    45e2:	2a00      	cmp	r2, #0
    45e4:	f43f af4e 	beq.w	4484 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x120>
    45e8:	e6db      	b.n	43a2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
        // based on the application in use, the hardware buffer could be flushed
        // and start fresh.
        if ((hardware_.time() - c_time) > spin_timeout_)
        {
          // Exit the spin, processing timeout exceeded.
          return SPIN_TIMEOUT;
    45ea:	f06f 0001 	mvn.w	r0, #1
      requestSyncTime();
      last_sync_time = c_time;
    }

    return SPIN_OK;
  }
    45ee:	b013      	add	sp, #76	; 0x4c
    45f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    public:
      typedef ros::Time _data_type;
      _data_type data;

    Time():
      data()
    45f4:	4a1b      	ldr	r2, [pc, #108]	; (4664 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x300>)
   */

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    45f6:	6823      	ldr	r3, [r4, #0]
    45f8:	920f      	str	r2, [sp, #60]	; 0x3c
    45fa:	681b      	ldr	r3, [r3, #0]
    45fc:	491a      	ldr	r1, [pc, #104]	; (4668 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x304>)
    45fe:	2200      	movs	r2, #0
    4600:	428b      	cmp	r3, r1
    4602:	9210      	str	r2, [sp, #64]	; 0x40
    4604:	9211      	str	r2, [sp, #68]	; 0x44
    4606:	d16a      	bne.n	46de <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x37a>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    4608:	21ff      	movs	r1, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    460a:	2008      	movs	r0, #8
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    460c:	23f7      	movs	r3, #247	; 0xf7
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    460e:	27fe      	movs	r7, #254	; 0xfe

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    4610:	f884 121c 	strb.w	r1, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    4614:	210a      	movs	r1, #10
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    4616:	f884 021e 	strb.w	r0, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    461a:	f884 3220 	strb.w	r3, [r4, #544]	; 0x220
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->data.sec >> (8 * 0)) & 0xFF;
    461e:	f884 2223 	strb.w	r2, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->data.sec >> (8 * 1)) & 0xFF;
    4622:	f884 2224 	strb.w	r2, [r4, #548]	; 0x224
      *(outbuffer + offset + 2) = (this->data.sec >> (8 * 2)) & 0xFF;
    4626:	f884 2225 	strb.w	r2, [r4, #549]	; 0x225
      *(outbuffer + offset + 3) = (this->data.sec >> (8 * 3)) & 0xFF;
    462a:	f884 2226 	strb.w	r2, [r4, #550]	; 0x226
      offset += sizeof(this->data.sec);
      *(outbuffer + offset + 0) = (this->data.nsec >> (8 * 0)) & 0xFF;
    462e:	f884 2227 	strb.w	r2, [r4, #551]	; 0x227
      *(outbuffer + offset + 1) = (this->data.nsec >> (8 * 1)) & 0xFF;
    4632:	f884 2228 	strb.w	r2, [r4, #552]	; 0x228
      *(outbuffer + offset + 2) = (this->data.nsec >> (8 * 2)) & 0xFF;
    4636:	f884 2229 	strb.w	r2, [r4, #553]	; 0x229
      *(outbuffer + offset + 3) = (this->data.nsec >> (8 * 3)) & 0xFF;
    463a:	f884 222a 	strb.w	r2, [r4, #554]	; 0x22a

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    463e:	f884 221f 	strb.w	r2, [r4, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    4642:	f884 2222 	strb.w	r2, [r4, #546]	; 0x222
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    4646:	f884 721d 	strb.w	r7, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    464a:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    464e:	f204 2321 	addw	r3, r4, #545	; 0x221
    4652:	f204 202a 	addw	r0, r4, #554	; 0x22a
    4656:	e00f      	b.n	4678 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x314>
    4658:	1fff2ae4 	.word	0x1fff2ae4
    465c:	00000951 	.word	0x00000951
    4660:	800000ff 	.word	0x800000ff
    4664:	00008f7c 	.word	0x00008f7c
    4668:	000026ed 	.word	0x000026ed
    466c:	00000949 	.word	0x00000949
    4670:	000f4240 	.word	0x000f4240
    4674:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    4678:	4283      	cmp	r3, r0
      chk += message_out[i];
    467a:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    467c:	d1fa      	bne.n	4674 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x310>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    467e:	43d2      	mvns	r2, r2
    4680:	6867      	ldr	r7, [r4, #4]
    4682:	f884 222b 	strb.w	r2, [r4, #555]	; 0x22b
    4686:	683b      	ldr	r3, [r7, #0]
    4688:	4ad2      	ldr	r2, [pc, #840]	; (49d4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x670>)
    468a:	685b      	ldr	r3, [r3, #4]
    468c:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    468e:	f504 7007 	add.w	r0, r4, #540	; 0x21c
    4692:	d129      	bne.n	46e8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x384>
    4694:	2110      	movs	r1, #16
    4696:	f002 faa5 	bl	6be4 <usb_serial_write>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    469a:	6833      	ldr	r3, [r6, #0]
    469c:	930b      	str	r3, [sp, #44]	; 0x2c
	return ret;
    469e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c

    /* occasionally sync time */
    if (configured_ && ((c_time - last_sync_time) > (SYNC_SECONDS * 500)))
    {
      requestSyncTime();
      last_sync_time = c_time;
    46a0:	f8c4 54fc 	str.w	r5, [r4, #1276]	; 0x4fc
    }

    return SPIN_OK;
    46a4:	2000      	movs	r0, #0

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    rt_time = hardware_.time();
    46a6:	60e3      	str	r3, [r4, #12]
      requestSyncTime();
      last_sync_time = c_time;
    }

    return SPIN_OK;
  }
    46a8:	b013      	add	sp, #76	; 0x4c
    46aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        bytes_ += data << 8;
        mode_++;
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
      {
        if ((checksum_ % 256) == 255)
    46ae:	3a01      	subs	r2, #1
    46b0:	f062 02ff 	orn	r2, r2, #255	; 0xff
    46b4:	3201      	adds	r2, #1
    46b6:	e776      	b.n	45a6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x242>
   */

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    46b8:	aa0f      	add	r2, sp, #60	; 0x3c
    46ba:	210a      	movs	r1, #10
    46bc:	4620      	mov	r0, r4
    46be:	4798      	blx	r3
    46c0:	e752      	b.n	4568 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x204>
    46c2:	4601      	mov	r1, r0
    46c4:	2210      	movs	r2, #16
    46c6:	4670      	mov	r0, lr
    46c8:	4798      	blx	r3
    46ca:	e74d      	b.n	4568 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x204>
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
        if ((checksum_ % 256) == 255)
    46cc:	3a01      	subs	r2, #1
    46ce:	f062 02ff 	orn	r2, r2, #255	; 0xff
    46d2:	3201      	adds	r2, #1
    46d4:	e6ad      	b.n	4432 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0xce>
            req_param_resp.deserialize(message_in);
            param_received = true;
          }
          else if (topic_ == TopicInfo::ID_TX_STOP)
          {
            configured_ = false;
    46d6:	2300      	movs	r3, #0
    46d8:	f884 34f8 	strb.w	r3, [r4, #1272]	; 0x4f8
    46dc:	e661      	b.n	43a2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
   */

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    46de:	aa0f      	add	r2, sp, #60	; 0x3c
    46e0:	210a      	movs	r1, #10
    46e2:	4620      	mov	r0, r4
    46e4:	4798      	blx	r3
    46e6:	e7d8      	b.n	469a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x336>
    46e8:	4601      	mov	r1, r0
    46ea:	2210      	movs	r2, #16
    46ec:	4638      	mov	r0, r7
    46ee:	4798      	blx	r3
    46f0:	e7d3      	b.n	469a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x336>
    {
      int offset = 0;
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    46f2:	7f22      	ldrb	r2, [r4, #28]
    46f4:	7f63      	ldrb	r3, [r4, #29]
    46f6:	f894 801e 	ldrb.w	r8, [r4, #30]
    46fa:	7fe1      	ldrb	r1, [r4, #31]
    46fc:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    4700:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
    4704:	f8d4 2510 	ldr.w	r2, [r4, #1296]	; 0x510
    {
      int offset = 0;
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    4708:	ea43 6801 	orr.w	r8, r3, r1, lsl #24
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
    470c:	4590      	cmp	r8, r2
          {
            syncTime(message_in);
          }
          else if (topic_ == TopicInfo::ID_PARAMETER_REQUEST)
          {
            req_param_resp.deserialize(message_in);
    470e:	f104 0b1c 	add.w	fp, r4, #28
    4712:	d907      	bls.n	4724 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c0>
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
    4714:	ea4f 0188 	mov.w	r1, r8, lsl #2
    4718:	f8d4 0518 	ldr.w	r0, [r4, #1304]	; 0x518
    471c:	f003 fe28 	bl	8370 <realloc>
    4720:	f8c4 0518 	str.w	r0, [r4, #1304]	; 0x518
      ints_length = ints_lengthT;
    4724:	f8c4 8510 	str.w	r8, [r4, #1296]	; 0x510
      for( uint32_t i = 0; i < ints_length; i++){
    4728:	f1b8 0f00 	cmp.w	r8, #0
    472c:	f000 8173 	beq.w	4a16 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x6b2>
    4730:	f204 5314 	addw	r3, r4, #1300	; 0x514
    4734:	9301      	str	r3, [sp, #4]
    4736:	2300      	movs	r3, #0
    4738:	9502      	str	r5, [sp, #8]
    473a:	46d8      	mov	r8, fp
    473c:	4625      	mov	r5, r4
    473e:	f04f 0a04 	mov.w	sl, #4
    4742:	461c      	mov	r4, r3
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
    4744:	f898 2006 	ldrb.w	r2, [r8, #6]
    4748:	f898 0005 	ldrb.w	r0, [r8, #5]
    474c:	f898 1004 	ldrb.w	r1, [r8, #4]
    4750:	f898 e007 	ldrb.w	lr, [r8, #7]
    4754:	0412      	lsls	r2, r2, #16
    4756:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
    475a:	430a      	orrs	r2, r1
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
    475c:	f8d5 0518 	ldr.w	r0, [r5, #1304]	; 0x518
    4760:	9901      	ldr	r1, [sp, #4]
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
    4762:	ea42 620e 	orr.w	r2, r2, lr, lsl #24
    4766:	f8c5 2514 	str.w	r2, [r5, #1300]	; 0x514
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
    476a:	eb00 0084 	add.w	r0, r0, r4, lsl #2
    476e:	2204      	movs	r2, #4
    4770:	f000 ff20 	bl	55b4 <memcpy>
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
      ints_length = ints_lengthT;
      for( uint32_t i = 0; i < ints_length; i++){
    4774:	f8d5 2510 	ldr.w	r2, [r5, #1296]	; 0x510
    4778:	3401      	adds	r4, #1
    477a:	42a2      	cmp	r2, r4
    477c:	4650      	mov	r0, sl
    477e:	f108 0804 	add.w	r8, r8, #4
    4782:	f10a 0a04 	add.w	sl, sl, #4
    4786:	d8dd      	bhi.n	4744 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e0>
    4788:	f100 0109 	add.w	r1, r0, #9
    478c:	9101      	str	r1, [sp, #4]
    478e:	f100 010b 	add.w	r1, r0, #11
    4792:	462c      	mov	r4, r5
    4794:	f100 0208 	add.w	r2, r0, #8
    4798:	9d02      	ldr	r5, [sp, #8]
    479a:	9102      	str	r1, [sp, #8]
    479c:	f100 010c 	add.w	r1, r0, #12
    47a0:	f8cd a00c 	str.w	sl, [sp, #12]
    47a4:	4613      	mov	r3, r2
    47a6:	f100 0e05 	add.w	lr, r0, #5
    47aa:	f100 0c06 	add.w	ip, r0, #6
    47ae:	f100 0807 	add.w	r8, r0, #7
    47b2:	f100 0a0a 	add.w	sl, r0, #10
    47b6:	9104      	str	r1, [sp, #16]
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    47b8:	f81b 000c 	ldrb.w	r0, [fp, ip]
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    47bc:	9903      	ldr	r1, [sp, #12]
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    47be:	f81b e00e 	ldrb.w	lr, [fp, lr]
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    47c2:	f81b c001 	ldrb.w	ip, [fp, r1]
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    47c6:	f81b 8008 	ldrb.w	r8, [fp, r8]
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
    47ca:	f8d4 151c 	ldr.w	r1, [r4, #1308]	; 0x51c
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    47ce:	0400      	lsls	r0, r0, #16
    47d0:	ea40 200e 	orr.w	r0, r0, lr, lsl #8
    47d4:	ea40 0c0c 	orr.w	ip, r0, ip
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    47d8:	ea4c 6808 	orr.w	r8, ip, r8, lsl #24
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
    47dc:	4588      	cmp	r8, r1
    47de:	d90b      	bls.n	47f8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x494>
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
    47e0:	ea4f 0188 	mov.w	r1, r8, lsl #2
    47e4:	f8d4 0524 	ldr.w	r0, [r4, #1316]	; 0x524
    47e8:	9305      	str	r3, [sp, #20]
    47ea:	9203      	str	r2, [sp, #12]
    47ec:	f003 fdc0 	bl	8370 <realloc>
    47f0:	9b05      	ldr	r3, [sp, #20]
    47f2:	9a03      	ldr	r2, [sp, #12]
    47f4:	f8c4 0524 	str.w	r0, [r4, #1316]	; 0x524
      floats_length = floats_lengthT;
    47f8:	f8c4 851c 	str.w	r8, [r4, #1308]	; 0x51c
      for( uint32_t i = 0; i < floats_length; i++){
    47fc:	f1b8 0f00 	cmp.w	r8, #0
    4800:	f000 8106 	beq.w	4a10 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x6ac>
    4804:	f504 62a4 	add.w	r2, r4, #1312	; 0x520
    4808:	9201      	str	r2, [sp, #4]
    480a:	f204 520c 	addw	r2, r4, #1292	; 0x50c
    480e:	9503      	str	r5, [sp, #12]
    4810:	eb0b 0a03 	add.w	sl, fp, r3
    4814:	4625      	mov	r5, r4
    4816:	f04f 0800 	mov.w	r8, #0
    481a:	9202      	str	r2, [sp, #8]
    481c:	461c      	mov	r4, r3
      } u_st_floats;
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    481e:	f89a 0002 	ldrb.w	r0, [sl, #2]
    4822:	f89a 2001 	ldrb.w	r2, [sl, #1]
    4826:	f89a 1000 	ldrb.w	r1, [sl]
    482a:	f89a e003 	ldrb.w	lr, [sl, #3]
      this->st_floats = u_st_floats.real;
    482e:	9b02      	ldr	r3, [sp, #8]
      } u_st_floats;
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    4830:	0400      	lsls	r0, r0, #16
    4832:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    4836:	430a      	orrs	r2, r1
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    4838:	f8d5 0524 	ldr.w	r0, [r5, #1316]	; 0x524
    483c:	9901      	ldr	r1, [sp, #4]
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
    483e:	ea42 620e 	orr.w	r2, r2, lr, lsl #24
    4842:	615a      	str	r2, [r3, #20]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    4844:	eb00 0088 	add.w	r0, r0, r8, lsl #2
    4848:	2204      	movs	r2, #4
    484a:	f000 feb3 	bl	55b4 <memcpy>
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
      floats_length = floats_lengthT;
      for( uint32_t i = 0; i < floats_length; i++){
    484e:	f8d5 251c 	ldr.w	r2, [r5, #1308]	; 0x51c
    4852:	f108 0801 	add.w	r8, r8, #1
    4856:	4542      	cmp	r2, r8
    4858:	4621      	mov	r1, r4
    485a:	f10a 0a04 	add.w	sl, sl, #4
    485e:	f104 0404 	add.w	r4, r4, #4
    4862:	d8dc      	bhi.n	481e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x4ba>
    4864:	4623      	mov	r3, r4
    4866:	461a      	mov	r2, r3
    4868:	1d4b      	adds	r3, r1, #5
    486a:	462c      	mov	r4, r5
    486c:	9301      	str	r3, [sp, #4]
    486e:	9d03      	ldr	r5, [sp, #12]
    4870:	1dcb      	adds	r3, r1, #7
    4872:	f101 0a06 	add.w	sl, r1, #6
    4876:	9302      	str	r3, [sp, #8]
    4878:	f101 0808 	add.w	r8, r1, #8
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    487c:	9b01      	ldr	r3, [sp, #4]
    487e:	f81b 000a 	ldrb.w	r0, [fp, sl]
    4882:	f81b 1003 	ldrb.w	r1, [fp, r3]
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    4886:	f81b 3002 	ldrb.w	r3, [fp, r2]
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    488a:	9a02      	ldr	r2, [sp, #8]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    488c:	0400      	lsls	r0, r0, #16
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    488e:	f81b a002 	ldrb.w	sl, [fp, r2]
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
    4892:	f8d4 2528 	ldr.w	r2, [r4, #1320]	; 0x528
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    4896:	ea40 2101 	orr.w	r1, r0, r1, lsl #8
    489a:	430b      	orrs	r3, r1
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    489c:	ea43 6a0a 	orr.w	sl, r3, sl, lsl #24
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
    48a0:	4592      	cmp	sl, r2
    48a2:	d907      	bls.n	48b4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x550>
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
    48a4:	ea4f 018a 	mov.w	r1, sl, lsl #2
    48a8:	f8d4 0530 	ldr.w	r0, [r4, #1328]	; 0x530
    48ac:	f003 fd60 	bl	8370 <realloc>
    48b0:	f8c4 0530 	str.w	r0, [r4, #1328]	; 0x530
      strings_length = strings_lengthT;
    48b4:	f8c4 a528 	str.w	sl, [r4, #1320]	; 0x528
      for( uint32_t i = 0; i < strings_length; i++){
    48b8:	f1ba 0f00 	cmp.w	sl, #0
    48bc:	d039      	beq.n	4932 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x5ce>
    48be:	f204 532c 	addw	r3, r4, #1324	; 0x52c
    48c2:	f04f 0a00 	mov.w	sl, #0
    48c6:	9301      	str	r3, [sp, #4]
      uint32_t length_st_strings;
      arrToVar(length_st_strings, (inbuffer + offset));
    48c8:	2300      	movs	r3, #0

  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    48ca:	469e      	mov	lr, r3
    48cc:	eb0b 0108 	add.w	r1, fp, r8
    for (size_t i = 0; i < sizeof(V); i++)
      var |= (arr[i] << (8 * i));
    48d0:	f811 2b01 	ldrb.w	r2, [r1], #1
    48d4:	409a      	lsls	r2, r3
    48d6:	3308      	adds	r3, #8
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
    48d8:	2b20      	cmp	r3, #32
      var |= (arr[i] << (8 * i));
    48da:	ea4e 0e02 	orr.w	lr, lr, r2
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
    48de:	d1f7      	bne.n	48d0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x56c>
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
    48e0:	f108 0104 	add.w	r1, r8, #4
    48e4:	448e      	add	lr, r1
    48e6:	4571      	cmp	r1, lr
    48e8:	d20a      	bcs.n	4900 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x59c>
    48ea:	f108 0303 	add.w	r3, r8, #3
    48ee:	445b      	add	r3, fp
    48f0:	460a      	mov	r2, r1
    48f2:	3201      	adds	r2, #1
          inbuffer[k-1]=inbuffer[k];
    48f4:	f813 0f01 	ldrb.w	r0, [r3, #1]!
    48f8:	f803 0c01 	strb.w	r0, [r3, #-1]
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
      uint32_t length_st_strings;
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
    48fc:	4572      	cmp	r2, lr
    48fe:	d3f8      	bcc.n	48f2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x58e>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    4900:	eb0b 020e 	add.w	r2, fp, lr
      this->st_strings = (char *)(inbuffer + offset-1);
    4904:	1e4b      	subs	r3, r1, #1
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    4906:	f04f 0100 	mov.w	r1, #0
    490a:	f802 1c01 	strb.w	r1, [r2, #-1]
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    490e:	f8d4 0530 	ldr.w	r0, [r4, #1328]	; 0x530
    4912:	9901      	ldr	r1, [sp, #4]
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
    4914:	445b      	add	r3, fp
    4916:	f8c4 352c 	str.w	r3, [r4, #1324]	; 0x52c
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    491a:	eb00 008a 	add.w	r0, r0, sl, lsl #2
    491e:	2204      	movs	r2, #4
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
    4920:	46f0      	mov	r8, lr
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    4922:	f000 fe47 	bl	55b4 <memcpy>
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
    4926:	f8d4 3528 	ldr.w	r3, [r4, #1320]	; 0x528
    492a:	f10a 0a01 	add.w	sl, sl, #1
    492e:	4553      	cmp	r3, sl
    4930:	d8ca      	bhi.n	48c8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x564>
            param_received = true;
    4932:	2301      	movs	r3, #1
    4934:	f884 3508 	strb.w	r3, [r4, #1288]	; 0x508
    4938:	e533      	b.n	43a2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    493a:	6833      	ldr	r3, [r6, #0]
    493c:	930c      	str	r3, [sp, #48]	; 0x30
	return ret;
    493e:	980c      	ldr	r0, [sp, #48]	; 0x30
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    4940:	f894 2020 	ldrb.w	r2, [r4, #32]
    4944:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4948:	6833      	ldr	r3, [r6, #0]
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    494a:	f894 801d 	ldrb.w	r8, [r4, #29]
    494e:	f894 a01c 	ldrb.w	sl, [r4, #28]
    4952:	930e      	str	r3, [sp, #56]	; 0x38
  }

  void syncTime(uint8_t * data)
  {
    std_msgs::Time t;
    uint32_t offset = hardware_.time() - rt_time;
    4954:	68e3      	ldr	r3, [r4, #12]
    4956:	f894 e01e 	ldrb.w	lr, [r4, #30]
    495a:	f894 b01f 	ldrb.w	fp, [r4, #31]
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    495e:	ea42 2c01 	orr.w	ip, r2, r1, lsl #8
    4962:	f894 1022 	ldrb.w	r1, [r4, #34]	; 0x22
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    4966:	4a1c      	ldr	r2, [pc, #112]	; (49d8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x674>)
  }

  void syncTime(uint8_t * data)
  {
    std_msgs::Time t;
    uint32_t offset = hardware_.time() - rt_time;
    4968:	1ac0      	subs	r0, r0, r3
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    496a:	ea4a 2308 	orr.w	r3, sl, r8, lsl #8
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    496e:	f894 a023 	ldrb.w	sl, [r4, #35]	; 0x23
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    4972:	fba2 8200 	umull	r8, r2, r2, r0
    4976:	ea4c 4101 	orr.w	r1, ip, r1, lsl #16
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    497a:	ea43 4e0e 	orr.w	lr, r3, lr, lsl #16
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    497e:	f8df 805c 	ldr.w	r8, [pc, #92]	; 49dc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x678>
	return ret;
    4982:	9b0e      	ldr	r3, [sp, #56]	; 0x38
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    4984:	ea41 6a0a 	orr.w	sl, r1, sl, lsl #24
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    4988:	ea4e 610b 	orr.w	r1, lr, fp, lsl #24
    498c:	44d0      	add	r8, sl
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    498e:	f101 3aff 	add.w	sl, r1, #4294967295	; 0xffffffff
    4992:	4911      	ldr	r1, [pc, #68]	; (49d8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x674>)
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    4994:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    4998:	fba1 1e03 	umull	r1, lr, r1, r3
    499c:	0992      	lsrs	r2, r2, #6
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    499e:	fb0c 0012 	mls	r0, ip, r2, r0
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    49a2:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    49a6:	fb09 8000 	mla	r0, r9, r0, r8
    49aa:	fb0c 331e 	mls	r3, ip, lr, r3
    49ae:	4621      	mov	r1, r4
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    49b0:	4452      	add	r2, sl
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    49b2:	fb09 0313 	mls	r3, r9, r3, r0
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    49b6:	ebce 0202 	rsb	r2, lr, r2
    49ba:	6122      	str	r2, [r4, #16]
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    normalizeSecNSec(sec_offset, nsec_offset);
    49bc:	f104 0010 	add.w	r0, r4, #16

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    49c0:	f841 3f14 	str.w	r3, [r1, #20]!
    normalizeSecNSec(sec_offset, nsec_offset);
    49c4:	f000 fde2 	bl	558c <ros::normalizeSecNSec(unsigned long&, unsigned long&)>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    49c8:	6833      	ldr	r3, [r6, #0]
    49ca:	930d      	str	r3, [sp, #52]	; 0x34
	return ret;
    49cc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    t.deserialize(data);
    t.data.sec += offset / 1000;
    t.data.nsec += (offset % 1000) * 1000000UL;

    this->setNow(t.data);
    last_sync_receive_time = hardware_.time();
    49ce:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
    49d2:	e4e6      	b.n	43a2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
    49d4:	00000949 	.word	0x00000949
    49d8:	10624dd3 	.word	0x10624dd3
    49dc:	3b9aca00 	.word	0x3b9aca00
   */

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    49e0:	6822      	ldr	r2, [r4, #0]
    public:
      typedef ros::Time _data_type;
      _data_type data;

    Time():
      data()
    49e2:	4916      	ldr	r1, [pc, #88]	; (4a3c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x6d8>)
    49e4:	910f      	str	r1, [sp, #60]	; 0x3c
    49e6:	9310      	str	r3, [sp, #64]	; 0x40
    49e8:	9311      	str	r3, [sp, #68]	; 0x44
    49ea:	210a      	movs	r1, #10
    49ec:	6813      	ldr	r3, [r2, #0]
    49ee:	4620      	mov	r0, r4
    49f0:	aa0f      	add	r2, sp, #60	; 0x3c
    49f2:	4798      	blx	r3
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    49f4:	6833      	ldr	r3, [r6, #0]
    49f6:	930a      	str	r3, [sp, #40]	; 0x28
	return ret;
    49f8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    rt_time = hardware_.time();
    49fa:	60e3      	str	r3, [r4, #12]
        if ((checksum_ % 256) == 255)
        {
          if (topic_ == TopicInfo::ID_PUBLISHER)
          {
            requestSyncTime();
            negotiateTopics();
    49fc:	4620      	mov	r0, r4
    49fe:	f7ff fa2f 	bl	3e60 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()>
            last_sync_time = c_time;
    4a02:	f8c4 54fc 	str.w	r5, [r4, #1276]	; 0x4fc
            last_sync_receive_time = c_time;
    4a06:	f8c4 5500 	str.w	r5, [r4, #1280]	; 0x500
            return SPIN_ERR;
    4a0a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    4a0e:	e4f2      	b.n	43f6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x92>
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
      floats_length = floats_lengthT;
      for( uint32_t i = 0; i < floats_length; i++){
    4a10:	f8dd 8010 	ldr.w	r8, [sp, #16]
    4a14:	e732      	b.n	487c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x518>
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
      ints_length = ints_lengthT;
      for( uint32_t i = 0; i < ints_length; i++){
    4a16:	210c      	movs	r1, #12
    4a18:	9104      	str	r1, [sp, #16]
    4a1a:	210b      	movs	r1, #11
    4a1c:	9102      	str	r1, [sp, #8]
    4a1e:	2109      	movs	r1, #9
    4a20:	2208      	movs	r2, #8
    4a22:	9101      	str	r1, [sp, #4]
    4a24:	2104      	movs	r1, #4
    4a26:	4613      	mov	r3, r2
    4a28:	f04f 0a0a 	mov.w	sl, #10
    4a2c:	f04f 0807 	mov.w	r8, #7
    4a30:	f04f 0c06 	mov.w	ip, #6
    4a34:	f04f 0e05 	mov.w	lr, #5
    4a38:	9103      	str	r1, [sp, #12]
    4a3a:	e6bd      	b.n	47b8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x454>
    4a3c:	00008f7c 	.word	0x00008f7c

00004a40 <_GLOBAL__sub_I_bool_tele_op_toggel>:
    4a40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
float float_to_long_factor = 10000.0;
float wheel_base = 0.229;            // needs to be updated and use the right unit (proberbly meters)
float wheel_radius = 0.04;           // needs to be updated and use the right unit (proberbly meters)
int16_t accel_X, accel_Y, accel_Z, tmp, gyro_X, gyro_Y, gyro_Z, mx, my, mz;
long publisher_timer;
MPU9250 accelgyro;
    4a42:	486b      	ldr	r0, [pc, #428]	; (4bf0 <_GLOBAL__sub_I_bool_tele_op_toggel+0x1b0>)
template<class Hardware,
         int MAX_SUBSCRIBERS = 25,
         int MAX_PUBLISHERS = 25,
         int INPUT_SIZE = 512,
         int OUTPUT_SIZE = 512>
class NodeHandle_ : public NodeHandleBase_
    4a44:	4d6b      	ldr	r5, [pc, #428]	; (4bf4 <_GLOBAL__sub_I_bool_tele_op_toggel+0x1b4>)
      /* Leonardo support */
      iostream = &Serial1;
#elif defined(USE_TEENSY_HW_SERIAL) or defined(USE_STM32_HW_SERIAL)
      iostream = &Serial1;
#else
      iostream = &Serial;
    4a46:	4e6c      	ldr	r6, [pc, #432]	; (4bf8 <_GLOBAL__sub_I_bool_tele_op_toggel+0x1b8>)
    4a48:	f000 fd76 	bl	5538 <MPU9250::MPU9250()>
    4a4c:	4b6b      	ldr	r3, [pc, #428]	; (4bfc <_GLOBAL__sub_I_bool_tele_op_toggel+0x1bc>)
    4a4e:	602b      	str	r3, [r5, #0]
    4a50:	2400      	movs	r4, #0
#endif
      baud_ = 57600;
    4a52:	f44f 4361 	mov.w	r3, #57600	; 0xe100
    4a56:	f44f 7700 	mov.w	r7, #512	; 0x200
    4a5a:	60ab      	str	r3, [r5, #8]
    4a5c:	4621      	mov	r1, r4
    4a5e:	463a      	mov	r2, r7
      /* Leonardo support */
      iostream = &Serial1;
#elif defined(USE_TEENSY_HW_SERIAL) or defined(USE_STM32_HW_SERIAL)
      iostream = &Serial1;
#else
      iostream = &Serial;
    4a60:	606e      	str	r6, [r5, #4]
    4a62:	f105 001c 	add.w	r0, r5, #28
    4a66:	60ec      	str	r4, [r5, #12]
    4a68:	612c      	str	r4, [r5, #16]
    4a6a:	616c      	str	r4, [r5, #20]
    4a6c:	61ac      	str	r4, [r5, #24]
    4a6e:	2664      	movs	r6, #100	; 0x64
    4a70:	f003 fc2c 	bl	82cc <memset>
    4a74:	463a      	mov	r2, r7
    4a76:	4621      	mov	r1, r4
    4a78:	f505 7007 	add.w	r0, r5, #540	; 0x21c
    4a7c:	f003 fc26 	bl	82cc <memset>
    4a80:	4621      	mov	r1, r4
    4a82:	4632      	mov	r2, r6
    4a84:	f205 401c 	addw	r0, r5, #1052	; 0x41c
    4a88:	f003 fc20 	bl	82cc <memset>
    4a8c:	4632      	mov	r2, r6
    4a8e:	4621      	mov	r1, r4
    4a90:	f505 6090 	add.w	r0, r5, #1152	; 0x480
    4a94:	f003 fc1a 	bl	82cc <memset>
      _strings_type * strings;

    RequestParamResponse():
      ints_length(0), st_ints(), ints(nullptr),
      floats_length(0), st_floats(), floats(nullptr),
      strings_length(0), st_strings(), strings(nullptr)
    4a98:	4859      	ldr	r0, [pc, #356]	; (4c00 <_GLOBAL__sub_I_bool_tele_op_toggel+0x1c0>)
    4a9a:	f8c5 44e4 	str.w	r4, [r5, #1252]	; 0x4e4
    4a9e:	f8c5 44e8 	str.w	r4, [r5, #1256]	; 0x4e8
    4aa2:	f8c5 44ec 	str.w	r4, [r5, #1260]	; 0x4ec
    4aa6:	f8c5 44f0 	str.w	r4, [r5, #1264]	; 0x4f0
    4aaa:	f8c5 44f4 	str.w	r4, [r5, #1268]	; 0x4f4
    4aae:	f885 44f8 	strb.w	r4, [r5, #1272]	; 0x4f8
    4ab2:	f8c5 44fc 	str.w	r4, [r5, #1276]	; 0x4fc
    4ab6:	f8c5 4500 	str.w	r4, [r5, #1280]	; 0x500
    4aba:	f8c5 4504 	str.w	r4, [r5, #1284]	; 0x504
    4abe:	f885 4508 	strb.w	r4, [r5, #1288]	; 0x508
    4ac2:	f8c5 4510 	str.w	r4, [r5, #1296]	; 0x510
    4ac6:	f8c5 4514 	str.w	r4, [r5, #1300]	; 0x514
    4aca:	f8c5 4518 	str.w	r4, [r5, #1304]	; 0x518
    4ace:	f8c5 451c 	str.w	r4, [r5, #1308]	; 0x51c
    4ad2:	f8c5 4524 	str.w	r4, [r5, #1316]	; 0x524
    4ad6:	f8c5 4528 	str.w	r4, [r5, #1320]	; 0x528
    4ada:	f8c5 452c 	str.w	r4, [r5, #1324]	; 0x52c
    4ade:	f8c5 4530 	str.w	r4, [r5, #1328]	; 0x530
    4ae2:	f8c5 050c 	str.w	r0, [r5, #1292]	; 0x50c
    4ae6:	f505 65a4 	add.w	r5, r5, #1312	; 0x520
    4aea:	2300      	movs	r3, #0
    public:
      typedef int16_t _data_type;
      _data_type data;

    Int16():
      data(0)
    4aec:	4945      	ldr	r1, [pc, #276]	; (4c04 <_GLOBAL__sub_I_bool_tele_op_toggel+0x1c4>)
{
public:
  Publisher(const char * topic_name, Msg * msg, int endpoint = rosserial_msgs::TopicInfo::ID_PUBLISHER) :
    topic_(topic_name),
    msg_(msg),
    endpoint_(endpoint) {};
    4aee:	4a46      	ldr	r2, [pc, #280]	; (4c08 <_GLOBAL__sub_I_bool_tele_op_toggel+0x1c8>)
    4af0:	f8df e18c 	ldr.w	lr, [pc, #396]	; 4c80 <_GLOBAL__sub_I_bool_tele_op_toggel+0x240>
    public:
      typedef float _data_type;
      _data_type data;

    Float32():
      data(0)
    4af4:	4e45      	ldr	r6, [pc, #276]	; (4c0c <_GLOBAL__sub_I_bool_tele_op_toggel+0x1cc>)
    4af6:	4f46      	ldr	r7, [pc, #280]	; (4c10 <_GLOBAL__sub_I_bool_tele_op_toggel+0x1d0>)
    4af8:	602b      	str	r3, [r5, #0]
    4afa:	4d46      	ldr	r5, [pc, #280]	; (4c14 <_GLOBAL__sub_I_bool_tele_op_toggel+0x1d4>)
    4afc:	f8df c184 	ldr.w	ip, [pc, #388]	; 4c84 <_GLOBAL__sub_I_bool_tele_op_toggel+0x244>
    4b00:	4845      	ldr	r0, [pc, #276]	; (4c18 <_GLOBAL__sub_I_bool_tele_op_toggel+0x1d8>)
    4b02:	808c      	strh	r4, [r1, #4]
    4b04:	600f      	str	r7, [r1, #0]
    4b06:	6051      	str	r1, [r2, #4]
    4b08:	f8ce 5000 	str.w	r5, [lr]
    4b0c:	4943      	ldr	r1, [pc, #268]	; (4c1c <_GLOBAL__sub_I_bool_tele_op_toggel+0x1dc>)
    4b0e:	4d44      	ldr	r5, [pc, #272]	; (4c20 <_GLOBAL__sub_I_bool_tele_op_toggel+0x1e0>)
    4b10:	6114      	str	r4, [r2, #16]
    4b12:	6011      	str	r1, [r2, #0]
    4b14:	6035      	str	r5, [r6, #0]

    Quaternion():
      x(0),
      y(0),
      z(0),
      w(0)
    4b16:	4a43      	ldr	r2, [pc, #268]	; (4c24 <_GLOBAL__sub_I_bool_tele_op_toggel+0x1e4>)
    4b18:	4943      	ldr	r1, [pc, #268]	; (4c28 <_GLOBAL__sub_I_bool_tele_op_toggel+0x1e8>)
    4b1a:	4d44      	ldr	r5, [pc, #272]	; (4c2c <_GLOBAL__sub_I_bool_tele_op_toggel+0x1ec>)
    4b1c:	f8cc 7000 	str.w	r7, [ip]
    4b20:	f8ac 4004 	strh.w	r4, [ip, #4]
    4b24:	f8ce c004 	str.w	ip, [lr, #4]
    4b28:	f8ce 4010 	str.w	r4, [lr, #16]
    4b2c:	6073      	str	r3, [r6, #4]
    4b2e:	6005      	str	r5, [r0, #0]
    4b30:	6046      	str	r6, [r0, #4]
    4b32:	6104      	str	r4, [r0, #16]
    4b34:	483e      	ldr	r0, [pc, #248]	; (4c30 <_GLOBAL__sub_I_bool_tele_op_toggel+0x1f0>)
      _z_type z;

    Vector3():
      x(0),
      y(0),
      z(0)
    4b36:	4d3f      	ldr	r5, [pc, #252]	; (4c34 <_GLOBAL__sub_I_bool_tele_op_toggel+0x1f4>)
    4b38:	f8df e14c 	ldr.w	lr, [pc, #332]	; 4c88 <_GLOBAL__sub_I_bool_tele_op_toggel+0x248>
    4b3c:	6010      	str	r0, [r2, #0]
    4b3e:	6053      	str	r3, [r2, #4]
    4b40:	6093      	str	r3, [r2, #8]
    4b42:	60d3      	str	r3, [r2, #12]
    4b44:	604a      	str	r2, [r1, #4]
    4b46:	6113      	str	r3, [r2, #16]
    4b48:	4a3b      	ldr	r2, [pc, #236]	; (4c38 <_GLOBAL__sub_I_bool_tele_op_toggel+0x1f8>)
    4b4a:	483c      	ldr	r0, [pc, #240]	; (4c3c <_GLOBAL__sub_I_bool_tele_op_toggel+0x1fc>)
    4b4c:	4e3c      	ldr	r6, [pc, #240]	; (4c40 <_GLOBAL__sub_I_bool_tele_op_toggel+0x200>)
    4b4e:	610c      	str	r4, [r1, #16]
    4b50:	600a      	str	r2, [r1, #0]
    4b52:	493c      	ldr	r1, [pc, #240]	; (4c44 <_GLOBAL__sub_I_bool_tele_op_toggel+0x204>)
    4b54:	f8ce 5004 	str.w	r5, [lr, #4]
    4b58:	6029      	str	r1, [r5, #0]
    4b5a:	606b      	str	r3, [r5, #4]
    4b5c:	60ab      	str	r3, [r5, #8]
    4b5e:	60eb      	str	r3, [r5, #12]
    4b60:	4d39      	ldr	r5, [pc, #228]	; (4c48 <_GLOBAL__sub_I_bool_tele_op_toggel+0x208>)
    4b62:	4a3a      	ldr	r2, [pc, #232]	; (4c4c <_GLOBAL__sub_I_bool_tele_op_toggel+0x20c>)
    4b64:	f8ce 4010 	str.w	r4, [lr, #16]
    4b68:	f8ce 5000 	str.w	r5, [lr]
    4b6c:	6070      	str	r0, [r6, #4]
    4b6e:	f8df e11c 	ldr.w	lr, [pc, #284]	; 4c8c <_GLOBAL__sub_I_bool_tele_op_toggel+0x24c>
    4b72:	6001      	str	r1, [r0, #0]
    4b74:	6043      	str	r3, [r0, #4]
    4b76:	6083      	str	r3, [r0, #8]
    4b78:	60c3      	str	r3, [r0, #12]
    4b7a:	4835      	ldr	r0, [pc, #212]	; (4c50 <_GLOBAL__sub_I_bool_tele_op_toggel+0x210>)
    4b7c:	4d35      	ldr	r5, [pc, #212]	; (4c54 <_GLOBAL__sub_I_bool_tele_op_toggel+0x214>)
    4b7e:	6134      	str	r4, [r6, #16]
    4b80:	6030      	str	r0, [r6, #0]
  typedef void(*CallbackT)(const MsgT&);
  MsgT msg;

  Subscriber(const char * topic_name, CallbackT cb, int endpoint = rosserial_msgs::TopicInfo::ID_SUBSCRIBER) :
    cb_(cb),
    endpoint_(endpoint)
    4b82:	4835      	ldr	r0, [pc, #212]	; (4c58 <_GLOBAL__sub_I_bool_tele_op_toggel+0x218>)
    4b84:	4e35      	ldr	r6, [pc, #212]	; (4c5c <_GLOBAL__sub_I_bool_tele_op_toggel+0x21c>)
    4b86:	f8ce 2004 	str.w	r2, [lr, #4]
    4b8a:	6011      	str	r1, [r2, #0]
    4b8c:	6053      	str	r3, [r2, #4]
    4b8e:	6093      	str	r3, [r2, #8]
    4b90:	60d3      	str	r3, [r2, #12]
    4b92:	4a33      	ldr	r2, [pc, #204]	; (4c60 <_GLOBAL__sub_I_bool_tele_op_toggel+0x220>)
    4b94:	f8ce 4010 	str.w	r4, [lr, #16]
    4b98:	f8ce 2000 	str.w	r2, [lr]
    4b9c:	6029      	str	r1, [r5, #0]
    4b9e:	4a31      	ldr	r2, [pc, #196]	; (4c64 <_GLOBAL__sub_I_bool_tele_op_toggel+0x224>)
    4ba0:	606b      	str	r3, [r5, #4]
    4ba2:	f8df c0ec 	ldr.w	ip, [pc, #236]	; 4c90 <_GLOBAL__sub_I_bool_tele_op_toggel+0x250>
    4ba6:	60c7      	str	r7, [r0, #12]
    4ba8:	8204      	strh	r4, [r0, #16]
    4baa:	4f2f      	ldr	r7, [pc, #188]	; (4c68 <_GLOBAL__sub_I_bool_tele_op_toggel+0x228>)
    4bac:	6075      	str	r5, [r6, #4]
    4bae:	6134      	str	r4, [r6, #16]
    4bb0:	60ab      	str	r3, [r5, #8]
    4bb2:	2401      	movs	r4, #1
    4bb4:	60eb      	str	r3, [r5, #12]
    4bb6:	f8df e0dc 	ldr.w	lr, [pc, #220]	; 4c94 <_GLOBAL__sub_I_bool_tele_op_toggel+0x254>
  {
    topic_ = topic_name;
    4bba:	4d2c      	ldr	r5, [pc, #176]	; (4c6c <_GLOBAL__sub_I_bool_tele_op_toggel+0x22c>)
    4bbc:	6037      	str	r7, [r6, #0]
    4bbe:	6085      	str	r5, [r0, #8]
  typedef void(*CallbackT)(const MsgT&);
  MsgT msg;

  Subscriber(const char * topic_name, CallbackT cb, int endpoint = rosserial_msgs::TopicInfo::ID_SUBSCRIBER) :
    cb_(cb),
    endpoint_(endpoint)
    4bc0:	4f2b      	ldr	r7, [pc, #172]	; (4c70 <_GLOBAL__sub_I_bool_tele_op_toggel+0x230>)
    4bc2:	f8c0 c000 	str.w	ip, [r0]
    4bc6:	f8c0 e014 	str.w	lr, [r0, #20]
      typedef geometry_msgs::Vector3 _angular_type;
      _angular_type angular;

    Twist():
      linear(),
      angular()
    4bca:	4e2a      	ldr	r6, [pc, #168]	; (4c74 <_GLOBAL__sub_I_bool_tele_op_toggel+0x234>)
    4bcc:	4d2a      	ldr	r5, [pc, #168]	; (4c78 <_GLOBAL__sub_I_bool_tele_op_toggel+0x238>)
    4bce:	6184      	str	r4, [r0, #24]
  {
    topic_ = topic_name;
    4bd0:	482a      	ldr	r0, [pc, #168]	; (4c7c <_GLOBAL__sub_I_bool_tele_op_toggel+0x23c>)
  typedef void(*CallbackT)(const MsgT&);
  MsgT msg;

  Subscriber(const char * topic_name, CallbackT cb, int endpoint = rosserial_msgs::TopicInfo::ID_SUBSCRIBER) :
    cb_(cb),
    endpoint_(endpoint)
    4bd2:	6354      	str	r4, [r2, #52]	; 0x34
    4bd4:	6111      	str	r1, [r2, #16]
    4bd6:	6153      	str	r3, [r2, #20]
    4bd8:	6193      	str	r3, [r2, #24]
    4bda:	61d3      	str	r3, [r2, #28]
    4bdc:	6211      	str	r1, [r2, #32]
    4bde:	6253      	str	r3, [r2, #36]	; 0x24
    4be0:	6293      	str	r3, [r2, #40]	; 0x28
    4be2:	62d3      	str	r3, [r2, #44]	; 0x2c
    4be4:	6017      	str	r7, [r2, #0]
    4be6:	60d6      	str	r6, [r2, #12]
    4be8:	6315      	str	r5, [r2, #48]	; 0x30
  {
    topic_ = topic_name;
    4bea:	6090      	str	r0, [r2, #8]
    4bec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    4bee:	bf00      	nop
    4bf0:	1fff1c58 	.word	0x1fff1c58
    4bf4:	1fff1d54 	.word	0x1fff1d54
    4bf8:	1fff0b24 	.word	0x1fff0b24
    4bfc:	00009054 	.word	0x00009054
    4c00:	00008fc4 	.word	0x00008fc4
    4c04:	1fff1cdc 	.word	0x1fff1cdc
    4c08:	1fff1458 	.word	0x1fff1458
    4c0c:	1fff2ab8 	.word	0x1fff2ab8
    4c10:	00008fdc 	.word	0x00008fdc
    4c14:	00009378 	.word	0x00009378
    4c18:	1fff2a68 	.word	0x1fff2a68
    4c1c:	0000936c 	.word	0x0000936c
    4c20:	00008ff4 	.word	0x00008ff4
    4c24:	1fff2a98 	.word	0x1fff2a98
    4c28:	1fff1d0c 	.word	0x1fff1d0c
    4c2c:	00009384 	.word	0x00009384
    4c30:	00009024 	.word	0x00009024
    4c34:	1fff1478 	.word	0x1fff1478
    4c38:	00009390 	.word	0x00009390
    4c3c:	1fff1c90 	.word	0x1fff1c90
    4c40:	1fff1ce4 	.word	0x1fff1ce4
    4c44:	0000900c 	.word	0x0000900c
    4c48:	000093a0 	.word	0x000093a0
    4c4c:	1fff1c80 	.word	0x1fff1c80
    4c50:	000093a8 	.word	0x000093a8
    4c54:	1fff143c 	.word	0x1fff143c
    4c58:	1fff2a7c 	.word	0x1fff2a7c
    4c5c:	1fff2ac0 	.word	0x1fff2ac0
    4c60:	000093b4 	.word	0x000093b4
    4c64:	1fff1ca4 	.word	0x1fff1ca4
    4c68:	000093bc 	.word	0x000093bc
    4c6c:	000093d4 	.word	0x000093d4
    4c70:	00009068 	.word	0x00009068
    4c74:	0000903c 	.word	0x0000903c
    4c78:	00002c69 	.word	0x00002c69
    4c7c:	000093cc 	.word	0x000093cc
    4c80:	1fff1d38 	.word	0x1fff1d38
    4c84:	1fff2ad4 	.word	0x1fff2ad4
    4c88:	1fff1c68 	.word	0x1fff1c68
    4c8c:	1fff1cf8 	.word	0x1fff1cf8
    4c90:	00009080 	.word	0x00009080
    4c94:	00002af9 	.word	0x00002af9

00004c98 <TwoWire::available()>:
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    4c98:	f890 2039 	ldrb.w	r2, [r0, #57]	; 0x39
    4c9c:	f890 0038 	ldrb.w	r0, [r0, #56]	; 0x38
	}
    4ca0:	1a10      	subs	r0, r2, r0
    4ca2:	4770      	bx	lr

00004ca4 <TwoWire::read()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    4ca4:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
    4ca8:	f890 2039 	ldrb.w	r2, [r0, #57]	; 0x39
    4cac:	429a      	cmp	r2, r3
    4cae:	d905      	bls.n	4cbc <TwoWire::read()+0x18>
		return rxBuffer[rxBufferIndex++];
    4cb0:	1c5a      	adds	r2, r3, #1
    4cb2:	4403      	add	r3, r0
    4cb4:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    4cb8:	7e18      	ldrb	r0, [r3, #24]
    4cba:	4770      	bx	lr
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    4cbc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		return rxBuffer[rxBufferIndex++];
	}
    4cc0:	4770      	bx	lr
    4cc2:	bf00      	nop

00004cc4 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)>:
 * @param length Number of bytes to read
 * @param data Buffer to store read data in
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Number of bytes read (-1 indicates failure)
 */
int8_t I2Cdev::readBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t *data, uint16_t timeout, void *wireObj) {
    4cc4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4cc8:	f8df a144 	ldr.w	sl, [pc, #324]	; 4e10 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x14c>

    int8_t count = 0;
    uint32_t t1 = millis();

    #if (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
        TwoWire *useWire = &Wire;
    4ccc:	4d4e      	ldr	r5, [pc, #312]	; (4e08 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x144>)
    4cce:	f8da 6000 	ldr.w	r6, [sl]
 * @param length Number of bytes to read
 * @param data Buffer to store read data in
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Number of bytes read (-1 indicates failure)
 */
int8_t I2Cdev::readBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t *data, uint16_t timeout, void *wireObj) {
    4cd2:	b08d      	sub	sp, #52	; 0x34
    4cd4:	4699      	mov	r9, r3
    4cd6:	9c17      	ldr	r4, [sp, #92]	; 0x5c
    4cd8:	9609      	str	r6, [sp, #36]	; 0x24
    4cda:	9006      	str	r0, [sp, #24]
    4cdc:	9107      	str	r1, [sp, #28]
	return ret;
    4cde:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
    4ce2:	f8bd 6058 	ldrh.w	r6, [sp, #88]	; 0x58
            // Adds official support for repeated start condition, yay!

            // I2C/TWI subsystem uses internal buffer that breaks with large data requests
            // so if user requests more than I2CDEVLIB_WIRE_BUFFER_LENGTH bytes, we have to do it in
            // smaller chunks instead of all at once
            for (int k = 0; k < length; k += min((int)length, I2CDEVLIB_WIRE_BUFFER_LENGTH)) {
    4ce6:	9204      	str	r2, [sp, #16]

    int8_t count = 0;
    uint32_t t1 = millis();

    #if (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
        TwoWire *useWire = &Wire;
    4ce8:	2c00      	cmp	r4, #0
    4cea:	bf08      	it	eq
    4cec:	462c      	moveq	r4, r5
            // Adds official support for repeated start condition, yay!

            // I2C/TWI subsystem uses internal buffer that breaks with large data requests
            // so if user requests more than I2CDEVLIB_WIRE_BUFFER_LENGTH bytes, we have to do it in
            // smaller chunks instead of all at once
            for (int k = 0; k < length; k += min((int)length, I2CDEVLIB_WIRE_BUFFER_LENGTH)) {
    4cee:	2a00      	cmp	r2, #0
    4cf0:	d076      	beq.n	4de0 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x11c>
    4cf2:	0043      	lsls	r3, r0, #1
    4cf4:	2a20      	cmp	r2, #32
    4cf6:	4610      	mov	r0, r2
    4cf8:	b2db      	uxtb	r3, r3
    4cfa:	bfa8      	it	ge
    4cfc:	2220      	movge	r2, #32
    4cfe:	4f43      	ldr	r7, [pc, #268]	; (4e0c <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x148>)
    4d00:	f8df 8110 	ldr.w	r8, [pc, #272]	; 4e14 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x150>
    4d04:	9205      	str	r2, [sp, #20]
    4d06:	9303      	str	r3, [sp, #12]
    4d08:	9202      	str	r2, [sp, #8]
    4d0a:	9001      	str	r0, [sp, #4]
    4d0c:	2500      	movs	r5, #0
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    4d0e:	f89d 200c 	ldrb.w	r2, [sp, #12]
    4d12:	f884 203b 	strb.w	r2, [r4, #59]	; 0x3b
                useWire->beginTransmission(devAddr);
                useWire->write(regAddr);
    4d16:	6823      	ldr	r3, [r4, #0]
    4d18:	9907      	ldr	r1, [sp, #28]
		transmitting = 1;
    4d1a:	f04f 0201 	mov.w	r2, #1
    4d1e:	f884 205e 	strb.w	r2, [r4, #94]	; 0x5e
		txBufferLength = 1;
    4d22:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
    4d26:	681b      	ldr	r3, [r3, #0]
    4d28:	4620      	mov	r0, r4
    4d2a:	4798      	blx	r3
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    4d2c:	2101      	movs	r1, #1
    4d2e:	4620      	mov	r0, r4
    4d30:	f000 fa54 	bl	51dc <TwoWire::endTransmission(unsigned char)>
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    4d34:	f89d 300c 	ldrb.w	r3, [sp, #12]
    4d38:	f884 303b 	strb.w	r3, [r4, #59]	; 0x3b
		transmitting = 1;
    4d3c:	f04f 0301 	mov.w	r3, #1
    4d40:	f884 305e 	strb.w	r3, [r4, #94]	; 0x5e
		txBufferLength = 1;
    4d44:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
//#include <algorithm> // this isn't really needed, is it?  (slows down compiling)
#include <utility>
// https://forum.pjrc.com/threads/44596-Teensyduino-1-37-Beta-2-(Arduino-1-8-3-support)?p=145150&viewfull=1#post145150
template<class A, class B>
constexpr auto min(A&& a, B&& b) -> decltype(a < b ? std::forward<A>(a) : std::forward<B>(b)) {
  return a < b ? std::forward<A>(a) : std::forward<B>(b);
    4d48:	9b01      	ldr	r3, [sp, #4]
	uint8_t endTransmission(void) {
		return endTransmission(1);
	}
	uint8_t requestFrom(uint8_t address, uint8_t quantity, uint8_t sendStop);
	uint8_t requestFrom(uint8_t address, uint8_t quantity) {
		return requestFrom(address, quantity, (uint8_t)1);
    4d4a:	9906      	ldr	r1, [sp, #24]
    4d4c:	2b1f      	cmp	r3, #31
    4d4e:	bfd4      	ite	le
    4d50:	b2da      	uxtble	r2, r3
    4d52:	2220      	movgt	r2, #32
    4d54:	2301      	movs	r3, #1
    4d56:	4620      	mov	r0, r4
    4d58:	f000 faca 	bl	52f0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>
                useWire->endTransmission();
                useWire->beginTransmission(devAddr);
                useWire->requestFrom((uint8_t)devAddr, (uint8_t)min((int)length - k, I2CDEVLIB_WIRE_BUFFER_LENGTH));
        
                for (; useWire->available() && (timeout == 0 || millis() - t1 < timeout); count++) {
    4d5c:	6823      	ldr	r3, [r4, #0]
    4d5e:	691b      	ldr	r3, [r3, #16]
    4d60:	42bb      	cmp	r3, r7
    4d62:	d126      	bne.n	4db2 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xee>
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    4d64:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
    4d68:	f894 0038 	ldrb.w	r0, [r4, #56]	; 0x38
    4d6c:	1a18      	subs	r0, r3, r0
    4d6e:	b320      	cbz	r0, 4dba <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xf6>
    4d70:	b13e      	cbz	r6, 4d82 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xbe>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4d72:	f8da 3000 	ldr.w	r3, [sl]
    4d76:	930a      	str	r3, [sp, #40]	; 0x28
	return ret;
    4d78:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4d7a:	ebcb 0303 	rsb	r3, fp, r3
    4d7e:	42b3      	cmp	r3, r6
    4d80:	d21b      	bcs.n	4dba <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xf6>
                    data[count] = useWire->read();
    4d82:	6823      	ldr	r3, [r4, #0]
    4d84:	695b      	ldr	r3, [r3, #20]
    4d86:	4543      	cmp	r3, r8
    4d88:	eb09 0205 	add.w	r2, r9, r5
    4d8c:	d120      	bne.n	4dd0 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x10c>
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    4d8e:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
    4d92:	f894 1039 	ldrb.w	r1, [r4, #57]	; 0x39
    4d96:	4299      	cmp	r1, r3
    4d98:	d920      	bls.n	4ddc <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x118>
		return rxBuffer[rxBufferIndex++];
    4d9a:	1c59      	adds	r1, r3, #1
    4d9c:	4423      	add	r3, r4
    4d9e:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
    4da2:	7e18      	ldrb	r0, [r3, #24]
    4da4:	7010      	strb	r0, [r2, #0]
                useWire->write(regAddr);
                useWire->endTransmission();
                useWire->beginTransmission(devAddr);
                useWire->requestFrom((uint8_t)devAddr, (uint8_t)min((int)length - k, I2CDEVLIB_WIRE_BUFFER_LENGTH));
        
                for (; useWire->available() && (timeout == 0 || millis() - t1 < timeout); count++) {
    4da6:	6823      	ldr	r3, [r4, #0]
    4da8:	691b      	ldr	r3, [r3, #16]
    4daa:	3501      	adds	r5, #1
    4dac:	42bb      	cmp	r3, r7
    4dae:	b26d      	sxtb	r5, r5
    4db0:	d0d8      	beq.n	4d64 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xa0>
    4db2:	4620      	mov	r0, r4
    4db4:	4798      	blx	r3
    4db6:	2800      	cmp	r0, #0
    4db8:	d1da      	bne.n	4d70 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xac>
    4dba:	9a01      	ldr	r2, [sp, #4]
    4dbc:	9b05      	ldr	r3, [sp, #20]
            // Adds official support for repeated start condition, yay!

            // I2C/TWI subsystem uses internal buffer that breaks with large data requests
            // so if user requests more than I2CDEVLIB_WIRE_BUFFER_LENGTH bytes, we have to do it in
            // smaller chunks instead of all at once
            for (int k = 0; k < length; k += min((int)length, I2CDEVLIB_WIRE_BUFFER_LENGTH)) {
    4dbe:	9904      	ldr	r1, [sp, #16]
    4dc0:	1ad2      	subs	r2, r2, r3
    4dc2:	9201      	str	r2, [sp, #4]
    4dc4:	9a02      	ldr	r2, [sp, #8]
    4dc6:	428a      	cmp	r2, r1
    4dc8:	4413      	add	r3, r2
    4dca:	da0a      	bge.n	4de2 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x11e>
    4dcc:	9302      	str	r3, [sp, #8]
    4dce:	e79e      	b.n	4d0e <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x4a>
    4dd0:	9200      	str	r2, [sp, #0]
                useWire->endTransmission();
                useWire->beginTransmission(devAddr);
                useWire->requestFrom((uint8_t)devAddr, (uint8_t)min((int)length - k, I2CDEVLIB_WIRE_BUFFER_LENGTH));
        
                for (; useWire->available() && (timeout == 0 || millis() - t1 < timeout); count++) {
                    data[count] = useWire->read();
    4dd2:	4620      	mov	r0, r4
    4dd4:	4798      	blx	r3
    4dd6:	9a00      	ldr	r2, [sp, #0]
    4dd8:	b2c0      	uxtb	r0, r0
    4dda:	e7e3      	b.n	4da4 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xe0>
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    4ddc:	20ff      	movs	r0, #255	; 0xff
    4dde:	e7e1      	b.n	4da4 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xe0>
        Serial.print(" bytes from 0x");
        Serial.print(regAddr, HEX);
        Serial.print("...");
    #endif

    int8_t count = 0;
    4de0:	9d04      	ldr	r5, [sp, #16]
        }

    #endif

    // check for timeout
    if (timeout > 0 && millis() - t1 >= timeout && count < length) count = -1; // timeout
    4de2:	b166      	cbz	r6, 4dfe <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x13a>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4de4:	f8da 3000 	ldr.w	r3, [sl]
    4de8:	930b      	str	r3, [sp, #44]	; 0x2c
	return ret;
    4dea:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    4dec:	ebcb 0b03 	rsb	fp, fp, r3
    4df0:	45b3      	cmp	fp, r6
    4df2:	d304      	bcc.n	4dfe <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x13a>
    4df4:	9b04      	ldr	r3, [sp, #16]
    4df6:	429d      	cmp	r5, r3
    4df8:	bfb8      	it	lt
    4dfa:	f04f 35ff 	movlt.w	r5, #4294967295	; 0xffffffff
        Serial.print(count, DEC);
        Serial.println(" read).");
    #endif

    return count;
}
    4dfe:	4628      	mov	r0, r5
    4e00:	b00d      	add	sp, #52	; 0x34
    4e02:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4e06:	bf00      	nop
    4e08:	1fff088c 	.word	0x1fff088c
    4e0c:	00004c99 	.word	0x00004c99
    4e10:	1fff2ae4 	.word	0x1fff2ae4
    4e14:	00004ca5 	.word	0x00004ca5

00004e18 <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*, void*)>:
 * @param regAddr First register address to write to
 * @param length Number of bytes to write
 * @param data Buffer to copy new data from
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t* data, void *wireObj) {
    4e18:	b570      	push	{r4, r5, r6, lr}
    4e1a:	9d04      	ldr	r5, [sp, #16]
        Serial.print("...");
    #endif
    uint8_t status = 0;

#if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE
    TwoWire *useWire = &Wire;
    4e1c:	4c13      	ldr	r4, [pc, #76]	; (4e6c <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*, void*)+0x54>)
    4e1e:	2d00      	cmp	r5, #0
    4e20:	bf08      	it	eq
    4e22:	4625      	moveq	r5, r4
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    4e24:	0040      	lsls	r0, r0, #1
        useWire->send((uint8_t) regAddr); // send address
    #elif ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100) \
            || (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE && ARDUINO >= 100) \
            || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
        useWire->beginTransmission(devAddr);
        useWire->write((uint8_t) regAddr); // send address
    4e26:	682c      	ldr	r4, [r5, #0]
    4e28:	f885 003b 	strb.w	r0, [r5, #59]	; 0x3b
		transmitting = 1;
    4e2c:	2001      	movs	r0, #1
    4e2e:	f885 005e 	strb.w	r0, [r5, #94]	; 0x5e
		txBufferLength = 1;
    4e32:	f885 005d 	strb.w	r0, [r5, #93]	; 0x5d
 * @param regAddr First register address to write to
 * @param length Number of bytes to write
 * @param data Buffer to copy new data from
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t* data, void *wireObj) {
    4e36:	4616      	mov	r6, r2
        useWire->send((uint8_t) regAddr); // send address
    #elif ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100) \
            || (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE && ARDUINO >= 100) \
            || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
        useWire->beginTransmission(devAddr);
        useWire->write((uint8_t) regAddr); // send address
    4e38:	4628      	mov	r0, r5
    4e3a:	6822      	ldr	r2, [r4, #0]
 * @param regAddr First register address to write to
 * @param length Number of bytes to write
 * @param data Buffer to copy new data from
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t* data, void *wireObj) {
    4e3c:	461c      	mov	r4, r3
        useWire->send((uint8_t) regAddr); // send address
    #elif ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100) \
            || (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE && ARDUINO >= 100) \
            || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
        useWire->beginTransmission(devAddr);
        useWire->write((uint8_t) regAddr); // send address
    4e3e:	4790      	blx	r2
    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE)
        Fastwire::beginTransmission(devAddr);
        Fastwire::write(regAddr);
    #endif
    for (uint8_t i = 0; i < length; i++) {
    4e40:	b15e      	cbz	r6, 4e5a <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*, void*)+0x42>
    4e42:	3e01      	subs	r6, #1
    4e44:	fa54 f686 	uxtab	r6, r4, r6
    4e48:	3c01      	subs	r4, #1
        #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)
            useWire->send((uint8_t) data[i]);
        #elif ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100) \
                || (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE && ARDUINO >= 100) \
                || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
            useWire->write((uint8_t) data[i]);
    4e4a:	682b      	ldr	r3, [r5, #0]
    4e4c:	f814 1f01 	ldrb.w	r1, [r4, #1]!
    4e50:	681b      	ldr	r3, [r3, #0]
    4e52:	4628      	mov	r0, r5
    4e54:	4798      	blx	r3
        useWire->write((uint8_t) regAddr); // send address
    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE)
        Fastwire::beginTransmission(devAddr);
        Fastwire::write(regAddr);
    #endif
    for (uint8_t i = 0; i < length; i++) {
    4e56:	42b4      	cmp	r4, r6
    4e58:	d1f7      	bne.n	4e4a <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*, void*)+0x32>
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    4e5a:	4628      	mov	r0, r5
    4e5c:	2101      	movs	r1, #1
    4e5e:	f000 f9bd 	bl	51dc <TwoWire::endTransmission(unsigned char)>
        //status = Fastwire::endTransmission();
    #endif
    #ifdef I2CDEV_SERIAL_DEBUG
        Serial.println(". Done.");
    #endif
    return status == 0;
    4e62:	fab0 f080 	clz	r0, r0
    4e66:	0940      	lsrs	r0, r0, #5
}
    4e68:	bd70      	pop	{r4, r5, r6, pc}
    4e6a:	bf00      	nop
    4e6c:	1fff088c 	.word	0x1fff088c

00004e70 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char, void*)>:
 * @param regAddr Register regAddr to write to
 * @param bitNum Bit position to write (0-7)
 * @param value New bit value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    4e70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint8_t b;
    readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj);
    4e74:	4c14      	ldr	r4, [pc, #80]	; (4ec8 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char, void*)+0x58>)
 * @param regAddr Register regAddr to write to
 * @param bitNum Bit position to write (0-7)
 * @param value New bit value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    4e76:	b084      	sub	sp, #16
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    4e78:	8824      	ldrh	r4, [r4, #0]
 * @param regAddr Register regAddr to write to
 * @param bitNum Bit position to write (0-7)
 * @param value New bit value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    4e7a:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    4e7c:	9400      	str	r4, [sp, #0]
 * @param regAddr Register regAddr to write to
 * @param bitNum Bit position to write (0-7)
 * @param value New bit value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    4e7e:	4698      	mov	r8, r3
    4e80:	4614      	mov	r4, r2
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    4e82:	f10d 030e 	add.w	r3, sp, #14
    4e86:	2201      	movs	r2, #1
    4e88:	9501      	str	r5, [sp, #4]
 * @param regAddr Register regAddr to write to
 * @param bitNum Bit position to write (0-7)
 * @param value New bit value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    4e8a:	4606      	mov	r6, r0
    4e8c:	460f      	mov	r7, r1
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    4e8e:	f7ff ff19 	bl	4cc4 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)>
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    uint8_t b;
    readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj);
    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
    4e92:	2201      	movs	r2, #1
    4e94:	f89d 300e 	ldrb.w	r3, [sp, #14]
    4e98:	fa02 f404 	lsl.w	r4, r2, r4
    4e9c:	f1b8 0f00 	cmp.w	r8, #0
    4ea0:	d10f      	bne.n	4ec2 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char, void*)+0x52>
    4ea2:	ea23 0404 	bic.w	r4, r3, r4
    4ea6:	ab04      	add	r3, sp, #16
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data, void *wireObj) {
    return writeBytes(devAddr, regAddr, 1, &data, wireObj);
    4ea8:	9500      	str	r5, [sp, #0]
    4eaa:	4639      	mov	r1, r7
    4eac:	f803 4d01 	strb.w	r4, [r3, #-1]!
    4eb0:	4630      	mov	r0, r6
    4eb2:	2201      	movs	r2, #1
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    uint8_t b;
    readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj);
    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
    4eb4:	f88d 400e 	strb.w	r4, [sp, #14]
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data, void *wireObj) {
    return writeBytes(devAddr, regAddr, 1, &data, wireObj);
    4eb8:	f7ff ffae 	bl	4e18 <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*, void*)>
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    uint8_t b;
    readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj);
    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
    return writeByte(devAddr, regAddr, b, wireObj);
}
    4ebc:	b004      	add	sp, #16
    4ebe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    uint8_t b;
    readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj);
    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
    4ec2:	431c      	orrs	r4, r3
    4ec4:	b2e4      	uxtb	r4, r4
    4ec6:	e7ee      	b.n	4ea6 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char, void*)+0x36>
    4ec8:	1fff081c 	.word	0x1fff081c

00004ecc <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, void*)>:
 * @param bitStart First bit position to write (0-7)
 * @param length Number of bits to write (not more than 8)
 * @param data Right-aligned value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data, void *wireObj) {
    4ecc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    // 00011100 mask byte
    // 10101111 original value (sample)
    // 10100011 original & ~mask
    // 10101011 masked | value
    uint8_t b;
    if (readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj) != 0) {
    4ed0:	4c19      	ldr	r4, [pc, #100]	; (4f38 <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, void*)+0x6c>)
 * @param bitStart First bit position to write (0-7)
 * @param length Number of bits to write (not more than 8)
 * @param data Right-aligned value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data, void *wireObj) {
    4ed2:	b085      	sub	sp, #20
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    4ed4:	8824      	ldrh	r4, [r4, #0]
 * @param bitStart First bit position to write (0-7)
 * @param length Number of bits to write (not more than 8)
 * @param data Right-aligned value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data, void *wireObj) {
    4ed6:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    4ed8:	9400      	str	r4, [sp, #0]
 * @param bitStart First bit position to write (0-7)
 * @param length Number of bits to write (not more than 8)
 * @param data Right-aligned value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data, void *wireObj) {
    4eda:	4691      	mov	r9, r2
    4edc:	4698      	mov	r8, r3
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    4ede:	9501      	str	r5, [sp, #4]
    4ee0:	f10d 030e 	add.w	r3, sp, #14
    4ee4:	2201      	movs	r2, #1
 * @param bitStart First bit position to write (0-7)
 * @param length Number of bits to write (not more than 8)
 * @param data Right-aligned value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data, void *wireObj) {
    4ee6:	4606      	mov	r6, r0
    4ee8:	460f      	mov	r7, r1
    4eea:	f89d 4030 	ldrb.w	r4, [sp, #48]	; 0x30
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    4eee:	f7ff fee9 	bl	4cc4 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)>
    // 00011100 mask byte
    // 10101111 original value (sample)
    // 10100011 original & ~mask
    // 10101011 masked | value
    uint8_t b;
    if (readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj) != 0) {
    4ef2:	b1e8      	cbz	r0, 4f30 <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, void*)+0x64>
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
    4ef4:	ebc8 0909 	rsb	r9, r8, r9
    4ef8:	2201      	movs	r2, #1
    4efa:	4491      	add	r9, r2
    4efc:	fa02 f808 	lsl.w	r8, r2, r8
        data <<= (bitStart - length + 1); // shift data into correct position
    4f00:	fa04 f109 	lsl.w	r1, r4, r9
    // 10101111 original value (sample)
    // 10100011 original & ~mask
    // 10101011 masked | value
    uint8_t b;
    if (readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj) != 0) {
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
    4f04:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
        data <<= (bitStart - length + 1); // shift data into correct position
        data &= mask; // zero all non-important bits in data
        b &= ~(mask); // zero all important bits in existing byte
        b |= data; // combine data with existing byte
    4f08:	f89d 400e 	ldrb.w	r4, [sp, #14]
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data, void *wireObj) {
    return writeBytes(devAddr, regAddr, 1, &data, wireObj);
    4f0c:	9500      	str	r5, [sp, #0]
    // 10101111 original value (sample)
    // 10100011 original & ~mask
    // 10101011 masked | value
    uint8_t b;
    if (readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj) != 0) {
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
    4f0e:	fa03 f809 	lsl.w	r8, r3, r9
        data <<= (bitStart - length + 1); // shift data into correct position
    4f12:	b2c9      	uxtb	r1, r1
        data &= mask; // zero all non-important bits in data
        b &= ~(mask); // zero all important bits in existing byte
        b |= data; // combine data with existing byte
    4f14:	ea01 0108 	and.w	r1, r1, r8
    4f18:	ea24 0408 	bic.w	r4, r4, r8
    4f1c:	ab04      	add	r3, sp, #16
    4f1e:	430c      	orrs	r4, r1
    4f20:	f803 4d01 	strb.w	r4, [r3, #-1]!
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data, void *wireObj) {
    return writeBytes(devAddr, regAddr, 1, &data, wireObj);
    4f24:	4639      	mov	r1, r7
    4f26:	4630      	mov	r0, r6
    if (readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj) != 0) {
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
        data <<= (bitStart - length + 1); // shift data into correct position
        data &= mask; // zero all non-important bits in data
        b &= ~(mask); // zero all important bits in existing byte
        b |= data; // combine data with existing byte
    4f28:	f88d 400e 	strb.w	r4, [sp, #14]
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data, void *wireObj) {
    return writeBytes(devAddr, regAddr, 1, &data, wireObj);
    4f2c:	f7ff ff74 	bl	4e18 <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*, void*)>
        b |= data; // combine data with existing byte
        return writeByte(devAddr, regAddr, b, wireObj);
    } else {
        return false;
    }
}
    4f30:	b005      	add	sp, #20
    4f32:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    4f36:	bf00      	nop
    4f38:	1fff081c 	.word	0x1fff081c

00004f3c <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
    4f3c:	2000      	movs	r0, #0
    4f3e:	4770      	bx	lr

00004f40 <TwoWire::peek()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    4f40:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
    4f44:	f890 2039 	ldrb.w	r2, [r0, #57]	; 0x39
    4f48:	429a      	cmp	r2, r3
		return rxBuffer[rxBufferIndex];
    4f4a:	bf86      	itte	hi
    4f4c:	181b      	addhi	r3, r3, r0
    4f4e:	7e18      	ldrbhi	r0, [r3, #24]
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    4f50:	f04f 30ff 	movls.w	r0, #4294967295	; 0xffffffff
		return rxBuffer[rxBufferIndex];
	}
    4f54:	4770      	bx	lr
    4f56:	bf00      	nop

00004f58 <TwoWire::flush()>:
	virtual void flush(void) {
    4f58:	4770      	bx	lr
    4f5a:	bf00      	nop

00004f5c <TwoWire::write(unsigned char const*, unsigned int)>:
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    4f5c:	b538      	push	{r3, r4, r5, lr}
    4f5e:	4605      	mov	r5, r0
	if (transmitting || slave_mode) {
    4f60:	f8b0 005e 	ldrh.w	r0, [r0, #94]	; 0x5e
    4f64:	b190      	cbz	r0, 4f8c <TwoWire::write(unsigned char const*, unsigned int)+0x30>
		size_t avail = BUFFER_LENGTH+1 - txBufferLength;
    4f66:	f895 305d 	ldrb.w	r3, [r5, #93]	; 0x5d
    4f6a:	4614      	mov	r4, r2
    4f6c:	f1c3 0221 	rsb	r2, r3, #33	; 0x21
		if (quantity > avail) {
    4f70:	4294      	cmp	r4, r2
    4f72:	d80c      	bhi.n	4f8e <TwoWire::write(unsigned char const*, unsigned int)+0x32>
			quantity = avail;
			setWriteError();
		}
		memcpy(txBuffer + txBufferLength, data, quantity);
    4f74:	f105 003b 	add.w	r0, r5, #59	; 0x3b
    4f78:	4418      	add	r0, r3
    4f7a:	4622      	mov	r2, r4
    4f7c:	f000 fb1a 	bl	55b4 <memcpy>
		txBufferLength += quantity;
    4f80:	f895 305d 	ldrb.w	r3, [r5, #93]	; 0x5d
    4f84:	4423      	add	r3, r4
    4f86:	f885 305d 	strb.w	r3, [r5, #93]	; 0x5d
    4f8a:	4620      	mov	r0, r4
		return quantity;
	}
	return 0;
}
    4f8c:	bd38      	pop	{r3, r4, r5, pc}
	// format warnings are too pedantic - disable until newer toolchain offers better...
	// https://forum.pjrc.com/threads/62473?p=256873&viewfull=1#post256873
	int printf(const char *format, ...) /*__attribute__ ((format (printf, 2, 3)))*/;
	int printf(const __FlashStringHelper *format, ...);
  protected:
	void setWriteError(int err = 1) { write_error = err; }
    4f8e:	2001      	movs	r0, #1
    4f90:	4614      	mov	r4, r2
    4f92:	7128      	strb	r0, [r5, #4]
    4f94:	e7ee      	b.n	4f74 <TwoWire::write(unsigned char const*, unsigned int)+0x18>
    4f96:	bf00      	nop

00004f98 <TwoWire::write(unsigned char)>:
//  I2C0_C2      // I2C Control Register 2
//  I2C0_FLT     // I2C Programmable Input Glitch Filter register

size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
    4f98:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
    4f9c:	b16b      	cbz	r3, 4fba <TwoWire::write(unsigned char)+0x22>
		if (txBufferLength >= BUFFER_LENGTH+1) {
    4f9e:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
    4fa2:	2b20      	cmp	r3, #32
    4fa4:	d807      	bhi.n	4fb6 <TwoWire::write(unsigned char)+0x1e>
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    4fa6:	18c2      	adds	r2, r0, r3
    4fa8:	3301      	adds	r3, #1
    4faa:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d
		return 1;
    4fae:	2001      	movs	r0, #1
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    4fb0:	f882 103b 	strb.w	r1, [r2, #59]	; 0x3b
    4fb4:	4770      	bx	lr
    4fb6:	2301      	movs	r3, #1
    4fb8:	7103      	strb	r3, [r0, #4]
size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
    4fba:	2000      	movs	r0, #0
    4fbc:	4770      	bx	lr
    4fbe:	bf00      	nop

00004fc0 <TwoWire::isr()>:
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    4fc0:	b538      	push	{r3, r4, r5, lr}
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    4fc2:	6902      	ldr	r2, [r0, #16]
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
    4fc4:	78d4      	ldrb	r4, [r2, #3]
    4fc6:	b2e4      	uxtb	r4, r4
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    4fc8:	06e1      	lsls	r1, r4, #27
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    4fca:	4605      	mov	r5, r0
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    4fcc:	d524      	bpl.n	5018 <TwoWire::isr()+0x58>
		// Arbitration Lost
		port().S = I2C_S_ARBL;
    4fce:	2310      	movs	r3, #16
    4fd0:	70d3      	strb	r3, [r2, #3]
		if (receiving && rxBufferLength > 0) {
			// TODO: does this detect the STOP condition in slave receive mode?


		}
		if (!(status & I2C_S_IAAS)) return;
    4fd2:	0663      	lsls	r3, r4, #25
    4fd4:	d51f      	bpl.n	5016 <TwoWire::isr()+0x56>
	}
	if (status & I2C_S_IAAS) {
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
    4fd6:	f004 0404 	and.w	r4, r4, #4
    4fda:	f004 03ff 	and.w	r3, r4, #255	; 0xff
    4fde:	2c00      	cmp	r4, #0
    4fe0:	d05a      	beq.n	5098 <TwoWire::isr()+0xd8>
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
    4fe2:	4942      	ldr	r1, [pc, #264]	; (50ec <TwoWire::isr()+0x12c>)
			txBufferLength = 0;
			if (user_onRequest != NULL) {
    4fe4:	6e6a      	ldr	r2, [r5, #100]	; 0x64
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
    4fe6:	2300      	movs	r3, #0
    4fe8:	700b      	strb	r3, [r1, #0]
			txBufferLength = 0;
    4fea:	f885 305d 	strb.w	r3, [r5, #93]	; 0x5d
			if (user_onRequest != NULL) {
    4fee:	2a00      	cmp	r2, #0
    4ff0:	d066      	beq.n	50c0 <TwoWire::isr()+0x100>
				user_onRequest();
    4ff2:	4790      	blx	r2
			}
			if (txBufferLength == 0) {
    4ff4:	f895 305d 	ldrb.w	r3, [r5, #93]	; 0x5d
    4ff8:	2b00      	cmp	r3, #0
    4ffa:	d061      	beq.n	50c0 <TwoWire::isr()+0x100>
    4ffc:	692b      	ldr	r3, [r5, #16]
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
				txBuffer[0] = 0;
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    4ffe:	22d0      	movs	r2, #208	; 0xd0
    5000:	709a      	strb	r2, [r3, #2]
    5002:	692b      	ldr	r3, [r5, #16]
			port().D = txBuffer[0];
    5004:	f895 203b 	ldrb.w	r2, [r5, #59]	; 0x3b
    5008:	711a      	strb	r2, [r3, #4]
    500a:	692b      	ldr	r3, [r5, #16]
			txBufferIndex = 1;
    500c:	2201      	movs	r2, #1
    500e:	f885 205c 	strb.w	r2, [r5, #92]	; 0x5c
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    5012:	2202      	movs	r2, #2
    5014:	70da      	strb	r2, [r3, #3]
    5016:	bd38      	pop	{r3, r4, r5, pc}


		}
		if (!(status & I2C_S_IAAS)) return;
	}
	if (status & I2C_S_IAAS) {
    5018:	f004 0340 	and.w	r3, r4, #64	; 0x40
    501c:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    5020:	2b00      	cmp	r3, #0
    5022:	d1d8      	bne.n	4fd6 <TwoWire::isr()+0x16>
		}
		port().S = I2C_S_IICIF;
		return;
	}
	#if defined(WIRE_HAS_STOP_INTERRUPT)
	c1 = port().FLT;
    5024:	7993      	ldrb	r3, [r2, #6]
    5026:	b2db      	uxtb	r3, r3
	if ((c1 & I2C_FLT_STOPF) && (c1 & I2C_FLT_STOPIE)) {
    5028:	f003 0160 	and.w	r1, r3, #96	; 0x60
    502c:	2960      	cmp	r1, #96	; 0x60
    502e:	d04e      	beq.n	50ce <TwoWire::isr()+0x10e>
			rxBufferIndex = 0;
			user_onReceive(rxBufferLength);
		}
	}
	#endif
	c1 = port().C1;
    5030:	7893      	ldrb	r3, [r2, #2]
	if (c1 & I2C_C1_TX) {
    5032:	f003 0310 	and.w	r3, r3, #16
    5036:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    503a:	b1b3      	cbz	r3, 506a <TwoWire::isr()+0xaa>
		// Continue Slave Transmit
		//serial_print("t");
		if ((status & I2C_S_RXAK) == 0) {
    503c:	f014 0401 	ands.w	r4, r4, #1
    5040:	d137      	bne.n	50b2 <TwoWire::isr()+0xf2>
			//serial_print(".");
			// Master ACK'd previous byte
			if (txBufferIndex < txBufferLength) {
    5042:	f895 305c 	ldrb.w	r3, [r5, #92]	; 0x5c
    5046:	f895 105d 	ldrb.w	r1, [r5, #93]	; 0x5d
    504a:	4299      	cmp	r1, r3
    504c:	d94b      	bls.n	50e6 <TwoWire::isr()+0x126>
				port().D = txBuffer[txBufferIndex++];
    504e:	1c59      	adds	r1, r3, #1
    5050:	442b      	add	r3, r5
    5052:	f885 105c 	strb.w	r1, [r5, #92]	; 0x5c
    5056:	f893 303b 	ldrb.w	r3, [r3, #59]	; 0x3b
    505a:	7113      	strb	r3, [r2, #4]
    505c:	692b      	ldr	r3, [r5, #16]
			} else {
				port().D = 0;
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    505e:	22d0      	movs	r2, #208	; 0xd0
    5060:	709a      	strb	r2, [r3, #2]
    5062:	692b      	ldr	r3, [r5, #16]
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    5064:	2202      	movs	r2, #2
    5066:	70da      	strb	r2, [r3, #3]
    5068:	e7d5      	b.n	5016 <TwoWire::isr()+0x56>
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
			data = port().D;
		}
	} else {
		// Continue Slave Receive
		irqcount = 0;
    506a:	f885 1060 	strb.w	r1, [r5, #96]	; 0x60
		#ifdef WIRE_HAS_STOP_INTERRUPT
		port().FLT |= I2C_FLT_STOPIE;
    506e:	7993      	ldrb	r3, [r2, #6]
    5070:	f043 0320 	orr.w	r3, r3, #32
    5074:	7193      	strb	r3, [r2, #6]
    5076:	692b      	ldr	r3, [r5, #16]
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    5078:	f895 1039 	ldrb.w	r1, [r5, #57]	; 0x39
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    507c:	791a      	ldrb	r2, [r3, #4]
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    507e:	291f      	cmp	r1, #31
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    5080:	b2d2      	uxtb	r2, r2
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    5082:	d8c6      	bhi.n	5012 <TwoWire::isr()+0x52>
    5084:	4819      	ldr	r0, [pc, #100]	; (50ec <TwoWire::isr()+0x12c>)
    5086:	7800      	ldrb	r0, [r0, #0]
    5088:	2800      	cmp	r0, #0
    508a:	d0c2      	beq.n	5012 <TwoWire::isr()+0x52>
			rxBuffer[rxBufferLength++] = data;
    508c:	1868      	adds	r0, r5, r1
    508e:	3101      	adds	r1, #1
    5090:	f885 1039 	strb.w	r1, [r5, #57]	; 0x39
    5094:	7602      	strb	r2, [r0, #24]
    5096:	e7bc      	b.n	5012 <TwoWire::isr()+0x52>
    5098:	692a      	ldr	r2, [r5, #16]
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
			rxBufferLength = 0;
    509a:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
    509e:	23c0      	movs	r3, #192	; 0xc0
    50a0:	7093      	strb	r3, [r2, #2]
    50a2:	692b      	ldr	r3, [r5, #16]
			port().D = txBuffer[0];
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
    50a4:	4a11      	ldr	r2, [pc, #68]	; (50ec <TwoWire::isr()+0x12c>)
			rxBufferLength = 0;
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
			data = port().D;
    50a6:	7919      	ldrb	r1, [r3, #4]
			port().D = txBuffer[0];
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
    50a8:	2101      	movs	r1, #1
    50aa:	7011      	strb	r1, [r2, #0]
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    50ac:	2202      	movs	r2, #2
    50ae:	70da      	strb	r2, [r3, #3]
    50b0:	e7b1      	b.n	5016 <TwoWire::isr()+0x56>
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
		} else {
			//serial_print("*");
			// Master did not ACK previous byte
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
    50b2:	23c0      	movs	r3, #192	; 0xc0
    50b4:	7093      	strb	r3, [r2, #2]
    50b6:	692b      	ldr	r3, [r5, #16]
			data = port().D;
    50b8:	791a      	ldrb	r2, [r3, #4]
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    50ba:	2202      	movs	r2, #2
    50bc:	70da      	strb	r2, [r3, #3]
    50be:	e7aa      	b.n	5016 <TwoWire::isr()+0x56>
			}
			if (txBufferLength == 0) {
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
    50c0:	2201      	movs	r2, #1
				txBuffer[0] = 0;
    50c2:	2300      	movs	r3, #0
			}
			if (txBufferLength == 0) {
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
    50c4:	f885 205d 	strb.w	r2, [r5, #93]	; 0x5d
				txBuffer[0] = 0;
    50c8:	f885 303b 	strb.w	r3, [r5, #59]	; 0x3b
    50cc:	e796      	b.n	4ffc <TwoWire::isr()+0x3c>
		return;
	}
	#if defined(WIRE_HAS_STOP_INTERRUPT)
	c1 = port().FLT;
	if ((c1 & I2C_FLT_STOPF) && (c1 & I2C_FLT_STOPIE)) {
		port().FLT = c1 & ~I2C_FLT_STOPIE;
    50ce:	f003 03df 	and.w	r3, r3, #223	; 0xdf
    50d2:	7193      	strb	r3, [r2, #6]
		if (user_onReceive != NULL) {
    50d4:	6eab      	ldr	r3, [r5, #104]	; 0x68
    50d6:	b123      	cbz	r3, 50e2 <TwoWire::isr()+0x122>
			rxBufferIndex = 0;
    50d8:	f885 0038 	strb.w	r0, [r5, #56]	; 0x38
			user_onReceive(rxBufferLength);
    50dc:	f895 0039 	ldrb.w	r0, [r5, #57]	; 0x39
    50e0:	4798      	blx	r3
    50e2:	692a      	ldr	r2, [r5, #16]
    50e4:	e7a4      	b.n	5030 <TwoWire::isr()+0x70>
			//serial_print(".");
			// Master ACK'd previous byte
			if (txBufferIndex < txBufferLength) {
				port().D = txBuffer[txBufferIndex++];
			} else {
				port().D = 0;
    50e6:	7114      	strb	r4, [r2, #4]
    50e8:	e7b8      	b.n	505c <TwoWire::isr()+0x9c>
    50ea:	bf00      	nop
    50ec:	1fff2ae0 	.word	0x1fff2ae0

000050f0 <TwoWire::wait_idle()>:
	}
	return 0;
}

bool TwoWire::wait_idle(void)
{
    50f0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    50f4:	4f37      	ldr	r7, [pc, #220]	; (51d4 <L_1438_delayMicroseconds+0x18>)
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    50f6:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 51d8 <L_1438_delayMicroseconds+0x1c>
    50fa:	683b      	ldr	r3, [r7, #0]
    50fc:	6902      	ldr	r2, [r0, #16]
	}
	return 0;
}

bool TwoWire::wait_idle(void)
{
    50fe:	b082      	sub	sp, #8
    5100:	4606      	mov	r6, r0
    5102:	9300      	str	r3, [sp, #0]
	return ret;
    5104:	f8dd 8000 	ldr.w	r8, [sp]
	bool reset=false;
    5108:	2100      	movs	r1, #0
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    510a:	f44f 7596 	mov.w	r5, #300	; 0x12c
	uint8_t i2c_status(void) {
		return port().S;
    510e:	78d3      	ldrb	r3, [r2, #3]
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    5110:	069b      	lsls	r3, r3, #26
    5112:	d55b      	bpl.n	51cc <L_1438_delayMicroseconds+0x10>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5114:	683b      	ldr	r3, [r7, #0]
    5116:	9301      	str	r3, [sp, #4]
	return ret;
    5118:	9b01      	ldr	r3, [sp, #4]
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
    511a:	ebc8 0303 	rsb	r3, r8, r3
#if 1
		if (waited > 15 && !reset) {
    511e:	2b0f      	cmp	r3, #15
    5120:	d9f5      	bls.n	510e <TwoWire::wait_idle()+0x1e>
    5122:	b149      	cbz	r1, 5138 <TwoWire::wait_idle()+0x48>
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			delayMicroseconds(10);
			continue;
		}
#endif
		if (waited > 16) {
    5124:	2b10      	cmp	r3, #16
    5126:	d0f2      	beq.n	510e <TwoWire::wait_idle()+0x1e>
			// bus stuck busy too long
			port().C1 = 0;
    5128:	2000      	movs	r0, #0
    512a:	7090      	strb	r0, [r2, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    512c:	6933      	ldr	r3, [r6, #16]
			port().C1 = I2C_C1_IICEN;
    512e:	2280      	movs	r2, #128	; 0x80
    5130:	709a      	strb	r2, [r3, #2]
			//return 4; // timeout waiting for bus
			return false;
		}
	}
	return true;
}
    5132:	b002      	add	sp, #8
    5134:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uint32_t waited = millis() - wait_begin;
#if 1
		if (waited > 15 && !reset) {
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
    5138:	6972      	ldr	r2, [r6, #20]
    513a:	f896 3061 	ldrb.w	r3, [r6, #97]	; 0x61
    513e:	4413      	add	r3, r2
			pinMode(sda_pin, INPUT_DISABLE);
    5140:	2105      	movs	r1, #5
    5142:	7a18      	ldrb	r0, [r3, #8]
    5144:	f000 fe1c 	bl	5d80 <pinMode>
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
    5148:	6972      	ldr	r2, [r6, #20]
    514a:	f896 3061 	ldrb.w	r3, [r6, #97]	; 0x61
    514e:	4413      	add	r3, r2
			pinMode(scl_pin, OUTPUT);
    5150:	2101      	movs	r1, #1
		if (waited > 15 && !reset) {
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
    5152:	f893 a012 	ldrb.w	sl, [r3, #18]
			pinMode(scl_pin, OUTPUT);
    5156:	4650      	mov	r0, sl
    5158:	f000 fe12 	bl	5d80 <pinMode>
    515c:	2409      	movs	r4, #9
			for (int i=0; i < 9; i++) {
				digitalWrite(scl_pin, LOW);
    515e:	2100      	movs	r1, #0
    5160:	4650      	mov	r0, sl
    5162:	f000 fe07 	bl	5d74 <digitalWrite>
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    5166:	462b      	mov	r3, r5

00005168 <L_1373_delayMicroseconds>:
    5168:	3b01      	subs	r3, #1
    516a:	d1fd      	bne.n	5168 <L_1373_delayMicroseconds>
				delayMicroseconds(5);
				digitalWrite(scl_pin, HIGH);
    516c:	2101      	movs	r1, #1
    516e:	4650      	mov	r0, sl
    5170:	f000 fe00 	bl	5d74 <digitalWrite>
    5174:	462b      	mov	r3, r5

00005176 <L_1387_delayMicroseconds>:
    5176:	3b01      	subs	r3, #1
    5178:	d1fd      	bne.n	5176 <L_1387_delayMicroseconds>
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
			pinMode(scl_pin, OUTPUT);
			for (int i=0; i < 9; i++) {
    517a:	3c01      	subs	r4, #1
    517c:	d1ef      	bne.n	515e <TwoWire::wait_idle()+0x6e>
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    517e:	6970      	ldr	r0, [r6, #20]
    5180:	f896 1061 	ldrb.w	r1, [r6, #97]	; 0x61
    5184:	4401      	add	r1, r0
    5186:	f44f 7216 	mov.w	r2, #600	; 0x258
    518a:	7a0c      	ldrb	r4, [r1, #8]
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    518c:	7b4b      	ldrb	r3, [r1, #13]
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    518e:	eb09 01c4 	add.w	r1, r9, r4, lsl #3
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    5192:	021b      	lsls	r3, r3, #8
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    5194:	6849      	ldr	r1, [r1, #4]
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    5196:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    519a:	f043 0364 	orr.w	r3, r3, #100	; 0x64
    519e:	600b      	str	r3, [r1, #0]
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    51a0:	f896 3062 	ldrb.w	r3, [r6, #98]	; 0x62
    51a4:	4403      	add	r3, r0
    51a6:	7c99      	ldrb	r1, [r3, #18]
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    51a8:	7ddb      	ldrb	r3, [r3, #23]
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    51aa:	eb09 01c1 	add.w	r1, r9, r1, lsl #3
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    51ae:	021b      	lsls	r3, r3, #8
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    51b0:	6849      	ldr	r1, [r1, #4]
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    51b2:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    51b6:	f043 0364 	orr.w	r3, r3, #100	; 0x64
    51ba:	600b      	str	r3, [r1, #0]

000051bc <L_1438_delayMicroseconds>:
    51bc:	3a01      	subs	r2, #1
    51be:	d1fd      	bne.n	51bc <L_1438_delayMicroseconds>
    51c0:	6932      	ldr	r2, [r6, #16]
	uint8_t i2c_status(void) {
		return port().S;
    51c2:	78d3      	ldrb	r3, [r2, #3]
{
	bool reset=false;
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    51c4:	069b      	lsls	r3, r3, #26
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
#if 1
		if (waited > 15 && !reset) {
			reset = true;
    51c6:	f04f 0101 	mov.w	r1, #1
{
	bool reset=false;
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    51ca:	d4a3      	bmi.n	5114 <TwoWire::wait_idle()+0x24>
			//Serial.println("abort");
			//return 4; // timeout waiting for bus
			return false;
		}
	}
	return true;
    51cc:	2001      	movs	r0, #1
}
    51ce:	b002      	add	sp, #8
    51d0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    51d4:	1fff2ae4 	.word	0x1fff2ae4
    51d8:	00009484 	.word	0x00009484

000051dc <TwoWire::endTransmission(unsigned char)>:

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    51dc:	b5f0      	push	{r4, r5, r6, r7, lr}
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    51de:	6903      	ldr	r3, [r0, #16]
	uint8_t i, status, ret=0;
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    51e0:	2212      	movs	r2, #18
    51e2:	70da      	strb	r2, [r3, #3]
    51e4:	6902      	ldr	r2, [r0, #16]
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    51e6:	7893      	ldrb	r3, [r2, #2]
    51e8:	f003 0320 	and.w	r3, r3, #32
	}
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    51ec:	b085      	sub	sp, #20
    51ee:	4604      	mov	r4, r0
    51f0:	460d      	mov	r5, r1
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    51f2:	2b00      	cmp	r3, #0
    51f4:	d05e      	beq.n	52b4 <TwoWire::endTransmission(unsigned char)+0xd8>
		// we are already the bus master, so send a repeated start
		//Serial.print("rstart:");
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
    51f6:	23b4      	movs	r3, #180	; 0xb4
    51f8:	7093      	strb	r3, [r2, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    51fa:	493c      	ldr	r1, [pc, #240]	; (52ec <TwoWire::endTransmission(unsigned char)+0x110>)
    51fc:	6922      	ldr	r2, [r4, #16]
    51fe:	680b      	ldr	r3, [r1, #0]
    5200:	9300      	str	r3, [sp, #0]
	return ret;
    5202:	9e00      	ldr	r6, [sp, #0]
    5204:	e005      	b.n	5212 <TwoWire::endTransmission(unsigned char)+0x36>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5206:	680b      	ldr	r3, [r1, #0]
    5208:	9301      	str	r3, [sp, #4]
	return ret;
    520a:	9b01      	ldr	r3, [sp, #4]
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		//Serial.write('*') ;
		if (millis() - wait_begin > 4) {
    520c:	1b9b      	subs	r3, r3, r6
    520e:	2b04      	cmp	r3, #4
    5210:	d842      	bhi.n	5298 <TwoWire::endTransmission(unsigned char)+0xbc>
	uint8_t i2c_status(void) {
		return port().S;
    5212:	78d3      	ldrb	r3, [r2, #3]
	}
	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
    5214:	f003 0320 	and.w	r3, r3, #32
    5218:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    521c:	2b00      	cmp	r3, #0
    521e:	d0f2      	beq.n	5206 <TwoWire::endTransmission(unsigned char)+0x2a>
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
    5220:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
    5224:	2b00      	cmp	r3, #0
    5226:	d031      	beq.n	528c <TwoWire::endTransmission(unsigned char)+0xb0>
    5228:	f04f 0e00 	mov.w	lr, #0
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
			}
		}
		port().S = I2C_S_IICIF;
    522c:	f04f 0c02 	mov.w	ip, #2
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
		port().D = txBuffer[i];
    5230:	eb04 030e 	add.w	r3, r4, lr
    5234:	f893 303b 	ldrb.w	r3, [r3, #59]	; 0x3b
    5238:	7113      	strb	r3, [r2, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    523a:	680b      	ldr	r3, [r1, #0]
    523c:	9303      	str	r3, [sp, #12]
	return ret;
    523e:	9f03      	ldr	r7, [sp, #12]
    5240:	6920      	ldr	r0, [r4, #16]
    5242:	e007      	b.n	5254 <TwoWire::endTransmission(unsigned char)+0x78>
		//Serial.write('^');
		wait_begin = millis();
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
    5244:	069b      	lsls	r3, r3, #26
    5246:	d50d      	bpl.n	5264 <TwoWire::endTransmission(unsigned char)+0x88>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5248:	680b      	ldr	r3, [r1, #0]
    524a:	9302      	str	r3, [sp, #8]
	return ret;
    524c:	9b02      	ldr	r3, [sp, #8]
			if (millis() - wait_begin > 5) {
    524e:	1bdb      	subs	r3, r3, r7
    5250:	2b05      	cmp	r3, #5
    5252:	d828      	bhi.n	52a6 <TwoWire::endTransmission(unsigned char)+0xca>
    5254:	78c3      	ldrb	r3, [r0, #3]
    5256:	b2db      	uxtb	r3, r3
		port().D = txBuffer[i];
		//Serial.write('^');
		wait_begin = millis();
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
    5258:	f003 0202 	and.w	r2, r3, #2
    525c:	f002 06ff 	and.w	r6, r2, #255	; 0xff
    5260:	2a00      	cmp	r2, #0
    5262:	d0ef      	beq.n	5244 <TwoWire::endTransmission(unsigned char)+0x68>
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
			}
		}
		port().S = I2C_S_IICIF;
    5264:	f880 c003 	strb.w	ip, [r0, #3]
    5268:	6926      	ldr	r6, [r4, #16]
    526a:	78f3      	ldrb	r3, [r6, #3]
    526c:	b2db      	uxtb	r3, r3
		//Serial.write('$');
		status = i2c_status();
		if ((status & I2C_S_ARBL)) {
    526e:	06df      	lsls	r7, r3, #27
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    5270:	4632      	mov	r2, r6
    5272:	d42d      	bmi.n	52d0 <TwoWire::endTransmission(unsigned char)+0xf4>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("endTransmission err4\n");
			ret = 4; // 4:other error
			break;
		}
		if (!(status & I2C_S_BUSY)) {
    5274:	069f      	lsls	r7, r3, #26
    5276:	d52b      	bpl.n	52d0 <TwoWire::endTransmission(unsigned char)+0xf4>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("endTransmission err5\n");
			ret = 4; // 4:other error
			break;
		}
		if (status & I2C_S_RXAK) {
    5278:	07db      	lsls	r3, r3, #31
    527a:	d431      	bmi.n	52e0 <TwoWire::endTransmission(unsigned char)+0x104>
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
    527c:	f10e 0e01 	add.w	lr, lr, #1
    5280:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
    5284:	fa5f fe8e 	uxtb.w	lr, lr
    5288:	4573      	cmp	r3, lr
    528a:	d8d1      	bhi.n	5230 <TwoWire::endTransmission(unsigned char)+0x54>
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
	uint8_t i, status, ret=0;
    528c:	2000      	movs	r0, #0
			}
			sendStop = 1;
			break;
		}
	}
	if (sendStop) {
    528e:	bb1d      	cbnz	r5, 52d8 <TwoWire::endTransmission(unsigned char)+0xfc>
		// send the stop condition
		port().C1 = I2C_C1_IICEN;
		// TODO: do we wait for this somehow?
	}
	transmitting = 0;
    5290:	2300      	movs	r3, #0
    5292:	f884 305e 	strb.w	r3, [r4, #94]	; 0x5e
    5296:	e004      	b.n	52a2 <TwoWire::endTransmission(unsigned char)+0xc6>
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		//Serial.write('*') ;
		if (millis() - wait_begin > 4) {
			port().C1 = 0;
    5298:	7090      	strb	r0, [r2, #2]
    529a:	6923      	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    529c:	2280      	movs	r2, #128	; 0x80
    529e:	709a      	strb	r2, [r3, #2]
			//Serial.println("abort2");
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
    52a0:	2004      	movs	r0, #4
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    52a2:	b005      	add	sp, #20
    52a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
    52a6:	7086      	strb	r6, [r0, #2]
    52a8:	6923      	ldr	r3, [r4, #16]
				port().C1 = I2C_C1_IICEN;
    52aa:	2280      	movs	r2, #128	; 0x80
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
    52ac:	2004      	movs	r0, #4
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
				port().C1 = I2C_C1_IICEN;
    52ae:	709a      	strb	r2, [r3, #2]
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    52b0:	b005      	add	sp, #20
    52b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    52b4:	f003 06ff 	and.w	r6, r3, #255	; 0xff
		// we are already the bus master, so send a repeated start
		//Serial.print("rstart:");
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
    52b8:	f7ff ff1a 	bl	50f0 <TwoWire::wait_idle()>
    52bc:	b910      	cbnz	r0, 52c4 <TwoWire::endTransmission(unsigned char)+0xe8>
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
    52be:	2004      	movs	r0, #4
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    52c0:	b005      	add	sp, #20
    52c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    52c4:	6923      	ldr	r3, [r4, #16]
		if (!wait_idle()) {
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
    52c6:	f884 605f 	strb.w	r6, [r4, #95]	; 0x5f
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    52ca:	22b0      	movs	r2, #176	; 0xb0
    52cc:	709a      	strb	r2, [r3, #2]
    52ce:	e794      	b.n	51fa <TwoWire::endTransmission(unsigned char)+0x1e>
			ret = 4; // 4:other error
			break;
		}
		if (!(status & I2C_S_BUSY)) {
			// suddenly lost control of the bus!
			port().C1 = I2C_C1_IICEN;
    52d0:	2380      	movs	r3, #128	; 0x80
    52d2:	70b3      	strb	r3, [r6, #2]
			//Serial.printf("endTransmission err5\n");
			ret = 4; // 4:other error
    52d4:	2004      	movs	r0, #4
    52d6:	e7da      	b.n	528e <TwoWire::endTransmission(unsigned char)+0xb2>
    52d8:	6926      	ldr	r6, [r4, #16]
			break;
		}
	}
	if (sendStop) {
		// send the stop condition
		port().C1 = I2C_C1_IICEN;
    52da:	2380      	movs	r3, #128	; 0x80
    52dc:	70b3      	strb	r3, [r6, #2]
    52de:	e7d7      	b.n	5290 <TwoWire::endTransmission(unsigned char)+0xb4>
			if (i == 0) {
				//Serial.printf("endTransmission err6\n");
				ret = 2; // 2:received NACK on transmit of address
			} else {
				//Serial.printf("endTransmission err7\n");
				ret = 3; // 3:received NACK on transmit of data 
    52e0:	f1be 0f00 	cmp.w	lr, #0
    52e4:	bf0c      	ite	eq
    52e6:	2002      	moveq	r0, #2
    52e8:	2003      	movne	r0, #3
    52ea:	e7f6      	b.n	52da <TwoWire::endTransmission(unsigned char)+0xfe>
    52ec:	1fff2ae4 	.word	0x1fff2ae4

000052f0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>:
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    52f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    52f4:	6906      	ldr	r6, [r0, #16]
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
	uint32_t wait_begin;

	rxBufferIndex = 0;
    52f6:	2500      	movs	r5, #0
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    52f8:	2712      	movs	r7, #18
{
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
	uint32_t wait_begin;

	rxBufferIndex = 0;
    52fa:	f880 5038 	strb.w	r5, [r0, #56]	; 0x38
	rxBufferLength = 0;
    52fe:	f880 5039 	strb.w	r5, [r0, #57]	; 0x39
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    5302:	70f7      	strb	r7, [r6, #3]
    5304:	f8d0 c010 	ldr.w	ip, [r0, #16]
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    5308:	f89c e002 	ldrb.w	lr, [ip, #2]
    530c:	f00e 0e20 	and.w	lr, lr, #32
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    5310:	b088      	sub	sp, #32
    5312:	4604      	mov	r4, r0
    5314:	4688      	mov	r8, r1
    5316:	4615      	mov	r5, r2
    5318:	461e      	mov	r6, r3
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    531a:	f1be 0f00 	cmp.w	lr, #0
    531e:	d049      	beq.n	53b4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xc4>
		// we are already the bus master, so send a repeated start
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
    5320:	23b4      	movs	r3, #180	; 0xb4
    5322:	f88c 3002 	strb.w	r3, [ip, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5326:	4b7a      	ldr	r3, [pc, #488]	; (5510 <L_2952_delayMicroseconds+0x1e>)
    5328:	6921      	ldr	r1, [r4, #16]
    532a:	681a      	ldr	r2, [r3, #0]
    532c:	9200      	str	r2, [sp, #0]
	return ret;
    532e:	f8dd e000 	ldr.w	lr, [sp]
    5332:	e006      	b.n	5342 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x52>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5334:	681a      	ldr	r2, [r3, #0]
    5336:	9201      	str	r2, [sp, #4]
	return ret;
    5338:	9801      	ldr	r0, [sp, #4]
	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		if (millis() - wait_begin > 4) {
    533a:	ebce 0000 	rsb	r0, lr, r0
    533e:	2804      	cmp	r0, #4
    5340:	d830      	bhi.n	53a4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xb4>
	uint8_t i2c_status(void) {
		return port().S;
    5342:	78c8      	ldrb	r0, [r1, #3]
    5344:	f000 0020 	and.w	r0, r0, #32

	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
    5348:	f000 07ff 	and.w	r7, r0, #255	; 0xff
    534c:	2800      	cmp	r0, #0
    534e:	d0f1      	beq.n	5334 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x44>
			//Serial.printf("requestFrom err2\n");
			return 0; // error generating start condition
		}
	}
	// send the address
	port().D = (address << 1) | 1;
    5350:	ea4f 0248 	mov.w	r2, r8, lsl #1
    5354:	f042 0201 	orr.w	r2, r2, #1
    5358:	b2d2      	uxtb	r2, r2
    535a:	710a      	strb	r2, [r1, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    535c:	681a      	ldr	r2, [r3, #0]
    535e:	9202      	str	r2, [sp, #8]
	return ret;
    5360:	f8dd e008 	ldr.w	lr, [sp, #8]
    5364:	6920      	ldr	r0, [r4, #16]
    5366:	e006      	b.n	5376 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x86>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5368:	681a      	ldr	r2, [r3, #0]
    536a:	9203      	str	r2, [sp, #12]
	return ret;
    536c:	9903      	ldr	r1, [sp, #12]
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
    536e:	ebce 0101 	rsb	r1, lr, r1
    5372:	2905      	cmp	r1, #5
    5374:	d82a      	bhi.n	53cc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xdc>
		}
	}
	// send the address
	port().D = (address << 1) | 1;
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
    5376:	78c1      	ldrb	r1, [r0, #3]
    5378:	f001 0102 	and.w	r1, r1, #2
    537c:	f001 07ff 	and.w	r7, r1, #255	; 0xff
    5380:	2900      	cmp	r1, #0
    5382:	d0f1      	beq.n	5368 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x78>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("requestFrom err3\n");
			return 0; // clock stretch too long (during address)
		}
	}
	port().S = I2C_S_IICIF;
    5384:	f04f 0c02 	mov.w	ip, #2
    5388:	f880 c003 	strb.w	ip, [r0, #3]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    538c:	6922      	ldr	r2, [r4, #16]
	uint8_t i2c_status(void) {
		return port().S;
    538e:	78d1      	ldrb	r1, [r2, #3]
	status = i2c_status();
	if ((status & I2C_S_RXAK) || (status & I2C_S_ARBL)) {
    5390:	f011 0711 	ands.w	r7, r1, #17
    5394:	d122      	bne.n	53dc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xec>
		// or we lost bus arbitration to another master
		port().C1 = I2C_C1_IICEN;
		//Serial.printf("requestFrom err4\n");
		return 0;
	}
	if (length == 0) {
    5396:	bb2d      	cbnz	r5, 53e4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf4>
		// TODO: does anybody really do zero length reads?
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
    5398:	2e00      	cmp	r6, #0
    539a:	bf0c      	ite	eq
    539c:	23a0      	moveq	r3, #160	; 0xa0
    539e:	2380      	movne	r3, #128	; 0x80
    53a0:	7093      	strb	r3, [r2, #2]
		//Serial.printf("requestFrom err5\n");
		return 0;
    53a2:	e003      	b.n	53ac <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		if (millis() - wait_begin > 4) {
			port().C1 = 0;
    53a4:	708f      	strb	r7, [r1, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    53a6:	6923      	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    53a8:	2280      	movs	r2, #128	; 0x80
    53aa:	709a      	strb	r2, [r3, #2]
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
	rxBufferLength = count;
	return count;
}
    53ac:	4638      	mov	r0, r7
    53ae:	b008      	add	sp, #32
    53b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    53b4:	f00e 07ff 	and.w	r7, lr, #255	; 0xff
	if (port().C1 & I2C_C1_MST) {
		// we are already the bus master, so send a repeated start
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
    53b8:	f7ff fe9a 	bl	50f0 <TwoWire::wait_idle()>
    53bc:	2800      	cmp	r0, #0
    53be:	d0f5      	beq.n	53ac <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
    53c0:	6923      	ldr	r3, [r4, #16]
			//Serial.printf("requestFrom err1\n");
			return 0; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
    53c2:	f884 705f 	strb.w	r7, [r4, #95]	; 0x5f
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    53c6:	22b0      	movs	r2, #176	; 0xb0
    53c8:	709a      	strb	r2, [r3, #2]
    53ca:	e7ac      	b.n	5326 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x36>
	// send the address
	port().D = (address << 1) | 1;
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
    53cc:	7087      	strb	r7, [r0, #2]
    53ce:	6923      	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    53d0:	2280      	movs	r2, #128	; 0x80
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
	rxBufferLength = count;
	return count;
}
    53d2:	4638      	mov	r0, r7
	port().D = (address << 1) | 1;
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
    53d4:	709a      	strb	r2, [r3, #2]
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
	rxBufferLength = count;
	return count;
}
    53d6:	b008      	add	sp, #32
    53d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	port().S = I2C_S_IICIF;
	status = i2c_status();
	if ((status & I2C_S_RXAK) || (status & I2C_S_ARBL)) {
		// the slave device did not acknowledge
		// or we lost bus arbitration to another master
		port().C1 = I2C_C1_IICEN;
    53dc:	2380      	movs	r3, #128	; 0x80
    53de:	7093      	strb	r3, [r2, #2]
		//Serial.printf("requestFrom err4\n");
		return 0;
    53e0:	2700      	movs	r7, #0
    53e2:	e7e3      	b.n	53ac <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
		// TODO: does anybody really do zero length reads?
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
		//Serial.printf("requestFrom err5\n");
		return 0;
	} else if (length == 1) {
    53e4:	2d01      	cmp	r5, #1
    53e6:	d078      	beq.n	54da <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1ea>
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
    53e8:	21a0      	movs	r1, #160	; 0xa0
    53ea:	7091      	strb	r1, [r2, #2]
    53ec:	6921      	ldr	r1, [r4, #16]
	}
	tmp = port().D; // initiate the first receive
    53ee:	790a      	ldrb	r2, [r1, #4]
    53f0:	46be      	mov	lr, r7
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
    53f2:	4667      	mov	r7, ip
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    53f4:	f04f 0ca8 	mov.w	ip, #168	; 0xa8
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    53f8:	681a      	ldr	r2, [r3, #0]
    53fa:	9204      	str	r2, [sp, #16]
	return ret;
    53fc:	9804      	ldr	r0, [sp, #16]
    53fe:	e005      	b.n	540c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x11c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5400:	681a      	ldr	r2, [r3, #0]
    5402:	9205      	str	r2, [sp, #20]
	return ret;
    5404:	9a05      	ldr	r2, [sp, #20]
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
			if (millis() - wait_begin > 5) {
    5406:	1a12      	subs	r2, r2, r0
    5408:	2a05      	cmp	r2, #5
    540a:	d84d      	bhi.n	54a8 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1b8>
	}
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
    540c:	78ca      	ldrb	r2, [r1, #3]
    540e:	f002 0202 	and.w	r2, r2, #2
    5412:	f002 08ff 	and.w	r8, r2, #255	; 0xff
    5416:	2a00      	cmp	r2, #0
    5418:	d0f2      	beq.n	5400 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x110>
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
    541a:	70cf      	strb	r7, [r1, #3]
    541c:	6921      	ldr	r1, [r4, #16]
		status = port().S;
    541e:	78ca      	ldrb	r2, [r1, #3]
    5420:	b2d2      	uxtb	r2, r2
		if ((status & I2C_S_ARBL)) {
    5422:	f012 0f10 	tst.w	r2, #16
    5426:	4608      	mov	r0, r1
    5428:	d15d      	bne.n	54e6 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f6>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7a\n");
			return count;
		}
		if (!(status & I2C_S_BUSY)) {
    542a:	0692      	lsls	r2, r2, #26
    542c:	d55b      	bpl.n	54e6 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f6>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
    542e:	3d01      	subs	r5, #1
    5430:	b2ed      	uxtb	r5, r5
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    5432:	2d01      	cmp	r5, #1
    5434:	d04c      	beq.n	54d0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1e0>
		if (count < BUFFER_LENGTH) {
    5436:	f1be 0f1f 	cmp.w	lr, #31
    543a:	d93e      	bls.n	54ba <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1ca>
			rxBuffer[count++] = port().D;
		} else {
			tmp = port().D;
    543c:	790a      	ldrb	r2, [r1, #4]
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
	}
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
    543e:	2d01      	cmp	r5, #1
    5440:	d1da      	bne.n	53f8 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x108>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5442:	681a      	ldr	r2, [r3, #0]
    5444:	9206      	str	r2, [sp, #24]
	return ret;
    5446:	9d06      	ldr	r5, [sp, #24]
    5448:	e005      	b.n	5456 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x166>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    544a:	681a      	ldr	r2, [r3, #0]
    544c:	9207      	str	r2, [sp, #28]
	return ret;
    544e:	9a07      	ldr	r2, [sp, #28]
			tmp = port().D;
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
    5450:	1b52      	subs	r2, r2, r5
    5452:	2a05      	cmp	r2, #5
    5454:	d856      	bhi.n	5504 <L_2952_delayMicroseconds+0x12>
		} else {
			tmp = port().D;
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
    5456:	78c2      	ldrb	r2, [r0, #3]
    5458:	f002 0202 	and.w	r2, r2, #2
    545c:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    5460:	2a00      	cmp	r2, #0
    5462:	d0f2      	beq.n	544a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x15a>
			rxBufferLength = count;
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
		}
	}
	port().S = I2C_S_IICIF;
    5464:	2302      	movs	r3, #2
    5466:	70c3      	strb	r3, [r0, #3]
    5468:	6922      	ldr	r2, [r4, #16]
	status = port().S;
    546a:	78d3      	ldrb	r3, [r2, #3]
    546c:	b2db      	uxtb	r3, r3
	if ((status & I2C_S_ARBL)) {
    546e:	06d9      	lsls	r1, r3, #27
    5470:	d43b      	bmi.n	54ea <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1fa>
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
		//Serial.printf("requestFrom err9a\n");
		return count;
	}
	if (!(status & I2C_S_BUSY)) {
    5472:	069b      	lsls	r3, r3, #26
    5474:	d537      	bpl.n	54e6 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f6>
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//Serial.printf("requestFrom err9b\n");
		return count;
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    5476:	23b0      	movs	r3, #176	; 0xb0
	if (count < BUFFER_LENGTH) {
    5478:	f1be 0f1f 	cmp.w	lr, #31
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//Serial.printf("requestFrom err9b\n");
		return count;
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    547c:	7093      	strb	r3, [r2, #2]
	if (count < BUFFER_LENGTH) {
    547e:	d843      	bhi.n	5508 <L_2952_delayMicroseconds+0x16>
    5480:	6922      	ldr	r2, [r4, #16]
		rxBuffer[count++] = port().D;
    5482:	eb04 030e 	add.w	r3, r4, lr
    5486:	7912      	ldrb	r2, [r2, #4]
    5488:	761a      	strb	r2, [r3, #24]
    548a:	f10e 0e01 	add.w	lr, lr, #1
    548e:	fa5f fe8e 	uxtb.w	lr, lr
	} else {
		tmp = port().D;
	}
#if F_CPU > 120000000
	__asm__("nop");
    5492:	bf00      	nop
	__asm__("nop");
    5494:	bf00      	nop
	__asm__("nop");
    5496:	bf00      	nop
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
    5498:	b116      	cbz	r6, 54a0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1b0>
    549a:	6923      	ldr	r3, [r4, #16]
    549c:	2280      	movs	r2, #128	; 0x80
    549e:	709a      	strb	r2, [r3, #2]
	rxBufferLength = count;
    54a0:	f884 e039 	strb.w	lr, [r4, #57]	; 0x39
	return count;
    54a4:	4677      	mov	r7, lr
    54a6:	e781      	b.n	53ac <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
    54a8:	f881 8002 	strb.w	r8, [r1, #2]
    54ac:	6923      	ldr	r3, [r4, #16]
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
    54ae:	2280      	movs	r2, #128	; 0x80
    54b0:	709a      	strb	r2, [r3, #2]
			rxBufferLength = count;
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
    54b2:	4677      	mov	r7, lr
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
			rxBufferLength = count;
    54b4:	f884 e039 	strb.w	lr, [r4, #57]	; 0x39
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
    54b8:	e778      	b.n	53ac <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
		if (count < BUFFER_LENGTH) {
			rxBuffer[count++] = port().D;
    54ba:	eb04 020e 	add.w	r2, r4, lr
    54be:	f891 8004 	ldrb.w	r8, [r1, #4]
    54c2:	f882 8018 	strb.w	r8, [r2, #24]
    54c6:	f10e 0e01 	add.w	lr, lr, #1
    54ca:	fa5f fe8e 	uxtb.w	lr, lr
    54ce:	e7b6      	b.n	543e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x14e>
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    54d0:	f881 c002 	strb.w	ip, [r1, #2]
    54d4:	6921      	ldr	r1, [r4, #16]
    54d6:	4608      	mov	r0, r1
    54d8:	e7ad      	b.n	5436 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x146>
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
		//Serial.printf("requestFrom err5\n");
		return 0;
	} else if (length == 1) {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    54da:	21a8      	movs	r1, #168	; 0xa8
    54dc:	7091      	strb	r1, [r2, #2]
    54de:	6920      	ldr	r0, [r4, #16]


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
    54e0:	46be      	mov	lr, r7
	} else if (length == 1) {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
	}
	tmp = port().D; // initiate the first receive
    54e2:	7902      	ldrb	r2, [r0, #4]
    54e4:	e7ad      	b.n	5442 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x152>
    54e6:	4677      	mov	r7, lr
    54e8:	e760      	b.n	53ac <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
	if ((status & I2C_S_ARBL)) {
		// we lost bus arbitration to another master
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//digitalWriteFast(13, HIGH);
		port().S = I2C_S_ARBL;
    54ea:	2110      	movs	r1, #16
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    54ec:	f44f 7396 	mov.w	r3, #300	; 0x12c
    54f0:	70d1      	strb	r1, [r2, #3]

000054f2 <L_2952_delayMicroseconds>:
    54f2:	3b01      	subs	r3, #1
    54f4:	d1fd      	bne.n	54f2 <L_2952_delayMicroseconds>
    54f6:	6922      	ldr	r2, [r4, #16]
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
    54f8:	7893      	ldrb	r3, [r2, #2]
    54fa:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		//Serial.printf("requestFrom err9a\n");
		return count;
    54fe:	4677      	mov	r7, lr
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//digitalWriteFast(13, HIGH);
		port().S = I2C_S_ARBL;
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
    5500:	7093      	strb	r3, [r2, #2]
		//Serial.printf("requestFrom err9a\n");
		return count;
    5502:	e753      	b.n	53ac <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
    5504:	7081      	strb	r1, [r0, #2]
    5506:	e7d1      	b.n	54ac <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1bc>
    5508:	6923      	ldr	r3, [r4, #16]
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
	if (count < BUFFER_LENGTH) {
		rxBuffer[count++] = port().D;
	} else {
		tmp = port().D;
    550a:	791b      	ldrb	r3, [r3, #4]
    550c:	e7c1      	b.n	5492 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1a2>
    550e:	bf00      	nop
    5510:	1fff2ae4 	.word	0x1fff2ae4

00005514 <i2c0_isr>:
#define MAKE_CONST(x) (__builtin_constant_p(x) ? (x) : (x))

#ifdef WIRE_IMPLEMENT_WIRE
constexpr uintptr_t i2c0_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C0));
TwoWire Wire(i2c0_addr, TwoWire::i2c0_hardware);
void i2c0_isr(void) { Wire.isr(); }
    5514:	4801      	ldr	r0, [pc, #4]	; (551c <i2c0_isr+0x8>)
    5516:	f7ff bd53 	b.w	4fc0 <TwoWire::isr()>
    551a:	bf00      	nop
    551c:	1fff088c 	.word	0x1fff088c

00005520 <i2c1_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE1
constexpr uintptr_t i2c1_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C1));
TwoWire Wire1(i2c1_addr, TwoWire::i2c1_hardware);
void i2c1_isr(void) { Wire1.isr(); }
    5520:	4801      	ldr	r0, [pc, #4]	; (5528 <i2c1_isr+0x8>)
    5522:	f7ff bd4d 	b.w	4fc0 <TwoWire::isr()>
    5526:	bf00      	nop
    5528:	1fff08f8 	.word	0x1fff08f8

0000552c <i2c2_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE2
constexpr uintptr_t i2c2_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C2));
TwoWire Wire2(i2c2_addr, TwoWire::i2c2_hardware);
void i2c2_isr(void) { Wire2.isr(); }
    552c:	4801      	ldr	r0, [pc, #4]	; (5534 <i2c2_isr+0x8>)
    552e:	f7ff bd47 	b.w	4fc0 <TwoWire::isr()>
    5532:	bf00      	nop
    5534:	1fff0820 	.word	0x1fff0820

00005538 <MPU9250::MPU9250()>:

/** Default constructor, uses default I2C address.
 * @see MPU9250_DEFAULT_ADDRESS
 */
MPU9250::MPU9250() {
    devAddr = MPU9250_DEFAULT_ADDRESS;
    5538:	2368      	movs	r3, #104	; 0x68
    553a:	7003      	strb	r3, [r0, #0]
}
    553c:	4770      	bx	lr
    553e:	bf00      	nop

00005540 <MPU9250::initialize()>:
 * after start-up). This function also sets both the accelerometer and the gyroscope
 * to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets
 * the clock source to use the X Gyro for reference, which is slightly better than
 * the default internal clock source.
 */
void MPU9250::initialize() {
    5540:	b530      	push	{r4, r5, lr}
    5542:	b083      	sub	sp, #12
 * @see getSleepEnabled()
 * @see MPU9250_RA_PWR_MGMT_1
 * @see MPU9250_PWR1_SLEEP_BIT
 */
void MPU9250::setSleepEnabled(bool enabled) {
    I2Cdev::writeBit(devAddr, MPU9250_RA_PWR_MGMT_1, MPU9250_PWR1_SLEEP_BIT, enabled);
    5544:	2400      	movs	r4, #0
 * after start-up). This function also sets both the accelerometer and the gyroscope
 * to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets
 * the clock source to use the X Gyro for reference, which is slightly better than
 * the default internal clock source.
 */
void MPU9250::initialize() {
    5546:	4605      	mov	r5, r0
 * @see getSleepEnabled()
 * @see MPU9250_RA_PWR_MGMT_1
 * @see MPU9250_PWR1_SLEEP_BIT
 */
void MPU9250::setSleepEnabled(bool enabled) {
    I2Cdev::writeBit(devAddr, MPU9250_RA_PWR_MGMT_1, MPU9250_PWR1_SLEEP_BIT, enabled);
    5548:	4623      	mov	r3, r4
    554a:	7800      	ldrb	r0, [r0, #0]
    554c:	9400      	str	r4, [sp, #0]
    554e:	2206      	movs	r2, #6
    5550:	216b      	movs	r1, #107	; 0x6b
    5552:	f7ff fc8d 	bl	4e70 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char, void*)>
 * @see MPU9250_RA_PWR_MGMT_1
 * @see MPU9250_PWR1_CLKSEL_BIT
 * @see MPU9250_PWR1_CLKSEL_LENGTH
 */
void MPU9250::setClockSource(uint8_t source) {
    I2Cdev::writeBits(devAddr, MPU9250_RA_PWR_MGMT_1, MPU9250_PWR1_CLKSEL_BIT, MPU9250_PWR1_CLKSEL_LENGTH, source);
    5556:	2301      	movs	r3, #1
    5558:	7828      	ldrb	r0, [r5, #0]
    555a:	9300      	str	r3, [sp, #0]
    555c:	9401      	str	r4, [sp, #4]
    555e:	2303      	movs	r3, #3
    5560:	2202      	movs	r2, #2
    5562:	216b      	movs	r1, #107	; 0x6b
    5564:	f7ff fcb2 	bl	4ecc <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, void*)>
 * @see MPU9250_RA_GYRO_CONFIG
 * @see MPU9250_GCONFIG_FS_SEL_BIT
 * @see MPU9250_GCONFIG_FS_SEL_LENGTH
 */
void MPU9250::setFullScaleGyroRange(uint8_t range) {
    I2Cdev::writeBits(devAddr, MPU9250_RA_GYRO_CONFIG, MPU9250_GCONFIG_FS_SEL_BIT, MPU9250_GCONFIG_FS_SEL_LENGTH, range);
    5568:	7828      	ldrb	r0, [r5, #0]
    556a:	9401      	str	r4, [sp, #4]
    556c:	9400      	str	r4, [sp, #0]
    556e:	2302      	movs	r3, #2
    5570:	2204      	movs	r2, #4
    5572:	211b      	movs	r1, #27
    5574:	f7ff fcaa 	bl	4ecc <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, void*)>
/** Set full-scale accelerometer range.
 * @param range New full-scale accelerometer range setting
 * @see getFullScaleAccelRange()
 */
void MPU9250::setFullScaleAccelRange(uint8_t range) {
    I2Cdev::writeBits(devAddr, MPU9250_RA_ACCEL_CONFIG, MPU9250_ACONFIG_AFS_SEL_BIT, MPU9250_ACONFIG_AFS_SEL_LENGTH, range);
    5578:	7828      	ldrb	r0, [r5, #0]
    557a:	9401      	str	r4, [sp, #4]
    557c:	9400      	str	r4, [sp, #0]
    557e:	2302      	movs	r3, #2
    5580:	2204      	movs	r2, #4
    5582:	211c      	movs	r1, #28
    5584:	f7ff fca2 	bl	4ecc <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, void*)>
void MPU9250::initialize() {
    setSleepEnabled(false); // thanks to Jack Elston for pointing this one out!
    setClockSource(MPU9250_CLOCK_PLL_XGYRO);
    setFullScaleGyroRange(MPU9250_GYRO_FS_250);
    setFullScaleAccelRange(MPU9250_ACCEL_FS_2);
}
    5588:	b003      	add	sp, #12
    558a:	bd30      	pop	{r4, r5, pc}

0000558c <ros::normalizeSecNSec(unsigned long&, unsigned long&)>:
#include "ros/time.h"

namespace ros
{
void normalizeSecNSec(uint32_t& sec, uint32_t& nsec)
{
    558c:	b470      	push	{r4, r5, r6}
  uint32_t nsec_part = nsec % 1000000000UL;
    558e:	680d      	ldr	r5, [r1, #0]
  uint32_t sec_part = nsec / 1000000000UL;
  sec += sec_part;
    5590:	4b06      	ldr	r3, [pc, #24]	; (55ac <ros::normalizeSecNSec(unsigned long&, unsigned long&)+0x20>)
    5592:	6804      	ldr	r4, [r0, #0]
  nsec = nsec_part;
    5594:	4e06      	ldr	r6, [pc, #24]	; (55b0 <ros::normalizeSecNSec(unsigned long&, unsigned long&)+0x24>)
{
void normalizeSecNSec(uint32_t& sec, uint32_t& nsec)
{
  uint32_t nsec_part = nsec % 1000000000UL;
  uint32_t sec_part = nsec / 1000000000UL;
  sec += sec_part;
    5596:	0a6a      	lsrs	r2, r5, #9
    5598:	fba3 3202 	umull	r3, r2, r3, r2
    559c:	09d3      	lsrs	r3, r2, #7
    559e:	441c      	add	r4, r3
  nsec = nsec_part;
    55a0:	fb06 5313 	mls	r3, r6, r3, r5
{
void normalizeSecNSec(uint32_t& sec, uint32_t& nsec)
{
  uint32_t nsec_part = nsec % 1000000000UL;
  uint32_t sec_part = nsec / 1000000000UL;
  sec += sec_part;
    55a4:	6004      	str	r4, [r0, #0]
  nsec = nsec_part;
    55a6:	600b      	str	r3, [r1, #0]
}
    55a8:	bc70      	pop	{r4, r5, r6}
    55aa:	4770      	bx	lr
    55ac:	00044b83 	.word	0x00044b83
    55b0:	3b9aca00 	.word	0x3b9aca00

000055b4 <memcpy>:
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
#else
	push	{r0}
    55b4:	b401      	push	{r0}
#endif
	orr	r3, r1, r0
    55b6:	ea41 0300 	orr.w	r3, r1, r0
	ands	r3, r3, #3
    55ba:	f013 0303 	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    55be:	d16f      	bne.n	56a0 <memcpy+0xec>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    55c0:	3a40      	subs	r2, #64	; 0x40
	blo	.Lmid_block
    55c2:	d341      	bcc.n	5648 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    55c4:	f851 3b04 	ldr.w	r3, [r1], #4
    55c8:	f840 3b04 	str.w	r3, [r0], #4
    55cc:	f851 3b04 	ldr.w	r3, [r1], #4
    55d0:	f840 3b04 	str.w	r3, [r0], #4
    55d4:	f851 3b04 	ldr.w	r3, [r1], #4
    55d8:	f840 3b04 	str.w	r3, [r0], #4
    55dc:	f851 3b04 	ldr.w	r3, [r1], #4
    55e0:	f840 3b04 	str.w	r3, [r0], #4
    55e4:	f851 3b04 	ldr.w	r3, [r1], #4
    55e8:	f840 3b04 	str.w	r3, [r0], #4
    55ec:	f851 3b04 	ldr.w	r3, [r1], #4
    55f0:	f840 3b04 	str.w	r3, [r0], #4
    55f4:	f851 3b04 	ldr.w	r3, [r1], #4
    55f8:	f840 3b04 	str.w	r3, [r0], #4
    55fc:	f851 3b04 	ldr.w	r3, [r1], #4
    5600:	f840 3b04 	str.w	r3, [r0], #4
    5604:	f851 3b04 	ldr.w	r3, [r1], #4
    5608:	f840 3b04 	str.w	r3, [r0], #4
    560c:	f851 3b04 	ldr.w	r3, [r1], #4
    5610:	f840 3b04 	str.w	r3, [r0], #4
    5614:	f851 3b04 	ldr.w	r3, [r1], #4
    5618:	f840 3b04 	str.w	r3, [r0], #4
    561c:	f851 3b04 	ldr.w	r3, [r1], #4
    5620:	f840 3b04 	str.w	r3, [r0], #4
    5624:	f851 3b04 	ldr.w	r3, [r1], #4
    5628:	f840 3b04 	str.w	r3, [r0], #4
    562c:	f851 3b04 	ldr.w	r3, [r1], #4
    5630:	f840 3b04 	str.w	r3, [r0], #4
    5634:	f851 3b04 	ldr.w	r3, [r1], #4
    5638:	f840 3b04 	str.w	r3, [r0], #4
    563c:	f851 3b04 	ldr.w	r3, [r1], #4
    5640:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    5644:	3a40      	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    5646:	d2bd      	bcs.n	55c4 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    5648:	3230      	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    564a:	d311      	bcc.n	5670 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    564c:	f851 3b04 	ldr.w	r3, [r1], #4
    5650:	f840 3b04 	str.w	r3, [r0], #4
    5654:	f851 3b04 	ldr.w	r3, [r1], #4
    5658:	f840 3b04 	str.w	r3, [r0], #4
    565c:	f851 3b04 	ldr.w	r3, [r1], #4
    5660:	f840 3b04 	str.w	r3, [r0], #4
    5664:	f851 3b04 	ldr.w	r3, [r1], #4
    5668:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    566c:	3a10      	subs	r2, #16
	bhs	.Lmid_block_loop
    566e:	d2ed      	bcs.n	564c <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    5670:	320c      	adds	r2, #12
	blo	.Lcopy_less_than_4
    5672:	d305      	bcc.n	5680 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    5674:	f851 3b04 	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    5678:	f840 3b04 	str.w	r3, [r0], #4
	subs	r2, #4
    567c:	3a04      	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    567e:	d2f9      	bcs.n	5674 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    5680:	3204      	adds	r2, #4
	beq	.Ldone
    5682:	d00a      	beq.n	569a <memcpy+0xe6>

	lsls	r2, r2, #31
    5684:	07d2      	lsls	r2, r2, #31
	itt ne
    5686:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    5688:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    568c:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc	.Ldone
    5690:	d303      	bcc.n	569a <memcpy+0xe6>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
	strh	r3, [r0]
#else
	ldrb	r3, [r1]
    5692:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    5694:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    5696:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    5698:	7043      	strb	r3, [r0, #1]

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    569a:	bc01      	pop	{r0}
#endif
	bx	lr
    569c:	4770      	bx	lr
    569e:	bf00      	nop
	beq	.Ldst_aligned
#else
	/* if len < 12, misalignment adjustment has more overhead than
	just byte-to-byte copy.  Also, len must >=8 to guarantee code
	afterward work correctly.  */
	cmp	r2, #12
    56a0:	2a0c      	cmp	r2, #12
	blo	.Lbyte_copy
    56a2:	d34a      	bcc.n	573a <memcpy+0x186>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    56a4:	f010 0303 	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    56a8:	d011      	beq.n	56ce <memcpy+0x11a>

	rsb	r3, #4
    56aa:	f1c3 0304 	rsb	r3, r3, #4
	subs	r2, r3
    56ae:	1ad2      	subs	r2, r2, r3

	lsls    r3, r3, #31
    56b0:	07db      	lsls	r3, r3, #31
	itt ne
    56b2:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    56b4:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    56b8:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    56bc:	d307      	bcc.n	56ce <memcpy+0x11a>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
	strh    r3, [r0], #2
	b	.Ldst_aligned
#else
	ldrb    r3, [r1], #1
    56be:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    56c2:	f800 3b01 	strb.w	r3, [r0], #1
	ldrb    r3, [r1], #1
    56c6:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    56ca:	f800 3b01 	strb.w	r3, [r0], #1
	/* Now that dst is aligned */
.Ldst_aligned:
	/* if r1 is aligned now, it means r0/r1 has the same misalignment,
	and they are both aligned now.  Go aligned copy.  */
	ands	r3, r1, #3
    56ce:	f011 0303 	ands.w	r3, r1, #3
	beq	.Lbig_block
    56d2:	f43f af75 	beq.w	55c0 <memcpy+0xc>

	/* dst is aligned, but src isn't.  Misaligned copy.  */

	push	{r4, r5}
    56d6:	b430      	push	{r4, r5}
	subs	r2, #4
    56d8:	3a04      	subs	r2, #4

	/* Backward r1 by misaligned bytes, to make r1 aligned.
	Since we need to restore r1 to unaligned address after the loop,
	we need keep the offset bytes to ip and sub it from r1 afterward.  */
	subs	r1, r3
    56da:	1ac9      	subs	r1, r1, r3
	rsb	ip, r3, #4
    56dc:	f1c3 0c04 	rsb	ip, r3, #4

	/* Pre-load on word */
	ldr	r4, [r1], #4
    56e0:	f851 4b04 	ldr.w	r4, [r1], #4

	cmp	r3, #2
    56e4:	2b02      	cmp	r3, #2
	beq	.Lmisaligned_copy_2_2
    56e6:	d019      	beq.n	571c <memcpy+0x168>
	cmp	r3, #3
    56e8:	2b03      	cmp	r3, #3
	beq	.Lmisaligned_copy_3_1
    56ea:	d00b      	beq.n	5704 <memcpy+0x150>
	subs	r2, #4
	bhs	1b
	.endm

.Lmisaligned_copy_1_3:
	mis_src_copy shift=8
    56ec:	0a24      	lsrs	r4, r4, #8
    56ee:	f851 3b04 	ldr.w	r3, [r1], #4
    56f2:	061d      	lsls	r5, r3, #24
    56f4:	ea44 0405 	orr.w	r4, r4, r5
    56f8:	f840 4b04 	str.w	r4, [r0], #4
    56fc:	461c      	mov	r4, r3
    56fe:	3a04      	subs	r2, #4
    5700:	d2f4      	bcs.n	56ec <memcpy+0x138>
	b	.Lsrc_misaligned_tail
    5702:	e016      	b.n	5732 <memcpy+0x17e>

.Lmisaligned_copy_3_1:
	mis_src_copy shift=24
    5704:	0e24      	lsrs	r4, r4, #24
    5706:	f851 3b04 	ldr.w	r3, [r1], #4
    570a:	021d      	lsls	r5, r3, #8
    570c:	ea44 0405 	orr.w	r4, r4, r5
    5710:	f840 4b04 	str.w	r4, [r0], #4
    5714:	461c      	mov	r4, r3
    5716:	3a04      	subs	r2, #4
    5718:	d2f4      	bcs.n	5704 <memcpy+0x150>
	b	.Lsrc_misaligned_tail
    571a:	e00a      	b.n	5732 <memcpy+0x17e>

.Lmisaligned_copy_2_2:
	/* For 2_2 misalignment, ldr is still faster than 2 x ldrh.  */
	mis_src_copy shift=16
    571c:	0c24      	lsrs	r4, r4, #16
    571e:	f851 3b04 	ldr.w	r3, [r1], #4
    5722:	041d      	lsls	r5, r3, #16
    5724:	ea44 0405 	orr.w	r4, r4, r5
    5728:	f840 4b04 	str.w	r4, [r0], #4
    572c:	461c      	mov	r4, r3
    572e:	3a04      	subs	r2, #4
    5730:	d2f4      	bcs.n	571c <memcpy+0x168>

.Lsrc_misaligned_tail:
	adds	r2, #4
    5732:	3204      	adds	r2, #4
	subs	r1, ip
    5734:	ebb1 010c 	subs.w	r1, r1, ip
	pop	{r4, r5}
    5738:	bc30      	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    573a:	3a04      	subs	r2, #4
	blo	.Lcopy_less_than_4
    573c:	d3a0      	bcc.n	5680 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    573e:	3a01      	subs	r2, #1
	ldrb    r3, [r1], #1
    5740:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    5744:	f800 3b01 	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    5748:	d2f9      	bcs.n	573e <memcpy+0x18a>

	ldrb	r3, [r1]
    574a:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    574c:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    574e:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    5750:	7043      	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    5752:	788b      	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    5754:	7083      	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    5756:	bc01      	pop	{r0}
#endif
	bx	lr
    5758:	4770      	bx	lr
    575a:	bf00      	nop

0000575c <fault_isr>:
void _init_Teensyduino_internal_(void) __attribute__((noinline));
void __libc_init_array(void);


void fault_isr(void)
{
    575c:	b508      	push	{r3, lr}
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    575e:	4c10      	ldr	r4, [pc, #64]	; (57a0 <fault_isr+0x44>)
    5760:	e008      	b.n	5774 <fault_isr+0x18>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    5762:	6823      	ldr	r3, [r4, #0]
    5764:	0559      	lsls	r1, r3, #21
    5766:	d40d      	bmi.n	5784 <fault_isr+0x28>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    5768:	6823      	ldr	r3, [r4, #0]
    576a:	051a      	lsls	r2, r3, #20
    576c:	d40f      	bmi.n	578e <fault_isr+0x32>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    576e:	6823      	ldr	r3, [r4, #0]
    5770:	04db      	lsls	r3, r3, #19
    5772:	d411      	bmi.n	5798 <fault_isr+0x3c>
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    5774:	6823      	ldr	r3, [r4, #0]
    5776:	0358      	lsls	r0, r3, #13
    5778:	d5f3      	bpl.n	5762 <fault_isr+0x6>
    577a:	f000 fceb 	bl	6154 <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    577e:	6823      	ldr	r3, [r4, #0]
    5780:	0559      	lsls	r1, r3, #21
    5782:	d5f1      	bpl.n	5768 <fault_isr+0xc>
    5784:	f000 f80e 	bl	57a4 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    5788:	6823      	ldr	r3, [r4, #0]
    578a:	051a      	lsls	r2, r3, #20
    578c:	d5ef      	bpl.n	576e <fault_isr+0x12>
    578e:	f000 f809 	bl	57a4 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    5792:	6823      	ldr	r3, [r4, #0]
    5794:	04db      	lsls	r3, r3, #19
    5796:	d5ed      	bpl.n	5774 <fault_isr+0x18>
    5798:	f000 f804 	bl	57a4 <unused_isr>
    579c:	e7ea      	b.n	5774 <fault_isr+0x18>
    579e:	bf00      	nop
    57a0:	40048034 	.word	0x40048034

000057a4 <unused_isr>:
	}
}

void unused_isr(void)
{
    57a4:	b508      	push	{r3, lr}
	fault_isr();
    57a6:	f7ff ffd9 	bl	575c <fault_isr>
    57aa:	bf00      	nop

000057ac <startup_early_hook>:
extern void rtc_set(unsigned long t);


static void startup_default_early_hook(void) {
#if defined(KINETISK)
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    57ac:	4b01      	ldr	r3, [pc, #4]	; (57b4 <startup_early_hook+0x8>)
    57ae:	2210      	movs	r2, #16
    57b0:	801a      	strh	r2, [r3, #0]
    57b2:	4770      	bx	lr
    57b4:	40052000 	.word	0x40052000

000057b8 <startup_late_hook>:
#elif defined(KINETISL)
	SIM_COPC = 0;  // disable the watchdog
#endif
}
static void startup_default_late_hook(void) {}
    57b8:	4770      	bx	lr
    57ba:	bf00      	nop

000057bc <_sbrk>:

void * _sbrk(int incr)
{
	char *prev, *stack;

	prev = __brkval;
    57bc:	4909      	ldr	r1, [pc, #36]	; (57e4 <_sbrk+0x28>)

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

void * _sbrk(int incr)
{
    57be:	b508      	push	{r3, lr}
	char *prev, *stack;

	prev = __brkval;
    57c0:	680b      	ldr	r3, [r1, #0]
	if (incr != 0) {
    57c2:	b130      	cbz	r0, 57d2 <_sbrk+0x16>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
    57c4:	466a      	mov	r2, sp
		if (prev + incr >= stack - STACK_MARGIN) {
    57c6:	4418      	add	r0, r3
    57c8:	f5a2 5200 	sub.w	r2, r2, #8192	; 0x2000
    57cc:	4290      	cmp	r0, r2
    57ce:	d202      	bcs.n	57d6 <_sbrk+0x1a>
			errno = ENOMEM;
			return (void *)-1;
		}
		__brkval = prev + incr;
    57d0:	6008      	str	r0, [r1, #0]
	}
	return prev;
    57d2:	4618      	mov	r0, r3
}
    57d4:	bd08      	pop	{r3, pc}

	prev = __brkval;
	if (incr != 0) {
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
		if (prev + incr >= stack - STACK_MARGIN) {
			errno = ENOMEM;
    57d6:	f002 fa1f 	bl	7c18 <__errno>
    57da:	230c      	movs	r3, #12
    57dc:	6003      	str	r3, [r0, #0]
			return (void *)-1;
    57de:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    57e2:	bd08      	pop	{r3, pc}
    57e4:	1fff0964 	.word	0x1fff0964

000057e8 <kinetis_hsrun_disable>:


#if defined(HAS_KINETIS_HSRUN) && F_CPU > 120000000
int kinetis_hsrun_disable(void)
{
	if (SMC_PMSTAT == SMC_PMSTAT_HSRUN) {
    57e8:	4a08      	ldr	r2, [pc, #32]	; (580c <kinetis_hsrun_disable+0x24>)
    57ea:	7813      	ldrb	r3, [r2, #0]
    57ec:	2b80      	cmp	r3, #128	; 0x80
    57ee:	d001      	beq.n	57f4 <kinetis_hsrun_disable+0xc>
		// Then turn off HSRUN mode
		SMC_PMCTRL = SMC_PMCTRL_RUNM(0);
		while (SMC_PMSTAT == SMC_PMSTAT_HSRUN) ; // wait
		return 1;
	}
	return 0;
    57f0:	2000      	movs	r0, #0
}
    57f2:	4770      	bx	lr
		#elif F_CPU == 192000000 && F_BUS == 64000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(2, 2, 2, 8); // ok
		#elif F_CPU == 192000000 && F_BUS == 96000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 7); // ok
		#elif F_CPU == 180000000 && F_BUS == 60000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(2, 2, 2, 8); // ok
    57f4:	4906      	ldr	r1, [pc, #24]	; (5810 <kinetis_hsrun_disable+0x28>)
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 5); // ok
		#else
			return 0;
		#endif
		// Then turn off HSRUN mode
		SMC_PMCTRL = SMC_PMCTRL_RUNM(0);
    57f6:	4b07      	ldr	r3, [pc, #28]	; (5814 <kinetis_hsrun_disable+0x2c>)
		#elif F_CPU == 192000000 && F_BUS == 64000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(2, 2, 2, 8); // ok
		#elif F_CPU == 192000000 && F_BUS == 96000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 7); // ok
		#elif F_CPU == 180000000 && F_BUS == 60000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(2, 2, 2, 8); // ok
    57f8:	4807      	ldr	r0, [pc, #28]	; (5818 <kinetis_hsrun_disable+0x30>)
    57fa:	6008      	str	r0, [r1, #0]
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 5); // ok
		#else
			return 0;
		#endif
		// Then turn off HSRUN mode
		SMC_PMCTRL = SMC_PMCTRL_RUNM(0);
    57fc:	2100      	movs	r1, #0
    57fe:	7019      	strb	r1, [r3, #0]
		while (SMC_PMSTAT == SMC_PMSTAT_HSRUN) ; // wait
    5800:	7813      	ldrb	r3, [r2, #0]
    5802:	2b80      	cmp	r3, #128	; 0x80
    5804:	d0fc      	beq.n	5800 <kinetis_hsrun_disable+0x18>
		return 1;
    5806:	2001      	movs	r0, #1
    5808:	4770      	bx	lr
    580a:	bf00      	nop
    580c:	4007e003 	.word	0x4007e003
    5810:	40048044 	.word	0x40048044
    5814:	4007e001 	.word	0x4007e001
    5818:	22280000 	.word	0x22280000

0000581c <kinetis_hsrun_enable>:
	return 0;
}

int kinetis_hsrun_enable(void)
{
	if (SMC_PMSTAT == SMC_PMSTAT_RUN) {
    581c:	4a09      	ldr	r2, [pc, #36]	; (5844 <kinetis_hsrun_enable+0x28>)
    581e:	7813      	ldrb	r3, [r2, #0]
    5820:	2b01      	cmp	r3, #1
    5822:	d001      	beq.n	5828 <kinetis_hsrun_enable+0xc>
		#else
			return 0;
		#endif
		return 1;
	}
	return 0;
    5824:	2000      	movs	r0, #0
}
    5826:	4770      	bx	lr

int kinetis_hsrun_enable(void)
{
	if (SMC_PMSTAT == SMC_PMSTAT_RUN) {
		// Turn HSRUN mode on
		SMC_PMCTRL = SMC_PMCTRL_RUNM(3);
    5828:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    582c:	f503 23fc 	add.w	r3, r3, #516096	; 0x7e000
    5830:	2160      	movs	r1, #96	; 0x60
    5832:	7019      	strb	r1, [r3, #0]
		while (SMC_PMSTAT != SMC_PMSTAT_HSRUN) {;} // wait
    5834:	7813      	ldrb	r3, [r2, #0]
    5836:	2b80      	cmp	r3, #128	; 0x80
    5838:	d1fc      	bne.n	5834 <kinetis_hsrun_enable+0x18>
		#elif F_CPU == 192000000 && F_BUS == 64000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 2, 0, 6);
		#elif F_CPU == 192000000 && F_BUS == 96000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 1, 0, 6);
		#elif F_CPU == 180000000 && F_BUS == 60000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 2, 0, 6);
    583a:	4b03      	ldr	r3, [pc, #12]	; (5848 <kinetis_hsrun_enable+0x2c>)
    583c:	4a03      	ldr	r2, [pc, #12]	; (584c <kinetis_hsrun_enable+0x30>)
    583e:	601a      	str	r2, [r3, #0]
		#elif F_CPU == 144000000 && F_BUS == 72000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 1, 0, 4);
		#else
			return 0;
		#endif
		return 1;
    5840:	2001      	movs	r0, #1
    5842:	4770      	bx	lr
    5844:	4007e003 	.word	0x4007e003
    5848:	40048044 	.word	0x40048044
    584c:	02060000 	.word	0x02060000

00005850 <dummy_isr>:
	{((volatile uint8_t *)&CORE_PIN26_PORTREG + (CORE_PIN26_BIT >> 3)), &CORE_PIN26_CONFIG, (1<<(CORE_PIN26_BIT & 7))}
};

#endif

static void dummy_isr() {};
    5850:	4770      	bx	lr
    5852:	bf00      	nop

00005854 <digitalWrite.part.1>:



// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
    5854:	b410      	push	{r4}
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
    5856:	4b11      	ldr	r3, [pc, #68]	; (589c <digitalWrite.part.1+0x48>)
    5858:	f853 2030 	ldr.w	r2, [r3, r0, lsl #3]
    585c:	f892 4280 	ldrb.w	r4, [r2, #640]	; 0x280
    5860:	b134      	cbz	r4, 5870 <digitalWrite.part.1+0x1c>
		if (val) {
			*portSetRegister(pin) = 1;
    5862:	2301      	movs	r3, #1
void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
    5864:	b179      	cbz	r1, 5886 <digitalWrite.part.1+0x32>
			*portSetRegister(pin) = 1;
    5866:	f882 3080 	strb.w	r3, [r2, #128]	; 0x80
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    586a:	f85d 4b04 	ldr.w	r4, [sp], #4
    586e:	4770      	bx	lr
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
    5870:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
    5874:	685b      	ldr	r3, [r3, #4]
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    5876:	681a      	ldr	r2, [r3, #0]
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
    5878:	b951      	cbnz	r1, 5890 <digitalWrite.part.1+0x3c>
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
			//*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else {
			// TODO use bitband for atomic read-mod-write
			*config &= ~(PORT_PCR_PE);
    587a:	f022 0202 	bic.w	r2, r2, #2
    587e:	601a      	str	r2, [r3, #0]
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    5880:	f85d 4b04 	ldr.w	r4, [sp], #4
    5884:	4770      	bx	lr
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
			*portSetRegister(pin) = 1;
		} else {
			*portClearRegister(pin) = 1;
    5886:	f882 3100 	strb.w	r3, [r2, #256]	; 0x100
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    588a:	f85d 4b04 	ldr.w	r4, [sp], #4
    588e:	4770      	bx	lr
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    5890:	f042 0203 	orr.w	r2, r2, #3
    5894:	601a      	str	r2, [r3, #0]
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    5896:	f85d 4b04 	ldr.w	r4, [sp], #4
    589a:	4770      	bx	lr
    589c:	00009484 	.word	0x00009484

000058a0 <pinMode.part.2>:
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    58a0:	4a1c      	ldr	r2, [pc, #112]	; (5914 <pinMode.part.2+0x74>)
    58a2:	eb02 03c0 	add.w	r3, r2, r0, lsl #3

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    58a6:	2901      	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    58a8:	685b      	ldr	r3, [r3, #4]

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    58aa:	d011      	beq.n	58d0 <pinMode.part.2+0x30>
    58ac:	2904      	cmp	r1, #4
    58ae:	d01b      	beq.n	58e8 <pinMode.part.2+0x48>
		} else {
		    *config &= ~PORT_PCR_ODE;
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
    58b0:	f852 0030 	ldr.w	r0, [r2, r0, lsl #3]
    58b4:	2200      	movs	r2, #0
    58b6:	f880 2280 	strb.w	r2, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
    58ba:	b129      	cbz	r1, 58c8 <pinMode.part.2+0x28>
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
    58bc:	2902      	cmp	r1, #2
    58be:	d020      	beq.n	5902 <pinMode.part.2+0x62>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else if (mode == INPUT_PULLDOWN) {
    58c0:	2903      	cmp	r1, #3
    58c2:	d022      	beq.n	590a <pinMode.part.2+0x6a>
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    58c4:	601a      	str	r2, [r3, #0]
    58c6:	4770      	bx	lr
		*portModeRegister(pin) = 0;
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
    58c8:	f44f 7280 	mov.w	r2, #256	; 0x100
    58cc:	601a      	str	r2, [r3, #0]
    58ce:	4770      	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    58d0:	f852 0030 	ldr.w	r0, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    58d4:	f44f 72a2 	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    58d8:	f880 1280 	strb.w	r1, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    58dc:	601a      	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    58de:	681a      	ldr	r2, [r3, #0]
    58e0:	f022 0220 	bic.w	r2, r2, #32
    58e4:	601a      	str	r2, [r3, #0]
    58e6:	4770      	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    58e8:	f852 1030 	ldr.w	r1, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    58ec:	f44f 72a2 	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    58f0:	2001      	movs	r0, #1
    58f2:	f881 0280 	strb.w	r0, [r1, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    58f6:	601a      	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
    58f8:	681a      	ldr	r2, [r3, #0]
    58fa:	f042 0220 	orr.w	r2, r2, #32
    58fe:	601a      	str	r2, [r3, #0]
    5900:	4770      	bx	lr
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    5902:	f240 1203 	movw	r2, #259	; 0x103
    5906:	601a      	str	r2, [r3, #0]
    5908:	4770      	bx	lr
		} else if (mode == INPUT_PULLDOWN) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    590a:	f44f 7281 	mov.w	r2, #258	; 0x102
    590e:	601a      	str	r2, [r3, #0]
    5910:	4770      	bx	lr
    5912:	bf00      	nop
    5914:	00009484 	.word	0x00009484

00005918 <attachInterrupt>:
void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
    5918:	283f      	cmp	r0, #63	; 0x3f
    591a:	d848      	bhi.n	59ae <attachInterrupt+0x96>
{
	_VectorsRam[irq + 16] = function;
}

void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
    591c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	switch (mode) {
    591e:	2a04      	cmp	r2, #4
    5920:	d844      	bhi.n	59ac <attachInterrupt+0x94>
    5922:	e8df f002 	tbb	[pc, r2]
    5926:	4b48      	.short	0x4b48
    5928:	034e      	.short	0x034e
    592a:	45          	.byte	0x45
    592b:	00          	.byte	0x00
    592c:	f44f 2610 	mov.w	r6, #589824	; 0x90000
	  case LOW:	mask = 0x08; break;
	  case HIGH:	mask = 0x0C; break;
	  default: return;
	}
	mask = (mask << 16) | 0x01000000;
	config = portConfigRegister(pin);
    5930:	4b2b      	ldr	r3, [pc, #172]	; (59e0 <attachInterrupt+0xc8>)
    5932:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
    5936:	460d      	mov	r5, r1
    5938:	685c      	ldr	r4, [r3, #4]
	if ((*config & 0x00000700) == 0) {
    593a:	6821      	ldr	r1, [r4, #0]
    593c:	f411 61e0 	ands.w	r1, r1, #1792	; 0x700
    5940:	d048      	beq.n	59d4 <attachInterrupt+0xbc>
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    5942:	4b28      	ldr	r3, [pc, #160]	; (59e4 <attachInterrupt+0xcc>)
    5944:	4a28      	ldr	r2, [pc, #160]	; (59e8 <attachInterrupt+0xd0>)
    5946:	4929      	ldr	r1, [pc, #164]	; (59ec <attachInterrupt+0xd4>)
    5948:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    594c:	f104 4240 	add.w	r2, r4, #3221225472	; 0xc0000000
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    5950:	4827      	ldr	r0, [pc, #156]	; (59f0 <attachInterrupt+0xd8>)
    5952:	f8c3 1134 	str.w	r1, [r3, #308]	; 0x134

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    5956:	f5a2 2192 	sub.w	r1, r2, #299008	; 0x49000
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    595a:	4f26      	ldr	r7, [pc, #152]	; (59f4 <attachInterrupt+0xdc>)
    595c:	f8c3 0130 	str.w	r0, [r3, #304]	; 0x130

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    5960:	297c      	cmp	r1, #124	; 0x7c
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    5962:	4825      	ldr	r0, [pc, #148]	; (59f8 <attachInterrupt+0xe0>)
    5964:	f8c3 7138 	str.w	r7, [r3, #312]	; 0x138
    5968:	f8c3 013c 	str.w	r0, [r3, #316]	; 0x13c

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    596c:	d92c      	bls.n	59c8 <attachInterrupt+0xb0>
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
    596e:	f5a2 2394 	sub.w	r3, r2, #303104	; 0x4a000
    5972:	2b7c      	cmp	r3, #124	; 0x7c
    5974:	d92a      	bls.n	59cc <attachInterrupt+0xb4>
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
    5976:	f5a2 2396 	sub.w	r3, r2, #307200	; 0x4b000
    597a:	2b7c      	cmp	r3, #124	; 0x7c
    597c:	d928      	bls.n	59d0 <attachInterrupt+0xb8>
	else if(&PORTD_PCR0 <= config && config <= &PORTD_PCR31) isr_table = isr_table_portD;
    597e:	f5a2 2398 	sub.w	r3, r2, #311296	; 0x4c000
    5982:	2b7c      	cmp	r3, #124	; 0x7c
    5984:	d929      	bls.n	59da <attachInterrupt+0xc2>
	else if(&PORTE_PCR0 <= config && config <= &PORTE_PCR31) isr_table = isr_table_portE;
    5986:	f5a2 229a 	sub.w	r2, r2, #315392	; 0x4d000
    598a:	2a7c      	cmp	r2, #124	; 0x7c
    598c:	d827      	bhi.n	59de <attachInterrupt+0xc6>
    598e:	481b      	ldr	r0, [pc, #108]	; (59fc <attachInterrupt+0xe4>)
	attachInterruptVector(IRQ_PORTD, port_D_isr);
	attachInterruptVector(IRQ_PORTE, port_E_isr);
	voidFuncPtr* isr_table = getIsrTable(config);
	if(!isr_table) return;
	uint32_t pin_index = getPinIndex(config);
	__disable_irq();
    5990:	b672      	cpsid	i
	cfg = *config;
    5992:	6823      	ldr	r3, [r4, #0]
	cfg &= ~0x000F0000;		// disable any previous interrupt
    5994:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    5998:	f043 7280 	orr.w	r2, r3, #16777216	; 0x1000000
	*config = cfg;
	isr_table[pin_index] = function;	// set the function pointer
    599c:	f3c4 0184 	ubfx	r1, r4, #2, #5
	cfg |= mask;
    59a0:	4316      	orrs	r6, r2
	if(!isr_table) return;
	uint32_t pin_index = getPinIndex(config);
	__disable_irq();
	cfg = *config;
	cfg &= ~0x000F0000;		// disable any previous interrupt
	*config = cfg;
    59a2:	6023      	str	r3, [r4, #0]
	isr_table[pin_index] = function;	// set the function pointer
    59a4:	f840 5021 	str.w	r5, [r0, r1, lsl #2]
	cfg |= mask;
	*config = cfg;			// enable the new interrupt
    59a8:	6026      	str	r6, [r4, #0]
	__enable_irq();
    59aa:	b662      	cpsie	i
    59ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    59ae:	4770      	bx	lr
{
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	switch (mode) {
    59b0:	f44f 2630 	mov.w	r6, #720896	; 0xb0000
    59b4:	e7bc      	b.n	5930 <attachInterrupt+0x18>
	  case CHANGE:	mask = 0x0B; break;
	  case RISING:	mask = 0x09; break;
	  case FALLING:	mask = 0x0A; break;
	  case LOW:	mask = 0x08; break;
    59b6:	f44f 2600 	mov.w	r6, #524288	; 0x80000
    59ba:	e7b9      	b.n	5930 <attachInterrupt+0x18>
	  case HIGH:	mask = 0x0C; break;
    59bc:	f44f 2640 	mov.w	r6, #786432	; 0xc0000
    59c0:	e7b6      	b.n	5930 <attachInterrupt+0x18>
{
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	switch (mode) {
    59c2:	f44f 2620 	mov.w	r6, #655360	; 0xa0000
    59c6:	e7b3      	b.n	5930 <attachInterrupt+0x18>

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    59c8:	480d      	ldr	r0, [pc, #52]	; (5a00 <attachInterrupt+0xe8>)
    59ca:	e7e1      	b.n	5990 <attachInterrupt+0x78>
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
    59cc:	480d      	ldr	r0, [pc, #52]	; (5a04 <attachInterrupt+0xec>)
    59ce:	e7df      	b.n	5990 <attachInterrupt+0x78>
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
    59d0:	480d      	ldr	r0, [pc, #52]	; (5a08 <attachInterrupt+0xf0>)
    59d2:	e7dd      	b.n	5990 <attachInterrupt+0x78>
    59d4:	f7ff ff64 	bl	58a0 <pinMode.part.2>
    59d8:	e7b3      	b.n	5942 <attachInterrupt+0x2a>
	else if(&PORTD_PCR0 <= config && config <= &PORTD_PCR31) isr_table = isr_table_portD;
    59da:	480c      	ldr	r0, [pc, #48]	; (5a0c <attachInterrupt+0xf4>)
    59dc:	e7d8      	b.n	5990 <attachInterrupt+0x78>
    59de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    59e0:	00009484 	.word	0x00009484
    59e4:	1fff0200 	.word	0x1fff0200
    59e8:	1fff07e1 	.word	0x1fff07e1
    59ec:	1fff0789 	.word	0x1fff0789
    59f0:	1fff07b5 	.word	0x1fff07b5
    59f4:	1fff075d 	.word	0x1fff075d
    59f8:	1fff0731 	.word	0x1fff0731
    59fc:	1fff0ab0 	.word	0x1fff0ab0
    5a00:	1fff0968 	.word	0x1fff0968
    5a04:	1fff09e0 	.word	0x1fff09e0
    5a08:	1fff0a40 	.word	0x1fff0a40
    5a0c:	1fff0a70 	.word	0x1fff0a70

00005a10 <rtc_set>:
{
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
    5a10:	b430      	push	{r4, r5}
	RTC_SR = 0;
    5a12:	4b05      	ldr	r3, [pc, #20]	; (5a28 <rtc_set+0x18>)
	RTC_TPR = 0;
    5a14:	4d05      	ldr	r5, [pc, #20]	; (5a2c <rtc_set+0x1c>)
	RTC_TSR = t;
    5a16:	4c06      	ldr	r4, [pc, #24]	; (5a30 <rtc_set+0x20>)
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    5a18:	2200      	movs	r2, #0
	RTC_TPR = 0;
	RTC_TSR = t;
	RTC_SR = RTC_SR_TCE;
    5a1a:	2110      	movs	r1, #16
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    5a1c:	601a      	str	r2, [r3, #0]
	RTC_TPR = 0;
    5a1e:	602a      	str	r2, [r5, #0]
	RTC_TSR = t;
    5a20:	6020      	str	r0, [r4, #0]
	RTC_SR = RTC_SR_TCE;
    5a22:	6019      	str	r1, [r3, #0]
}
    5a24:	bc30      	pop	{r4, r5}
    5a26:	4770      	bx	lr
    5a28:	4003d014 	.word	0x4003d014
    5a2c:	4003d004 	.word	0x4003d004
    5a30:	4003d000 	.word	0x4003d000

00005a34 <analogWrite>:
// FTM is clocked by the bus clock, either 24 or 48 MHz
// input capture can be FTM1_CH0, CMP0 or CMP1 or USB start of frame
// 24 MHz with reload 49152 to match Arduino's speed = 488.28125 Hz

void analogWrite(uint8_t pin, int val)
{
    5a34:	b538      	push	{r3, r4, r5, lr}
		}
		analogWriteDAC0(val);
		return;
	}
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (pin == A21 || pin == A22) {
    5a36:	f1a0 0342 	sub.w	r3, r0, #66	; 0x42
    5a3a:	2b01      	cmp	r3, #1
// FTM is clocked by the bus clock, either 24 or 48 MHz
// input capture can be FTM1_CH0, CMP0 or CMP1 or USB start of frame
// 24 MHz with reload 49152 to match Arduino's speed = 488.28125 Hz

void analogWrite(uint8_t pin, int val)
{
    5a3c:	4604      	mov	r4, r0
		}
		analogWriteDAC0(val);
		return;
	}
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (pin == A21 || pin == A22) {
    5a3e:	d924      	bls.n	5a8a <analogWrite+0x56>
		return;
	}
#endif

	max = 1 << analog_write_res;
	if (val <= 0) {
    5a40:	2900      	cmp	r1, #0
    5a42:	dd7a      	ble.n	5b3a <analogWrite+0x106>
		else analogWriteDAC1(val);
		return;
	}
#endif

	max = 1 << analog_write_res;
    5a44:	4b99      	ldr	r3, [pc, #612]	; (5cac <analogWrite+0x278>)
    5a46:	781b      	ldrb	r3, [r3, #0]
	if (val <= 0) {
		digitalWrite(pin, LOW);
		pinMode(pin, OUTPUT);	// TODO: implement OUTPUT_LOW
		return;
	} else if (val >= max) {
    5a48:	2501      	movs	r5, #1
    5a4a:	fa05 f203 	lsl.w	r2, r5, r3
    5a4e:	428a      	cmp	r2, r1
    5a50:	d802      	bhi.n	5a58 <analogWrite+0x24>

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    5a52:	283f      	cmp	r0, #63	; 0x3f
    5a54:	d92c      	bls.n	5ab0 <analogWrite+0x7c>
    5a56:	bd38      	pop	{r3, r4, r5, pc}
	//serial_phex32(val);
	//serial_print("\n");
	//serial_print("analog_write_res = ");
	//serial_phex(analog_write_res);
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
    5a58:	1ec2      	subs	r2, r0, #3
    5a5a:	2a01      	cmp	r2, #1
    5a5c:	d930      	bls.n	5ac0 <analogWrite+0x8c>
		cval = ((uint32_t)val * (uint32_t)(FTM1_MOD + 1)) >> analog_write_res;
#if defined(FTM2_CH0_PIN)
	} else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
    5a5e:	f1a0 021d 	sub.w	r2, r0, #29
    5a62:	2a01      	cmp	r2, #1
    5a64:	d978      	bls.n	5b58 <analogWrite+0x124>
		cval = ((uint32_t)val * (uint32_t)(FTM2_MOD + 1)) >> analog_write_res;
#endif
#if defined(FTM3_CH0_PIN)
	} else if (pin == FTM3_CH0_PIN || pin == FTM3_CH1_PIN || pin == FTM3_CH2_PIN
    5a66:	280e      	cmp	r0, #14
    5a68:	d95b      	bls.n	5b22 <analogWrite+0xee>
	  || pin == FTM3_CH3_PIN || pin == FTM3_CH4_PIN || pin == FTM3_CH5_PIN
    5a6a:	f1a4 0223 	sub.w	r2, r4, #35	; 0x23
    5a6e:	2a03      	cmp	r2, #3
    5a70:	d95c      	bls.n	5b2c <analogWrite+0xf8>
	  || pin == FTM3_CH6_PIN || pin == FTM3_CH7_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM3_MOD + 1)) >> analog_write_res;
#endif
#if defined(TPM1_CH0_PIN)
	} else if (pin == TPM1_CH0_PIN || pin == TPM1_CH1_PIN) {
    5a72:	f1a4 0210 	sub.w	r2, r4, #16
    5a76:	2a01      	cmp	r2, #1
		cval = ((uint32_t)val * (uint32_t)(TPM1_MOD + 1)) >> analog_write_res;
    5a78:	bf94      	ite	ls
    5a7a:	4a8d      	ldrls	r2, [pc, #564]	; (5cb0 <analogWrite+0x27c>)
#endif
	} else {
		cval = ((uint32_t)val * (uint32_t)(FTM0_MOD + 1)) >> analog_write_res;
    5a7c:	4a8d      	ldrhi	r2, [pc, #564]	; (5cb4 <analogWrite+0x280>)
    5a7e:	6812      	ldr	r2, [r2, #0]
    5a80:	fb02 1201 	mla	r2, r2, r1, r1
    5a84:	fa22 f303 	lsr.w	r3, r2, r3
    5a88:	e020      	b.n	5acc <analogWrite+0x98>
		analogWriteDAC0(val);
		return;
	}
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (pin == A21 || pin == A22) {
		uint8_t res = analog_write_res;
    5a8a:	4b88      	ldr	r3, [pc, #544]	; (5cac <analogWrite+0x278>)
    5a8c:	781b      	ldrb	r3, [r3, #0]
		if (res < 12) {
    5a8e:	2b0b      	cmp	r3, #11
    5a90:	d90a      	bls.n	5aa8 <analogWrite+0x74>
			val <<= 12 - res;
		} else if (res > 12) {
    5a92:	2b0c      	cmp	r3, #12
			val >>= res - 12;
    5a94:	bf1c      	itt	ne
    5a96:	3b0c      	subne	r3, #12
    5a98:	4119      	asrne	r1, r3
		}
		if (pin == A21) analogWriteDAC0(val);
    5a9a:	2c42      	cmp	r4, #66	; 0x42
    5a9c:	4608      	mov	r0, r1
    5a9e:	d057      	beq.n	5b50 <analogWrite+0x11c>
#endif
	  default:
		digitalWrite(pin, (val > 127) ? HIGH : LOW);
		pinMode(pin, OUTPUT);
	}
}
    5aa0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			val <<= 12 - res;
		} else if (res > 12) {
			val >>= res - 12;
		}
		if (pin == A21) analogWriteDAC0(val);
		else analogWriteDAC1(val);
    5aa4:	f001 bb66 	b.w	7174 <analogWriteDAC1>
	}
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (pin == A21 || pin == A22) {
		uint8_t res = analog_write_res;
		if (res < 12) {
			val <<= 12 - res;
    5aa8:	f1c3 030c 	rsb	r3, r3, #12
    5aac:	4099      	lsls	r1, r3
    5aae:	e7f4      	b.n	5a9a <analogWrite+0x66>
    5ab0:	4629      	mov	r1, r5
    5ab2:	f7ff fecf 	bl	5854 <digitalWrite.part.1>
    5ab6:	4629      	mov	r1, r5
#endif
	  default:
		digitalWrite(pin, (val > 127) ? HIGH : LOW);
		pinMode(pin, OUTPUT);
	}
}
    5ab8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    5abc:	f7ff bef0 	b.w	58a0 <pinMode.part.2>
	//serial_print("\n");
	//serial_print("analog_write_res = ");
	//serial_phex(analog_write_res);
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM1_MOD + 1)) >> analog_write_res;
    5ac0:	4a7d      	ldr	r2, [pc, #500]	; (5cb8 <analogWrite+0x284>)
    5ac2:	6812      	ldr	r2, [r2, #0]
    5ac4:	fb02 1201 	mla	r2, r2, r1, r1
    5ac8:	fa22 f303 	lsr.w	r3, r2, r3
		cval = ((uint32_t)val * (uint32_t)(FTM0_MOD + 1)) >> analog_write_res;
	}
	//serial_print("cval = ");
	//serial_phex32(cval);
	//serial_print("\n");
	switch (pin) {
    5acc:	1ea2      	subs	r2, r4, #2
    5ace:	2a24      	cmp	r2, #36	; 0x24
    5ad0:	f200 80e3 	bhi.w	5c9a <analogWrite+0x266>
    5ad4:	e8df f012 	tbh	[pc, r2, lsl #1]
    5ad8:	00d300da 	.word	0x00d300da
    5adc:	00c500cc 	.word	0x00c500cc
    5ae0:	00b700be 	.word	0x00b700be
    5ae4:	00a900b0 	.word	0x00a900b0
    5ae8:	00e100a2 	.word	0x00e100a2
    5aec:	00e100e1 	.word	0x00e100e1
    5af0:	00e1009b 	.word	0x00e1009b
    5af4:	008d0094 	.word	0x008d0094
    5af8:	00e100e1 	.word	0x00e100e1
    5afc:	007f0086 	.word	0x007f0086
    5b00:	00710078 	.word	0x00710078
    5b04:	00e100e1 	.word	0x00e100e1
    5b08:	00e100e1 	.word	0x00e100e1
    5b0c:	006a00e1 	.word	0x006a00e1
    5b10:	00e10063 	.word	0x00e10063
    5b14:	00e100e1 	.word	0x00e100e1
    5b18:	005c00e1 	.word	0x005c00e1
    5b1c:	004e0055 	.word	0x004e0055
    5b20:	0047      	.short	0x0047
#if defined(FTM2_CH0_PIN)
	} else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM2_MOD + 1)) >> analog_write_res;
#endif
#if defined(FTM3_CH0_PIN)
	} else if (pin == FTM3_CH0_PIN || pin == FTM3_CH1_PIN || pin == FTM3_CH2_PIN
    5b22:	f244 1284 	movw	r2, #16772	; 0x4184
    5b26:	40c2      	lsrs	r2, r0
    5b28:	07d2      	lsls	r2, r2, #31
    5b2a:	d59e      	bpl.n	5a6a <analogWrite+0x36>
	  || pin == FTM3_CH3_PIN || pin == FTM3_CH4_PIN || pin == FTM3_CH5_PIN
	  || pin == FTM3_CH6_PIN || pin == FTM3_CH7_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM3_MOD + 1)) >> analog_write_res;
    5b2c:	4a63      	ldr	r2, [pc, #396]	; (5cbc <analogWrite+0x288>)
    5b2e:	6812      	ldr	r2, [r2, #0]
    5b30:	fb02 1201 	mla	r2, r2, r1, r1
    5b34:	fa22 f303 	lsr.w	r3, r2, r3
    5b38:	e7c8      	b.n	5acc <analogWrite+0x98>

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    5b3a:	283f      	cmp	r0, #63	; 0x3f
    5b3c:	d88b      	bhi.n	5a56 <analogWrite+0x22>
    5b3e:	2100      	movs	r1, #0
    5b40:	f7ff fe88 	bl	5854 <digitalWrite.part.1>
    5b44:	4620      	mov	r0, r4
    5b46:	2101      	movs	r1, #1
#endif
	  default:
		digitalWrite(pin, (val > 127) ? HIGH : LOW);
		pinMode(pin, OUTPUT);
	}
}
    5b48:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    5b4c:	f7ff bea8 	b.w	58a0 <pinMode.part.2>
    5b50:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		if (res < 12) {
			val <<= 12 - res;
		} else if (res > 12) {
			val >>= res - 12;
		}
		if (pin == A21) analogWriteDAC0(val);
    5b54:	f001 baf0 	b.w	7138 <analogWriteDAC0>
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM1_MOD + 1)) >> analog_write_res;
#if defined(FTM2_CH0_PIN)
	} else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM2_MOD + 1)) >> analog_write_res;
    5b58:	4a59      	ldr	r2, [pc, #356]	; (5cc0 <analogWrite+0x28c>)
    5b5a:	6812      	ldr	r2, [r2, #0]
    5b5c:	fb02 1201 	mla	r2, r2, r1, r1
    5b60:	fa22 f303 	lsr.w	r3, r2, r3
    5b64:	e7b2      	b.n	5acc <analogWrite+0x98>
		FTM_PINCFG(FTM3_CH6_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH7_PIN
	  case FTM3_CH7_PIN:
		FTM3_C7V = cval;
    5b66:	4957      	ldr	r1, [pc, #348]	; (5cc4 <analogWrite+0x290>)
		FTM_PINCFG(FTM3_CH7_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5b68:	4a57      	ldr	r2, [pc, #348]	; (5cc8 <analogWrite+0x294>)
		FTM_PINCFG(FTM3_CH6_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH7_PIN
	  case FTM3_CH7_PIN:
		FTM3_C7V = cval;
    5b6a:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH7_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5b6c:	f44f 7351 	mov.w	r3, #836	; 0x344
    5b70:	6013      	str	r3, [r2, #0]
		break;
    5b72:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH5_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH6_PIN
	  case FTM3_CH6_PIN:
		FTM3_C6V = cval;
    5b74:	4955      	ldr	r1, [pc, #340]	; (5ccc <analogWrite+0x298>)
		FTM_PINCFG(FTM3_CH6_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5b76:	4a56      	ldr	r2, [pc, #344]	; (5cd0 <analogWrite+0x29c>)
		FTM_PINCFG(FTM3_CH5_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH6_PIN
	  case FTM3_CH6_PIN:
		FTM3_C6V = cval;
    5b78:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH6_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5b7a:	f44f 7351 	mov.w	r3, #836	; 0x344
    5b7e:	6013      	str	r3, [r2, #0]
		break;
    5b80:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH4_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH5_PIN
	  case FTM3_CH5_PIN:
		FTM3_C5V = cval;
    5b82:	4954      	ldr	r1, [pc, #336]	; (5cd4 <analogWrite+0x2a0>)
		FTM_PINCFG(FTM3_CH5_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5b84:	4a54      	ldr	r2, [pc, #336]	; (5cd8 <analogWrite+0x2a4>)
		FTM_PINCFG(FTM3_CH4_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH5_PIN
	  case FTM3_CH5_PIN:
		FTM3_C5V = cval;
    5b86:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH5_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5b88:	f44f 7351 	mov.w	r3, #836	; 0x344
    5b8c:	6013      	str	r3, [r2, #0]
		break;
    5b8e:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH4_PIN
	  case FTM3_CH4_PIN:
		FTM3_C4V = cval;
    5b90:	4952      	ldr	r1, [pc, #328]	; (5cdc <analogWrite+0x2a8>)
		FTM_PINCFG(FTM3_CH4_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5b92:	4a53      	ldr	r2, [pc, #332]	; (5ce0 <analogWrite+0x2ac>)
		FTM_PINCFG(FTM3_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH4_PIN
	  case FTM3_CH4_PIN:
		FTM3_C4V = cval;
    5b94:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH4_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5b96:	f44f 7351 	mov.w	r3, #836	; 0x344
    5b9a:	6013      	str	r3, [r2, #0]
		break;
    5b9c:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH1_PIN
	  case FTM2_CH1_PIN: // PTB19, FTM1_CH1
		FTM2_C1V = cval;
    5b9e:	4951      	ldr	r1, [pc, #324]	; (5ce4 <analogWrite+0x2b0>)
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5ba0:	4a51      	ldr	r2, [pc, #324]	; (5ce8 <analogWrite+0x2b4>)
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH1_PIN
	  case FTM2_CH1_PIN: // PTB19, FTM1_CH1
		FTM2_C1V = cval;
    5ba2:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5ba4:	f44f 7351 	mov.w	r3, #836	; 0x344
    5ba8:	6013      	str	r3, [r2, #0]
		break;
    5baa:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH0_PIN
	  case FTM2_CH0_PIN: // PTB18, FTM2_CH0
		FTM2_C0V = cval;
    5bac:	494f      	ldr	r1, [pc, #316]	; (5cec <analogWrite+0x2b8>)
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5bae:	4a50      	ldr	r2, [pc, #320]	; (5cf0 <analogWrite+0x2bc>)
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH0_PIN
	  case FTM2_CH0_PIN: // PTB18, FTM2_CH0
		FTM2_C0V = cval;
    5bb0:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5bb2:	f44f 7351 	mov.w	r3, #836	; 0x344
    5bb6:	6013      	str	r3, [r2, #0]
		break;
    5bb8:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH1_PIN
	  case FTM0_CH1_PIN: // PTC2, FTM0_CH1
		FTM0_C1V = cval;
    5bba:	494e      	ldr	r1, [pc, #312]	; (5cf4 <analogWrite+0x2c0>)
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5bbc:	4a4e      	ldr	r2, [pc, #312]	; (5cf8 <analogWrite+0x2c4>)
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH1_PIN
	  case FTM0_CH1_PIN: // PTC2, FTM0_CH1
		FTM0_C1V = cval;
    5bbe:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5bc0:	f240 4344 	movw	r3, #1092	; 0x444
    5bc4:	6013      	str	r3, [r2, #0]
		break;
    5bc6:	bd38      	pop	{r3, r4, r5, pc}
	//serial_phex32(cval);
	//serial_print("\n");
	switch (pin) {
#ifdef FTM0_CH0_PIN
	  case FTM0_CH0_PIN: // PTC1, FTM0_CH0
		FTM0_C0V = cval;
    5bc8:	494c      	ldr	r1, [pc, #304]	; (5cfc <analogWrite+0x2c8>)
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5bca:	4a4d      	ldr	r2, [pc, #308]	; (5d00 <analogWrite+0x2cc>)
	//serial_phex32(cval);
	//serial_print("\n");
	switch (pin) {
#ifdef FTM0_CH0_PIN
	  case FTM0_CH0_PIN: // PTC1, FTM0_CH0
		FTM0_C0V = cval;
    5bcc:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5bce:	f240 4344 	movw	r3, #1092	; 0x444
    5bd2:	6013      	str	r3, [r2, #0]
		break;
    5bd4:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH6_PIN
	  case FTM0_CH6_PIN: // PTD6, FTM0_CH6
		FTM0_C6V = cval;
    5bd6:	494b      	ldr	r1, [pc, #300]	; (5d04 <analogWrite+0x2d0>)
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5bd8:	4a4b      	ldr	r2, [pc, #300]	; (5d08 <analogWrite+0x2d4>)
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH6_PIN
	  case FTM0_CH6_PIN: // PTD6, FTM0_CH6
		FTM0_C6V = cval;
    5bda:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5bdc:	f240 4344 	movw	r3, #1092	; 0x444
    5be0:	6013      	str	r3, [r2, #0]
		break;
    5be2:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH5_PIN
	  case FTM0_CH5_PIN: // PTD5, FTM0_CH5
		FTM0_C5V = cval;
    5be4:	4949      	ldr	r1, [pc, #292]	; (5d0c <analogWrite+0x2d8>)
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5be6:	4a4a      	ldr	r2, [pc, #296]	; (5d10 <analogWrite+0x2dc>)
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH5_PIN
	  case FTM0_CH5_PIN: // PTD5, FTM0_CH5
		FTM0_C5V = cval;
    5be8:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5bea:	f240 4344 	movw	r3, #1092	; 0x444
    5bee:	6013      	str	r3, [r2, #0]
		break;
    5bf0:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(TPM1_CH0_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef TPM1_CH1_PIN
	  case TPM1_CH1_PIN:
		TPM1_C1V = cval;
    5bf2:	4948      	ldr	r1, [pc, #288]	; (5d14 <analogWrite+0x2e0>)
		FTM_PINCFG(TPM1_CH1_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
    5bf4:	4a48      	ldr	r2, [pc, #288]	; (5d18 <analogWrite+0x2e4>)
		FTM_PINCFG(TPM1_CH0_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef TPM1_CH1_PIN
	  case TPM1_CH1_PIN:
		TPM1_C1V = cval;
    5bf6:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(TPM1_CH1_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
    5bf8:	f240 6344 	movw	r3, #1604	; 0x644
    5bfc:	6013      	str	r3, [r2, #0]
		break;
    5bfe:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH7_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef TPM1_CH0_PIN
	  case TPM1_CH0_PIN:
		TPM1_C0V = cval;
    5c00:	4946      	ldr	r1, [pc, #280]	; (5d1c <analogWrite+0x2e8>)
		FTM_PINCFG(TPM1_CH0_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c02:	4a47      	ldr	r2, [pc, #284]	; (5d20 <analogWrite+0x2ec>)
		FTM_PINCFG(FTM3_CH7_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef TPM1_CH0_PIN
	  case TPM1_CH0_PIN:
		TPM1_C0V = cval;
    5c04:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(TPM1_CH0_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c06:	f240 6344 	movw	r3, #1604	; 0x644
    5c0a:	6013      	str	r3, [r2, #0]
		break;
    5c0c:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH1_PIN
	  case FTM3_CH1_PIN:
		FTM3_C1V = cval;
    5c0e:	4945      	ldr	r1, [pc, #276]	; (5d24 <analogWrite+0x2f0>)
		FTM_PINCFG(FTM3_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c10:	4a45      	ldr	r2, [pc, #276]	; (5d28 <analogWrite+0x2f4>)
		FTM_PINCFG(FTM3_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH1_PIN
	  case FTM3_CH1_PIN:
		FTM3_C1V = cval;
    5c12:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c14:	f240 4344 	movw	r3, #1092	; 0x444
    5c18:	6013      	str	r3, [r2, #0]
		break;
    5c1a:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH3_PIN
	  case FTM0_CH3_PIN: // PTC4, FTM0_CH3
		FTM0_C3V = cval;
    5c1c:	4943      	ldr	r1, [pc, #268]	; (5d2c <analogWrite+0x2f8>)
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c1e:	4a44      	ldr	r2, [pc, #272]	; (5d30 <analogWrite+0x2fc>)
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH3_PIN
	  case FTM0_CH3_PIN: // PTC4, FTM0_CH3
		FTM0_C3V = cval;
    5c20:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c22:	f240 4344 	movw	r3, #1092	; 0x444
    5c26:	6013      	str	r3, [r2, #0]
		break;
    5c28:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH2_PIN
	  case FTM0_CH2_PIN: // PTC3, FTM0_CH2
		FTM0_C2V = cval;
    5c2a:	4942      	ldr	r1, [pc, #264]	; (5d34 <analogWrite+0x300>)
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c2c:	4a42      	ldr	r2, [pc, #264]	; (5d38 <analogWrite+0x304>)
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH2_PIN
	  case FTM0_CH2_PIN: // PTC3, FTM0_CH2
		FTM0_C2V = cval;
    5c2e:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c30:	f240 4344 	movw	r3, #1092	; 0x444
    5c34:	6013      	str	r3, [r2, #0]
		break;
    5c36:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH3_PIN
	  case FTM3_CH3_PIN:
		FTM3_C3V = cval;
    5c38:	4940      	ldr	r1, [pc, #256]	; (5d3c <analogWrite+0x308>)
		FTM_PINCFG(FTM3_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c3a:	4a41      	ldr	r2, [pc, #260]	; (5d40 <analogWrite+0x30c>)
		FTM_PINCFG(FTM3_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH3_PIN
	  case FTM3_CH3_PIN:
		FTM3_C3V = cval;
    5c3c:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c3e:	f240 4344 	movw	r3, #1092	; 0x444
    5c42:	6013      	str	r3, [r2, #0]
		break;
    5c44:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH2_PIN
	  case FTM3_CH2_PIN:
		FTM3_C2V = cval;
    5c46:	493f      	ldr	r1, [pc, #252]	; (5d44 <analogWrite+0x310>)
		FTM_PINCFG(FTM3_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c48:	4a3f      	ldr	r2, [pc, #252]	; (5d48 <analogWrite+0x314>)
		FTM_PINCFG(FTM3_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH2_PIN
	  case FTM3_CH2_PIN:
		FTM3_C2V = cval;
    5c4a:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c4c:	f240 4344 	movw	r3, #1092	; 0x444
    5c50:	6013      	str	r3, [r2, #0]
		break;
    5c52:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH4_PIN
	  case FTM0_CH4_PIN: // PTD4, FTM0_CH4
		FTM0_C4V = cval;
    5c54:	493d      	ldr	r1, [pc, #244]	; (5d4c <analogWrite+0x318>)
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c56:	4a3e      	ldr	r2, [pc, #248]	; (5d50 <analogWrite+0x31c>)
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH4_PIN
	  case FTM0_CH4_PIN: // PTD4, FTM0_CH4
		FTM0_C4V = cval;
    5c58:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c5a:	f240 4344 	movw	r3, #1092	; 0x444
    5c5e:	6013      	str	r3, [r2, #0]
		break;
    5c60:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH7_PIN
	  case FTM0_CH7_PIN: // PTD7, FTM0_CH7
		FTM0_C7V = cval;
    5c62:	493c      	ldr	r1, [pc, #240]	; (5d54 <analogWrite+0x320>)
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c64:	4a3c      	ldr	r2, [pc, #240]	; (5d58 <analogWrite+0x324>)
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH7_PIN
	  case FTM0_CH7_PIN: // PTD7, FTM0_CH7
		FTM0_C7V = cval;
    5c66:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c68:	f240 4344 	movw	r3, #1092	; 0x444
    5c6c:	6013      	str	r3, [r2, #0]
		break;
    5c6e:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH1_PIN
	  case FTM1_CH1_PIN: // PTA13, FTM1_CH1
		FTM1_C1V = cval;
    5c70:	493a      	ldr	r1, [pc, #232]	; (5d5c <analogWrite+0x328>)
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c72:	4a3b      	ldr	r2, [pc, #236]	; (5d60 <analogWrite+0x32c>)
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH1_PIN
	  case FTM1_CH1_PIN: // PTA13, FTM1_CH1
		FTM1_C1V = cval;
    5c74:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c76:	f44f 7351 	mov.w	r3, #836	; 0x344
    5c7a:	6013      	str	r3, [r2, #0]
		break;
    5c7c:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH0_PIN
	  case FTM1_CH0_PIN: // PTA12, FTM1_CH0
		FTM1_C0V = cval;
    5c7e:	4939      	ldr	r1, [pc, #228]	; (5d64 <analogWrite+0x330>)
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c80:	4a39      	ldr	r2, [pc, #228]	; (5d68 <analogWrite+0x334>)
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH0_PIN
	  case FTM1_CH0_PIN: // PTA12, FTM1_CH0
		FTM1_C0V = cval;
    5c82:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c84:	f44f 7351 	mov.w	r3, #836	; 0x344
    5c88:	6013      	str	r3, [r2, #0]
		break;
    5c8a:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH0_PIN
	  case FTM3_CH0_PIN:
		FTM3_C0V = cval;
    5c8c:	4937      	ldr	r1, [pc, #220]	; (5d6c <analogWrite+0x338>)
		FTM_PINCFG(FTM3_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c8e:	4a38      	ldr	r2, [pc, #224]	; (5d70 <analogWrite+0x33c>)
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH0_PIN
	  case FTM3_CH0_PIN:
		FTM3_C0V = cval;
    5c90:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5c92:	f240 4344 	movw	r3, #1092	; 0x444
    5c96:	6013      	str	r3, [r2, #0]
		break;
    5c98:	bd38      	pop	{r3, r4, r5, pc}

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    5c9a:	2c3f      	cmp	r4, #63	; 0x3f
    5c9c:	f63f aedb 	bhi.w	5a56 <analogWrite+0x22>
    5ca0:	297f      	cmp	r1, #127	; 0x7f
    5ca2:	bfd4      	ite	le
    5ca4:	2100      	movle	r1, #0
    5ca6:	2101      	movgt	r1, #1
    5ca8:	4620      	mov	r0, r4
    5caa:	e749      	b.n	5b40 <analogWrite+0x10c>
    5cac:	1fff0b1c 	.word	0x1fff0b1c
    5cb0:	400c9008 	.word	0x400c9008
    5cb4:	40038008 	.word	0x40038008
    5cb8:	40039008 	.word	0x40039008
    5cbc:	400b9008 	.word	0x400b9008
    5cc0:	400b8008 	.word	0x400b8008
    5cc4:	400b9048 	.word	0x400b9048
    5cc8:	4004b02c 	.word	0x4004b02c
    5ccc:	400b9040 	.word	0x400b9040
    5cd0:	4004b028 	.word	0x4004b028
    5cd4:	400b9038 	.word	0x400b9038
    5cd8:	4004b024 	.word	0x4004b024
    5cdc:	400b9030 	.word	0x400b9030
    5ce0:	4004b020 	.word	0x4004b020
    5ce4:	400b8018 	.word	0x400b8018
    5ce8:	4004a04c 	.word	0x4004a04c
    5cec:	400b8010 	.word	0x400b8010
    5cf0:	4004a048 	.word	0x4004a048
    5cf4:	40038018 	.word	0x40038018
    5cf8:	4004b008 	.word	0x4004b008
    5cfc:	40038010 	.word	0x40038010
    5d00:	4004b004 	.word	0x4004b004
    5d04:	40038040 	.word	0x40038040
    5d08:	4004c018 	.word	0x4004c018
    5d0c:	40038038 	.word	0x40038038
    5d10:	4004c014 	.word	0x4004c014
    5d14:	400c9018 	.word	0x400c9018
    5d18:	4004a004 	.word	0x4004a004
    5d1c:	400c9010 	.word	0x400c9010
    5d20:	4004a000 	.word	0x4004a000
    5d24:	400b9018 	.word	0x400b9018
    5d28:	4004c004 	.word	0x4004c004
    5d2c:	40038028 	.word	0x40038028
    5d30:	4004b010 	.word	0x4004b010
    5d34:	40038020 	.word	0x40038020
    5d38:	4004b00c 	.word	0x4004b00c
    5d3c:	400b9028 	.word	0x400b9028
    5d40:	4004c00c 	.word	0x4004c00c
    5d44:	400b9020 	.word	0x400b9020
    5d48:	4004c008 	.word	0x4004c008
    5d4c:	40038030 	.word	0x40038030
    5d50:	4004c010 	.word	0x4004c010
    5d54:	40038048 	.word	0x40038048
    5d58:	4004c01c 	.word	0x4004c01c
    5d5c:	40039018 	.word	0x40039018
    5d60:	40049034 	.word	0x40049034
    5d64:	40039010 	.word	0x40039010
    5d68:	40049030 	.word	0x40049030
    5d6c:	400b9010 	.word	0x400b9010
    5d70:	4004c000 	.word	0x4004c000

00005d74 <digitalWrite>:
    5d74:	283f      	cmp	r0, #63	; 0x3f
    5d76:	d801      	bhi.n	5d7c <digitalWrite+0x8>
    5d78:	f7ff bd6c 	b.w	5854 <digitalWrite.part.1>
    5d7c:	4770      	bx	lr
    5d7e:	bf00      	nop

00005d80 <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    5d80:	283f      	cmp	r0, #63	; 0x3f
    5d82:	d801      	bhi.n	5d88 <pinMode+0x8>
    5d84:	f7ff bd8c 	b.w	58a0 <pinMode.part.2>
    5d88:	4770      	bx	lr
    5d8a:	bf00      	nop

00005d8c <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    5d8c:	b672      	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    5d8e:	490d      	ldr	r1, [pc, #52]	; (5dc4 <micros+0x38>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    5d90:	4b0d      	ldr	r3, [pc, #52]	; (5dc8 <micros+0x3c>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    5d92:	4a0e      	ldr	r2, [pc, #56]	; (5dcc <micros+0x40>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    5d94:	681b      	ldr	r3, [r3, #0]
	count = systick_millis_count;
    5d96:	6808      	ldr	r0, [r1, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    5d98:	6812      	ldr	r2, [r2, #0]
	__enable_irq();
    5d9a:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    5d9c:	0152      	lsls	r2, r2, #5
    5d9e:	d502      	bpl.n	5da6 <micros+0x1a>
    5da0:	2b32      	cmp	r3, #50	; 0x32
    5da2:	bf88      	it	hi
    5da4:	3001      	addhi	r0, #1
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    5da6:	f5c3 332f 	rsb	r3, r3, #179200	; 0x2bc00
    5daa:	4909      	ldr	r1, [pc, #36]	; (5dd0 <micros+0x44>)
    5dac:	f203 331f 	addw	r3, r3, #799	; 0x31f
    5db0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    5db4:	089b      	lsrs	r3, r3, #2
    5db6:	fba1 1303 	umull	r1, r3, r1, r3
    5dba:	fb02 f000 	mul.w	r0, r2, r0
}
    5dbe:	eb00 0093 	add.w	r0, r0, r3, lsr #2
    5dc2:	4770      	bx	lr
    5dc4:	1fff2ae4 	.word	0x1fff2ae4
    5dc8:	e000e018 	.word	0xe000e018
    5dcc:	e000ed04 	.word	0xe000ed04
    5dd0:	16c16c17 	.word	0x16c16c17

00005dd4 <delay>:

void delay(uint32_t ms)
{
    5dd4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    5dd8:	4605      	mov	r5, r0

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    5dda:	b672      	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    5ddc:	4f22      	ldr	r7, [pc, #136]	; (5e68 <delay+0x94>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    5dde:	4b23      	ldr	r3, [pc, #140]	; (5e6c <delay+0x98>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    5de0:	4a23      	ldr	r2, [pc, #140]	; (5e70 <delay+0x9c>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    5de2:	681b      	ldr	r3, [r3, #0]
	count = systick_millis_count;
    5de4:	683c      	ldr	r4, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    5de6:	6812      	ldr	r2, [r2, #0]
	__enable_irq();
    5de8:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    5dea:	0152      	lsls	r2, r2, #5
    5dec:	d502      	bpl.n	5df4 <delay+0x20>
    5dee:	2b32      	cmp	r3, #50	; 0x32
    5df0:	bf88      	it	hi
    5df2:	3401      	addhi	r4, #1

void delay(uint32_t ms)
{
	uint32_t start = micros();

	if (ms > 0) {
    5df4:	b3b5      	cbz	r5, 5e64 <delay+0x90>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    5df6:	f5c3 332f 	rsb	r3, r3, #179200	; 0x2bc00
    5dfa:	f203 331f 	addw	r3, r3, #799	; 0x31f
    5dfe:	4e1d      	ldr	r6, [pc, #116]	; (5e74 <delay+0xa0>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    5e00:	f8df 9068 	ldr.w	r9, [pc, #104]	; 5e6c <delay+0x98>
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    5e04:	f8df 8068 	ldr.w	r8, [pc, #104]	; 5e70 <delay+0x9c>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    5e08:	089b      	lsrs	r3, r3, #2
    5e0a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    5e0e:	fba6 1303 	umull	r1, r3, r6, r3
    5e12:	fb02 f404 	mul.w	r4, r2, r4
    5e16:	eb04 0493 	add.w	r4, r4, r3, lsr #2

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    5e1a:	b672      	cpsid	i
	current = SYST_CVR;
    5e1c:	f8d9 1000 	ldr.w	r1, [r9]
	count = systick_millis_count;
    5e20:	683a      	ldr	r2, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    5e22:	f8d8 e000 	ldr.w	lr, [r8]
	__enable_irq();
    5e26:	b662      	cpsie	i
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    5e28:	f5c1 332f 	rsb	r3, r1, #179200	; 0x2bc00
    5e2c:	f203 331f 	addw	r3, r3, #799	; 0x31f
    5e30:	089b      	lsrs	r3, r3, #2
    5e32:	fba6 0303 	umull	r0, r3, r6, r3
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    5e36:	f01e 6f80 	tst.w	lr, #67108864	; 0x4000000
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    5e3a:	ebc4 0393 	rsb	r3, r4, r3, lsr #2
    5e3e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    5e42:	d002      	beq.n	5e4a <delay+0x76>
    5e44:	2932      	cmp	r1, #50	; 0x32
    5e46:	bf88      	it	hi
    5e48:	3201      	addhi	r2, #1
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    5e4a:	fb00 3302 	mla	r3, r0, r2, r3
    5e4e:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    5e52:	d304      	bcc.n	5e5e <delay+0x8a>
				ms--;
				if (ms == 0) return;
    5e54:	3d01      	subs	r5, #1
    5e56:	d005      	beq.n	5e64 <delay+0x90>
				start += 1000;
    5e58:	f504 747a 	add.w	r4, r4, #1000	; 0x3e8
    5e5c:	e7dd      	b.n	5e1a <delay+0x46>
			}
			yield();
    5e5e:	f001 f885 	bl	6f6c <yield>
		}
    5e62:	e7da      	b.n	5e1a <delay+0x46>
    5e64:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    5e68:	1fff2ae4 	.word	0x1fff2ae4
    5e6c:	e000e018 	.word	0xe000e018
    5e70:	e000ed04 	.word	0xe000ed04
    5e74:	16c16c17 	.word	0x16c16c17

00005e78 <_init_Teensyduino_internal_>:
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
    5e78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    5e7a:	4b4e      	ldr	r3, [pc, #312]	; (5fb4 <_init_Teensyduino_internal_+0x13c>)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    5e7c:	484e      	ldr	r0, [pc, #312]	; (5fb8 <_init_Teensyduino_internal_+0x140>)
	FTM0_MOD = DEFAULT_FTM_MOD;
    5e7e:	f8df c15c 	ldr.w	ip, [pc, #348]	; 5fdc <_init_Teensyduino_internal_+0x164>
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
    5e82:	4c4e      	ldr	r4, [pc, #312]	; (5fbc <_init_Teensyduino_internal_+0x144>)
	FTM0_C2SC = 0x28;
    5e84:	494e      	ldr	r1, [pc, #312]	; (5fc0 <_init_Teensyduino_internal_+0x148>)
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    5e86:	f8df e158 	ldr.w	lr, [pc, #344]	; 5fe0 <_init_Teensyduino_internal_+0x168>
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
    5e8a:	4e4e      	ldr	r6, [pc, #312]	; (5fc4 <_init_Teensyduino_internal_+0x14c>)
	FTM0_C4SC = 0x28;
    5e8c:	4d4e      	ldr	r5, [pc, #312]	; (5fc8 <_init_Teensyduino_internal_+0x150>)
	FTM0_C5SC = 0x28;
    5e8e:	4f4f      	ldr	r7, [pc, #316]	; (5fcc <_init_Teensyduino_internal_+0x154>)
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    5e90:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    5e94:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    5e96:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    5e9a:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    5e9c:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
    5ea0:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    5ea2:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    5ea6:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    5ea8:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    5eac:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    5eae:	2200      	movs	r2, #0
    5eb0:	6002      	str	r2, [r0, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    5eb2:	2328      	movs	r3, #40	; 0x28
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
    5eb4:	f64e 70ff 	movw	r0, #61439	; 0xefff
    5eb8:	f8cc 0000 	str.w	r0, [ip]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    5ebc:	f8ce 3000 	str.w	r3, [lr]
	FTM0_C1SC = 0x28;
    5ec0:	6023      	str	r3, [r4, #0]
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    5ec2:	f50e 2e01 	add.w	lr, lr, #528384	; 0x81000
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
    5ec6:	600b      	str	r3, [r1, #0]
	FTM0_C3SC = 0x28;
    5ec8:	6033      	str	r3, [r6, #0]
	FTM0_C4SC = 0x28;
    5eca:	602b      	str	r3, [r5, #0]
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    5ecc:	f506 2600 	add.w	r6, r6, #524288	; 0x80000
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
    5ed0:	603b      	str	r3, [r7, #0]
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
    5ed2:	f505 2500 	add.w	r5, r5, #524288	; 0x80000
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
    5ed6:	62a3      	str	r3, [r4, #40]	; 0x28
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
    5ed8:	f507 2700 	add.w	r7, r7, #524288	; 0x80000
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
    5edc:	628b      	str	r3, [r1, #40]	; 0x28
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
    5ede:	f504 2401 	add.w	r4, r4, #528384	; 0x81000
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
    5ee2:	f501 2101 	add.w	r1, r1, #528384	; 0x81000
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    5ee6:	f606 76e8 	addw	r6, r6, #4072	; 0xfe8
	FTM3_C1SC = 0x28;
    5eea:	f605 75e8 	addw	r5, r5, #4072	; 0xfe8
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
    5eee:	f507 677f 	add.w	r7, r7, #4080	; 0xff0
	FTM3_C4SC = 0x28;
    5ef2:	3110      	adds	r1, #16
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    5ef4:	f10e 0e10 	add.w	lr, lr, #16
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
    5ef8:	3420      	adds	r4, #32
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    5efa:	6033      	str	r3, [r6, #0]
	FTM3_C1SC = 0x28;
    5efc:	602b      	str	r3, [r5, #0]
	FTM3_C2SC = 0x28;
    5efe:	f8ce 3000 	str.w	r3, [lr]
	FTM3_C3SC = 0x28;
    5f02:	603b      	str	r3, [r7, #0]
	FTM3_C4SC = 0x28;
    5f04:	600b      	str	r3, [r1, #0]
	FTM3_C5SC = 0x28;
    5f06:	6023      	str	r3, [r4, #0]
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    5f08:	4c31      	ldr	r4, [pc, #196]	; (5fd0 <_init_Teensyduino_internal_+0x158>)
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
    5f0a:	61bb      	str	r3, [r7, #24]
	FTM3_C7SC = 0x28;
    5f0c:	618b      	str	r3, [r1, #24]
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    5f0e:	2109      	movs	r1, #9
    5f10:	6021      	str	r1, [r4, #0]
	FTM1_CNT = 0;
    5f12:	f5a7 2700 	sub.w	r7, r7, #524288	; 0x80000
	FTM1_MOD = DEFAULT_FTM_MOD;
    5f16:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
    5f1a:	3f20      	subs	r7, #32
	FTM1_MOD = DEFAULT_FTM_MOD;
    5f1c:	3408      	adds	r4, #8
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
    5f1e:	603a      	str	r2, [r7, #0]
	FTM1_MOD = DEFAULT_FTM_MOD;
    5f20:	6020      	str	r0, [r4, #0]
	FTM1_C0SC = 0x28;
    5f22:	60bb      	str	r3, [r7, #8]
	FTM1_C1SC = 0x28;
    5f24:	60e3      	str	r3, [r4, #12]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    5f26:	f847 1c04 	str.w	r1, [r7, #-4]
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    5f2a:	f504 24fd 	add.w	r4, r4, #518144	; 0x7e800
	FTM2_MOD = DEFAULT_FTM_MOD;
    5f2e:	f507 27fe 	add.w	r7, r7, #520192	; 0x7f000
    5f32:	3704      	adds	r7, #4
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    5f34:	f204 74fc 	addw	r4, r4, #2044	; 0x7fc
    5f38:	6022      	str	r2, [r4, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
    5f3a:	6038      	str	r0, [r7, #0]
	FTM2_C0SC = 0x28;
    5f3c:	60a3      	str	r3, [r4, #8]
	FTM2_C1SC = 0x28;
    5f3e:	60fb      	str	r3, [r7, #12]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    5f40:	f844 1c04 	str.w	r1, [r4, #-4]
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
	FTM2_MOD = DEFAULT_FTM_MOD;
	FTM2_C0SC = 0x28;
    5f44:	3408      	adds	r4, #8
	FTM2_C1SC = 0x28;
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
    5f46:	f604 74fc 	addw	r4, r4, #4092	; 0xffc
	FTM2_C0SC = 0x28;
	FTM2_C1SC = 0x28;
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
    5f4a:	f8c7 2ffc 	str.w	r2, [r7, #4092]	; 0xffc
	FTM3_MOD = DEFAULT_FTM_MOD;
    5f4e:	6020      	str	r0, [r4, #0]
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    5f50:	f5a4 24e1 	sub.w	r4, r4, #460800	; 0x70800
    5f54:	f2a4 74dc 	subw	r4, r4, #2012	; 0x7dc
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
	FTM3_C0SC = 0x28;
    5f58:	6033      	str	r3, [r6, #0]
	FTM3_C1SC = 0x28;
    5f5a:	602b      	str	r3, [r5, #0]
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    5f5c:	f8c7 1ff8 	str.w	r1, [r7, #4088]	; 0xff8
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    5f60:	6821      	ldr	r1, [r4, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    5f62:	481c      	ldr	r0, [pc, #112]	; (5fd4 <_init_Teensyduino_internal_+0x15c>)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    5f64:	f441 7100 	orr.w	r1, r1, #512	; 0x200
    5f68:	6021      	str	r1, [r4, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    5f6a:	6801      	ldr	r1, [r0, #0]
	TPM1_CNT = 0;
	TPM1_MOD = 32767;
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    5f6c:	4c1a      	ldr	r4, [pc, #104]	; (5fd8 <_init_Teensyduino_internal_+0x160>)
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
	TPM1_CNT = 0;
    5f6e:	f50e 4e7f 	add.w	lr, lr, #65280	; 0xff00
    5f72:	f10e 0ee8 	add.w	lr, lr, #232	; 0xe8
	TPM1_MOD = 32767;
    5f76:	f507 3788 	add.w	r7, r7, #69632	; 0x11000
	TPM1_C0SC = 0x28;
    5f7a:	f506 3680 	add.w	r6, r6, #65536	; 0x10000
	TPM1_C1SC = 0x28;
    5f7e:	f505 3580 	add.w	r5, r5, #65536	; 0x10000
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    5f82:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
    5f86:	6001      	str	r1, [r0, #0]
	TPM1_CNT = 0;
    5f88:	f8ce 2000 	str.w	r2, [lr]
	TPM1_MOD = 32767;
    5f8c:	f647 71ff 	movw	r1, #32767	; 0x7fff
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    5f90:	2208      	movs	r2, #8
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
	TPM1_CNT = 0;
	TPM1_MOD = 32767;
    5f92:	6039      	str	r1, [r7, #0]
	TPM1_C0SC = 0x28;
    5f94:	6033      	str	r3, [r6, #0]
	TPM1_C1SC = 0x28;
    5f96:	602b      	str	r3, [r5, #0]
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    5f98:	6022      	str	r2, [r4, #0]
#endif
	analog_init();
    5f9a:	f001 f85d 	bl	7058 <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
    5f9e:	2019      	movs	r0, #25
    5fa0:	f7ff ff18 	bl	5dd4 <delay>
	usb_init();
    5fa4:	f000 fd10 	bl	69c8 <usb_init>
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    5fa8:	f240 1013 	movw	r0, #275	; 0x113
}
    5fac:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
	usb_init();
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    5fb0:	f7ff bf10 	b.w	5dd4 <delay>
    5fb4:	e000e104 	.word	0xe000e104
    5fb8:	40038004 	.word	0x40038004
    5fbc:	40038014 	.word	0x40038014
    5fc0:	4003801c 	.word	0x4003801c
    5fc4:	40038024 	.word	0x40038024
    5fc8:	4003802c 	.word	0x4003802c
    5fcc:	40038034 	.word	0x40038034
    5fd0:	40038000 	.word	0x40038000
    5fd4:	40048004 	.word	0x40048004
    5fd8:	400c9000 	.word	0x400c9000
    5fdc:	40038008 	.word	0x40038008
    5fe0:	4003800c 	.word	0x4003800c

00005fe4 <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    5fe4:	1e43      	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    5fe6:	2b03      	cmp	r3, #3
    5fe8:	d814      	bhi.n	6014 <usb_rx+0x30>
	__disable_irq();
    5fea:	b672      	cpsid	i
	ret = rx_first[endpoint];
    5fec:	490a      	ldr	r1, [pc, #40]	; (6018 <usb_rx+0x34>)
    5fee:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
	if (ret) {
    5ff2:	b168      	cbz	r0, 6010 <usb_rx+0x2c>




usb_packet_t *usb_rx(uint32_t endpoint)
{
    5ff4:	b470      	push	{r4, r5, r6}
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
    5ff6:	4c09      	ldr	r4, [pc, #36]	; (601c <usb_rx+0x38>)
    5ff8:	8805      	ldrh	r5, [r0, #0]
    5ffa:	f834 2013 	ldrh.w	r2, [r4, r3, lsl #1]
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
    5ffe:	6846      	ldr	r6, [r0, #4]
    6000:	f841 6023 	str.w	r6, [r1, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    6004:	1b52      	subs	r2, r2, r5
    6006:	f824 2013 	strh.w	r2, [r4, r3, lsl #1]
	}
	__enable_irq();
    600a:	b662      	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    600c:	bc70      	pop	{r4, r5, r6}
    600e:	4770      	bx	lr
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
	}
	__enable_irq();
    6010:	b662      	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    6012:	4770      	bx	lr

usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    6014:	2000      	movs	r0, #0
    6016:	4770      	bx	lr
    6018:	1fff2b40 	.word	0x1fff2b40
    601c:	1fff2c48 	.word	0x1fff2c48

00006020 <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    6020:	3801      	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    6022:	2803      	cmp	r0, #3
    6024:	d80b      	bhi.n	603e <usb_tx_packet_count+0x1e>
	__disable_irq();
    6026:	b672      	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    6028:	4b07      	ldr	r3, [pc, #28]	; (6048 <usb_tx_packet_count+0x28>)
    602a:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    602e:	b143      	cbz	r3, 6042 <usb_tx_packet_count+0x22>
    6030:	2000      	movs	r0, #0
    6032:	685b      	ldr	r3, [r3, #4]
    6034:	3001      	adds	r0, #1
    6036:	2b00      	cmp	r3, #0
    6038:	d1fb      	bne.n	6032 <usb_tx_packet_count+0x12>
	__enable_irq();
    603a:	b662      	cpsie	i
	return count;
    603c:	4770      	bx	lr
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
    603e:	2000      	movs	r0, #0
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
	__enable_irq();
	return count;
}
    6040:	4770      	bx	lr
// https://forum.pjrc.com/threads/58663?p=223513&viewfull=1#post223513
//
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;
    6042:	4618      	mov	r0, r3
    6044:	e7f9      	b.n	603a <usb_tx_packet_count+0x1a>
    6046:	bf00      	nop
    6048:	1fff2b94 	.word	0x1fff2b94

0000604c <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    604c:	b4f0      	push	{r4, r5, r6, r7}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    604e:	b672      	cpsid	i
void usb_rx_memory(usb_packet_t *packet)
{
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
    6050:	491a      	ldr	r1, [pc, #104]	; (60bc <usb_rx_memory+0x70>)
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
    6052:	4e1b      	ldr	r6, [pc, #108]	; (60c0 <usb_rx_memory+0x74>)
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    6054:	2301      	movs	r3, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    6056:	f811 4b01 	ldrb.w	r4, [r1], #1
			if (table[index(i, RX, EVEN)].desc == 0) {
    605a:	4f19      	ldr	r7, [pc, #100]	; (60c0 <usb_rx_memory+0x74>)
    605c:	009a      	lsls	r2, r3, #2
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    605e:	0724      	lsls	r4, r4, #28
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    6060:	f042 0501 	orr.w	r5, r2, #1
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    6064:	d505      	bpl.n	6072 <usb_rx_memory+0x26>
			if (table[index(i, RX, EVEN)].desc == 0) {
    6066:	f856 4032 	ldr.w	r4, [r6, r2, lsl #3]
    606a:	b164      	cbz	r4, 6086 <usb_rx_memory+0x3a>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    606c:	f856 2035 	ldr.w	r2, [r6, r5, lsl #3]
    6070:	b1ba      	cbz	r2, 60a2 <usb_rx_memory+0x56>
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    6072:	3301      	adds	r3, #1
    6074:	2b05      	cmp	r3, #5
    6076:	d1ee      	bne.n	6056 <usb_rx_memory+0xa>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    6078:	b662      	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    607a:	4b12      	ldr	r3, [pc, #72]	; (60c4 <usb_rx_memory+0x78>)
    607c:	2200      	movs	r2, #0
    607e:	701a      	strb	r2, [r3, #0]
	usb_free(packet);
	return;
}
    6080:	bcf0      	pop	{r4, r5, r6, r7}
	__enable_irq();
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
    6082:	f000 bd23 	b.w	6acc <usb_free>
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    6086:	4c0f      	ldr	r4, [pc, #60]	; (60c4 <usb_rx_memory+0x78>)
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    6088:	4d0f      	ldr	r5, [pc, #60]	; (60c8 <usb_rx_memory+0x7c>)
				usb_rx_memory_needed--;
    608a:	7821      	ldrb	r1, [r4, #0]
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    608c:	eb07 1343 	add.w	r3, r7, r3, lsl #5
    6090:	3008      	adds	r0, #8
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    6092:	3901      	subs	r1, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    6094:	6058      	str	r0, [r3, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    6096:	7021      	strb	r1, [r4, #0]
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    6098:	f847 5032 	str.w	r5, [r7, r2, lsl #3]
				usb_rx_memory_needed--;
				__enable_irq();
    609c:	b662      	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
	return;
}
    609e:	bcf0      	pop	{r4, r5, r6, r7}
    60a0:	4770      	bx	lr
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    60a2:	4a08      	ldr	r2, [pc, #32]	; (60c4 <usb_rx_memory+0x78>)
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    60a4:	4909      	ldr	r1, [pc, #36]	; (60cc <usb_rx_memory+0x80>)
				usb_rx_memory_needed--;
    60a6:	7813      	ldrb	r3, [r2, #0]
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    60a8:	eb07 04c5 	add.w	r4, r7, r5, lsl #3
    60ac:	3008      	adds	r0, #8
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    60ae:	3b01      	subs	r3, #1
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    60b0:	6060      	str	r0, [r4, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    60b2:	7013      	strb	r3, [r2, #0]
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    60b4:	f847 1035 	str.w	r1, [r7, r5, lsl #3]
				usb_rx_memory_needed--;
				__enable_irq();
    60b8:	b662      	cpsie	i
				//serial_phex(i);
				//serial_print(",odd\n");
				return;
    60ba:	e7f0      	b.n	609e <usb_rx_memory+0x52>
    60bc:	000096b0 	.word	0x000096b0
    60c0:	1fff0000 	.word	0x1fff0000
    60c4:	1fff2bbd 	.word	0x1fff2bbd
    60c8:	00400088 	.word	0x00400088
    60cc:	004000c8 	.word	0x004000c8

000060d0 <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    60d0:	1e43      	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    60d2:	2b03      	cmp	r3, #3
    60d4:	d81d      	bhi.n	6112 <usb_tx+0x42>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    60d6:	4a1b      	ldr	r2, [pc, #108]	; (6144 <usb_tx+0x74>)
    60d8:	0140      	lsls	r0, r0, #5
    60da:	f040 0010 	orr.w	r0, r0, #16

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
    60de:	b430      	push	{r4, r5}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    60e0:	4410      	add	r0, r2
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
	__disable_irq();
    60e2:	b672      	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    60e4:	4c18      	ldr	r4, [pc, #96]	; (6148 <usb_tx+0x78>)
    60e6:	5ce2      	ldrb	r2, [r4, r3]
    60e8:	2a03      	cmp	r2, #3
    60ea:	d81b      	bhi.n	6124 <usb_tx+0x54>
    60ec:	e8df f002 	tbb	[pc, r2]
    60f0:	17151202 	.word	0x17151202
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    60f4:	2203      	movs	r2, #3
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    60f6:	880d      	ldrh	r5, [r1, #0]
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    60f8:	54e2      	strb	r2, [r4, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    60fa:	f010 0f08 	tst.w	r0, #8
    60fe:	bf14      	ite	ne
    6100:	23c8      	movne	r3, #200	; 0xc8
    6102:	2388      	moveq	r3, #136	; 0x88
    6104:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    6108:	3108      	adds	r1, #8
    610a:	6041      	str	r1, [r0, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    610c:	6003      	str	r3, [r0, #0]
	__enable_irq();
    610e:	b662      	cpsie	i
}
    6110:	bc30      	pop	{r4, r5}
    6112:	4770      	bx	lr
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    6114:	3008      	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    6116:	2202      	movs	r2, #2
		break;
    6118:	e7ed      	b.n	60f6 <usb_tx+0x26>
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    611a:	2205      	movs	r2, #5
    611c:	e7eb      	b.n	60f6 <usb_tx+0x26>
		break;
	  case TX_STATE_ODD_FREE:
		b++;
    611e:	3008      	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    6120:	2204      	movs	r2, #4
		break;
    6122:	e7e8      	b.n	60f6 <usb_tx+0x26>
	  default:
		if (tx_first[endpoint] == NULL) {
    6124:	4a09      	ldr	r2, [pc, #36]	; (614c <usb_tx+0x7c>)
    6126:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    612a:	b138      	cbz	r0, 613c <usb_tx+0x6c>
			tx_first[endpoint] = packet;
		} else {
			tx_last[endpoint]->next = packet;
    612c:	4a08      	ldr	r2, [pc, #32]	; (6150 <usb_tx+0x80>)
    612e:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    6132:	6041      	str	r1, [r0, #4]
		}
		tx_last[endpoint] = packet;
    6134:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		__enable_irq();
    6138:	b662      	cpsie	i
		return;
    613a:	e7e9      	b.n	6110 <usb_tx+0x40>
		b++;
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
		break;
	  default:
		if (tx_first[endpoint] == NULL) {
			tx_first[endpoint] = packet;
    613c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    6140:	4a03      	ldr	r2, [pc, #12]	; (6150 <usb_tx+0x80>)
    6142:	e7f7      	b.n	6134 <usb_tx+0x64>
    6144:	1fff0000 	.word	0x1fff0000
    6148:	1fff2bcc 	.word	0x1fff2bcc
    614c:	1fff2b94 	.word	0x1fff2b94
    6150:	1fff2ba4 	.word	0x1fff2ba4

00006154 <usb_isr>:
}



void usb_isr(void)
{
    6154:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    6158:	f8df b314 	ldr.w	fp, [pc, #788]	; 6470 <usb_isr+0x31c>
		USB0_ISTAT = USB_ISTAT_SOFTOK;
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
		uint8_t endpoint;
		stat = USB0_STAT;
    615c:	f8df a314 	ldr.w	sl, [pc, #788]	; 6474 <usb_isr+0x320>
}



void usb_isr(void)
{
    6160:	b087      	sub	sp, #28
    6162:	e044      	b.n	61ee <usb_isr+0x9a>
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    6164:	4fad      	ldr	r7, [pc, #692]	; (641c <usb_isr+0x2c8>)
    6166:	ea4f 0893 	mov.w	r8, r3, lsr #2
    616a:	eb07 09c8 	add.w	r9, r7, r8, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    616e:	3e01      	subs	r6, #1
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    6170:	f8d9 2004 	ldr.w	r2, [r9, #4]
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    6174:	f003 0308 	and.w	r3, r3, #8
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    6178:	b2f6      	uxtb	r6, r6
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    617a:	f1a2 0008 	sub.w	r0, r2, #8
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    617e:	f003 04ff 	and.w	r4, r3, #255	; 0xff
    6182:	2b00      	cmp	r3, #0
    6184:	f040 8103 	bne.w	638e <usb_isr+0x23a>
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
    6188:	f857 3038 	ldr.w	r3, [r7, r8, lsl #3]
    618c:	0c1b      	lsrs	r3, r3, #16
    618e:	b299      	uxth	r1, r3
    6190:	f822 1c08 	strh.w	r1, [r2, #-8]
				if (packet->len > 0) {
    6194:	2b00      	cmp	r3, #0
    6196:	f000 80f1 	beq.w	637c <usb_isr+0x228>
					packet->index = 0;
					packet->next = NULL;
					if (rx_first[endpoint] == NULL) {
    619a:	4ba1      	ldr	r3, [pc, #644]	; (6420 <usb_isr+0x2cc>)
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
				if (packet->len > 0) {
					packet->index = 0;
    619c:	f822 4c06 	strh.w	r4, [r2, #-6]
					packet->next = NULL;
    61a0:	f842 4c04 	str.w	r4, [r2, #-4]
					if (rx_first[endpoint] == NULL) {
    61a4:	f853 2026 	ldr.w	r2, [r3, r6, lsl #2]
    61a8:	2a00      	cmp	r2, #0
    61aa:	f000 816c 	beq.w	6486 <usb_isr+0x332>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
    61ae:	4d9d      	ldr	r5, [pc, #628]	; (6424 <usb_isr+0x2d0>)
    61b0:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
    61b4:	6058      	str	r0, [r3, #4]
					}
					rx_last[endpoint] = packet;
					usb_rx_byte_count_data[endpoint] += packet->len;
    61b6:	4c9c      	ldr	r4, [pc, #624]	; (6428 <usb_isr+0x2d4>)
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
					}
					rx_last[endpoint] = packet;
    61b8:	f845 0026 	str.w	r0, [r5, r6, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    61bc:	f834 3016 	ldrh.w	r3, [r4, r6, lsl #1]
    61c0:	4419      	add	r1, r3
    61c2:	f824 1016 	strh.w	r1, [r4, r6, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
    61c6:	f000 fc61 	bl	6a8c <usb_malloc>
					if (packet) {
    61ca:	2800      	cmp	r0, #0
    61cc:	f000 8154 	beq.w	6478 <usb_isr+0x324>
						b->addr = packet->buf;
						b->desc = BDT_DESC(64,
    61d0:	4a96      	ldr	r2, [pc, #600]	; (642c <usb_isr+0x2d8>)
    61d2:	4b97      	ldr	r3, [pc, #604]	; (6430 <usb_isr+0x2dc>)
    61d4:	f019 0f08 	tst.w	r9, #8
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    61d8:	f100 0008 	add.w	r0, r0, #8
						b->desc = BDT_DESC(64,
    61dc:	bf18      	it	ne
    61de:	4613      	movne	r3, r2
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    61e0:	f8c9 0004 	str.w	r0, [r9, #4]
						b->desc = BDT_DESC(64,
    61e4:	f847 3038 	str.w	r3, [r7, r8, lsl #3]
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    61e8:	2308      	movs	r3, #8
    61ea:	f88b 3000 	strb.w	r3, [fp]
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    61ee:	f89b 4000 	ldrb.w	r4, [fp]
    61f2:	b2e4      	uxtb	r4, r4

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    61f4:	0760      	lsls	r0, r4, #29
    61f6:	d51b      	bpl.n	6230 <usb_isr+0xdc>
		if (usb_configuration) {
    61f8:	4b8e      	ldr	r3, [pc, #568]	; (6434 <usb_isr+0x2e0>)
    61fa:	781b      	ldrb	r3, [r3, #0]
    61fc:	b1ab      	cbz	r3, 622a <usb_isr+0xd6>
			t = usb_reboot_timer;
    61fe:	498e      	ldr	r1, [pc, #568]	; (6438 <usb_isr+0x2e4>)
    6200:	780a      	ldrb	r2, [r1, #0]
			if (t) {
    6202:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    6206:	b12a      	cbz	r2, 6214 <usb_isr+0xc0>
				usb_reboot_timer = --t;
    6208:	3b01      	subs	r3, #1
    620a:	b2db      	uxtb	r3, r3
    620c:	700b      	strb	r3, [r1, #0]
				if (!t) _reboot_Teensyduino_();
    620e:	2b00      	cmp	r3, #0
    6210:	f000 83b5 	beq.w	697e <usb_isr+0x82a>
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
    6214:	4989      	ldr	r1, [pc, #548]	; (643c <usb_isr+0x2e8>)
    6216:	780a      	ldrb	r2, [r1, #0]
			if (t) {
    6218:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    621c:	b12a      	cbz	r2, 622a <usb_isr+0xd6>
				usb_cdc_transmit_flush_timer = --t;
    621e:	3b01      	subs	r3, #1
    6220:	b2db      	uxtb	r3, r3
    6222:	700b      	strb	r3, [r1, #0]
				if (t == 0) usb_serial_flush_callback();
    6224:	2b00      	cmp	r3, #0
    6226:	f000 80f6 	beq.w	6416 <usb_isr+0x2c2>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    622a:	2304      	movs	r3, #4
    622c:	f88b 3000 	strb.w	r3, [fp]
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    6230:	f004 0308 	and.w	r3, r4, #8
    6234:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    6238:	2b00      	cmp	r3, #0
    623a:	f000 80d5 	beq.w	63e8 <usb_isr+0x294>
		uint8_t endpoint;
		stat = USB0_STAT;
    623e:	f89a 3000 	ldrb.w	r3, [sl]
    6242:	b2db      	uxtb	r3, r3
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
    6244:	091e      	lsrs	r6, r3, #4
    6246:	d18d      	bne.n	6164 <usb_isr+0x10>
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    6248:	089c      	lsrs	r4, r3, #2
    624a:	4f74      	ldr	r7, [pc, #464]	; (641c <usb_isr+0x2c8>)
	pid = BDT_PID(b->desc);
    624c:	f857 2034 	ldr.w	r2, [r7, r4, lsl #3]
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    6250:	eb07 01c4 	add.w	r1, r7, r4, lsl #3
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    6254:	f3c2 0283 	ubfx	r2, r2, #2, #4
    6258:	3a01      	subs	r2, #1
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
	//count = b->desc >> 16;
	buf = b->addr;
    625a:	6849      	ldr	r1, [r1, #4]
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    625c:	2a0c      	cmp	r2, #12
    625e:	d87e      	bhi.n	635e <usb_isr+0x20a>
    6260:	e8df f002 	tbb	[pc, r2]
    6264:	7d7d8181 	.word	0x7d7d8181
    6268:	7d7d7d7d 	.word	0x7d7d7d7d
    626c:	7d7d7d42 	.word	0x7d7d7d42
    6270:	07          	.byte	0x07
    6271:	00          	.byte	0x00
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    6272:	6808      	ldr	r0, [r1, #0]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    6274:	4b72      	ldr	r3, [pc, #456]	; (6440 <usb_isr+0x2ec>)
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    6276:	4d73      	ldr	r5, [pc, #460]	; (6444 <usb_isr+0x2f0>)
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    6278:	9301      	str	r3, [sp, #4]
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    627a:	4b6c      	ldr	r3, [pc, #432]	; (642c <usb_isr+0x2d8>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    627c:	684a      	ldr	r2, [r1, #4]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    627e:	4e72      	ldr	r6, [pc, #456]	; (6448 <usb_isr+0x2f4>)
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    6280:	f847 3034 	str.w	r3, [r7, r4, lsl #3]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    6284:	b281      	uxth	r1, r0
    6286:	f240 6481 	movw	r4, #1665	; 0x681
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    628a:	4b6d      	ldr	r3, [pc, #436]	; (6440 <usb_isr+0x2ec>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    628c:	606a      	str	r2, [r5, #4]
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    628e:	6028      	str	r0, [r5, #0]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    6290:	2200      	movs	r2, #0
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    6292:	2001      	movs	r0, #1
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    6294:	42a1      	cmp	r1, r4
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    6296:	613a      	str	r2, [r7, #16]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    6298:	601a      	str	r2, [r3, #0]
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
    629a:	61ba      	str	r2, [r7, #24]
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    629c:	7030      	strb	r0, [r6, #0]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    629e:	f200 80f6 	bhi.w	648e <usb_isr+0x33a>
    62a2:	f5b1 6fd0 	cmp.w	r1, #1664	; 0x680
    62a6:	f080 82e8 	bcs.w	687a <usb_isr+0x726>
    62aa:	f5b1 7f81 	cmp.w	r1, #258	; 0x102
    62ae:	f000 82d3 	beq.w	6858 <usb_isr+0x704>
    62b2:	f200 81d8 	bhi.w	6666 <usb_isr+0x512>
    62b6:	2980      	cmp	r1, #128	; 0x80
    62b8:	f000 814d 	beq.w	6556 <usb_isr+0x402>
    62bc:	2982      	cmp	r1, #130	; 0x82
    62be:	f040 8292 	bne.w	67e6 <usb_isr+0x692>
    62c2:	88a9      	ldrh	r1, [r5, #4]
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    62c4:	4b61      	ldr	r3, [pc, #388]	; (644c <usb_isr+0x2f8>)
    62c6:	f001 017f 	and.w	r1, r1, #127	; 0x7f
		datalen = 2;
		data = reply_buffer;
		break;
	  case 0x0082: // GET_STATUS (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS) {
    62ca:	2904      	cmp	r1, #4
    62cc:	f200 828c 	bhi.w	67e8 <usb_isr+0x694>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    62d0:	4c5f      	ldr	r4, [pc, #380]	; (6450 <usb_isr+0x2fc>)
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    62d2:	0089      	lsls	r1, r1, #2
    62d4:	440b      	add	r3, r1
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    62d6:	7022      	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    62d8:	7062      	strb	r2, [r4, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    62da:	781a      	ldrb	r2, [r3, #0]
    62dc:	0793      	lsls	r3, r2, #30
    62de:	f140 8338 	bpl.w	6952 <usb_isr+0x7fe>
    62e2:	7020      	strb	r0, [r4, #0]
		data = reply_buffer;
		datalen = 2;
    62e4:	2002      	movs	r0, #2
    62e6:	e13a      	b.n	655e <usb_isr+0x40a>
		//serial_print("PID=IN:");
		//serial_phex(stat);
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
    62e8:	4b55      	ldr	r3, [pc, #340]	; (6440 <usb_isr+0x2ec>)
    62ea:	9301      	str	r3, [sp, #4]
    62ec:	681a      	ldr	r2, [r3, #0]
		if (data) {
    62ee:	b362      	cbz	r2, 634a <usb_isr+0x1f6>
			size = ep0_tx_len;
    62f0:	4b58      	ldr	r3, [pc, #352]	; (6454 <usb_isr+0x300>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    62f2:	4959      	ldr	r1, [pc, #356]	; (6458 <usb_isr+0x304>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    62f4:	4e54      	ldr	r6, [pc, #336]	; (6448 <usb_isr+0x2f4>)
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
    62f6:	8818      	ldrh	r0, [r3, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    62f8:	780c      	ldrb	r4, [r1, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    62fa:	f896 e000 	ldrb.w	lr, [r6]
    62fe:	2840      	cmp	r0, #64	; 0x40
    6300:	4605      	mov	r5, r0
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    6302:	f084 0c01 	eor.w	ip, r4, #1
    6306:	bf28      	it	cs
    6308:	2540      	movcs	r5, #64	; 0x40
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    630a:	f044 0402 	orr.w	r4, r4, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    630e:	f1be 0f00 	cmp.w	lr, #0
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    6312:	f881 c000 	strb.w	ip, [r1]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    6316:	eba0 0005 	sub.w	r0, r0, r5
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    631a:	eb07 0cc4 	add.w	ip, r7, r4, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    631e:	bf0c      	ite	eq
    6320:	2188      	moveq	r1, #136	; 0x88
    6322:	21c8      	movne	r1, #200	; 0xc8
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    6324:	b280      	uxth	r0, r0
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    6326:	f08e 0e01 	eor.w	lr, lr, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    632a:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    632e:	f8cc 2004 	str.w	r2, [ip, #4]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    6332:	8018      	strh	r0, [r3, #0]
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    6334:	f886 e000 	strb.w	lr, [r6]
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    6338:	442a      	add	r2, r5
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    633a:	f847 1034 	str.w	r1, [r7, r4, lsl #3]
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    633e:	b910      	cbnz	r0, 6346 <usb_isr+0x1f2>
    6340:	2d40      	cmp	r5, #64	; 0x40
    6342:	bf18      	it	ne
    6344:	2200      	movne	r2, #0
    6346:	9b01      	ldr	r3, [sp, #4]
    6348:	601a      	str	r2, [r3, #0]
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    634a:	4b3e      	ldr	r3, [pc, #248]	; (6444 <usb_isr+0x2f0>)
    634c:	881a      	ldrh	r2, [r3, #0]
    634e:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
    6352:	d104      	bne.n	635e <usb_isr+0x20a>
			setup.bRequest = 0;
    6354:	2100      	movs	r1, #0
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    6356:	789a      	ldrb	r2, [r3, #2]
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
			setup.bRequest = 0;
    6358:	7059      	strb	r1, [r3, #1]
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    635a:	4b40      	ldr	r3, [pc, #256]	; (645c <usb_isr+0x308>)
    635c:	701a      	strb	r2, [r3, #0]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    635e:	4a40      	ldr	r2, [pc, #256]	; (6460 <usb_isr+0x30c>)
    6360:	2301      	movs	r3, #1
    6362:	7013      	strb	r3, [r2, #0]
    6364:	e740      	b.n	61e8 <usb_isr+0x94>
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
		break;
	case 0x01:  // OUT transaction received from host
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    6366:	4a37      	ldr	r2, [pc, #220]	; (6444 <usb_isr+0x2f0>)
    6368:	8815      	ldrh	r5, [r2, #0]
    636a:	f242 0021 	movw	r0, #8225	; 0x2021
    636e:	4285      	cmp	r5, r0
    6370:	f000 8152 	beq.w	6618 <usb_isr+0x4c4>
		if (usb_audio_set_feature(&setup, buf)) {
			endpoint0_transmit(NULL, 0);
		}
#endif
		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    6374:	4a2d      	ldr	r2, [pc, #180]	; (642c <usb_isr+0x2d8>)
    6376:	f847 2034 	str.w	r2, [r7, r4, lsl #3]
    637a:	e7f0      	b.n	635e <usb_isr+0x20a>
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
					}
				} else {
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    637c:	4a2b      	ldr	r2, [pc, #172]	; (642c <usb_isr+0x2d8>)
    637e:	4b2c      	ldr	r3, [pc, #176]	; (6430 <usb_isr+0x2dc>)
    6380:	f019 0f08 	tst.w	r9, #8
    6384:	bf18      	it	ne
    6386:	4613      	movne	r3, r2
    6388:	f847 3038 	str.w	r3, [r7, r8, lsl #3]
    638c:	e72c      	b.n	61e8 <usb_isr+0x94>
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
    638e:	f000 fb9d 	bl	6acc <usb_free>
				packet = tx_first[endpoint];
    6392:	4a34      	ldr	r2, [pc, #208]	; (6464 <usb_isr+0x310>)
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    6394:	4934      	ldr	r1, [pc, #208]	; (6468 <usb_isr+0x314>)
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
    6396:	f852 3026 	ldr.w	r3, [r2, r6, lsl #2]
				if (packet) {
    639a:	2b00      	cmp	r3, #0
    639c:	f000 812d 	beq.w	65fa <usb_isr+0x4a6>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    63a0:	6858      	ldr	r0, [r3, #4]
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    63a2:	5d8c      	ldrb	r4, [r1, r6]
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    63a4:	f842 0026 	str.w	r0, [r2, r6, lsl #2]
					b->addr = packet->buf;
    63a8:	f103 0208 	add.w	r2, r3, #8
    63ac:	f8c9 2004 	str.w	r2, [r9, #4]
					switch (tx_state[endpoint]) {
    63b0:	2c03      	cmp	r4, #3
    63b2:	d805      	bhi.n	63c0 <usb_isr+0x26c>
    63b4:	e8df f004 	tbb	[pc, r4]
    63b8:	02150f12 	.word	0x02150f12
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    63bc:	2204      	movs	r2, #4
    63be:	558a      	strb	r2, [r1, r6]
						break;
					  default:
						break;
					}
					b->desc = BDT_DESC(packet->len,
    63c0:	881a      	ldrh	r2, [r3, #0]
    63c2:	f019 0f08 	tst.w	r9, #8
    63c6:	bf0c      	ite	eq
    63c8:	2388      	moveq	r3, #136	; 0x88
    63ca:	23c8      	movne	r3, #200	; 0xc8
    63cc:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    63d0:	f847 3038 	str.w	r3, [r7, r8, lsl #3]
    63d4:	e708      	b.n	61e8 <usb_isr+0x94>
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    63d6:	2202      	movs	r2, #2
    63d8:	558a      	strb	r2, [r1, r6]
						break;
    63da:	e7f1      	b.n	63c0 <usb_isr+0x26c>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    63dc:	2203      	movs	r2, #3
    63de:	558a      	strb	r2, [r1, r6]
						break;
    63e0:	e7ee      	b.n	63c0 <usb_isr+0x26c>
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    63e2:	2205      	movs	r2, #5
    63e4:	558a      	strb	r2, [r1, r6]
						break;
    63e6:	e7eb      	b.n	63c0 <usb_isr+0x26c>
		goto restart;
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    63e8:	07e0      	lsls	r0, r4, #31
    63ea:	f100 8178 	bmi.w	66de <usb_isr+0x58a>
		USB0_CTL = USB_CTL_USBENSOFEN;
		return;
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    63ee:	0621      	lsls	r1, r4, #24
    63f0:	f100 81a2 	bmi.w	6738 <usb_isr+0x5e4>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    63f4:	07a2      	lsls	r2, r4, #30
    63f6:	d506      	bpl.n	6406 <usb_isr+0x2b2>
		uint8_t err = USB0_ERRSTAT;
    63f8:	4a1c      	ldr	r2, [pc, #112]	; (646c <usb_isr+0x318>)
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    63fa:	491d      	ldr	r1, [pc, #116]	; (6470 <usb_isr+0x31c>)
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    63fc:	7813      	ldrb	r3, [r2, #0]
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    63fe:	2002      	movs	r0, #2
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    6400:	b2db      	uxtb	r3, r3
		USB0_ERRSTAT = err;
    6402:	7013      	strb	r3, [r2, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    6404:	7008      	strb	r0, [r1, #0]
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    6406:	06e3      	lsls	r3, r4, #27
    6408:	d502      	bpl.n	6410 <usb_isr+0x2bc>
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    640a:	4b19      	ldr	r3, [pc, #100]	; (6470 <usb_isr+0x31c>)
    640c:	2210      	movs	r2, #16
    640e:	701a      	strb	r2, [r3, #0]
	}

}
    6410:	b007      	add	sp, #28
    6412:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
			if (t) {
				usb_cdc_transmit_flush_timer = --t;
				if (t == 0) usb_serial_flush_callback();
    6416:	f000 fcc5 	bl	6da4 <usb_serial_flush_callback>
    641a:	e706      	b.n	622a <usb_isr+0xd6>
    641c:	1fff0000 	.word	0x1fff0000
    6420:	1fff2b40 	.word	0x1fff2b40
    6424:	1fff2aec 	.word	0x1fff2aec
    6428:	1fff2c48 	.word	0x1fff2c48
    642c:	004000c8 	.word	0x004000c8
    6430:	00400088 	.word	0x00400088
    6434:	1fff2bc8 	.word	0x1fff2bc8
    6438:	1fff2b51 	.word	0x1fff2b51
    643c:	1fff2bd0 	.word	0x1fff2bd0
    6440:	1fff2ae8 	.word	0x1fff2ae8
    6444:	1fff2bb4 	.word	0x1fff2bb4
    6448:	1fff2b50 	.word	0x1fff2b50
    644c:	400720c0 	.word	0x400720c0
    6450:	1fff2bc0 	.word	0x1fff2bc0
    6454:	1fff2afc 	.word	0x1fff2afc
    6458:	1fff2bbc 	.word	0x1fff2bbc
    645c:	40072098 	.word	0x40072098
    6460:	40072094 	.word	0x40072094
    6464:	1fff2b94 	.word	0x1fff2b94
    6468:	1fff2bcc 	.word	0x1fff2bcc
    646c:	40072088 	.word	0x40072088
    6470:	40072080 	.word	0x40072080
    6474:	40072090 	.word	0x40072090
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
    6478:	4ab7      	ldr	r2, [pc, #732]	; (6758 <usb_isr+0x604>)
						b->desc = BDT_DESC(64,
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
    647a:	f847 0038 	str.w	r0, [r7, r8, lsl #3]
						usb_rx_memory_needed++;
    647e:	7813      	ldrb	r3, [r2, #0]
    6480:	3301      	adds	r3, #1
    6482:	7013      	strb	r3, [r2, #0]
    6484:	e6b0      	b.n	61e8 <usb_isr+0x94>
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[endpoint] = packet;
    6486:	f843 0026 	str.w	r0, [r3, r6, lsl #2]
    648a:	4db4      	ldr	r5, [pc, #720]	; (675c <usb_isr+0x608>)
    648c:	e693      	b.n	61b6 <usb_isr+0x62>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    648e:	f242 0421 	movw	r4, #8225	; 0x2021
    6492:	42a1      	cmp	r1, r4
    6494:	f000 80ad 	beq.w	65f2 <usb_isr+0x49e>
    6498:	f200 810e 	bhi.w	66b8 <usb_isr+0x564>
    649c:	f5b1 6f08 	cmp.w	r1, #2176	; 0x880
    64a0:	f000 8154 	beq.w	674c <usb_isr+0x5f8>
    64a4:	f5b1 6f10 	cmp.w	r1, #2304	; 0x900
    64a8:	f040 819d 	bne.w	67e6 <usb_isr+0x692>
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
    64ac:	4aac      	ldr	r2, [pc, #688]	; (6760 <usb_isr+0x60c>)
    64ae:	78a9      	ldrb	r1, [r5, #2]
    64b0:	7011      	strb	r1, [r2, #0]
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
			if (table[i].desc & BDT_OWN) {
    64b2:	4dac      	ldr	r5, [pc, #688]	; (6764 <usb_isr+0x610>)
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    64b4:	2404      	movs	r4, #4
    64b6:	e002      	b.n	64be <usb_isr+0x36a>
    64b8:	3401      	adds	r4, #1
    64ba:	2c14      	cmp	r4, #20
    64bc:	d00c      	beq.n	64d8 <usb_isr+0x384>
			if (table[i].desc & BDT_OWN) {
    64be:	f857 3034 	ldr.w	r3, [r7, r4, lsl #3]
    64c2:	0619      	lsls	r1, r3, #24
    64c4:	d5f8      	bpl.n	64b8 <usb_isr+0x364>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    64c6:	eb05 03c4 	add.w	r3, r5, r4, lsl #3
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    64ca:	3401      	adds	r4, #1
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    64cc:	6858      	ldr	r0, [r3, #4]
    64ce:	3808      	subs	r0, #8
    64d0:	f000 fafc 	bl	6acc <usb_free>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    64d4:	2c14      	cmp	r4, #20
    64d6:	d1f2      	bne.n	64be <usb_isr+0x36a>
    64d8:	49a3      	ldr	r1, [pc, #652]	; (6768 <usb_isr+0x614>)
    64da:	4ba4      	ldr	r3, [pc, #656]	; (676c <usb_isr+0x618>)
    64dc:	4aa4      	ldr	r2, [pc, #656]	; (6770 <usb_isr+0x61c>)
    64de:	9102      	str	r1, [sp, #8]
    64e0:	49a4      	ldr	r1, [pc, #656]	; (6774 <usb_isr+0x620>)
    64e2:	4ca5      	ldr	r4, [pc, #660]	; (6778 <usb_isr+0x624>)
    64e4:	4d9d      	ldr	r5, [pc, #628]	; (675c <usb_isr+0x608>)
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    64e6:	9403      	str	r4, [sp, #12]
    64e8:	9605      	str	r6, [sp, #20]
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    64ea:	f04f 0900 	mov.w	r9, #0
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    64ee:	4688      	mov	r8, r1
    64f0:	461c      	mov	r4, r3
    64f2:	4616      	mov	r6, r2
    64f4:	9504      	str	r5, [sp, #16]
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    64f6:	6820      	ldr	r0, [r4, #0]
			while (p) {
    64f8:	b128      	cbz	r0, 6506 <usb_isr+0x3b2>
				n = p->next;
    64fa:	6845      	ldr	r5, [r0, #4]
				usb_free(p);
    64fc:	f000 fae6 	bl	6acc <usb_free>
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
			while (p) {
    6500:	4628      	mov	r0, r5
    6502:	2d00      	cmp	r5, #0
    6504:	d1f9      	bne.n	64fa <usb_isr+0x3a6>
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
    6506:	2300      	movs	r3, #0
    6508:	6023      	str	r3, [r4, #0]
			rx_last[i] = NULL;
    650a:	9b04      	ldr	r3, [sp, #16]
			p = tx_first[i];
    650c:	6830      	ldr	r0, [r6, #0]
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
    650e:	461a      	mov	r2, r3
    6510:	2300      	movs	r3, #0
    6512:	f842 3029 	str.w	r3, [r2, r9, lsl #2]
			p = tx_first[i];
			while (p) {
    6516:	b128      	cbz	r0, 6524 <usb_isr+0x3d0>
				n = p->next;
    6518:	6845      	ldr	r5, [r0, #4]
				usb_free(p);
    651a:	f000 fad7 	bl	6acc <usb_free>
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
			p = tx_first[i];
			while (p) {
    651e:	4628      	mov	r0, r5
    6520:	2d00      	cmp	r5, #0
    6522:	d1f9      	bne.n	6518 <usb_isr+0x3c4>
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    6524:	2200      	movs	r2, #0
    6526:	6032      	str	r2, [r6, #0]
			tx_last[i] = NULL;
    6528:	9a02      	ldr	r2, [sp, #8]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    652a:	f898 3000 	ldrb.w	r3, [r8]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    652e:	4611      	mov	r1, r2
    6530:	2200      	movs	r2, #0
    6532:	f841 2b04 	str.w	r2, [r1], #4
			usb_rx_byte_count_data[i] = 0;
    6536:	9a03      	ldr	r2, [sp, #12]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    6538:	9102      	str	r1, [sp, #8]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    653a:	3b02      	subs	r3, #2
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    653c:	f04f 0100 	mov.w	r1, #0
    6540:	f822 1019 	strh.w	r1, [r2, r9, lsl #1]
			switch (tx_state[i]) {
    6544:	2b03      	cmp	r3, #3
    6546:	f200 81b4 	bhi.w	68b2 <usb_isr+0x75e>
    654a:	e8df f013 	tbh	[pc, r3, lsl #1]
    654e:	01e2      	.short	0x01e2
    6550:	01e201ae 	.word	0x01e201ae
    6554:	01ae      	.short	0x01ae
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    6556:	4c89      	ldr	r4, [pc, #548]	; (677c <usb_isr+0x628>)
		reply_buffer[1] = 0;
		datalen = 2;
    6558:	2002      	movs	r0, #2
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    655a:	7022      	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    655c:	7062      	strb	r2, [r4, #1]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    655e:	88ea      	ldrh	r2, [r5, #6]
    6560:	4282      	cmp	r2, r0
    6562:	f080 820d 	bcs.w	6980 <usb_isr+0x82c>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    6566:	4986      	ldr	r1, [pc, #536]	; (6780 <usb_isr+0x62c>)
    6568:	780d      	ldrb	r5, [r1, #0]
    656a:	2a40      	cmp	r2, #64	; 0x40
    656c:	f045 0e02 	orr.w	lr, r5, #2
    6570:	4694      	mov	ip, r2
    6572:	eb07 00ce 	add.w	r0, r7, lr, lsl #3
    6576:	bf28      	it	cs
    6578:	f04f 0c40 	movcs.w	ip, #64	; 0x40
    657c:	eb04 030c 	add.w	r3, r4, ip
    6580:	6044      	str	r4, [r0, #4]
    6582:	9302      	str	r3, [sp, #8]
    6584:	ebcc 0002 	rsb	r0, ip, r2
    6588:	ea4f 480c 	mov.w	r8, ip, lsl #16
    658c:	f04f 0901 	mov.w	r9, #1
    6590:	2200      	movs	r2, #0
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6592:	24c8      	movs	r4, #200	; 0xc8
    6594:	ea44 0308 	orr.w	r3, r4, r8
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    6598:	f085 0401 	eor.w	r4, r5, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    659c:	f847 303e 	str.w	r3, [r7, lr, lsl #3]
	ep0_tx_data_toggle ^= 1;
    65a0:	7032      	strb	r2, [r6, #0]
	ep0_tx_bdt_bank ^= 1;
    65a2:	700c      	strb	r4, [r1, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    65a4:	f8df e1bc 	ldr.w	lr, [pc, #444]	; 6764 <usb_isr+0x610>
	ep0_tx_data_toggle ^= 1;
    65a8:	4b76      	ldr	r3, [pc, #472]	; (6784 <usb_isr+0x630>)
	ep0_tx_bdt_bank ^= 1;
    65aa:	f8df 81d4 	ldr.w	r8, [pc, #468]	; 6780 <usb_isr+0x62c>
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    65ae:	2800      	cmp	r0, #0
    65b0:	f040 8120 	bne.w	67f4 <usb_isr+0x6a0>
    65b4:	f1bc 0f40 	cmp.w	ip, #64	; 0x40
    65b8:	d11b      	bne.n	65f2 <usb_isr+0x49e>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    65ba:	f044 0402 	orr.w	r4, r4, #2
    65be:	eb07 03c4 	add.w	r3, r7, r4, lsl #3
    65c2:	9f02      	ldr	r7, [sp, #8]
    65c4:	f8df e19c 	ldr.w	lr, [pc, #412]	; 6764 <usb_isr+0x610>
    65c8:	605f      	str	r7, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    65ca:	2a00      	cmp	r2, #0
    65cc:	f040 8127 	bne.w	681e <usb_isr+0x6ca>
    65d0:	0402      	lsls	r2, r0, #16
    65d2:	f042 0288 	orr.w	r2, r2, #136	; 0x88
	ep0_tx_data_toggle ^= 1;
    65d6:	f886 9000 	strb.w	r9, [r6]
	ep0_tx_bdt_bank ^= 1;
    65da:	700d      	strb	r5, [r1, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    65dc:	4407      	add	r7, r0
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    65de:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    65e2:	463b      	mov	r3, r7
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    65e4:	2840      	cmp	r0, #64	; 0x40
    65e6:	d104      	bne.n	65f2 <usb_isr+0x49e>
    65e8:	2000      	movs	r0, #0

	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
    65ea:	4a67      	ldr	r2, [pc, #412]	; (6788 <usb_isr+0x634>)
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    65ec:	9901      	ldr	r1, [sp, #4]
	ep0_tx_len = datalen;
    65ee:	8010      	strh	r0, [r2, #0]
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    65f0:	600b      	str	r3, [r1, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    65f2:	4a66      	ldr	r2, [pc, #408]	; (678c <usb_isr+0x638>)
    65f4:	2301      	movs	r3, #1
    65f6:	7013      	strb	r3, [r2, #0]
    65f8:	e6b1      	b.n	635e <usb_isr+0x20a>
					}
					b->desc = BDT_DESC(packet->len,
						((uint32_t)b & 8) ? DATA1 : DATA0);
				} else {
					//serial_print("tx no packet\n");
					switch (tx_state[endpoint]) {
    65fa:	5d8b      	ldrb	r3, [r1, r6]
    65fc:	2b03      	cmp	r3, #3
    65fe:	f200 8124 	bhi.w	684a <usb_isr+0x6f6>
    6602:	a201      	add	r2, pc, #4	; (adr r2, 6608 <usb_isr+0x4b4>)
    6604:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    6608:	000061e9 	.word	0x000061e9
    660c:	000061e9 	.word	0x000061e9
    6610:	0000672d 	.word	0x0000672d
    6614:	00006733 	.word	0x00006733
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
			int i;
			uint32_t *line_coding = NULL;
			switch (setup.wIndex) {
    6618:	8892      	ldrh	r2, [r2, #4]
    661a:	b962      	cbnz	r2, 6636 <usb_isr+0x4e2>
    661c:	4a5c      	ldr	r2, [pc, #368]	; (6790 <usb_isr+0x63c>)
    661e:	1dcd      	adds	r5, r1, #7
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
					//serial_phex(*buf);
					*dst++ = *buf++;
    6620:	f811 3b01 	ldrb.w	r3, [r1], #1
    6624:	f802 3f01 	strb.w	r3, [r2, #1]!
#endif
			}
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
    6628:	428d      	cmp	r5, r1
    662a:	d1f9      	bne.n	6620 <usb_isr+0x4cc>
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    662c:	4a59      	ldr	r2, [pc, #356]	; (6794 <usb_isr+0x640>)
    662e:	6812      	ldr	r2, [r2, #0]
    6630:	2a86      	cmp	r2, #134	; 0x86
    6632:	f000 80c9 	beq.w	67c8 <usb_isr+0x674>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    6636:	4952      	ldr	r1, [pc, #328]	; (6780 <usb_isr+0x62c>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6638:	4e52      	ldr	r6, [pc, #328]	; (6784 <usb_isr+0x630>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    663a:	7808      	ldrb	r0, [r1, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    663c:	7832      	ldrb	r2, [r6, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    663e:	f040 0502 	orr.w	r5, r0, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    6642:	f080 0001 	eor.w	r0, r0, #1
    6646:	7008      	strb	r0, [r1, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    6648:	eb07 01c5 	add.w	r1, r7, r5, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    664c:	2a00      	cmp	r2, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    664e:	f04f 0000 	mov.w	r0, #0
    6652:	6048      	str	r0, [r1, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    6654:	f082 0201 	eor.w	r2, r2, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6658:	bf0c      	ite	eq
    665a:	2188      	moveq	r1, #136	; 0x88
    665c:	21c8      	movne	r1, #200	; 0xc8
    665e:	f847 1035 	str.w	r1, [r7, r5, lsl #3]
	ep0_tx_data_toggle ^= 1;
    6662:	7032      	strb	r2, [r6, #0]
    6664:	e686      	b.n	6374 <usb_isr+0x220>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    6666:	f240 3202 	movw	r2, #770	; 0x302
    666a:	4291      	cmp	r1, r2
    666c:	f040 80b0 	bne.w	67d0 <usb_isr+0x67c>
    6670:	88a9      	ldrh	r1, [r5, #4]
    6672:	f001 017f 	and.w	r1, r1, #127	; 0x7f
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
		// TODO: do we need to clear the data toggle here?
		break;
	  case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    6676:	2904      	cmp	r1, #4
    6678:	f200 80b5 	bhi.w	67e6 <usb_isr+0x692>
    667c:	886a      	ldrh	r2, [r5, #2]
    667e:	2a00      	cmp	r2, #0
    6680:	f040 80b1 	bne.w	67e6 <usb_isr+0x692>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    6684:	4c44      	ldr	r4, [pc, #272]	; (6798 <usb_isr+0x644>)
    6686:	0089      	lsls	r1, r1, #2
    6688:	440c      	add	r4, r1
    668a:	4681      	mov	r9, r0
    668c:	7821      	ldrb	r1, [r4, #0]
    668e:	f041 0102 	orr.w	r1, r1, #2
    6692:	7021      	strb	r1, [r4, #0]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    6694:	2000      	movs	r0, #0
    6696:	9002      	str	r0, [sp, #8]
    6698:	4680      	mov	r8, r0
    669a:	4684      	mov	ip, r0
    669c:	4604      	mov	r4, r0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    669e:	4938      	ldr	r1, [pc, #224]	; (6780 <usb_isr+0x62c>)
    66a0:	780d      	ldrb	r5, [r1, #0]
    66a2:	f045 0e02 	orr.w	lr, r5, #2
    66a6:	eb07 03ce 	add.w	r3, r7, lr, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    66aa:	f1b9 0f00 	cmp.w	r9, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    66ae:	605c      	str	r4, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    66b0:	bf0c      	ite	eq
    66b2:	2488      	moveq	r4, #136	; 0x88
    66b4:	24c8      	movne	r4, #200	; 0xc8
    66b6:	e76d      	b.n	6594 <usb_isr+0x440>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    66b8:	f242 2421 	movw	r4, #8737	; 0x2221
    66bc:	42a1      	cmp	r1, r4
    66be:	f040 808e 	bne.w	67de <usb_isr+0x68a>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    66c2:	88a9      	ldrh	r1, [r5, #4]
    66c4:	2900      	cmp	r1, #0
    66c6:	f040 8142 	bne.w	694e <usb_isr+0x7fa>
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    66ca:	4b34      	ldr	r3, [pc, #208]	; (679c <usb_isr+0x648>)
    66cc:	4a34      	ldr	r2, [pc, #208]	; (67a0 <usb_isr+0x64c>)
			usb_cdc_line_rtsdtr = setup.wValue;
    66ce:	4c35      	ldr	r4, [pc, #212]	; (67a4 <usb_isr+0x650>)
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    66d0:	681b      	ldr	r3, [r3, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    66d2:	78ad      	ldrb	r5, [r5, #2]
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    66d4:	6013      	str	r3, [r2, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    66d6:	4681      	mov	r9, r0
    66d8:	460a      	mov	r2, r1
    66da:	7025      	strb	r5, [r4, #0]
    66dc:	e7da      	b.n	6694 <usb_isr+0x540>

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    66de:	492b      	ldr	r1, [pc, #172]	; (678c <usb_isr+0x638>)
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    66e0:	4b20      	ldr	r3, [pc, #128]	; (6764 <usb_isr+0x610>)
    66e2:	4831      	ldr	r0, [pc, #196]	; (67a8 <usb_isr+0x654>)
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    66e4:	4e26      	ldr	r6, [pc, #152]	; (6780 <usb_isr+0x62c>)
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    66e6:	f8df c0b0 	ldr.w	ip, [pc, #176]	; 6798 <usb_isr+0x644>

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    66ea:	4d30      	ldr	r5, [pc, #192]	; (67ac <usb_isr+0x658>)
		USB0_ISTAT = 0xFF;
    66ec:	f8df e0d4 	ldr.w	lr, [pc, #212]	; 67c4 <usb_isr+0x670>

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    66f0:	4f2f      	ldr	r7, [pc, #188]	; (67b0 <usb_isr+0x65c>)

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    66f2:	2402      	movs	r4, #2
    66f4:	700c      	strb	r4, [r1, #0]
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    66f6:	4c2f      	ldr	r4, [pc, #188]	; (67b4 <usb_isr+0x660>)
		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    66f8:	6018      	str	r0, [r3, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    66fa:	605c      	str	r4, [r3, #4]
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    66fc:	6098      	str	r0, [r3, #8]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    66fe:	482e      	ldr	r0, [pc, #184]	; (67b8 <usb_isr+0x664>)
    6700:	60d8      	str	r0, [r3, #12]
		table[index(0, TX, EVEN)].desc = 0;
    6702:	611a      	str	r2, [r3, #16]
		table[index(0, TX, ODD)].desc = 0;
    6704:	619a      	str	r2, [r3, #24]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    6706:	230d      	movs	r3, #13
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    6708:	7032      	strb	r2, [r6, #0]
		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    670a:	4c2c      	ldr	r4, [pc, #176]	; (67bc <usb_isr+0x668>)
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    670c:	f88c 3000 	strb.w	r3, [ip]

		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
    6710:	4e2b      	ldr	r6, [pc, #172]	; (67c0 <usb_isr+0x66c>)

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    6712:	23ff      	movs	r3, #255	; 0xff
    6714:	702b      	strb	r3, [r5, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    6716:	2001      	movs	r0, #1
		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    6718:	259f      	movs	r5, #159	; 0x9f
		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
		USB0_ISTAT = 0xFF;
    671a:	f88e 3000 	strb.w	r3, [lr]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    671e:	703a      	strb	r2, [r7, #0]

		// enable other interrupts
		USB0_ERREN = 0xFF;
    6720:	7033      	strb	r3, [r6, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    6722:	7025      	strb	r5, [r4, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    6724:	7008      	strb	r0, [r1, #0]
	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
	}

}
    6726:	b007      	add	sp, #28
    6728:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    672c:	2300      	movs	r3, #0
    672e:	558b      	strb	r3, [r1, r6]
						break;
    6730:	e55a      	b.n	61e8 <usb_isr+0x94>
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    6732:	2301      	movs	r3, #1
    6734:	558b      	strb	r3, [r1, r6]
						break;
    6736:	e557      	b.n	61e8 <usb_isr+0x94>
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    6738:	4917      	ldr	r1, [pc, #92]	; (6798 <usb_isr+0x644>)
		USB0_ISTAT = USB_ISTAT_STALL;
    673a:	4b22      	ldr	r3, [pc, #136]	; (67c4 <usb_isr+0x670>)
    673c:	2280      	movs	r2, #128	; 0x80
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    673e:	200d      	movs	r0, #13
    6740:	7008      	strb	r0, [r1, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    6742:	701a      	strb	r2, [r3, #0]
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    6744:	07a2      	lsls	r2, r4, #30
    6746:	f57f ae5e 	bpl.w	6406 <usb_isr+0x2b2>
    674a:	e655      	b.n	63f8 <usb_isr+0x2a4>
			}
#endif
		}
		break;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    674c:	4a04      	ldr	r2, [pc, #16]	; (6760 <usb_isr+0x60c>)
    674e:	4c0b      	ldr	r4, [pc, #44]	; (677c <usb_isr+0x628>)
    6750:	7812      	ldrb	r2, [r2, #0]
    6752:	7022      	strb	r2, [r4, #0]
    6754:	e703      	b.n	655e <usb_isr+0x40a>
    6756:	bf00      	nop
    6758:	1fff2bbd 	.word	0x1fff2bbd
    675c:	1fff2aec 	.word	0x1fff2aec
    6760:	1fff2bc8 	.word	0x1fff2bc8
    6764:	1fff0000 	.word	0x1fff0000
    6768:	1fff2ba4 	.word	0x1fff2ba4
    676c:	1fff2b40 	.word	0x1fff2b40
    6770:	1fff2b94 	.word	0x1fff2b94
    6774:	1fff2bcc 	.word	0x1fff2bcc
    6778:	1fff2c48 	.word	0x1fff2c48
    677c:	1fff2bc0 	.word	0x1fff2bc0
    6780:	1fff2bbc 	.word	0x1fff2bbc
    6784:	1fff2b50 	.word	0x1fff2b50
    6788:	1fff2afc 	.word	0x1fff2afc
    678c:	40072094 	.word	0x40072094
    6790:	1fff2c4f 	.word	0x1fff2c4f
    6794:	1fff2c50 	.word	0x1fff2c50
    6798:	400720c0 	.word	0x400720c0
    679c:	1fff2ae4 	.word	0x1fff2ae4
    67a0:	1fff2c58 	.word	0x1fff2c58
    67a4:	1fff2be0 	.word	0x1fff2be0
    67a8:	00400088 	.word	0x00400088
    67ac:	40072088 	.word	0x40072088
    67b0:	40072098 	.word	0x40072098
    67b4:	1fff2b00 	.word	0x1fff2b00
    67b8:	1fff2b54 	.word	0x1fff2b54
    67bc:	40072084 	.word	0x40072084
    67c0:	4007208c 	.word	0x4007208c
    67c4:	40072080 	.word	0x40072080
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    67c8:	4a75      	ldr	r2, [pc, #468]	; (69a0 <usb_isr+0x84c>)
    67ca:	210f      	movs	r1, #15
    67cc:	7011      	strb	r1, [r2, #0]
    67ce:	e732      	b.n	6636 <usb_isr+0x4e2>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    67d0:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
    67d4:	d107      	bne.n	67e6 <usb_isr+0x692>
    67d6:	2200      	movs	r2, #0
    67d8:	f04f 0901 	mov.w	r9, #1
    67dc:	e75a      	b.n	6694 <usb_isr+0x540>
    67de:	f242 3221 	movw	r2, #8993	; 0x2321
    67e2:	4291      	cmp	r1, r2
    67e4:	d0f7      	beq.n	67d6 <usb_isr+0x682>
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    67e6:	4b6f      	ldr	r3, [pc, #444]	; (69a4 <usb_isr+0x850>)
    67e8:	220f      	movs	r2, #15
    67ea:	701a      	strb	r2, [r3, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    67ec:	4a6e      	ldr	r2, [pc, #440]	; (69a8 <usb_isr+0x854>)
    67ee:	2301      	movs	r3, #1
    67f0:	7013      	strb	r3, [r2, #0]
    67f2:	e5b4      	b.n	635e <usb_isr+0x20a>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
    67f4:	2840      	cmp	r0, #64	; 0x40
    67f6:	f67f aee0 	bls.w	65ba <usb_isr+0x466>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    67fa:	f044 0402 	orr.w	r4, r4, #2
    67fe:	eb0e 01c4 	add.w	r1, lr, r4, lsl #3
    6802:	9e02      	ldr	r6, [sp, #8]
    6804:	604e      	str	r6, [r1, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6806:	b1aa      	cbz	r2, 6834 <usb_isr+0x6e0>
	ep0_tx_data_toggle ^= 1;
    6808:	f883 9000 	strb.w	r9, [r3]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    680c:	4a67      	ldr	r2, [pc, #412]	; (69ac <usb_isr+0x858>)
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    680e:	f888 5000 	strb.w	r5, [r8]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    6812:	4633      	mov	r3, r6
    6814:	3840      	subs	r0, #64	; 0x40
    6816:	3340      	adds	r3, #64	; 0x40
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6818:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
    681c:	e6e5      	b.n	65ea <usb_isr+0x496>
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    681e:	9b02      	ldr	r3, [sp, #8]
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    6820:	f886 9000 	strb.w	r9, [r6]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6824:	0402      	lsls	r2, r0, #16
    6826:	f042 02c8 	orr.w	r2, r2, #200	; 0xc8
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    682a:	700d      	strb	r5, [r1, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    682c:	4403      	add	r3, r0
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    682e:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
    6832:	e6d7      	b.n	65e4 <usb_isr+0x490>
	ep0_tx_data_toggle ^= 1;
    6834:	f883 9000 	strb.w	r9, [r3]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    6838:	9b02      	ldr	r3, [sp, #8]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    683a:	4a5d      	ldr	r2, [pc, #372]	; (69b0 <usb_isr+0x85c>)
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    683c:	f888 5000 	strb.w	r5, [r8]
    6840:	3840      	subs	r0, #64	; 0x40
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    6842:	3340      	adds	r3, #64	; 0x40
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6844:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
    6848:	e6cf      	b.n	65ea <usb_isr+0x496>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
						break;
					  default:
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    684a:	f019 0f08 	tst.w	r9, #8
    684e:	bf0c      	ite	eq
    6850:	2302      	moveq	r3, #2
    6852:	2303      	movne	r3, #3
    6854:	558b      	strb	r3, [r1, r6]
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
    6856:	e4c7      	b.n	61e8 <usb_isr+0x94>
    6858:	88a9      	ldrh	r1, [r5, #4]
    685a:	f001 017f 	and.w	r1, r1, #127	; 0x7f
		data = reply_buffer;
		datalen = 2;
		break;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    685e:	2904      	cmp	r1, #4
    6860:	d8c1      	bhi.n	67e6 <usb_isr+0x692>
    6862:	886a      	ldrh	r2, [r5, #2]
    6864:	2a00      	cmp	r2, #0
    6866:	d1be      	bne.n	67e6 <usb_isr+0x692>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    6868:	4c4e      	ldr	r4, [pc, #312]	; (69a4 <usb_isr+0x850>)
    686a:	0089      	lsls	r1, r1, #2
    686c:	440c      	add	r4, r1
    686e:	4681      	mov	r9, r0
    6870:	7821      	ldrb	r1, [r4, #0]
    6872:	f021 0102 	bic.w	r1, r1, #2
    6876:	7021      	strb	r1, [r4, #0]
    6878:	e70c      	b.n	6694 <usb_isr+0x540>
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
    687a:	4a4e      	ldr	r2, [pc, #312]	; (69b4 <usb_isr+0x860>)
    687c:	6854      	ldr	r4, [r2, #4]
    687e:	2c00      	cmp	r4, #0
    6880:	d0b1      	beq.n	67e6 <usb_isr+0x692>
    6882:	8868      	ldrh	r0, [r5, #2]
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    6884:	f8b5 e004 	ldrh.w	lr, [r5, #4]
    6888:	e003      	b.n	6892 <usb_isr+0x73e>
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
    688a:	320c      	adds	r2, #12
			if (list->addr == NULL) break;
    688c:	6854      	ldr	r4, [r2, #4]
    688e:	2c00      	cmp	r4, #0
    6890:	d0a9      	beq.n	67e6 <usb_isr+0x692>
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    6892:	8813      	ldrh	r3, [r2, #0]
    6894:	4283      	cmp	r3, r0
    6896:	d1f8      	bne.n	688a <usb_isr+0x736>
    6898:	8853      	ldrh	r3, [r2, #2]
    689a:	4573      	cmp	r3, lr
    689c:	d1f5      	bne.n	688a <usb_isr+0x736>
				data = list->addr;
				if ((setup.wValue >> 8) == 3) {
    689e:	0a00      	lsrs	r0, r0, #8
    68a0:	2803      	cmp	r0, #3
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    68a2:	bf0c      	ite	eq
    68a4:	7820      	ldrbeq	r0, [r4, #0]
				} else {
					datalen = list->length;
    68a6:	8910      	ldrhne	r0, [r2, #8]
    68a8:	e659      	b.n	655e <usb_isr+0x40a>
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    68aa:	f04f 0301 	mov.w	r3, #1
    68ae:	f888 3000 	strb.w	r3, [r8]
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
    68b2:	f109 0901 	add.w	r9, r9, #1
    68b6:	f1b9 0f04 	cmp.w	r9, #4
    68ba:	f104 0404 	add.w	r4, r4, #4
    68be:	f106 0604 	add.w	r6, r6, #4
    68c2:	f108 0801 	add.w	r8, r8, #1
    68c6:	f47f ae16 	bne.w	64f6 <usb_isr+0x3a2>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    68ca:	4b3b      	ldr	r3, [pc, #236]	; (69b8 <usb_isr+0x864>)
    68cc:	9e05      	ldr	r6, [sp, #20]
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
    68ce:	4d3b      	ldr	r5, [pc, #236]	; (69bc <usb_isr+0x868>)
		cfg = usb_endpoint_config_table;
    68d0:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 69c4 <usb_isr+0x870>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    68d4:	2000      	movs	r0, #0
    68d6:	7018      	strb	r0, [r3, #0]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    68d8:	f04f 0901 	mov.w	r9, #1
			epconf = *cfg++;
    68dc:	f818 3b01 	ldrb.w	r3, [r8], #1
			*reg = epconf;
    68e0:	f805 3b04 	strb.w	r3, [r5], #4
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    68e4:	071a      	lsls	r2, r3, #28
    68e6:	d419      	bmi.n	691c <usb_isr+0x7c8>
    68e8:	ea4f 0489 	mov.w	r4, r9, lsl #2
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    68ec:	f044 0202 	orr.w	r2, r4, #2
			table[index(i, TX, ODD)].desc = 0;
    68f0:	f044 0403 	orr.w	r4, r4, #3
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    68f4:	2300      	movs	r3, #0
    68f6:	f847 3032 	str.w	r3, [r7, r2, lsl #3]
			table[index(i, TX, ODD)].desc = 0;
    68fa:	f847 3034 	str.w	r3, [r7, r4, lsl #3]
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    68fe:	4b30      	ldr	r3, [pc, #192]	; (69c0 <usb_isr+0x86c>)
    6900:	429d      	cmp	r5, r3
    6902:	f109 0901 	add.w	r9, r9, #1
    6906:	d1e9      	bne.n	68dc <usb_isr+0x788>
    6908:	f896 9000 	ldrb.w	r9, [r6]
    690c:	f089 0201 	eor.w	r2, r9, #1
    6910:	e6c0      	b.n	6694 <usb_isr+0x540>
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
			  case TX_STATE_EVEN_FREE:
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    6912:	f04f 0300 	mov.w	r3, #0
    6916:	f888 3000 	strb.w	r3, [r8]
    691a:	e7ca      	b.n	68b2 <usb_isr+0x75e>
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
    691c:	f000 f8b6 	bl	6a8c <usb_malloc>
				if (p) {
    6920:	b318      	cbz	r0, 696a <usb_isr+0x816>
					table[index(i, RX, EVEN)].addr = p->buf;
    6922:	eb07 1349 	add.w	r3, r7, r9, lsl #5
    6926:	ea4f 0489 	mov.w	r4, r9, lsl #2
    692a:	3008      	adds	r0, #8
    692c:	6058      	str	r0, [r3, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    692e:	4b20      	ldr	r3, [pc, #128]	; (69b0 <usb_isr+0x85c>)
    6930:	f847 3034 	str.w	r3, [r7, r4, lsl #3]
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
    6934:	f000 f8aa 	bl	6a8c <usb_malloc>
				if (p) {
    6938:	b168      	cbz	r0, 6956 <usb_isr+0x802>
					table[index(i, RX, ODD)].addr = p->buf;
    693a:	f044 0301 	orr.w	r3, r4, #1
    693e:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
    6942:	3008      	adds	r0, #8
    6944:	6050      	str	r0, [r2, #4]
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    6946:	4a19      	ldr	r2, [pc, #100]	; (69ac <usb_isr+0x858>)
    6948:	f847 2033 	str.w	r2, [r7, r3, lsl #3]
    694c:	e7ce      	b.n	68ec <usb_isr+0x798>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    694e:	4681      	mov	r9, r0
    6950:	e6a0      	b.n	6694 <usb_isr+0x540>
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
		data = reply_buffer;
		datalen = 2;
    6952:	2002      	movs	r0, #2
    6954:	e603      	b.n	655e <usb_isr+0x40a>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
    6956:	4b18      	ldr	r3, [pc, #96]	; (69b8 <usb_isr+0x864>)
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    6958:	f044 0201 	orr.w	r2, r4, #1
					usb_rx_memory_needed++;
    695c:	781b      	ldrb	r3, [r3, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    695e:	f847 0032 	str.w	r0, [r7, r2, lsl #3]
					usb_rx_memory_needed++;
    6962:	4a15      	ldr	r2, [pc, #84]	; (69b8 <usb_isr+0x864>)
    6964:	3301      	adds	r3, #1
    6966:	7013      	strb	r3, [r2, #0]
    6968:	e7c0      	b.n	68ec <usb_isr+0x798>
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
    696a:	4b13      	ldr	r3, [pc, #76]	; (69b8 <usb_isr+0x864>)
    696c:	4a12      	ldr	r2, [pc, #72]	; (69b8 <usb_isr+0x864>)
    696e:	781b      	ldrb	r3, [r3, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    6970:	ea4f 0489 	mov.w	r4, r9, lsl #2
					usb_rx_memory_needed++;
    6974:	3301      	adds	r3, #1
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    6976:	f847 0034 	str.w	r0, [r7, r4, lsl #3]
					usb_rx_memory_needed++;
    697a:	7013      	strb	r3, [r2, #0]
    697c:	e7da      	b.n	6934 <usb_isr+0x7e0>


void _reboot_Teensyduino_(void)
{
	// TODO: initialize R0 with a code....
	__asm__ volatile("bkpt");
    697e:	be00      	bkpt	0x0000
    6980:	2840      	cmp	r0, #64	; 0x40
    6982:	4684      	mov	ip, r0
    6984:	bf28      	it	cs
    6986:	f04f 0c40 	movcs.w	ip, #64	; 0x40
    698a:	eb04 030c 	add.w	r3, r4, ip
    698e:	ebcc 0000 	rsb	r0, ip, r0
    6992:	ea4f 480c 	mov.w	r8, ip, lsl #16
    6996:	9302      	str	r3, [sp, #8]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    6998:	2200      	movs	r2, #0
    699a:	f04f 0901 	mov.w	r9, #1
    699e:	e67e      	b.n	669e <usb_isr+0x54a>
    69a0:	1fff2b51 	.word	0x1fff2b51
    69a4:	400720c0 	.word	0x400720c0
    69a8:	40072094 	.word	0x40072094
    69ac:	004000c8 	.word	0x004000c8
    69b0:	00400088 	.word	0x00400088
    69b4:	000096b4 	.word	0x000096b4
    69b8:	1fff2bbd 	.word	0x1fff2bbd
    69bc:	400720c4 	.word	0x400720c4
    69c0:	400720d4 	.word	0x400720d4
    69c4:	000096b0 	.word	0x000096b0

000069c8 <usb_init>:
}



void usb_init(void)
{
    69c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    69ca:	f000 fc17 	bl	71fc <usb_init_serialnumber>

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    69ce:	2300      	movs	r3, #0
    69d0:	4924      	ldr	r1, [pc, #144]	; (6a64 <usb_init+0x9c>)
		table[i].desc = 0;
    69d2:	461a      	mov	r2, r3
		table[i].addr = 0;
    69d4:	eb01 00c3 	add.w	r0, r1, r3, lsl #3
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
		table[i].desc = 0;
    69d8:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    69dc:	3301      	adds	r3, #1
    69de:	2b14      	cmp	r3, #20
		table[i].desc = 0;
		table[i].addr = 0;
    69e0:	6042      	str	r2, [r0, #4]
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
		table[i].desc = 0;
    69e2:	f04f 0400 	mov.w	r4, #0
    69e6:	481f      	ldr	r0, [pc, #124]	; (6a64 <usb_init+0x9c>)
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    69e8:	d1f4      	bne.n	69d4 <usb_init+0xc>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    69ea:	491f      	ldr	r1, [pc, #124]	; (6a68 <usb_init+0xa0>)
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    69ec:	4a1f      	ldr	r2, [pc, #124]	; (6a6c <usb_init+0xa4>)
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    69ee:	680b      	ldr	r3, [r1, #0]
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
#endif
#if F_CPU == 180000000 || F_CPU == 216000000 || F_CPU == 256000000
	// if using IRC48M, turn on the USB clock recovery hardware
	USB0_CLK_RECOVER_IRC_EN = USB_CLK_RECOVER_IRC_EN_IRC_EN | USB_CLK_RECOVER_IRC_EN_REG_EN;
    69f0:	f8df c090 	ldr.w	ip, [pc, #144]	; 6a84 <usb_init+0xbc>
	USB0_CLK_RECOVER_CTRL = USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN |
    69f4:	4e1e      	ldr	r6, [pc, #120]	; (6a70 <usb_init+0xa8>)
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    69f6:	4f1f      	ldr	r7, [pc, #124]	; (6a74 <usb_init+0xac>)
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    69f8:	4d1f      	ldr	r5, [pc, #124]	; (6a78 <usb_init+0xb0>)

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    69fa:	f8df e08c 	ldr.w	lr, [pc, #140]	; 6a88 <usb_init+0xc0>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    69fe:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    6a02:	600b      	str	r3, [r1, #0]
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    6a04:	6813      	ldr	r3, [r2, #0]
    6a06:	f043 7340 	orr.w	r3, r3, #50331648	; 0x3000000
    6a0a:	6013      	str	r3, [r2, #0]
#endif
#if F_CPU == 180000000 || F_CPU == 216000000 || F_CPU == 256000000
	// if using IRC48M, turn on the USB clock recovery hardware
	USB0_CLK_RECOVER_IRC_EN = USB_CLK_RECOVER_IRC_EN_IRC_EN | USB_CLK_RECOVER_IRC_EN_REG_EN;
    6a0c:	2303      	movs	r3, #3
    6a0e:	f88c 3000 	strb.w	r3, [ip]
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    6a12:	f501 3128 	add.w	r1, r1, #172032	; 0x2a000
	MPU_RGDAAC0 |= 0x03000000;
#endif
#if F_CPU == 180000000 || F_CPU == 216000000 || F_CPU == 256000000
	// if using IRC48M, turn on the USB clock recovery hardware
	USB0_CLK_RECOVER_IRC_EN = USB_CLK_RECOVER_IRC_EN_IRC_EN | USB_CLK_RECOVER_IRC_EN_REG_EN;
	USB0_CLK_RECOVER_CTRL = USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN |
    6a16:	23a0      	movs	r3, #160	; 0xa0
    6a18:	7033      	strb	r3, [r6, #0]
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    6a1a:	317c      	adds	r1, #124	; 0x7c
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    6a1c:	f502 22c9 	add.w	r2, r2, #411648	; 0x64800
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    6a20:	f3c0 2307 	ubfx	r3, r0, #8, #8
    6a24:	703b      	strb	r3, [r7, #0]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    6a26:	3210      	adds	r2, #16
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    6a28:	f3c0 4307 	ubfx	r3, r0, #16, #8
    6a2c:	700b      	strb	r3, [r1, #0]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    6a2e:	0e00      	lsrs	r0, r0, #24

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    6a30:	23ff      	movs	r3, #255	; 0xff
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    6a32:	7028      	strb	r0, [r5, #0]

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    6a34:	f88e 3000 	strb.w	r3, [lr]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    6a38:	4d10      	ldr	r5, [pc, #64]	; (6a7c <usb_init+0xb4>)
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
    6a3a:	f80c 3cbc 	strb.w	r3, [ip, #-188]
	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    6a3e:	4810      	ldr	r0, [pc, #64]	; (6a80 <usb_init+0xb8>)
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    6a40:	7013      	strb	r3, [r2, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    6a42:	2301      	movs	r3, #1
    6a44:	f806 3cac 	strb.w	r3, [r6, #-172]
	USB0_USBCTRL = 0;
    6a48:	f881 4050 	strb.w	r4, [r1, #80]	; 0x50

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    6a4c:	2670      	movs	r6, #112	; 0x70
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    6a4e:	f44f 1400 	mov.w	r4, #2097152	; 0x200000

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    6a52:	2110      	movs	r1, #16
	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    6a54:	f807 3c18 	strb.w	r3, [r7, #-24]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    6a58:	702e      	strb	r6, [r5, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    6a5a:	6004      	str	r4, [r0, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    6a5c:	f882 10f8 	strb.w	r1, [r2, #248]	; 0xf8
    6a60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6a62:	bf00      	nop
    6a64:	1fff0000 	.word	0x1fff0000
    6a68:	40048034 	.word	0x40048034
    6a6c:	4000d800 	.word	0x4000d800
    6a70:	40072140 	.word	0x40072140
    6a74:	4007209c 	.word	0x4007209c
    6a78:	400720b4 	.word	0x400720b4
    6a7c:	e000e435 	.word	0xe000e435
    6a80:	e000e104 	.word	0xe000e104
    6a84:	40072144 	.word	0x40072144
    6a88:	40072080 	.word	0x40072080

00006a8c <usb_malloc>:
usb_packet_t * usb_malloc(void)
{
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    6a8c:	b672      	cpsid	i
	avail = usb_buffer_available;
    6a8e:	480d      	ldr	r0, [pc, #52]	; (6ac4 <usb_malloc+0x38>)
    6a90:	6802      	ldr	r2, [r0, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    6a92:	fab2 f382 	clz	r3, r2
	if (n >= NUM_USB_BUFFERS) {
    6a96:	2b0b      	cmp	r3, #11
    6a98:	dc10      	bgt.n	6abc <usb_malloc+0x30>
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    6a9a:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    6a9e:	40d9      	lsrs	r1, r3
    6aa0:	ea22 0201 	bic.w	r2, r2, r1
    6aa4:	6002      	str	r2, [r0, #0]
	__enable_irq();
    6aa6:	b662      	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    6aa8:	4807      	ldr	r0, [pc, #28]	; (6ac8 <usb_malloc+0x3c>)
    6aaa:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
    6aae:	00db      	lsls	r3, r3, #3
    6ab0:	18c2      	adds	r2, r0, r3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    6ab2:	2100      	movs	r1, #0
    6ab4:	50c1      	str	r1, [r0, r3]
	*(uint32_t *)(p + 4) = 0;
	return (usb_packet_t *)p;
    6ab6:	4610      	mov	r0, r2
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
	*(uint32_t *)(p + 4) = 0;
    6ab8:	6051      	str	r1, [r2, #4]
	return (usb_packet_t *)p;
}
    6aba:	4770      	bx	lr

	__disable_irq();
	avail = usb_buffer_available;
	n = __builtin_clz(avail); // clz = count leading zeros
	if (n >= NUM_USB_BUFFERS) {
		__enable_irq();
    6abc:	b662      	cpsie	i
		return NULL;
    6abe:	2000      	movs	r0, #0
    6ac0:	4770      	bx	lr
    6ac2:	bf00      	nop
    6ac4:	1fff0b20 	.word	0x1fff0b20
    6ac8:	1fff03d0 	.word	0x1fff03d0

00006acc <usb_free>:
void usb_free(usb_packet_t *p)
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    6acc:	4b0d      	ldr	r3, [pc, #52]	; (6b04 <usb_free+0x38>)
    6ace:	4a0e      	ldr	r2, [pc, #56]	; (6b08 <usb_free+0x3c>)
    6ad0:	1ac3      	subs	r3, r0, r3
    6ad2:	fba2 2303 	umull	r2, r3, r2, r3
    6ad6:	091b      	lsrs	r3, r3, #4
	if (n >= NUM_USB_BUFFERS) return;
    6ad8:	2b0b      	cmp	r3, #11
    6ada:	d80c      	bhi.n	6af6 <usb_free+0x2a>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    6adc:	4a0b      	ldr	r2, [pc, #44]	; (6b0c <usb_free+0x40>)
    6ade:	7812      	ldrb	r2, [r2, #0]
    6ae0:	b952      	cbnz	r2, 6af8 <usb_free+0x2c>
		usb_rx_memory(p);
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    6ae2:	b672      	cpsid	i
	usb_buffer_available |= mask;
    6ae4:	480a      	ldr	r0, [pc, #40]	; (6b10 <usb_free+0x44>)
    6ae6:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    6aea:	6802      	ldr	r2, [r0, #0]
    6aec:	fa21 f303 	lsr.w	r3, r1, r3
    6af0:	431a      	orrs	r2, r3
    6af2:	6002      	str	r2, [r0, #0]
	__enable_irq();
    6af4:	b662      	cpsie	i
    6af6:	4770      	bx	lr
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    6af8:	4a06      	ldr	r2, [pc, #24]	; (6b14 <usb_free+0x48>)
    6afa:	7812      	ldrb	r2, [r2, #0]
    6afc:	2a00      	cmp	r2, #0
    6afe:	d0f0      	beq.n	6ae2 <usb_free+0x16>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    6b00:	f7ff baa4 	b.w	604c <usb_rx_memory>
    6b04:	1fff03d0 	.word	0x1fff03d0
    6b08:	38e38e39 	.word	0x38e38e39
    6b0c:	1fff2bbd 	.word	0x1fff2bbd
    6b10:	1fff0b20 	.word	0x1fff0b20
    6b14:	1fff2bc8 	.word	0x1fff2bc8

00006b18 <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    6b18:	b538      	push	{r3, r4, r5, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    6b1a:	4d0f      	ldr	r5, [pc, #60]	; (6b58 <usb_serial_getchar+0x40>)
    6b1c:	6828      	ldr	r0, [r5, #0]
    6b1e:	b178      	cbz	r0, 6b40 <usb_serial_getchar+0x28>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    6b20:	8843      	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
    6b22:	8802      	ldrh	r2, [r0, #0]
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    6b24:	18c1      	adds	r1, r0, r3
    6b26:	3301      	adds	r3, #1
	if (i >= rx_packet->len) {
    6b28:	4293      	cmp	r3, r2
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    6b2a:	7a0c      	ldrb	r4, [r1, #8]
	if (i >= rx_packet->len) {
    6b2c:	d202      	bcs.n	6b34 <usb_serial_getchar+0x1c>
		usb_free(rx_packet);
		rx_packet = NULL;
	} else {
		rx_packet->index = i;
    6b2e:	8043      	strh	r3, [r0, #2]
	}
	return c;
    6b30:	4620      	mov	r0, r4
}
    6b32:	bd38      	pop	{r3, r4, r5, pc}
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
    6b34:	f7ff ffca 	bl	6acc <usb_free>
		rx_packet = NULL;
    6b38:	2300      	movs	r3, #0
	} else {
		rx_packet->index = i;
	}
	return c;
    6b3a:	4620      	mov	r0, r4
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
		rx_packet = NULL;
    6b3c:	602b      	str	r3, [r5, #0]
    6b3e:	bd38      	pop	{r3, r4, r5, pc}
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    6b40:	4b06      	ldr	r3, [pc, #24]	; (6b5c <usb_serial_getchar+0x44>)
    6b42:	781b      	ldrb	r3, [r3, #0]
    6b44:	b12b      	cbz	r3, 6b52 <usb_serial_getchar+0x3a>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    6b46:	2003      	movs	r0, #3
    6b48:	f7ff fa4c 	bl	5fe4 <usb_rx>
    6b4c:	6028      	str	r0, [r5, #0]
		if (!rx_packet) return -1;
    6b4e:	2800      	cmp	r0, #0
    6b50:	d1e6      	bne.n	6b20 <usb_serial_getchar+0x8>
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    6b52:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    6b56:	bd38      	pop	{r3, r4, r5, pc}
    6b58:	1fff2bdc 	.word	0x1fff2bdc
    6b5c:	1fff2bc8 	.word	0x1fff2bc8

00006b60 <usb_serial_peekchar>:
	return c;
}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    6b60:	b510      	push	{r4, lr}
	if (!rx_packet) {
    6b62:	4c09      	ldr	r4, [pc, #36]	; (6b88 <usb_serial_peekchar+0x28>)
    6b64:	6820      	ldr	r0, [r4, #0]
    6b66:	b118      	cbz	r0, 6b70 <usb_serial_peekchar+0x10>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
	return rx_packet->buf[rx_packet->index];
    6b68:	8843      	ldrh	r3, [r0, #2]
    6b6a:	4418      	add	r0, r3
    6b6c:	7a00      	ldrb	r0, [r0, #8]
}
    6b6e:	bd10      	pop	{r4, pc}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    6b70:	4b06      	ldr	r3, [pc, #24]	; (6b8c <usb_serial_peekchar+0x2c>)
    6b72:	781b      	ldrb	r3, [r3, #0]
    6b74:	b12b      	cbz	r3, 6b82 <usb_serial_peekchar+0x22>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    6b76:	2003      	movs	r0, #3
    6b78:	f7ff fa34 	bl	5fe4 <usb_rx>
    6b7c:	6020      	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    6b7e:	2800      	cmp	r0, #0
    6b80:	d1f2      	bne.n	6b68 <usb_serial_peekchar+0x8>

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    6b82:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    6b86:	bd10      	pop	{r4, pc}
    6b88:	1fff2bdc 	.word	0x1fff2bdc
    6b8c:	1fff2bc8 	.word	0x1fff2bc8

00006b90 <usb_serial_available>:
// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    6b90:	4b04      	ldr	r3, [pc, #16]	; (6ba4 <usb_serial_available+0x14>)
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    6b92:	4a05      	ldr	r2, [pc, #20]	; (6ba8 <usb_serial_available+0x18>)
    6b94:	681b      	ldr	r3, [r3, #0]

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    6b96:	8890      	ldrh	r0, [r2, #4]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    6b98:	b11b      	cbz	r3, 6ba2 <usb_serial_available+0x12>
    6b9a:	881a      	ldrh	r2, [r3, #0]
    6b9c:	885b      	ldrh	r3, [r3, #2]
    6b9e:	1ad3      	subs	r3, r2, r3
    6ba0:	4418      	add	r0, r3
	return count;
}
    6ba2:	4770      	bx	lr
    6ba4:	1fff2bdc 	.word	0x1fff2bdc
    6ba8:	1fff2c48 	.word	0x1fff2c48

00006bac <usb_serial_flush_input>:
// discard any buffered input
void usb_serial_flush_input(void)
{
	usb_packet_t *rx;

	if (!usb_configuration) return;
    6bac:	4b0b      	ldr	r3, [pc, #44]	; (6bdc <usb_serial_flush_input+0x30>)
    6bae:	781b      	ldrb	r3, [r3, #0]
    6bb0:	b19b      	cbz	r3, 6bda <usb_serial_flush_input+0x2e>
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    6bb2:	b510      	push	{r4, lr}
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
    6bb4:	4c0a      	ldr	r4, [pc, #40]	; (6be0 <usb_serial_flush_input+0x34>)
    6bb6:	6820      	ldr	r0, [r4, #0]
    6bb8:	b148      	cbz	r0, 6bce <usb_serial_flush_input+0x22>
		usb_free(rx_packet);
    6bba:	f7ff ff87 	bl	6acc <usb_free>
		rx_packet = NULL;
    6bbe:	2300      	movs	r3, #0
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    6bc0:	2003      	movs	r0, #3
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
    6bc2:	6023      	str	r3, [r4, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    6bc4:	f7ff fa0e 	bl	5fe4 <usb_rx>
		if (!rx) break;
    6bc8:	b130      	cbz	r0, 6bd8 <usb_serial_flush_input+0x2c>
		usb_free(rx);
    6bca:	f7ff ff7f 	bl	6acc <usb_free>
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    6bce:	2003      	movs	r0, #3
    6bd0:	f7ff fa08 	bl	5fe4 <usb_rx>
		if (!rx) break;
    6bd4:	2800      	cmp	r0, #0
    6bd6:	d1f8      	bne.n	6bca <usb_serial_flush_input+0x1e>
    6bd8:	bd10      	pop	{r4, pc}
    6bda:	4770      	bx	lr
    6bdc:	1fff2bc8 	.word	0x1fff2bc8
    6be0:	1fff2bdc 	.word	0x1fff2bdc

00006be4 <usb_serial_write>:
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    6be4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    6be8:	f8df 90f8 	ldr.w	r9, [pc, #248]	; 6ce4 <usb_serial_write+0x100>
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    6bec:	b083      	sub	sp, #12
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    6bee:	2201      	movs	r2, #1
    6bf0:	f889 2000 	strb.w	r2, [r9]
	while (size > 0) {
    6bf4:	9101      	str	r1, [sp, #4]
    6bf6:	b369      	cbz	r1, 6c54 <usb_serial_write+0x70>
    6bf8:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 6ce8 <usb_serial_write+0x104>
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    6bfc:	4f35      	ldr	r7, [pc, #212]	; (6cd4 <usb_serial_write+0xf0>)
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    6bfe:	9e01      	ldr	r6, [sp, #4]
    6c00:	4683      	mov	fp, r0
		if (!tx_packet) {
    6c02:	f8d8 0000 	ldr.w	r0, [r8]
    6c06:	b3b0      	cbz	r0, 6c76 <usb_serial_write+0x92>
    6c08:	4d33      	ldr	r5, [pc, #204]	; (6cd8 <usb_serial_write+0xf4>)
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
    6c0a:	8844      	ldrh	r4, [r0, #2]
    6c0c:	f1c4 0140 	rsb	r1, r4, #64	; 0x40
    6c10:	42b1      	cmp	r1, r6
    6c12:	bf28      	it	cs
    6c14:	4631      	movcs	r1, r6
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    6c16:	eb04 0e01 	add.w	lr, r4, r1
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    6c1a:	2200      	movs	r2, #0
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    6c1c:	fa1f fe8e 	uxth.w	lr, lr
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    6c20:	702a      	strb	r2, [r5, #0]
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
    6c22:	1a76      	subs	r6, r6, r1
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    6c24:	f8a0 e002 	strh.w	lr, [r0, #2]
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
    6c28:	f100 0208 	add.w	r2, r0, #8
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
    6c2c:	b151      	cbz	r1, 6c44 <usb_serial_write+0x60>
    6c2e:	3c01      	subs	r4, #1
    6c30:	4422      	add	r2, r4
    6c32:	4459      	add	r1, fp
    6c34:	f81b 4b01 	ldrb.w	r4, [fp], #1
    6c38:	f802 4f01 	strb.w	r4, [r2, #1]!
    6c3c:	458b      	cmp	fp, r1
    6c3e:	d1f9      	bne.n	6c34 <usb_serial_write+0x50>
    6c40:	f8b0 e002 	ldrh.w	lr, [r0, #2]
		if (tx_packet->index >= CDC_TX_SIZE) {
    6c44:	f1be 0f3f 	cmp.w	lr, #63	; 0x3f
    6c48:	d80b      	bhi.n	6c62 <usb_serial_write+0x7e>
			tx_packet->len = CDC_TX_SIZE;
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    6c4a:	4a24      	ldr	r2, [pc, #144]	; (6cdc <usb_serial_write+0xf8>)
    6c4c:	2105      	movs	r1, #5
    6c4e:	7011      	strb	r1, [r2, #0]
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    6c50:	2e00      	cmp	r6, #0
    6c52:	d1d6      	bne.n	6c02 <usb_serial_write+0x1e>
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
    6c54:	9801      	ldr	r0, [sp, #4]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
    6c56:	2300      	movs	r3, #0
    6c58:	f889 3000 	strb.w	r3, [r9]
	return ret;
}
    6c5c:	b003      	add	sp, #12
    6c5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
		if (tx_packet->index >= CDC_TX_SIZE) {
			tx_packet->len = CDC_TX_SIZE;
    6c62:	2240      	movs	r2, #64	; 0x40
    6c64:	8002      	strh	r2, [r0, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    6c66:	4601      	mov	r1, r0
    6c68:	2004      	movs	r0, #4
    6c6a:	f7ff fa31 	bl	60d0 <usb_tx>
			tx_packet = NULL;
    6c6e:	2200      	movs	r2, #0
    6c70:	f8c8 2000 	str.w	r2, [r8]
    6c74:	e7e9      	b.n	6c4a <usb_serial_write+0x66>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    6c76:	783a      	ldrb	r2, [r7, #0]
    6c78:	b322      	cbz	r2, 6cc4 <usb_serial_write+0xe0>
    6c7a:	4c19      	ldr	r4, [pc, #100]	; (6ce0 <usb_serial_write+0xfc>)
    6c7c:	4d16      	ldr	r5, [pc, #88]	; (6cd8 <usb_serial_write+0xf4>)
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
    6c7e:	f04f 0a01 	mov.w	sl, #1
    6c82:	e007      	b.n	6c94 <usb_serial_write+0xb0>
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    6c84:	3c01      	subs	r4, #1
    6c86:	d016      	beq.n	6cb6 <usb_serial_write+0xd2>
    6c88:	782a      	ldrb	r2, [r5, #0]
    6c8a:	b9a2      	cbnz	r2, 6cb6 <usb_serial_write+0xd2>
					transmit_previous_timeout = 1;
					return -1;
				}
				yield();
    6c8c:	f000 f96e 	bl	6f6c <yield>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    6c90:	783a      	ldrb	r2, [r7, #0]
    6c92:	b1ba      	cbz	r2, 6cc4 <usb_serial_write+0xe0>
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    6c94:	2004      	movs	r0, #4
    6c96:	f7ff f9c3 	bl	6020 <usb_tx_packet_count>
    6c9a:	2807      	cmp	r0, #7
    6c9c:	d8f2      	bhi.n	6c84 <usb_serial_write+0xa0>
					tx_noautoflush = 1;
    6c9e:	f889 a000 	strb.w	sl, [r9]
					tx_packet = usb_malloc();
    6ca2:	f7ff fef3 	bl	6a8c <usb_malloc>
    6ca6:	f8c8 0000 	str.w	r0, [r8]
					if (tx_packet) break;
    6caa:	2800      	cmp	r0, #0
    6cac:	d1ad      	bne.n	6c0a <usb_serial_write+0x26>
					tx_noautoflush = 0;
    6cae:	4b0d      	ldr	r3, [pc, #52]	; (6ce4 <usb_serial_write+0x100>)
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    6cb0:	3c01      	subs	r4, #1
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
    6cb2:	7018      	strb	r0, [r3, #0]
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    6cb4:	d1e8      	bne.n	6c88 <usb_serial_write+0xa4>
					transmit_previous_timeout = 1;
    6cb6:	2301      	movs	r3, #1
					return -1;
    6cb8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
					transmit_previous_timeout = 1;
    6cbc:	702b      	strb	r3, [r5, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    6cbe:	b003      	add	sp, #12
    6cc0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    6cc4:	2300      	movs	r3, #0
					return -1;
    6cc6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    6cca:	f889 3000 	strb.w	r3, [r9]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    6cce:	b003      	add	sp, #12
    6cd0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6cd4:	1fff2bc8 	.word	0x1fff2bc8
    6cd8:	1fff2bd8 	.word	0x1fff2bd8
    6cdc:	1fff2bd0 	.word	0x1fff2bd0
    6ce0:	00014821 	.word	0x00014821
    6ce4:	1fff2bd1 	.word	0x1fff2bd1
    6ce8:	1fff2bd4 	.word	0x1fff2bd4

00006cec <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    6cec:	b500      	push	{lr}
    6cee:	b083      	sub	sp, #12
    6cf0:	ab02      	add	r3, sp, #8
	return usb_serial_write(&c, 1);
    6cf2:	2101      	movs	r1, #1
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    6cf4:	f803 0d01 	strb.w	r0, [r3, #-1]!
	return usb_serial_write(&c, 1);
    6cf8:	4618      	mov	r0, r3
    6cfa:	f7ff ff73 	bl	6be4 <usb_serial_write>
}
    6cfe:	b003      	add	sp, #12
    6d00:	f85d fb04 	ldr.w	pc, [sp], #4

00006d04 <usb_serial_write_buffer_free>:
	tx_noautoflush = 0;
	return ret;
}

int usb_serial_write_buffer_free(void)
{
    6d04:	b538      	push	{r3, r4, r5, lr}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
    6d06:	4d0e      	ldr	r5, [pc, #56]	; (6d40 <usb_serial_write_buffer_free+0x3c>)

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    6d08:	4c0e      	ldr	r4, [pc, #56]	; (6d44 <usb_serial_write_buffer_free+0x40>)
	if (!tx_packet) {
    6d0a:	6828      	ldr	r0, [r5, #0]

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    6d0c:	2301      	movs	r3, #1
    6d0e:	7023      	strb	r3, [r4, #0]
	if (!tx_packet) {
    6d10:	b128      	cbz	r0, 6d1e <usb_serial_write_buffer_free+0x1a>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    6d12:	8840      	ldrh	r0, [r0, #2]
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    6d14:	2300      	movs	r3, #0
    6d16:	7023      	strb	r3, [r4, #0]
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    6d18:	f1c0 0040 	rsb	r0, r0, #64	; 0x40
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
	return len;
}
    6d1c:	bd38      	pop	{r3, r4, r5, pc}
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    6d1e:	4b0a      	ldr	r3, [pc, #40]	; (6d48 <usb_serial_write_buffer_free+0x44>)
    6d20:	781b      	ldrb	r3, [r3, #0]
    6d22:	b913      	cbnz	r3, 6d2a <usb_serial_write_buffer_free+0x26>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    6d24:	2000      	movs	r0, #0
    6d26:	7020      	strb	r0, [r4, #0]
			return 0;
    6d28:	bd38      	pop	{r3, r4, r5, pc}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    6d2a:	2004      	movs	r0, #4
    6d2c:	f7ff f978 	bl	6020 <usb_tx_packet_count>
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    6d30:	2807      	cmp	r0, #7
    6d32:	d8f7      	bhi.n	6d24 <usb_serial_write_buffer_free+0x20>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
    6d34:	f7ff feaa 	bl	6a8c <usb_malloc>
    6d38:	6028      	str	r0, [r5, #0]
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    6d3a:	2800      	cmp	r0, #0
    6d3c:	d1e9      	bne.n	6d12 <usb_serial_write_buffer_free+0xe>
    6d3e:	e7f1      	b.n	6d24 <usb_serial_write_buffer_free+0x20>
    6d40:	1fff2bd4 	.word	0x1fff2bd4
    6d44:	1fff2bd1 	.word	0x1fff2bd1
    6d48:	1fff2bc8 	.word	0x1fff2bc8

00006d4c <usb_serial_flush_output>:
	tx_noautoflush = 0;
	return len;
}

void usb_serial_flush_output(void)
{
    6d4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!usb_configuration) return;
    6d4e:	4b11      	ldr	r3, [pc, #68]	; (6d94 <usb_serial_flush_output+0x48>)
    6d50:	781b      	ldrb	r3, [r3, #0]
    6d52:	b18b      	cbz	r3, 6d78 <usb_serial_flush_output+0x2c>
	tx_noautoflush = 1;
	if (tx_packet) {
    6d54:	4e10      	ldr	r6, [pc, #64]	; (6d98 <usb_serial_flush_output+0x4c>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    6d56:	4d11      	ldr	r5, [pc, #68]	; (6d9c <usb_serial_flush_output+0x50>)
	if (tx_packet) {
    6d58:	6834      	ldr	r4, [r6, #0]
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    6d5a:	2701      	movs	r7, #1
    6d5c:	702f      	strb	r7, [r5, #0]
	if (tx_packet) {
    6d5e:	b164      	cbz	r4, 6d7a <usb_serial_flush_output+0x2e>
		usb_cdc_transmit_flush_timer = 0;
    6d60:	4a0f      	ldr	r2, [pc, #60]	; (6da0 <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
    6d62:	8863      	ldrh	r3, [r4, #2]
void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
    6d64:	2700      	movs	r7, #0
    6d66:	7017      	strb	r7, [r2, #0]
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    6d68:	4621      	mov	r1, r4
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
    6d6a:	8023      	strh	r3, [r4, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    6d6c:	2004      	movs	r0, #4
    6d6e:	f7ff f9af 	bl	60d0 <usb_tx>
		tx_packet = NULL;
    6d72:	6037      	str	r7, [r6, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
	tx_noautoflush = 0;
    6d74:	2300      	movs	r3, #0
    6d76:	702b      	strb	r3, [r5, #0]
    6d78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    6d7a:	f7ff fe87 	bl	6a8c <usb_malloc>
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    6d7e:	4b08      	ldr	r3, [pc, #32]	; (6da0 <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
    6d80:	b128      	cbz	r0, 6d8e <usb_serial_flush_output+0x42>
			usb_cdc_transmit_flush_timer = 0;
			usb_tx(CDC_TX_ENDPOINT, tx);
    6d82:	4601      	mov	r1, r0
    6d84:	2004      	movs	r0, #4
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    6d86:	701c      	strb	r4, [r3, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    6d88:	f7ff f9a2 	bl	60d0 <usb_tx>
    6d8c:	e7f2      	b.n	6d74 <usb_serial_flush_output+0x28>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    6d8e:	701f      	strb	r7, [r3, #0]
    6d90:	e7f0      	b.n	6d74 <usb_serial_flush_output+0x28>
    6d92:	bf00      	nop
    6d94:	1fff2bc8 	.word	0x1fff2bc8
    6d98:	1fff2bd4 	.word	0x1fff2bd4
    6d9c:	1fff2bd1 	.word	0x1fff2bd1
    6da0:	1fff2bd0 	.word	0x1fff2bd0

00006da4 <usb_serial_flush_callback>:
	}
	tx_noautoflush = 0;
}

void usb_serial_flush_callback(void)
{
    6da4:	b538      	push	{r3, r4, r5, lr}
	if (tx_noautoflush) return;
    6da6:	4b0e      	ldr	r3, [pc, #56]	; (6de0 <usb_serial_flush_callback+0x3c>)
    6da8:	781b      	ldrb	r3, [r3, #0]
    6daa:	b973      	cbnz	r3, 6dca <usb_serial_flush_callback+0x26>
	if (tx_packet) {
    6dac:	4c0d      	ldr	r4, [pc, #52]	; (6de4 <usb_serial_flush_callback+0x40>)
    6dae:	6821      	ldr	r1, [r4, #0]
    6db0:	b161      	cbz	r1, 6dcc <usb_serial_flush_callback+0x28>
    6db2:	f003 05ff 	and.w	r5, r3, #255	; 0xff
		tx_packet->len = tx_packet->index;
    6db6:	884b      	ldrh	r3, [r1, #2]
    6db8:	800b      	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    6dba:	2004      	movs	r0, #4
    6dbc:	f7ff f988 	bl	60d0 <usb_tx>
		tx_packet = NULL;
    6dc0:	6025      	str	r5, [r4, #0]
    6dc2:	bd38      	pop	{r3, r4, r5, pc}
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
    6dc4:	4b08      	ldr	r3, [pc, #32]	; (6de8 <usb_serial_flush_callback+0x44>)
    6dc6:	2201      	movs	r2, #1
    6dc8:	701a      	strb	r2, [r3, #0]
    6dca:	bd38      	pop	{r3, r4, r5, pc}
	if (tx_packet) {
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    6dcc:	f7ff fe5e 	bl	6a8c <usb_malloc>
		if (tx) {
    6dd0:	2800      	cmp	r0, #0
    6dd2:	d0f7      	beq.n	6dc4 <usb_serial_flush_callback+0x20>
			usb_tx(CDC_TX_ENDPOINT, tx);
    6dd4:	4601      	mov	r1, r0
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    6dd6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
    6dda:	2004      	movs	r0, #4
    6ddc:	f7ff b978 	b.w	60d0 <usb_tx>
    6de0:	1fff2bd1 	.word	0x1fff2bd1
    6de4:	1fff2bd4 	.word	0x1fff2bd4
    6de8:	1fff2bd0 	.word	0x1fff2bd0

00006dec <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    6dec:	b570      	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    6dee:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    6df2:	b672      	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    6df4:	4c0c      	ldr	r4, [pc, #48]	; (6e28 <EventResponder::runFromInterrupt()+0x3c>)
    6df6:	6820      	ldr	r0, [r4, #0]
		if (first) {
    6df8:	b180      	cbz	r0, 6e1c <EventResponder::runFromInterrupt()+0x30>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    6dfa:	4e0c      	ldr	r6, [pc, #48]	; (6e2c <EventResponder::runFromInterrupt()+0x40>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    6dfc:	2500      	movs	r5, #0
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
    6dfe:	6943      	ldr	r3, [r0, #20]
    6e00:	6023      	str	r3, [r4, #0]
			if (firstInterrupt) {
    6e02:	b173      	cbz	r3, 6e22 <EventResponder::runFromInterrupt()+0x36>
				firstInterrupt->_prev = nullptr;
    6e04:	619d      	str	r5, [r3, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    6e06:	b902      	cbnz	r2, 6e0a <EventResponder::runFromInterrupt()+0x1e>
    6e08:	b662      	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    6e0a:	7745      	strb	r5, [r0, #29]
			(*(first->_function))(*first);
    6e0c:	6883      	ldr	r3, [r0, #8]
    6e0e:	4798      	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    6e10:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    6e14:	b672      	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    6e16:	6820      	ldr	r0, [r4, #0]
		if (first) {
    6e18:	2800      	cmp	r0, #0
    6e1a:	d1f0      	bne.n	6dfe <EventResponder::runFromInterrupt()+0x12>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    6e1c:	b902      	cbnz	r2, 6e20 <EventResponder::runFromInterrupt()+0x34>
    6e1e:	b662      	cpsie	i
    6e20:	bd70      	pop	{r4, r5, r6, pc}
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    6e22:	6033      	str	r3, [r6, #0]
    6e24:	e7ef      	b.n	6e06 <EventResponder::runFromInterrupt()+0x1a>
    6e26:	bf00      	nop
    6e28:	1fff2be4 	.word	0x1fff2be4
    6e2c:	1fff2be8 	.word	0x1fff2be8

00006e30 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    6e30:	f7ff bfdc 	b.w	6dec <EventResponder::runFromInterrupt()>

00006e34 <systick_isr>:

extern "C" volatile uint32_t systick_millis_count;

void systick_isr(void)
{
	systick_millis_count++;
    6e34:	4a02      	ldr	r2, [pc, #8]	; (6e40 <systick_isr+0xc>)
    6e36:	6813      	ldr	r3, [r2, #0]
    6e38:	3301      	adds	r3, #1
    6e3a:	6013      	str	r3, [r2, #0]
    6e3c:	4770      	bx	lr
    6e3e:	bf00      	nop
    6e40:	1fff2ae4 	.word	0x1fff2ae4

00006e44 <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    6e44:	b530      	push	{r4, r5, lr}
    6e46:	4604      	mov	r4, r0
    6e48:	b083      	sub	sp, #12
	uint8_t buf[2]={'\r', '\n'};
    6e4a:	2502      	movs	r5, #2
    6e4c:	462a      	mov	r2, r5
    6e4e:	a801      	add	r0, sp, #4
    6e50:	4905      	ldr	r1, [pc, #20]	; (6e68 <Print::println()+0x24>)
    6e52:	f7fe fbaf 	bl	55b4 <memcpy>
	return write(buf, 2);
    6e56:	6823      	ldr	r3, [r4, #0]
    6e58:	462a      	mov	r2, r5
    6e5a:	a901      	add	r1, sp, #4
    6e5c:	685b      	ldr	r3, [r3, #4]
    6e5e:	4620      	mov	r0, r4
    6e60:	4798      	blx	r3
}
    6e62:	b003      	add	sp, #12
    6e64:	bd30      	pop	{r4, r5, pc}
    6e66:	bf00      	nop
    6e68:	00009684 	.word	0x00009684

00006e6c <String::~String()>:
	init();
	char buf[40];
	*this = dtostrf(num, digits + 2, digits, buf);
}

String::~String()
    6e6c:	b510      	push	{r4, lr}
    6e6e:	4604      	mov	r4, r0
{
	free(buffer);
    6e70:	6800      	ldr	r0, [r0, #0]
    6e72:	f000 ff07 	bl	7c84 <free>
}
    6e76:	4620      	mov	r0, r4
    6e78:	bd10      	pop	{r4, pc}
    6e7a:	bf00      	nop

00006e7c <String::reserve(unsigned int)>:
	len = 0;
	flags = 0;
}

unsigned char String::reserve(unsigned int size)
{
    6e7c:	b538      	push	{r3, r4, r5, lr}
	if (capacity >= size) return 1;
    6e7e:	6843      	ldr	r3, [r0, #4]
    6e80:	428b      	cmp	r3, r1
    6e82:	d301      	bcc.n	6e88 <String::reserve(unsigned int)+0xc>
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    6e84:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
    6e86:	bd38      	pop	{r3, r4, r5, pc}
    6e88:	460d      	mov	r5, r1
    6e8a:	4604      	mov	r4, r0

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
    6e8c:	3101      	adds	r1, #1
    6e8e:	6800      	ldr	r0, [r0, #0]
    6e90:	f001 fa6e 	bl	8370 <realloc>
	if (newbuffer) {
    6e94:	2800      	cmp	r0, #0
    6e96:	d0f6      	beq.n	6e86 <String::reserve(unsigned int)+0xa>

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    6e98:	68a3      	ldr	r3, [r4, #8]
unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
	if (newbuffer) {
		buffer = newbuffer;
		capacity = maxStrLen;
    6e9a:	e884 0021 	stmia.w	r4, {r0, r5}

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    6e9e:	2b00      	cmp	r3, #0
    6ea0:	d1f0      	bne.n	6e84 <String::reserve(unsigned int)+0x8>
    6ea2:	7003      	strb	r3, [r0, #0]
    6ea4:	e7ee      	b.n	6e84 <String::reserve(unsigned int)+0x8>
    6ea6:	bf00      	nop

00006ea8 <String::copy(char const*, unsigned int)>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
    6ea8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6eaa:	4604      	mov	r4, r0
	if (length == 0) {
    6eac:	4615      	mov	r5, r2
    6eae:	b932      	cbnz	r2, 6ebe <String::copy(char const*, unsigned int)+0x16>
		if (buffer) buffer[0] = 0;
    6eb0:	6803      	ldr	r3, [r0, #0]
    6eb2:	b103      	cbz	r3, 6eb6 <String::copy(char const*, unsigned int)+0xe>
    6eb4:	701a      	strb	r2, [r3, #0]
		len = 0;
    6eb6:	2300      	movs	r3, #0
    6eb8:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    6eba:	4620      	mov	r0, r4
    6ebc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6ebe:	460e      	mov	r6, r1
	if (length == 0) {
		if (buffer) buffer[0] = 0;
		len = 0;
		return *this;
	}
	if (!reserve(length)) {
    6ec0:	4611      	mov	r1, r2
    6ec2:	f7ff ffdb 	bl	6e7c <String::reserve(unsigned int)>
    6ec6:	4607      	mov	r7, r0
    6ec8:	b948      	cbnz	r0, 6ede <String::copy(char const*, unsigned int)+0x36>
		if (buffer) {
    6eca:	6820      	ldr	r0, [r4, #0]
    6ecc:	b110      	cbz	r0, 6ed4 <String::copy(char const*, unsigned int)+0x2c>
			free(buffer);
    6ece:	f000 fed9 	bl	7c84 <free>
			buffer = NULL;
    6ed2:	6027      	str	r7, [r4, #0]
		}
		len = capacity = 0;
    6ed4:	2300      	movs	r3, #0
    6ed6:	6063      	str	r3, [r4, #4]
    6ed8:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    6eda:	4620      	mov	r0, r4
    6edc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			buffer = NULL;
		}
		len = capacity = 0;
		return *this;
	}
	len = length;
    6ede:	60a5      	str	r5, [r4, #8]
	strcpy(buffer, cstr);
    6ee0:	4631      	mov	r1, r6
    6ee2:	6820      	ldr	r0, [r4, #0]
    6ee4:	f001 fdca 	bl	8a7c <strcpy>
	return *this;
    6ee8:	e7e7      	b.n	6eba <String::copy(char const*, unsigned int)+0x12>
    6eea:	bf00      	nop

00006eec <String::String(char const*)>:

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    6eec:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    6eee:	2300      	movs	r3, #0

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    6ef0:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    6ef2:	6003      	str	r3, [r0, #0]
	capacity = 0;
    6ef4:	6043      	str	r3, [r0, #4]
	len = 0;
    6ef6:	6083      	str	r3, [r0, #8]
	flags = 0;
    6ef8:	7303      	strb	r3, [r0, #12]
/*********************************************/

String::String(const char *cstr)
{
	init();
	if (cstr) copy(cstr, strlen(cstr));
    6efa:	b141      	cbz	r1, 6f0e <String::String(char const*)+0x22>
    6efc:	4608      	mov	r0, r1
    6efe:	460d      	mov	r5, r1
    6f00:	f001 fe1e 	bl	8b40 <strlen>
    6f04:	4629      	mov	r1, r5
    6f06:	4602      	mov	r2, r0
    6f08:	4620      	mov	r0, r4
    6f0a:	f7ff ffcd 	bl	6ea8 <String::copy(char const*, unsigned int)>
}
    6f0e:	4620      	mov	r0, r4
    6f10:	bd38      	pop	{r3, r4, r5, pc}
    6f12:	bf00      	nop

00006f14 <String::equals(char const*) const>:
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    6f14:	6882      	ldr	r2, [r0, #8]
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
    6f16:	b508      	push	{r3, lr}
    6f18:	460b      	mov	r3, r1
	if (len == 0) return (cstr == NULL || *cstr == 0);
    6f1a:	b92a      	cbnz	r2, 6f28 <String::equals(char const*) const+0x14>
    6f1c:	b171      	cbz	r1, 6f3c <String::equals(char const*) const+0x28>
	if (cstr == NULL) return buffer[0] == 0;
    6f1e:	7818      	ldrb	r0, [r3, #0]
    6f20:	fab0 f080 	clz	r0, r0
    6f24:	0940      	lsrs	r0, r0, #5
    6f26:	bd08      	pop	{r3, pc}
    6f28:	b131      	cbz	r1, 6f38 <String::equals(char const*) const+0x24>
	return strcmp(buffer, cstr) == 0;
    6f2a:	6800      	ldr	r0, [r0, #0]
    6f2c:	f001 fc3c 	bl	87a8 <strcmp>
    6f30:	fab0 f080 	clz	r0, r0
    6f34:	0940      	lsrs	r0, r0, #5
}
    6f36:	bd08      	pop	{r3, pc}
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
	if (cstr == NULL) return buffer[0] == 0;
    6f38:	6803      	ldr	r3, [r0, #0]
    6f3a:	e7f0      	b.n	6f1e <String::equals(char const*) const+0xa>
    6f3c:	2001      	movs	r0, #1
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    6f3e:	bd08      	pop	{r3, pc}

00006f40 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    6f40:	b508      	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    6f42:	f7fb feb3 	bl	2cac <setup>
	while (1) {
		loop();
    6f46:	f7fb fff3 	bl	2f30 <loop>
		yield();
    6f4a:	f000 f80f 	bl	6f6c <yield>
    6f4e:	e7fa      	b.n	6f46 <main+0x6>

00006f50 <usb_serial_class::clear()>:
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    6f50:	f7ff be2c 	b.w	6bac <usb_serial_flush_input>

00006f54 <usb_serial_class::peek()>:
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    6f54:	f7ff be04 	b.w	6b60 <usb_serial_peekchar>

00006f58 <usb_serial_class::available()>:
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    6f58:	f7ff be1a 	b.w	6b90 <usb_serial_available>

00006f5c <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    6f5c:	f7ff bef6 	b.w	6d4c <usb_serial_flush_output>

00006f60 <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    6f60:	f7ff bed0 	b.w	6d04 <usb_serial_write_buffer_free>

00006f64 <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    6f64:	4608      	mov	r0, r1
    6f66:	f7ff bec1 	b.w	6cec <usb_serial_putchar>
    6f6a:	bf00      	nop

00006f6c <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    6f6c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    6f70:	4e31      	ldr	r6, [pc, #196]	; (7038 <yield+0xcc>)
    6f72:	7833      	ldrb	r3, [r6, #0]
    6f74:	b193      	cbz	r3, 6f9c <yield+0x30>
	if (running) return; // TODO: does this need to be atomic?
    6f76:	4f31      	ldr	r7, [pc, #196]	; (703c <yield+0xd0>)
    6f78:	783a      	ldrb	r2, [r7, #0]
    6f7a:	b97a      	cbnz	r2, 6f9c <yield+0x30>
	running = 1;
    6f7c:	2201      	movs	r2, #1


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    6f7e:	07d9      	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    6f80:	703a      	strb	r2, [r7, #0]


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    6f82:	d436      	bmi.n	6ff2 <yield+0x86>
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIALUSB2) {
		if (SerialUSB2.available()) serialEventUSB2();
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    6f84:	079a      	lsls	r2, r3, #30
    6f86:	d419      	bmi.n	6fbc <yield+0x50>
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    6f88:	2200      	movs	r2, #0
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    6f8a:	075b      	lsls	r3, r3, #29
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    6f8c:	703a      	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    6f8e:	d505      	bpl.n	6f9c <yield+0x30>
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;  
    6f90:	4b2b      	ldr	r3, [pc, #172]	; (7040 <yield+0xd4>)
    6f92:	681a      	ldr	r2, [r3, #0]
    6f94:	b112      	cbz	r2, 6f9c <yield+0x30>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    6f96:	f3ef 8205 	mrs	r2, IPSR
		if (ipsr != 0) return;
    6f9a:	b10a      	cbz	r2, 6fa0 <yield+0x34>
    6f9c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    6fa0:	f3ef 8110 	mrs	r1, PRIMASK
		__disable_irq();
    6fa4:	b672      	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    6fa6:	6818      	ldr	r0, [r3, #0]
		if (first == nullptr) {
    6fa8:	b118      	cbz	r0, 6fb2 <yield+0x46>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    6faa:	4c26      	ldr	r4, [pc, #152]	; (7044 <yield+0xd8>)
    6fac:	7822      	ldrb	r2, [r4, #0]
    6fae:	2a00      	cmp	r2, #0
    6fb0:	d02e      	beq.n	7010 <yield+0xa4>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    6fb2:	2900      	cmp	r1, #0
    6fb4:	d1f2      	bne.n	6f9c <yield+0x30>
    6fb6:	b662      	cpsie	i
    6fb8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    6fbc:	f8df 8090 	ldr.w	r8, [pc, #144]	; 7050 <yield+0xe4>
    6fc0:	f898 2000 	ldrb.w	r2, [r8]
    6fc4:	2a00      	cmp	r2, #0
    6fc6:	d0df      	beq.n	6f88 <yield+0x1c>
    6fc8:	f8df 9088 	ldr.w	r9, [pc, #136]	; 7054 <yield+0xe8>
    6fcc:	2400      	movs	r4, #0
    6fce:	e005      	b.n	6fdc <yield+0x70>
    6fd0:	3401      	adds	r4, #1
    6fd2:	f898 3000 	ldrb.w	r3, [r8]
    6fd6:	b2e4      	uxtb	r4, r4
    6fd8:	42a3      	cmp	r3, r4
    6fda:	d912      	bls.n	7002 <yield+0x96>
			s_serials_with_serial_events[i]->doYieldCode();
    6fdc:	f859 5024 	ldr.w	r5, [r9, r4, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
	static uint8_t 			s_count_serials_with_serial_events;
	void 		(* const _serialEvent)(); 
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*_serialEvent)();
    6fe0:	682b      	ldr	r3, [r5, #0]
    6fe2:	4628      	mov	r0, r5
    6fe4:	691b      	ldr	r3, [r3, #16]
    6fe6:	4798      	blx	r3
    6fe8:	2800      	cmp	r0, #0
    6fea:	d0f1      	beq.n	6fd0 <yield+0x64>
    6fec:	692b      	ldr	r3, [r5, #16]
    6fee:	4798      	blx	r3
    6ff0:	e7ee      	b.n	6fd0 <yield+0x64>
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    6ff2:	f7ff fdcd 	bl	6b90 <usb_serial_available>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    6ff6:	b9c8      	cbnz	r0, 702c <yield+0xc0>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    6ff8:	4b13      	ldr	r3, [pc, #76]	; (7048 <yield+0xdc>)
    6ffa:	781b      	ldrb	r3, [r3, #0]
    6ffc:	b91b      	cbnz	r3, 7006 <yield+0x9a>
    6ffe:	7833      	ldrb	r3, [r6, #0]
    7000:	e7c0      	b.n	6f84 <yield+0x18>
    7002:	7833      	ldrb	r3, [r6, #0]
    7004:	e7c0      	b.n	6f88 <yield+0x1c>
    7006:	7833      	ldrb	r3, [r6, #0]
    7008:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    700c:	7033      	strb	r3, [r6, #0]
    700e:	e7b9      	b.n	6f84 <yield+0x18>
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
		firstYield = first->_next;
    7010:	6945      	ldr	r5, [r0, #20]
    7012:	601d      	str	r5, [r3, #0]
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    7014:	2301      	movs	r3, #1
    7016:	7023      	strb	r3, [r4, #0]
		firstYield = first->_next;
		if (firstYield) {
    7018:	b15d      	cbz	r5, 7032 <yield+0xc6>
			firstYield->_prev = nullptr;
    701a:	61aa      	str	r2, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    701c:	b901      	cbnz	r1, 7020 <yield+0xb4>
    701e:	b662      	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    7020:	2500      	movs	r5, #0
    7022:	7745      	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    7024:	6883      	ldr	r3, [r0, #8]
    7026:	4798      	blx	r3
		runningFromYield = false;
    7028:	7025      	strb	r5, [r4, #0]
    702a:	e7b7      	b.n	6f9c <yield+0x30>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    702c:	f000 f928 	bl	7280 <serialEvent()>
    7030:	e7e2      	b.n	6ff8 <yield+0x8c>
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
    7032:	4b06      	ldr	r3, [pc, #24]	; (704c <yield+0xe0>)
    7034:	601d      	str	r5, [r3, #0]
    7036:	e7f1      	b.n	701c <yield+0xb0>
    7038:	1fff0b34 	.word	0x1fff0b34
    703c:	1fff2bf5 	.word	0x1fff2bf5
    7040:	1fff2bf0 	.word	0x1fff2bf0
    7044:	1fff2bf4 	.word	0x1fff2bf4
    7048:	1fff0bda 	.word	0x1fff0bda
    704c:	1fff2bec 	.word	0x1fff2bec
    7050:	1fff2c10 	.word	0x1fff2c10
    7054:	1fff2bf8 	.word	0x1fff2bf8

00007058 <analog_init>:
#else
#error "F_BUS must be 128, 120, 108, 96, 90, 80, 72, 64, 60, 56, 54, 48, 40, 36, 24, 4 or 2 MHz"
#endif

void analog_init(void)
{
    7058:	b430      	push	{r4, r5}
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    705a:	4829      	ldr	r0, [pc, #164]	; (7100 <analog_init+0xa8>)
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    705c:	4a29      	ldr	r2, [pc, #164]	; (7104 <analog_init+0xac>)
	#endif

	if (analog_config_bits == 8) {
    705e:	4b2a      	ldr	r3, [pc, #168]	; (7108 <analog_init+0xb0>)
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    7060:	4d2a      	ldr	r5, [pc, #168]	; (710c <analog_init+0xb4>)
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    7062:	2460      	movs	r4, #96	; 0x60
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    7064:	21e1      	movs	r1, #225	; 0xe1
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    7066:	7004      	strb	r4, [r0, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    7068:	7011      	strb	r1, [r2, #0]
	#endif

	if (analog_config_bits == 8) {
    706a:	781b      	ldrb	r3, [r3, #0]
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    706c:	4c28      	ldr	r4, [pc, #160]	; (7110 <analog_init+0xb8>)
	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
    706e:	2b08      	cmp	r3, #8
    7070:	d030      	beq.n	70d4 <analog_init+0x7c>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    7072:	2b0a      	cmp	r3, #10
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    7074:	4827      	ldr	r0, [pc, #156]	; (7114 <analog_init+0xbc>)
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    7076:	4928      	ldr	r1, [pc, #160]	; (7118 <analog_init+0xc0>)
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    7078:	d037      	beq.n	70ea <analog_init+0x92>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    707a:	2b0c      	cmp	r3, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    707c:	bf0c      	ite	eq
    707e:	2235      	moveq	r2, #53	; 0x35
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    7080:	225d      	movne	r2, #93	; 0x5d
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    7082:	2312      	movs	r3, #18
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    7084:	602a      	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    7086:	6023      	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    7088:	6002      	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    708a:	600b      	str	r3, [r1, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    708c:	4b23      	ldr	r3, [pc, #140]	; (711c <analog_init+0xc4>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    708e:	4924      	ldr	r1, [pc, #144]	; (7120 <analog_init+0xc8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    7090:	781b      	ldrb	r3, [r3, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    7092:	4a24      	ldr	r2, [pc, #144]	; (7124 <analog_init+0xcc>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    7094:	b1bb      	cbz	r3, 70c6 <analog_init+0x6e>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    7096:	2301      	movs	r3, #1
    7098:	600b      	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    709a:	6013      	str	r3, [r2, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    709c:	4b22      	ldr	r3, [pc, #136]	; (7128 <analog_init+0xd0>)
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    709e:	4923      	ldr	r1, [pc, #140]	; (712c <analog_init+0xd4>)
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    70a0:	781b      	ldrb	r3, [r3, #0]
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    70a2:	4a23      	ldr	r2, [pc, #140]	; (7130 <analog_init+0xd8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
    70a4:	2b01      	cmp	r3, #1
    70a6:	d926      	bls.n	70f6 <analog_init+0x9e>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
    70a8:	2b04      	cmp	r3, #4
    70aa:	d90f      	bls.n	70cc <analog_init+0x74>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
    70ac:	2b08      	cmp	r3, #8
    70ae:	d91e      	bls.n	70ee <analog_init+0x96>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#endif
	} else if (num <= 16) {
    70b0:	2b10      	cmp	r3, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    70b2:	bf94      	ite	ls
    70b4:	2386      	movls	r3, #134	; 0x86
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    70b6:	2387      	movhi	r3, #135	; 0x87
    70b8:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    70ba:	6013      	str	r3, [r2, #0]
		#endif
	}
	calibrating = 1;
    70bc:	4b1d      	ldr	r3, [pc, #116]	; (7134 <analog_init+0xdc>)
    70be:	2201      	movs	r2, #1
    70c0:	701a      	strb	r2, [r3, #0]
}
    70c2:	bc30      	pop	{r4, r5}
    70c4:	4770      	bx	lr
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    70c6:	600b      	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    70c8:	6013      	str	r3, [r2, #0]
    70ca:	e7e7      	b.n	709c <analog_init+0x44>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    70cc:	2384      	movs	r3, #132	; 0x84
    70ce:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    70d0:	6013      	str	r3, [r2, #0]
    70d2:	e7f3      	b.n	70bc <analog_init+0x64>

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    70d4:	f500 208e 	add.w	r0, r0, #290816	; 0x47000
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    70d8:	490f      	ldr	r1, [pc, #60]	; (7118 <analog_init+0xc0>)

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    70da:	3008      	adds	r0, #8
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    70dc:	2221      	movs	r2, #33	; 0x21
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    70de:	2313      	movs	r3, #19
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    70e0:	602a      	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    70e2:	6023      	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    70e4:	6002      	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    70e6:	600b      	str	r3, [r1, #0]
    70e8:	e7d0      	b.n	708c <analog_init+0x34>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    70ea:	2239      	movs	r2, #57	; 0x39
    70ec:	e7f7      	b.n	70de <analog_init+0x86>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    70ee:	2385      	movs	r3, #133	; 0x85
    70f0:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    70f2:	6013      	str	r3, [r2, #0]
    70f4:	e7e2      	b.n	70bc <analog_init+0x64>
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    70f6:	2380      	movs	r3, #128	; 0x80
    70f8:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    70fa:	6013      	str	r3, [r2, #0]
    70fc:	e7de      	b.n	70bc <analog_init+0x64>
    70fe:	bf00      	nop
    7100:	40074000 	.word	0x40074000
    7104:	40074001 	.word	0x40074001
    7108:	1fff0b35 	.word	0x1fff0b35
    710c:	4003b008 	.word	0x4003b008
    7110:	4003b00c 	.word	0x4003b00c
    7114:	400bb008 	.word	0x400bb008
    7118:	400bb00c 	.word	0x400bb00c
    711c:	1fff2bf7 	.word	0x1fff2bf7
    7120:	4003b020 	.word	0x4003b020
    7124:	400bb020 	.word	0x400bb020
    7128:	1fff0b36 	.word	0x1fff0b36
    712c:	4003b024 	.word	0x4003b024
    7130:	400bb024 	.word	0x400bb024
    7134:	1fff2bf6 	.word	0x1fff2bf6

00007138 <analogWriteDAC0>:
typedef int16_t __attribute__((__may_alias__)) aliased_int16_t;

void analogWriteDAC0(int val)
{
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_DAC0;
    7138:	4a0a      	ldr	r2, [pc, #40]	; (7164 <analogWriteDAC0+0x2c>)
	if (analog_reference_internal) {
    713a:	490b      	ldr	r1, [pc, #44]	; (7168 <analogWriteDAC0+0x30>)
typedef int16_t __attribute__((__may_alias__)) aliased_int16_t;

void analogWriteDAC0(int val)
{
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_DAC0;
    713c:	6813      	ldr	r3, [r2, #0]
    713e:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    7142:	6013      	str	r3, [r2, #0]
	if (analog_reference_internal) {
    7144:	780b      	ldrb	r3, [r1, #0]
    7146:	b943      	cbnz	r3, 715a <analogWriteDAC0+0x22>
		DAC0_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC0_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
    7148:	4b08      	ldr	r3, [pc, #32]	; (716c <analogWriteDAC0+0x34>)
    714a:	22c0      	movs	r2, #192	; 0xc0
    714c:	701a      	strb	r2, [r3, #0]
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095

	*(volatile aliased_int16_t *)&(DAC0_DAT0L) = val;
    714e:	4b08      	ldr	r3, [pc, #32]	; (7170 <analogWriteDAC0+0x38>)
	if (analog_reference_internal) {
		DAC0_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC0_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095
    7150:	f380 000c 	usat	r0, #12, r0

	*(volatile aliased_int16_t *)&(DAC0_DAT0L) = val;
    7154:	b200      	sxth	r0, r0
    7156:	8018      	strh	r0, [r3, #0]
    7158:	4770      	bx	lr
void analogWriteDAC0(int val)
{
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_DAC0;
	if (analog_reference_internal) {
		DAC0_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
    715a:	4b04      	ldr	r3, [pc, #16]	; (716c <analogWriteDAC0+0x34>)
    715c:	2280      	movs	r2, #128	; 0x80
    715e:	701a      	strb	r2, [r3, #0]
    7160:	e7f5      	b.n	714e <analogWriteDAC0+0x16>
    7162:	bf00      	nop
    7164:	4004802c 	.word	0x4004802c
    7168:	1fff2bf7 	.word	0x1fff2bf7
    716c:	400cc021 	.word	0x400cc021
    7170:	400cc000 	.word	0x400cc000

00007174 <analogWriteDAC1>:


#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
void analogWriteDAC1(int val)
{
	SIM_SCGC2 |= SIM_SCGC2_DAC1;
    7174:	4a0a      	ldr	r2, [pc, #40]	; (71a0 <analogWriteDAC1+0x2c>)
	if (analog_reference_internal) {
    7176:	490b      	ldr	r1, [pc, #44]	; (71a4 <analogWriteDAC1+0x30>)


#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
void analogWriteDAC1(int val)
{
	SIM_SCGC2 |= SIM_SCGC2_DAC1;
    7178:	6813      	ldr	r3, [r2, #0]
    717a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    717e:	6013      	str	r3, [r2, #0]
	if (analog_reference_internal) {
    7180:	780b      	ldrb	r3, [r1, #0]
    7182:	b943      	cbnz	r3, 7196 <analogWriteDAC1+0x22>
		DAC1_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC1_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
    7184:	4b08      	ldr	r3, [pc, #32]	; (71a8 <analogWriteDAC1+0x34>)
    7186:	22c0      	movs	r2, #192	; 0xc0
    7188:	701a      	strb	r2, [r3, #0]
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095

	*(volatile aliased_int16_t *)&(DAC1_DAT0L) = val;
    718a:	4b08      	ldr	r3, [pc, #32]	; (71ac <analogWriteDAC1+0x38>)
	if (analog_reference_internal) {
		DAC1_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC1_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095
    718c:	f380 000c 	usat	r0, #12, r0

	*(volatile aliased_int16_t *)&(DAC1_DAT0L) = val;
    7190:	b200      	sxth	r0, r0
    7192:	8018      	strh	r0, [r3, #0]
    7194:	4770      	bx	lr
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
void analogWriteDAC1(int val)
{
	SIM_SCGC2 |= SIM_SCGC2_DAC1;
	if (analog_reference_internal) {
		DAC1_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
    7196:	4b04      	ldr	r3, [pc, #16]	; (71a8 <analogWriteDAC1+0x34>)
    7198:	2280      	movs	r2, #128	; 0x80
    719a:	701a      	strb	r2, [r3, #0]
    719c:	e7f5      	b.n	718a <analogWriteDAC1+0x16>
    719e:	bf00      	nop
    71a0:	4004802c 	.word	0x4004802c
    71a4:	1fff2bf7 	.word	0x1fff2bf7
    71a8:	400cd021 	.word	0x400cd021
    71ac:	400cd000 	.word	0x400cd000

000071b0 <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    71b0:	b4f0      	push	{r4, r5, r6, r7}
    71b2:	1e4d      	subs	r5, r1, #1
    71b4:	462e      	mov	r6, r5
	unsigned digit;
	int i=0, j;
    71b6:	2400      	movs	r4, #0
    71b8:	e000      	b.n	71bc <ultoa+0xc>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    71ba:	3401      	adds	r4, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
    71bc:	fbb0 f3f2 	udiv	r3, r0, r2
    71c0:	fb02 0013 	mls	r0, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    71c4:	2809      	cmp	r0, #9
    71c6:	f100 0730 	add.w	r7, r0, #48	; 0x30
    71ca:	bf8a      	itet	hi
    71cc:	3037      	addhi	r0, #55	; 0x37
    71ce:	b2f8      	uxtbls	r0, r7
    71d0:	b2c0      	uxtbhi	r0, r0
    71d2:	f806 0f01 	strb.w	r0, [r6, #1]!
		val /= radix;
		if (val == 0) break;
    71d6:	4618      	mov	r0, r3
    71d8:	2b00      	cmp	r3, #0
    71da:	d1ee      	bne.n	71ba <ultoa+0xa>
		i++;
	}
	buf[i + 1] = 0;
    71dc:	190a      	adds	r2, r1, r4
    71de:	7053      	strb	r3, [r2, #1]
	for (j=0; j < i; j++, i--) {
    71e0:	b14c      	cbz	r4, 71f6 <ultoa+0x46>
		t = buf[j];
		buf[j] = buf[i];
    71e2:	7810      	ldrb	r0, [r2, #0]
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
		t = buf[j];
    71e4:	f815 6f01 	ldrb.w	r6, [r5, #1]!
		buf[j] = buf[i];
    71e8:	7028      	strb	r0, [r5, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    71ea:	3301      	adds	r3, #1
    71ec:	1ae0      	subs	r0, r4, r3
    71ee:	4283      	cmp	r3, r0
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
    71f0:	f802 6901 	strb.w	r6, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    71f4:	dbf5      	blt.n	71e2 <ultoa+0x32>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    71f6:	4608      	mov	r0, r1
    71f8:	bcf0      	pop	{r4, r5, r6, r7}
    71fa:	4770      	bx	lr

000071fc <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    71fc:	b510      	push	{r4, lr}
    71fe:	b084      	sub	sp, #16
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    7200:	b672      	cpsid	i
	FTFL_FCCOB1 = 15;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
    7202:	f7fe faf1 	bl	57e8 <kinetis_hsrun_disable>
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    7206:	4a18      	ldr	r2, [pc, #96]	; (7268 <usb_init_serialnumber+0x6c>)
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    7208:	4b18      	ldr	r3, [pc, #96]	; (726c <usb_init_serialnumber+0x70>)
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    720a:	4919      	ldr	r1, [pc, #100]	; (7270 <usb_init_serialnumber+0x74>)
    720c:	6011      	str	r1, [r2, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    720e:	2270      	movs	r2, #112	; 0x70
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    7210:	2180      	movs	r1, #128	; 0x80
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    7212:	701a      	strb	r2, [r3, #0]
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    7214:	461a      	mov	r2, r3
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    7216:	7019      	strb	r1, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    7218:	7813      	ldrb	r3, [r2, #0]
    721a:	061b      	lsls	r3, r3, #24
    721c:	d5fc      	bpl.n	7218 <usb_init_serialnumber+0x1c>
	num = *(uint32_t *)&FTFL_FCCOBB;
    721e:	4b15      	ldr	r3, [pc, #84]	; (7274 <usb_init_serialnumber+0x78>)
    7220:	681c      	ldr	r4, [r3, #0]
	kinetis_hsrun_enable();
    7222:	f7fe fafb 	bl	581c <kinetis_hsrun_enable>
#endif
	__enable_irq();
    7226:	b662      	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    7228:	4b13      	ldr	r3, [pc, #76]	; (7278 <usb_init_serialnumber+0x7c>)
    722a:	429c      	cmp	r4, r3
    722c:	bf9c      	itt	ls
    722e:	eb04 0484 	addls.w	r4, r4, r4, lsl #2
    7232:	0064      	lslls	r4, r4, #1
	ultoa(num, buf, 10);
    7234:	4620      	mov	r0, r4
    7236:	4c11      	ldr	r4, [pc, #68]	; (727c <usb_init_serialnumber+0x80>)
    7238:	a901      	add	r1, sp, #4
    723a:	220a      	movs	r2, #10
    723c:	f7ff ffb8 	bl	71b0 <ultoa>
    7240:	a901      	add	r1, sp, #4
    7242:	4620      	mov	r0, r4
	for (i=0; i<10; i++) {
    7244:	2300      	movs	r3, #0
		char c = buf[i];
    7246:	f811 2b01 	ldrb.w	r2, [r1], #1
    724a:	3301      	adds	r3, #1
		if (!c) break;
    724c:	b13a      	cbz	r2, 725e <usb_init_serialnumber+0x62>
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    724e:	2b0a      	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    7250:	f820 2f02 	strh.w	r2, [r0, #2]!
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    7254:	d1f7      	bne.n	7246 <usb_init_serialnumber+0x4a>
    7256:	2316      	movs	r3, #22
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    7258:	7023      	strb	r3, [r4, #0]
}
    725a:	b004      	add	sp, #16
    725c:	bd10      	pop	{r4, pc}
    725e:	005b      	lsls	r3, r3, #1
    7260:	b2db      	uxtb	r3, r3
	for (i=0; i<10; i++) {
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    7262:	7023      	strb	r3, [r4, #0]
}
    7264:	b004      	add	sp, #16
    7266:	bd10      	pop	{r4, pc}
    7268:	40020004 	.word	0x40020004
    726c:	40020000 	.word	0x40020000
    7270:	41070000 	.word	0x41070000
    7274:	4002000c 	.word	0x4002000c
    7278:	0098967f 	.word	0x0098967f
    727c:	1fff0bc4 	.word	0x1fff0bc4

00007280 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    7280:	4770      	bx	lr
    7282:	bf00      	nop

00007284 <__aeabi_drsub>:
    7284:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
    7288:	e002      	b.n	7290 <__adddf3>
    728a:	bf00      	nop

0000728c <__aeabi_dsub>:
    728c:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

00007290 <__adddf3>:
    7290:	b530      	push	{r4, r5, lr}
    7292:	ea4f 0441 	mov.w	r4, r1, lsl #1
    7296:	ea4f 0543 	mov.w	r5, r3, lsl #1
    729a:	ea94 0f05 	teq	r4, r5
    729e:	bf08      	it	eq
    72a0:	ea90 0f02 	teqeq	r0, r2
    72a4:	bf1f      	itttt	ne
    72a6:	ea54 0c00 	orrsne.w	ip, r4, r0
    72aa:	ea55 0c02 	orrsne.w	ip, r5, r2
    72ae:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
    72b2:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    72b6:	f000 80e2 	beq.w	747e <__adddf3+0x1ee>
    72ba:	ea4f 5454 	mov.w	r4, r4, lsr #21
    72be:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
    72c2:	bfb8      	it	lt
    72c4:	426d      	neglt	r5, r5
    72c6:	dd0c      	ble.n	72e2 <__adddf3+0x52>
    72c8:	442c      	add	r4, r5
    72ca:	ea80 0202 	eor.w	r2, r0, r2
    72ce:	ea81 0303 	eor.w	r3, r1, r3
    72d2:	ea82 0000 	eor.w	r0, r2, r0
    72d6:	ea83 0101 	eor.w	r1, r3, r1
    72da:	ea80 0202 	eor.w	r2, r0, r2
    72de:	ea81 0303 	eor.w	r3, r1, r3
    72e2:	2d36      	cmp	r5, #54	; 0x36
    72e4:	bf88      	it	hi
    72e6:	bd30      	pophi	{r4, r5, pc}
    72e8:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    72ec:	ea4f 3101 	mov.w	r1, r1, lsl #12
    72f0:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
    72f4:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
    72f8:	d002      	beq.n	7300 <__adddf3+0x70>
    72fa:	4240      	negs	r0, r0
    72fc:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    7300:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
    7304:	ea4f 3303 	mov.w	r3, r3, lsl #12
    7308:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
    730c:	d002      	beq.n	7314 <__adddf3+0x84>
    730e:	4252      	negs	r2, r2
    7310:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    7314:	ea94 0f05 	teq	r4, r5
    7318:	f000 80a7 	beq.w	746a <__adddf3+0x1da>
    731c:	f1a4 0401 	sub.w	r4, r4, #1
    7320:	f1d5 0e20 	rsbs	lr, r5, #32
    7324:	db0d      	blt.n	7342 <__adddf3+0xb2>
    7326:	fa02 fc0e 	lsl.w	ip, r2, lr
    732a:	fa22 f205 	lsr.w	r2, r2, r5
    732e:	1880      	adds	r0, r0, r2
    7330:	f141 0100 	adc.w	r1, r1, #0
    7334:	fa03 f20e 	lsl.w	r2, r3, lr
    7338:	1880      	adds	r0, r0, r2
    733a:	fa43 f305 	asr.w	r3, r3, r5
    733e:	4159      	adcs	r1, r3
    7340:	e00e      	b.n	7360 <__adddf3+0xd0>
    7342:	f1a5 0520 	sub.w	r5, r5, #32
    7346:	f10e 0e20 	add.w	lr, lr, #32
    734a:	2a01      	cmp	r2, #1
    734c:	fa03 fc0e 	lsl.w	ip, r3, lr
    7350:	bf28      	it	cs
    7352:	f04c 0c02 	orrcs.w	ip, ip, #2
    7356:	fa43 f305 	asr.w	r3, r3, r5
    735a:	18c0      	adds	r0, r0, r3
    735c:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
    7360:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    7364:	d507      	bpl.n	7376 <__adddf3+0xe6>
    7366:	f04f 0e00 	mov.w	lr, #0
    736a:	f1dc 0c00 	rsbs	ip, ip, #0
    736e:	eb7e 0000 	sbcs.w	r0, lr, r0
    7372:	eb6e 0101 	sbc.w	r1, lr, r1
    7376:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    737a:	d31b      	bcc.n	73b4 <__adddf3+0x124>
    737c:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    7380:	d30c      	bcc.n	739c <__adddf3+0x10c>
    7382:	0849      	lsrs	r1, r1, #1
    7384:	ea5f 0030 	movs.w	r0, r0, rrx
    7388:	ea4f 0c3c 	mov.w	ip, ip, rrx
    738c:	f104 0401 	add.w	r4, r4, #1
    7390:	ea4f 5244 	mov.w	r2, r4, lsl #21
    7394:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
    7398:	f080 809a 	bcs.w	74d0 <__adddf3+0x240>
    739c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    73a0:	bf08      	it	eq
    73a2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    73a6:	f150 0000 	adcs.w	r0, r0, #0
    73aa:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    73ae:	ea41 0105 	orr.w	r1, r1, r5
    73b2:	bd30      	pop	{r4, r5, pc}
    73b4:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
    73b8:	4140      	adcs	r0, r0
    73ba:	eb41 0101 	adc.w	r1, r1, r1
    73be:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    73c2:	f1a4 0401 	sub.w	r4, r4, #1
    73c6:	d1e9      	bne.n	739c <__adddf3+0x10c>
    73c8:	f091 0f00 	teq	r1, #0
    73cc:	bf04      	itt	eq
    73ce:	4601      	moveq	r1, r0
    73d0:	2000      	moveq	r0, #0
    73d2:	fab1 f381 	clz	r3, r1
    73d6:	bf08      	it	eq
    73d8:	3320      	addeq	r3, #32
    73da:	f1a3 030b 	sub.w	r3, r3, #11
    73de:	f1b3 0220 	subs.w	r2, r3, #32
    73e2:	da0c      	bge.n	73fe <__adddf3+0x16e>
    73e4:	320c      	adds	r2, #12
    73e6:	dd08      	ble.n	73fa <__adddf3+0x16a>
    73e8:	f102 0c14 	add.w	ip, r2, #20
    73ec:	f1c2 020c 	rsb	r2, r2, #12
    73f0:	fa01 f00c 	lsl.w	r0, r1, ip
    73f4:	fa21 f102 	lsr.w	r1, r1, r2
    73f8:	e00c      	b.n	7414 <__adddf3+0x184>
    73fa:	f102 0214 	add.w	r2, r2, #20
    73fe:	bfd8      	it	le
    7400:	f1c2 0c20 	rsble	ip, r2, #32
    7404:	fa01 f102 	lsl.w	r1, r1, r2
    7408:	fa20 fc0c 	lsr.w	ip, r0, ip
    740c:	bfdc      	itt	le
    740e:	ea41 010c 	orrle.w	r1, r1, ip
    7412:	4090      	lslle	r0, r2
    7414:	1ae4      	subs	r4, r4, r3
    7416:	bfa2      	ittt	ge
    7418:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
    741c:	4329      	orrge	r1, r5
    741e:	bd30      	popge	{r4, r5, pc}
    7420:	ea6f 0404 	mvn.w	r4, r4
    7424:	3c1f      	subs	r4, #31
    7426:	da1c      	bge.n	7462 <__adddf3+0x1d2>
    7428:	340c      	adds	r4, #12
    742a:	dc0e      	bgt.n	744a <__adddf3+0x1ba>
    742c:	f104 0414 	add.w	r4, r4, #20
    7430:	f1c4 0220 	rsb	r2, r4, #32
    7434:	fa20 f004 	lsr.w	r0, r0, r4
    7438:	fa01 f302 	lsl.w	r3, r1, r2
    743c:	ea40 0003 	orr.w	r0, r0, r3
    7440:	fa21 f304 	lsr.w	r3, r1, r4
    7444:	ea45 0103 	orr.w	r1, r5, r3
    7448:	bd30      	pop	{r4, r5, pc}
    744a:	f1c4 040c 	rsb	r4, r4, #12
    744e:	f1c4 0220 	rsb	r2, r4, #32
    7452:	fa20 f002 	lsr.w	r0, r0, r2
    7456:	fa01 f304 	lsl.w	r3, r1, r4
    745a:	ea40 0003 	orr.w	r0, r0, r3
    745e:	4629      	mov	r1, r5
    7460:	bd30      	pop	{r4, r5, pc}
    7462:	fa21 f004 	lsr.w	r0, r1, r4
    7466:	4629      	mov	r1, r5
    7468:	bd30      	pop	{r4, r5, pc}
    746a:	f094 0f00 	teq	r4, #0
    746e:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
    7472:	bf06      	itte	eq
    7474:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
    7478:	3401      	addeq	r4, #1
    747a:	3d01      	subne	r5, #1
    747c:	e74e      	b.n	731c <__adddf3+0x8c>
    747e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    7482:	bf18      	it	ne
    7484:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    7488:	d029      	beq.n	74de <__adddf3+0x24e>
    748a:	ea94 0f05 	teq	r4, r5
    748e:	bf08      	it	eq
    7490:	ea90 0f02 	teqeq	r0, r2
    7494:	d005      	beq.n	74a2 <__adddf3+0x212>
    7496:	ea54 0c00 	orrs.w	ip, r4, r0
    749a:	bf04      	itt	eq
    749c:	4619      	moveq	r1, r3
    749e:	4610      	moveq	r0, r2
    74a0:	bd30      	pop	{r4, r5, pc}
    74a2:	ea91 0f03 	teq	r1, r3
    74a6:	bf1e      	ittt	ne
    74a8:	2100      	movne	r1, #0
    74aa:	2000      	movne	r0, #0
    74ac:	bd30      	popne	{r4, r5, pc}
    74ae:	ea5f 5c54 	movs.w	ip, r4, lsr #21
    74b2:	d105      	bne.n	74c0 <__adddf3+0x230>
    74b4:	0040      	lsls	r0, r0, #1
    74b6:	4149      	adcs	r1, r1
    74b8:	bf28      	it	cs
    74ba:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
    74be:	bd30      	pop	{r4, r5, pc}
    74c0:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
    74c4:	bf3c      	itt	cc
    74c6:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
    74ca:	bd30      	popcc	{r4, r5, pc}
    74cc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    74d0:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
    74d4:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    74d8:	f04f 0000 	mov.w	r0, #0
    74dc:	bd30      	pop	{r4, r5, pc}
    74de:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    74e2:	bf1a      	itte	ne
    74e4:	4619      	movne	r1, r3
    74e6:	4610      	movne	r0, r2
    74e8:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
    74ec:	bf1c      	itt	ne
    74ee:	460b      	movne	r3, r1
    74f0:	4602      	movne	r2, r0
    74f2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    74f6:	bf06      	itte	eq
    74f8:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
    74fc:	ea91 0f03 	teqeq	r1, r3
    7500:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
    7504:	bd30      	pop	{r4, r5, pc}
    7506:	bf00      	nop

00007508 <__aeabi_ui2d>:
    7508:	f090 0f00 	teq	r0, #0
    750c:	bf04      	itt	eq
    750e:	2100      	moveq	r1, #0
    7510:	4770      	bxeq	lr
    7512:	b530      	push	{r4, r5, lr}
    7514:	f44f 6480 	mov.w	r4, #1024	; 0x400
    7518:	f104 0432 	add.w	r4, r4, #50	; 0x32
    751c:	f04f 0500 	mov.w	r5, #0
    7520:	f04f 0100 	mov.w	r1, #0
    7524:	e750      	b.n	73c8 <__adddf3+0x138>
    7526:	bf00      	nop

00007528 <__aeabi_i2d>:
    7528:	f090 0f00 	teq	r0, #0
    752c:	bf04      	itt	eq
    752e:	2100      	moveq	r1, #0
    7530:	4770      	bxeq	lr
    7532:	b530      	push	{r4, r5, lr}
    7534:	f44f 6480 	mov.w	r4, #1024	; 0x400
    7538:	f104 0432 	add.w	r4, r4, #50	; 0x32
    753c:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
    7540:	bf48      	it	mi
    7542:	4240      	negmi	r0, r0
    7544:	f04f 0100 	mov.w	r1, #0
    7548:	e73e      	b.n	73c8 <__adddf3+0x138>
    754a:	bf00      	nop

0000754c <__aeabi_f2d>:
    754c:	0042      	lsls	r2, r0, #1
    754e:	ea4f 01e2 	mov.w	r1, r2, asr #3
    7552:	ea4f 0131 	mov.w	r1, r1, rrx
    7556:	ea4f 7002 	mov.w	r0, r2, lsl #28
    755a:	bf1f      	itttt	ne
    755c:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
    7560:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    7564:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
    7568:	4770      	bxne	lr
    756a:	f092 0f00 	teq	r2, #0
    756e:	bf14      	ite	ne
    7570:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    7574:	4770      	bxeq	lr
    7576:	b530      	push	{r4, r5, lr}
    7578:	f44f 7460 	mov.w	r4, #896	; 0x380
    757c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    7580:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    7584:	e720      	b.n	73c8 <__adddf3+0x138>
    7586:	bf00      	nop

00007588 <__aeabi_ul2d>:
    7588:	ea50 0201 	orrs.w	r2, r0, r1
    758c:	bf08      	it	eq
    758e:	4770      	bxeq	lr
    7590:	b530      	push	{r4, r5, lr}
    7592:	f04f 0500 	mov.w	r5, #0
    7596:	e00a      	b.n	75ae <__aeabi_l2d+0x16>

00007598 <__aeabi_l2d>:
    7598:	ea50 0201 	orrs.w	r2, r0, r1
    759c:	bf08      	it	eq
    759e:	4770      	bxeq	lr
    75a0:	b530      	push	{r4, r5, lr}
    75a2:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
    75a6:	d502      	bpl.n	75ae <__aeabi_l2d+0x16>
    75a8:	4240      	negs	r0, r0
    75aa:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    75ae:	f44f 6480 	mov.w	r4, #1024	; 0x400
    75b2:	f104 0432 	add.w	r4, r4, #50	; 0x32
    75b6:	ea5f 5c91 	movs.w	ip, r1, lsr #22
    75ba:	f43f aedc 	beq.w	7376 <__adddf3+0xe6>
    75be:	f04f 0203 	mov.w	r2, #3
    75c2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    75c6:	bf18      	it	ne
    75c8:	3203      	addne	r2, #3
    75ca:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    75ce:	bf18      	it	ne
    75d0:	3203      	addne	r2, #3
    75d2:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
    75d6:	f1c2 0320 	rsb	r3, r2, #32
    75da:	fa00 fc03 	lsl.w	ip, r0, r3
    75de:	fa20 f002 	lsr.w	r0, r0, r2
    75e2:	fa01 fe03 	lsl.w	lr, r1, r3
    75e6:	ea40 000e 	orr.w	r0, r0, lr
    75ea:	fa21 f102 	lsr.w	r1, r1, r2
    75ee:	4414      	add	r4, r2
    75f0:	e6c1      	b.n	7376 <__adddf3+0xe6>
    75f2:	bf00      	nop

000075f4 <__aeabi_dmul>:
    75f4:	b570      	push	{r4, r5, r6, lr}
    75f6:	f04f 0cff 	mov.w	ip, #255	; 0xff
    75fa:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    75fe:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    7602:	bf1d      	ittte	ne
    7604:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    7608:	ea94 0f0c 	teqne	r4, ip
    760c:	ea95 0f0c 	teqne	r5, ip
    7610:	f000 f8de 	bleq	77d0 <__aeabi_dmul+0x1dc>
    7614:	442c      	add	r4, r5
    7616:	ea81 0603 	eor.w	r6, r1, r3
    761a:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
    761e:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
    7622:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
    7626:	bf18      	it	ne
    7628:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
    762c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    7630:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    7634:	d038      	beq.n	76a8 <__aeabi_dmul+0xb4>
    7636:	fba0 ce02 	umull	ip, lr, r0, r2
    763a:	f04f 0500 	mov.w	r5, #0
    763e:	fbe1 e502 	umlal	lr, r5, r1, r2
    7642:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
    7646:	fbe0 e503 	umlal	lr, r5, r0, r3
    764a:	f04f 0600 	mov.w	r6, #0
    764e:	fbe1 5603 	umlal	r5, r6, r1, r3
    7652:	f09c 0f00 	teq	ip, #0
    7656:	bf18      	it	ne
    7658:	f04e 0e01 	orrne.w	lr, lr, #1
    765c:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
    7660:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
    7664:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
    7668:	d204      	bcs.n	7674 <__aeabi_dmul+0x80>
    766a:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
    766e:	416d      	adcs	r5, r5
    7670:	eb46 0606 	adc.w	r6, r6, r6
    7674:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
    7678:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
    767c:	ea4f 20c5 	mov.w	r0, r5, lsl #11
    7680:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
    7684:	ea4f 2ece 	mov.w	lr, lr, lsl #11
    7688:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    768c:	bf88      	it	hi
    768e:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    7692:	d81e      	bhi.n	76d2 <__aeabi_dmul+0xde>
    7694:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
    7698:	bf08      	it	eq
    769a:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
    769e:	f150 0000 	adcs.w	r0, r0, #0
    76a2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    76a6:	bd70      	pop	{r4, r5, r6, pc}
    76a8:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
    76ac:	ea46 0101 	orr.w	r1, r6, r1
    76b0:	ea40 0002 	orr.w	r0, r0, r2
    76b4:	ea81 0103 	eor.w	r1, r1, r3
    76b8:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
    76bc:	bfc2      	ittt	gt
    76be:	ebd4 050c 	rsbsgt	r5, r4, ip
    76c2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    76c6:	bd70      	popgt	{r4, r5, r6, pc}
    76c8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    76cc:	f04f 0e00 	mov.w	lr, #0
    76d0:	3c01      	subs	r4, #1
    76d2:	f300 80ab 	bgt.w	782c <__aeabi_dmul+0x238>
    76d6:	f114 0f36 	cmn.w	r4, #54	; 0x36
    76da:	bfde      	ittt	le
    76dc:	2000      	movle	r0, #0
    76de:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
    76e2:	bd70      	pople	{r4, r5, r6, pc}
    76e4:	f1c4 0400 	rsb	r4, r4, #0
    76e8:	3c20      	subs	r4, #32
    76ea:	da35      	bge.n	7758 <__aeabi_dmul+0x164>
    76ec:	340c      	adds	r4, #12
    76ee:	dc1b      	bgt.n	7728 <__aeabi_dmul+0x134>
    76f0:	f104 0414 	add.w	r4, r4, #20
    76f4:	f1c4 0520 	rsb	r5, r4, #32
    76f8:	fa00 f305 	lsl.w	r3, r0, r5
    76fc:	fa20 f004 	lsr.w	r0, r0, r4
    7700:	fa01 f205 	lsl.w	r2, r1, r5
    7704:	ea40 0002 	orr.w	r0, r0, r2
    7708:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
    770c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    7710:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    7714:	fa21 f604 	lsr.w	r6, r1, r4
    7718:	eb42 0106 	adc.w	r1, r2, r6
    771c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    7720:	bf08      	it	eq
    7722:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    7726:	bd70      	pop	{r4, r5, r6, pc}
    7728:	f1c4 040c 	rsb	r4, r4, #12
    772c:	f1c4 0520 	rsb	r5, r4, #32
    7730:	fa00 f304 	lsl.w	r3, r0, r4
    7734:	fa20 f005 	lsr.w	r0, r0, r5
    7738:	fa01 f204 	lsl.w	r2, r1, r4
    773c:	ea40 0002 	orr.w	r0, r0, r2
    7740:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    7744:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    7748:	f141 0100 	adc.w	r1, r1, #0
    774c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    7750:	bf08      	it	eq
    7752:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    7756:	bd70      	pop	{r4, r5, r6, pc}
    7758:	f1c4 0520 	rsb	r5, r4, #32
    775c:	fa00 f205 	lsl.w	r2, r0, r5
    7760:	ea4e 0e02 	orr.w	lr, lr, r2
    7764:	fa20 f304 	lsr.w	r3, r0, r4
    7768:	fa01 f205 	lsl.w	r2, r1, r5
    776c:	ea43 0302 	orr.w	r3, r3, r2
    7770:	fa21 f004 	lsr.w	r0, r1, r4
    7774:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    7778:	fa21 f204 	lsr.w	r2, r1, r4
    777c:	ea20 0002 	bic.w	r0, r0, r2
    7780:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
    7784:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    7788:	bf08      	it	eq
    778a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    778e:	bd70      	pop	{r4, r5, r6, pc}
    7790:	f094 0f00 	teq	r4, #0
    7794:	d10f      	bne.n	77b6 <__aeabi_dmul+0x1c2>
    7796:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
    779a:	0040      	lsls	r0, r0, #1
    779c:	eb41 0101 	adc.w	r1, r1, r1
    77a0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    77a4:	bf08      	it	eq
    77a6:	3c01      	subeq	r4, #1
    77a8:	d0f7      	beq.n	779a <__aeabi_dmul+0x1a6>
    77aa:	ea41 0106 	orr.w	r1, r1, r6
    77ae:	f095 0f00 	teq	r5, #0
    77b2:	bf18      	it	ne
    77b4:	4770      	bxne	lr
    77b6:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
    77ba:	0052      	lsls	r2, r2, #1
    77bc:	eb43 0303 	adc.w	r3, r3, r3
    77c0:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    77c4:	bf08      	it	eq
    77c6:	3d01      	subeq	r5, #1
    77c8:	d0f7      	beq.n	77ba <__aeabi_dmul+0x1c6>
    77ca:	ea43 0306 	orr.w	r3, r3, r6
    77ce:	4770      	bx	lr
    77d0:	ea94 0f0c 	teq	r4, ip
    77d4:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    77d8:	bf18      	it	ne
    77da:	ea95 0f0c 	teqne	r5, ip
    77de:	d00c      	beq.n	77fa <__aeabi_dmul+0x206>
    77e0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    77e4:	bf18      	it	ne
    77e6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    77ea:	d1d1      	bne.n	7790 <__aeabi_dmul+0x19c>
    77ec:	ea81 0103 	eor.w	r1, r1, r3
    77f0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    77f4:	f04f 0000 	mov.w	r0, #0
    77f8:	bd70      	pop	{r4, r5, r6, pc}
    77fa:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    77fe:	bf06      	itte	eq
    7800:	4610      	moveq	r0, r2
    7802:	4619      	moveq	r1, r3
    7804:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    7808:	d019      	beq.n	783e <__aeabi_dmul+0x24a>
    780a:	ea94 0f0c 	teq	r4, ip
    780e:	d102      	bne.n	7816 <__aeabi_dmul+0x222>
    7810:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
    7814:	d113      	bne.n	783e <__aeabi_dmul+0x24a>
    7816:	ea95 0f0c 	teq	r5, ip
    781a:	d105      	bne.n	7828 <__aeabi_dmul+0x234>
    781c:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
    7820:	bf1c      	itt	ne
    7822:	4610      	movne	r0, r2
    7824:	4619      	movne	r1, r3
    7826:	d10a      	bne.n	783e <__aeabi_dmul+0x24a>
    7828:	ea81 0103 	eor.w	r1, r1, r3
    782c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    7830:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    7834:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    7838:	f04f 0000 	mov.w	r0, #0
    783c:	bd70      	pop	{r4, r5, r6, pc}
    783e:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    7842:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
    7846:	bd70      	pop	{r4, r5, r6, pc}

00007848 <__aeabi_ddiv>:
    7848:	b570      	push	{r4, r5, r6, lr}
    784a:	f04f 0cff 	mov.w	ip, #255	; 0xff
    784e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    7852:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    7856:	bf1d      	ittte	ne
    7858:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    785c:	ea94 0f0c 	teqne	r4, ip
    7860:	ea95 0f0c 	teqne	r5, ip
    7864:	f000 f8a7 	bleq	79b6 <__aeabi_ddiv+0x16e>
    7868:	eba4 0405 	sub.w	r4, r4, r5
    786c:	ea81 0e03 	eor.w	lr, r1, r3
    7870:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    7874:	ea4f 3101 	mov.w	r1, r1, lsl #12
    7878:	f000 8088 	beq.w	798c <__aeabi_ddiv+0x144>
    787c:	ea4f 3303 	mov.w	r3, r3, lsl #12
    7880:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
    7884:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
    7888:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    788c:	ea4f 2202 	mov.w	r2, r2, lsl #8
    7890:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
    7894:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
    7898:	ea4f 2600 	mov.w	r6, r0, lsl #8
    789c:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
    78a0:	429d      	cmp	r5, r3
    78a2:	bf08      	it	eq
    78a4:	4296      	cmpeq	r6, r2
    78a6:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
    78aa:	f504 7440 	add.w	r4, r4, #768	; 0x300
    78ae:	d202      	bcs.n	78b6 <__aeabi_ddiv+0x6e>
    78b0:	085b      	lsrs	r3, r3, #1
    78b2:	ea4f 0232 	mov.w	r2, r2, rrx
    78b6:	1ab6      	subs	r6, r6, r2
    78b8:	eb65 0503 	sbc.w	r5, r5, r3
    78bc:	085b      	lsrs	r3, r3, #1
    78be:	ea4f 0232 	mov.w	r2, r2, rrx
    78c2:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
    78c6:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
    78ca:	ebb6 0e02 	subs.w	lr, r6, r2
    78ce:	eb75 0e03 	sbcs.w	lr, r5, r3
    78d2:	bf22      	ittt	cs
    78d4:	1ab6      	subcs	r6, r6, r2
    78d6:	4675      	movcs	r5, lr
    78d8:	ea40 000c 	orrcs.w	r0, r0, ip
    78dc:	085b      	lsrs	r3, r3, #1
    78de:	ea4f 0232 	mov.w	r2, r2, rrx
    78e2:	ebb6 0e02 	subs.w	lr, r6, r2
    78e6:	eb75 0e03 	sbcs.w	lr, r5, r3
    78ea:	bf22      	ittt	cs
    78ec:	1ab6      	subcs	r6, r6, r2
    78ee:	4675      	movcs	r5, lr
    78f0:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    78f4:	085b      	lsrs	r3, r3, #1
    78f6:	ea4f 0232 	mov.w	r2, r2, rrx
    78fa:	ebb6 0e02 	subs.w	lr, r6, r2
    78fe:	eb75 0e03 	sbcs.w	lr, r5, r3
    7902:	bf22      	ittt	cs
    7904:	1ab6      	subcs	r6, r6, r2
    7906:	4675      	movcs	r5, lr
    7908:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    790c:	085b      	lsrs	r3, r3, #1
    790e:	ea4f 0232 	mov.w	r2, r2, rrx
    7912:	ebb6 0e02 	subs.w	lr, r6, r2
    7916:	eb75 0e03 	sbcs.w	lr, r5, r3
    791a:	bf22      	ittt	cs
    791c:	1ab6      	subcs	r6, r6, r2
    791e:	4675      	movcs	r5, lr
    7920:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    7924:	ea55 0e06 	orrs.w	lr, r5, r6
    7928:	d018      	beq.n	795c <__aeabi_ddiv+0x114>
    792a:	ea4f 1505 	mov.w	r5, r5, lsl #4
    792e:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
    7932:	ea4f 1606 	mov.w	r6, r6, lsl #4
    7936:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    793a:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
    793e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    7942:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
    7946:	d1c0      	bne.n	78ca <__aeabi_ddiv+0x82>
    7948:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    794c:	d10b      	bne.n	7966 <__aeabi_ddiv+0x11e>
    794e:	ea41 0100 	orr.w	r1, r1, r0
    7952:	f04f 0000 	mov.w	r0, #0
    7956:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
    795a:	e7b6      	b.n	78ca <__aeabi_ddiv+0x82>
    795c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    7960:	bf04      	itt	eq
    7962:	4301      	orreq	r1, r0
    7964:	2000      	moveq	r0, #0
    7966:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    796a:	bf88      	it	hi
    796c:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    7970:	f63f aeaf 	bhi.w	76d2 <__aeabi_dmul+0xde>
    7974:	ebb5 0c03 	subs.w	ip, r5, r3
    7978:	bf04      	itt	eq
    797a:	ebb6 0c02 	subseq.w	ip, r6, r2
    797e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    7982:	f150 0000 	adcs.w	r0, r0, #0
    7986:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    798a:	bd70      	pop	{r4, r5, r6, pc}
    798c:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
    7990:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
    7994:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
    7998:	bfc2      	ittt	gt
    799a:	ebd4 050c 	rsbsgt	r5, r4, ip
    799e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    79a2:	bd70      	popgt	{r4, r5, r6, pc}
    79a4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    79a8:	f04f 0e00 	mov.w	lr, #0
    79ac:	3c01      	subs	r4, #1
    79ae:	e690      	b.n	76d2 <__aeabi_dmul+0xde>
    79b0:	ea45 0e06 	orr.w	lr, r5, r6
    79b4:	e68d      	b.n	76d2 <__aeabi_dmul+0xde>
    79b6:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    79ba:	ea94 0f0c 	teq	r4, ip
    79be:	bf08      	it	eq
    79c0:	ea95 0f0c 	teqeq	r5, ip
    79c4:	f43f af3b 	beq.w	783e <__aeabi_dmul+0x24a>
    79c8:	ea94 0f0c 	teq	r4, ip
    79cc:	d10a      	bne.n	79e4 <__aeabi_ddiv+0x19c>
    79ce:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    79d2:	f47f af34 	bne.w	783e <__aeabi_dmul+0x24a>
    79d6:	ea95 0f0c 	teq	r5, ip
    79da:	f47f af25 	bne.w	7828 <__aeabi_dmul+0x234>
    79de:	4610      	mov	r0, r2
    79e0:	4619      	mov	r1, r3
    79e2:	e72c      	b.n	783e <__aeabi_dmul+0x24a>
    79e4:	ea95 0f0c 	teq	r5, ip
    79e8:	d106      	bne.n	79f8 <__aeabi_ddiv+0x1b0>
    79ea:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    79ee:	f43f aefd 	beq.w	77ec <__aeabi_dmul+0x1f8>
    79f2:	4610      	mov	r0, r2
    79f4:	4619      	mov	r1, r3
    79f6:	e722      	b.n	783e <__aeabi_dmul+0x24a>
    79f8:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    79fc:	bf18      	it	ne
    79fe:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    7a02:	f47f aec5 	bne.w	7790 <__aeabi_dmul+0x19c>
    7a06:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
    7a0a:	f47f af0d 	bne.w	7828 <__aeabi_dmul+0x234>
    7a0e:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
    7a12:	f47f aeeb 	bne.w	77ec <__aeabi_dmul+0x1f8>
    7a16:	e712      	b.n	783e <__aeabi_dmul+0x24a>

00007a18 <__gedf2>:
    7a18:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
    7a1c:	e006      	b.n	7a2c <__cmpdf2+0x4>
    7a1e:	bf00      	nop

00007a20 <__ledf2>:
    7a20:	f04f 0c01 	mov.w	ip, #1
    7a24:	e002      	b.n	7a2c <__cmpdf2+0x4>
    7a26:	bf00      	nop

00007a28 <__cmpdf2>:
    7a28:	f04f 0c01 	mov.w	ip, #1
    7a2c:	f84d cd04 	str.w	ip, [sp, #-4]!
    7a30:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    7a34:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    7a38:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    7a3c:	bf18      	it	ne
    7a3e:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
    7a42:	d01b      	beq.n	7a7c <__cmpdf2+0x54>
    7a44:	b001      	add	sp, #4
    7a46:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
    7a4a:	bf0c      	ite	eq
    7a4c:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
    7a50:	ea91 0f03 	teqne	r1, r3
    7a54:	bf02      	ittt	eq
    7a56:	ea90 0f02 	teqeq	r0, r2
    7a5a:	2000      	moveq	r0, #0
    7a5c:	4770      	bxeq	lr
    7a5e:	f110 0f00 	cmn.w	r0, #0
    7a62:	ea91 0f03 	teq	r1, r3
    7a66:	bf58      	it	pl
    7a68:	4299      	cmppl	r1, r3
    7a6a:	bf08      	it	eq
    7a6c:	4290      	cmpeq	r0, r2
    7a6e:	bf2c      	ite	cs
    7a70:	17d8      	asrcs	r0, r3, #31
    7a72:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
    7a76:	f040 0001 	orr.w	r0, r0, #1
    7a7a:	4770      	bx	lr
    7a7c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    7a80:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    7a84:	d102      	bne.n	7a8c <__cmpdf2+0x64>
    7a86:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    7a8a:	d107      	bne.n	7a9c <__cmpdf2+0x74>
    7a8c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    7a90:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    7a94:	d1d6      	bne.n	7a44 <__cmpdf2+0x1c>
    7a96:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    7a9a:	d0d3      	beq.n	7a44 <__cmpdf2+0x1c>
    7a9c:	f85d 0b04 	ldr.w	r0, [sp], #4
    7aa0:	4770      	bx	lr
    7aa2:	bf00      	nop

00007aa4 <__aeabi_cdrcmple>:
    7aa4:	4684      	mov	ip, r0
    7aa6:	4610      	mov	r0, r2
    7aa8:	4662      	mov	r2, ip
    7aaa:	468c      	mov	ip, r1
    7aac:	4619      	mov	r1, r3
    7aae:	4663      	mov	r3, ip
    7ab0:	e000      	b.n	7ab4 <__aeabi_cdcmpeq>
    7ab2:	bf00      	nop

00007ab4 <__aeabi_cdcmpeq>:
    7ab4:	b501      	push	{r0, lr}
    7ab6:	f7ff ffb7 	bl	7a28 <__cmpdf2>
    7aba:	2800      	cmp	r0, #0
    7abc:	bf48      	it	mi
    7abe:	f110 0f00 	cmnmi.w	r0, #0
    7ac2:	bd01      	pop	{r0, pc}

00007ac4 <__aeabi_dcmpeq>:
    7ac4:	f84d ed08 	str.w	lr, [sp, #-8]!
    7ac8:	f7ff fff4 	bl	7ab4 <__aeabi_cdcmpeq>
    7acc:	bf0c      	ite	eq
    7ace:	2001      	moveq	r0, #1
    7ad0:	2000      	movne	r0, #0
    7ad2:	f85d fb08 	ldr.w	pc, [sp], #8
    7ad6:	bf00      	nop

00007ad8 <__aeabi_dcmplt>:
    7ad8:	f84d ed08 	str.w	lr, [sp, #-8]!
    7adc:	f7ff ffea 	bl	7ab4 <__aeabi_cdcmpeq>
    7ae0:	bf34      	ite	cc
    7ae2:	2001      	movcc	r0, #1
    7ae4:	2000      	movcs	r0, #0
    7ae6:	f85d fb08 	ldr.w	pc, [sp], #8
    7aea:	bf00      	nop

00007aec <__aeabi_dcmple>:
    7aec:	f84d ed08 	str.w	lr, [sp, #-8]!
    7af0:	f7ff ffe0 	bl	7ab4 <__aeabi_cdcmpeq>
    7af4:	bf94      	ite	ls
    7af6:	2001      	movls	r0, #1
    7af8:	2000      	movhi	r0, #0
    7afa:	f85d fb08 	ldr.w	pc, [sp], #8
    7afe:	bf00      	nop

00007b00 <__aeabi_dcmpge>:
    7b00:	f84d ed08 	str.w	lr, [sp, #-8]!
    7b04:	f7ff ffce 	bl	7aa4 <__aeabi_cdrcmple>
    7b08:	bf94      	ite	ls
    7b0a:	2001      	movls	r0, #1
    7b0c:	2000      	movhi	r0, #0
    7b0e:	f85d fb08 	ldr.w	pc, [sp], #8
    7b12:	bf00      	nop

00007b14 <__aeabi_dcmpgt>:
    7b14:	f84d ed08 	str.w	lr, [sp, #-8]!
    7b18:	f7ff ffc4 	bl	7aa4 <__aeabi_cdrcmple>
    7b1c:	bf34      	ite	cc
    7b1e:	2001      	movcc	r0, #1
    7b20:	2000      	movcs	r0, #0
    7b22:	f85d fb08 	ldr.w	pc, [sp], #8
    7b26:	bf00      	nop

00007b28 <__aeabi_d2iz>:
    7b28:	ea4f 0241 	mov.w	r2, r1, lsl #1
    7b2c:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
    7b30:	d215      	bcs.n	7b5e <__aeabi_d2iz+0x36>
    7b32:	d511      	bpl.n	7b58 <__aeabi_d2iz+0x30>
    7b34:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
    7b38:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
    7b3c:	d912      	bls.n	7b64 <__aeabi_d2iz+0x3c>
    7b3e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    7b42:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    7b46:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
    7b4a:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    7b4e:	fa23 f002 	lsr.w	r0, r3, r2
    7b52:	bf18      	it	ne
    7b54:	4240      	negne	r0, r0
    7b56:	4770      	bx	lr
    7b58:	f04f 0000 	mov.w	r0, #0
    7b5c:	4770      	bx	lr
    7b5e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
    7b62:	d105      	bne.n	7b70 <__aeabi_d2iz+0x48>
    7b64:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
    7b68:	bf08      	it	eq
    7b6a:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
    7b6e:	4770      	bx	lr
    7b70:	f04f 0000 	mov.w	r0, #0
    7b74:	4770      	bx	lr
    7b76:	bf00      	nop

00007b78 <__aeabi_d2f>:
    7b78:	ea4f 0241 	mov.w	r2, r1, lsl #1
    7b7c:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
    7b80:	bf24      	itt	cs
    7b82:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
    7b86:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
    7b8a:	d90d      	bls.n	7ba8 <__aeabi_d2f+0x30>
    7b8c:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    7b90:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    7b94:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
    7b98:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    7b9c:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
    7ba0:	bf08      	it	eq
    7ba2:	f020 0001 	biceq.w	r0, r0, #1
    7ba6:	4770      	bx	lr
    7ba8:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
    7bac:	d121      	bne.n	7bf2 <__aeabi_d2f+0x7a>
    7bae:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
    7bb2:	bfbc      	itt	lt
    7bb4:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
    7bb8:	4770      	bxlt	lr
    7bba:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    7bbe:	ea4f 5252 	mov.w	r2, r2, lsr #21
    7bc2:	f1c2 0218 	rsb	r2, r2, #24
    7bc6:	f1c2 0c20 	rsb	ip, r2, #32
    7bca:	fa10 f30c 	lsls.w	r3, r0, ip
    7bce:	fa20 f002 	lsr.w	r0, r0, r2
    7bd2:	bf18      	it	ne
    7bd4:	f040 0001 	orrne.w	r0, r0, #1
    7bd8:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    7bdc:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    7be0:	fa03 fc0c 	lsl.w	ip, r3, ip
    7be4:	ea40 000c 	orr.w	r0, r0, ip
    7be8:	fa23 f302 	lsr.w	r3, r3, r2
    7bec:	ea4f 0343 	mov.w	r3, r3, lsl #1
    7bf0:	e7cc      	b.n	7b8c <__aeabi_d2f+0x14>
    7bf2:	ea7f 5362 	mvns.w	r3, r2, asr #21
    7bf6:	d107      	bne.n	7c08 <__aeabi_d2f+0x90>
    7bf8:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
    7bfc:	bf1e      	ittt	ne
    7bfe:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
    7c02:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
    7c06:	4770      	bxne	lr
    7c08:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
    7c0c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    7c10:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    7c14:	4770      	bx	lr
    7c16:	bf00      	nop

00007c18 <__errno>:
    7c18:	4b01      	ldr	r3, [pc, #4]	; (7c20 <__errno+0x8>)
    7c1a:	6818      	ldr	r0, [r3, #0]
    7c1c:	4770      	bx	lr
    7c1e:	bf00      	nop
    7c20:	1fff1008 	.word	0x1fff1008

00007c24 <__libc_init_array>:
    7c24:	b570      	push	{r4, r5, r6, lr}
    7c26:	4e0f      	ldr	r6, [pc, #60]	; (7c64 <__libc_init_array+0x40>)
    7c28:	4d0f      	ldr	r5, [pc, #60]	; (7c68 <__libc_init_array+0x44>)
    7c2a:	1b76      	subs	r6, r6, r5
    7c2c:	10b6      	asrs	r6, r6, #2
    7c2e:	bf18      	it	ne
    7c30:	2400      	movne	r4, #0
    7c32:	d005      	beq.n	7c40 <__libc_init_array+0x1c>
    7c34:	3401      	adds	r4, #1
    7c36:	f855 3b04 	ldr.w	r3, [r5], #4
    7c3a:	4798      	blx	r3
    7c3c:	42a6      	cmp	r6, r4
    7c3e:	d1f9      	bne.n	7c34 <__libc_init_array+0x10>
    7c40:	4e0a      	ldr	r6, [pc, #40]	; (7c6c <__libc_init_array+0x48>)
    7c42:	4d0b      	ldr	r5, [pc, #44]	; (7c70 <__libc_init_array+0x4c>)
    7c44:	1b76      	subs	r6, r6, r5
    7c46:	f001 fd61 	bl	970c <_init>
    7c4a:	10b6      	asrs	r6, r6, #2
    7c4c:	bf18      	it	ne
    7c4e:	2400      	movne	r4, #0
    7c50:	d006      	beq.n	7c60 <__libc_init_array+0x3c>
    7c52:	3401      	adds	r4, #1
    7c54:	f855 3b04 	ldr.w	r3, [r5], #4
    7c58:	4798      	blx	r3
    7c5a:	42a6      	cmp	r6, r4
    7c5c:	d1f9      	bne.n	7c52 <__libc_init_array+0x2e>
    7c5e:	bd70      	pop	{r4, r5, r6, pc}
    7c60:	bd70      	pop	{r4, r5, r6, pc}
    7c62:	bf00      	nop
    7c64:	00009718 	.word	0x00009718
    7c68:	00009718 	.word	0x00009718
    7c6c:	00009724 	.word	0x00009724
    7c70:	00009718 	.word	0x00009718

00007c74 <malloc>:
    7c74:	4b02      	ldr	r3, [pc, #8]	; (7c80 <malloc+0xc>)
    7c76:	4601      	mov	r1, r0
    7c78:	6818      	ldr	r0, [r3, #0]
    7c7a:	f000 b80b 	b.w	7c94 <_malloc_r>
    7c7e:	bf00      	nop
    7c80:	1fff1008 	.word	0x1fff1008

00007c84 <free>:
    7c84:	4b02      	ldr	r3, [pc, #8]	; (7c90 <free+0xc>)
    7c86:	4601      	mov	r1, r0
    7c88:	6818      	ldr	r0, [r3, #0]
    7c8a:	f001 b839 	b.w	8d00 <_free_r>
    7c8e:	bf00      	nop
    7c90:	1fff1008 	.word	0x1fff1008

00007c94 <_malloc_r>:
    7c94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7c98:	f101 050b 	add.w	r5, r1, #11
    7c9c:	2d16      	cmp	r5, #22
    7c9e:	b083      	sub	sp, #12
    7ca0:	4606      	mov	r6, r0
    7ca2:	f240 809f 	bls.w	7de4 <_malloc_r+0x150>
    7ca6:	f035 0507 	bics.w	r5, r5, #7
    7caa:	f100 80bf 	bmi.w	7e2c <_malloc_r+0x198>
    7cae:	42a9      	cmp	r1, r5
    7cb0:	f200 80bc 	bhi.w	7e2c <_malloc_r+0x198>
    7cb4:	f000 fb58 	bl	8368 <__malloc_lock>
    7cb8:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
    7cbc:	f0c0 829c 	bcc.w	81f8 <_malloc_r+0x564>
    7cc0:	0a6b      	lsrs	r3, r5, #9
    7cc2:	f000 80ba 	beq.w	7e3a <_malloc_r+0x1a6>
    7cc6:	2b04      	cmp	r3, #4
    7cc8:	f200 8183 	bhi.w	7fd2 <_malloc_r+0x33e>
    7ccc:	09a8      	lsrs	r0, r5, #6
    7cce:	f100 0e39 	add.w	lr, r0, #57	; 0x39
    7cd2:	ea4f 034e 	mov.w	r3, lr, lsl #1
    7cd6:	3038      	adds	r0, #56	; 0x38
    7cd8:	4fc4      	ldr	r7, [pc, #784]	; (7fec <_malloc_r+0x358>)
    7cda:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    7cde:	f1a3 0108 	sub.w	r1, r3, #8
    7ce2:	685c      	ldr	r4, [r3, #4]
    7ce4:	42a1      	cmp	r1, r4
    7ce6:	d107      	bne.n	7cf8 <_malloc_r+0x64>
    7ce8:	e0ac      	b.n	7e44 <_malloc_r+0x1b0>
    7cea:	2a00      	cmp	r2, #0
    7cec:	f280 80ac 	bge.w	7e48 <_malloc_r+0x1b4>
    7cf0:	68e4      	ldr	r4, [r4, #12]
    7cf2:	42a1      	cmp	r1, r4
    7cf4:	f000 80a6 	beq.w	7e44 <_malloc_r+0x1b0>
    7cf8:	6863      	ldr	r3, [r4, #4]
    7cfa:	f023 0303 	bic.w	r3, r3, #3
    7cfe:	1b5a      	subs	r2, r3, r5
    7d00:	2a0f      	cmp	r2, #15
    7d02:	ddf2      	ble.n	7cea <_malloc_r+0x56>
    7d04:	49b9      	ldr	r1, [pc, #740]	; (7fec <_malloc_r+0x358>)
    7d06:	693c      	ldr	r4, [r7, #16]
    7d08:	f101 0e08 	add.w	lr, r1, #8
    7d0c:	4574      	cmp	r4, lr
    7d0e:	f000 81b3 	beq.w	8078 <_malloc_r+0x3e4>
    7d12:	6863      	ldr	r3, [r4, #4]
    7d14:	f023 0303 	bic.w	r3, r3, #3
    7d18:	1b5a      	subs	r2, r3, r5
    7d1a:	2a0f      	cmp	r2, #15
    7d1c:	f300 8199 	bgt.w	8052 <_malloc_r+0x3be>
    7d20:	2a00      	cmp	r2, #0
    7d22:	f8c1 e014 	str.w	lr, [r1, #20]
    7d26:	f8c1 e010 	str.w	lr, [r1, #16]
    7d2a:	f280 809e 	bge.w	7e6a <_malloc_r+0x1d6>
    7d2e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    7d32:	f080 8167 	bcs.w	8004 <_malloc_r+0x370>
    7d36:	08db      	lsrs	r3, r3, #3
    7d38:	f103 0c01 	add.w	ip, r3, #1
    7d3c:	2201      	movs	r2, #1
    7d3e:	109b      	asrs	r3, r3, #2
    7d40:	fa02 f303 	lsl.w	r3, r2, r3
    7d44:	684a      	ldr	r2, [r1, #4]
    7d46:	f851 803c 	ldr.w	r8, [r1, ip, lsl #3]
    7d4a:	f8c4 8008 	str.w	r8, [r4, #8]
    7d4e:	eb01 09cc 	add.w	r9, r1, ip, lsl #3
    7d52:	431a      	orrs	r2, r3
    7d54:	f1a9 0308 	sub.w	r3, r9, #8
    7d58:	60e3      	str	r3, [r4, #12]
    7d5a:	604a      	str	r2, [r1, #4]
    7d5c:	f841 403c 	str.w	r4, [r1, ip, lsl #3]
    7d60:	f8c8 400c 	str.w	r4, [r8, #12]
    7d64:	1083      	asrs	r3, r0, #2
    7d66:	2401      	movs	r4, #1
    7d68:	409c      	lsls	r4, r3
    7d6a:	4294      	cmp	r4, r2
    7d6c:	f200 808a 	bhi.w	7e84 <_malloc_r+0x1f0>
    7d70:	4214      	tst	r4, r2
    7d72:	d106      	bne.n	7d82 <_malloc_r+0xee>
    7d74:	f020 0003 	bic.w	r0, r0, #3
    7d78:	0064      	lsls	r4, r4, #1
    7d7a:	4214      	tst	r4, r2
    7d7c:	f100 0004 	add.w	r0, r0, #4
    7d80:	d0fa      	beq.n	7d78 <_malloc_r+0xe4>
    7d82:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
    7d86:	46cc      	mov	ip, r9
    7d88:	4680      	mov	r8, r0
    7d8a:	f8dc 100c 	ldr.w	r1, [ip, #12]
    7d8e:	458c      	cmp	ip, r1
    7d90:	d107      	bne.n	7da2 <_malloc_r+0x10e>
    7d92:	e173      	b.n	807c <_malloc_r+0x3e8>
    7d94:	2a00      	cmp	r2, #0
    7d96:	f280 8181 	bge.w	809c <_malloc_r+0x408>
    7d9a:	68c9      	ldr	r1, [r1, #12]
    7d9c:	458c      	cmp	ip, r1
    7d9e:	f000 816d 	beq.w	807c <_malloc_r+0x3e8>
    7da2:	684b      	ldr	r3, [r1, #4]
    7da4:	f023 0303 	bic.w	r3, r3, #3
    7da8:	1b5a      	subs	r2, r3, r5
    7daa:	2a0f      	cmp	r2, #15
    7dac:	ddf2      	ble.n	7d94 <_malloc_r+0x100>
    7dae:	460c      	mov	r4, r1
    7db0:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    7db4:	f854 8f08 	ldr.w	r8, [r4, #8]!
    7db8:	194b      	adds	r3, r1, r5
    7dba:	f045 0501 	orr.w	r5, r5, #1
    7dbe:	604d      	str	r5, [r1, #4]
    7dc0:	f042 0101 	orr.w	r1, r2, #1
    7dc4:	f8c8 c00c 	str.w	ip, [r8, #12]
    7dc8:	4630      	mov	r0, r6
    7dca:	f8cc 8008 	str.w	r8, [ip, #8]
    7dce:	617b      	str	r3, [r7, #20]
    7dd0:	613b      	str	r3, [r7, #16]
    7dd2:	f8c3 e00c 	str.w	lr, [r3, #12]
    7dd6:	f8c3 e008 	str.w	lr, [r3, #8]
    7dda:	6059      	str	r1, [r3, #4]
    7ddc:	509a      	str	r2, [r3, r2]
    7dde:	f000 fac5 	bl	836c <__malloc_unlock>
    7de2:	e01f      	b.n	7e24 <_malloc_r+0x190>
    7de4:	2910      	cmp	r1, #16
    7de6:	d821      	bhi.n	7e2c <_malloc_r+0x198>
    7de8:	f000 fabe 	bl	8368 <__malloc_lock>
    7dec:	2510      	movs	r5, #16
    7dee:	2306      	movs	r3, #6
    7df0:	2002      	movs	r0, #2
    7df2:	4f7e      	ldr	r7, [pc, #504]	; (7fec <_malloc_r+0x358>)
    7df4:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    7df8:	f1a3 0208 	sub.w	r2, r3, #8
    7dfc:	685c      	ldr	r4, [r3, #4]
    7dfe:	4294      	cmp	r4, r2
    7e00:	f000 8145 	beq.w	808e <_malloc_r+0x3fa>
    7e04:	6863      	ldr	r3, [r4, #4]
    7e06:	68e1      	ldr	r1, [r4, #12]
    7e08:	68a5      	ldr	r5, [r4, #8]
    7e0a:	f023 0303 	bic.w	r3, r3, #3
    7e0e:	4423      	add	r3, r4
    7e10:	4630      	mov	r0, r6
    7e12:	685a      	ldr	r2, [r3, #4]
    7e14:	60e9      	str	r1, [r5, #12]
    7e16:	f042 0201 	orr.w	r2, r2, #1
    7e1a:	608d      	str	r5, [r1, #8]
    7e1c:	605a      	str	r2, [r3, #4]
    7e1e:	f000 faa5 	bl	836c <__malloc_unlock>
    7e22:	3408      	adds	r4, #8
    7e24:	4620      	mov	r0, r4
    7e26:	b003      	add	sp, #12
    7e28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7e2c:	2400      	movs	r4, #0
    7e2e:	230c      	movs	r3, #12
    7e30:	4620      	mov	r0, r4
    7e32:	6033      	str	r3, [r6, #0]
    7e34:	b003      	add	sp, #12
    7e36:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7e3a:	2380      	movs	r3, #128	; 0x80
    7e3c:	f04f 0e40 	mov.w	lr, #64	; 0x40
    7e40:	203f      	movs	r0, #63	; 0x3f
    7e42:	e749      	b.n	7cd8 <_malloc_r+0x44>
    7e44:	4670      	mov	r0, lr
    7e46:	e75d      	b.n	7d04 <_malloc_r+0x70>
    7e48:	4423      	add	r3, r4
    7e4a:	68e1      	ldr	r1, [r4, #12]
    7e4c:	685a      	ldr	r2, [r3, #4]
    7e4e:	68a5      	ldr	r5, [r4, #8]
    7e50:	f042 0201 	orr.w	r2, r2, #1
    7e54:	60e9      	str	r1, [r5, #12]
    7e56:	4630      	mov	r0, r6
    7e58:	608d      	str	r5, [r1, #8]
    7e5a:	605a      	str	r2, [r3, #4]
    7e5c:	f000 fa86 	bl	836c <__malloc_unlock>
    7e60:	3408      	adds	r4, #8
    7e62:	4620      	mov	r0, r4
    7e64:	b003      	add	sp, #12
    7e66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7e6a:	4423      	add	r3, r4
    7e6c:	4630      	mov	r0, r6
    7e6e:	685a      	ldr	r2, [r3, #4]
    7e70:	f042 0201 	orr.w	r2, r2, #1
    7e74:	605a      	str	r2, [r3, #4]
    7e76:	f000 fa79 	bl	836c <__malloc_unlock>
    7e7a:	3408      	adds	r4, #8
    7e7c:	4620      	mov	r0, r4
    7e7e:	b003      	add	sp, #12
    7e80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7e84:	68bc      	ldr	r4, [r7, #8]
    7e86:	6863      	ldr	r3, [r4, #4]
    7e88:	f023 0803 	bic.w	r8, r3, #3
    7e8c:	45a8      	cmp	r8, r5
    7e8e:	d304      	bcc.n	7e9a <_malloc_r+0x206>
    7e90:	ebc5 0308 	rsb	r3, r5, r8
    7e94:	2b0f      	cmp	r3, #15
    7e96:	f300 808c 	bgt.w	7fb2 <_malloc_r+0x31e>
    7e9a:	4b55      	ldr	r3, [pc, #340]	; (7ff0 <_malloc_r+0x35c>)
    7e9c:	f8df 9160 	ldr.w	r9, [pc, #352]	; 8000 <_malloc_r+0x36c>
    7ea0:	681a      	ldr	r2, [r3, #0]
    7ea2:	f8d9 3000 	ldr.w	r3, [r9]
    7ea6:	3301      	adds	r3, #1
    7ea8:	442a      	add	r2, r5
    7eaa:	eb04 0a08 	add.w	sl, r4, r8
    7eae:	f000 8160 	beq.w	8172 <_malloc_r+0x4de>
    7eb2:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    7eb6:	320f      	adds	r2, #15
    7eb8:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
    7ebc:	f022 020f 	bic.w	r2, r2, #15
    7ec0:	4611      	mov	r1, r2
    7ec2:	4630      	mov	r0, r6
    7ec4:	9201      	str	r2, [sp, #4]
    7ec6:	f000 fc4b 	bl	8760 <_sbrk_r>
    7eca:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    7ece:	4683      	mov	fp, r0
    7ed0:	9a01      	ldr	r2, [sp, #4]
    7ed2:	f000 8158 	beq.w	8186 <_malloc_r+0x4f2>
    7ed6:	4582      	cmp	sl, r0
    7ed8:	f200 80fc 	bhi.w	80d4 <_malloc_r+0x440>
    7edc:	4b45      	ldr	r3, [pc, #276]	; (7ff4 <_malloc_r+0x360>)
    7ede:	6819      	ldr	r1, [r3, #0]
    7ee0:	45da      	cmp	sl, fp
    7ee2:	4411      	add	r1, r2
    7ee4:	6019      	str	r1, [r3, #0]
    7ee6:	f000 8153 	beq.w	8190 <_malloc_r+0x4fc>
    7eea:	f8d9 0000 	ldr.w	r0, [r9]
    7eee:	f8df e110 	ldr.w	lr, [pc, #272]	; 8000 <_malloc_r+0x36c>
    7ef2:	3001      	adds	r0, #1
    7ef4:	bf1b      	ittet	ne
    7ef6:	ebca 0a0b 	rsbne	sl, sl, fp
    7efa:	4451      	addne	r1, sl
    7efc:	f8ce b000 	streq.w	fp, [lr]
    7f00:	6019      	strne	r1, [r3, #0]
    7f02:	f01b 0107 	ands.w	r1, fp, #7
    7f06:	f000 8117 	beq.w	8138 <_malloc_r+0x4a4>
    7f0a:	f1c1 0008 	rsb	r0, r1, #8
    7f0e:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
    7f12:	4483      	add	fp, r0
    7f14:	3108      	adds	r1, #8
    7f16:	445a      	add	r2, fp
    7f18:	f3c2 020b 	ubfx	r2, r2, #0, #12
    7f1c:	ebc2 0901 	rsb	r9, r2, r1
    7f20:	4649      	mov	r1, r9
    7f22:	4630      	mov	r0, r6
    7f24:	9301      	str	r3, [sp, #4]
    7f26:	f000 fc1b 	bl	8760 <_sbrk_r>
    7f2a:	1c43      	adds	r3, r0, #1
    7f2c:	9b01      	ldr	r3, [sp, #4]
    7f2e:	f000 813f 	beq.w	81b0 <_malloc_r+0x51c>
    7f32:	ebcb 0200 	rsb	r2, fp, r0
    7f36:	444a      	add	r2, r9
    7f38:	f042 0201 	orr.w	r2, r2, #1
    7f3c:	6819      	ldr	r1, [r3, #0]
    7f3e:	f8c7 b008 	str.w	fp, [r7, #8]
    7f42:	4449      	add	r1, r9
    7f44:	42bc      	cmp	r4, r7
    7f46:	f8cb 2004 	str.w	r2, [fp, #4]
    7f4a:	6019      	str	r1, [r3, #0]
    7f4c:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 7ff4 <_malloc_r+0x360>
    7f50:	d016      	beq.n	7f80 <_malloc_r+0x2ec>
    7f52:	f1b8 0f0f 	cmp.w	r8, #15
    7f56:	f240 80fd 	bls.w	8154 <_malloc_r+0x4c0>
    7f5a:	6862      	ldr	r2, [r4, #4]
    7f5c:	f1a8 030c 	sub.w	r3, r8, #12
    7f60:	f023 0307 	bic.w	r3, r3, #7
    7f64:	18e0      	adds	r0, r4, r3
    7f66:	f002 0201 	and.w	r2, r2, #1
    7f6a:	f04f 0e05 	mov.w	lr, #5
    7f6e:	431a      	orrs	r2, r3
    7f70:	2b0f      	cmp	r3, #15
    7f72:	6062      	str	r2, [r4, #4]
    7f74:	f8c0 e004 	str.w	lr, [r0, #4]
    7f78:	f8c0 e008 	str.w	lr, [r0, #8]
    7f7c:	f200 811c 	bhi.w	81b8 <_malloc_r+0x524>
    7f80:	4b1d      	ldr	r3, [pc, #116]	; (7ff8 <_malloc_r+0x364>)
    7f82:	68bc      	ldr	r4, [r7, #8]
    7f84:	681a      	ldr	r2, [r3, #0]
    7f86:	4291      	cmp	r1, r2
    7f88:	bf88      	it	hi
    7f8a:	6019      	strhi	r1, [r3, #0]
    7f8c:	4b1b      	ldr	r3, [pc, #108]	; (7ffc <_malloc_r+0x368>)
    7f8e:	681a      	ldr	r2, [r3, #0]
    7f90:	4291      	cmp	r1, r2
    7f92:	6862      	ldr	r2, [r4, #4]
    7f94:	bf88      	it	hi
    7f96:	6019      	strhi	r1, [r3, #0]
    7f98:	f022 0203 	bic.w	r2, r2, #3
    7f9c:	4295      	cmp	r5, r2
    7f9e:	eba2 0305 	sub.w	r3, r2, r5
    7fa2:	d801      	bhi.n	7fa8 <_malloc_r+0x314>
    7fa4:	2b0f      	cmp	r3, #15
    7fa6:	dc04      	bgt.n	7fb2 <_malloc_r+0x31e>
    7fa8:	4630      	mov	r0, r6
    7faa:	f000 f9df 	bl	836c <__malloc_unlock>
    7fae:	2400      	movs	r4, #0
    7fb0:	e738      	b.n	7e24 <_malloc_r+0x190>
    7fb2:	1962      	adds	r2, r4, r5
    7fb4:	f043 0301 	orr.w	r3, r3, #1
    7fb8:	f045 0501 	orr.w	r5, r5, #1
    7fbc:	6065      	str	r5, [r4, #4]
    7fbe:	4630      	mov	r0, r6
    7fc0:	60ba      	str	r2, [r7, #8]
    7fc2:	6053      	str	r3, [r2, #4]
    7fc4:	f000 f9d2 	bl	836c <__malloc_unlock>
    7fc8:	3408      	adds	r4, #8
    7fca:	4620      	mov	r0, r4
    7fcc:	b003      	add	sp, #12
    7fce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7fd2:	2b14      	cmp	r3, #20
    7fd4:	d971      	bls.n	80ba <_malloc_r+0x426>
    7fd6:	2b54      	cmp	r3, #84	; 0x54
    7fd8:	f200 80a4 	bhi.w	8124 <_malloc_r+0x490>
    7fdc:	0b28      	lsrs	r0, r5, #12
    7fde:	f100 0e6f 	add.w	lr, r0, #111	; 0x6f
    7fe2:	ea4f 034e 	mov.w	r3, lr, lsl #1
    7fe6:	306e      	adds	r0, #110	; 0x6e
    7fe8:	e676      	b.n	7cd8 <_malloc_r+0x44>
    7fea:	bf00      	nop
    7fec:	1fff100c 	.word	0x1fff100c
    7ff0:	1fff2c1c 	.word	0x1fff2c1c
    7ff4:	1fff2c20 	.word	0x1fff2c20
    7ff8:	1fff2c18 	.word	0x1fff2c18
    7ffc:	1fff2c14 	.word	0x1fff2c14
    8000:	1fff1418 	.word	0x1fff1418
    8004:	0a5a      	lsrs	r2, r3, #9
    8006:	2a04      	cmp	r2, #4
    8008:	d95e      	bls.n	80c8 <_malloc_r+0x434>
    800a:	2a14      	cmp	r2, #20
    800c:	f200 80b3 	bhi.w	8176 <_malloc_r+0x4e2>
    8010:	f102 015c 	add.w	r1, r2, #92	; 0x5c
    8014:	0049      	lsls	r1, r1, #1
    8016:	325b      	adds	r2, #91	; 0x5b
    8018:	eb07 0c81 	add.w	ip, r7, r1, lsl #2
    801c:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
    8020:	f8df 81dc 	ldr.w	r8, [pc, #476]	; 8200 <_malloc_r+0x56c>
    8024:	f1ac 0c08 	sub.w	ip, ip, #8
    8028:	458c      	cmp	ip, r1
    802a:	f000 8088 	beq.w	813e <_malloc_r+0x4aa>
    802e:	684a      	ldr	r2, [r1, #4]
    8030:	f022 0203 	bic.w	r2, r2, #3
    8034:	4293      	cmp	r3, r2
    8036:	d202      	bcs.n	803e <_malloc_r+0x3aa>
    8038:	6889      	ldr	r1, [r1, #8]
    803a:	458c      	cmp	ip, r1
    803c:	d1f7      	bne.n	802e <_malloc_r+0x39a>
    803e:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    8042:	687a      	ldr	r2, [r7, #4]
    8044:	f8c4 c00c 	str.w	ip, [r4, #12]
    8048:	60a1      	str	r1, [r4, #8]
    804a:	f8cc 4008 	str.w	r4, [ip, #8]
    804e:	60cc      	str	r4, [r1, #12]
    8050:	e688      	b.n	7d64 <_malloc_r+0xd0>
    8052:	1963      	adds	r3, r4, r5
    8054:	f042 0701 	orr.w	r7, r2, #1
    8058:	f045 0501 	orr.w	r5, r5, #1
    805c:	6065      	str	r5, [r4, #4]
    805e:	4630      	mov	r0, r6
    8060:	614b      	str	r3, [r1, #20]
    8062:	610b      	str	r3, [r1, #16]
    8064:	f8c3 e00c 	str.w	lr, [r3, #12]
    8068:	f8c3 e008 	str.w	lr, [r3, #8]
    806c:	605f      	str	r7, [r3, #4]
    806e:	509a      	str	r2, [r3, r2]
    8070:	3408      	adds	r4, #8
    8072:	f000 f97b 	bl	836c <__malloc_unlock>
    8076:	e6d5      	b.n	7e24 <_malloc_r+0x190>
    8078:	684a      	ldr	r2, [r1, #4]
    807a:	e673      	b.n	7d64 <_malloc_r+0xd0>
    807c:	f108 0801 	add.w	r8, r8, #1
    8080:	f018 0f03 	tst.w	r8, #3
    8084:	f10c 0c08 	add.w	ip, ip, #8
    8088:	f47f ae7f 	bne.w	7d8a <_malloc_r+0xf6>
    808c:	e030      	b.n	80f0 <_malloc_r+0x45c>
    808e:	68dc      	ldr	r4, [r3, #12]
    8090:	42a3      	cmp	r3, r4
    8092:	bf08      	it	eq
    8094:	3002      	addeq	r0, #2
    8096:	f43f ae35 	beq.w	7d04 <_malloc_r+0x70>
    809a:	e6b3      	b.n	7e04 <_malloc_r+0x170>
    809c:	440b      	add	r3, r1
    809e:	460c      	mov	r4, r1
    80a0:	685a      	ldr	r2, [r3, #4]
    80a2:	68c9      	ldr	r1, [r1, #12]
    80a4:	f854 5f08 	ldr.w	r5, [r4, #8]!
    80a8:	f042 0201 	orr.w	r2, r2, #1
    80ac:	605a      	str	r2, [r3, #4]
    80ae:	4630      	mov	r0, r6
    80b0:	60e9      	str	r1, [r5, #12]
    80b2:	608d      	str	r5, [r1, #8]
    80b4:	f000 f95a 	bl	836c <__malloc_unlock>
    80b8:	e6b4      	b.n	7e24 <_malloc_r+0x190>
    80ba:	f103 0e5c 	add.w	lr, r3, #92	; 0x5c
    80be:	f103 005b 	add.w	r0, r3, #91	; 0x5b
    80c2:	ea4f 034e 	mov.w	r3, lr, lsl #1
    80c6:	e607      	b.n	7cd8 <_malloc_r+0x44>
    80c8:	099a      	lsrs	r2, r3, #6
    80ca:	f102 0139 	add.w	r1, r2, #57	; 0x39
    80ce:	0049      	lsls	r1, r1, #1
    80d0:	3238      	adds	r2, #56	; 0x38
    80d2:	e7a1      	b.n	8018 <_malloc_r+0x384>
    80d4:	42bc      	cmp	r4, r7
    80d6:	4b4a      	ldr	r3, [pc, #296]	; (8200 <_malloc_r+0x56c>)
    80d8:	f43f af00 	beq.w	7edc <_malloc_r+0x248>
    80dc:	689c      	ldr	r4, [r3, #8]
    80de:	6862      	ldr	r2, [r4, #4]
    80e0:	f022 0203 	bic.w	r2, r2, #3
    80e4:	e75a      	b.n	7f9c <_malloc_r+0x308>
    80e6:	f859 3908 	ldr.w	r3, [r9], #-8
    80ea:	4599      	cmp	r9, r3
    80ec:	f040 8082 	bne.w	81f4 <_malloc_r+0x560>
    80f0:	f010 0f03 	tst.w	r0, #3
    80f4:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
    80f8:	d1f5      	bne.n	80e6 <_malloc_r+0x452>
    80fa:	687b      	ldr	r3, [r7, #4]
    80fc:	ea23 0304 	bic.w	r3, r3, r4
    8100:	607b      	str	r3, [r7, #4]
    8102:	0064      	lsls	r4, r4, #1
    8104:	429c      	cmp	r4, r3
    8106:	f63f aebd 	bhi.w	7e84 <_malloc_r+0x1f0>
    810a:	2c00      	cmp	r4, #0
    810c:	f43f aeba 	beq.w	7e84 <_malloc_r+0x1f0>
    8110:	421c      	tst	r4, r3
    8112:	4640      	mov	r0, r8
    8114:	f47f ae35 	bne.w	7d82 <_malloc_r+0xee>
    8118:	0064      	lsls	r4, r4, #1
    811a:	421c      	tst	r4, r3
    811c:	f100 0004 	add.w	r0, r0, #4
    8120:	d0fa      	beq.n	8118 <_malloc_r+0x484>
    8122:	e62e      	b.n	7d82 <_malloc_r+0xee>
    8124:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
    8128:	d818      	bhi.n	815c <_malloc_r+0x4c8>
    812a:	0be8      	lsrs	r0, r5, #15
    812c:	f100 0e78 	add.w	lr, r0, #120	; 0x78
    8130:	ea4f 034e 	mov.w	r3, lr, lsl #1
    8134:	3077      	adds	r0, #119	; 0x77
    8136:	e5cf      	b.n	7cd8 <_malloc_r+0x44>
    8138:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    813c:	e6eb      	b.n	7f16 <_malloc_r+0x282>
    813e:	2101      	movs	r1, #1
    8140:	f8d8 3004 	ldr.w	r3, [r8, #4]
    8144:	1092      	asrs	r2, r2, #2
    8146:	fa01 f202 	lsl.w	r2, r1, r2
    814a:	431a      	orrs	r2, r3
    814c:	f8c8 2004 	str.w	r2, [r8, #4]
    8150:	4661      	mov	r1, ip
    8152:	e777      	b.n	8044 <_malloc_r+0x3b0>
    8154:	2301      	movs	r3, #1
    8156:	f8cb 3004 	str.w	r3, [fp, #4]
    815a:	e725      	b.n	7fa8 <_malloc_r+0x314>
    815c:	f240 5254 	movw	r2, #1364	; 0x554
    8160:	4293      	cmp	r3, r2
    8162:	d820      	bhi.n	81a6 <_malloc_r+0x512>
    8164:	0ca8      	lsrs	r0, r5, #18
    8166:	f100 0e7d 	add.w	lr, r0, #125	; 0x7d
    816a:	ea4f 034e 	mov.w	r3, lr, lsl #1
    816e:	307c      	adds	r0, #124	; 0x7c
    8170:	e5b2      	b.n	7cd8 <_malloc_r+0x44>
    8172:	3210      	adds	r2, #16
    8174:	e6a4      	b.n	7ec0 <_malloc_r+0x22c>
    8176:	2a54      	cmp	r2, #84	; 0x54
    8178:	d826      	bhi.n	81c8 <_malloc_r+0x534>
    817a:	0b1a      	lsrs	r2, r3, #12
    817c:	f102 016f 	add.w	r1, r2, #111	; 0x6f
    8180:	0049      	lsls	r1, r1, #1
    8182:	326e      	adds	r2, #110	; 0x6e
    8184:	e748      	b.n	8018 <_malloc_r+0x384>
    8186:	68bc      	ldr	r4, [r7, #8]
    8188:	6862      	ldr	r2, [r4, #4]
    818a:	f022 0203 	bic.w	r2, r2, #3
    818e:	e705      	b.n	7f9c <_malloc_r+0x308>
    8190:	f3ca 000b 	ubfx	r0, sl, #0, #12
    8194:	2800      	cmp	r0, #0
    8196:	f47f aea8 	bne.w	7eea <_malloc_r+0x256>
    819a:	4442      	add	r2, r8
    819c:	68bb      	ldr	r3, [r7, #8]
    819e:	f042 0201 	orr.w	r2, r2, #1
    81a2:	605a      	str	r2, [r3, #4]
    81a4:	e6ec      	b.n	7f80 <_malloc_r+0x2ec>
    81a6:	23fe      	movs	r3, #254	; 0xfe
    81a8:	f04f 0e7f 	mov.w	lr, #127	; 0x7f
    81ac:	207e      	movs	r0, #126	; 0x7e
    81ae:	e593      	b.n	7cd8 <_malloc_r+0x44>
    81b0:	2201      	movs	r2, #1
    81b2:	f04f 0900 	mov.w	r9, #0
    81b6:	e6c1      	b.n	7f3c <_malloc_r+0x2a8>
    81b8:	f104 0108 	add.w	r1, r4, #8
    81bc:	4630      	mov	r0, r6
    81be:	f000 fd9f 	bl	8d00 <_free_r>
    81c2:	f8d9 1000 	ldr.w	r1, [r9]
    81c6:	e6db      	b.n	7f80 <_malloc_r+0x2ec>
    81c8:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    81cc:	d805      	bhi.n	81da <_malloc_r+0x546>
    81ce:	0bda      	lsrs	r2, r3, #15
    81d0:	f102 0178 	add.w	r1, r2, #120	; 0x78
    81d4:	0049      	lsls	r1, r1, #1
    81d6:	3277      	adds	r2, #119	; 0x77
    81d8:	e71e      	b.n	8018 <_malloc_r+0x384>
    81da:	f240 5154 	movw	r1, #1364	; 0x554
    81de:	428a      	cmp	r2, r1
    81e0:	d805      	bhi.n	81ee <_malloc_r+0x55a>
    81e2:	0c9a      	lsrs	r2, r3, #18
    81e4:	f102 017d 	add.w	r1, r2, #125	; 0x7d
    81e8:	0049      	lsls	r1, r1, #1
    81ea:	327c      	adds	r2, #124	; 0x7c
    81ec:	e714      	b.n	8018 <_malloc_r+0x384>
    81ee:	21fe      	movs	r1, #254	; 0xfe
    81f0:	227e      	movs	r2, #126	; 0x7e
    81f2:	e711      	b.n	8018 <_malloc_r+0x384>
    81f4:	687b      	ldr	r3, [r7, #4]
    81f6:	e784      	b.n	8102 <_malloc_r+0x46e>
    81f8:	08e8      	lsrs	r0, r5, #3
    81fa:	1c43      	adds	r3, r0, #1
    81fc:	005b      	lsls	r3, r3, #1
    81fe:	e5f8      	b.n	7df2 <_malloc_r+0x15e>
    8200:	1fff100c 	.word	0x1fff100c

00008204 <memmove>:
    8204:	4288      	cmp	r0, r1
    8206:	b5f0      	push	{r4, r5, r6, r7, lr}
    8208:	d90d      	bls.n	8226 <memmove+0x22>
    820a:	188b      	adds	r3, r1, r2
    820c:	4298      	cmp	r0, r3
    820e:	d20a      	bcs.n	8226 <memmove+0x22>
    8210:	1881      	adds	r1, r0, r2
    8212:	2a00      	cmp	r2, #0
    8214:	d051      	beq.n	82ba <memmove+0xb6>
    8216:	1a9a      	subs	r2, r3, r2
    8218:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
    821c:	f801 4d01 	strb.w	r4, [r1, #-1]!
    8220:	4293      	cmp	r3, r2
    8222:	d1f9      	bne.n	8218 <memmove+0x14>
    8224:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8226:	2a0f      	cmp	r2, #15
    8228:	d948      	bls.n	82bc <memmove+0xb8>
    822a:	ea41 0300 	orr.w	r3, r1, r0
    822e:	079b      	lsls	r3, r3, #30
    8230:	d146      	bne.n	82c0 <memmove+0xbc>
    8232:	f100 0410 	add.w	r4, r0, #16
    8236:	f101 0310 	add.w	r3, r1, #16
    823a:	4615      	mov	r5, r2
    823c:	f853 6c10 	ldr.w	r6, [r3, #-16]
    8240:	f844 6c10 	str.w	r6, [r4, #-16]
    8244:	f853 6c0c 	ldr.w	r6, [r3, #-12]
    8248:	f844 6c0c 	str.w	r6, [r4, #-12]
    824c:	f853 6c08 	ldr.w	r6, [r3, #-8]
    8250:	f844 6c08 	str.w	r6, [r4, #-8]
    8254:	3d10      	subs	r5, #16
    8256:	f853 6c04 	ldr.w	r6, [r3, #-4]
    825a:	f844 6c04 	str.w	r6, [r4, #-4]
    825e:	2d0f      	cmp	r5, #15
    8260:	f103 0310 	add.w	r3, r3, #16
    8264:	f104 0410 	add.w	r4, r4, #16
    8268:	d8e8      	bhi.n	823c <memmove+0x38>
    826a:	f1a2 0310 	sub.w	r3, r2, #16
    826e:	f023 030f 	bic.w	r3, r3, #15
    8272:	f002 0e0f 	and.w	lr, r2, #15
    8276:	3310      	adds	r3, #16
    8278:	f1be 0f03 	cmp.w	lr, #3
    827c:	4419      	add	r1, r3
    827e:	4403      	add	r3, r0
    8280:	d921      	bls.n	82c6 <memmove+0xc2>
    8282:	1f1e      	subs	r6, r3, #4
    8284:	460d      	mov	r5, r1
    8286:	4674      	mov	r4, lr
    8288:	3c04      	subs	r4, #4
    828a:	f855 7b04 	ldr.w	r7, [r5], #4
    828e:	f846 7f04 	str.w	r7, [r6, #4]!
    8292:	2c03      	cmp	r4, #3
    8294:	d8f8      	bhi.n	8288 <memmove+0x84>
    8296:	f1ae 0404 	sub.w	r4, lr, #4
    829a:	f024 0403 	bic.w	r4, r4, #3
    829e:	3404      	adds	r4, #4
    82a0:	4423      	add	r3, r4
    82a2:	4421      	add	r1, r4
    82a4:	f002 0203 	and.w	r2, r2, #3
    82a8:	b162      	cbz	r2, 82c4 <memmove+0xc0>
    82aa:	3b01      	subs	r3, #1
    82ac:	440a      	add	r2, r1
    82ae:	f811 4b01 	ldrb.w	r4, [r1], #1
    82b2:	f803 4f01 	strb.w	r4, [r3, #1]!
    82b6:	428a      	cmp	r2, r1
    82b8:	d1f9      	bne.n	82ae <memmove+0xaa>
    82ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
    82bc:	4603      	mov	r3, r0
    82be:	e7f3      	b.n	82a8 <memmove+0xa4>
    82c0:	4603      	mov	r3, r0
    82c2:	e7f2      	b.n	82aa <memmove+0xa6>
    82c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    82c6:	4672      	mov	r2, lr
    82c8:	e7ee      	b.n	82a8 <memmove+0xa4>
    82ca:	bf00      	nop

000082cc <memset>:
    82cc:	b470      	push	{r4, r5, r6}
    82ce:	0784      	lsls	r4, r0, #30
    82d0:	d046      	beq.n	8360 <memset+0x94>
    82d2:	1e54      	subs	r4, r2, #1
    82d4:	2a00      	cmp	r2, #0
    82d6:	d041      	beq.n	835c <memset+0x90>
    82d8:	b2cd      	uxtb	r5, r1
    82da:	4603      	mov	r3, r0
    82dc:	e002      	b.n	82e4 <memset+0x18>
    82de:	1e62      	subs	r2, r4, #1
    82e0:	b3e4      	cbz	r4, 835c <memset+0x90>
    82e2:	4614      	mov	r4, r2
    82e4:	f803 5b01 	strb.w	r5, [r3], #1
    82e8:	079a      	lsls	r2, r3, #30
    82ea:	d1f8      	bne.n	82de <memset+0x12>
    82ec:	2c03      	cmp	r4, #3
    82ee:	d92e      	bls.n	834e <memset+0x82>
    82f0:	b2cd      	uxtb	r5, r1
    82f2:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    82f6:	2c0f      	cmp	r4, #15
    82f8:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    82fc:	d919      	bls.n	8332 <memset+0x66>
    82fe:	f103 0210 	add.w	r2, r3, #16
    8302:	4626      	mov	r6, r4
    8304:	3e10      	subs	r6, #16
    8306:	2e0f      	cmp	r6, #15
    8308:	f842 5c10 	str.w	r5, [r2, #-16]
    830c:	f842 5c0c 	str.w	r5, [r2, #-12]
    8310:	f842 5c08 	str.w	r5, [r2, #-8]
    8314:	f842 5c04 	str.w	r5, [r2, #-4]
    8318:	f102 0210 	add.w	r2, r2, #16
    831c:	d8f2      	bhi.n	8304 <memset+0x38>
    831e:	f1a4 0210 	sub.w	r2, r4, #16
    8322:	f022 020f 	bic.w	r2, r2, #15
    8326:	f004 040f 	and.w	r4, r4, #15
    832a:	3210      	adds	r2, #16
    832c:	2c03      	cmp	r4, #3
    832e:	4413      	add	r3, r2
    8330:	d90d      	bls.n	834e <memset+0x82>
    8332:	461e      	mov	r6, r3
    8334:	4622      	mov	r2, r4
    8336:	3a04      	subs	r2, #4
    8338:	2a03      	cmp	r2, #3
    833a:	f846 5b04 	str.w	r5, [r6], #4
    833e:	d8fa      	bhi.n	8336 <memset+0x6a>
    8340:	1f22      	subs	r2, r4, #4
    8342:	f022 0203 	bic.w	r2, r2, #3
    8346:	3204      	adds	r2, #4
    8348:	4413      	add	r3, r2
    834a:	f004 0403 	and.w	r4, r4, #3
    834e:	b12c      	cbz	r4, 835c <memset+0x90>
    8350:	b2c9      	uxtb	r1, r1
    8352:	441c      	add	r4, r3
    8354:	f803 1b01 	strb.w	r1, [r3], #1
    8358:	42a3      	cmp	r3, r4
    835a:	d1fb      	bne.n	8354 <memset+0x88>
    835c:	bc70      	pop	{r4, r5, r6}
    835e:	4770      	bx	lr
    8360:	4614      	mov	r4, r2
    8362:	4603      	mov	r3, r0
    8364:	e7c2      	b.n	82ec <memset+0x20>
    8366:	bf00      	nop

00008368 <__malloc_lock>:
    8368:	4770      	bx	lr
    836a:	bf00      	nop

0000836c <__malloc_unlock>:
    836c:	4770      	bx	lr
    836e:	bf00      	nop

00008370 <realloc>:
    8370:	4b02      	ldr	r3, [pc, #8]	; (837c <realloc+0xc>)
    8372:	460a      	mov	r2, r1
    8374:	4601      	mov	r1, r0
    8376:	6818      	ldr	r0, [r3, #0]
    8378:	f000 b802 	b.w	8380 <_realloc_r>
    837c:	1fff1008 	.word	0x1fff1008

00008380 <_realloc_r>:
    8380:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8384:	4617      	mov	r7, r2
    8386:	b083      	sub	sp, #12
    8388:	2900      	cmp	r1, #0
    838a:	f000 80c1 	beq.w	8510 <_realloc_r+0x190>
    838e:	460e      	mov	r6, r1
    8390:	4681      	mov	r9, r0
    8392:	f107 050b 	add.w	r5, r7, #11
    8396:	f7ff ffe7 	bl	8368 <__malloc_lock>
    839a:	f856 ec04 	ldr.w	lr, [r6, #-4]
    839e:	2d16      	cmp	r5, #22
    83a0:	f02e 0403 	bic.w	r4, lr, #3
    83a4:	f1a6 0808 	sub.w	r8, r6, #8
    83a8:	d840      	bhi.n	842c <_realloc_r+0xac>
    83aa:	2210      	movs	r2, #16
    83ac:	4615      	mov	r5, r2
    83ae:	42af      	cmp	r7, r5
    83b0:	d841      	bhi.n	8436 <_realloc_r+0xb6>
    83b2:	4294      	cmp	r4, r2
    83b4:	da75      	bge.n	84a2 <_realloc_r+0x122>
    83b6:	4bc9      	ldr	r3, [pc, #804]	; (86dc <_realloc_r+0x35c>)
    83b8:	6899      	ldr	r1, [r3, #8]
    83ba:	eb08 0004 	add.w	r0, r8, r4
    83be:	4288      	cmp	r0, r1
    83c0:	6841      	ldr	r1, [r0, #4]
    83c2:	f000 80d9 	beq.w	8578 <_realloc_r+0x1f8>
    83c6:	f021 0301 	bic.w	r3, r1, #1
    83ca:	4403      	add	r3, r0
    83cc:	685b      	ldr	r3, [r3, #4]
    83ce:	07db      	lsls	r3, r3, #31
    83d0:	d57d      	bpl.n	84ce <_realloc_r+0x14e>
    83d2:	f01e 0f01 	tst.w	lr, #1
    83d6:	d035      	beq.n	8444 <_realloc_r+0xc4>
    83d8:	4639      	mov	r1, r7
    83da:	4648      	mov	r0, r9
    83dc:	f7ff fc5a 	bl	7c94 <_malloc_r>
    83e0:	4607      	mov	r7, r0
    83e2:	b1e0      	cbz	r0, 841e <_realloc_r+0x9e>
    83e4:	f856 3c04 	ldr.w	r3, [r6, #-4]
    83e8:	f023 0301 	bic.w	r3, r3, #1
    83ec:	4443      	add	r3, r8
    83ee:	f1a0 0208 	sub.w	r2, r0, #8
    83f2:	429a      	cmp	r2, r3
    83f4:	f000 8144 	beq.w	8680 <_realloc_r+0x300>
    83f8:	1f22      	subs	r2, r4, #4
    83fa:	2a24      	cmp	r2, #36	; 0x24
    83fc:	f200 8131 	bhi.w	8662 <_realloc_r+0x2e2>
    8400:	2a13      	cmp	r2, #19
    8402:	f200 8104 	bhi.w	860e <_realloc_r+0x28e>
    8406:	4603      	mov	r3, r0
    8408:	4632      	mov	r2, r6
    840a:	6811      	ldr	r1, [r2, #0]
    840c:	6019      	str	r1, [r3, #0]
    840e:	6851      	ldr	r1, [r2, #4]
    8410:	6059      	str	r1, [r3, #4]
    8412:	6892      	ldr	r2, [r2, #8]
    8414:	609a      	str	r2, [r3, #8]
    8416:	4631      	mov	r1, r6
    8418:	4648      	mov	r0, r9
    841a:	f000 fc71 	bl	8d00 <_free_r>
    841e:	4648      	mov	r0, r9
    8420:	f7ff ffa4 	bl	836c <__malloc_unlock>
    8424:	4638      	mov	r0, r7
    8426:	b003      	add	sp, #12
    8428:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    842c:	f025 0507 	bic.w	r5, r5, #7
    8430:	2d00      	cmp	r5, #0
    8432:	462a      	mov	r2, r5
    8434:	dabb      	bge.n	83ae <_realloc_r+0x2e>
    8436:	230c      	movs	r3, #12
    8438:	2000      	movs	r0, #0
    843a:	f8c9 3000 	str.w	r3, [r9]
    843e:	b003      	add	sp, #12
    8440:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8444:	f856 3c08 	ldr.w	r3, [r6, #-8]
    8448:	ebc3 0a08 	rsb	sl, r3, r8
    844c:	f8da 3004 	ldr.w	r3, [sl, #4]
    8450:	f023 0c03 	bic.w	ip, r3, #3
    8454:	eb04 030c 	add.w	r3, r4, ip
    8458:	4293      	cmp	r3, r2
    845a:	dbbd      	blt.n	83d8 <_realloc_r+0x58>
    845c:	4657      	mov	r7, sl
    845e:	f8da 100c 	ldr.w	r1, [sl, #12]
    8462:	f857 0f08 	ldr.w	r0, [r7, #8]!
    8466:	1f22      	subs	r2, r4, #4
    8468:	2a24      	cmp	r2, #36	; 0x24
    846a:	60c1      	str	r1, [r0, #12]
    846c:	6088      	str	r0, [r1, #8]
    846e:	f200 8117 	bhi.w	86a0 <_realloc_r+0x320>
    8472:	2a13      	cmp	r2, #19
    8474:	f240 8112 	bls.w	869c <_realloc_r+0x31c>
    8478:	6831      	ldr	r1, [r6, #0]
    847a:	f8ca 1008 	str.w	r1, [sl, #8]
    847e:	6871      	ldr	r1, [r6, #4]
    8480:	f8ca 100c 	str.w	r1, [sl, #12]
    8484:	2a1b      	cmp	r2, #27
    8486:	f200 812b 	bhi.w	86e0 <_realloc_r+0x360>
    848a:	3608      	adds	r6, #8
    848c:	f10a 0210 	add.w	r2, sl, #16
    8490:	6831      	ldr	r1, [r6, #0]
    8492:	6011      	str	r1, [r2, #0]
    8494:	6871      	ldr	r1, [r6, #4]
    8496:	6051      	str	r1, [r2, #4]
    8498:	68b1      	ldr	r1, [r6, #8]
    849a:	6091      	str	r1, [r2, #8]
    849c:	463e      	mov	r6, r7
    849e:	461c      	mov	r4, r3
    84a0:	46d0      	mov	r8, sl
    84a2:	1b63      	subs	r3, r4, r5
    84a4:	2b0f      	cmp	r3, #15
    84a6:	d81d      	bhi.n	84e4 <_realloc_r+0x164>
    84a8:	f8d8 3004 	ldr.w	r3, [r8, #4]
    84ac:	f003 0301 	and.w	r3, r3, #1
    84b0:	4323      	orrs	r3, r4
    84b2:	4444      	add	r4, r8
    84b4:	f8c8 3004 	str.w	r3, [r8, #4]
    84b8:	6863      	ldr	r3, [r4, #4]
    84ba:	f043 0301 	orr.w	r3, r3, #1
    84be:	6063      	str	r3, [r4, #4]
    84c0:	4648      	mov	r0, r9
    84c2:	f7ff ff53 	bl	836c <__malloc_unlock>
    84c6:	4630      	mov	r0, r6
    84c8:	b003      	add	sp, #12
    84ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    84ce:	f021 0103 	bic.w	r1, r1, #3
    84d2:	4421      	add	r1, r4
    84d4:	4291      	cmp	r1, r2
    84d6:	db21      	blt.n	851c <_realloc_r+0x19c>
    84d8:	68c3      	ldr	r3, [r0, #12]
    84da:	6882      	ldr	r2, [r0, #8]
    84dc:	460c      	mov	r4, r1
    84de:	60d3      	str	r3, [r2, #12]
    84e0:	609a      	str	r2, [r3, #8]
    84e2:	e7de      	b.n	84a2 <_realloc_r+0x122>
    84e4:	f8d8 2004 	ldr.w	r2, [r8, #4]
    84e8:	eb08 0105 	add.w	r1, r8, r5
    84ec:	f002 0201 	and.w	r2, r2, #1
    84f0:	4315      	orrs	r5, r2
    84f2:	f043 0201 	orr.w	r2, r3, #1
    84f6:	440b      	add	r3, r1
    84f8:	f8c8 5004 	str.w	r5, [r8, #4]
    84fc:	604a      	str	r2, [r1, #4]
    84fe:	685a      	ldr	r2, [r3, #4]
    8500:	f042 0201 	orr.w	r2, r2, #1
    8504:	3108      	adds	r1, #8
    8506:	605a      	str	r2, [r3, #4]
    8508:	4648      	mov	r0, r9
    850a:	f000 fbf9 	bl	8d00 <_free_r>
    850e:	e7d7      	b.n	84c0 <_realloc_r+0x140>
    8510:	4611      	mov	r1, r2
    8512:	b003      	add	sp, #12
    8514:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8518:	f7ff bbbc 	b.w	7c94 <_malloc_r>
    851c:	f01e 0f01 	tst.w	lr, #1
    8520:	f47f af5a 	bne.w	83d8 <_realloc_r+0x58>
    8524:	f856 3c08 	ldr.w	r3, [r6, #-8]
    8528:	ebc3 0a08 	rsb	sl, r3, r8
    852c:	f8da 3004 	ldr.w	r3, [sl, #4]
    8530:	f023 0c03 	bic.w	ip, r3, #3
    8534:	eb01 0e0c 	add.w	lr, r1, ip
    8538:	4596      	cmp	lr, r2
    853a:	db8b      	blt.n	8454 <_realloc_r+0xd4>
    853c:	68c3      	ldr	r3, [r0, #12]
    853e:	6882      	ldr	r2, [r0, #8]
    8540:	4657      	mov	r7, sl
    8542:	60d3      	str	r3, [r2, #12]
    8544:	609a      	str	r2, [r3, #8]
    8546:	f857 1f08 	ldr.w	r1, [r7, #8]!
    854a:	f8da 300c 	ldr.w	r3, [sl, #12]
    854e:	60cb      	str	r3, [r1, #12]
    8550:	1f22      	subs	r2, r4, #4
    8552:	2a24      	cmp	r2, #36	; 0x24
    8554:	6099      	str	r1, [r3, #8]
    8556:	f200 8099 	bhi.w	868c <_realloc_r+0x30c>
    855a:	2a13      	cmp	r2, #19
    855c:	d962      	bls.n	8624 <_realloc_r+0x2a4>
    855e:	6833      	ldr	r3, [r6, #0]
    8560:	f8ca 3008 	str.w	r3, [sl, #8]
    8564:	6873      	ldr	r3, [r6, #4]
    8566:	f8ca 300c 	str.w	r3, [sl, #12]
    856a:	2a1b      	cmp	r2, #27
    856c:	f200 80a0 	bhi.w	86b0 <_realloc_r+0x330>
    8570:	3608      	adds	r6, #8
    8572:	f10a 0310 	add.w	r3, sl, #16
    8576:	e056      	b.n	8626 <_realloc_r+0x2a6>
    8578:	f021 0b03 	bic.w	fp, r1, #3
    857c:	44a3      	add	fp, r4
    857e:	f105 0010 	add.w	r0, r5, #16
    8582:	4583      	cmp	fp, r0
    8584:	da59      	bge.n	863a <_realloc_r+0x2ba>
    8586:	f01e 0f01 	tst.w	lr, #1
    858a:	f47f af25 	bne.w	83d8 <_realloc_r+0x58>
    858e:	f856 1c08 	ldr.w	r1, [r6, #-8]
    8592:	ebc1 0a08 	rsb	sl, r1, r8
    8596:	f8da 1004 	ldr.w	r1, [sl, #4]
    859a:	f021 0c03 	bic.w	ip, r1, #3
    859e:	44e3      	add	fp, ip
    85a0:	4558      	cmp	r0, fp
    85a2:	f73f af57 	bgt.w	8454 <_realloc_r+0xd4>
    85a6:	4657      	mov	r7, sl
    85a8:	f8da 100c 	ldr.w	r1, [sl, #12]
    85ac:	f857 0f08 	ldr.w	r0, [r7, #8]!
    85b0:	1f22      	subs	r2, r4, #4
    85b2:	2a24      	cmp	r2, #36	; 0x24
    85b4:	60c1      	str	r1, [r0, #12]
    85b6:	6088      	str	r0, [r1, #8]
    85b8:	f200 80b4 	bhi.w	8724 <_realloc_r+0x3a4>
    85bc:	2a13      	cmp	r2, #19
    85be:	f240 80a5 	bls.w	870c <_realloc_r+0x38c>
    85c2:	6831      	ldr	r1, [r6, #0]
    85c4:	f8ca 1008 	str.w	r1, [sl, #8]
    85c8:	6871      	ldr	r1, [r6, #4]
    85ca:	f8ca 100c 	str.w	r1, [sl, #12]
    85ce:	2a1b      	cmp	r2, #27
    85d0:	f200 80af 	bhi.w	8732 <_realloc_r+0x3b2>
    85d4:	3608      	adds	r6, #8
    85d6:	f10a 0210 	add.w	r2, sl, #16
    85da:	6831      	ldr	r1, [r6, #0]
    85dc:	6011      	str	r1, [r2, #0]
    85de:	6871      	ldr	r1, [r6, #4]
    85e0:	6051      	str	r1, [r2, #4]
    85e2:	68b1      	ldr	r1, [r6, #8]
    85e4:	6091      	str	r1, [r2, #8]
    85e6:	eb0a 0105 	add.w	r1, sl, r5
    85ea:	ebc5 020b 	rsb	r2, r5, fp
    85ee:	f042 0201 	orr.w	r2, r2, #1
    85f2:	6099      	str	r1, [r3, #8]
    85f4:	604a      	str	r2, [r1, #4]
    85f6:	f8da 3004 	ldr.w	r3, [sl, #4]
    85fa:	f003 0301 	and.w	r3, r3, #1
    85fe:	431d      	orrs	r5, r3
    8600:	4648      	mov	r0, r9
    8602:	f8ca 5004 	str.w	r5, [sl, #4]
    8606:	f7ff feb1 	bl	836c <__malloc_unlock>
    860a:	4638      	mov	r0, r7
    860c:	e75c      	b.n	84c8 <_realloc_r+0x148>
    860e:	6833      	ldr	r3, [r6, #0]
    8610:	6003      	str	r3, [r0, #0]
    8612:	6873      	ldr	r3, [r6, #4]
    8614:	6043      	str	r3, [r0, #4]
    8616:	2a1b      	cmp	r2, #27
    8618:	d827      	bhi.n	866a <_realloc_r+0x2ea>
    861a:	f100 0308 	add.w	r3, r0, #8
    861e:	f106 0208 	add.w	r2, r6, #8
    8622:	e6f2      	b.n	840a <_realloc_r+0x8a>
    8624:	463b      	mov	r3, r7
    8626:	6832      	ldr	r2, [r6, #0]
    8628:	601a      	str	r2, [r3, #0]
    862a:	6872      	ldr	r2, [r6, #4]
    862c:	605a      	str	r2, [r3, #4]
    862e:	68b2      	ldr	r2, [r6, #8]
    8630:	609a      	str	r2, [r3, #8]
    8632:	463e      	mov	r6, r7
    8634:	4674      	mov	r4, lr
    8636:	46d0      	mov	r8, sl
    8638:	e733      	b.n	84a2 <_realloc_r+0x122>
    863a:	eb08 0105 	add.w	r1, r8, r5
    863e:	ebc5 0b0b 	rsb	fp, r5, fp
    8642:	f04b 0201 	orr.w	r2, fp, #1
    8646:	6099      	str	r1, [r3, #8]
    8648:	604a      	str	r2, [r1, #4]
    864a:	f856 3c04 	ldr.w	r3, [r6, #-4]
    864e:	f003 0301 	and.w	r3, r3, #1
    8652:	431d      	orrs	r5, r3
    8654:	4648      	mov	r0, r9
    8656:	f846 5c04 	str.w	r5, [r6, #-4]
    865a:	f7ff fe87 	bl	836c <__malloc_unlock>
    865e:	4630      	mov	r0, r6
    8660:	e732      	b.n	84c8 <_realloc_r+0x148>
    8662:	4631      	mov	r1, r6
    8664:	f7ff fdce 	bl	8204 <memmove>
    8668:	e6d5      	b.n	8416 <_realloc_r+0x96>
    866a:	68b3      	ldr	r3, [r6, #8]
    866c:	6083      	str	r3, [r0, #8]
    866e:	68f3      	ldr	r3, [r6, #12]
    8670:	60c3      	str	r3, [r0, #12]
    8672:	2a24      	cmp	r2, #36	; 0x24
    8674:	d028      	beq.n	86c8 <_realloc_r+0x348>
    8676:	f100 0310 	add.w	r3, r0, #16
    867a:	f106 0210 	add.w	r2, r6, #16
    867e:	e6c4      	b.n	840a <_realloc_r+0x8a>
    8680:	f850 3c04 	ldr.w	r3, [r0, #-4]
    8684:	f023 0303 	bic.w	r3, r3, #3
    8688:	441c      	add	r4, r3
    868a:	e70a      	b.n	84a2 <_realloc_r+0x122>
    868c:	4631      	mov	r1, r6
    868e:	4638      	mov	r0, r7
    8690:	4674      	mov	r4, lr
    8692:	46d0      	mov	r8, sl
    8694:	f7ff fdb6 	bl	8204 <memmove>
    8698:	463e      	mov	r6, r7
    869a:	e702      	b.n	84a2 <_realloc_r+0x122>
    869c:	463a      	mov	r2, r7
    869e:	e6f7      	b.n	8490 <_realloc_r+0x110>
    86a0:	4631      	mov	r1, r6
    86a2:	4638      	mov	r0, r7
    86a4:	461c      	mov	r4, r3
    86a6:	46d0      	mov	r8, sl
    86a8:	f7ff fdac 	bl	8204 <memmove>
    86ac:	463e      	mov	r6, r7
    86ae:	e6f8      	b.n	84a2 <_realloc_r+0x122>
    86b0:	68b3      	ldr	r3, [r6, #8]
    86b2:	f8ca 3010 	str.w	r3, [sl, #16]
    86b6:	68f3      	ldr	r3, [r6, #12]
    86b8:	f8ca 3014 	str.w	r3, [sl, #20]
    86bc:	2a24      	cmp	r2, #36	; 0x24
    86be:	d01b      	beq.n	86f8 <_realloc_r+0x378>
    86c0:	3610      	adds	r6, #16
    86c2:	f10a 0318 	add.w	r3, sl, #24
    86c6:	e7ae      	b.n	8626 <_realloc_r+0x2a6>
    86c8:	6933      	ldr	r3, [r6, #16]
    86ca:	6103      	str	r3, [r0, #16]
    86cc:	6973      	ldr	r3, [r6, #20]
    86ce:	6143      	str	r3, [r0, #20]
    86d0:	f106 0218 	add.w	r2, r6, #24
    86d4:	f100 0318 	add.w	r3, r0, #24
    86d8:	e697      	b.n	840a <_realloc_r+0x8a>
    86da:	bf00      	nop
    86dc:	1fff100c 	.word	0x1fff100c
    86e0:	68b1      	ldr	r1, [r6, #8]
    86e2:	f8ca 1010 	str.w	r1, [sl, #16]
    86e6:	68f1      	ldr	r1, [r6, #12]
    86e8:	f8ca 1014 	str.w	r1, [sl, #20]
    86ec:	2a24      	cmp	r2, #36	; 0x24
    86ee:	d00f      	beq.n	8710 <_realloc_r+0x390>
    86f0:	3610      	adds	r6, #16
    86f2:	f10a 0218 	add.w	r2, sl, #24
    86f6:	e6cb      	b.n	8490 <_realloc_r+0x110>
    86f8:	6933      	ldr	r3, [r6, #16]
    86fa:	f8ca 3018 	str.w	r3, [sl, #24]
    86fe:	6973      	ldr	r3, [r6, #20]
    8700:	f8ca 301c 	str.w	r3, [sl, #28]
    8704:	3618      	adds	r6, #24
    8706:	f10a 0320 	add.w	r3, sl, #32
    870a:	e78c      	b.n	8626 <_realloc_r+0x2a6>
    870c:	463a      	mov	r2, r7
    870e:	e764      	b.n	85da <_realloc_r+0x25a>
    8710:	6932      	ldr	r2, [r6, #16]
    8712:	f8ca 2018 	str.w	r2, [sl, #24]
    8716:	6972      	ldr	r2, [r6, #20]
    8718:	f8ca 201c 	str.w	r2, [sl, #28]
    871c:	3618      	adds	r6, #24
    871e:	f10a 0220 	add.w	r2, sl, #32
    8722:	e6b5      	b.n	8490 <_realloc_r+0x110>
    8724:	4631      	mov	r1, r6
    8726:	4638      	mov	r0, r7
    8728:	9301      	str	r3, [sp, #4]
    872a:	f7ff fd6b 	bl	8204 <memmove>
    872e:	9b01      	ldr	r3, [sp, #4]
    8730:	e759      	b.n	85e6 <_realloc_r+0x266>
    8732:	68b1      	ldr	r1, [r6, #8]
    8734:	f8ca 1010 	str.w	r1, [sl, #16]
    8738:	68f1      	ldr	r1, [r6, #12]
    873a:	f8ca 1014 	str.w	r1, [sl, #20]
    873e:	2a24      	cmp	r2, #36	; 0x24
    8740:	d003      	beq.n	874a <_realloc_r+0x3ca>
    8742:	3610      	adds	r6, #16
    8744:	f10a 0218 	add.w	r2, sl, #24
    8748:	e747      	b.n	85da <_realloc_r+0x25a>
    874a:	6932      	ldr	r2, [r6, #16]
    874c:	f8ca 2018 	str.w	r2, [sl, #24]
    8750:	6972      	ldr	r2, [r6, #20]
    8752:	f8ca 201c 	str.w	r2, [sl, #28]
    8756:	3618      	adds	r6, #24
    8758:	f10a 0220 	add.w	r2, sl, #32
    875c:	e73d      	b.n	85da <_realloc_r+0x25a>
    875e:	bf00      	nop

00008760 <_sbrk_r>:
    8760:	b538      	push	{r3, r4, r5, lr}
    8762:	4c07      	ldr	r4, [pc, #28]	; (8780 <_sbrk_r+0x20>)
    8764:	2300      	movs	r3, #0
    8766:	4605      	mov	r5, r0
    8768:	4608      	mov	r0, r1
    876a:	6023      	str	r3, [r4, #0]
    876c:	f7fd f826 	bl	57bc <_sbrk>
    8770:	1c43      	adds	r3, r0, #1
    8772:	d000      	beq.n	8776 <_sbrk_r+0x16>
    8774:	bd38      	pop	{r3, r4, r5, pc}
    8776:	6823      	ldr	r3, [r4, #0]
    8778:	2b00      	cmp	r3, #0
    877a:	d0fb      	beq.n	8774 <_sbrk_r+0x14>
    877c:	602b      	str	r3, [r5, #0]
    877e:	bd38      	pop	{r3, r4, r5, pc}
    8780:	1fff2c5c 	.word	0x1fff2c5c
    8784:	ffffffff 	.word	0xffffffff
    8788:	ffffffff 	.word	0xffffffff
    878c:	ffffffff 	.word	0xffffffff
    8790:	ffffffff 	.word	0xffffffff
    8794:	ffffffff 	.word	0xffffffff
    8798:	ffffffff 	.word	0xffffffff
    879c:	ffffffff 	.word	0xffffffff
    87a0:	eba2 0003 	sub.w	r0, r2, r3
    87a4:	4770      	bx	lr
    87a6:	bf00      	nop

000087a8 <strcmp>:
    87a8:	7802      	ldrb	r2, [r0, #0]
    87aa:	780b      	ldrb	r3, [r1, #0]
    87ac:	2a01      	cmp	r2, #1
    87ae:	bf28      	it	cs
    87b0:	429a      	cmpcs	r2, r3
    87b2:	d1f5      	bne.n	87a0 <_sbrk_r+0x40>
    87b4:	e96d 4504 	strd	r4, r5, [sp, #-16]!
    87b8:	ea40 0401 	orr.w	r4, r0, r1
    87bc:	e9cd 6702 	strd	r6, r7, [sp, #8]
    87c0:	f06f 0c00 	mvn.w	ip, #0
    87c4:	ea4f 7244 	mov.w	r2, r4, lsl #29
    87c8:	b312      	cbz	r2, 8810 <strcmp+0x68>
    87ca:	ea80 0401 	eor.w	r4, r0, r1
    87ce:	f014 0f07 	tst.w	r4, #7
    87d2:	d16a      	bne.n	88aa <strcmp+0x102>
    87d4:	f000 0407 	and.w	r4, r0, #7
    87d8:	f020 0007 	bic.w	r0, r0, #7
    87dc:	f004 0503 	and.w	r5, r4, #3
    87e0:	f021 0107 	bic.w	r1, r1, #7
    87e4:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    87e8:	e8f0 2304 	ldrd	r2, r3, [r0], #16
    87ec:	f014 0f04 	tst.w	r4, #4
    87f0:	e8f1 6704 	ldrd	r6, r7, [r1], #16
    87f4:	fa0c f405 	lsl.w	r4, ip, r5
    87f8:	ea62 0204 	orn	r2, r2, r4
    87fc:	ea66 0604 	orn	r6, r6, r4
    8800:	d00a      	beq.n	8818 <strcmp+0x70>
    8802:	ea63 0304 	orn	r3, r3, r4
    8806:	4662      	mov	r2, ip
    8808:	ea67 0704 	orn	r7, r7, r4
    880c:	4666      	mov	r6, ip
    880e:	e003      	b.n	8818 <strcmp+0x70>
    8810:	e8f0 2304 	ldrd	r2, r3, [r0], #16
    8814:	e8f1 6704 	ldrd	r6, r7, [r1], #16
    8818:	fa82 f54c 	uadd8	r5, r2, ip
    881c:	ea82 0406 	eor.w	r4, r2, r6
    8820:	faa4 f48c 	sel	r4, r4, ip
    8824:	bb6c      	cbnz	r4, 8882 <strcmp+0xda>
    8826:	fa83 f54c 	uadd8	r5, r3, ip
    882a:	ea83 0507 	eor.w	r5, r3, r7
    882e:	faa5 f58c 	sel	r5, r5, ip
    8832:	b995      	cbnz	r5, 885a <strcmp+0xb2>
    8834:	e950 2302 	ldrd	r2, r3, [r0, #-8]
    8838:	e951 6702 	ldrd	r6, r7, [r1, #-8]
    883c:	fa82 f54c 	uadd8	r5, r2, ip
    8840:	ea82 0406 	eor.w	r4, r2, r6
    8844:	faa4 f48c 	sel	r4, r4, ip
    8848:	fa83 f54c 	uadd8	r5, r3, ip
    884c:	ea83 0507 	eor.w	r5, r3, r7
    8850:	faa5 f58c 	sel	r5, r5, ip
    8854:	4325      	orrs	r5, r4
    8856:	d0db      	beq.n	8810 <strcmp+0x68>
    8858:	b99c      	cbnz	r4, 8882 <strcmp+0xda>
    885a:	ba2d      	rev	r5, r5
    885c:	fab5 f485 	clz	r4, r5
    8860:	f024 0407 	bic.w	r4, r4, #7
    8864:	fa27 f104 	lsr.w	r1, r7, r4
    8868:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    886c:	fa23 f304 	lsr.w	r3, r3, r4
    8870:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    8874:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    8878:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    887c:	eba0 0001 	sub.w	r0, r0, r1
    8880:	4770      	bx	lr
    8882:	ba24      	rev	r4, r4
    8884:	fab4 f484 	clz	r4, r4
    8888:	f024 0407 	bic.w	r4, r4, #7
    888c:	fa26 f104 	lsr.w	r1, r6, r4
    8890:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    8894:	fa22 f204 	lsr.w	r2, r2, r4
    8898:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    889c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    88a0:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    88a4:	eba0 0001 	sub.w	r0, r0, r1
    88a8:	4770      	bx	lr
    88aa:	f014 0f03 	tst.w	r4, #3
    88ae:	d13c      	bne.n	892a <strcmp+0x182>
    88b0:	f010 0403 	ands.w	r4, r0, #3
    88b4:	d128      	bne.n	8908 <strcmp+0x160>
    88b6:	f850 2b08 	ldr.w	r2, [r0], #8
    88ba:	f851 3b08 	ldr.w	r3, [r1], #8
    88be:	fa82 f54c 	uadd8	r5, r2, ip
    88c2:	ea82 0503 	eor.w	r5, r2, r3
    88c6:	faa5 f58c 	sel	r5, r5, ip
    88ca:	b95d      	cbnz	r5, 88e4 <strcmp+0x13c>
    88cc:	f850 2c04 	ldr.w	r2, [r0, #-4]
    88d0:	f851 3c04 	ldr.w	r3, [r1, #-4]
    88d4:	fa82 f54c 	uadd8	r5, r2, ip
    88d8:	ea82 0503 	eor.w	r5, r2, r3
    88dc:	faa5 f58c 	sel	r5, r5, ip
    88e0:	2d00      	cmp	r5, #0
    88e2:	d0e8      	beq.n	88b6 <strcmp+0x10e>
    88e4:	ba2d      	rev	r5, r5
    88e6:	fab5 f485 	clz	r4, r5
    88ea:	f024 0407 	bic.w	r4, r4, #7
    88ee:	fa23 f104 	lsr.w	r1, r3, r4
    88f2:	fa22 f204 	lsr.w	r2, r2, r4
    88f6:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    88fa:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    88fe:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    8902:	eba0 0001 	sub.w	r0, r0, r1
    8906:	4770      	bx	lr
    8908:	ea4f 04c4 	mov.w	r4, r4, lsl #3
    890c:	f020 0003 	bic.w	r0, r0, #3
    8910:	f850 2b08 	ldr.w	r2, [r0], #8
    8914:	f021 0103 	bic.w	r1, r1, #3
    8918:	f851 3b08 	ldr.w	r3, [r1], #8
    891c:	fa0c f404 	lsl.w	r4, ip, r4
    8920:	ea62 0204 	orn	r2, r2, r4
    8924:	ea63 0304 	orn	r3, r3, r4
    8928:	e7c9      	b.n	88be <strcmp+0x116>
    892a:	f010 0403 	ands.w	r4, r0, #3
    892e:	d01a      	beq.n	8966 <strcmp+0x1be>
    8930:	eba1 0104 	sub.w	r1, r1, r4
    8934:	f020 0003 	bic.w	r0, r0, #3
    8938:	07e4      	lsls	r4, r4, #31
    893a:	f850 2b04 	ldr.w	r2, [r0], #4
    893e:	d006      	beq.n	894e <strcmp+0x1a6>
    8940:	d20f      	bcs.n	8962 <strcmp+0x1ba>
    8942:	788b      	ldrb	r3, [r1, #2]
    8944:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
    8948:	1ae4      	subs	r4, r4, r3
    894a:	d106      	bne.n	895a <strcmp+0x1b2>
    894c:	b12b      	cbz	r3, 895a <strcmp+0x1b2>
    894e:	78cb      	ldrb	r3, [r1, #3]
    8950:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
    8954:	1ae4      	subs	r4, r4, r3
    8956:	d100      	bne.n	895a <strcmp+0x1b2>
    8958:	b91b      	cbnz	r3, 8962 <strcmp+0x1ba>
    895a:	4620      	mov	r0, r4
    895c:	f85d 4b10 	ldr.w	r4, [sp], #16
    8960:	4770      	bx	lr
    8962:	f101 0104 	add.w	r1, r1, #4
    8966:	f850 2b04 	ldr.w	r2, [r0], #4
    896a:	07cc      	lsls	r4, r1, #31
    896c:	f021 0103 	bic.w	r1, r1, #3
    8970:	f851 3b04 	ldr.w	r3, [r1], #4
    8974:	d848      	bhi.n	8a08 <strcmp+0x260>
    8976:	d224      	bcs.n	89c2 <strcmp+0x21a>
    8978:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
    897c:	fa82 f54c 	uadd8	r5, r2, ip
    8980:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
    8984:	faa5 f58c 	sel	r5, r5, ip
    8988:	d10a      	bne.n	89a0 <strcmp+0x1f8>
    898a:	b965      	cbnz	r5, 89a6 <strcmp+0x1fe>
    898c:	f851 3b04 	ldr.w	r3, [r1], #4
    8990:	ea84 0402 	eor.w	r4, r4, r2
    8994:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
    8998:	d10e      	bne.n	89b8 <strcmp+0x210>
    899a:	f850 2b04 	ldr.w	r2, [r0], #4
    899e:	e7eb      	b.n	8978 <strcmp+0x1d0>
    89a0:	ea4f 2313 	mov.w	r3, r3, lsr #8
    89a4:	e055      	b.n	8a52 <strcmp+0x2aa>
    89a6:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
    89aa:	d14d      	bne.n	8a48 <strcmp+0x2a0>
    89ac:	7808      	ldrb	r0, [r1, #0]
    89ae:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    89b2:	f1c0 0000 	rsb	r0, r0, #0
    89b6:	4770      	bx	lr
    89b8:	ea4f 6212 	mov.w	r2, r2, lsr #24
    89bc:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    89c0:	e047      	b.n	8a52 <strcmp+0x2aa>
    89c2:	ea02 441c 	and.w	r4, r2, ip, lsr #16
    89c6:	fa82 f54c 	uadd8	r5, r2, ip
    89ca:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
    89ce:	faa5 f58c 	sel	r5, r5, ip
    89d2:	d10a      	bne.n	89ea <strcmp+0x242>
    89d4:	b965      	cbnz	r5, 89f0 <strcmp+0x248>
    89d6:	f851 3b04 	ldr.w	r3, [r1], #4
    89da:	ea84 0402 	eor.w	r4, r4, r2
    89de:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
    89e2:	d10c      	bne.n	89fe <strcmp+0x256>
    89e4:	f850 2b04 	ldr.w	r2, [r0], #4
    89e8:	e7eb      	b.n	89c2 <strcmp+0x21a>
    89ea:	ea4f 4313 	mov.w	r3, r3, lsr #16
    89ee:	e030      	b.n	8a52 <strcmp+0x2aa>
    89f0:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
    89f4:	d128      	bne.n	8a48 <strcmp+0x2a0>
    89f6:	880b      	ldrh	r3, [r1, #0]
    89f8:	ea4f 4212 	mov.w	r2, r2, lsr #16
    89fc:	e029      	b.n	8a52 <strcmp+0x2aa>
    89fe:	ea4f 4212 	mov.w	r2, r2, lsr #16
    8a02:	ea03 431c 	and.w	r3, r3, ip, lsr #16
    8a06:	e024      	b.n	8a52 <strcmp+0x2aa>
    8a08:	f002 04ff 	and.w	r4, r2, #255	; 0xff
    8a0c:	fa82 f54c 	uadd8	r5, r2, ip
    8a10:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
    8a14:	faa5 f58c 	sel	r5, r5, ip
    8a18:	d10a      	bne.n	8a30 <strcmp+0x288>
    8a1a:	b965      	cbnz	r5, 8a36 <strcmp+0x28e>
    8a1c:	f851 3b04 	ldr.w	r3, [r1], #4
    8a20:	ea84 0402 	eor.w	r4, r4, r2
    8a24:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
    8a28:	d109      	bne.n	8a3e <strcmp+0x296>
    8a2a:	f850 2b04 	ldr.w	r2, [r0], #4
    8a2e:	e7eb      	b.n	8a08 <strcmp+0x260>
    8a30:	ea4f 6313 	mov.w	r3, r3, lsr #24
    8a34:	e00d      	b.n	8a52 <strcmp+0x2aa>
    8a36:	f015 0fff 	tst.w	r5, #255	; 0xff
    8a3a:	d105      	bne.n	8a48 <strcmp+0x2a0>
    8a3c:	680b      	ldr	r3, [r1, #0]
    8a3e:	ea4f 2212 	mov.w	r2, r2, lsr #8
    8a42:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    8a46:	e004      	b.n	8a52 <strcmp+0x2aa>
    8a48:	f04f 0000 	mov.w	r0, #0
    8a4c:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    8a50:	4770      	bx	lr
    8a52:	ba12      	rev	r2, r2
    8a54:	ba1b      	rev	r3, r3
    8a56:	fa82 f44c 	uadd8	r4, r2, ip
    8a5a:	ea82 0403 	eor.w	r4, r2, r3
    8a5e:	faa4 f58c 	sel	r5, r4, ip
    8a62:	fab5 f485 	clz	r4, r5
    8a66:	fa02 f204 	lsl.w	r2, r2, r4
    8a6a:	fa03 f304 	lsl.w	r3, r3, r4
    8a6e:	ea4f 6012 	mov.w	r0, r2, lsr #24
    8a72:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    8a76:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
    8a7a:	4770      	bx	lr

00008a7c <strcpy>:
    8a7c:	ea80 0201 	eor.w	r2, r0, r1
    8a80:	4684      	mov	ip, r0
    8a82:	f012 0f03 	tst.w	r2, #3
    8a86:	d14f      	bne.n	8b28 <strcpy+0xac>
    8a88:	f011 0f03 	tst.w	r1, #3
    8a8c:	d132      	bne.n	8af4 <strcpy+0x78>
    8a8e:	f84d 4d04 	str.w	r4, [sp, #-4]!
    8a92:	f011 0f04 	tst.w	r1, #4
    8a96:	f851 3b04 	ldr.w	r3, [r1], #4
    8a9a:	d00b      	beq.n	8ab4 <strcpy+0x38>
    8a9c:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    8aa0:	439a      	bics	r2, r3
    8aa2:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    8aa6:	bf04      	itt	eq
    8aa8:	f84c 3b04 	streq.w	r3, [ip], #4
    8aac:	f851 3b04 	ldreq.w	r3, [r1], #4
    8ab0:	d116      	bne.n	8ae0 <strcpy+0x64>
    8ab2:	bf00      	nop
    8ab4:	f851 4b04 	ldr.w	r4, [r1], #4
    8ab8:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    8abc:	439a      	bics	r2, r3
    8abe:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    8ac2:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
    8ac6:	d10b      	bne.n	8ae0 <strcpy+0x64>
    8ac8:	f84c 3b04 	str.w	r3, [ip], #4
    8acc:	43a2      	bics	r2, r4
    8ace:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    8ad2:	bf04      	itt	eq
    8ad4:	f851 3b04 	ldreq.w	r3, [r1], #4
    8ad8:	f84c 4b04 	streq.w	r4, [ip], #4
    8adc:	d0ea      	beq.n	8ab4 <strcpy+0x38>
    8ade:	4623      	mov	r3, r4
    8ae0:	f80c 3b01 	strb.w	r3, [ip], #1
    8ae4:	f013 0fff 	tst.w	r3, #255	; 0xff
    8ae8:	ea4f 2333 	mov.w	r3, r3, ror #8
    8aec:	d1f8      	bne.n	8ae0 <strcpy+0x64>
    8aee:	f85d 4b04 	ldr.w	r4, [sp], #4
    8af2:	4770      	bx	lr
    8af4:	f011 0f01 	tst.w	r1, #1
    8af8:	d006      	beq.n	8b08 <strcpy+0x8c>
    8afa:	f811 2b01 	ldrb.w	r2, [r1], #1
    8afe:	f80c 2b01 	strb.w	r2, [ip], #1
    8b02:	2a00      	cmp	r2, #0
    8b04:	bf08      	it	eq
    8b06:	4770      	bxeq	lr
    8b08:	f011 0f02 	tst.w	r1, #2
    8b0c:	d0bf      	beq.n	8a8e <strcpy+0x12>
    8b0e:	f831 2b02 	ldrh.w	r2, [r1], #2
    8b12:	f012 0fff 	tst.w	r2, #255	; 0xff
    8b16:	bf16      	itet	ne
    8b18:	f82c 2b02 	strhne.w	r2, [ip], #2
    8b1c:	f88c 2000 	strbeq.w	r2, [ip]
    8b20:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
    8b24:	d1b3      	bne.n	8a8e <strcpy+0x12>
    8b26:	4770      	bx	lr
    8b28:	f811 2b01 	ldrb.w	r2, [r1], #1
    8b2c:	f80c 2b01 	strb.w	r2, [ip], #1
    8b30:	2a00      	cmp	r2, #0
    8b32:	d1f9      	bne.n	8b28 <strcpy+0xac>
    8b34:	4770      	bx	lr
    8b36:	bf00      	nop
    8b38:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    8b3c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

00008b40 <strlen>:
    8b40:	f890 f000 	pld	[r0]
    8b44:	e96d 4502 	strd	r4, r5, [sp, #-8]!
    8b48:	f020 0107 	bic.w	r1, r0, #7
    8b4c:	f06f 0c00 	mvn.w	ip, #0
    8b50:	f010 0407 	ands.w	r4, r0, #7
    8b54:	f891 f020 	pld	[r1, #32]
    8b58:	f040 8049 	bne.w	8bee <strlen+0xae>
    8b5c:	f04f 0400 	mov.w	r4, #0
    8b60:	f06f 0007 	mvn.w	r0, #7
    8b64:	e9d1 2300 	ldrd	r2, r3, [r1]
    8b68:	f891 f040 	pld	[r1, #64]	; 0x40
    8b6c:	f100 0008 	add.w	r0, r0, #8
    8b70:	fa82 f24c 	uadd8	r2, r2, ip
    8b74:	faa4 f28c 	sel	r2, r4, ip
    8b78:	fa83 f34c 	uadd8	r3, r3, ip
    8b7c:	faa2 f38c 	sel	r3, r2, ip
    8b80:	bb4b      	cbnz	r3, 8bd6 <strlen+0x96>
    8b82:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
    8b86:	fa82 f24c 	uadd8	r2, r2, ip
    8b8a:	f100 0008 	add.w	r0, r0, #8
    8b8e:	faa4 f28c 	sel	r2, r4, ip
    8b92:	fa83 f34c 	uadd8	r3, r3, ip
    8b96:	faa2 f38c 	sel	r3, r2, ip
    8b9a:	b9e3      	cbnz	r3, 8bd6 <strlen+0x96>
    8b9c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
    8ba0:	fa82 f24c 	uadd8	r2, r2, ip
    8ba4:	f100 0008 	add.w	r0, r0, #8
    8ba8:	faa4 f28c 	sel	r2, r4, ip
    8bac:	fa83 f34c 	uadd8	r3, r3, ip
    8bb0:	faa2 f38c 	sel	r3, r2, ip
    8bb4:	b97b      	cbnz	r3, 8bd6 <strlen+0x96>
    8bb6:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
    8bba:	f101 0120 	add.w	r1, r1, #32
    8bbe:	fa82 f24c 	uadd8	r2, r2, ip
    8bc2:	f100 0008 	add.w	r0, r0, #8
    8bc6:	faa4 f28c 	sel	r2, r4, ip
    8bca:	fa83 f34c 	uadd8	r3, r3, ip
    8bce:	faa2 f38c 	sel	r3, r2, ip
    8bd2:	2b00      	cmp	r3, #0
    8bd4:	d0c6      	beq.n	8b64 <strlen+0x24>
    8bd6:	2a00      	cmp	r2, #0
    8bd8:	bf04      	itt	eq
    8bda:	3004      	addeq	r0, #4
    8bdc:	461a      	moveq	r2, r3
    8bde:	ba12      	rev	r2, r2
    8be0:	fab2 f282 	clz	r2, r2
    8be4:	e8fd 4502 	ldrd	r4, r5, [sp], #8
    8be8:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
    8bec:	4770      	bx	lr
    8bee:	e9d1 2300 	ldrd	r2, r3, [r1]
    8bf2:	f004 0503 	and.w	r5, r4, #3
    8bf6:	f1c4 0000 	rsb	r0, r4, #0
    8bfa:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    8bfe:	f014 0f04 	tst.w	r4, #4
    8c02:	f891 f040 	pld	[r1, #64]	; 0x40
    8c06:	fa0c f505 	lsl.w	r5, ip, r5
    8c0a:	ea62 0205 	orn	r2, r2, r5
    8c0e:	bf1c      	itt	ne
    8c10:	ea63 0305 	ornne	r3, r3, r5
    8c14:	4662      	movne	r2, ip
    8c16:	f04f 0400 	mov.w	r4, #0
    8c1a:	e7a9      	b.n	8b70 <strlen+0x30>

00008c1c <register_fini>:
    8c1c:	4b02      	ldr	r3, [pc, #8]	; (8c28 <register_fini+0xc>)
    8c1e:	b113      	cbz	r3, 8c26 <register_fini+0xa>
    8c20:	4802      	ldr	r0, [pc, #8]	; (8c2c <register_fini+0x10>)
    8c22:	f000 b805 	b.w	8c30 <atexit>
    8c26:	4770      	bx	lr
    8c28:	00000000 	.word	0x00000000
    8c2c:	00008c3d 	.word	0x00008c3d

00008c30 <atexit>:
    8c30:	2300      	movs	r3, #0
    8c32:	4601      	mov	r1, r0
    8c34:	461a      	mov	r2, r3
    8c36:	4618      	mov	r0, r3
    8c38:	f000 b94a 	b.w	8ed0 <__register_exitproc>

00008c3c <__libc_fini_array>:
    8c3c:	b538      	push	{r3, r4, r5, lr}
    8c3e:	4d07      	ldr	r5, [pc, #28]	; (8c5c <__libc_fini_array+0x20>)
    8c40:	4c07      	ldr	r4, [pc, #28]	; (8c60 <__libc_fini_array+0x24>)
    8c42:	1b2c      	subs	r4, r5, r4
    8c44:	10a4      	asrs	r4, r4, #2
    8c46:	d005      	beq.n	8c54 <__libc_fini_array+0x18>
    8c48:	3c01      	subs	r4, #1
    8c4a:	f855 3d04 	ldr.w	r3, [r5, #-4]!
    8c4e:	4798      	blx	r3
    8c50:	2c00      	cmp	r4, #0
    8c52:	d1f9      	bne.n	8c48 <__libc_fini_array+0xc>
    8c54:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    8c58:	f000 bd64 	b.w	9724 <__init_array_end>
	...

00008c64 <_malloc_trim_r>:
    8c64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8c66:	4f23      	ldr	r7, [pc, #140]	; (8cf4 <_malloc_trim_r+0x90>)
    8c68:	460c      	mov	r4, r1
    8c6a:	4606      	mov	r6, r0
    8c6c:	f7ff fb7c 	bl	8368 <__malloc_lock>
    8c70:	68bb      	ldr	r3, [r7, #8]
    8c72:	685d      	ldr	r5, [r3, #4]
    8c74:	f025 0503 	bic.w	r5, r5, #3
    8c78:	1b29      	subs	r1, r5, r4
    8c7a:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
    8c7e:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
    8c82:	f021 010f 	bic.w	r1, r1, #15
    8c86:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
    8c8a:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    8c8e:	db07      	blt.n	8ca0 <_malloc_trim_r+0x3c>
    8c90:	2100      	movs	r1, #0
    8c92:	4630      	mov	r0, r6
    8c94:	f7ff fd64 	bl	8760 <_sbrk_r>
    8c98:	68bb      	ldr	r3, [r7, #8]
    8c9a:	442b      	add	r3, r5
    8c9c:	4298      	cmp	r0, r3
    8c9e:	d004      	beq.n	8caa <_malloc_trim_r+0x46>
    8ca0:	4630      	mov	r0, r6
    8ca2:	f7ff fb63 	bl	836c <__malloc_unlock>
    8ca6:	2000      	movs	r0, #0
    8ca8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8caa:	4261      	negs	r1, r4
    8cac:	4630      	mov	r0, r6
    8cae:	f7ff fd57 	bl	8760 <_sbrk_r>
    8cb2:	3001      	adds	r0, #1
    8cb4:	d00d      	beq.n	8cd2 <_malloc_trim_r+0x6e>
    8cb6:	4b10      	ldr	r3, [pc, #64]	; (8cf8 <_malloc_trim_r+0x94>)
    8cb8:	68ba      	ldr	r2, [r7, #8]
    8cba:	6819      	ldr	r1, [r3, #0]
    8cbc:	1b2d      	subs	r5, r5, r4
    8cbe:	f045 0501 	orr.w	r5, r5, #1
    8cc2:	4630      	mov	r0, r6
    8cc4:	1b09      	subs	r1, r1, r4
    8cc6:	6055      	str	r5, [r2, #4]
    8cc8:	6019      	str	r1, [r3, #0]
    8cca:	f7ff fb4f 	bl	836c <__malloc_unlock>
    8cce:	2001      	movs	r0, #1
    8cd0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8cd2:	2100      	movs	r1, #0
    8cd4:	4630      	mov	r0, r6
    8cd6:	f7ff fd43 	bl	8760 <_sbrk_r>
    8cda:	68ba      	ldr	r2, [r7, #8]
    8cdc:	1a83      	subs	r3, r0, r2
    8cde:	2b0f      	cmp	r3, #15
    8ce0:	ddde      	ble.n	8ca0 <_malloc_trim_r+0x3c>
    8ce2:	4c06      	ldr	r4, [pc, #24]	; (8cfc <_malloc_trim_r+0x98>)
    8ce4:	4904      	ldr	r1, [pc, #16]	; (8cf8 <_malloc_trim_r+0x94>)
    8ce6:	6824      	ldr	r4, [r4, #0]
    8ce8:	f043 0301 	orr.w	r3, r3, #1
    8cec:	1b00      	subs	r0, r0, r4
    8cee:	6053      	str	r3, [r2, #4]
    8cf0:	6008      	str	r0, [r1, #0]
    8cf2:	e7d5      	b.n	8ca0 <_malloc_trim_r+0x3c>
    8cf4:	1fff100c 	.word	0x1fff100c
    8cf8:	1fff2c20 	.word	0x1fff2c20
    8cfc:	1fff1418 	.word	0x1fff1418

00008d00 <_free_r>:
    8d00:	2900      	cmp	r1, #0
    8d02:	d045      	beq.n	8d90 <_free_r+0x90>
    8d04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8d08:	460d      	mov	r5, r1
    8d0a:	4680      	mov	r8, r0
    8d0c:	f7ff fb2c 	bl	8368 <__malloc_lock>
    8d10:	f855 7c04 	ldr.w	r7, [r5, #-4]
    8d14:	496a      	ldr	r1, [pc, #424]	; (8ec0 <_free_r+0x1c0>)
    8d16:	f027 0301 	bic.w	r3, r7, #1
    8d1a:	f1a5 0408 	sub.w	r4, r5, #8
    8d1e:	18e2      	adds	r2, r4, r3
    8d20:	688e      	ldr	r6, [r1, #8]
    8d22:	6850      	ldr	r0, [r2, #4]
    8d24:	42b2      	cmp	r2, r6
    8d26:	f020 0003 	bic.w	r0, r0, #3
    8d2a:	d062      	beq.n	8df2 <_free_r+0xf2>
    8d2c:	07fe      	lsls	r6, r7, #31
    8d2e:	6050      	str	r0, [r2, #4]
    8d30:	d40b      	bmi.n	8d4a <_free_r+0x4a>
    8d32:	f855 7c08 	ldr.w	r7, [r5, #-8]
    8d36:	1be4      	subs	r4, r4, r7
    8d38:	f101 0e08 	add.w	lr, r1, #8
    8d3c:	68a5      	ldr	r5, [r4, #8]
    8d3e:	4575      	cmp	r5, lr
    8d40:	443b      	add	r3, r7
    8d42:	d06f      	beq.n	8e24 <_free_r+0x124>
    8d44:	68e7      	ldr	r7, [r4, #12]
    8d46:	60ef      	str	r7, [r5, #12]
    8d48:	60bd      	str	r5, [r7, #8]
    8d4a:	1815      	adds	r5, r2, r0
    8d4c:	686d      	ldr	r5, [r5, #4]
    8d4e:	07ed      	lsls	r5, r5, #31
    8d50:	d542      	bpl.n	8dd8 <_free_r+0xd8>
    8d52:	f043 0201 	orr.w	r2, r3, #1
    8d56:	6062      	str	r2, [r4, #4]
    8d58:	50e3      	str	r3, [r4, r3]
    8d5a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    8d5e:	d218      	bcs.n	8d92 <_free_r+0x92>
    8d60:	08db      	lsrs	r3, r3, #3
    8d62:	1c5a      	adds	r2, r3, #1
    8d64:	684d      	ldr	r5, [r1, #4]
    8d66:	f851 7032 	ldr.w	r7, [r1, r2, lsl #3]
    8d6a:	60a7      	str	r7, [r4, #8]
    8d6c:	2001      	movs	r0, #1
    8d6e:	109b      	asrs	r3, r3, #2
    8d70:	fa00 f303 	lsl.w	r3, r0, r3
    8d74:	eb01 00c2 	add.w	r0, r1, r2, lsl #3
    8d78:	431d      	orrs	r5, r3
    8d7a:	3808      	subs	r0, #8
    8d7c:	60e0      	str	r0, [r4, #12]
    8d7e:	604d      	str	r5, [r1, #4]
    8d80:	f841 4032 	str.w	r4, [r1, r2, lsl #3]
    8d84:	60fc      	str	r4, [r7, #12]
    8d86:	4640      	mov	r0, r8
    8d88:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    8d8c:	f7ff baee 	b.w	836c <__malloc_unlock>
    8d90:	4770      	bx	lr
    8d92:	0a5a      	lsrs	r2, r3, #9
    8d94:	2a04      	cmp	r2, #4
    8d96:	d853      	bhi.n	8e40 <_free_r+0x140>
    8d98:	099a      	lsrs	r2, r3, #6
    8d9a:	f102 0739 	add.w	r7, r2, #57	; 0x39
    8d9e:	007f      	lsls	r7, r7, #1
    8da0:	f102 0538 	add.w	r5, r2, #56	; 0x38
    8da4:	eb01 0087 	add.w	r0, r1, r7, lsl #2
    8da8:	f851 2027 	ldr.w	r2, [r1, r7, lsl #2]
    8dac:	4944      	ldr	r1, [pc, #272]	; (8ec0 <_free_r+0x1c0>)
    8dae:	3808      	subs	r0, #8
    8db0:	4290      	cmp	r0, r2
    8db2:	d04d      	beq.n	8e50 <_free_r+0x150>
    8db4:	6851      	ldr	r1, [r2, #4]
    8db6:	f021 0103 	bic.w	r1, r1, #3
    8dba:	428b      	cmp	r3, r1
    8dbc:	d202      	bcs.n	8dc4 <_free_r+0xc4>
    8dbe:	6892      	ldr	r2, [r2, #8]
    8dc0:	4290      	cmp	r0, r2
    8dc2:	d1f7      	bne.n	8db4 <_free_r+0xb4>
    8dc4:	68d0      	ldr	r0, [r2, #12]
    8dc6:	60e0      	str	r0, [r4, #12]
    8dc8:	60a2      	str	r2, [r4, #8]
    8dca:	6084      	str	r4, [r0, #8]
    8dcc:	60d4      	str	r4, [r2, #12]
    8dce:	4640      	mov	r0, r8
    8dd0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    8dd4:	f7ff baca 	b.w	836c <__malloc_unlock>
    8dd8:	6895      	ldr	r5, [r2, #8]
    8dda:	4f3a      	ldr	r7, [pc, #232]	; (8ec4 <_free_r+0x1c4>)
    8ddc:	42bd      	cmp	r5, r7
    8dde:	4403      	add	r3, r0
    8de0:	d03f      	beq.n	8e62 <_free_r+0x162>
    8de2:	68d0      	ldr	r0, [r2, #12]
    8de4:	60e8      	str	r0, [r5, #12]
    8de6:	f043 0201 	orr.w	r2, r3, #1
    8dea:	6085      	str	r5, [r0, #8]
    8dec:	6062      	str	r2, [r4, #4]
    8dee:	50e3      	str	r3, [r4, r3]
    8df0:	e7b3      	b.n	8d5a <_free_r+0x5a>
    8df2:	07ff      	lsls	r7, r7, #31
    8df4:	4403      	add	r3, r0
    8df6:	d407      	bmi.n	8e08 <_free_r+0x108>
    8df8:	f855 2c08 	ldr.w	r2, [r5, #-8]
    8dfc:	1aa4      	subs	r4, r4, r2
    8dfe:	4413      	add	r3, r2
    8e00:	68a0      	ldr	r0, [r4, #8]
    8e02:	68e2      	ldr	r2, [r4, #12]
    8e04:	60c2      	str	r2, [r0, #12]
    8e06:	6090      	str	r0, [r2, #8]
    8e08:	4a2f      	ldr	r2, [pc, #188]	; (8ec8 <_free_r+0x1c8>)
    8e0a:	6812      	ldr	r2, [r2, #0]
    8e0c:	f043 0001 	orr.w	r0, r3, #1
    8e10:	4293      	cmp	r3, r2
    8e12:	6060      	str	r0, [r4, #4]
    8e14:	608c      	str	r4, [r1, #8]
    8e16:	d3b6      	bcc.n	8d86 <_free_r+0x86>
    8e18:	4b2c      	ldr	r3, [pc, #176]	; (8ecc <_free_r+0x1cc>)
    8e1a:	4640      	mov	r0, r8
    8e1c:	6819      	ldr	r1, [r3, #0]
    8e1e:	f7ff ff21 	bl	8c64 <_malloc_trim_r>
    8e22:	e7b0      	b.n	8d86 <_free_r+0x86>
    8e24:	1811      	adds	r1, r2, r0
    8e26:	6849      	ldr	r1, [r1, #4]
    8e28:	07c9      	lsls	r1, r1, #31
    8e2a:	d444      	bmi.n	8eb6 <_free_r+0x1b6>
    8e2c:	6891      	ldr	r1, [r2, #8]
    8e2e:	68d2      	ldr	r2, [r2, #12]
    8e30:	60ca      	str	r2, [r1, #12]
    8e32:	4403      	add	r3, r0
    8e34:	f043 0001 	orr.w	r0, r3, #1
    8e38:	6091      	str	r1, [r2, #8]
    8e3a:	6060      	str	r0, [r4, #4]
    8e3c:	50e3      	str	r3, [r4, r3]
    8e3e:	e7a2      	b.n	8d86 <_free_r+0x86>
    8e40:	2a14      	cmp	r2, #20
    8e42:	d817      	bhi.n	8e74 <_free_r+0x174>
    8e44:	f102 075c 	add.w	r7, r2, #92	; 0x5c
    8e48:	007f      	lsls	r7, r7, #1
    8e4a:	f102 055b 	add.w	r5, r2, #91	; 0x5b
    8e4e:	e7a9      	b.n	8da4 <_free_r+0xa4>
    8e50:	10aa      	asrs	r2, r5, #2
    8e52:	684b      	ldr	r3, [r1, #4]
    8e54:	2501      	movs	r5, #1
    8e56:	fa05 f202 	lsl.w	r2, r5, r2
    8e5a:	4313      	orrs	r3, r2
    8e5c:	604b      	str	r3, [r1, #4]
    8e5e:	4602      	mov	r2, r0
    8e60:	e7b1      	b.n	8dc6 <_free_r+0xc6>
    8e62:	f043 0201 	orr.w	r2, r3, #1
    8e66:	614c      	str	r4, [r1, #20]
    8e68:	610c      	str	r4, [r1, #16]
    8e6a:	60e5      	str	r5, [r4, #12]
    8e6c:	60a5      	str	r5, [r4, #8]
    8e6e:	6062      	str	r2, [r4, #4]
    8e70:	50e3      	str	r3, [r4, r3]
    8e72:	e788      	b.n	8d86 <_free_r+0x86>
    8e74:	2a54      	cmp	r2, #84	; 0x54
    8e76:	d806      	bhi.n	8e86 <_free_r+0x186>
    8e78:	0b1a      	lsrs	r2, r3, #12
    8e7a:	f102 076f 	add.w	r7, r2, #111	; 0x6f
    8e7e:	007f      	lsls	r7, r7, #1
    8e80:	f102 056e 	add.w	r5, r2, #110	; 0x6e
    8e84:	e78e      	b.n	8da4 <_free_r+0xa4>
    8e86:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    8e8a:	d806      	bhi.n	8e9a <_free_r+0x19a>
    8e8c:	0bda      	lsrs	r2, r3, #15
    8e8e:	f102 0778 	add.w	r7, r2, #120	; 0x78
    8e92:	007f      	lsls	r7, r7, #1
    8e94:	f102 0577 	add.w	r5, r2, #119	; 0x77
    8e98:	e784      	b.n	8da4 <_free_r+0xa4>
    8e9a:	f240 5054 	movw	r0, #1364	; 0x554
    8e9e:	4282      	cmp	r2, r0
    8ea0:	d806      	bhi.n	8eb0 <_free_r+0x1b0>
    8ea2:	0c9a      	lsrs	r2, r3, #18
    8ea4:	f102 077d 	add.w	r7, r2, #125	; 0x7d
    8ea8:	007f      	lsls	r7, r7, #1
    8eaa:	f102 057c 	add.w	r5, r2, #124	; 0x7c
    8eae:	e779      	b.n	8da4 <_free_r+0xa4>
    8eb0:	27fe      	movs	r7, #254	; 0xfe
    8eb2:	257e      	movs	r5, #126	; 0x7e
    8eb4:	e776      	b.n	8da4 <_free_r+0xa4>
    8eb6:	f043 0201 	orr.w	r2, r3, #1
    8eba:	6062      	str	r2, [r4, #4]
    8ebc:	50e3      	str	r3, [r4, r3]
    8ebe:	e762      	b.n	8d86 <_free_r+0x86>
    8ec0:	1fff100c 	.word	0x1fff100c
    8ec4:	1fff1014 	.word	0x1fff1014
    8ec8:	1fff1414 	.word	0x1fff1414
    8ecc:	1fff2c1c 	.word	0x1fff2c1c

00008ed0 <__register_exitproc>:
    8ed0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    8ed4:	4c25      	ldr	r4, [pc, #148]	; (8f6c <__register_exitproc+0x9c>)
    8ed6:	6825      	ldr	r5, [r4, #0]
    8ed8:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
    8edc:	4606      	mov	r6, r0
    8ede:	4688      	mov	r8, r1
    8ee0:	4692      	mov	sl, r2
    8ee2:	4699      	mov	r9, r3
    8ee4:	b3c4      	cbz	r4, 8f58 <__register_exitproc+0x88>
    8ee6:	6860      	ldr	r0, [r4, #4]
    8ee8:	281f      	cmp	r0, #31
    8eea:	dc17      	bgt.n	8f1c <__register_exitproc+0x4c>
    8eec:	1c43      	adds	r3, r0, #1
    8eee:	b176      	cbz	r6, 8f0e <__register_exitproc+0x3e>
    8ef0:	eb04 0580 	add.w	r5, r4, r0, lsl #2
    8ef4:	2201      	movs	r2, #1
    8ef6:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
    8efa:	f8d4 1188 	ldr.w	r1, [r4, #392]	; 0x188
    8efe:	4082      	lsls	r2, r0
    8f00:	4311      	orrs	r1, r2
    8f02:	2e02      	cmp	r6, #2
    8f04:	f8c4 1188 	str.w	r1, [r4, #392]	; 0x188
    8f08:	f8c5 9108 	str.w	r9, [r5, #264]	; 0x108
    8f0c:	d01e      	beq.n	8f4c <__register_exitproc+0x7c>
    8f0e:	3002      	adds	r0, #2
    8f10:	6063      	str	r3, [r4, #4]
    8f12:	f844 8020 	str.w	r8, [r4, r0, lsl #2]
    8f16:	2000      	movs	r0, #0
    8f18:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8f1c:	4b14      	ldr	r3, [pc, #80]	; (8f70 <__register_exitproc+0xa0>)
    8f1e:	b303      	cbz	r3, 8f62 <__register_exitproc+0x92>
    8f20:	f44f 70c8 	mov.w	r0, #400	; 0x190
    8f24:	f7fe fea6 	bl	7c74 <malloc>
    8f28:	4604      	mov	r4, r0
    8f2a:	b1d0      	cbz	r0, 8f62 <__register_exitproc+0x92>
    8f2c:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
    8f30:	2700      	movs	r7, #0
    8f32:	e880 0088 	stmia.w	r0, {r3, r7}
    8f36:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    8f3a:	4638      	mov	r0, r7
    8f3c:	2301      	movs	r3, #1
    8f3e:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
    8f42:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
    8f46:	2e00      	cmp	r6, #0
    8f48:	d0e1      	beq.n	8f0e <__register_exitproc+0x3e>
    8f4a:	e7d1      	b.n	8ef0 <__register_exitproc+0x20>
    8f4c:	f8d4 118c 	ldr.w	r1, [r4, #396]	; 0x18c
    8f50:	430a      	orrs	r2, r1
    8f52:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
    8f56:	e7da      	b.n	8f0e <__register_exitproc+0x3e>
    8f58:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
    8f5c:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    8f60:	e7c1      	b.n	8ee6 <__register_exitproc+0x16>
    8f62:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    8f66:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8f6a:	bf00      	nop
    8f6c:	00009708 	.word	0x00009708
    8f70:	00007c75 	.word	0x00007c75

00008f74 <vtable for std_msgs::Time>:
	...
    8f7c:	0000046d 00000495 000004d1 000004d9     m...............

00008f8c <vtable for rosserial_msgs::TopicInfo>:
	...
    8f94:	000008b1 000004e1 000005c9 000005d1     ................

00008fa4 <vtable for rosserial_msgs::Log>:
	...
    8fac:	0000087d 000005d9 00000621 00000629     }.......!...)...

00008fbc <vtable for rosserial_msgs::RequestParamResponse>:
	...
    8fc4:	00000735 00000955 00000631 00000639     5...U...1...9...

00008fd4 <vtable for std_msgs::Int16>:
	...
    8fdc:	00000641 00000651 00000661 00000669     A...Q...a...i...

00008fec <vtable for std_msgs::Float32>:
	...
    8ff4:	00000671 0000068d 000006ad 000006b5     q...............

00009004 <vtable for geometry_msgs::Vector3>:
	...
    900c:	00000fc5 00001dd9 000006bd 000006c5     ................

0000901c <vtable for geometry_msgs::Quaternion>:
	...
    9024:	000011f1 00002445 000006cd 000006d5     ....E$..........

00009034 <vtable for geometry_msgs::Twist>:
	...
    903c:	00000b3d 000019d1 000006dd 000006e5     =...............

0000904c <vtable for ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>>:
	...
    9054:	000026ed 00004365 0000072d              .&..eC..-...

00009060 <vtable for ros::Subscriber<geometry_msgs::Twist, void>>:
	...
    9068:	000015ad 00000719 0000071d 00000725     ............%...

00009078 <vtable for ros::Subscriber<std_msgs::Int16, void>>:
	...
    9080:	000006ed 00000705 00000709 00000711     ................
    9090:	5f647473 7367736d 6d69542f 00000065     std_msgs/Time...
    90a0:	31376463 37633636 35356334 31336332     cd7166c74c552c31
    90b0:	63626631 65663263 62376135 39383263     1fbcc2fe5a7bc289
    90c0:	00000000 73736f72 61697265 736d5f6c     ....rosserial_ms
    90d0:	542f7367 6369706f 6f666e49 00000000     gs/TopicInfo....
    90e0:	35646130 38386631 34346366 66323938     0ad51f88fc44892f
    90f0:	30316338 30343836 34363737 35303036     8c10684077646005
    9100:	00000000 73736f72 61697265 736d5f6c     ....rosserial_ms
    9110:	4c2f7367 0000676f 62613131 31333764     gs/Log..11abd731
    9120:	39353263 36323333 36646331 62333831     c25933261cd6183b
    9130:	64323164 35393236 00000000 65306639     d12d6295....9f0e
    9140:	64623839 39353661 38393138 66646436     98bda65981986ddf
    9150:	66613335 34613761 39346530 00000000     53afa7a40e49....
    9160:	5f647473 7367736d 746e492f 00003631     std_msgs/Int16..
    9170:	34323538 65363835 62663433 62633764     8524586e34fbd7cb
    9180:	38306331 35663563 61633166 37356530     1c08c5f5f1ca0e57
    9190:	00000000 5f647473 7367736d 6f6c462f     ....std_msgs/Flo
    91a0:	32337461 00000000 63663337 36346662     at32....73fcbf46
    91b0:	31393462 36653139 30393237 30356538     b49191e672908e50
    91c0:	61323438 34643338 00000000 6d6f6567     842a83d4....geom
    91d0:	79727465 67736d5f 65562f73 726f7463     etry_msgs/Vector
    91e0:	00000033 34386134 35366232 33313466     3...4a842b65f413
    91f0:	64343830 31623263 34626630 61653438     084dc2b10fb484ea
    9200:	37316637 00000000 6d6f6567 79727465     7f17....geometry
    9210:	67736d5f 75512f73 72657461 6e6f696e     _msgs/Quaternion
    9220:	00000000 39373761 66393738 30666461     ....a779879fadf0
    9230:	37303631 39663433 38623630 63393163     160734f906b8c19c
    9240:	34303037 00000000 6d6f6567 79727465     7004....geometry
    9250:	67736d5f 77542f73 00747369 39316639     _msgs/Twist.9f19
    9260:	38386635 36343231 61666466 38393732     5f881246fdfa2798
    9270:	33643164 63626565 61343861 00000000     d1d3eebca84a....
    9280:	7373654d 20656761 6d6f7266 76656420     Message from dev
    9290:	20656369 706f7264 3a646570 73656d20     ice dropped: mes
    92a0:	65676173 72616c20 20726567 6e616874     sage larger than
    92b0:	66756220 2e726566 00000000 00646572      buffer.....red.
    92c0:	00646552 00444552 65657267 0000006e     Red.RED.green...
    92d0:	65657247 0000006e 45455247 0000004e     Green...GREEN...
    92e0:	65756c62 00000000 65756c42 00000000     blue....Blue....
    92f0:	45554c42 00000000 6e617963 00000000     BLUE....cyan....
    9300:	6e617943 00000000 4e415943 00000000     Cyan....CYAN....
    9310:	70727570 0000656c 70727550 0000656c     purple..Purple..
    9320:	50525550 0000454c 6e61726f 00006567     PURPLE..orange..
    9330:	6e61724f 00006567 4e41524f 00004547     Orange..ORANGE..
    9340:	74696877 00002065 74696857 00000065     white ..White...
    9350:	54494857 00000045 72617453 70752074     WHITE...Start up
    9360:	00000000 74696877 00000065 68676972     ....white...righ
    9370:	69745f74 00006b63 7466656c 6369745f     t_tick..left_tic
    9380:	0000006b 65656877 6e615f6c 00656c67     k...wheel_angle.
    9390:	65657073 6e615f64 69745f64 00006b63     speed_and_tick..
    93a0:	5f756d69 00636361 5f756d69 6f727967     imu_acc.imu_gyro
    93b0:	00000000 5f756d69 0067616d 7361656d     ....imu_mag.meas
    93c0:	64657275 676e615f 0000656c 5f646d63     ured_angle..cmd_
    93d0:	006c6576 74617473 5f70755f 656e6f64     vel.stat_up_done
    93e0:	00000000                                ....

000093e4 <rosserial_msgs::REQUESTPARAM>:
    93e4:	73736f72 61697265 736d5f6c 522f7367     rosserial_msgs/R
    93f4:	65757165 61507473 006d6172              equestParam.

00009400 <TwoWire::i2c0_hardware>:
    9400:	40048034 00000040 08221112 05020230     4..@@.....".0...
    9410:	10130207 022f0721 02070502 00000018     ....!./.........

00009420 <TwoWire::i2c1_hardware>:
    9420:	40048034 00000080 ffff3a26 000602ff     4..@....&:......
    9430:	3b250000 02ffffff 00000006 00000019     ..%;............

00009440 <TwoWire::i2c2_hardware>:
    9440:	40048028 00000040 ffffff04 000005ff     (..@@...........
    9450:	1a030000 05ffffff 00000005 0000004a     ............J...

00009460 <vtable for TwoWire>:
	...
    9468:	00004f99 00004f5d 00004f3d 00004f59     .O..]O..=O..YO..
    9478:	00004c99 00004ca5 00004f41              .L...L..AO..

00009484 <digital_pin_to_info_PGM>:
    9484:	43fe0840 4004a040 43fe0844 4004a044     @..C@..@D..CD..@
    9494:	43fe1800 4004c000 43fe0030 40049030     ...C...@0..C0..@
    94a4:	43fe0034 40049034 43fe181c 4004c01c     4..C4..@...C...@
    94b4:	43fe1810 4004c010 43fe1808 4004c008     ...C...@...C...@
    94c4:	43fe180c 4004c00c 43fe100c 4004b00c     ...C...@...C...@
    94d4:	43fe1010 4004b010 43fe1018 4004b018     ...C...@...C...@
    94e4:	43fe101c 4004b01c 43fe1014 4004b014     ...C...@...C...@
    94f4:	43fe1804 4004c004 43fe1000 4004b000     ...C...@...C...@
    9504:	43fe0800 4004a000 43fe0804 4004a004     ...C...@...C...@
    9514:	43fe080c 4004a00c 43fe0808 4004a008     ...C...@...C...@
    9524:	43fe1814 4004c014 43fe1818 4004c018     ...C...@...C...@
    9534:	43fe1004 4004b004 43fe1008 4004b008     ...C...@...C...@
    9544:	43fe2068 4004d068 43fe0014 40049014     h .Ch..@...C...@
    9554:	43fe0038 40049038 43fe003c 4004903c     8..C8..@<..C<..@
    9564:	43fe0040 40049040 43fe0848 4004a048     @..C@..@H..CH..@
    9574:	43fe084c 4004a04c 43fe0828 4004a028     L..CL..@(..C(..@
    9584:	43fe082c 4004a02c 43fe2060 4004d060     ,..C,..@` .C`..@
    9594:	43fe2064 4004d064 43fe1020 4004b020     d .Cd..@ ..C ..@
    95a4:	43fe1024 4004b024 43fe1028 4004b028     $..C$..@(..C(..@
    95b4:	43fe102c 4004b02c 43fe0044 40049044     ,..C,..@D..CD..@
    95c4:	43fe0070 40049070 43fe0074 40049074     p..Cp..@t..Ct..@
    95d4:	43fe0068 40049068 43fe0850 4004a050     h..Ch..@P..CP..@
    95e4:	43fe0858 4004a058 43fe085c 4004a05c     X..CX..@\..C\..@
    95f4:	43fe0854 4004a054 43fe1820 4004c020     T..CT..@ ..C ..@
    9604:	43fe1824 4004c024 43fe0810 4004a010     $..C$..@...C...@
    9614:	43fe0814 4004a014 43fe1838 4004c038     ...C...@8..C8..@
    9624:	43fe1834 4004c034 43fe1830 4004c030     4..C4..@0..C0..@
    9634:	43fe183c 4004c03c 43fe182c 4004c02c     <..C<..@,..C,..@
    9644:	43fe2028 4004d028 43fe202c 4004d02c     ( .C(..@, .C,..@
    9654:	43fe2000 4004d000 43fe2004 4004d004     . .C...@. .C...@
    9664:	43fe2008 4004d008 43fe200c 4004d00c     . .C...@. .C...@
    9674:	43fe2010 4004d010 43fe2014 4004d014     . .C...@. .C...@
    9684:	ffff0a0d                                ....

00009688 <vtable for usb_serial_class>:
	...
    9690:	00006f65 00000949 00006f61 00006f5d     eo..I...ao..]o..
    96a0:	00006f59 00000951 00006f55 00006f51     Yo..Q...Uo..Qo..

000096b0 <usb_endpoint_config_table>:
    96b0:	15191500                                ....

000096b4 <usb_descriptor_list>:
    96b4:	00000100 1fff0b38 00000012 00000200     ....8...........
    96c4:	1fff0b64 00000043 00000300 1fff0bc0     d...C...........
    96d4:	00000000 04090301 1fff0b4c 00000000     ........L.......
    96e4:	04090302 1fff0ba8 00000000 04090303     ................
    96f4:	1fff0bc4 00000000 00000000 00000000     ................
    9704:	00000000                                ....

00009708 <_global_impure_ptr>:
    9708:	1fff0be0                                ....

0000970c <_init>:
    970c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    970e:	bf00      	nop
    9710:	bcf8      	pop	{r3, r4, r5, r6, r7}
    9712:	bc08      	pop	{r3}
    9714:	469e      	mov	lr, r3
    9716:	4770      	bx	lr

00009718 <__init_array_start>:
    9718:	00008c1d 	.word	0x00008c1d

0000971c <__frame_dummy_init_array_entry>:
    971c:	00000435 00004a41                       5...AJ..

Disassembly of section .fini:

00009724 <_fini>:
    9724:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9726:	bf00      	nop

Disassembly of section .data:

1fff0730 <port_E_isr>:
#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
PORT_ISR_FUNCTION_CLZ(C)
PORT_ISR_FUNCTION_CLZ(D)
PORT_ISR_FUNCTION_CLZ(E)
1fff0730:	b538      	push	{r3, r4, r5, lr}
1fff0732:	4b08      	ldr	r3, [pc, #32]	; (1fff0754 <port_E_isr+0x24>)
1fff0734:	681c      	ldr	r4, [r3, #0]
1fff0736:	601c      	str	r4, [r3, #0]
1fff0738:	b154      	cbz	r4, 1fff0750 <port_E_isr+0x20>
1fff073a:	4d07      	ldr	r5, [pc, #28]	; (1fff0758 <port_E_isr+0x28>)
1fff073c:	fa94 f3a4 	rbit	r3, r4
1fff0740:	fab3 f383 	clz	r3, r3
1fff0744:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff0748:	4798      	blx	r3
1fff074a:	1e63      	subs	r3, r4, #1
1fff074c:	401c      	ands	r4, r3
1fff074e:	d1f5      	bne.n	1fff073c <port_E_isr+0xc>
1fff0750:	bd38      	pop	{r3, r4, r5, pc}
1fff0752:	bf00      	nop
1fff0754:	4004d0a0 	.word	0x4004d0a0
1fff0758:	1fff0ab0 	.word	0x1fff0ab0

1fff075c <port_D_isr>:

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
PORT_ISR_FUNCTION_CLZ(C)
PORT_ISR_FUNCTION_CLZ(D)
1fff075c:	b538      	push	{r3, r4, r5, lr}
1fff075e:	4b08      	ldr	r3, [pc, #32]	; (1fff0780 <port_D_isr+0x24>)
1fff0760:	681c      	ldr	r4, [r3, #0]
1fff0762:	601c      	str	r4, [r3, #0]
1fff0764:	b154      	cbz	r4, 1fff077c <port_D_isr+0x20>
1fff0766:	4d07      	ldr	r5, [pc, #28]	; (1fff0784 <port_D_isr+0x28>)
1fff0768:	fa94 f3a4 	rbit	r3, r4
1fff076c:	fab3 f383 	clz	r3, r3
1fff0770:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff0774:	4798      	blx	r3
1fff0776:	1e63      	subs	r3, r4, #1
1fff0778:	401c      	ands	r4, r3
1fff077a:	d1f5      	bne.n	1fff0768 <port_D_isr+0xc>
1fff077c:	bd38      	pop	{r3, r4, r5, pc}
1fff077e:	bf00      	nop
1fff0780:	4004c0a0 	.word	0x4004c0a0
1fff0784:	1fff0a70 	.word	0x1fff0a70

1fff0788 <port_C_isr>:
// END PORT_ISR_FUNCTION_CLZ

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
PORT_ISR_FUNCTION_CLZ(C)
1fff0788:	b538      	push	{r3, r4, r5, lr}
1fff078a:	4b08      	ldr	r3, [pc, #32]	; (1fff07ac <port_C_isr+0x24>)
1fff078c:	681c      	ldr	r4, [r3, #0]
1fff078e:	601c      	str	r4, [r3, #0]
1fff0790:	b154      	cbz	r4, 1fff07a8 <port_C_isr+0x20>
1fff0792:	4d07      	ldr	r5, [pc, #28]	; (1fff07b0 <port_C_isr+0x28>)
1fff0794:	fa94 f3a4 	rbit	r3, r4
1fff0798:	fab3 f383 	clz	r3, r3
1fff079c:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff07a0:	4798      	blx	r3
1fff07a2:	1e63      	subs	r3, r4, #1
1fff07a4:	401c      	ands	r4, r3
1fff07a6:	d1f5      	bne.n	1fff0794 <port_C_isr+0xc>
1fff07a8:	bd38      	pop	{r3, r4, r5, pc}
1fff07aa:	bf00      	nop
1fff07ac:	4004b0a0 	.word	0x4004b0a0
1fff07b0:	1fff0a40 	.word	0x1fff0a40

1fff07b4 <port_B_isr>:
	}
// END PORT_ISR_FUNCTION_CLZ

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
1fff07b4:	b538      	push	{r3, r4, r5, lr}
1fff07b6:	4b08      	ldr	r3, [pc, #32]	; (1fff07d8 <port_B_isr+0x24>)
1fff07b8:	681c      	ldr	r4, [r3, #0]
1fff07ba:	601c      	str	r4, [r3, #0]
1fff07bc:	b154      	cbz	r4, 1fff07d4 <port_B_isr+0x20>
1fff07be:	4d07      	ldr	r5, [pc, #28]	; (1fff07dc <port_B_isr+0x28>)
1fff07c0:	fa94 f3a4 	rbit	r3, r4
1fff07c4:	fab3 f383 	clz	r3, r3
1fff07c8:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff07cc:	4798      	blx	r3
1fff07ce:	1e63      	subs	r3, r4, #1
1fff07d0:	401c      	ands	r4, r3
1fff07d2:	d1f5      	bne.n	1fff07c0 <port_B_isr+0xc>
1fff07d4:	bd38      	pop	{r3, r4, r5, pc}
1fff07d6:	bf00      	nop
1fff07d8:	4004a0a0 	.word	0x4004a0a0
1fff07dc:	1fff09e0 	.word	0x1fff09e0

1fff07e0 <port_A_isr>:
		}                                                     \
	}
// END PORT_ISR_FUNCTION_CLZ

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
1fff07e0:	b538      	push	{r3, r4, r5, lr}
1fff07e2:	4b08      	ldr	r3, [pc, #32]	; (1fff0804 <port_A_isr+0x24>)
1fff07e4:	681c      	ldr	r4, [r3, #0]
1fff07e6:	601c      	str	r4, [r3, #0]
1fff07e8:	b154      	cbz	r4, 1fff0800 <port_A_isr+0x20>
1fff07ea:	4d07      	ldr	r5, [pc, #28]	; (1fff0808 <port_A_isr+0x28>)
1fff07ec:	fa94 f3a4 	rbit	r3, r4
1fff07f0:	fab3 f383 	clz	r3, r3
1fff07f4:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff07f8:	4798      	blx	r3
1fff07fa:	1e63      	subs	r3, r4, #1
1fff07fc:	401c      	ands	r4, r3
1fff07fe:	d1f5      	bne.n	1fff07ec <port_A_isr+0xc>
1fff0800:	bd38      	pop	{r3, r4, r5, pc}
1fff0802:	bf00      	nop
1fff0804:	400490a0 	.word	0x400490a0
1fff0808:	1fff0968 	.word	0x1fff0968

1fff080c <bool_tele_op_toggel>:
1fff080c:	00000001                                ....

1fff0810 <count_to_rad>:
1fff0810:	20000000 3f6aceea                       ... ..j?

1fff0818 <float_to_long_factor>:
1fff0818:	461c4000                                .@.F

1fff081c <I2Cdev::readTimeout>:
1fff081c:	000003e8                                ....

1fff0820 <Wire2>:
1fff0820:	00009468 00000000 000003e8 00000000     h...............
1fff0830:	400e6000 00009440 00000000 00000000     .`.@@...........
	...

1fff088c <Wire>:
1fff088c:	00009468 00000000 000003e8 00000000     h...............
1fff089c:	40066000 00009400 00000000 00000000     .`.@............
	...

1fff08f8 <Wire1>:
1fff08f8:	00009468 00000000 000003e8 00000000     h...............
1fff0908:	40067000 00009420 00000000 00000000     .p.@ ...........
	...

1fff0964 <__brkval>:
1fff0964:	1fff2c60                                `,..

1fff0968 <isr_table_portA>:
1fff0968:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff0978:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff0988:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff0998:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff09a8:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff09b8:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff09c8:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff09d8:	00005851 00005851                       QX..QX..

1fff09e0 <isr_table_portB>:
1fff09e0:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff09f0:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff0a00:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff0a10:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff0a20:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff0a30:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..

1fff0a40 <isr_table_portC>:
1fff0a40:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff0a50:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff0a60:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..

1fff0a70 <isr_table_portD>:
1fff0a70:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff0a80:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff0a90:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff0aa0:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..

1fff0ab0 <isr_table_portE>:
1fff0ab0:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff0ac0:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff0ad0:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff0ae0:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff0af0:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff0b00:	00005851 00005851 00005851 00005851     QX..QX..QX..QX..
1fff0b10:	00005851 00005851 00005851              QX..QX..QX..

1fff0b1c <analog_write_res>:
1fff0b1c:	00000008                                ....

1fff0b20 <usb_buffer_available>:
1fff0b20:	ffffffff                                ....

1fff0b24 <Serial>:
1fff0b24:	00009690 00000000 000003e8 00000000     ................

1fff0b34 <yield_active_check_flags>:
1fff0b34:	00040a01                                         .

1fff0b35 <analog_config_bits>:
1fff0b35:	1200040a                                         .

1fff0b36 <analog_num_average>:
1fff0b36:	01120004                                         ..

1fff0b38 <device_descriptor>:
1fff0b38:	01100112 40000002 048316c0 02010277     .......@....w...
1fff0b48:	00000103                                ....

1fff0b4c <usb_string_manufacturer_name_default>:
1fff0b4c:	00540318 00650065 0073006e 00640079     ..T.e.e.n.s.y.d.
1fff0b5c:	00690075 006f006e                       u.i.n.o.

1fff0b64 <config_descriptor>:
1fff0b64:	00430209 c0000102 00040932 02020100     ..C.....2.......
1fff0b74:	24050001 05011000 01010124 06022404     ...$....$....$..
1fff0b84:	00062405 82050701 40001003 00010409     .$.........@....
1fff0b94:	00000a02 03050700 00004002 02840507     .........@......
1fff0ba4:	00000040                                @...

1fff0ba8 <usb_string_product_name_default>:
1fff0ba8:	00550316 00420053 00530020 00720065     ..U.S.B. .S.e.r.
1fff0bb8:	00610069 0000006c                       i.a.l...

1fff0bc0 <string0>:
1fff0bc0:	04090304                                ....

1fff0bc4 <usb_string_serial_number_default>:
1fff0bc4:	0000030c 00000000 00000000 00000000     ................
1fff0bd4:	00000000 00010000                                ......

1fff0bda <_serialEvent_default>:
1fff0bda:	00000001 00000000                                ......

1fff0be0 <impure_data>:
1fff0be0:	00000000 1fff0ecc 1fff0f34 1fff0f9c     ........4.......
	...
1fff0c88:	00000001 00000000 abcd330e e66d1234     .........3..4.m.
1fff0c98:	0005deec 0000000b 00000000 00000000     ................
	...

1fff1008 <_impure_ptr>:
1fff1008:	1fff0be0                                ....

1fff100c <__malloc_av_>:
	...
1fff1014:	1fff100c 1fff100c 1fff1014 1fff1014     ................
1fff1024:	1fff101c 1fff101c 1fff1024 1fff1024     ........$...$...
1fff1034:	1fff102c 1fff102c 1fff1034 1fff1034     ,...,...4...4...
1fff1044:	1fff103c 1fff103c 1fff1044 1fff1044     <...<...D...D...
1fff1054:	1fff104c 1fff104c 1fff1054 1fff1054     L...L...T...T...
1fff1064:	1fff105c 1fff105c 1fff1064 1fff1064     \...\...d...d...
1fff1074:	1fff106c 1fff106c 1fff1074 1fff1074     l...l...t...t...
1fff1084:	1fff107c 1fff107c 1fff1084 1fff1084     |...|...........
1fff1094:	1fff108c 1fff108c 1fff1094 1fff1094     ................
1fff10a4:	1fff109c 1fff109c 1fff10a4 1fff10a4     ................
1fff10b4:	1fff10ac 1fff10ac 1fff10b4 1fff10b4     ................
1fff10c4:	1fff10bc 1fff10bc 1fff10c4 1fff10c4     ................
1fff10d4:	1fff10cc 1fff10cc 1fff10d4 1fff10d4     ................
1fff10e4:	1fff10dc 1fff10dc 1fff10e4 1fff10e4     ................
1fff10f4:	1fff10ec 1fff10ec 1fff10f4 1fff10f4     ................
1fff1104:	1fff10fc 1fff10fc 1fff1104 1fff1104     ................
1fff1114:	1fff110c 1fff110c 1fff1114 1fff1114     ................
1fff1124:	1fff111c 1fff111c 1fff1124 1fff1124     ........$...$...
1fff1134:	1fff112c 1fff112c 1fff1134 1fff1134     ,...,...4...4...
1fff1144:	1fff113c 1fff113c 1fff1144 1fff1144     <...<...D...D...
1fff1154:	1fff114c 1fff114c 1fff1154 1fff1154     L...L...T...T...
1fff1164:	1fff115c 1fff115c 1fff1164 1fff1164     \...\...d...d...
1fff1174:	1fff116c 1fff116c 1fff1174 1fff1174     l...l...t...t...
1fff1184:	1fff117c 1fff117c 1fff1184 1fff1184     |...|...........
1fff1194:	1fff118c 1fff118c 1fff1194 1fff1194     ................
1fff11a4:	1fff119c 1fff119c 1fff11a4 1fff11a4     ................
1fff11b4:	1fff11ac 1fff11ac 1fff11b4 1fff11b4     ................
1fff11c4:	1fff11bc 1fff11bc 1fff11c4 1fff11c4     ................
1fff11d4:	1fff11cc 1fff11cc 1fff11d4 1fff11d4     ................
1fff11e4:	1fff11dc 1fff11dc 1fff11e4 1fff11e4     ................
1fff11f4:	1fff11ec 1fff11ec 1fff11f4 1fff11f4     ................
1fff1204:	1fff11fc 1fff11fc 1fff1204 1fff1204     ................
1fff1214:	1fff120c 1fff120c 1fff1214 1fff1214     ................
1fff1224:	1fff121c 1fff121c 1fff1224 1fff1224     ........$...$...
1fff1234:	1fff122c 1fff122c 1fff1234 1fff1234     ,...,...4...4...
1fff1244:	1fff123c 1fff123c 1fff1244 1fff1244     <...<...D...D...
1fff1254:	1fff124c 1fff124c 1fff1254 1fff1254     L...L...T...T...
1fff1264:	1fff125c 1fff125c 1fff1264 1fff1264     \...\...d...d...
1fff1274:	1fff126c 1fff126c 1fff1274 1fff1274     l...l...t...t...
1fff1284:	1fff127c 1fff127c 1fff1284 1fff1284     |...|...........
1fff1294:	1fff128c 1fff128c 1fff1294 1fff1294     ................
1fff12a4:	1fff129c 1fff129c 1fff12a4 1fff12a4     ................
1fff12b4:	1fff12ac 1fff12ac 1fff12b4 1fff12b4     ................
1fff12c4:	1fff12bc 1fff12bc 1fff12c4 1fff12c4     ................
1fff12d4:	1fff12cc 1fff12cc 1fff12d4 1fff12d4     ................
1fff12e4:	1fff12dc 1fff12dc 1fff12e4 1fff12e4     ................
1fff12f4:	1fff12ec 1fff12ec 1fff12f4 1fff12f4     ................
1fff1304:	1fff12fc 1fff12fc 1fff1304 1fff1304     ................
1fff1314:	1fff130c 1fff130c 1fff1314 1fff1314     ................
1fff1324:	1fff131c 1fff131c 1fff1324 1fff1324     ........$...$...
1fff1334:	1fff132c 1fff132c 1fff1334 1fff1334     ,...,...4...4...
1fff1344:	1fff133c 1fff133c 1fff1344 1fff1344     <...<...D...D...
1fff1354:	1fff134c 1fff134c 1fff1354 1fff1354     L...L...T...T...
1fff1364:	1fff135c 1fff135c 1fff1364 1fff1364     \...\...d...d...
1fff1374:	1fff136c 1fff136c 1fff1374 1fff1374     l...l...t...t...
1fff1384:	1fff137c 1fff137c 1fff1384 1fff1384     |...|...........
1fff1394:	1fff138c 1fff138c 1fff1394 1fff1394     ................
1fff13a4:	1fff139c 1fff139c 1fff13a4 1fff13a4     ................
1fff13b4:	1fff13ac 1fff13ac 1fff13b4 1fff13b4     ................
1fff13c4:	1fff13bc 1fff13bc 1fff13c4 1fff13c4     ................
1fff13d4:	1fff13cc 1fff13cc 1fff13d4 1fff13d4     ................
1fff13e4:	1fff13dc 1fff13dc 1fff13e4 1fff13e4     ................
1fff13f4:	1fff13ec 1fff13ec 1fff13f4 1fff13f4     ................
1fff1404:	1fff13fc 1fff13fc 1fff1404 1fff1404     ................

1fff1414 <__malloc_trim_threshold>:
1fff1414:	00020000                                ....

1fff1418 <__malloc_sbrk_base>:
1fff1418:	ffffffff                                ....
