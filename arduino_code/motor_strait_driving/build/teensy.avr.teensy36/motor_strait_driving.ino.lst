
/tmp/arduino-sketch-1A5AB903302D1BEDD698E1DA3B58D00C/motor_strait_driving.ino.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <_VectorsFlash>:
HardwareSerial 	*HardwareSerial::s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
uint8_t 		HardwareSerial::s_count_serials_with_serial_events = 0;

// simple helper function that add us to the list of Serial ports that have
// their own serialEvent code defined that needs to be called at yield.
void HardwareSerial::addToSerialEventsList() {
       0:	00 00 03 20 d1 01 00 00 69 5d 00 00 21 5d 00 00     ... ....i]..!]..
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
		if (s_serials_with_serial_events[i] == this) return; // already in the list.
      10:	21 5d 00 00 21 5d 00 00 21 5d 00 00 21 5d 00 00     !]..!]..!]..!]..
      20:	21 5d 00 00 21 5d 00 00 21 5d 00 00 69 5d 00 00     !]..!]..!]..i]..
	}

	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
      30:	69 5d 00 00 21 5d 00 00 f5 73 00 00 f9 73 00 00     i]..!]...s...s..
uint8_t 		HardwareSerial::s_count_serials_with_serial_events = 0;

// simple helper function that add us to the list of Serial ports that have
// their own serialEvent code defined that needs to be called at yield.
void HardwareSerial::addToSerialEventsList() {
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
      40:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..
      50:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..
      60:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..
      70:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..
      80:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..
      90:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..
      a0:	d9 5a 00 00 e5 5a 00 00 69 5d 00 00 69 5d 00 00     .Z...Z..i]..i]..
      b0:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..
      c0:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..
      d0:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..
      e0:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..
      f0:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..
     100:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..
     110:	69 5d 00 00 19 67 00 00 69 5d 00 00 69 5d 00 00     i]...g..i]..i]..
     120:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..
     130:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..
     140:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..
     150:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..
     160:	69 5d 00 00 69 5d 00 00 f1 5a 00 00 69 5d 00 00     i]..i]...Z..i]..
     170:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..
     180:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..
     190:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..
     1a0:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..
     1b0:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..
     1c0:	69 5d 00 00 69 5d 00 00 69 5d 00 00 69 5d 00 00     i]..i]..i]..i]..

000001d0 <ResetHandler>:
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d0:	4b5c      	ldr	r3, [pc, #368]	; (344 <ResetHandler+0x174>)
     1d2:	f24c 5220 	movw	r2, #50464	; 0xc520
#else
// hopefully all others fit into startup section (below 0x400)
__attribute__ ((section(".startup"),optimize("-Os")))
#endif
void ResetHandler(void)
{
     1d6:	b510      	push	{r4, lr}
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d8:	801a      	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
     1da:	f64d 1228 	movw	r2, #55592	; 0xd928
     1de:	801a      	strh	r2, [r3, #0]
	__asm__ volatile ("nop");
     1e0:	bf00      	nop
	__asm__ volatile ("nop");
     1e2:	bf00      	nop
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
     1e4:	f005 fdc4 	bl	5d70 <startup_early_hook>
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1e8:	4b57      	ldr	r3, [pc, #348]	; (348 <ResetHandler+0x178>)
     1ea:	f04f 6230 	mov.w	r2, #184549376	; 0xb000000
     1ee:	601a      	str	r2, [r3, #0]
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
     1f0:	4a56      	ldr	r2, [pc, #344]	; (34c <ResetHandler+0x17c>)
     1f2:	609a      	str	r2, [r3, #8]
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
     1f4:	4a56      	ldr	r2, [pc, #344]	; (350 <ResetHandler+0x180>)
     1f6:	60da      	str	r2, [r3, #12]
	SIM_SCGC4 = SIM_SCGC4_USBOTG | 0xF0000030;
	SIM_SCGC5 = 0x00003F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_ADC0 | SIM_SCGC6_TPM0 | SIM_SCGC6_TPM1 | SIM_SCGC6_TPM2 | SIM_SCGC6_FTFL;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SCB_CPACR = 0x00F00000;
     1f8:	4b56      	ldr	r3, [pc, #344]	; (354 <ResetHandler+0x184>)
     1fa:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
     1fe:	601a      	str	r2, [r3, #0]
#endif
#if defined(__MK66FX1M0__)
	LMEM_PCCCR = 0x85000003;
     200:	4b55      	ldr	r3, [pc, #340]	; (358 <ResetHandler+0x188>)
     202:	4a56      	ldr	r2, [pc, #344]	; (35c <ResetHandler+0x18c>)
     204:	601a      	str	r2, [r3, #0]
		RTC_SR = 0;
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
     206:	4b56      	ldr	r3, [pc, #344]	; (360 <ResetHandler+0x190>)
     208:	781a      	ldrb	r2, [r3, #0]
     20a:	0711      	lsls	r1, r2, #28
     20c:	d503      	bpl.n	216 <ResetHandler+0x46>
     20e:	781a      	ldrb	r2, [r3, #0]
     210:	f042 0208 	orr.w	r2, r2, #8
     214:	701a      	strb	r2, [r3, #0]

    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     216:	4b53      	ldr	r3, [pc, #332]	; (364 <ResetHandler+0x194>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     218:	4953      	ldr	r1, [pc, #332]	; (368 <ResetHandler+0x198>)
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;

    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     21a:	22aa      	movs	r2, #170	; 0xaa
     21c:	701a      	strb	r2, [r3, #0]
     21e:	4a53      	ldr	r2, [pc, #332]	; (36c <ResetHandler+0x19c>)
     220:	4b53      	ldr	r3, [pc, #332]	; (370 <ResetHandler+0x1a0>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     222:	428b      	cmp	r3, r1
     224:	d204      	bcs.n	230 <ResetHandler+0x60>
     226:	f852 0f04 	ldr.w	r0, [r2, #4]!
     22a:	f843 0b04 	str.w	r0, [r3], #4
     22e:	e7f8      	b.n	222 <ResetHandler+0x52>
     230:	4b50      	ldr	r3, [pc, #320]	; (374 <ResetHandler+0x1a4>)
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
     232:	4951      	ldr	r1, [pc, #324]	; (378 <ResetHandler+0x1a8>)
     234:	2200      	movs	r2, #0
     236:	428b      	cmp	r3, r1
     238:	d202      	bcs.n	240 <ResetHandler+0x70>
     23a:	f843 2b04 	str.w	r2, [r3], #4
     23e:	e7fa      	b.n	236 <ResetHandler+0x66>

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
     240:	494e      	ldr	r1, [pc, #312]	; (37c <ResetHandler+0x1ac>)
     242:	4a4f      	ldr	r2, [pc, #316]	; (380 <ResetHandler+0x1b0>)
     244:	2300      	movs	r3, #0
     246:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
     24a:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
     24e:	3301      	adds	r3, #1
     250:	2b74      	cmp	r3, #116	; 0x74
     252:	d1f8      	bne.n	246 <ResetHandler+0x76>
     254:	4b4b      	ldr	r3, [pc, #300]	; (384 <ResetHandler+0x1b4>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
     256:	4a4c      	ldr	r2, [pc, #304]	; (388 <ResetHandler+0x1b8>)
     258:	2180      	movs	r1, #128	; 0x80
     25a:	f803 1b01 	strb.w	r1, [r3], #1
     25e:	4293      	cmp	r3, r2
     260:	d1fb      	bne.n	25a <ResetHandler+0x8a>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
     262:	4b4a      	ldr	r3, [pc, #296]	; (38c <ResetHandler+0x1bc>)
     264:	4a45      	ldr	r2, [pc, #276]	; (37c <ResetHandler+0x1ac>)
     266:	601a      	str	r2, [r3, #0]
	//  C6[PLLS] bit is written to 0
	//  C2[LP] bit is written to 1
#else
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
     268:	4b49      	ldr	r3, [pc, #292]	; (390 <ResetHandler+0x1c0>)
     26a:	228a      	movs	r2, #138	; 0x8a
     26c:	701a      	strb	r2, [r3, #0]
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
     26e:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
     272:	2224      	movs	r2, #36	; 0x24
     274:	705a      	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
     276:	22a0      	movs	r2, #160	; 0xa0
     278:	701a      	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
     27a:	799a      	ldrb	r2, [r3, #6]
     27c:	0792      	lsls	r2, r2, #30
     27e:	d5fc      	bpl.n	27a <ResetHandler+0xaa>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
     280:	799a      	ldrb	r2, [r3, #6]
     282:	06d4      	lsls	r4, r2, #27
     284:	d4fc      	bmi.n	280 <ResetHandler+0xb0>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     286:	4a43      	ldr	r2, [pc, #268]	; (394 <ResetHandler+0x1c4>)
     288:	7993      	ldrb	r3, [r2, #6]
     28a:	f003 030c 	and.w	r3, r3, #12
     28e:	2b08      	cmp	r3, #8
     290:	d1fa      	bne.n	288 <ResetHandler+0xb8>
	//   C2[LP] bit is written to 1
  #else
	// if we need faster than the crystal, turn on the PLL
   #if defined(__MK66FX1M0__)
    #if F_CPU > 120000000
	SMC_PMCTRL = SMC_PMCTRL_RUNM(3); // enter HSRUN mode
     292:	4b41      	ldr	r3, [pc, #260]	; (398 <ResetHandler+0x1c8>)
     294:	2260      	movs	r2, #96	; 0x60
     296:	701a      	strb	r2, [r3, #0]
	while (SMC_PMSTAT != SMC_PMSTAT_HSRUN) ; // wait for HSRUN
     298:	3302      	adds	r3, #2
     29a:	781a      	ldrb	r2, [r3, #0]
     29c:	2a80      	cmp	r2, #128	; 0x80
     29e:	d1fc      	bne.n	29a <ResetHandler+0xca>
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(11);
    #elif F_CPU == 192000000
	MCG_C5 = MCG_C5_PRDIV0(0);
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(8);
    #elif F_CPU == 180000000
	MCG_C5 = MCG_C5_PRDIV0(1);
     2a0:	4b3c      	ldr	r3, [pc, #240]	; (394 <ResetHandler+0x1c4>)
     2a2:	2201      	movs	r2, #1
     2a4:	711a      	strb	r2, [r3, #4]
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(29);
     2a6:	225d      	movs	r2, #93	; 0x5d
     2a8:	715a      	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     2aa:	799a      	ldrb	r2, [r3, #6]
     2ac:	0690      	lsls	r0, r2, #26
     2ae:	d5fc      	bpl.n	2aa <ResetHandler+0xda>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     2b0:	7999      	ldrb	r1, [r3, #6]
     2b2:	4a38      	ldr	r2, [pc, #224]	; (394 <ResetHandler+0x1c4>)
     2b4:	0649      	lsls	r1, r1, #25
     2b6:	d5fb      	bpl.n	2b0 <ResetHandler+0xe0>
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(3);
#elif F_CPU == 180000000
	// config divisors: 180 MHz core, 60 MHz bus, 25.7 MHz flash, USB = IRC48M
	#if F_BUS == 60000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(2) | SIM_CLKDIV1_OUTDIV4(6);
     2b8:	4b38      	ldr	r3, [pc, #224]	; (39c <ResetHandler+0x1cc>)
     2ba:	4939      	ldr	r1, [pc, #228]	; (3a0 <ResetHandler+0x1d0>)
     2bc:	6019      	str	r1, [r3, #0]
	#elif F_BUS == 90000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(6);
	#else
	#error "This F_CPU & F_BUS combination is not supported"
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(0);
     2be:	2100      	movs	r1, #0
     2c0:	6059      	str	r1, [r3, #4]
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     2c2:	2320      	movs	r3, #32
     2c4:	7013      	strb	r3, [r2, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     2c6:	7993      	ldrb	r3, [r2, #6]
     2c8:	f003 030c 	and.w	r3, r3, #12
     2cc:	2b0c      	cmp	r3, #12
     2ce:	d1fa      	bne.n	2c6 <ResetHandler+0xf6>
	// now we're in PEE mode
	// trace is CPU clock, CLKOUT=OSCERCLK0
	#if defined(KINETISK)
	#if F_CPU == 256000000 || F_CPU == 216000000 || F_CPU == 180000000
	// USB uses IRC48
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
     2d0:	4b34      	ldr	r3, [pc, #208]	; (3a4 <ResetHandler+0x1d4>)
     2d2:	4a35      	ldr	r2, [pc, #212]	; (3a8 <ResetHandler+0x1d8>)
     2d4:	601a      	str	r2, [r3, #0]
#endif

#if defined(__MK66FX1M0__)
	// If the RTC oscillator isn't enabled, get it started.  For Teensy 3.6
	// we don't do this early.  See comment above about slow rising power.
	if (!(RTC_CR & RTC_CR_OSCE)) {
     2d6:	4a35      	ldr	r2, [pc, #212]	; (3ac <ResetHandler+0x1dc>)
     2d8:	4c35      	ldr	r4, [pc, #212]	; (3b0 <ResetHandler+0x1e0>)
     2da:	6813      	ldr	r3, [r2, #0]
     2dc:	f413 7380 	ands.w	r3, r3, #256	; 0x100
     2e0:	d103      	bne.n	2ea <ResetHandler+0x11a>
		RTC_SR = 0;
     2e2:	6023      	str	r3, [r4, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
     2e4:	f44f 53a8 	mov.w	r3, #5376	; 0x1500
     2e8:	6013      	str	r3, [r2, #0]
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     2ea:	4b32      	ldr	r3, [pc, #200]	; (3b4 <ResetHandler+0x1e4>)
     2ec:	4a32      	ldr	r2, [pc, #200]	; (3b8 <ResetHandler+0x1e8>)
     2ee:	601a      	str	r2, [r3, #0]
	SYST_CVR = 0;
     2f0:	2200      	movs	r2, #0
     2f2:	605a      	str	r2, [r3, #4]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     2f4:	2207      	movs	r2, #7
     2f6:	f843 2c04 	str.w	r2, [r3, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     2fa:	4a30      	ldr	r2, [pc, #192]	; (3bc <ResetHandler+0x1ec>)
     2fc:	f8c3 2d0c 	str.w	r2, [r3, #3340]	; 0xd0c

	//init_pins();
	__enable_irq();
     300:	b662      	cpsie	i

	_init_Teensyduino_internal_();
     302:	f006 f89b 	bl	643c <_init_Teensyduino_internal_>

#if defined(KINETISK)
	// RTC initialization
	if (RTC_SR & RTC_SR_TIF) {
     306:	6823      	ldr	r3, [r4, #0]
     308:	07da      	lsls	r2, r3, #31
     30a:	d505      	bpl.n	318 <ResetHandler+0x148>
		// compiled-in time will be stale.  Write a special
		// flag into the VBAT register file indicating the
		// RTC is set with known-stale time and should be
		// updated when fresh time is known.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     30c:	482c      	ldr	r0, [pc, #176]	; (3c0 <ResetHandler+0x1f0>)
     30e:	f005 fe61 	bl	5fd4 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
     312:	4b2c      	ldr	r3, [pc, #176]	; (3c4 <ResetHandler+0x1f4>)
     314:	4a2c      	ldr	r2, [pc, #176]	; (3c8 <ResetHandler+0x1f8>)
     316:	601a      	str	r2, [r3, #0]
	}
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
     318:	4b2c      	ldr	r3, [pc, #176]	; (3cc <ResetHandler+0x1fc>)
     31a:	781b      	ldrb	r3, [r3, #0]
     31c:	065b      	lsls	r3, r3, #25
     31e:	d509      	bpl.n	334 <ResetHandler+0x164>
     320:	4c28      	ldr	r4, [pc, #160]	; (3c4 <ResetHandler+0x1f4>)
     322:	4b29      	ldr	r3, [pc, #164]	; (3c8 <ResetHandler+0x1f8>)
     324:	6822      	ldr	r2, [r4, #0]
     326:	429a      	cmp	r2, r3
     328:	d104      	bne.n	334 <ResetHandler+0x164>
		// Our compiled-in time will be very fresh, so set
		// the RTC with this, and clear the VBAT resister file
		// data so we don't mess with the time after it's been
		// set well.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     32a:	4825      	ldr	r0, [pc, #148]	; (3c0 <ResetHandler+0x1f0>)
     32c:	f005 fe52 	bl	5fd4 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0;
     330:	2300      	movs	r3, #0
     332:	6023      	str	r3, [r4, #0]
	}
#endif

	__libc_init_array();
     334:	f009 f892 	bl	945c <__libc_init_array>

	startup_late_hook();
     338:	f005 fd20 	bl	5d7c <startup_late_hook>
	main();
     33c:	f007 f8ce 	bl	74dc <main>
     340:	e7fe      	b.n	340 <ResetHandler+0x170>
     342:	bf00      	nop
     344:	4005200e 	.word	0x4005200e
     348:	40048030 	.word	0x40048030
     34c:	00043f82 	.word	0x00043f82
     350:	2b000001 	.word	0x2b000001
     354:	e000ed88 	.word	0xe000ed88
     358:	e0082000 	.word	0xe0082000
     35c:	85000003 	.word	0x85000003
     360:	4007d002 	.word	0x4007d002
     364:	4007e000 	.word	0x4007e000
     368:	1fff1424 	.word	0x1fff1424
     36c:	0000af6c 	.word	0x0000af6c
     370:	1fff0730 	.word	0x1fff0730
     374:	1fff1428 	.word	0x1fff1428
     378:	1fff2cc8 	.word	0x1fff2cc8
     37c:	1fff0200 	.word	0x1fff0200
     380:	00000000 	.word	0x00000000
     384:	e000e400 	.word	0xe000e400
     388:	e000e464 	.word	0xe000e464
     38c:	e000ed08 	.word	0xe000ed08
     390:	40065000 	.word	0x40065000
     394:	40064000 	.word	0x40064000
     398:	4007e001 	.word	0x4007e001
     39c:	40048044 	.word	0x40048044
     3a0:	02060000 	.word	0x02060000
     3a4:	40048004 	.word	0x40048004
     3a8:	000710c0 	.word	0x000710c0
     3ac:	4003d010 	.word	0x4003d010
     3b0:	4003d014 	.word	0x4003d014
     3b4:	e000e014 	.word	0xe000e014
     3b8:	0002bf1f 	.word	0x0002bf1f
     3bc:	20200000 	.word	0x20200000
     3c0:	620cce47 	.word	0x620cce47
     3c4:	4003e01c 	.word	0x4003e01c
     3c8:	5a94c3a5 	.word	0x5a94c3a5
     3cc:	4007f000 	.word	0x4007f000
     3d0:	ffffffff 	.word	0xffffffff
     3d4:	ffffffff 	.word	0xffffffff
     3d8:	ffffffff 	.word	0xffffffff
     3dc:	ffffffff 	.word	0xffffffff
     3e0:	ffffffff 	.word	0xffffffff
     3e4:	ffffffff 	.word	0xffffffff
     3e8:	ffffffff 	.word	0xffffffff
     3ec:	ffffffff 	.word	0xffffffff
     3f0:	ffffffff 	.word	0xffffffff
     3f4:	ffffffff 	.word	0xffffffff
     3f8:	ffffffff 	.word	0xffffffff
     3fc:	ffffffff 	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	ffffffff ffffffff ffffffff fffff9de     ................

00000410 <__do_global_dtors_aux>:
     410:	b510      	push	{r4, lr}
     412:	4c05      	ldr	r4, [pc, #20]	; (428 <__do_global_dtors_aux+0x18>)
     414:	7823      	ldrb	r3, [r4, #0]
     416:	b933      	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
     418:	4b04      	ldr	r3, [pc, #16]	; (42c <__do_global_dtors_aux+0x1c>)
     41a:	b113      	cbz	r3, 422 <__do_global_dtors_aux+0x12>
     41c:	4804      	ldr	r0, [pc, #16]	; (430 <__do_global_dtors_aux+0x20>)
     41e:	f3af 8000 	nop.w
     422:	2301      	movs	r3, #1
     424:	7023      	strb	r3, [r4, #0]
     426:	bd10      	pop	{r4, pc}
     428:	1fff1428 	.word	0x1fff1428
     42c:	00000000 	.word	0x00000000
     430:	0000af70 	.word	0x0000af70

00000434 <frame_dummy>:
     434:	4b08      	ldr	r3, [pc, #32]	; (458 <frame_dummy+0x24>)
     436:	b510      	push	{r4, lr}
     438:	b11b      	cbz	r3, 442 <frame_dummy+0xe>
     43a:	4908      	ldr	r1, [pc, #32]	; (45c <frame_dummy+0x28>)
     43c:	4808      	ldr	r0, [pc, #32]	; (460 <frame_dummy+0x2c>)
     43e:	f3af 8000 	nop.w
     442:	4808      	ldr	r0, [pc, #32]	; (464 <frame_dummy+0x30>)
     444:	6803      	ldr	r3, [r0, #0]
     446:	b903      	cbnz	r3, 44a <frame_dummy+0x16>
     448:	bd10      	pop	{r4, pc}
     44a:	4b07      	ldr	r3, [pc, #28]	; (468 <frame_dummy+0x34>)
     44c:	2b00      	cmp	r3, #0
     44e:	d0fb      	beq.n	448 <frame_dummy+0x14>
     450:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     454:	4718      	bx	r3
     456:	bf00      	nop
     458:	00000000 	.word	0x00000000
     45c:	1fff142c 	.word	0x1fff142c
     460:	0000af70 	.word	0x0000af70
     464:	1fff1424 	.word	0x1fff1424
     468:	00000000 	.word	0x00000000

0000046c <std_msgs::Time::serialize(unsigned char*) const>:
    l += 7;
    message_out[l++] = 255 - (chk % 256);

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
     46c:	6843      	ldr	r3, [r0, #4]
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
     46e:	700b      	strb	r3, [r1, #0]
     470:	6843      	ldr	r3, [r0, #4]
     472:	0a1b      	lsrs	r3, r3, #8
     474:	704b      	strb	r3, [r1, #1]
  imu_gyro.z = gyro_Z;
  IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
  imu_mag.y = my;
  imu_mag.z = mz;
     476:	88c3      	ldrh	r3, [r0, #6]
  imu_gyro.x = gyro_X;
  imu_gyro.y = gyro_Y;
  imu_gyro.z = gyro_Z;
  IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
     478:	708b      	strb	r3, [r1, #2]
     47a:	79c3      	ldrb	r3, [r0, #7]
  imu_mag.y = my;
  imu_mag.z = mz;
     47c:	70cb      	strb	r3, [r1, #3]
     47e:	6883      	ldr	r3, [r0, #8]
     480:	710b      	strb	r3, [r1, #4]
  imu_gyro.y = gyro_Y;
  imu_gyro.z = gyro_Z;
  IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
  imu_mag.y = my;
     482:	6883      	ldr	r3, [r0, #8]
     484:	0a1b      	lsrs	r3, r3, #8
  imu_gyro.x = gyro_X;
  imu_gyro.y = gyro_Y;
  imu_gyro.z = gyro_Z;
  IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
     486:	714b      	strb	r3, [r1, #5]
     488:	8943      	ldrh	r3, [r0, #10]
     48a:	718b      	strb	r3, [r1, #6]
  imu_mag.y = my;
     48c:	7ac3      	ldrb	r3, [r0, #11]
     48e:	71cb      	strb	r3, [r1, #7]
  imu_gyro.x = gyro_X;
  imu_gyro.y = gyro_Y;
  imu_gyro.z = gyro_Z;
  IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
     490:	2008      	movs	r0, #8
     492:	4770      	bx	lr

00000494 <std_msgs::Time::deserialize(unsigned char*)>:
  imu_mag.y = my;
  imu_mag.z = mz;
     494:	780b      	ldrb	r3, [r1, #0]
     496:	6043      	str	r3, [r0, #4]
    msg_(msg),
    endpoint_(endpoint) {};

  int publish(const Msg * msg)
  {
    return nh_->publish(id_, msg);
     498:	784a      	ldrb	r2, [r1, #1]
  imu_gyro.x = gyro_X;
  imu_gyro.y = gyro_Y;
  imu_gyro.z = gyro_Z;
  IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
     49a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  imu_mag.y = my;
     49e:	6043      	str	r3, [r0, #4]
     4a0:	788a      	ldrb	r2, [r1, #2]
     4a2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  imu_gyro.x = gyro_X;
  imu_gyro.y = gyro_Y;
  imu_gyro.z = gyro_Z;
  IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
     4a6:	6043      	str	r3, [r0, #4]
  imu_mag.y = my;
  imu_mag.z = mz;
     4a8:	78ca      	ldrb	r2, [r1, #3]
     4aa:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  imu_gyro.y = gyro_Y;
  imu_gyro.z = gyro_Z;
  IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
  imu_mag.y = my;
     4ae:	6043      	str	r3, [r0, #4]
     4b0:	790b      	ldrb	r3, [r1, #4]
  imu_mag.z = mz;
     4b2:	6083      	str	r3, [r0, #8]
     4b4:	794a      	ldrb	r2, [r1, #5]
  imu_gyro.y = gyro_Y;
  imu_gyro.z = gyro_Z;
  IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
  imu_mag.y = my;
     4b6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
     4ba:	6083      	str	r3, [r0, #8]
     4bc:	798a      	ldrb	r2, [r1, #6]
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
     4be:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
     4c2:	6083      	str	r3, [r0, #8]
     4c4:	79ca      	ldrb	r2, [r1, #7]
     4c6:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
     4ca:	6083      	str	r3, [r0, #8]
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
     4cc:	2008      	movs	r0, #8
     4ce:	4770      	bx	lr

000004d0 <std_msgs::Time::getType()>:

    int16_t exp = ((val >> 23) & 255);
     4d0:	4800      	ldr	r0, [pc, #0]	; (4d4 <std_msgs::Time::getType()+0x4>)
     4d2:	4770      	bx	lr
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
     4d4:	0000a8ec 	.word	0x0000a8ec

000004d8 <std_msgs::Time::getMD5()>:
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
     4d8:	4800      	ldr	r0, [pc, #0]	; (4dc <std_msgs::Time::getMD5()+0x4>)

    if (exp == 255)
     4da:	4770      	bx	lr
     4dc:	0000a8fc 	.word	0x0000a8fc

000004e0 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)>:
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
     4e0:	b5f0      	push	{r4, r5, r6, r7, lr}
     4e2:	460c      	mov	r4, r1
    {
      exp += 1023 - 127; // Normal case
     4e4:	780a      	ldrb	r2, [r1, #0]
     4e6:	8082      	strh	r2, [r0, #4]
     4e8:	4606      	mov	r6, r0
     4ea:	f814 0f01 	ldrb.w	r0, [r4, #1]!
     4ee:	2300      	movs	r3, #0
     4f0:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
     4f4:	80b2      	strh	r2, [r6, #4]
     4f6:	461a      	mov	r2, r3
     4f8:	f814 0f01 	ldrb.w	r0, [r4, #1]!
     4fc:	4098      	lsls	r0, r3
     4fe:	3308      	adds	r3, #8
     500:	2b20      	cmp	r3, #32
     502:	ea42 0200 	orr.w	r2, r2, r0
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
     506:	d1f7      	bne.n	4f8 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x18>
     508:	1d97      	adds	r7, r2, #6
     50a:	2f06      	cmp	r7, #6
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
     50c:	d958      	bls.n	5c0 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0xe0>
     50e:	f101 0e05 	add.w	lr, r1, #5
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
     512:	1d55      	adds	r5, r2, #5
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     514:	4673      	mov	r3, lr
     516:	194c      	adds	r4, r1, r5
     518:	f813 0f01 	ldrb.w	r0, [r3, #1]!
     51c:	f803 0c01 	strb.w	r0, [r3, #-1]
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
     520:	42a3      	cmp	r3, r4
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     522:	d1f9      	bne.n	518 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x38>
     524:	2300      	movs	r3, #0
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
     526:	554b      	strb	r3, [r1, r5]
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
     528:	4618      	mov	r0, r3
     52a:	440d      	add	r5, r1
    *(outbuffer++) = (mantissa >> 3) & 0xff;
     52c:	f8c6 e008 	str.w	lr, [r6, #8]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
     530:	f815 4f01 	ldrb.w	r4, [r5, #1]!
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     534:	4084      	lsls	r4, r0
     536:	3008      	adds	r0, #8
    *(outbuffer++) = 0;
     538:	2820      	cmp	r0, #32
     53a:	ea43 0304 	orr.w	r3, r3, r4
    *(outbuffer++) = 0;
     53e:	d1f7      	bne.n	530 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x50>
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
     540:	1d38      	adds	r0, r7, #4
     542:	4403      	add	r3, r0

    if (exp == 255)
     544:	4283      	cmp	r3, r0
     546:	d909      	bls.n	55c <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x7c>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
     548:	3209      	adds	r2, #9
     54a:	440a      	add	r2, r1
     54c:	4604      	mov	r4, r0
    {
      exp += 1023 - 127; // Normal case
     54e:	3401      	adds	r4, #1
     550:	f812 5f01 	ldrb.w	r5, [r2, #1]!
     554:	f802 5c01 	strb.w	r5, [r2, #-1]
     558:	42a3      	cmp	r3, r4
     55a:	d8f8      	bhi.n	54e <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x6e>
     55c:	3801      	subs	r0, #1
     55e:	18cf      	adds	r7, r1, r3
     560:	2400      	movs	r4, #0
     562:	4408      	add	r0, r1
     564:	f807 4c01 	strb.w	r4, [r7, #-1]
     568:	4622      	mov	r2, r4
     56a:	60f0      	str	r0, [r6, #12]
     56c:	f817 5b01 	ldrb.w	r5, [r7], #1
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
     570:	4095      	lsls	r5, r2
     572:	3208      	adds	r2, #8
     574:	2a20      	cmp	r2, #32
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
     576:	ea44 0405 	orr.w	r4, r4, r5
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
     57a:	d1f7      	bne.n	56c <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x8c>
     57c:	1d18      	adds	r0, r3, #4
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     57e:	4404      	add	r4, r0
     580:	42a0      	cmp	r0, r4
     582:	d209      	bcs.n	598 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0xb8>
     584:	3303      	adds	r3, #3
     586:	440b      	add	r3, r1
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
     588:	4602      	mov	r2, r0
     58a:	3201      	adds	r2, #1
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     58c:	f813 5f01 	ldrb.w	r5, [r3, #1]!
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
     590:	f803 5c01 	strb.w	r5, [r3, #-1]
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
     594:	42a2      	cmp	r2, r4
    *(outbuffer++) = (mantissa >> 3) & 0xff;
     596:	d3f8      	bcc.n	58a <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0xaa>
     598:	190d      	adds	r5, r1, r4
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
     59a:	3801      	subs	r0, #1
     59c:	4408      	add	r0, r1
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     59e:	2300      	movs	r3, #0
     5a0:	f805 3c01 	strb.w	r3, [r5, #-1]
    *(outbuffer++) = 0;
     5a4:	6130      	str	r0, [r6, #16]
    *(outbuffer++) = 0;
     5a6:	78a8      	ldrb	r0, [r5, #2]
     5a8:	786b      	ldrb	r3, [r5, #1]
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
     5aa:	5d0a      	ldrb	r2, [r1, r4]
     5ac:	78ed      	ldrb	r5, [r5, #3]

    if (exp == 255)
     5ae:	0401      	lsls	r1, r0, #16
     5b0:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
     5b4:	4313      	orrs	r3, r2
     5b6:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
    {
      exp += 1023 - 127; // Normal case
     5ba:	1d20      	adds	r0, r4, #4
     5bc:	6173      	str	r3, [r6, #20]
     5be:	bdf0      	pop	{r4, r5, r6, r7, pc}
     5c0:	1d55      	adds	r5, r2, #5
     5c2:	f101 0e05 	add.w	lr, r1, #5
     5c6:	e7ad      	b.n	524 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x44>

000005c8 <rosserial_msgs::TopicInfo::getType()>:
     5c8:	4800      	ldr	r0, [pc, #0]	; (5cc <rosserial_msgs::TopicInfo::getType()+0x4>)
     5ca:	4770      	bx	lr
     5cc:	0000a920 	.word	0x0000a920

000005d0 <rosserial_msgs::TopicInfo::getMD5()>:
     5d0:	4800      	ldr	r0, [pc, #0]	; (5d4 <rosserial_msgs::TopicInfo::getMD5()+0x4>)
     5d2:	4770      	bx	lr
     5d4:	0000a93c 	.word	0x0000a93c

000005d8 <rosserial_msgs::Log::deserialize(unsigned char*)>:
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
     5d8:	780b      	ldrb	r3, [r1, #0]
     5da:	b4f0      	push	{r4, r5, r6, r7}
     5dc:	7103      	strb	r3, [r0, #4]
     5de:	2300      	movs	r3, #0
    {
      *(outbuffer - 1) |= 0x80;
     5e0:	4606      	mov	r6, r0
     5e2:	460c      	mov	r4, r1
     5e4:	461d      	mov	r5, r3
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
     5e6:	f814 2f01 	ldrb.w	r2, [r4, #1]!
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
     5ea:	409a      	lsls	r2, r3
     5ec:	3308      	adds	r3, #8

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
     5ee:	2b20      	cmp	r3, #32
    message_out[1] = PROTOCOL_VER;
     5f0:	ea45 0502 	orr.w	r5, r5, r2
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     5f4:	d1f7      	bne.n	5e6 <rosserial_msgs::Log::deserialize(unsigned char*)+0xe>
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
     5f6:	1d68      	adds	r0, r5, #5
     5f8:	2805      	cmp	r0, #5
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     5fa:	f101 0704 	add.w	r7, r1, #4
    message_out[2] = (uint8_t)((uint16_t)l & 255);
     5fe:	d908      	bls.n	612 <rosserial_msgs::Log::deserialize(unsigned char*)+0x3a>
     600:	1d2c      	adds	r4, r5, #4
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
     602:	463b      	mov	r3, r7

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
     604:	440c      	add	r4, r1
     606:	f813 2f01 	ldrb.w	r2, [r3, #1]!
    message_out[1] = PROTOCOL_VER;
     60a:	f803 2c01 	strb.w	r2, [r3, #-1]
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
     60e:	429c      	cmp	r4, r3
    message_out[6] = (uint8_t)((int16_t)id >> 8);
     610:	d1f9      	bne.n	606 <rosserial_msgs::Log::deserialize(unsigned char*)+0x2e>
     612:	440d      	add	r5, r1
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
     614:	2300      	movs	r3, #0
     616:	712b      	strb	r3, [r5, #4]
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
     618:	60b7      	str	r7, [r6, #8]
     61a:	bcf0      	pop	{r4, r5, r6, r7}

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
     61c:	4770      	bx	lr
     61e:	bf00      	nop

00000620 <rosserial_msgs::Log::getType()>:
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     620:	4800      	ldr	r0, [pc, #0]	; (624 <rosserial_msgs::Log::getType()+0x4>)
     622:	4770      	bx	lr
    *(outbuffer++) = 0;
     624:	0000a960 	.word	0x0000a960

00000628 <rosserial_msgs::Log::getMD5()>:
    *(outbuffer++) = 0;
     628:	4800      	ldr	r0, [pc, #0]	; (62c <rosserial_msgs::Log::getMD5()+0x4>)
     62a:	4770      	bx	lr
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
     62c:	0000a974 	.word	0x0000a974

00000630 <rosserial_msgs::RequestParamResponse::getType()>:
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
     630:	4800      	ldr	r0, [pc, #0]	; (634 <rosserial_msgs::RequestParamResponse::getType()+0x4>)
     632:	4770      	bx	lr
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
     634:	0000a8d0 	.word	0x0000a8d0

00000638 <rosserial_msgs::RequestParamResponse::getMD5()>:
     638:	4800      	ldr	r0, [pc, #0]	; (63c <rosserial_msgs::RequestParamResponse::getMD5()+0x4>)
     63a:	4770      	bx	lr
     63c:	0000a998 	.word	0x0000a998

00000640 <std_msgs::Int16::serialize(unsigned char*) const>:
     640:	f9b0 3004 	ldrsh.w	r3, [r0, #4]
     644:	700b      	strb	r3, [r1, #0]
     646:	f3c3 2207 	ubfx	r2, r3, #8, #8
     64a:	704a      	strb	r2, [r1, #1]
     64c:	2002      	movs	r0, #2
     64e:	4770      	bx	lr

00000650 <std_msgs::Int16::deserialize(unsigned char*)>:
     650:	784a      	ldrb	r2, [r1, #1]
     652:	780b      	ldrb	r3, [r1, #0]
     654:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
     658:	8083      	strh	r3, [r0, #4]
     65a:	2002      	movs	r0, #2
     65c:	4770      	bx	lr
     65e:	bf00      	nop

00000660 <std_msgs::Int16::getType()>:
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
     660:	4800      	ldr	r0, [pc, #0]	; (664 <std_msgs::Int16::getType()+0x4>)
      chk += message_out[i];
     662:	4770      	bx	lr
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
     664:	0000a9bc 	.word	0x0000a9bc

00000668 <std_msgs::Int16::getMD5()>:
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
     668:	4800      	ldr	r0, [pc, #0]	; (66c <std_msgs::Int16::getMD5()+0x4>)
     66a:	4770      	bx	lr
     66c:	0000a9cc 	.word	0x0000a9cc

00000670 <std_msgs::Float32::serialize(unsigned char*) const>:
      iostream->begin(baud_);
    }

    int read(){return iostream->read();};
    void write(uint8_t* data, int length){
      iostream->write(data, length);
     670:	6843      	ldr	r3, [r0, #4]
     672:	700b      	strb	r3, [r1, #0]
     674:	b410      	push	{r4}

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
     676:	0c18      	lsrs	r0, r3, #16
     678:	0a1c      	lsrs	r4, r3, #8
     67a:	0e1a      	lsrs	r2, r3, #24
     67c:	704c      	strb	r4, [r1, #1]
     67e:	7088      	strb	r0, [r1, #2]
     680:	70ca      	strb	r2, [r1, #3]
     682:	2004      	movs	r0, #4
     684:	f85d 4b04 	ldr.w	r4, [sp], #4
     688:	4770      	bx	lr
     68a:	bf00      	nop

0000068c <std_msgs::Float32::deserialize(unsigned char*)>:
  imu_mag.z = mz;
  IMU_data_mag.publish(&imu_mag);
  measured_angle = atan2(my - mag_y_cal, mx - mag_x_cal) * 180 / pi;
     68c:	b410      	push	{r4}
     68e:	784c      	ldrb	r4, [r1, #1]
     690:	780a      	ldrb	r2, [r1, #0]
     692:	788b      	ldrb	r3, [r1, #2]
     694:	78c9      	ldrb	r1, [r1, #3]
     696:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
     69a:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
     69e:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
     6a2:	6043      	str	r3, [r0, #4]
     6a4:	f85d 4b04 	ldr.w	r4, [sp], #4
     6a8:	2004      	movs	r0, #4
     6aa:	4770      	bx	lr

000006ac <std_msgs::Float32::getType()>:
     6ac:	4800      	ldr	r0, [pc, #0]	; (6b0 <std_msgs::Float32::getType()+0x4>)
     6ae:	4770      	bx	lr
     6b0:	0000a9f0 	.word	0x0000a9f0

000006b4 <std_msgs::Float32::getMD5()>:
     6b4:	4800      	ldr	r0, [pc, #0]	; (6b8 <std_msgs::Float32::getMD5()+0x4>)
     6b6:	4770      	bx	lr
     6b8:	0000aa04 	.word	0x0000aa04

000006bc <geometry_msgs::Vector3::getType()>:
     6bc:	4800      	ldr	r0, [pc, #0]	; (6c0 <geometry_msgs::Vector3::getType()+0x4>)
     6be:	4770      	bx	lr
     6c0:	0000aa28 	.word	0x0000aa28

000006c4 <geometry_msgs::Vector3::getMD5()>:
     6c4:	4800      	ldr	r0, [pc, #0]	; (6c8 <geometry_msgs::Vector3::getMD5()+0x4>)
     6c6:	4770      	bx	lr
     6c8:	0000aa40 	.word	0x0000aa40

000006cc <geometry_msgs::Quaternion::getType()>:
     6cc:	4800      	ldr	r0, [pc, #0]	; (6d0 <geometry_msgs::Quaternion::getType()+0x4>)
     6ce:	4770      	bx	lr
     6d0:	0000aa64 	.word	0x0000aa64

000006d4 <geometry_msgs::Quaternion::getMD5()>:
  data_measured_angle.x = mx;
     6d4:	4800      	ldr	r0, [pc, #0]	; (6d8 <geometry_msgs::Quaternion::getMD5()+0x4>)
  data_measured_angle.y = reference_angle;
     6d6:	4770      	bx	lr
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
  imu_mag.y = my;
  imu_mag.z = mz;
  IMU_data_mag.publish(&imu_mag);
  measured_angle = atan2(my - mag_y_cal, mx - mag_x_cal) * 180 / pi;
     6d8:	0000aa80 	.word	0x0000aa80

000006dc <geometry_msgs::Twist::getType()>:
     6dc:	4800      	ldr	r0, [pc, #0]	; (6e0 <geometry_msgs::Twist::getType()+0x4>)
  data_measured_angle.x = mx;
  data_measured_angle.y = reference_angle;
     6de:	4770      	bx	lr
     6e0:	0000aaa4 	.word	0x0000aaa4

000006e4 <geometry_msgs::Twist::getMD5()>:
     6e4:	4800      	ldr	r0, [pc, #0]	; (6e8 <geometry_msgs::Twist::getMD5()+0x4>)
     6e6:	4770      	bx	lr
  // data from the magnetometer that is calibrated and turned into a heading
  imu_mag.x = mx;
  imu_mag.y = my;
  imu_mag.z = mz;
  IMU_data_mag.publish(&imu_mag);
  measured_angle = atan2(my - mag_y_cal, mx - mag_x_cal) * 180 / pi;
     6e8:	0000aab8 	.word	0x0000aab8

000006ec <ros::Subscriber<std_msgs::Int16, void>::callback(unsigned char*)>:
  data_measured_angle.x = mx;
     6ec:	b410      	push	{r4}
     6ee:	780b      	ldrb	r3, [r1, #0]
     6f0:	784c      	ldrb	r4, [r1, #1]
     6f2:	6942      	ldr	r2, [r0, #20]
     6f4:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
  data_measured_angle.y = reference_angle;
     6f8:	8203      	strh	r3, [r0, #16]
     6fa:	f85d 4b04 	ldr.w	r4, [sp], #4
  data_measured_angle.z = measured_angle;
     6fe:	300c      	adds	r0, #12
  imu_mag.x = mx;
  imu_mag.y = my;
  imu_mag.z = mz;
  IMU_data_mag.publish(&imu_mag);
  measured_angle = atan2(my - mag_y_cal, mx - mag_x_cal) * 180 / pi;
  data_measured_angle.x = mx;
     700:	4710      	bx	r2
     702:	bf00      	nop

00000704 <ros::Subscriber<std_msgs::Int16, void>::getEndpointType()>:
     704:	6980      	ldr	r0, [r0, #24]
     706:	4770      	bx	lr

00000708 <ros::Subscriber<std_msgs::Int16, void>::getMsgType()>:
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
     708:	4800      	ldr	r0, [pc, #0]	; (70c <ros::Subscriber<std_msgs::Int16, void>::getMsgType()+0x4>)
     70a:	4770      	bx	lr
     70c:	0000a9bc 	.word	0x0000a9bc

00000710 <ros::Subscriber<std_msgs::Int16, void>::getMsgMD5()>:
     710:	4800      	ldr	r0, [pc, #0]	; (714 <ros::Subscriber<std_msgs::Int16, void>::getMsgMD5()+0x4>)
     712:	4770      	bx	lr
     714:	0000a9cc 	.word	0x0000a9cc

00000718 <ros::Subscriber<geometry_msgs::Twist, void>::getEndpointType()>:
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
     718:	6b40      	ldr	r0, [r0, #52]	; 0x34

    int16_t exp = ((val >> 23) & 255);
     71a:	4770      	bx	lr

0000071c <ros::Subscriber<geometry_msgs::Twist, void>::getMsgType()>:
     71c:	4800      	ldr	r0, [pc, #0]	; (720 <ros::Subscriber<geometry_msgs::Twist, void>::getMsgType()+0x4>)
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
     71e:	4770      	bx	lr
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
     720:	0000aaa4 	.word	0x0000aaa4

00000724 <ros::Subscriber<geometry_msgs::Twist, void>::getMsgMD5()>:

    if (exp == 255)
     724:	4800      	ldr	r0, [pc, #0]	; (728 <ros::Subscriber<geometry_msgs::Twist, void>::getMsgMD5()+0x4>)
     726:	4770      	bx	lr
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
     728:	0000aab8 	.word	0x0000aab8

0000072c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::connected()>:
     72c:	f890 04f8 	ldrb.w	r0, [r0, #1272]	; 0x4f8
    {
      exp += 1023 - 127; // Normal case
     730:	4770      	bx	lr
     732:	bf00      	nop
     734:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

00000738 <encoder_count_chage_right()>:
     738:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     73a:	f005 fe09 	bl	6350 <micros>
     73e:	4c50      	ldr	r4, [pc, #320]	; (880 <encoder_count_chage_right()+0x148>)
     740:	4d50      	ldr	r5, [pc, #320]	; (884 <encoder_count_chage_right()+0x14c>)
     742:	f008 fae7 	bl	8d14 <__aeabi_ui2d>
     746:	a34c      	add	r3, pc, #304	; (adr r3, 878 <encoder_count_chage_right()+0x140>)
     748:	e9d3 2300 	ldrd	r2, r3, [r3]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
     74c:	f008 fc82 	bl	9054 <__aeabi_ddiv>
     750:	e9d4 2300 	ldrd	r2, r3, [r4]
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
     754:	f008 f9a0 	bl	8a98 <__aeabi_dsub>
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
     758:	e9c5 0100 	strd	r0, r1, [r5]
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     75c:	f005 fdf8 	bl	6350 <micros>
     760:	f008 fad8 	bl	8d14 <__aeabi_ui2d>
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
     764:	a344      	add	r3, pc, #272	; (adr r3, 878 <encoder_count_chage_right()+0x140>)
     766:	e9d3 2300 	ldrd	r2, r3, [r3]
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
     76a:	f008 fc73 	bl	9054 <__aeabi_ddiv>
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
     76e:	4b46      	ldr	r3, [pc, #280]	; (888 <encoder_count_chage_right()+0x150>)
    *(outbuffer++) = (mantissa >> 3) & 0xff;
     770:	e9d3 6700 	ldrd	r6, r7, [r3]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
     774:	e9c4 0100 	strd	r0, r1, [r4]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     778:	2200      	movs	r2, #0
     77a:	4b44      	ldr	r3, [pc, #272]	; (88c <encoder_count_chage_right()+0x154>)
    *(outbuffer++) = 0;
     77c:	4630      	mov	r0, r6
     77e:	4639      	mov	r1, r7
    *(outbuffer++) = 0;
     780:	f008 fdb0 	bl	92e4 <__aeabi_dcmplt>
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
     784:	b138      	cbz	r0, 796 <encoder_count_chage_right()+0x5e>
     786:	4630      	mov	r0, r6

    if (exp == 255)
     788:	4639      	mov	r1, r7
     78a:	2200      	movs	r2, #0
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
     78c:	4b40      	ldr	r3, [pc, #256]	; (890 <encoder_count_chage_right()+0x158>)
     78e:	f008 fdc7 	bl	9320 <__aeabi_dcmpgt>
    {
      exp += 1023 - 127; // Normal case
     792:	2800      	cmp	r0, #0
     794:	d14e      	bne.n	834 <encoder_count_chage_right()+0xfc>
     796:	4b3f      	ldr	r3, [pc, #252]	; (894 <encoder_count_chage_right()+0x15c>)
     798:	edd3 7a00 	vldr	s15, [r3]
     79c:	4a3e      	ldr	r2, [pc, #248]	; (898 <encoder_count_chage_right()+0x160>)
     79e:	4b3f      	ldr	r3, [pc, #252]	; (89c <encoder_count_chage_right()+0x164>)
     7a0:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
     7a4:	eef4 7ac7 	vcmpe.f32	s15, s14
     7a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     7ac:	d506      	bpl.n	7bc <encoder_count_chage_right()+0x84>
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
     7ae:	eebb 7a04 	vmov.f32	s14, #180	; 0xc1a00000 -20.0
     7b2:	eef4 7ac7 	vcmpe.f32	s15, s14
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
     7b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
     7ba:	dc2b      	bgt.n	814 <encoder_count_chage_right()+0xdc>
     7bc:	edd2 6a00 	vldr	s13, [r2]
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     7c0:	edd3 7a00 	vldr	s15, [r3]
     7c4:	ed93 6a01 	vldr	s12, [r3, #4]
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
     7c8:	ed93 7a02 	vldr	s14, [r3, #8]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     7cc:	edd3 4a03 	vldr	s9, [r3, #12]
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
     7d0:	ed9f 4a33 	vldr	s8, [pc, #204]	; 8a0 <encoder_count_chage_right()+0x168>
    *(outbuffer++) = (mantissa >> 3) & 0xff;
     7d4:	4b33      	ldr	r3, [pc, #204]	; (8a4 <encoder_count_chage_right()+0x16c>)
     7d6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
     7da:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     7de:	ee87 5aa6 	vdiv.f32	s10, s15, s13
    *(outbuffer++) = 0;
     7e2:	eec6 5a26 	vdiv.f32	s11, s12, s13
    *(outbuffer++) = 0;
     7e6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
     7ea:	eef8 4ae4 	vcvt.f32.s32	s9, s9

    if (exp == 255)
     7ee:	ee87 6a26 	vdiv.f32	s12, s14, s13
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
     7f2:	ee84 7aa6 	vdiv.f32	s14, s9, s13
    {
      exp += 1023 - 127; // Normal case
     7f6:	ee75 7a04 	vadd.f32	s15, s10, s8
     7fa:	eef5 6a00 	vmov.f32	s13, #80	; 0x3e800000  0.250
     7fe:	ee75 7aa7 	vadd.f32	s15, s11, s15
     802:	ee76 7a27 	vadd.f32	s15, s12, s15
     806:	ee77 7a27 	vadd.f32	s15, s14, s15
     80a:	ee67 7aa6 	vmul.f32	s15, s15, s13
     80e:	edc3 7a00 	vstr	s15, [r3]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
     812:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     814:	edd2 6a00 	vldr	s13, [r2]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     818:	681c      	ldr	r4, [r3, #0]
     81a:	1d18      	adds	r0, r3, #4
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     81c:	c807      	ldmia	r0, {r0, r1, r2}
     81e:	ee66 7aa7 	vmul.f32	s15, s13, s15
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
     822:	605c      	str	r4, [r3, #4]
     824:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    *(outbuffer++) = (mantissa >> 3) & 0xff;
     828:	6098      	str	r0, [r3, #8]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
     82a:	60d9      	str	r1, [r3, #12]
     82c:	edc3 7a00 	vstr	s15, [r3]
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
     830:	611a      	str	r2, [r3, #16]
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
     832:	e7c7      	b.n	7c4 <encoder_count_chage_right()+0x8c>
    message_out[5] = (uint8_t)((int16_t)id & 255);
     834:	4b1c      	ldr	r3, [pc, #112]	; (8a8 <encoder_count_chage_right()+0x170>)
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     836:	681b      	ldr	r3, [r3, #0]
     838:	2b01      	cmp	r3, #1
    message_out[6] = (uint8_t)((int16_t)id >> 8);
     83a:	d015      	beq.n	868 <encoder_count_chage_right()+0x130>
     83c:	2b00      	cmp	r3, #0
    *(outbuffer++) = 0;
     83e:	d1aa      	bne.n	796 <encoder_count_chage_right()+0x5e>
     840:	4b1a      	ldr	r3, [pc, #104]	; (8ac <encoder_count_chage_right()+0x174>)
    *(outbuffer++) = 0;
     842:	4e1b      	ldr	r6, [pc, #108]	; (8b0 <encoder_count_chage_right()+0x178>)
     844:	e893 0005 	ldmia.w	r3, {r0, r2}
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     848:	6833      	ldr	r3, [r6, #0]

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
     84a:	f102 4100 	add.w	r1, r2, #2147483648	; 0x80000000
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
     84e:	1e5c      	subs	r4, r3, #1
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
     850:	e9d5 2300 	ldrd	r2, r3, [r5]
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
     854:	6034      	str	r4, [r6, #0]
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
     856:	f008 fbfd 	bl	9054 <__aeabi_ddiv>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
     85a:	f008 fda9 	bl	93b0 <__aeabi_d2f>
    message_out[1] = PROTOCOL_VER;
     85e:	4b0d      	ldr	r3, [pc, #52]	; (894 <encoder_count_chage_right()+0x15c>)
     860:	ee07 0a90 	vmov	s15, r0
    message_out[2] = (uint8_t)((uint16_t)l & 255);
     864:	6018      	str	r0, [r3, #0]
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
     866:	e799      	b.n	79c <encoder_count_chage_right()+0x64>
     868:	4e11      	ldr	r6, [pc, #68]	; (8b0 <encoder_count_chage_right()+0x178>)
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
     86a:	4a10      	ldr	r2, [pc, #64]	; (8ac <encoder_count_chage_right()+0x174>)
     86c:	6833      	ldr	r3, [r6, #0]
     86e:	e9d2 0100 	ldrd	r0, r1, [r2]
     872:	1c5c      	adds	r4, r3, #1
     874:	e7ec      	b.n	850 <encoder_count_chage_right()+0x118>
     876:	bf00      	nop
     878:	00000000 	.word	0x00000000
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
     87c:	412e8480 	.word	0x412e8480
     880:	1fff1d70 	.word	0x1fff1d70
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
     884:	1fff1460 	.word	0x1fff1460
     888:	1fff1d60 	.word	0x1fff1d60
     88c:	409e0000 	.word	0x409e0000
     890:	c09e0000 	.word	0xc09e0000

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
     894:	1fff2b18 	.word	0x1fff2b18
     898:	1fff0820 	.word	0x1fff0820
  data_measured_angle.y = reference_angle;
  data_measured_angle.z = measured_angle;
  measured_angle_pub.publish(&data_measured_angle);

}
     89c:	1fff22c0 	.word	0x1fff22c0
     8a0:	00000000 	.word	0x00000000
     8a4:	1fff148c 	.word	0x1fff148c
     8a8:	1fff22bc 	.word	0x1fff22bc
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     8ac:	1fff0818 	.word	0x1fff0818
     8b0:	1fff1488 	.word	0x1fff1488
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     8b4:	ffffffff 	.word	0xffffffff

000008b8 <encoder_count_chage_left()>:
     8b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     8ba:	f005 fd49 	bl	6350 <micros>
     8be:	4c50      	ldr	r4, [pc, #320]	; (a00 <encoder_count_chage_left()+0x148>)
     8c0:	4d50      	ldr	r5, [pc, #320]	; (a04 <encoder_count_chage_left()+0x14c>)
      {
          mantissa <<= 1;
     8c2:	f008 fa27 	bl	8d14 <__aeabi_ui2d>
     8c6:	a34c      	add	r3, pc, #304	; (adr r3, 9f8 <encoder_count_chage_left()+0x140>)
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     8c8:	e9d3 2300 	ldrd	r2, r3, [r3]
     8cc:	f008 fbc2 	bl	9054 <__aeabi_ddiv>
     8d0:	e9d4 2300 	ldrd	r2, r3, [r4]
     8d4:	f008 f8e0 	bl	8a98 <__aeabi_dsub>
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     8d8:	e9c5 0100 	strd	r0, r1, [r5]
     8dc:	f005 fd38 	bl	6350 <micros>
     8e0:	f008 fa18 	bl	8d14 <__aeabi_ui2d>
     8e4:	a344      	add	r3, pc, #272	; (adr r3, 9f8 <encoder_count_chage_left()+0x140>)
     8e6:	e9d3 2300 	ldrd	r2, r3, [r3]
     8ea:	f008 fbb3 	bl	9054 <__aeabi_ddiv>
     8ee:	4b46      	ldr	r3, [pc, #280]	; (a08 <encoder_count_chage_left()+0x150>)
     8f0:	e9d3 6700 	ldrd	r6, r7, [r3]
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     8f4:	e9c4 0100 	strd	r0, r1, [r4]
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
     8f8:	2200      	movs	r2, #0
      while (!(mantissa & 0x800000))
     8fa:	4b44      	ldr	r3, [pc, #272]	; (a0c <encoder_count_chage_left()+0x154>)
     8fc:	4630      	mov	r0, r6
     8fe:	4639      	mov	r1, r7
     900:	f008 fcf0 	bl	92e4 <__aeabi_dcmplt>
     904:	b138      	cbz	r0, 916 <encoder_count_chage_left()+0x5e>
      {
          mantissa <<= 1;
     906:	4630      	mov	r0, r6
     908:	4639      	mov	r1, r7
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     90a:	2200      	movs	r2, #0
     90c:	4b40      	ldr	r3, [pc, #256]	; (a10 <encoder_count_chage_left()+0x158>)
     90e:	f008 fd07 	bl	9320 <__aeabi_dcmpgt>
     912:	2800      	cmp	r0, #0
     914:	d14e      	bne.n	9b4 <encoder_count_chage_left()+0xfc>
     916:	4b3f      	ldr	r3, [pc, #252]	; (a14 <encoder_count_chage_left()+0x15c>)
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     918:	edd3 7a00 	vldr	s15, [r3]
     91c:	4a3e      	ldr	r2, [pc, #248]	; (a18 <encoder_count_chage_left()+0x160>)
     91e:	4b3f      	ldr	r3, [pc, #252]	; (a1c <encoder_count_chage_left()+0x164>)
     920:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
     924:	eef4 7ac7 	vcmpe.f32	s15, s14
     928:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     92c:	d506      	bpl.n	93c <encoder_count_chage_left()+0x84>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     92e:	eebb 7a04 	vmov.f32	s14, #180	; 0xc1a00000 -20.0
     932:	eef4 7ac7 	vcmpe.f32	s15, s14
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     936:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     93a:	dc2b      	bgt.n	994 <encoder_count_chage_left()+0xdc>
     93c:	edd2 6a00 	vldr	s13, [r2]
     940:	edd3 7a00 	vldr	s15, [r3]
      {
          mantissa <<= 1;
     944:	ed93 6a01 	vldr	s12, [r3, #4]
     948:	ed93 7a02 	vldr	s14, [r3, #8]
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     94c:	edd3 4a03 	vldr	s9, [r3, #12]
     950:	ed9f 4a33 	vldr	s8, [pc, #204]	; a20 <encoder_count_chage_left()+0x168>
     954:	4b33      	ldr	r3, [pc, #204]	; (a24 <encoder_count_chage_left()+0x16c>)
     956:	eef8 7ae7 	vcvt.f32.s32	s15, s15
     95a:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
     95e:	ee87 5aa6 	vdiv.f32	s10, s15, s13
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     962:	eec6 5a26 	vdiv.f32	s11, s12, s13
     966:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
     96a:	eef8 4ae4 	vcvt.f32.s32	s9, s9
     96e:	ee87 6a26 	vdiv.f32	s12, s14, s13
     972:	ee84 7aa6 	vdiv.f32	s14, s9, s13
     976:	ee75 7a04 	vadd.f32	s15, s10, s8
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     97a:	eef5 6a00 	vmov.f32	s13, #80	; 0x3e800000  0.250
     97e:	ee75 7aa7 	vadd.f32	s15, s11, s15
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     982:	ee76 7a27 	vadd.f32	s15, s12, s15
     986:	ee77 7a27 	vadd.f32	s15, s14, s15
     98a:	ee67 7aa6 	vmul.f32	s15, s15, s13
     98e:	edc3 7a00 	vstr	s15, [r3]
      {
          mantissa <<= 1;
     992:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     994:	edd2 6a00 	vldr	s13, [r2]
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     998:	681c      	ldr	r4, [r3, #0]
     99a:	1d18      	adds	r0, r3, #4
     99c:	c807      	ldmia	r0, {r0, r1, r2}
     99e:	ee66 7aa7 	vmul.f32	s15, s13, s15
     9a2:	605c      	str	r4, [r3, #4]
     9a4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     9a8:	6098      	str	r0, [r3, #8]
     9aa:	60d9      	str	r1, [r3, #12]
     9ac:	edc3 7a00 	vstr	s15, [r3]
     9b0:	611a      	str	r2, [r3, #16]
     9b2:	e7c7      	b.n	944 <encoder_count_chage_left()+0x8c>
     9b4:	4b1c      	ldr	r3, [pc, #112]	; (a28 <encoder_count_chage_left()+0x170>)
     9b6:	681b      	ldr	r3, [r3, #0]
     9b8:	2b01      	cmp	r3, #1
     9ba:	d015      	beq.n	9e8 <encoder_count_chage_left()+0x130>
     9bc:	2b00      	cmp	r3, #0
     9be:	d1aa      	bne.n	916 <encoder_count_chage_left()+0x5e>
     9c0:	4b1a      	ldr	r3, [pc, #104]	; (a2c <encoder_count_chage_left()+0x174>)
     9c2:	4e1b      	ldr	r6, [pc, #108]	; (a30 <encoder_count_chage_left()+0x178>)
     9c4:	e893 0005 	ldmia.w	r3, {r0, r2}
     9c8:	6833      	ldr	r3, [r6, #0]
     9ca:	f102 4100 	add.w	r1, r2, #2147483648	; 0x80000000
     9ce:	1e5c      	subs	r4, r3, #1
     9d0:	e9d5 2300 	ldrd	r2, r3, [r5]
     9d4:	6034      	str	r4, [r6, #0]
     9d6:	f008 fb3d 	bl	9054 <__aeabi_ddiv>
     9da:	f008 fce9 	bl	93b0 <__aeabi_d2f>
     9de:	4b0d      	ldr	r3, [pc, #52]	; (a14 <encoder_count_chage_left()+0x15c>)
     9e0:	ee07 0a90 	vmov	s15, r0
     9e4:	6018      	str	r0, [r3, #0]
     9e6:	e799      	b.n	91c <encoder_count_chage_left()+0x64>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     9e8:	4e11      	ldr	r6, [pc, #68]	; (a30 <encoder_count_chage_left()+0x178>)
     9ea:	4a10      	ldr	r2, [pc, #64]	; (a2c <encoder_count_chage_left()+0x174>)
     9ec:	6833      	ldr	r3, [r6, #0]
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
     9ee:	e9d2 0100 	ldrd	r0, r1, [r2]
      while (!(mantissa & 0x800000))
     9f2:	1c5c      	adds	r4, r3, #1
     9f4:	e7ec      	b.n	9d0 <encoder_count_chage_left()+0x118>
     9f6:	bf00      	nop
     9f8:	00000000 	.word	0x00000000
     9fc:	412e8480 	.word	0x412e8480
      {
          mantissa <<= 1;
     a00:	1fff2a90 	.word	0x1fff2a90
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     a04:	1fff2af8 	.word	0x1fff2af8
     a08:	1fff1490 	.word	0x1fff1490
     a0c:	409e0000 	.word	0x409e0000
     a10:	c09e0000 	.word	0xc09e0000
     a14:	1fff1d6c 	.word	0x1fff1d6c
     a18:	1fff0820 	.word	0x1fff0820
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     a1c:	1fff14b0 	.word	0x1fff14b0
     a20:	00000000 	.word	0x00000000
     a24:	1fff1cb8 	.word	0x1fff1cb8
     a28:	1fff1d84 	.word	0x1fff1d84
     a2c:	1fff0818 	.word	0x1fff0818
     a30:	1fff2b34 	.word	0x1fff2b34

00000a34 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const>:
     a34:	6843      	ldr	r3, [r0, #4]
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     a36:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     a3a:	700b      	strb	r3, [r1, #0]
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
     a3c:	6843      	ldr	r3, [r0, #4]
      while (!(mantissa & 0x800000))
     a3e:	0a1b      	lsrs	r3, r3, #8
     a40:	704b      	strb	r3, [r1, #1]
     a42:	88c3      	ldrh	r3, [r0, #6]
     a44:	708b      	strb	r3, [r1, #2]
     a46:	79c3      	ldrb	r3, [r0, #7]
     a48:	70cb      	strb	r3, [r1, #3]
     a4a:	6843      	ldr	r3, [r0, #4]
      {
          mantissa <<= 1;
     a4c:	2b00      	cmp	r3, #0
     a4e:	f000 8085 	beq.w	b5c <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0x128>
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     a52:	460a      	mov	r2, r1
     a54:	2500      	movs	r5, #0
     a56:	2604      	movs	r6, #4
     a58:	68c3      	ldr	r3, [r0, #12]
     a5a:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
     a5e:	7113      	strb	r3, [r2, #4]
     a60:	0c1c      	lsrs	r4, r3, #16
     a62:	0a1f      	lsrs	r7, r3, #8
     a64:	0e1b      	lsrs	r3, r3, #24
     a66:	7194      	strb	r4, [r2, #6]
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     a68:	7157      	strb	r7, [r2, #5]
     a6a:	71d3      	strb	r3, [r2, #7]
     a6c:	6843      	ldr	r3, [r0, #4]
     a6e:	3501      	adds	r5, #1
     a70:	42ab      	cmp	r3, r5
     a72:	4634      	mov	r4, r6
     a74:	f102 0204 	add.w	r2, r2, #4
     a78:	f106 0604 	add.w	r6, r6, #4
     a7c:	d8ec      	bhi.n	a58 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0x24>
     a7e:	f104 0208 	add.w	r2, r4, #8
     a82:	f104 0a05 	add.w	sl, r4, #5
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     a86:	f104 0906 	add.w	r9, r4, #6
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
     a8a:	f104 0807 	add.w	r8, r4, #7
      while (!(mantissa & 0x800000))
     a8e:	f104 0c09 	add.w	ip, r4, #9
     a92:	f104 0e0a 	add.w	lr, r4, #10
     a96:	f104 050b 	add.w	r5, r4, #11
      {
          mantissa <<= 1;
     a9a:	4617      	mov	r7, r2
     a9c:	340c      	adds	r4, #12
     a9e:	6903      	ldr	r3, [r0, #16]
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     aa0:	558b      	strb	r3, [r1, r6]
     aa2:	6903      	ldr	r3, [r0, #16]
     aa4:	0a1b      	lsrs	r3, r3, #8
     aa6:	f801 300a 	strb.w	r3, [r1, sl]
     aaa:	8a43      	ldrh	r3, [r0, #18]
     aac:	f801 3009 	strb.w	r3, [r1, r9]
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     ab0:	7cc3      	ldrb	r3, [r0, #19]
     ab2:	f801 3008 	strb.w	r3, [r1, r8]
     ab6:	6903      	ldr	r3, [r0, #16]
     ab8:	b1f3      	cbz	r3, af8 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0xc4>
     aba:	eb01 0e07 	add.w	lr, r1, r7
     abe:	4675      	mov	r5, lr
     ac0:	2200      	movs	r2, #0
     ac2:	6983      	ldr	r3, [r0, #24]
     ac4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
     ac8:	f80e 3022 	strb.w	r3, [lr, r2, lsl #2]
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     acc:	0c1c      	lsrs	r4, r3, #16
     ace:	0a1e      	lsrs	r6, r3, #8
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
     ad0:	0e1b      	lsrs	r3, r3, #24
      while (!(mantissa & 0x800000))
     ad2:	70ac      	strb	r4, [r5, #2]
     ad4:	706e      	strb	r6, [r5, #1]
     ad6:	70eb      	strb	r3, [r5, #3]
     ad8:	6903      	ldr	r3, [r0, #16]
     ada:	3201      	adds	r2, #1
     adc:	4293      	cmp	r3, r2
     ade:	463c      	mov	r4, r7
      {
          mantissa <<= 1;
     ae0:	f105 0504 	add.w	r5, r5, #4
     ae4:	f107 0704 	add.w	r7, r7, #4
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     ae8:	d8eb      	bhi.n	ac2 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0x8e>
     aea:	f104 0c05 	add.w	ip, r4, #5
     aee:	f104 0e06 	add.w	lr, r4, #6
     af2:	1de5      	adds	r5, r4, #7
     af4:	463a      	mov	r2, r7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     af6:	3408      	adds	r4, #8
     af8:	69c3      	ldr	r3, [r0, #28]
     afa:	548b      	strb	r3, [r1, r2]
     afc:	69c3      	ldr	r3, [r0, #28]
     afe:	0a1b      	lsrs	r3, r3, #8
     b00:	f801 300c 	strb.w	r3, [r1, ip]
     b04:	8bc3      	ldrh	r3, [r0, #30]
     b06:	f801 300e 	strb.w	r3, [r1, lr]
     b0a:	7fc3      	ldrb	r3, [r0, #31]
     b0c:	554b      	strb	r3, [r1, r5]
     b0e:	69c3      	ldr	r3, [r0, #28]
     b10:	b30b      	cbz	r3, b56 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0x122>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     b12:	460f      	mov	r7, r1
     b14:	4680      	mov	r8, r0
     b16:	2600      	movs	r6, #0
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
     b18:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
      while (!(mantissa & 0x800000))
     b1c:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
     b20:	f009 fc2e 	bl	a380 <strlen>
     b24:	00b1      	lsls	r1, r6, #2
     b26:	4605      	mov	r5, r0
      {
          mantissa <<= 1;
     b28:	193a      	adds	r2, r7, r4
     b2a:	2300      	movs	r3, #0
     b2c:	fa25 f003 	lsr.w	r0, r5, r3
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     b30:	3308      	adds	r3, #8
     b32:	2b20      	cmp	r3, #32
     b34:	f802 0b01 	strb.w	r0, [r2], #1
     b38:	d1f8      	bne.n	b2c <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0xf8>
     b3a:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     b3e:	3404      	adds	r4, #4
     b40:	1938      	adds	r0, r7, r4
     b42:	5859      	ldr	r1, [r3, r1]
     b44:	462a      	mov	r2, r5
     b46:	f005 f817 	bl	5b78 <memcpy>
     b4a:	f8d8 301c 	ldr.w	r3, [r8, #28]
     b4e:	3601      	adds	r6, #1
     b50:	42b3      	cmp	r3, r6
     b52:	442c      	add	r4, r5
     b54:	d8e0      	bhi.n	b18 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0xe4>
     b56:	4620      	mov	r0, r4
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     b58:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     b5c:	2208      	movs	r2, #8
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
     b5e:	4617      	mov	r7, r2
      while (!(mantissa & 0x800000))
     b60:	240c      	movs	r4, #12
     b62:	250b      	movs	r5, #11
     b64:	f04f 0e0a 	mov.w	lr, #10
     b68:	f04f 0c09 	mov.w	ip, #9
     b6c:	f04f 0807 	mov.w	r8, #7
      {
          mantissa <<= 1;
     b70:	f04f 0906 	mov.w	r9, #6
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     b74:	f04f 0a05 	mov.w	sl, #5
     b78:	2604      	movs	r6, #4
     b7a:	e790      	b.n	a9e <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0x6a>

00000b7c <rosserial_msgs::Log::serialize(unsigned char*) const>:
     b7c:	b570      	push	{r4, r5, r6, lr}
     b7e:	7903      	ldrb	r3, [r0, #4]
     b80:	700b      	strb	r3, [r1, #0]
     b82:	4606      	mov	r6, r0
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     b84:	6880      	ldr	r0, [r0, #8]
     b86:	460d      	mov	r5, r1
     b88:	f009 fbfa 	bl	a380 <strlen>
     b8c:	462a      	mov	r2, r5
     b8e:	4604      	mov	r4, r0
     b90:	2300      	movs	r3, #0
     b92:	fa24 f103 	lsr.w	r1, r4, r3
     b96:	3308      	adds	r3, #8
     b98:	2b20      	cmp	r3, #32
     b9a:	f802 1f01 	strb.w	r1, [r2, #1]!
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     b9e:	d1f8      	bne.n	b92 <rosserial_msgs::Log::serialize(unsigned char*) const+0x16>
     ba0:	68b1      	ldr	r1, [r6, #8]
     ba2:	1d68      	adds	r0, r5, #5
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
     ba4:	4622      	mov	r2, r4
      while (!(mantissa & 0x800000))
     ba6:	f004 ffe7 	bl	5b78 <memcpy>
     baa:	1d60      	adds	r0, r4, #5
     bac:	bd70      	pop	{r4, r5, r6, pc}
     bae:	bf00      	nop

00000bb0 <rosserial_msgs::TopicInfo::serialize(unsigned char*) const>:
     bb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
      {
          mantissa <<= 1;
     bb2:	8883      	ldrh	r3, [r0, #4]
     bb4:	700b      	strb	r3, [r1, #0]
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     bb6:	8883      	ldrh	r3, [r0, #4]
     bb8:	0a1b      	lsrs	r3, r3, #8
     bba:	704b      	strb	r3, [r1, #1]
     bbc:	4606      	mov	r6, r0
     bbe:	6880      	ldr	r0, [r0, #8]
     bc0:	460d      	mov	r5, r1
     bc2:	f009 fbdd 	bl	a380 <strlen>
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     bc6:	0e03      	lsrs	r3, r0, #24
     bc8:	0a01      	lsrs	r1, r0, #8
     bca:	0c02      	lsrs	r2, r0, #16
     bcc:	716b      	strb	r3, [r5, #5]
     bce:	70a8      	strb	r0, [r5, #2]
     bd0:	712a      	strb	r2, [r5, #4]
     bd2:	70e9      	strb	r1, [r5, #3]
     bd4:	4602      	mov	r2, r0
     bd6:	4604      	mov	r4, r0
     bd8:	68b1      	ldr	r1, [r6, #8]
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     bda:	1da8      	adds	r0, r5, #6
     bdc:	f004 ffcc 	bl	5b78 <memcpy>
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     be0:	68f0      	ldr	r0, [r6, #12]
     be2:	f009 fbcd 	bl	a380 <strlen>
     be6:	1d61      	adds	r1, r4, #5
     be8:	4602      	mov	r2, r0
     bea:	4429      	add	r1, r5
      {
          mantissa <<= 1;
     bec:	3406      	adds	r4, #6
     bee:	2300      	movs	r3, #0
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     bf0:	fa22 f003 	lsr.w	r0, r2, r3
     bf4:	3308      	adds	r3, #8
     bf6:	2b20      	cmp	r3, #32
     bf8:	f801 0f01 	strb.w	r0, [r1, #1]!
     bfc:	d1f8      	bne.n	bf0 <rosserial_msgs::TopicInfo::serialize(unsigned char*) const+0x40>
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
     bfe:	3404      	adds	r4, #4
     c00:	1928      	adds	r0, r5, r4
     c02:	68f1      	ldr	r1, [r6, #12]
     c04:	4414      	add	r4, r2
     c06:	f004 ffb7 	bl	5b78 <memcpy>
     c0a:	6930      	ldr	r0, [r6, #16]
     c0c:	f009 fbb8 	bl	a380 <strlen>
     c10:	192a      	adds	r2, r5, r4
     c12:	4607      	mov	r7, r0
     c14:	2300      	movs	r3, #0
     c16:	fa27 f103 	lsr.w	r1, r7, r3
     c1a:	3308      	adds	r3, #8
     c1c:	2b20      	cmp	r3, #32
     c1e:	f802 1b01 	strb.w	r1, [r2], #1
     c22:	d1f8      	bne.n	c16 <rosserial_msgs::TopicInfo::serialize(unsigned char*) const+0x66>
     c24:	3404      	adds	r4, #4
     c26:	1928      	adds	r0, r5, r4
     c28:	463a      	mov	r2, r7
     c2a:	6931      	ldr	r1, [r6, #16]
     c2c:	f004 ffa4 	bl	5b78 <memcpy>
     c30:	1938      	adds	r0, r7, r4
     c32:	6973      	ldr	r3, [r6, #20]
     c34:	542b      	strb	r3, [r5, r0]
     c36:	4405      	add	r5, r0
     c38:	0a19      	lsrs	r1, r3, #8
     c3a:	0c1a      	lsrs	r2, r3, #16
     c3c:	0e1b      	lsrs	r3, r3, #24
     c3e:	7069      	strb	r1, [r5, #1]
     c40:	70aa      	strb	r2, [r5, #2]
     c42:	70eb      	strb	r3, [r5, #3]
     c44:	3004      	adds	r0, #4
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
     c46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00000c48 <usb_serial_class::write(unsigned char const*, unsigned int)>:
     c48:	4608      	mov	r0, r1
     c4a:	4611      	mov	r1, r2
     c4c:	f006 baac 	b.w	71a8 <usb_serial_write>

00000c50 <usb_serial_class::read()>:
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
     c50:	f006 ba44 	b.w	70dc <usb_serial_getchar>

00000c54 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)>:
     c54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     c58:	780a      	ldrb	r2, [r1, #0]
     c5a:	784b      	ldrb	r3, [r1, #1]
     c5c:	788c      	ldrb	r4, [r1, #2]
     c5e:	4605      	mov	r5, r0
     c60:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
     c64:	78c8      	ldrb	r0, [r1, #3]
     c66:	460e      	mov	r6, r1
     c68:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
     c6c:	6869      	ldr	r1, [r5, #4]
     c6e:	ea43 6400 	orr.w	r4, r3, r0, lsl #24
     c72:	428c      	cmp	r4, r1
     c74:	b083      	sub	sp, #12
     c76:	f200 80ba 	bhi.w	dee <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x19a>
     c7a:	606c      	str	r4, [r5, #4]
     c7c:	2c00      	cmp	r4, #0
     c7e:	f000 80bf 	beq.w	e00 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x1ac>
     c82:	f105 0908 	add.w	r9, r5, #8
     c86:	4634      	mov	r4, r6
     c88:	2700      	movs	r7, #0
     c8a:	f04f 0804 	mov.w	r8, #4
     c8e:	79a1      	ldrb	r1, [r4, #6]
     c90:	7963      	ldrb	r3, [r4, #5]
     c92:	7922      	ldrb	r2, [r4, #4]
     c94:	f894 e007 	ldrb.w	lr, [r4, #7]
     c98:	68e8      	ldr	r0, [r5, #12]
     c9a:	0409      	lsls	r1, r1, #16
     c9c:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
     ca0:	4313      	orrs	r3, r2
     ca2:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
     ca6:	60ab      	str	r3, [r5, #8]
     ca8:	eb00 0087 	add.w	r0, r0, r7, lsl #2
     cac:	2204      	movs	r2, #4
     cae:	4649      	mov	r1, r9
     cb0:	f004 ff62 	bl	5b78 <memcpy>
     cb4:	686b      	ldr	r3, [r5, #4]
     cb6:	3701      	adds	r7, #1
     cb8:	42bb      	cmp	r3, r7
     cba:	4642      	mov	r2, r8
     cbc:	f104 0404 	add.w	r4, r4, #4
     cc0:	f108 0804 	add.w	r8, r8, #4
     cc4:	d8e3      	bhi.n	c8e <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x3a>
     cc6:	f102 0708 	add.w	r7, r2, #8
     cca:	4641      	mov	r1, r8
     ccc:	46b9      	mov	r9, r7
     cce:	f102 0e05 	add.w	lr, r2, #5
     cd2:	1d90      	adds	r0, r2, #6
     cd4:	1dd3      	adds	r3, r2, #7
     cd6:	f102 0b09 	add.w	fp, r2, #9
     cda:	f102 080a 	add.w	r8, r2, #10
     cde:	f102 0a0b 	add.w	sl, r2, #11
     ce2:	f102 040c 	add.w	r4, r2, #12
     ce6:	5c30      	ldrb	r0, [r6, r0]
     ce8:	f816 200e 	ldrb.w	r2, [r6, lr]
     cec:	5c71      	ldrb	r1, [r6, r1]
     cee:	f816 e003 	ldrb.w	lr, [r6, r3]
     cf2:	692b      	ldr	r3, [r5, #16]
     cf4:	0400      	lsls	r0, r0, #16
     cf6:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
     cfa:	430a      	orrs	r2, r1
     cfc:	ea42 620e 	orr.w	r2, r2, lr, lsl #24
     d00:	429a      	cmp	r2, r3
     d02:	f200 8092 	bhi.w	e2a <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x1d6>
     d06:	612a      	str	r2, [r5, #16]
     d08:	b34a      	cbz	r2, d5e <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x10a>
     d0a:	f105 0a14 	add.w	sl, r5, #20
     d0e:	eb06 0709 	add.w	r7, r6, r9
     d12:	f04f 0800 	mov.w	r8, #0
     d16:	78b9      	ldrb	r1, [r7, #2]
     d18:	787b      	ldrb	r3, [r7, #1]
     d1a:	783a      	ldrb	r2, [r7, #0]
     d1c:	78fc      	ldrb	r4, [r7, #3]
     d1e:	69a8      	ldr	r0, [r5, #24]
     d20:	0409      	lsls	r1, r1, #16
     d22:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
     d26:	4313      	orrs	r3, r2
     d28:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
     d2c:	616b      	str	r3, [r5, #20]
     d2e:	eb00 0088 	add.w	r0, r0, r8, lsl #2
     d32:	2204      	movs	r2, #4
     d34:	4651      	mov	r1, sl
     d36:	f004 ff1f 	bl	5b78 <memcpy>
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
     d3a:	692b      	ldr	r3, [r5, #16]
     d3c:	f108 0801 	add.w	r8, r8, #1
     d40:	4543      	cmp	r3, r8
     d42:	464c      	mov	r4, r9
     d44:	f107 0704 	add.w	r7, r7, #4
     d48:	f109 0904 	add.w	r9, r9, #4
     d4c:	d8e3      	bhi.n	d16 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0xc2>
     d4e:	f104 0b05 	add.w	fp, r4, #5
     d52:	f104 0806 	add.w	r8, r4, #6
     d56:	f104 0a07 	add.w	sl, r4, #7
     d5a:	464f      	mov	r7, r9
     d5c:	3408      	adds	r4, #8
     d5e:	f816 2008 	ldrb.w	r2, [r6, r8]
     d62:	f816 000b 	ldrb.w	r0, [r6, fp]
     d66:	5df3      	ldrb	r3, [r6, r7]
     d68:	f816 700a 	ldrb.w	r7, [r6, sl]
     d6c:	69e9      	ldr	r1, [r5, #28]
     d6e:	0412      	lsls	r2, r2, #16
     d70:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
     d74:	4313      	orrs	r3, r2
     d76:	ea43 6707 	orr.w	r7, r3, r7, lsl #24
     d7a:	428f      	cmp	r7, r1
     d7c:	d84f      	bhi.n	e1e <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x1ca>
     d7e:	61ef      	str	r7, [r5, #28]
     d80:	b38f      	cbz	r7, de6 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x192>
     d82:	f04f 0900 	mov.w	r9, #0
     d86:	46c8      	mov	r8, r9
     d88:	f105 0720 	add.w	r7, r5, #32
     d8c:	2300      	movs	r3, #0
     d8e:	469e      	mov	lr, r3
     d90:	1931      	adds	r1, r6, r4
     d92:	f811 2b01 	ldrb.w	r2, [r1], #1
     d96:	409a      	lsls	r2, r3
     d98:	3308      	adds	r3, #8
     d9a:	2b20      	cmp	r3, #32
     d9c:	ea4e 0e02 	orr.w	lr, lr, r2
     da0:	d1f7      	bne.n	d92 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x13e>
     da2:	1d20      	adds	r0, r4, #4
     da4:	4486      	add	lr, r0
     da6:	4570      	cmp	r0, lr
     da8:	d209      	bcs.n	dbe <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x16a>
     daa:	1ce3      	adds	r3, r4, #3
     dac:	4433      	add	r3, r6
     dae:	4602      	mov	r2, r0
     db0:	3201      	adds	r2, #1
     db2:	f813 1f01 	ldrb.w	r1, [r3, #1]!
     db6:	f803 1c01 	strb.w	r1, [r3, #-1]
     dba:	4572      	cmp	r2, lr
     dbc:	d3f8      	bcc.n	db0 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x15c>
     dbe:	eb06 020e 	add.w	r2, r6, lr
     dc2:	1e43      	subs	r3, r0, #1
     dc4:	f802 8c01 	strb.w	r8, [r2, #-1]
     dc8:	6a68      	ldr	r0, [r5, #36]	; 0x24
     dca:	4433      	add	r3, r6
     dcc:	622b      	str	r3, [r5, #32]
     dce:	eb00 0089 	add.w	r0, r0, r9, lsl #2
     dd2:	2204      	movs	r2, #4
     dd4:	4639      	mov	r1, r7
     dd6:	4674      	mov	r4, lr
     dd8:	f004 fece 	bl	5b78 <memcpy>
     ddc:	69eb      	ldr	r3, [r5, #28]
     dde:	f109 0901 	add.w	r9, r9, #1
     de2:	454b      	cmp	r3, r9
     de4:	d8d2      	bhi.n	d8c <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x138>
     de6:	4620      	mov	r0, r4
     de8:	b003      	add	sp, #12
     dea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     dee:	00a1      	lsls	r1, r4, #2
     df0:	68e8      	ldr	r0, [r5, #12]
     df2:	f008 fed9 	bl	9ba8 <realloc>
     df6:	606c      	str	r4, [r5, #4]
     df8:	60e8      	str	r0, [r5, #12]
     dfa:	2c00      	cmp	r4, #0
     dfc:	f47f af41 	bne.w	c82 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x2e>
     e00:	2708      	movs	r7, #8
     e02:	46b9      	mov	r9, r7
     e04:	240c      	movs	r4, #12
     e06:	f04f 0a0b 	mov.w	sl, #11
     e0a:	f04f 080a 	mov.w	r8, #10
     e0e:	f04f 0b09 	mov.w	fp, #9
     e12:	2307      	movs	r3, #7
     e14:	2006      	movs	r0, #6
     e16:	f04f 0e05 	mov.w	lr, #5
     e1a:	2104      	movs	r1, #4
     e1c:	e763      	b.n	ce6 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x92>
     e1e:	00b9      	lsls	r1, r7, #2
     e20:	6a68      	ldr	r0, [r5, #36]	; 0x24
     e22:	f008 fec1 	bl	9ba8 <realloc>
     e26:	6268      	str	r0, [r5, #36]	; 0x24
     e28:	e7a9      	b.n	d7e <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x12a>
     e2a:	0091      	lsls	r1, r2, #2
     e2c:	69a8      	ldr	r0, [r5, #24]
     e2e:	9201      	str	r2, [sp, #4]
     e30:	f008 feba 	bl	9ba8 <realloc>
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
     e34:	9a01      	ldr	r2, [sp, #4]
     e36:	61a8      	str	r0, [r5, #24]
     e38:	e765      	b.n	d06 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0xb2>
     e3a:	bf00      	nop

00000e3c <geometry_msgs::Twist::serialize(unsigned char*) const>:
     e3c:	edd0 7a02 	vldr	s15, [r0, #8]
     e40:	ee17 3a90 	vmov	r3, s15
     e44:	f3c3 52c7 	ubfx	r2, r3, #23, #8
     e48:	2aff      	cmp	r2, #255	; 0xff
     e4a:	b4f0      	push	{r4, r5, r6, r7}
     e4c:	f3c3 0316 	ubfx	r3, r3, #0, #23
     e50:	f000 81fd 	beq.w	124e <geometry_msgs::Twist::serialize(unsigned char*) const+0x412>
     e54:	2a00      	cmp	r2, #0
     e56:	f000 8112 	beq.w	107e <geometry_msgs::Twist::serialize(unsigned char*) const+0x242>
     e5a:	f502 7260 	add.w	r2, r2, #896	; 0x380
     e5e:	0cdc      	lsrs	r4, r3, #19
     e60:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
     e64:	015e      	lsls	r6, r3, #5
     e66:	f3c3 07c7 	ubfx	r7, r3, #3, #8
     e6a:	b2e4      	uxtb	r4, r4
     e6c:	f3c2 1207 	ubfx	r2, r2, #4, #8
     e70:	b2f6      	uxtb	r6, r6
     e72:	f3c3 23c7 	ubfx	r3, r3, #11, #8
     e76:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
     e7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     e7e:	f04f 0500 	mov.w	r5, #0
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     e82:	bf48      	it	mi
     e84:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
     e88:	714b      	strb	r3, [r1, #5]
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     e8a:	71ca      	strb	r2, [r1, #7]
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
     e8c:	70ce      	strb	r6, [r1, #3]
    *(outbuffer++) = (mantissa >> 3) & 0xff;
     e8e:	710f      	strb	r7, [r1, #4]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
     e90:	718c      	strb	r4, [r1, #6]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     e92:	700d      	strb	r5, [r1, #0]
    *(outbuffer++) = 0;
     e94:	704d      	strb	r5, [r1, #1]
    *(outbuffer++) = 0;
     e96:	708d      	strb	r5, [r1, #2]

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      offset += serializeAvrFloat64(outbuffer + offset, this->x);
      offset += serializeAvrFloat64(outbuffer + offset, this->y);
     e98:	edd0 7a03 	vldr	s15, [r0, #12]
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
     e9c:	ee17 3a90 	vmov	r3, s15

    int16_t exp = ((val >> 23) & 255);
     ea0:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
     ea4:	2aff      	cmp	r2, #255	; 0xff
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
     ea6:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
     eaa:	f000 81c5 	beq.w	1238 <geometry_msgs::Twist::serialize(unsigned char*) const+0x3fc>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
     eae:	2a00      	cmp	r2, #0
     eb0:	f000 8103 	beq.w	10ba <geometry_msgs::Twist::serialize(unsigned char*) const+0x27e>
    {
      exp += 1023 - 127; // Normal case
     eb4:	f502 7260 	add.w	r2, r2, #896	; 0x380
     eb8:	0cdc      	lsrs	r4, r3, #19
     eba:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
     ebe:	015e      	lsls	r6, r3, #5
     ec0:	f3c3 07c7 	ubfx	r7, r3, #3, #8
     ec4:	b2e4      	uxtb	r4, r4
     ec6:	f3c2 1207 	ubfx	r2, r2, #4, #8
     eca:	b2f6      	uxtb	r6, r6
     ecc:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
     ed0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
     ed4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     ed8:	f04f 0500 	mov.w	r5, #0
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     edc:	bf48      	it	mi
     ede:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
     ee2:	734b      	strb	r3, [r1, #13]
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     ee4:	73ca      	strb	r2, [r1, #15]
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
     ee6:	72ce      	strb	r6, [r1, #11]
    *(outbuffer++) = (mantissa >> 3) & 0xff;
     ee8:	730f      	strb	r7, [r1, #12]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
     eea:	738c      	strb	r4, [r1, #14]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     eec:	720d      	strb	r5, [r1, #8]
    *(outbuffer++) = 0;
     eee:	724d      	strb	r5, [r1, #9]
    *(outbuffer++) = 0;
     ef0:	728d      	strb	r5, [r1, #10]
      offset += serializeAvrFloat64(outbuffer + offset, this->z);
     ef2:	edd0 7a04 	vldr	s15, [r0, #16]
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
     ef6:	ee17 3a90 	vmov	r3, s15

    int16_t exp = ((val >> 23) & 255);
     efa:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
     efe:	2aff      	cmp	r2, #255	; 0xff
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
     f00:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
     f04:	f000 8177 	beq.w	11f6 <geometry_msgs::Twist::serialize(unsigned char*) const+0x3ba>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
     f08:	2a00      	cmp	r2, #0
     f0a:	f000 814d 	beq.w	11a8 <geometry_msgs::Twist::serialize(unsigned char*) const+0x36c>
    {
      exp += 1023 - 127; // Normal case
     f0e:	f502 7260 	add.w	r2, r2, #896	; 0x380
     f12:	0cdc      	lsrs	r4, r3, #19
     f14:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
     f18:	015e      	lsls	r6, r3, #5
     f1a:	f3c3 07c7 	ubfx	r7, r3, #3, #8
     f1e:	b2e4      	uxtb	r4, r4
     f20:	f3c2 1207 	ubfx	r2, r2, #4, #8
     f24:	b2f6      	uxtb	r6, r6
     f26:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
     f2a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
     f2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     f32:	f04f 0500 	mov.w	r5, #0
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     f36:	bf48      	it	mi
     f38:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
     f3c:	754b      	strb	r3, [r1, #21]
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     f3e:	75ca      	strb	r2, [r1, #23]
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
     f40:	74ce      	strb	r6, [r1, #19]
    *(outbuffer++) = (mantissa >> 3) & 0xff;
     f42:	750f      	strb	r7, [r1, #20]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
     f44:	758c      	strb	r4, [r1, #22]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     f46:	740d      	strb	r5, [r1, #16]
    *(outbuffer++) = 0;
     f48:	744d      	strb	r5, [r1, #17]
    *(outbuffer++) = 0;
     f4a:	748d      	strb	r5, [r1, #18]
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      offset += serializeAvrFloat64(outbuffer + offset, this->x);
     f4c:	edd0 7a06 	vldr	s15, [r0, #24]
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
     f50:	ee17 3a90 	vmov	r3, s15

    int16_t exp = ((val >> 23) & 255);
     f54:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
     f58:	2aff      	cmp	r2, #255	; 0xff
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
     f5a:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
     f5e:	f000 813f 	beq.w	11e0 <geometry_msgs::Twist::serialize(unsigned char*) const+0x3a4>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
     f62:	2a00      	cmp	r2, #0
     f64:	f000 8103 	beq.w	116e <geometry_msgs::Twist::serialize(unsigned char*) const+0x332>
    {
      exp += 1023 - 127; // Normal case
     f68:	f502 7260 	add.w	r2, r2, #896	; 0x380
     f6c:	0cdc      	lsrs	r4, r3, #19
     f6e:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
     f72:	015e      	lsls	r6, r3, #5
     f74:	f3c3 07c7 	ubfx	r7, r3, #3, #8
     f78:	b2e4      	uxtb	r4, r4
     f7a:	f3c2 1207 	ubfx	r2, r2, #4, #8
     f7e:	b2f6      	uxtb	r6, r6
     f80:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
     f84:	eef5 7ac0 	vcmpe.f32	s15, #0.0
     f88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     f8c:	f04f 0500 	mov.w	r5, #0
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     f90:	bf48      	it	mi
     f92:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
     f96:	774b      	strb	r3, [r1, #29]
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     f98:	77ca      	strb	r2, [r1, #31]
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
     f9a:	76ce      	strb	r6, [r1, #27]
    *(outbuffer++) = (mantissa >> 3) & 0xff;
     f9c:	770f      	strb	r7, [r1, #28]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
     f9e:	778c      	strb	r4, [r1, #30]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     fa0:	760d      	strb	r5, [r1, #24]
    *(outbuffer++) = 0;
     fa2:	764d      	strb	r5, [r1, #25]
    *(outbuffer++) = 0;
     fa4:	768d      	strb	r5, [r1, #26]
      offset += serializeAvrFloat64(outbuffer + offset, this->y);
     fa6:	edd0 7a07 	vldr	s15, [r0, #28]
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
     faa:	ee17 3a90 	vmov	r3, s15

    int16_t exp = ((val >> 23) & 255);
     fae:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
     fb2:	2aff      	cmp	r2, #255	; 0xff
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
     fb4:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
     fb8:	f000 8133 	beq.w	1222 <geometry_msgs::Twist::serialize(unsigned char*) const+0x3e6>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
     fbc:	2a00      	cmp	r2, #0
     fbe:	f000 80b8 	beq.w	1132 <geometry_msgs::Twist::serialize(unsigned char*) const+0x2f6>
    {
      exp += 1023 - 127; // Normal case
     fc2:	f502 7260 	add.w	r2, r2, #896	; 0x380
     fc6:	0cdc      	lsrs	r4, r3, #19
     fc8:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
     fcc:	015e      	lsls	r6, r3, #5
     fce:	f3c3 07c7 	ubfx	r7, r3, #3, #8
     fd2:	b2e4      	uxtb	r4, r4
     fd4:	f3c2 1207 	ubfx	r2, r2, #4, #8
     fd8:	b2f6      	uxtb	r6, r6
     fda:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
     fde:	eef5 7ac0 	vcmpe.f32	s15, #0.0
     fe2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
     fe6:	f04f 0500 	mov.w	r5, #0
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     fea:	bf48      	it	mi
     fec:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
     ff0:	f881 3025 	strb.w	r3, [r1, #37]	; 0x25
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
     ff4:	f881 2027 	strb.w	r2, [r1, #39]	; 0x27
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
     ff8:	f881 6023 	strb.w	r6, [r1, #35]	; 0x23
    *(outbuffer++) = (mantissa >> 3) & 0xff;
     ffc:	f881 7024 	strb.w	r7, [r1, #36]	; 0x24
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    1000:	f881 4026 	strb.w	r4, [r1, #38]	; 0x26
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    1004:	f881 5020 	strb.w	r5, [r1, #32]
    *(outbuffer++) = 0;
    1008:	f881 5021 	strb.w	r5, [r1, #33]	; 0x21
    *(outbuffer++) = 0;
    100c:	f881 5022 	strb.w	r5, [r1, #34]	; 0x22
      offset += serializeAvrFloat64(outbuffer + offset, this->z);
    1010:	edd0 7a08 	vldr	s15, [r0, #32]
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    1014:	ee17 3a90 	vmov	r3, s15

    int16_t exp = ((val >> 23) & 255);
    1018:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    101c:	2aff      	cmp	r2, #255	; 0xff
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    101e:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    1022:	f000 80f3 	beq.w	120c <geometry_msgs::Twist::serialize(unsigned char*) const+0x3d0>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    1026:	2a00      	cmp	r2, #0
    1028:	d065      	beq.n	10f6 <geometry_msgs::Twist::serialize(unsigned char*) const+0x2ba>
    {
      exp += 1023 - 127; // Normal case
    102a:	f502 7260 	add.w	r2, r2, #896	; 0x380
    102e:	0cd8      	lsrs	r0, r3, #19
    1030:	ea40 1002 	orr.w	r0, r0, r2, lsl #4
    1034:	015d      	lsls	r5, r3, #5
    1036:	f3c3 06c7 	ubfx	r6, r3, #3, #8
    103a:	b2c0      	uxtb	r0, r0
    103c:	f3c2 1207 	ubfx	r2, r2, #4, #8
    1040:	b2ed      	uxtb	r5, r5
    1042:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    1046:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    104a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    104e:	f04f 0400 	mov.w	r4, #0
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    1052:	bf48      	it	mi
    1054:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    1058:	f881 502b 	strb.w	r5, [r1, #43]	; 0x2b
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    105c:	f881 602c 	strb.w	r6, [r1, #44]	; 0x2c
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    1060:	f881 002e 	strb.w	r0, [r1, #46]	; 0x2e
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    1064:	f881 4028 	strb.w	r4, [r1, #40]	; 0x28
    *(outbuffer++) = 0;
    1068:	f881 4029 	strb.w	r4, [r1, #41]	; 0x29
    *(outbuffer++) = 0;
    106c:	f881 402a 	strb.w	r4, [r1, #42]	; 0x2a
    {
      int offset = 0;
      offset += this->linear.serialize(outbuffer + offset);
      offset += this->angular.serialize(outbuffer + offset);
      return offset;
    }
    1070:	2030      	movs	r0, #48	; 0x30
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    1072:	f881 302d 	strb.w	r3, [r1, #45]	; 0x2d
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    1076:	f881 202f 	strb.w	r2, [r1, #47]	; 0x2f
    107a:	bcf0      	pop	{r4, r5, r6, r7}
    107c:	4770      	bx	lr
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    107e:	2b00      	cmp	r3, #0
    1080:	f000 8109 	beq.w	1296 <geometry_msgs::Twist::serialize(unsigned char*) const+0x45a>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    1084:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    1086:	021c      	lsls	r4, r3, #8
    1088:	f100 810d 	bmi.w	12a6 <geometry_msgs::Twist::serialize(unsigned char*) const+0x46a>
    108c:	f44f 7260 	mov.w	r2, #896	; 0x380
    1090:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    1092:	005b      	lsls	r3, r3, #1
    1094:	b294      	uxth	r4, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    1096:	021f      	lsls	r7, r3, #8
    1098:	b222      	sxth	r2, r4
    109a:	d5f9      	bpl.n	1090 <geometry_msgs::Twist::serialize(unsigned char*) const+0x254>
    109c:	0124      	lsls	r4, r4, #4
    109e:	b2e4      	uxtb	r4, r4
    10a0:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    10a4:	f3c3 0316 	ubfx	r3, r3, #0, #23
    10a8:	015e      	lsls	r6, r3, #5
    10aa:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
    10ae:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    10b2:	b2f6      	uxtb	r6, r6
    10b4:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    10b8:	e6dd      	b.n	e76 <geometry_msgs::Twist::serialize(unsigned char*) const+0x3a>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    10ba:	2b00      	cmp	r3, #0
    10bc:	f000 80e6 	beq.w	128c <geometry_msgs::Twist::serialize(unsigned char*) const+0x450>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    10c0:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    10c2:	021e      	lsls	r6, r3, #8
    10c4:	f100 80f2 	bmi.w	12ac <geometry_msgs::Twist::serialize(unsigned char*) const+0x470>
    10c8:	f44f 7260 	mov.w	r2, #896	; 0x380
    10cc:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    10ce:	005b      	lsls	r3, r3, #1
    10d0:	b294      	uxth	r4, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    10d2:	021d      	lsls	r5, r3, #8
    10d4:	b222      	sxth	r2, r4
    10d6:	d5f9      	bpl.n	10cc <geometry_msgs::Twist::serialize(unsigned char*) const+0x290>
    10d8:	0124      	lsls	r4, r4, #4
    10da:	b2e4      	uxtb	r4, r4
    10dc:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    10e0:	f3c3 0316 	ubfx	r3, r3, #0, #23
    10e4:	015e      	lsls	r6, r3, #5
    10e6:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
    10ea:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    10ee:	b2f6      	uxtb	r6, r6
    10f0:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    10f4:	e6ec      	b.n	ed0 <geometry_msgs::Twist::serialize(unsigned char*) const+0x94>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    10f6:	2b00      	cmp	r3, #0
    10f8:	f000 80c3 	beq.w	1282 <geometry_msgs::Twist::serialize(unsigned char*) const+0x446>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    10fc:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    10fe:	021d      	lsls	r5, r3, #8
    1100:	f100 80d7 	bmi.w	12b2 <geometry_msgs::Twist::serialize(unsigned char*) const+0x476>
    1104:	f44f 7260 	mov.w	r2, #896	; 0x380
    1108:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    110a:	005b      	lsls	r3, r3, #1
    110c:	b290      	uxth	r0, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    110e:	021c      	lsls	r4, r3, #8
    1110:	b202      	sxth	r2, r0
    1112:	d5f9      	bpl.n	1108 <geometry_msgs::Twist::serialize(unsigned char*) const+0x2cc>
    1114:	0100      	lsls	r0, r0, #4
    1116:	b2c0      	uxtb	r0, r0
    1118:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    111c:	f3c3 0316 	ubfx	r3, r3, #0, #23
    1120:	015d      	lsls	r5, r3, #5
    1122:	ea40 40d3 	orr.w	r0, r0, r3, lsr #19
    1126:	f3c3 06c7 	ubfx	r6, r3, #3, #8
    112a:	b2ed      	uxtb	r5, r5
    112c:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    1130:	e789      	b.n	1046 <geometry_msgs::Twist::serialize(unsigned char*) const+0x20a>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    1132:	2b00      	cmp	r3, #0
    1134:	f000 80a0 	beq.w	1278 <geometry_msgs::Twist::serialize(unsigned char*) const+0x43c>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    1138:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    113a:	021f      	lsls	r7, r3, #8
    113c:	f100 80bc 	bmi.w	12b8 <geometry_msgs::Twist::serialize(unsigned char*) const+0x47c>
    1140:	f44f 7260 	mov.w	r2, #896	; 0x380
    1144:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    1146:	005b      	lsls	r3, r3, #1
    1148:	b294      	uxth	r4, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    114a:	021e      	lsls	r6, r3, #8
    114c:	b222      	sxth	r2, r4
    114e:	d5f9      	bpl.n	1144 <geometry_msgs::Twist::serialize(unsigned char*) const+0x308>
    1150:	0124      	lsls	r4, r4, #4
    1152:	b2e4      	uxtb	r4, r4
    1154:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    1158:	f3c3 0316 	ubfx	r3, r3, #0, #23
    115c:	015e      	lsls	r6, r3, #5
    115e:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
    1162:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    1166:	b2f6      	uxtb	r6, r6
    1168:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    116c:	e737      	b.n	fde <geometry_msgs::Twist::serialize(unsigned char*) const+0x1a2>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    116e:	2b00      	cmp	r3, #0
    1170:	d07d      	beq.n	126e <geometry_msgs::Twist::serialize(unsigned char*) const+0x432>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    1172:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    1174:	021e      	lsls	r6, r3, #8
    1176:	f100 80a2 	bmi.w	12be <geometry_msgs::Twist::serialize(unsigned char*) const+0x482>
    117a:	f44f 7260 	mov.w	r2, #896	; 0x380
    117e:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    1180:	005b      	lsls	r3, r3, #1
    1182:	b294      	uxth	r4, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    1184:	021d      	lsls	r5, r3, #8
    1186:	b222      	sxth	r2, r4
    1188:	d5f9      	bpl.n	117e <geometry_msgs::Twist::serialize(unsigned char*) const+0x342>
    118a:	0124      	lsls	r4, r4, #4
    118c:	b2e4      	uxtb	r4, r4
    118e:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    1192:	f3c3 0316 	ubfx	r3, r3, #0, #23
    1196:	015e      	lsls	r6, r3, #5
    1198:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
    119c:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    11a0:	b2f6      	uxtb	r6, r6
    11a2:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    11a6:	e6ed      	b.n	f84 <geometry_msgs::Twist::serialize(unsigned char*) const+0x148>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    11a8:	2b00      	cmp	r3, #0
    11aa:	d05b      	beq.n	1264 <geometry_msgs::Twist::serialize(unsigned char*) const+0x428>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    11ac:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    11ae:	021c      	lsls	r4, r3, #8
    11b0:	d476      	bmi.n	12a0 <geometry_msgs::Twist::serialize(unsigned char*) const+0x464>
    11b2:	f44f 7260 	mov.w	r2, #896	; 0x380
    11b6:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    11b8:	005b      	lsls	r3, r3, #1
    11ba:	b294      	uxth	r4, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    11bc:	021f      	lsls	r7, r3, #8
    11be:	b222      	sxth	r2, r4
    11c0:	d5f9      	bpl.n	11b6 <geometry_msgs::Twist::serialize(unsigned char*) const+0x37a>
    11c2:	0124      	lsls	r4, r4, #4
    11c4:	b2e4      	uxtb	r4, r4
    11c6:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    11ca:	f3c3 0316 	ubfx	r3, r3, #0, #23
    11ce:	015e      	lsls	r6, r3, #5
    11d0:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
    11d4:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    11d8:	b2f6      	uxtb	r6, r6
    11da:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    11de:	e6a4      	b.n	f2a <geometry_msgs::Twist::serialize(unsigned char*) const+0xee>
    11e0:	015e      	lsls	r6, r3, #5
    11e2:	0cdc      	lsrs	r4, r3, #19
    11e4:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    11e8:	b2f6      	uxtb	r6, r6
    11ea:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    11ee:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    11f2:	227f      	movs	r2, #127	; 0x7f
    11f4:	e6c6      	b.n	f84 <geometry_msgs::Twist::serialize(unsigned char*) const+0x148>
    11f6:	015e      	lsls	r6, r3, #5
    11f8:	0cdc      	lsrs	r4, r3, #19
    11fa:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    11fe:	b2f6      	uxtb	r6, r6
    1200:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    1204:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    1208:	227f      	movs	r2, #127	; 0x7f
    120a:	e68e      	b.n	f2a <geometry_msgs::Twist::serialize(unsigned char*) const+0xee>
    120c:	015d      	lsls	r5, r3, #5
    120e:	0cd8      	lsrs	r0, r3, #19
    1210:	f3c3 06c7 	ubfx	r6, r3, #3, #8
    1214:	b2ed      	uxtb	r5, r5
    1216:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
    121a:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    121e:	227f      	movs	r2, #127	; 0x7f
    1220:	e711      	b.n	1046 <geometry_msgs::Twist::serialize(unsigned char*) const+0x20a>
    1222:	015e      	lsls	r6, r3, #5
    1224:	0cdc      	lsrs	r4, r3, #19
    1226:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    122a:	b2f6      	uxtb	r6, r6
    122c:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    1230:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    1234:	227f      	movs	r2, #127	; 0x7f
    1236:	e6d2      	b.n	fde <geometry_msgs::Twist::serialize(unsigned char*) const+0x1a2>
    1238:	015e      	lsls	r6, r3, #5
    123a:	0cdc      	lsrs	r4, r3, #19
    123c:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    1240:	b2f6      	uxtb	r6, r6
    1242:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    1246:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    124a:	227f      	movs	r2, #127	; 0x7f
    124c:	e640      	b.n	ed0 <geometry_msgs::Twist::serialize(unsigned char*) const+0x94>
    124e:	015e      	lsls	r6, r3, #5
    1250:	0cdc      	lsrs	r4, r3, #19
    1252:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    1256:	b2f6      	uxtb	r6, r6
    1258:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    125c:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    1260:	227f      	movs	r2, #127	; 0x7f
    1262:	e608      	b.n	e76 <geometry_msgs::Twist::serialize(unsigned char*) const+0x3a>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    1264:	461a      	mov	r2, r3
    1266:	461c      	mov	r4, r3
    1268:	461f      	mov	r7, r3
    126a:	461e      	mov	r6, r3
    126c:	e65d      	b.n	f2a <geometry_msgs::Twist::serialize(unsigned char*) const+0xee>
    126e:	461a      	mov	r2, r3
    1270:	461c      	mov	r4, r3
    1272:	461f      	mov	r7, r3
    1274:	461e      	mov	r6, r3
    1276:	e685      	b.n	f84 <geometry_msgs::Twist::serialize(unsigned char*) const+0x148>
    1278:	461a      	mov	r2, r3
    127a:	461c      	mov	r4, r3
    127c:	461f      	mov	r7, r3
    127e:	461e      	mov	r6, r3
    1280:	e6ad      	b.n	fde <geometry_msgs::Twist::serialize(unsigned char*) const+0x1a2>
    1282:	461a      	mov	r2, r3
    1284:	4618      	mov	r0, r3
    1286:	461e      	mov	r6, r3
    1288:	461d      	mov	r5, r3
    128a:	e6dc      	b.n	1046 <geometry_msgs::Twist::serialize(unsigned char*) const+0x20a>
    128c:	461a      	mov	r2, r3
    128e:	461c      	mov	r4, r3
    1290:	461f      	mov	r7, r3
    1292:	461e      	mov	r6, r3
    1294:	e61c      	b.n	ed0 <geometry_msgs::Twist::serialize(unsigned char*) const+0x94>
    1296:	461a      	mov	r2, r3
    1298:	461c      	mov	r4, r3
    129a:	461f      	mov	r7, r3
    129c:	461e      	mov	r6, r3
    129e:	e5ea      	b.n	e76 <geometry_msgs::Twist::serialize(unsigned char*) const+0x3a>
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    12a0:	4614      	mov	r4, r2
    12a2:	2238      	movs	r2, #56	; 0x38
    12a4:	e791      	b.n	11ca <geometry_msgs::Twist::serialize(unsigned char*) const+0x38e>
    12a6:	4614      	mov	r4, r2
    12a8:	2238      	movs	r2, #56	; 0x38
    12aa:	e6fb      	b.n	10a4 <geometry_msgs::Twist::serialize(unsigned char*) const+0x268>
    12ac:	4614      	mov	r4, r2
    12ae:	2238      	movs	r2, #56	; 0x38
    12b0:	e716      	b.n	10e0 <geometry_msgs::Twist::serialize(unsigned char*) const+0x2a4>
    12b2:	4610      	mov	r0, r2
    12b4:	2238      	movs	r2, #56	; 0x38
    12b6:	e731      	b.n	111c <geometry_msgs::Twist::serialize(unsigned char*) const+0x2e0>
    12b8:	4614      	mov	r4, r2
    12ba:	2238      	movs	r2, #56	; 0x38
    12bc:	e74c      	b.n	1158 <geometry_msgs::Twist::serialize(unsigned char*) const+0x31c>
    12be:	4614      	mov	r4, r2
    12c0:	2238      	movs	r2, #56	; 0x38
    12c2:	e766      	b.n	1192 <geometry_msgs::Twist::serialize(unsigned char*) const+0x356>

000012c4 <geometry_msgs::Vector3::serialize(unsigned char*) const>:
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      offset += serializeAvrFloat64(outbuffer + offset, this->x);
    12c4:	edd0 7a01 	vldr	s15, [r0, #4]
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    12c8:	ee17 3a90 	vmov	r3, s15

    int16_t exp = ((val >> 23) & 255);
    12cc:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    12d0:	2aff      	cmp	r2, #255	; 0xff
      y(0),
      z(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
    12d2:	b4f0      	push	{r4, r5, r6, r7}
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    12d4:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    12d8:	f000 80e6 	beq.w	14a8 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x1e4>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    12dc:	2a00      	cmp	r2, #0
    12de:	d078      	beq.n	13d2 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x10e>
    {
      exp += 1023 - 127; // Normal case
    12e0:	f502 7260 	add.w	r2, r2, #896	; 0x380
    12e4:	0cdc      	lsrs	r4, r3, #19
    12e6:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
    12ea:	015e      	lsls	r6, r3, #5
    12ec:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    12f0:	b2e4      	uxtb	r4, r4
    12f2:	f3c2 1207 	ubfx	r2, r2, #4, #8
    12f6:	b2f6      	uxtb	r6, r6
    12f8:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    12fc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    1300:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    1304:	f04f 0500 	mov.w	r5, #0
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    1308:	bf48      	it	mi
    130a:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    130e:	714b      	strb	r3, [r1, #5]
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    1310:	71ca      	strb	r2, [r1, #7]
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    1312:	70ce      	strb	r6, [r1, #3]
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    1314:	710f      	strb	r7, [r1, #4]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    1316:	718c      	strb	r4, [r1, #6]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    1318:	700d      	strb	r5, [r1, #0]
    *(outbuffer++) = 0;
    131a:	704d      	strb	r5, [r1, #1]
    *(outbuffer++) = 0;
    131c:	708d      	strb	r5, [r1, #2]
    {
      int offset = 0;
      offset += serializeAvrFloat64(outbuffer + offset, this->x);
      offset += serializeAvrFloat64(outbuffer + offset, this->y);
    131e:	edd0 7a02 	vldr	s15, [r0, #8]
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    1322:	ee17 3a90 	vmov	r3, s15

    int16_t exp = ((val >> 23) & 255);
    1326:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    132a:	2aff      	cmp	r2, #255	; 0xff
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    132c:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    1330:	f000 80af 	beq.w	1492 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x1ce>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    1334:	2a00      	cmp	r2, #0
    1336:	d069      	beq.n	140c <geometry_msgs::Vector3::serialize(unsigned char*) const+0x148>
    {
      exp += 1023 - 127; // Normal case
    1338:	f502 7260 	add.w	r2, r2, #896	; 0x380
    133c:	0cdc      	lsrs	r4, r3, #19
    133e:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
    1342:	015e      	lsls	r6, r3, #5
    1344:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    1348:	b2e4      	uxtb	r4, r4
    134a:	f3c2 1207 	ubfx	r2, r2, #4, #8
    134e:	b2f6      	uxtb	r6, r6
    1350:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    1354:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    1358:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    135c:	f04f 0500 	mov.w	r5, #0
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    1360:	bf48      	it	mi
    1362:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    1366:	734b      	strb	r3, [r1, #13]
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    1368:	73ca      	strb	r2, [r1, #15]
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    136a:	72ce      	strb	r6, [r1, #11]
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    136c:	730f      	strb	r7, [r1, #12]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    136e:	738c      	strb	r4, [r1, #14]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    1370:	720d      	strb	r5, [r1, #8]
    *(outbuffer++) = 0;
    1372:	724d      	strb	r5, [r1, #9]
    *(outbuffer++) = 0;
    1374:	728d      	strb	r5, [r1, #10]
      offset += serializeAvrFloat64(outbuffer + offset, this->z);
    1376:	edd0 7a03 	vldr	s15, [r0, #12]
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    137a:	ee17 3a90 	vmov	r3, s15

    int16_t exp = ((val >> 23) & 255);
    137e:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    1382:	2aff      	cmp	r2, #255	; 0xff
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    1384:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    1388:	d078      	beq.n	147c <geometry_msgs::Vector3::serialize(unsigned char*) const+0x1b8>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    138a:	2a00      	cmp	r2, #0
    138c:	d05a      	beq.n	1444 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x180>
    {
      exp += 1023 - 127; // Normal case
    138e:	f502 7260 	add.w	r2, r2, #896	; 0x380
    1392:	0cd8      	lsrs	r0, r3, #19
    1394:	ea40 1002 	orr.w	r0, r0, r2, lsl #4
    1398:	015d      	lsls	r5, r3, #5
    139a:	f3c3 06c7 	ubfx	r6, r3, #3, #8
    139e:	b2c0      	uxtb	r0, r0
    13a0:	f3c2 1207 	ubfx	r2, r2, #4, #8
    13a4:	b2ed      	uxtb	r5, r5
    13a6:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    13aa:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    13ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    13b2:	f04f 0400 	mov.w	r4, #0
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    13b6:	bf48      	it	mi
    13b8:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    13bc:	74cd      	strb	r5, [r1, #19]
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    13be:	750e      	strb	r6, [r1, #20]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    13c0:	7588      	strb	r0, [r1, #22]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    13c2:	740c      	strb	r4, [r1, #16]
    *(outbuffer++) = 0;
    13c4:	744c      	strb	r4, [r1, #17]
    *(outbuffer++) = 0;
    13c6:	748c      	strb	r4, [r1, #18]
      return offset;
    }
    13c8:	2018      	movs	r0, #24
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    13ca:	754b      	strb	r3, [r1, #21]
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    13cc:	75ca      	strb	r2, [r1, #23]
    13ce:	bcf0      	pop	{r4, r5, r6, r7}
    13d0:	4770      	bx	lr
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    13d2:	2b00      	cmp	r3, #0
    13d4:	d07d      	beq.n	14d2 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x20e>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    13d6:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    13d8:	021e      	lsls	r6, r3, #8
    13da:	f100 8082 	bmi.w	14e2 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x21e>
    13de:	f44f 7260 	mov.w	r2, #896	; 0x380
    13e2:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    13e4:	005b      	lsls	r3, r3, #1
    13e6:	b294      	uxth	r4, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    13e8:	021d      	lsls	r5, r3, #8
    13ea:	b222      	sxth	r2, r4
    13ec:	d5f9      	bpl.n	13e2 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x11e>
    13ee:	0124      	lsls	r4, r4, #4
    13f0:	b2e4      	uxtb	r4, r4
    13f2:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    13f6:	f3c3 0316 	ubfx	r3, r3, #0, #23
    13fa:	015e      	lsls	r6, r3, #5
    13fc:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
    1400:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    1404:	b2f6      	uxtb	r6, r6
    1406:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    140a:	e777      	b.n	12fc <geometry_msgs::Vector3::serialize(unsigned char*) const+0x38>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    140c:	2b00      	cmp	r3, #0
    140e:	d05b      	beq.n	14c8 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x204>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    1410:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    1412:	021f      	lsls	r7, r3, #8
    1414:	d468      	bmi.n	14e8 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x224>
    1416:	f44f 7260 	mov.w	r2, #896	; 0x380
    141a:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    141c:	005b      	lsls	r3, r3, #1
    141e:	b294      	uxth	r4, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    1420:	021e      	lsls	r6, r3, #8
    1422:	b222      	sxth	r2, r4
    1424:	d5f9      	bpl.n	141a <geometry_msgs::Vector3::serialize(unsigned char*) const+0x156>
    1426:	0124      	lsls	r4, r4, #4
    1428:	b2e4      	uxtb	r4, r4
    142a:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    142e:	f3c3 0316 	ubfx	r3, r3, #0, #23
    1432:	015e      	lsls	r6, r3, #5
    1434:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
    1438:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    143c:	b2f6      	uxtb	r6, r6
    143e:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    1442:	e787      	b.n	1354 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x90>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    1444:	2b00      	cmp	r3, #0
    1446:	d03a      	beq.n	14be <geometry_msgs::Vector3::serialize(unsigned char*) const+0x1fa>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    1448:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    144a:	021d      	lsls	r5, r3, #8
    144c:	d446      	bmi.n	14dc <geometry_msgs::Vector3::serialize(unsigned char*) const+0x218>
    144e:	f44f 7260 	mov.w	r2, #896	; 0x380
    1452:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    1454:	005b      	lsls	r3, r3, #1
    1456:	b290      	uxth	r0, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    1458:	021c      	lsls	r4, r3, #8
    145a:	b202      	sxth	r2, r0
    145c:	d5f9      	bpl.n	1452 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x18e>
    145e:	0100      	lsls	r0, r0, #4
    1460:	b2c0      	uxtb	r0, r0
    1462:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    1466:	f3c3 0316 	ubfx	r3, r3, #0, #23
    146a:	015d      	lsls	r5, r3, #5
    146c:	ea40 40d3 	orr.w	r0, r0, r3, lsr #19
    1470:	f3c3 06c7 	ubfx	r6, r3, #3, #8
    1474:	b2ed      	uxtb	r5, r5
    1476:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    147a:	e796      	b.n	13aa <geometry_msgs::Vector3::serialize(unsigned char*) const+0xe6>
    147c:	015d      	lsls	r5, r3, #5
    147e:	0cd8      	lsrs	r0, r3, #19
    1480:	f3c3 06c7 	ubfx	r6, r3, #3, #8
    1484:	b2ed      	uxtb	r5, r5
    1486:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
    148a:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    148e:	227f      	movs	r2, #127	; 0x7f
    1490:	e78b      	b.n	13aa <geometry_msgs::Vector3::serialize(unsigned char*) const+0xe6>
    1492:	015e      	lsls	r6, r3, #5
    1494:	0cdc      	lsrs	r4, r3, #19
    1496:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    149a:	b2f6      	uxtb	r6, r6
    149c:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    14a0:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    14a4:	227f      	movs	r2, #127	; 0x7f
    14a6:	e755      	b.n	1354 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x90>
    14a8:	015e      	lsls	r6, r3, #5
    14aa:	0cdc      	lsrs	r4, r3, #19
    14ac:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    14b0:	b2f6      	uxtb	r6, r6
    14b2:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    14b6:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    14ba:	227f      	movs	r2, #127	; 0x7f
    14bc:	e71e      	b.n	12fc <geometry_msgs::Vector3::serialize(unsigned char*) const+0x38>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    14be:	461a      	mov	r2, r3
    14c0:	4618      	mov	r0, r3
    14c2:	461e      	mov	r6, r3
    14c4:	461d      	mov	r5, r3
    14c6:	e770      	b.n	13aa <geometry_msgs::Vector3::serialize(unsigned char*) const+0xe6>
    14c8:	461a      	mov	r2, r3
    14ca:	461c      	mov	r4, r3
    14cc:	461f      	mov	r7, r3
    14ce:	461e      	mov	r6, r3
    14d0:	e740      	b.n	1354 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x90>
    14d2:	461a      	mov	r2, r3
    14d4:	461c      	mov	r4, r3
    14d6:	461f      	mov	r7, r3
    14d8:	461e      	mov	r6, r3
    14da:	e70f      	b.n	12fc <geometry_msgs::Vector3::serialize(unsigned char*) const+0x38>
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    14dc:	4610      	mov	r0, r2
    14de:	2238      	movs	r2, #56	; 0x38
    14e0:	e7c1      	b.n	1466 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x1a2>
    14e2:	4614      	mov	r4, r2
    14e4:	2238      	movs	r2, #56	; 0x38
    14e6:	e786      	b.n	13f6 <geometry_msgs::Vector3::serialize(unsigned char*) const+0x132>
    14e8:	4614      	mov	r4, r2
    14ea:	2238      	movs	r2, #56	; 0x38
    14ec:	e79f      	b.n	142e <geometry_msgs::Vector3::serialize(unsigned char*) const+0x16a>
    14ee:	bf00      	nop

000014f0 <geometry_msgs::Quaternion::serialize(unsigned char*) const>:
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      offset += serializeAvrFloat64(outbuffer + offset, this->x);
    14f0:	edd0 7a01 	vldr	s15, [r0, #4]
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    14f4:	ee17 3a90 	vmov	r3, s15

    int16_t exp = ((val >> 23) & 255);
    14f8:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    14fc:	2aff      	cmp	r2, #255	; 0xff
      z(0),
      w(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
    14fe:	b4f0      	push	{r4, r5, r6, r7}
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    1500:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    1504:	f000 8140 	beq.w	1788 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x298>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    1508:	2a00      	cmp	r2, #0
    150a:	f000 80a8 	beq.w	165e <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x16e>
    {
      exp += 1023 - 127; // Normal case
    150e:	f502 7260 	add.w	r2, r2, #896	; 0x380
    1512:	0cdc      	lsrs	r4, r3, #19
    1514:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
    1518:	015e      	lsls	r6, r3, #5
    151a:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    151e:	b2e4      	uxtb	r4, r4
    1520:	f3c2 1207 	ubfx	r2, r2, #4, #8
    1524:	b2f6      	uxtb	r6, r6
    1526:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    152a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    152e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    1532:	f04f 0500 	mov.w	r5, #0
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    1536:	bf48      	it	mi
    1538:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    153c:	714b      	strb	r3, [r1, #5]
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    153e:	71ca      	strb	r2, [r1, #7]
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    1540:	70ce      	strb	r6, [r1, #3]
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    1542:	710f      	strb	r7, [r1, #4]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    1544:	718c      	strb	r4, [r1, #6]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    1546:	700d      	strb	r5, [r1, #0]
    *(outbuffer++) = 0;
    1548:	704d      	strb	r5, [r1, #1]
    *(outbuffer++) = 0;
    154a:	708d      	strb	r5, [r1, #2]
    {
      int offset = 0;
      offset += serializeAvrFloat64(outbuffer + offset, this->x);
      offset += serializeAvrFloat64(outbuffer + offset, this->y);
    154c:	edd0 7a02 	vldr	s15, [r0, #8]
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    1550:	ee17 3a90 	vmov	r3, s15

    int16_t exp = ((val >> 23) & 255);
    1554:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    1558:	2aff      	cmp	r2, #255	; 0xff
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    155a:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    155e:	f000 8108 	beq.w	1772 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x282>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    1562:	2a00      	cmp	r2, #0
    1564:	f000 8099 	beq.w	169a <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x1aa>
    {
      exp += 1023 - 127; // Normal case
    1568:	f502 7260 	add.w	r2, r2, #896	; 0x380
    156c:	0cdc      	lsrs	r4, r3, #19
    156e:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
    1572:	015e      	lsls	r6, r3, #5
    1574:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    1578:	b2e4      	uxtb	r4, r4
    157a:	f3c2 1207 	ubfx	r2, r2, #4, #8
    157e:	b2f6      	uxtb	r6, r6
    1580:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    1584:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    1588:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    158c:	f04f 0500 	mov.w	r5, #0
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    1590:	bf48      	it	mi
    1592:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    1596:	734b      	strb	r3, [r1, #13]
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    1598:	73ca      	strb	r2, [r1, #15]
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    159a:	72ce      	strb	r6, [r1, #11]
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    159c:	730f      	strb	r7, [r1, #12]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    159e:	738c      	strb	r4, [r1, #14]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    15a0:	720d      	strb	r5, [r1, #8]
    *(outbuffer++) = 0;
    15a2:	724d      	strb	r5, [r1, #9]
    *(outbuffer++) = 0;
    15a4:	728d      	strb	r5, [r1, #10]
      offset += serializeAvrFloat64(outbuffer + offset, this->z);
    15a6:	edd0 7a03 	vldr	s15, [r0, #12]
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    15aa:	ee17 3a90 	vmov	r3, s15

    int16_t exp = ((val >> 23) & 255);
    15ae:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    15b2:	2aff      	cmp	r2, #255	; 0xff
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    15b4:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    15b8:	f000 80d0 	beq.w	175c <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x26c>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    15bc:	2a00      	cmp	r2, #0
    15be:	f000 80a6 	beq.w	170e <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x21e>
    {
      exp += 1023 - 127; // Normal case
    15c2:	f502 7260 	add.w	r2, r2, #896	; 0x380
    15c6:	0cdc      	lsrs	r4, r3, #19
    15c8:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
    15cc:	015e      	lsls	r6, r3, #5
    15ce:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    15d2:	b2e4      	uxtb	r4, r4
    15d4:	f3c2 1207 	ubfx	r2, r2, #4, #8
    15d8:	b2f6      	uxtb	r6, r6
    15da:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    15de:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    15e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    15e6:	f04f 0500 	mov.w	r5, #0
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    15ea:	bf48      	it	mi
    15ec:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    15f0:	754b      	strb	r3, [r1, #21]
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    15f2:	75ca      	strb	r2, [r1, #23]
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    15f4:	74ce      	strb	r6, [r1, #19]
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    15f6:	750f      	strb	r7, [r1, #20]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    15f8:	758c      	strb	r4, [r1, #22]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    15fa:	740d      	strb	r5, [r1, #16]
    *(outbuffer++) = 0;
    15fc:	744d      	strb	r5, [r1, #17]
    *(outbuffer++) = 0;
    15fe:	748d      	strb	r5, [r1, #18]
      offset += serializeAvrFloat64(outbuffer + offset, this->w);
    1600:	edd0 7a04 	vldr	s15, [r0, #16]
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    1604:	ee17 3a90 	vmov	r3, s15

    int16_t exp = ((val >> 23) & 255);
    1608:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    160c:	2aff      	cmp	r2, #255	; 0xff
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    160e:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    1612:	f000 8098 	beq.w	1746 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x256>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    1616:	2a00      	cmp	r2, #0
    1618:	d05d      	beq.n	16d6 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x1e6>
    {
      exp += 1023 - 127; // Normal case
    161a:	f502 7260 	add.w	r2, r2, #896	; 0x380
    161e:	0cd8      	lsrs	r0, r3, #19
    1620:	ea40 1002 	orr.w	r0, r0, r2, lsl #4
    1624:	015d      	lsls	r5, r3, #5
    1626:	f3c3 06c7 	ubfx	r6, r3, #3, #8
    162a:	b2c0      	uxtb	r0, r0
    162c:	f3c2 1207 	ubfx	r2, r2, #4, #8
    1630:	b2ed      	uxtb	r5, r5
    1632:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    1636:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    163a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    163e:	f04f 0400 	mov.w	r4, #0
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    1642:	bf48      	it	mi
    1644:	f062 027f 	ornmi	r2, r2, #127	; 0x7f
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    1648:	76cd      	strb	r5, [r1, #27]
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    164a:	770e      	strb	r6, [r1, #28]
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    164c:	7788      	strb	r0, [r1, #30]
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    164e:	760c      	strb	r4, [r1, #24]
    *(outbuffer++) = 0;
    1650:	764c      	strb	r4, [r1, #25]
    *(outbuffer++) = 0;
    1652:	768c      	strb	r4, [r1, #26]
      return offset;
    }
    1654:	2020      	movs	r0, #32
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    1656:	774b      	strb	r3, [r1, #29]
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    1658:	77ca      	strb	r2, [r1, #31]
    165a:	bcf0      	pop	{r4, r5, r6, r7}
    165c:	4770      	bx	lr
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    165e:	2b00      	cmp	r3, #0
    1660:	f000 80ac 	beq.w	17bc <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x2cc>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    1664:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    1666:	021c      	lsls	r4, r3, #8
    1668:	f100 80b0 	bmi.w	17cc <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x2dc>
    166c:	f44f 7260 	mov.w	r2, #896	; 0x380
    1670:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    1672:	005b      	lsls	r3, r3, #1
    1674:	b294      	uxth	r4, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    1676:	021f      	lsls	r7, r3, #8
    1678:	b222      	sxth	r2, r4
    167a:	d5f9      	bpl.n	1670 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x180>
    167c:	0124      	lsls	r4, r4, #4
    167e:	b2e4      	uxtb	r4, r4
    1680:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    1684:	f3c3 0316 	ubfx	r3, r3, #0, #23
    1688:	015e      	lsls	r6, r3, #5
    168a:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
    168e:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    1692:	b2f6      	uxtb	r6, r6
    1694:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    1698:	e747      	b.n	152a <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x3a>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    169a:	2b00      	cmp	r3, #0
    169c:	f000 8089 	beq.w	17b2 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x2c2>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    16a0:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    16a2:	021e      	lsls	r6, r3, #8
    16a4:	f100 8095 	bmi.w	17d2 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x2e2>
    16a8:	f44f 7260 	mov.w	r2, #896	; 0x380
    16ac:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    16ae:	005b      	lsls	r3, r3, #1
    16b0:	b294      	uxth	r4, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    16b2:	021d      	lsls	r5, r3, #8
    16b4:	b222      	sxth	r2, r4
    16b6:	d5f9      	bpl.n	16ac <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x1bc>
    16b8:	0124      	lsls	r4, r4, #4
    16ba:	b2e4      	uxtb	r4, r4
    16bc:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    16c0:	f3c3 0316 	ubfx	r3, r3, #0, #23
    16c4:	015e      	lsls	r6, r3, #5
    16c6:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
    16ca:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    16ce:	b2f6      	uxtb	r6, r6
    16d0:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    16d4:	e756      	b.n	1584 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x94>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    16d6:	2b00      	cmp	r3, #0
    16d8:	d066      	beq.n	17a8 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x2b8>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    16da:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    16dc:	021d      	lsls	r5, r3, #8
    16de:	d47b      	bmi.n	17d8 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x2e8>
    16e0:	f44f 7260 	mov.w	r2, #896	; 0x380
    16e4:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    16e6:	005b      	lsls	r3, r3, #1
    16e8:	b290      	uxth	r0, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    16ea:	021c      	lsls	r4, r3, #8
    16ec:	b202      	sxth	r2, r0
    16ee:	d5f9      	bpl.n	16e4 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x1f4>
    16f0:	0100      	lsls	r0, r0, #4
    16f2:	b2c0      	uxtb	r0, r0
    16f4:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    16f8:	f3c3 0316 	ubfx	r3, r3, #0, #23
    16fc:	015d      	lsls	r5, r3, #5
    16fe:	ea40 40d3 	orr.w	r0, r0, r3, lsr #19
    1702:	f3c3 06c7 	ubfx	r6, r3, #3, #8
    1706:	b2ed      	uxtb	r5, r5
    1708:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    170c:	e793      	b.n	1636 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x146>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    170e:	2b00      	cmp	r3, #0
    1710:	d045      	beq.n	179e <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x2ae>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    1712:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    1714:	021f      	lsls	r7, r3, #8
    1716:	d456      	bmi.n	17c6 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x2d6>
    1718:	f44f 7260 	mov.w	r2, #896	; 0x380
    171c:	3a01      	subs	r2, #1
      {
          mantissa <<= 1;
    171e:	005b      	lsls	r3, r3, #1
    1720:	b294      	uxth	r4, r2
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    1722:	021e      	lsls	r6, r3, #8
    1724:	b222      	sxth	r2, r4
    1726:	d5f9      	bpl.n	171c <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x22c>
    1728:	0124      	lsls	r4, r4, #4
    172a:	b2e4      	uxtb	r4, r4
    172c:	f3c2 1206 	ubfx	r2, r2, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    1730:	f3c3 0316 	ubfx	r3, r3, #0, #23
    1734:	015e      	lsls	r6, r3, #5
    1736:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
    173a:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    173e:	b2f6      	uxtb	r6, r6
    1740:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    1744:	e74b      	b.n	15de <geometry_msgs::Quaternion::serialize(unsigned char*) const+0xee>
    1746:	015d      	lsls	r5, r3, #5
    1748:	0cd8      	lsrs	r0, r3, #19
    174a:	f3c3 06c7 	ubfx	r6, r3, #3, #8
    174e:	b2ed      	uxtb	r5, r5
    1750:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
    1754:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    1758:	227f      	movs	r2, #127	; 0x7f
    175a:	e76c      	b.n	1636 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x146>
    175c:	015e      	lsls	r6, r3, #5
    175e:	0cdc      	lsrs	r4, r3, #19
    1760:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    1764:	b2f6      	uxtb	r6, r6
    1766:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    176a:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    176e:	227f      	movs	r2, #127	; 0x7f
    1770:	e735      	b.n	15de <geometry_msgs::Quaternion::serialize(unsigned char*) const+0xee>
    1772:	015e      	lsls	r6, r3, #5
    1774:	0cdc      	lsrs	r4, r3, #19
    1776:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    177a:	b2f6      	uxtb	r6, r6
    177c:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    1780:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    1784:	227f      	movs	r2, #127	; 0x7f
    1786:	e6fd      	b.n	1584 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x94>
    1788:	015e      	lsls	r6, r3, #5
    178a:	0cdc      	lsrs	r4, r3, #19
    178c:	f3c3 07c7 	ubfx	r7, r3, #3, #8
    1790:	b2f6      	uxtb	r6, r6
    1792:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    1796:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    179a:	227f      	movs	r2, #127	; 0x7f
    179c:	e6c5      	b.n	152a <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x3a>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    179e:	461a      	mov	r2, r3
    17a0:	461c      	mov	r4, r3
    17a2:	461f      	mov	r7, r3
    17a4:	461e      	mov	r6, r3
    17a6:	e71a      	b.n	15de <geometry_msgs::Quaternion::serialize(unsigned char*) const+0xee>
    17a8:	461a      	mov	r2, r3
    17aa:	4618      	mov	r0, r3
    17ac:	461e      	mov	r6, r3
    17ae:	461d      	mov	r5, r3
    17b0:	e741      	b.n	1636 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x146>
    17b2:	461a      	mov	r2, r3
    17b4:	461c      	mov	r4, r3
    17b6:	461f      	mov	r7, r3
    17b8:	461e      	mov	r6, r3
    17ba:	e6e3      	b.n	1584 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x94>
    17bc:	461a      	mov	r2, r3
    17be:	461c      	mov	r4, r3
    17c0:	461f      	mov	r7, r3
    17c2:	461e      	mov	r6, r3
    17c4:	e6b1      	b.n	152a <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x3a>
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    17c6:	4614      	mov	r4, r2
    17c8:	2238      	movs	r2, #56	; 0x38
    17ca:	e7b1      	b.n	1730 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x240>
    17cc:	4614      	mov	r4, r2
    17ce:	2238      	movs	r2, #56	; 0x38
    17d0:	e758      	b.n	1684 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x194>
    17d2:	4614      	mov	r4, r2
    17d4:	2238      	movs	r2, #56	; 0x38
    17d6:	e773      	b.n	16c0 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x1d0>
    17d8:	4610      	mov	r0, r2
    17da:	2238      	movs	r2, #56	; 0x38
    17dc:	e78c      	b.n	16f8 <geometry_msgs::Quaternion::serialize(unsigned char*) const+0x208>
    17de:	bf00      	nop

000017e0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.9] [clone .constprop.11]>:
      }
    }
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
    17e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    17e2:	b085      	sub	sp, #20
      enum { ERROR = 3 };
      enum { FATAL = 4 };

    Log():
      level(0),
      msg("")
    17e4:	4b2d      	ldr	r3, [pc, #180]	; (189c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.9] [clone .constprop.11]+0xbc>)
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    17e6:	6802      	ldr	r2, [r0, #0]
    17e8:	9301      	str	r3, [sp, #4]
protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    17ea:	492d      	ldr	r1, [pc, #180]	; (18a0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.9] [clone .constprop.11]+0xc0>)
    17ec:	9103      	str	r1, [sp, #12]

protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    17ee:	2303      	movs	r3, #3
    17f0:	f88d 3008 	strb.w	r3, [sp, #8]
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    17f4:	6814      	ldr	r4, [r2, #0]
    17f6:	4a2b      	ldr	r2, [pc, #172]	; (18a4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.9] [clone .constprop.11]+0xc4>)
    17f8:	4294      	cmp	r4, r2
    17fa:	d140      	bne.n	187e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.9] [clone .constprop.11]+0x9e>
  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
      arr[i] = (var >> (8 * i));
    17fc:	2400      	movs	r4, #0
    17fe:	2238      	movs	r2, #56	; 0x38
    1800:	4605      	mov	r5, r0
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    1802:	f880 3223 	strb.w	r3, [r0, #547]	; 0x223
    1806:	f880 2224 	strb.w	r2, [r0, #548]	; 0x224
    180a:	f880 4225 	strb.w	r4, [r0, #549]	; 0x225
    180e:	f880 4226 	strb.w	r4, [r0, #550]	; 0x226
    1812:	f880 4227 	strb.w	r4, [r0, #551]	; 0x227
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    1816:	f500 700a 	add.w	r0, r0, #552	; 0x228
    181a:	f004 f9ad 	bl	5b78 <memcpy>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    181e:	27ff      	movs	r7, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    1820:	203d      	movs	r0, #61	; 0x3d
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    1822:	23c2      	movs	r3, #194	; 0xc2
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    1824:	26fe      	movs	r6, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    1826:	2107      	movs	r1, #7
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    1828:	f885 021e 	strb.w	r0, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    182c:	f885 3220 	strb.w	r3, [r5, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    1830:	f885 421f 	strb.w	r4, [r5, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    1834:	f885 4222 	strb.w	r4, [r5, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    1838:	4622      	mov	r2, r4

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    183a:	f885 721c 	strb.w	r7, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    183e:	f885 621d 	strb.w	r6, [r5, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    1842:	f885 1221 	strb.w	r1, [r5, #545]	; 0x221
    1846:	f205 2321 	addw	r3, r5, #545	; 0x221
    184a:	f205 205f 	addw	r0, r5, #607	; 0x25f
    184e:	e001      	b.n	1854 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.9] [clone .constprop.11]+0x74>
    1850:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    1854:	4283      	cmp	r3, r0
      chk += message_out[i];
    1856:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    1858:	d1fa      	bne.n	1850 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.9] [clone .constprop.11]+0x70>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    185a:	43d2      	mvns	r2, r2
    185c:	686c      	ldr	r4, [r5, #4]
    185e:	f885 2260 	strb.w	r2, [r5, #608]	; 0x260
    1862:	6823      	ldr	r3, [r4, #0]
    1864:	4a10      	ldr	r2, [pc, #64]	; (18a8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.9] [clone .constprop.11]+0xc8>)
    1866:	685b      	ldr	r3, [r3, #4]
    1868:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    186a:	f505 7007 	add.w	r0, r5, #540	; 0x21c
    186e:	d10d      	bne.n	188c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.9] [clone .constprop.11]+0xac>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    1870:	2145      	movs	r1, #69	; 0x45
    1872:	f005 fc99 	bl	71a8 <usb_serial_write>
    else
    {
      logerror("Message from device dropped: message larger than buffer.");
      return -1;
    }
  }
    1876:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    187a:	b005      	add	sp, #20
    187c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    187e:	aa01      	add	r2, sp, #4
    1880:	2107      	movs	r1, #7
    1882:	47a0      	blx	r4
    else
    {
      logerror("Message from device dropped: message larger than buffer.");
      return -1;
    }
  }
    1884:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1888:	b005      	add	sp, #20
    188a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    188c:	4601      	mov	r1, r0
    188e:	2245      	movs	r2, #69	; 0x45
    1890:	4620      	mov	r0, r4
    1892:	4798      	blx	r3
    1894:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1898:	b005      	add	sp, #20
    189a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    189c:	0000a7ec 	.word	0x0000a7ec
    18a0:	0000aadc 	.word	0x0000aadc
    18a4:	0000257d 	.word	0x0000257d
    18a8:	00000c49 	.word	0x00000c49

000018ac <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)>:
    endpoint_(endpoint)
  {
    topic_ = topic_name;
  };

  virtual void callback(unsigned char* data) override
    18ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    18b0:	f891 e007 	ldrb.w	lr, [r1, #7]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    18b4:	790e      	ldrb	r6, [r1, #4]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    18b6:	798b      	ldrb	r3, [r1, #6]
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    18b8:	794f      	ldrb	r7, [r1, #5]
    18ba:	4605      	mov	r5, r0
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    18bc:	ea4f 120e 	mov.w	r2, lr, lsl #4

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    18c0:	78c8      	ldrb	r0, [r1, #3]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    18c2:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    18c6:	0136      	lsls	r6, r6, #4
    18c8:	460c      	mov	r4, r1
    18ca:	ea46 1010 	orr.w	r0, r6, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    18ce:	0519      	lsls	r1, r3, #20

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    18d0:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    18d4:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    18d8:	ea40 3007 	orr.w	r0, r0, r7, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    18dc:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    18e0:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    18e2:	ea41 0100 	orr.w	r1, r1, r0
    18e6:	b082      	sub	sp, #8
  {
    msg.deserialize(data);
    18e8:	f105 070c 	add.w	r7, r5, #12

    virtual int deserialize(unsigned char *inbuffer) override
    {
      int offset = 0;
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->x));
    18ec:	f105 0014 	add.w	r0, r5, #20

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    18f0:	f000 81a1 	beq.w	1c36 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x38a>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    18f4:	f240 467e 	movw	r6, #1150	; 0x47e
    18f8:	42b3      	cmp	r3, r6
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    18fa:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    18fc:	d943      	bls.n	1986 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0xda>
    18fe:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1902:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1904:	f02e 0e7f 	bic.w	lr, lr, #127	; 0x7f
    1908:	4313      	orrs	r3, r2
    190a:	ae02      	add	r6, sp, #8
    190c:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
    1910:	f846 3d04 	str.w	r3, [r6, #-4]!

    memcpy(f, &val, sizeof(val));
    1914:	2204      	movs	r2, #4
    1916:	4631      	mov	r1, r6
    1918:	f004 f92e 	bl	5b78 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    191c:	f894 c00f 	ldrb.w	ip, [r4, #15]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1920:	f894 e00c 	ldrb.w	lr, [r4, #12]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1924:	7ba3      	ldrb	r3, [r4, #14]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    1926:	7ae0      	ldrb	r0, [r4, #11]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1928:	f894 800d 	ldrb.w	r8, [r4, #13]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    192c:	ea4f 120c 	mov.w	r2, ip, lsl #4
    1930:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1934:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1938:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    193a:	ea4e 1010 	orr.w	r0, lr, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    193e:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    1942:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1946:	ea40 3008 	orr.w	r0, r0, r8, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    194a:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    194e:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1950:	ea41 0100 	orr.w	r1, r1, r0
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->y));
    1954:	f105 0018 	add.w	r0, r5, #24

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1958:	f000 8164 	beq.w	1c24 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x378>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    195c:	f240 4e7e 	movw	lr, #1150	; 0x47e
    1960:	4573      	cmp	r3, lr
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1962:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1964:	d81f      	bhi.n	19a6 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0xfa>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1966:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    196a:	f300 819a 	bgt.w	1ca2 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x3f6>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    196e:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1972:	f340 81a9 	ble.w	1cc8 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x41c>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1976:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    197a:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    197c:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1980:	40d1      	lsrs	r1, r2
    1982:	2200      	movs	r2, #0
    1984:	e150      	b.n	1c28 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x37c>
    else if (exp - 1023 > 127)
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1986:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    198a:	f300 816f 	bgt.w	1c6c <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x3c0>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    198e:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1992:	f340 8193 	ble.w	1cbc <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x410>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1996:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    199a:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    199c:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    19a0:	40d1      	lsrs	r1, r2
    19a2:	2200      	movs	r2, #0
    19a4:	e149      	b.n	1c3a <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x38e>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    19a6:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    19aa:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    19ac:	f02c 0c7f 	bic.w	ip, ip, #127	; 0x7f
    19b0:	4313      	orrs	r3, r2
    19b2:	ea43 630c 	orr.w	r3, r3, ip, lsl #24

    memcpy(f, &val, sizeof(val));
    19b6:	2204      	movs	r2, #4
    19b8:	4631      	mov	r1, r6
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    19ba:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    19bc:	f004 f8dc 	bl	5b78 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    19c0:	f894 c017 	ldrb.w	ip, [r4, #23]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    19c4:	f894 e014 	ldrb.w	lr, [r4, #20]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    19c8:	7da3      	ldrb	r3, [r4, #22]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    19ca:	7ce0      	ldrb	r0, [r4, #19]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    19cc:	f894 8015 	ldrb.w	r8, [r4, #21]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    19d0:	ea4f 120c 	mov.w	r2, ip, lsl #4
    19d4:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    19d8:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    19dc:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    19de:	ea4e 1010 	orr.w	r0, lr, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    19e2:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    19e6:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    19ea:	ea40 3008 	orr.w	r0, r0, r8, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    19ee:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    19f2:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    19f4:	ea41 0100 	orr.w	r1, r1, r0
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->z));
    19f8:	f105 001c 	add.w	r0, r5, #28

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    19fc:	f000 8109 	beq.w	1c12 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x366>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1a00:	f240 4e7e 	movw	lr, #1150	; 0x47e
    1a04:	4573      	cmp	r3, lr
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1a06:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1a08:	d80f      	bhi.n	1a2a <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x17e>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1a0a:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    1a0e:	f300 8136 	bgt.w	1c7e <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x3d2>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1a12:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1a16:	f340 8153 	ble.w	1cc0 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x414>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1a1a:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    1a1e:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    1a20:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1a24:	40d1      	lsrs	r1, r2
    1a26:	2200      	movs	r2, #0
    1a28:	e0f5      	b.n	1c16 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x36a>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1a2a:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1a2e:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1a30:	f02c 0c7f 	bic.w	ip, ip, #127	; 0x7f
    1a34:	4313      	orrs	r3, r2
    1a36:	ea43 630c 	orr.w	r3, r3, ip, lsl #24

    memcpy(f, &val, sizeof(val));
    1a3a:	2204      	movs	r2, #4
    1a3c:	4631      	mov	r1, r6
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1a3e:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    1a40:	f004 f89a 	bl	5b78 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1a44:	f894 c01f 	ldrb.w	ip, [r4, #31]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1a48:	f894 e01c 	ldrb.w	lr, [r4, #28]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1a4c:	7fa3      	ldrb	r3, [r4, #30]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    1a4e:	7ee0      	ldrb	r0, [r4, #27]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1a50:	f894 801d 	ldrb.w	r8, [r4, #29]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1a54:	ea4f 120c 	mov.w	r2, ip, lsl #4
    1a58:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1a5c:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1a60:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1a62:	ea4e 1010 	orr.w	r0, lr, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1a66:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    1a6a:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1a6e:	ea40 3008 	orr.w	r0, r0, r8, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1a72:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1a76:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1a78:	ea41 0100 	orr.w	r1, r1, r0
    }

    virtual int deserialize(unsigned char *inbuffer) override
    {
      int offset = 0;
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->x));
    1a7c:	f105 0024 	add.w	r0, r5, #36	; 0x24

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1a80:	f000 80be 	beq.w	1c00 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x354>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1a84:	f240 4e7e 	movw	lr, #1150	; 0x47e
    1a88:	4573      	cmp	r3, lr
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1a8a:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1a8c:	d80f      	bhi.n	1aae <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x202>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1a8e:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    1a92:	f300 80fd 	bgt.w	1c90 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x3e4>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1a96:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1a9a:	f340 8113 	ble.w	1cc4 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x418>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1a9e:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    1aa2:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    1aa4:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1aa8:	40d1      	lsrs	r1, r2
    1aaa:	2200      	movs	r2, #0
    1aac:	e0aa      	b.n	1c04 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x358>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1aae:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1ab2:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1ab4:	f02c 0c7f 	bic.w	ip, ip, #127	; 0x7f
    1ab8:	4313      	orrs	r3, r2
    1aba:	ea43 630c 	orr.w	r3, r3, ip, lsl #24

    memcpy(f, &val, sizeof(val));
    1abe:	2204      	movs	r2, #4
    1ac0:	4631      	mov	r1, r6
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1ac2:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    1ac4:	f004 f858 	bl	5b78 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1ac8:	f894 c027 	ldrb.w	ip, [r4, #39]	; 0x27
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1acc:	f894 e024 	ldrb.w	lr, [r4, #36]	; 0x24
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1ad0:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    1ad4:	f894 0023 	ldrb.w	r0, [r4, #35]	; 0x23
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1ad8:	f894 8025 	ldrb.w	r8, [r4, #37]	; 0x25
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1adc:	ea4f 120c 	mov.w	r2, ip, lsl #4
    1ae0:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1ae4:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1ae8:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1aea:	ea4e 1010 	orr.w	r0, lr, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1aee:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    1af2:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1af6:	ea40 3008 	orr.w	r0, r0, r8, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1afa:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1afe:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1b00:	ea41 0100 	orr.w	r1, r1, r0
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->y));
    1b04:	f105 0028 	add.w	r0, r5, #40	; 0x28

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1b08:	d071      	beq.n	1bee <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x342>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1b0a:	f240 4e7e 	movw	lr, #1150	; 0x47e
    1b0e:	4573      	cmp	r3, lr
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1b10:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1b12:	d80f      	bhi.n	1b34 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x288>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1b14:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    1b18:	f300 809f 	bgt.w	1c5a <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x3ae>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1b1c:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1b20:	f340 80ca 	ble.w	1cb8 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x40c>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1b24:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    1b28:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    1b2a:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1b2e:	40d1      	lsrs	r1, r2
    1b30:	2200      	movs	r2, #0
    1b32:	e05e      	b.n	1bf2 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x346>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1b34:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1b38:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1b3a:	f02c 0c7f 	bic.w	ip, ip, #127	; 0x7f
    1b3e:	4313      	orrs	r3, r2
    1b40:	ea43 630c 	orr.w	r3, r3, ip, lsl #24

    memcpy(f, &val, sizeof(val));
    1b44:	2204      	movs	r2, #4
    1b46:	4631      	mov	r1, r6
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1b48:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    1b4a:	f004 f815 	bl	5b78 <memcpy>
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1b4e:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1b52:	f894 e02f 	ldrb.w	lr, [r4, #47]	; 0x2f

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1b56:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    1b5a:	f894 002b 	ldrb.w	r0, [r4, #43]	; 0x2b
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1b5e:	f894 c02d 	ldrb.w	ip, [r4, #45]	; 0x2d
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1b62:	0114      	lsls	r4, r2, #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1b64:	ea4f 120e 	mov.w	r2, lr, lsl #4
    1b68:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1b6c:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1b6e:	ea44 1010 	orr.w	r0, r4, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1b72:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    1b76:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1b7a:	ea40 300c 	orr.w	r0, r0, ip, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1b7e:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1b82:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1b84:	ea41 0100 	orr.w	r1, r1, r0
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->z));
    1b88:	f105 002c 	add.w	r0, r5, #44	; 0x2c

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1b8c:	d026      	beq.n	1bdc <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x330>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1b8e:	f240 447e 	movw	r4, #1150	; 0x47e
    1b92:	42a3      	cmp	r3, r4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1b94:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1b96:	d80e      	bhi.n	1bb6 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x30a>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1b98:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    1b9c:	dc54      	bgt.n	1c48 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x39c>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1b9e:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1ba2:	f340 8087 	ble.w	1cb4 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x408>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1ba6:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    1baa:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    1bac:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1bb0:	40d1      	lsrs	r1, r2
    1bb2:	2200      	movs	r2, #0
    1bb4:	e014      	b.n	1be0 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x334>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1bb6:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1bba:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1bbc:	f02e 0e7f 	bic.w	lr, lr, #127	; 0x7f
    1bc0:	4313      	orrs	r3, r2
    1bc2:	ea43 630e 	orr.w	r3, r3, lr, lsl #24

    memcpy(f, &val, sizeof(val));
    1bc6:	4631      	mov	r1, r6
    1bc8:	2204      	movs	r2, #4
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1bca:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    1bcc:	f003 ffd4 	bl	5b78 <memcpy>
    this->cb_(msg);
    1bd0:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    1bd2:	4638      	mov	r0, r7
  }
    1bd4:	b002      	add	sp, #8
    1bd6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  };

  virtual void callback(unsigned char* data) override
  {
    msg.deserialize(data);
    this->cb_(msg);
    1bda:	4718      	bx	r3

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1bdc:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    1be0:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1be4:	4299      	cmp	r1, r3
    1be6:	d036      	beq.n	1c56 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x3aa>
    1be8:	1c4b      	adds	r3, r1, #1
    1bea:	085b      	lsrs	r3, r3, #1
    1bec:	e7e6      	b.n	1bbc <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x310>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1bee:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    1bf2:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1bf6:	4299      	cmp	r1, r3
    1bf8:	d036      	beq.n	1c68 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x3bc>
    1bfa:	1c4b      	adds	r3, r1, #1
    1bfc:	085b      	lsrs	r3, r3, #1
    1bfe:	e79c      	b.n	1b3a <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x28e>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1c00:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    1c04:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1c08:	4299      	cmp	r1, r3
    1c0a:	d048      	beq.n	1c9e <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x3f2>
    1c0c:	1c4b      	adds	r3, r1, #1
    1c0e:	085b      	lsrs	r3, r3, #1
    1c10:	e750      	b.n	1ab4 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x208>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1c12:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    1c16:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1c1a:	4299      	cmp	r1, r3
    1c1c:	d036      	beq.n	1c8c <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x3e0>
    1c1e:	1c4b      	adds	r3, r1, #1
    1c20:	085b      	lsrs	r3, r3, #1
    1c22:	e705      	b.n	1a30 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x184>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1c24:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    1c28:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1c2c:	4299      	cmp	r1, r3
    1c2e:	d03f      	beq.n	1cb0 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x404>
    1c30:	1c4b      	adds	r3, r1, #1
    1c32:	085b      	lsrs	r3, r3, #1
    1c34:	e6ba      	b.n	19ac <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x100>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1c36:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    1c3a:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1c3e:	4299      	cmp	r1, r3
    1c40:	d01b      	beq.n	1c7a <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x3ce>
    1c42:	1c4b      	adds	r3, r1, #1
    1c44:	085b      	lsrs	r3, r3, #1
    1c46:	e65d      	b.n	1904 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x58>
    1c48:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    1c4c:	05da      	lsls	r2, r3, #23
    1c4e:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1c52:	4299      	cmp	r1, r3
    1c54:	d1c8      	bne.n	1be8 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x33c>
    1c56:	4b1d      	ldr	r3, [pc, #116]	; (1ccc <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x420>)
    1c58:	e7b0      	b.n	1bbc <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x310>
    1c5a:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    1c5e:	05da      	lsls	r2, r3, #23
    1c60:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1c64:	4299      	cmp	r1, r3
    1c66:	d1c8      	bne.n	1bfa <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x34e>
    1c68:	4b18      	ldr	r3, [pc, #96]	; (1ccc <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x420>)
    1c6a:	e766      	b.n	1b3a <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x28e>
    1c6c:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    1c70:	05da      	lsls	r2, r3, #23
    1c72:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1c76:	4299      	cmp	r1, r3
    1c78:	d1e3      	bne.n	1c42 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x396>
    1c7a:	4b14      	ldr	r3, [pc, #80]	; (1ccc <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x420>)
    1c7c:	e642      	b.n	1904 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x58>
    1c7e:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    1c82:	05da      	lsls	r2, r3, #23
    1c84:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1c88:	4299      	cmp	r1, r3
    1c8a:	d1c8      	bne.n	1c1e <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x372>
    1c8c:	4b0f      	ldr	r3, [pc, #60]	; (1ccc <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x420>)
    1c8e:	e6cf      	b.n	1a30 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x184>
    1c90:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    1c94:	05da      	lsls	r2, r3, #23
    1c96:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1c9a:	4299      	cmp	r1, r3
    1c9c:	d1b6      	bne.n	1c0c <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x360>
    1c9e:	4b0b      	ldr	r3, [pc, #44]	; (1ccc <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x420>)
    1ca0:	e708      	b.n	1ab4 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x208>
    1ca2:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    1ca6:	05da      	lsls	r2, r3, #23
    1ca8:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1cac:	4299      	cmp	r1, r3
    1cae:	d1bf      	bne.n	1c30 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x384>
    1cb0:	4b06      	ldr	r3, [pc, #24]	; (1ccc <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x420>)
    1cb2:	e67b      	b.n	19ac <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x100>
    }
    else if (exp - 1023 >= -126)
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1cb4:	2200      	movs	r2, #0
    1cb6:	e793      	b.n	1be0 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x334>
    1cb8:	2200      	movs	r2, #0
    1cba:	e79a      	b.n	1bf2 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x346>
    1cbc:	2200      	movs	r2, #0
    1cbe:	e7bc      	b.n	1c3a <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x38e>
    1cc0:	2200      	movs	r2, #0
    1cc2:	e7a8      	b.n	1c16 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x36a>
    1cc4:	2200      	movs	r2, #0
    1cc6:	e79d      	b.n	1c04 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x358>
    1cc8:	2200      	movs	r2, #0
    1cca:	e7ad      	b.n	1c28 <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)+0x37c>
    1ccc:	007fffff 	.word	0x007fffff

00001cd0 <geometry_msgs::Twist::deserialize(unsigned char*)>:

    virtual int deserialize(unsigned char *inbuffer) override
    1cd0:	b5f0      	push	{r4, r5, r6, r7, lr}
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1cd2:	79cf      	ldrb	r7, [r1, #7]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1cd4:	790d      	ldrb	r5, [r1, #4]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1cd6:	798b      	ldrb	r3, [r1, #6]
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1cd8:	f891 e005 	ldrb.w	lr, [r1, #5]
    1cdc:	4606      	mov	r6, r0
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1cde:	013a      	lsls	r2, r7, #4

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    1ce0:	78c8      	ldrb	r0, [r1, #3]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1ce2:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1ce6:	012d      	lsls	r5, r5, #4
    1ce8:	460c      	mov	r4, r1
    1cea:	ea45 1010 	orr.w	r0, r5, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1cee:	0519      	lsls	r1, r3, #20

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1cf0:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    1cf4:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1cf8:	ea40 300e 	orr.w	r0, r0, lr, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1cfc:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1d00:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1d02:	ea41 0100 	orr.w	r1, r1, r0
    1d06:	b083      	sub	sp, #12
    }

    virtual int deserialize(unsigned char *inbuffer) override
    {
      int offset = 0;
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->x));
    1d08:	f106 0008 	add.w	r0, r6, #8

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1d0c:	f000 8196 	beq.w	203c <geometry_msgs::Twist::deserialize(unsigned char*)+0x36c>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1d10:	f240 457e 	movw	r5, #1150	; 0x47e
    1d14:	42ab      	cmp	r3, r5
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1d16:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1d18:	d941      	bls.n	1d9e <geometry_msgs::Twist::deserialize(unsigned char*)+0xce>
    1d1a:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1d1e:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1d20:	f027 077f 	bic.w	r7, r7, #127	; 0x7f
    1d24:	4313      	orrs	r3, r2
    1d26:	ad02      	add	r5, sp, #8
    1d28:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
    1d2c:	f845 3d04 	str.w	r3, [r5, #-4]!

    memcpy(f, &val, sizeof(val));
    1d30:	2204      	movs	r2, #4
    1d32:	4629      	mov	r1, r5
    1d34:	f003 ff20 	bl	5b78 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1d38:	f894 e00f 	ldrb.w	lr, [r4, #15]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1d3c:	7b27      	ldrb	r7, [r4, #12]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1d3e:	7ba3      	ldrb	r3, [r4, #14]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    1d40:	7ae0      	ldrb	r0, [r4, #11]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1d42:	f894 c00d 	ldrb.w	ip, [r4, #13]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1d46:	ea4f 120e 	mov.w	r2, lr, lsl #4
    1d4a:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1d4e:	013f      	lsls	r7, r7, #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1d50:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1d52:	ea47 1010 	orr.w	r0, r7, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1d56:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    1d5a:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1d5e:	ea40 300c 	orr.w	r0, r0, ip, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1d62:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1d66:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1d68:	ea41 0100 	orr.w	r1, r1, r0
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->y));
    1d6c:	f106 000c 	add.w	r0, r6, #12

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1d70:	f000 815b 	beq.w	202a <geometry_msgs::Twist::deserialize(unsigned char*)+0x35a>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1d74:	f240 477e 	movw	r7, #1150	; 0x47e
    1d78:	42bb      	cmp	r3, r7
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1d7a:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1d7c:	d81f      	bhi.n	1dbe <geometry_msgs::Twist::deserialize(unsigned char*)+0xee>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1d7e:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    1d82:	f300 8191 	bgt.w	20a8 <geometry_msgs::Twist::deserialize(unsigned char*)+0x3d8>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1d86:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1d8a:	f340 81a0 	ble.w	20ce <geometry_msgs::Twist::deserialize(unsigned char*)+0x3fe>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1d8e:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    1d92:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    1d94:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1d98:	40d1      	lsrs	r1, r2
    1d9a:	2200      	movs	r2, #0
    1d9c:	e147      	b.n	202e <geometry_msgs::Twist::deserialize(unsigned char*)+0x35e>
    else if (exp - 1023 > 127)
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1d9e:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    1da2:	f300 8166 	bgt.w	2072 <geometry_msgs::Twist::deserialize(unsigned char*)+0x3a2>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1da6:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1daa:	f340 818a 	ble.w	20c2 <geometry_msgs::Twist::deserialize(unsigned char*)+0x3f2>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1dae:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    1db2:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    1db4:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1db8:	40d1      	lsrs	r1, r2
    1dba:	2200      	movs	r2, #0
    1dbc:	e140      	b.n	2040 <geometry_msgs::Twist::deserialize(unsigned char*)+0x370>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1dbe:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1dc2:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1dc4:	f02e 0e7f 	bic.w	lr, lr, #127	; 0x7f
    1dc8:	4313      	orrs	r3, r2
    1dca:	ea43 630e 	orr.w	r3, r3, lr, lsl #24

    memcpy(f, &val, sizeof(val));
    1dce:	2204      	movs	r2, #4
    1dd0:	4629      	mov	r1, r5
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1dd2:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    1dd4:	f003 fed0 	bl	5b78 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1dd8:	f894 e017 	ldrb.w	lr, [r4, #23]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1ddc:	7d27      	ldrb	r7, [r4, #20]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1dde:	7da3      	ldrb	r3, [r4, #22]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    1de0:	7ce0      	ldrb	r0, [r4, #19]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1de2:	f894 c015 	ldrb.w	ip, [r4, #21]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1de6:	ea4f 120e 	mov.w	r2, lr, lsl #4
    1dea:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1dee:	013f      	lsls	r7, r7, #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1df0:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1df2:	ea47 1010 	orr.w	r0, r7, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1df6:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    1dfa:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1dfe:	ea40 300c 	orr.w	r0, r0, ip, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1e02:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1e06:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1e08:	ea41 0100 	orr.w	r1, r1, r0
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->z));
    1e0c:	f106 0010 	add.w	r0, r6, #16

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1e10:	f000 8102 	beq.w	2018 <geometry_msgs::Twist::deserialize(unsigned char*)+0x348>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1e14:	f240 477e 	movw	r7, #1150	; 0x47e
    1e18:	42bb      	cmp	r3, r7
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1e1a:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1e1c:	d80f      	bhi.n	1e3e <geometry_msgs::Twist::deserialize(unsigned char*)+0x16e>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1e1e:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    1e22:	f300 812f 	bgt.w	2084 <geometry_msgs::Twist::deserialize(unsigned char*)+0x3b4>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1e26:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1e2a:	f340 814c 	ble.w	20c6 <geometry_msgs::Twist::deserialize(unsigned char*)+0x3f6>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1e2e:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    1e32:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    1e34:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1e38:	40d1      	lsrs	r1, r2
    1e3a:	2200      	movs	r2, #0
    1e3c:	e0ee      	b.n	201c <geometry_msgs::Twist::deserialize(unsigned char*)+0x34c>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1e3e:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1e42:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1e44:	f02e 0e7f 	bic.w	lr, lr, #127	; 0x7f
    1e48:	4313      	orrs	r3, r2
    1e4a:	ea43 630e 	orr.w	r3, r3, lr, lsl #24

    memcpy(f, &val, sizeof(val));
    1e4e:	2204      	movs	r2, #4
    1e50:	4629      	mov	r1, r5
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1e52:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    1e54:	f003 fe90 	bl	5b78 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1e58:	f894 e01f 	ldrb.w	lr, [r4, #31]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1e5c:	7f27      	ldrb	r7, [r4, #28]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1e5e:	7fa3      	ldrb	r3, [r4, #30]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    1e60:	7ee0      	ldrb	r0, [r4, #27]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1e62:	f894 c01d 	ldrb.w	ip, [r4, #29]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1e66:	ea4f 120e 	mov.w	r2, lr, lsl #4
    1e6a:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1e6e:	013f      	lsls	r7, r7, #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1e70:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1e72:	ea47 1010 	orr.w	r0, r7, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1e76:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    1e7a:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1e7e:	ea40 300c 	orr.w	r0, r0, ip, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1e82:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1e86:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1e88:	ea41 0100 	orr.w	r1, r1, r0
    }

    virtual int deserialize(unsigned char *inbuffer) override
    {
      int offset = 0;
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->x));
    1e8c:	f106 0018 	add.w	r0, r6, #24

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1e90:	f000 80b9 	beq.w	2006 <geometry_msgs::Twist::deserialize(unsigned char*)+0x336>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1e94:	f240 477e 	movw	r7, #1150	; 0x47e
    1e98:	42bb      	cmp	r3, r7
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1e9a:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1e9c:	d80f      	bhi.n	1ebe <geometry_msgs::Twist::deserialize(unsigned char*)+0x1ee>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1e9e:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    1ea2:	f300 80f8 	bgt.w	2096 <geometry_msgs::Twist::deserialize(unsigned char*)+0x3c6>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1ea6:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1eaa:	f340 810e 	ble.w	20ca <geometry_msgs::Twist::deserialize(unsigned char*)+0x3fa>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1eae:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    1eb2:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    1eb4:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1eb8:	40d1      	lsrs	r1, r2
    1eba:	2200      	movs	r2, #0
    1ebc:	e0a5      	b.n	200a <geometry_msgs::Twist::deserialize(unsigned char*)+0x33a>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1ebe:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1ec2:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1ec4:	f02e 0e7f 	bic.w	lr, lr, #127	; 0x7f
    1ec8:	4313      	orrs	r3, r2
    1eca:	ea43 630e 	orr.w	r3, r3, lr, lsl #24

    memcpy(f, &val, sizeof(val));
    1ece:	2204      	movs	r2, #4
    1ed0:	4629      	mov	r1, r5
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1ed2:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    1ed4:	f003 fe50 	bl	5b78 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1ed8:	f894 e027 	ldrb.w	lr, [r4, #39]	; 0x27
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1edc:	f894 7024 	ldrb.w	r7, [r4, #36]	; 0x24
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1ee0:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    1ee4:	f894 0023 	ldrb.w	r0, [r4, #35]	; 0x23
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1ee8:	f894 c025 	ldrb.w	ip, [r4, #37]	; 0x25
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1eec:	ea4f 120e 	mov.w	r2, lr, lsl #4
    1ef0:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1ef4:	013f      	lsls	r7, r7, #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1ef6:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1ef8:	ea47 1010 	orr.w	r0, r7, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1efc:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    1f00:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1f04:	ea40 300c 	orr.w	r0, r0, ip, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1f08:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1f0c:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1f0e:	ea41 0100 	orr.w	r1, r1, r0
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->y));
    1f12:	f106 001c 	add.w	r0, r6, #28

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1f16:	d06d      	beq.n	1ff4 <geometry_msgs::Twist::deserialize(unsigned char*)+0x324>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1f18:	f240 477e 	movw	r7, #1150	; 0x47e
    1f1c:	42bb      	cmp	r3, r7
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1f1e:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1f20:	d80f      	bhi.n	1f42 <geometry_msgs::Twist::deserialize(unsigned char*)+0x272>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1f22:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    1f26:	f300 809b 	bgt.w	2060 <geometry_msgs::Twist::deserialize(unsigned char*)+0x390>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1f2a:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1f2e:	f340 80c6 	ble.w	20be <geometry_msgs::Twist::deserialize(unsigned char*)+0x3ee>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1f32:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    1f36:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    1f38:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1f3c:	40d1      	lsrs	r1, r2
    1f3e:	2200      	movs	r2, #0
    1f40:	e05a      	b.n	1ff8 <geometry_msgs::Twist::deserialize(unsigned char*)+0x328>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1f42:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1f46:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1f48:	f02e 0e7f 	bic.w	lr, lr, #127	; 0x7f
    1f4c:	4313      	orrs	r3, r2
    1f4e:	ea43 630e 	orr.w	r3, r3, lr, lsl #24

    memcpy(f, &val, sizeof(val));
    1f52:	2204      	movs	r2, #4
    1f54:	4629      	mov	r1, r5
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1f56:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    1f58:	f003 fe0e 	bl	5b78 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1f5c:	f894 702f 	ldrb.w	r7, [r4, #47]	; 0x2f
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1f60:	f894 002c 	ldrb.w	r0, [r4, #44]	; 0x2c

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    1f64:	f894 102b 	ldrb.w	r1, [r4, #43]	; 0x2b
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1f68:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1f6c:	f894 e02d 	ldrb.w	lr, [r4, #45]	; 0x2d
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1f70:	013a      	lsls	r2, r7, #4
    1f72:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    1f76:	0100      	lsls	r0, r0, #4
    1f78:	ea40 1011 	orr.w	r0, r0, r1, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1f7c:	0519      	lsls	r1, r3, #20

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1f7e:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    1f82:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    1f86:	ea40 340e 	orr.w	r4, r0, lr, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1f8a:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1f8e:	4293      	cmp	r3, r2
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->z));
    1f90:	f106 0020 	add.w	r0, r6, #32

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    1f94:	ea41 0104 	orr.w	r1, r1, r4

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1f98:	d023      	beq.n	1fe2 <geometry_msgs::Twist::deserialize(unsigned char*)+0x312>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1f9a:	f240 447e 	movw	r4, #1150	; 0x47e
    1f9e:	42a3      	cmp	r3, r4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    1fa0:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1fa2:	d80e      	bhi.n	1fc2 <geometry_msgs::Twist::deserialize(unsigned char*)+0x2f2>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    1fa4:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    1fa8:	dc51      	bgt.n	204e <geometry_msgs::Twist::deserialize(unsigned char*)+0x37e>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    1faa:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    1fae:	f340 8084 	ble.w	20ba <geometry_msgs::Twist::deserialize(unsigned char*)+0x3ea>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    1fb2:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    1fb6:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    1fb8:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    1fbc:	40d1      	lsrs	r1, r2
    1fbe:	2200      	movs	r2, #0
    1fc0:	e011      	b.n	1fe6 <geometry_msgs::Twist::deserialize(unsigned char*)+0x316>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    1fc2:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    1fc6:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1fc8:	f027 077f 	bic.w	r7, r7, #127	; 0x7f
    1fcc:	4313      	orrs	r3, r2
    1fce:	ea43 6307 	orr.w	r3, r3, r7, lsl #24

    memcpy(f, &val, sizeof(val));
    1fd2:	4629      	mov	r1, r5
    1fd4:	2204      	movs	r2, #4
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    1fd6:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    1fd8:	f003 fdce 	bl	5b78 <memcpy>
    {
      int offset = 0;
      offset += this->linear.deserialize(inbuffer + offset);
      offset += this->angular.deserialize(inbuffer + offset);
     return offset;
    }
    1fdc:	2030      	movs	r0, #48	; 0x30
    1fde:	b003      	add	sp, #12
    1fe0:	bdf0      	pop	{r4, r5, r6, r7, pc}

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1fe2:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    1fe6:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1fea:	4299      	cmp	r1, r3
    1fec:	d036      	beq.n	205c <geometry_msgs::Twist::deserialize(unsigned char*)+0x38c>
    1fee:	1c4b      	adds	r3, r1, #1
    1ff0:	085b      	lsrs	r3, r3, #1
    1ff2:	e7e9      	b.n	1fc8 <geometry_msgs::Twist::deserialize(unsigned char*)+0x2f8>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    1ff4:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    1ff8:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    1ffc:	4299      	cmp	r1, r3
    1ffe:	d036      	beq.n	206e <geometry_msgs::Twist::deserialize(unsigned char*)+0x39e>
    2000:	1c4b      	adds	r3, r1, #1
    2002:	085b      	lsrs	r3, r3, #1
    2004:	e7a0      	b.n	1f48 <geometry_msgs::Twist::deserialize(unsigned char*)+0x278>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    2006:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    200a:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    200e:	4299      	cmp	r1, r3
    2010:	d048      	beq.n	20a4 <geometry_msgs::Twist::deserialize(unsigned char*)+0x3d4>
    2012:	1c4b      	adds	r3, r1, #1
    2014:	085b      	lsrs	r3, r3, #1
    2016:	e755      	b.n	1ec4 <geometry_msgs::Twist::deserialize(unsigned char*)+0x1f4>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    2018:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    201c:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    2020:	4299      	cmp	r1, r3
    2022:	d036      	beq.n	2092 <geometry_msgs::Twist::deserialize(unsigned char*)+0x3c2>
    2024:	1c4b      	adds	r3, r1, #1
    2026:	085b      	lsrs	r3, r3, #1
    2028:	e70c      	b.n	1e44 <geometry_msgs::Twist::deserialize(unsigned char*)+0x174>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    202a:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    202e:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    2032:	4299      	cmp	r1, r3
    2034:	d03f      	beq.n	20b6 <geometry_msgs::Twist::deserialize(unsigned char*)+0x3e6>
    2036:	1c4b      	adds	r3, r1, #1
    2038:	085b      	lsrs	r3, r3, #1
    203a:	e6c3      	b.n	1dc4 <geometry_msgs::Twist::deserialize(unsigned char*)+0xf4>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    203c:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    2040:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    2044:	4299      	cmp	r1, r3
    2046:	d01b      	beq.n	2080 <geometry_msgs::Twist::deserialize(unsigned char*)+0x3b0>
    2048:	1c4b      	adds	r3, r1, #1
    204a:	085b      	lsrs	r3, r3, #1
    204c:	e668      	b.n	1d20 <geometry_msgs::Twist::deserialize(unsigned char*)+0x50>
    204e:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    2052:	05da      	lsls	r2, r3, #23
    2054:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    2058:	4299      	cmp	r1, r3
    205a:	d1c8      	bne.n	1fee <geometry_msgs::Twist::deserialize(unsigned char*)+0x31e>
    205c:	4b1d      	ldr	r3, [pc, #116]	; (20d4 <geometry_msgs::Twist::deserialize(unsigned char*)+0x404>)
    205e:	e7b3      	b.n	1fc8 <geometry_msgs::Twist::deserialize(unsigned char*)+0x2f8>
    2060:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    2064:	05da      	lsls	r2, r3, #23
    2066:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    206a:	4299      	cmp	r1, r3
    206c:	d1c8      	bne.n	2000 <geometry_msgs::Twist::deserialize(unsigned char*)+0x330>
    206e:	4b19      	ldr	r3, [pc, #100]	; (20d4 <geometry_msgs::Twist::deserialize(unsigned char*)+0x404>)
    2070:	e76a      	b.n	1f48 <geometry_msgs::Twist::deserialize(unsigned char*)+0x278>
    2072:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    2076:	05da      	lsls	r2, r3, #23
    2078:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    207c:	4299      	cmp	r1, r3
    207e:	d1e3      	bne.n	2048 <geometry_msgs::Twist::deserialize(unsigned char*)+0x378>
    2080:	4b14      	ldr	r3, [pc, #80]	; (20d4 <geometry_msgs::Twist::deserialize(unsigned char*)+0x404>)
    2082:	e64d      	b.n	1d20 <geometry_msgs::Twist::deserialize(unsigned char*)+0x50>
    2084:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    2088:	05da      	lsls	r2, r3, #23
    208a:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    208e:	4299      	cmp	r1, r3
    2090:	d1c8      	bne.n	2024 <geometry_msgs::Twist::deserialize(unsigned char*)+0x354>
    2092:	4b10      	ldr	r3, [pc, #64]	; (20d4 <geometry_msgs::Twist::deserialize(unsigned char*)+0x404>)
    2094:	e6d6      	b.n	1e44 <geometry_msgs::Twist::deserialize(unsigned char*)+0x174>
    2096:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    209a:	05da      	lsls	r2, r3, #23
    209c:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    20a0:	4299      	cmp	r1, r3
    20a2:	d1b6      	bne.n	2012 <geometry_msgs::Twist::deserialize(unsigned char*)+0x342>
    20a4:	4b0b      	ldr	r3, [pc, #44]	; (20d4 <geometry_msgs::Twist::deserialize(unsigned char*)+0x404>)
    20a6:	e70d      	b.n	1ec4 <geometry_msgs::Twist::deserialize(unsigned char*)+0x1f4>
    20a8:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    20ac:	05da      	lsls	r2, r3, #23
    20ae:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    20b2:	4299      	cmp	r1, r3
    20b4:	d1bf      	bne.n	2036 <geometry_msgs::Twist::deserialize(unsigned char*)+0x366>
    20b6:	4b07      	ldr	r3, [pc, #28]	; (20d4 <geometry_msgs::Twist::deserialize(unsigned char*)+0x404>)
    20b8:	e684      	b.n	1dc4 <geometry_msgs::Twist::deserialize(unsigned char*)+0xf4>
    }
    else if (exp - 1023 >= -126)
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    20ba:	2200      	movs	r2, #0
    20bc:	e793      	b.n	1fe6 <geometry_msgs::Twist::deserialize(unsigned char*)+0x316>
    20be:	2200      	movs	r2, #0
    20c0:	e79a      	b.n	1ff8 <geometry_msgs::Twist::deserialize(unsigned char*)+0x328>
    20c2:	2200      	movs	r2, #0
    20c4:	e7bc      	b.n	2040 <geometry_msgs::Twist::deserialize(unsigned char*)+0x370>
    20c6:	2200      	movs	r2, #0
    20c8:	e7a8      	b.n	201c <geometry_msgs::Twist::deserialize(unsigned char*)+0x34c>
    20ca:	2200      	movs	r2, #0
    20cc:	e79d      	b.n	200a <geometry_msgs::Twist::deserialize(unsigned char*)+0x33a>
    20ce:	2200      	movs	r2, #0
    20d0:	e7ad      	b.n	202e <geometry_msgs::Twist::deserialize(unsigned char*)+0x35e>
    20d2:	bf00      	nop
    20d4:	007fffff 	.word	0x007fffff

000020d8 <geometry_msgs::Vector3::deserialize(unsigned char*)>:
      offset += serializeAvrFloat64(outbuffer + offset, this->y);
      offset += serializeAvrFloat64(outbuffer + offset, this->z);
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
    20d8:	b5f0      	push	{r4, r5, r6, r7, lr}
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    20da:	79cf      	ldrb	r7, [r1, #7]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    20dc:	790d      	ldrb	r5, [r1, #4]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    20de:	798b      	ldrb	r3, [r1, #6]
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    20e0:	f891 e005 	ldrb.w	lr, [r1, #5]
    20e4:	4606      	mov	r6, r0
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    20e6:	013a      	lsls	r2, r7, #4

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    20e8:	78c8      	ldrb	r0, [r1, #3]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    20ea:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    20ee:	012d      	lsls	r5, r5, #4
    20f0:	460c      	mov	r4, r1
    20f2:	ea45 1010 	orr.w	r0, r5, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    20f6:	0519      	lsls	r1, r3, #20

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    20f8:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    20fc:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    2100:	ea40 300e 	orr.w	r0, r0, lr, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    2104:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    2108:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    210a:	ea41 0100 	orr.w	r1, r1, r0
    210e:	b083      	sub	sp, #12
    {
      int offset = 0;
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->x));
    2110:	f106 0004 	add.w	r0, r6, #4

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    2114:	f000 80b2 	beq.w	227c <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1a4>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    2118:	f240 457e 	movw	r5, #1150	; 0x47e
    211c:	42ab      	cmp	r3, r5
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    211e:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    2120:	d940      	bls.n	21a4 <geometry_msgs::Vector3::deserialize(unsigned char*)+0xcc>
    2122:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    2126:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    2128:	f027 077f 	bic.w	r7, r7, #127	; 0x7f
    212c:	4313      	orrs	r3, r2
    212e:	ad02      	add	r5, sp, #8
    2130:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
    2134:	f845 3d04 	str.w	r3, [r5, #-4]!

    memcpy(f, &val, sizeof(val));
    2138:	2204      	movs	r2, #4
    213a:	4629      	mov	r1, r5
    213c:	f003 fd1c 	bl	5b78 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    2140:	f894 e00f 	ldrb.w	lr, [r4, #15]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    2144:	7b27      	ldrb	r7, [r4, #12]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    2146:	7ba3      	ldrb	r3, [r4, #14]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    2148:	7ae0      	ldrb	r0, [r4, #11]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    214a:	f894 c00d 	ldrb.w	ip, [r4, #13]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    214e:	ea4f 120e 	mov.w	r2, lr, lsl #4
    2152:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    2156:	013f      	lsls	r7, r7, #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    2158:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    215a:	ea47 1010 	orr.w	r0, r7, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    215e:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    2162:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    2166:	ea40 300c 	orr.w	r0, r0, ip, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    216a:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    216e:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    2170:	ea41 0100 	orr.w	r1, r1, r0
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->y));
    2174:	f106 0008 	add.w	r0, r6, #8

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    2178:	d077      	beq.n	226a <geometry_msgs::Vector3::deserialize(unsigned char*)+0x192>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    217a:	f240 477e 	movw	r7, #1150	; 0x47e
    217e:	42bb      	cmp	r3, r7
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    2180:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    2182:	d81e      	bhi.n	21c2 <geometry_msgs::Vector3::deserialize(unsigned char*)+0xea>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    2184:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    2188:	f300 8093 	bgt.w	22b2 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1da>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    218c:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    2190:	f340 8098 	ble.w	22c4 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1ec>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    2194:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    2198:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    219a:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    219e:	40d1      	lsrs	r1, r2
    21a0:	2200      	movs	r2, #0
    21a2:	e064      	b.n	226e <geometry_msgs::Vector3::deserialize(unsigned char*)+0x196>
    else if (exp - 1023 > 127)
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    21a4:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    21a8:	dc7a      	bgt.n	22a0 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1c8>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    21aa:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    21ae:	f340 808d 	ble.w	22cc <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1f4>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    21b2:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    21b6:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    21b8:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    21bc:	40d1      	lsrs	r1, r2
    21be:	2200      	movs	r2, #0
    21c0:	e05e      	b.n	2280 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1a8>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    21c2:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    21c6:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    21c8:	f02e 0e7f 	bic.w	lr, lr, #127	; 0x7f
    21cc:	4313      	orrs	r3, r2
    21ce:	ea43 630e 	orr.w	r3, r3, lr, lsl #24

    memcpy(f, &val, sizeof(val));
    21d2:	2204      	movs	r2, #4
    21d4:	4629      	mov	r1, r5
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    21d6:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    21d8:	f003 fcce 	bl	5b78 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    21dc:	7de7      	ldrb	r7, [r4, #23]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    21de:	7d20      	ldrb	r0, [r4, #20]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    21e0:	7ce1      	ldrb	r1, [r4, #19]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    21e2:	7da3      	ldrb	r3, [r4, #22]
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    21e4:	f894 e015 	ldrb.w	lr, [r4, #21]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    21e8:	013a      	lsls	r2, r7, #4
    21ea:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    21ee:	0100      	lsls	r0, r0, #4
    21f0:	ea40 1011 	orr.w	r0, r0, r1, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    21f4:	0519      	lsls	r1, r3, #20

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    21f6:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    21fa:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    21fe:	ea40 340e 	orr.w	r4, r0, lr, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    2202:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    2206:	4293      	cmp	r3, r2
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->z));
    2208:	f106 000c 	add.w	r0, r6, #12

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    220c:	ea41 0104 	orr.w	r1, r1, r4

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    2210:	d022      	beq.n	2258 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x180>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    2212:	f240 447e 	movw	r4, #1150	; 0x47e
    2216:	42a3      	cmp	r3, r4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    2218:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    221a:	d80d      	bhi.n	2238 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x160>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    221c:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    2220:	dc35      	bgt.n	228e <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1b6>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    2222:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    2226:	dd4f      	ble.n	22c8 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1f0>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    2228:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    222c:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    222e:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    2232:	40d1      	lsrs	r1, r2
    2234:	2200      	movs	r2, #0
    2236:	e011      	b.n	225c <geometry_msgs::Vector3::deserialize(unsigned char*)+0x184>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    2238:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    223c:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    223e:	f027 077f 	bic.w	r7, r7, #127	; 0x7f
    2242:	4313      	orrs	r3, r2
    2244:	ea43 6307 	orr.w	r3, r3, r7, lsl #24

    memcpy(f, &val, sizeof(val));
    2248:	4629      	mov	r1, r5
    224a:	2204      	movs	r2, #4
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    224c:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    224e:	f003 fc93 	bl	5b78 <memcpy>
     return offset;
    }
    2252:	2018      	movs	r0, #24
    2254:	b003      	add	sp, #12
    2256:	bdf0      	pop	{r4, r5, r6, r7, pc}

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    2258:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    225c:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    2260:	4299      	cmp	r1, r3
    2262:	d01b      	beq.n	229c <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1c4>
    2264:	1c4b      	adds	r3, r1, #1
    2266:	085b      	lsrs	r3, r3, #1
    2268:	e7e9      	b.n	223e <geometry_msgs::Vector3::deserialize(unsigned char*)+0x166>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    226a:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    226e:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    2272:	4299      	cmp	r1, r3
    2274:	d024      	beq.n	22c0 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1e8>
    2276:	1c4b      	adds	r3, r1, #1
    2278:	085b      	lsrs	r3, r3, #1
    227a:	e7a5      	b.n	21c8 <geometry_msgs::Vector3::deserialize(unsigned char*)+0xf0>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    227c:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    2280:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    2284:	4299      	cmp	r1, r3
    2286:	d012      	beq.n	22ae <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1d6>
    2288:	1c4b      	adds	r3, r1, #1
    228a:	085b      	lsrs	r3, r3, #1
    228c:	e74c      	b.n	2128 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x50>
    228e:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    2292:	05da      	lsls	r2, r3, #23
    2294:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    2298:	4299      	cmp	r1, r3
    229a:	d1e3      	bne.n	2264 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x18c>
    229c:	4b0c      	ldr	r3, [pc, #48]	; (22d0 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1f8>)
    229e:	e7ce      	b.n	223e <geometry_msgs::Vector3::deserialize(unsigned char*)+0x166>
    22a0:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    22a4:	05da      	lsls	r2, r3, #23
    22a6:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    22aa:	4299      	cmp	r1, r3
    22ac:	d1ec      	bne.n	2288 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1b0>
    22ae:	4b08      	ldr	r3, [pc, #32]	; (22d0 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1f8>)
    22b0:	e73a      	b.n	2128 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x50>
    22b2:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    22b6:	05da      	lsls	r2, r3, #23
    22b8:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    22bc:	4299      	cmp	r1, r3
    22be:	d1da      	bne.n	2276 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x19e>
    22c0:	4b03      	ldr	r3, [pc, #12]	; (22d0 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1f8>)
    22c2:	e781      	b.n	21c8 <geometry_msgs::Vector3::deserialize(unsigned char*)+0xf0>
    }
    else if (exp - 1023 >= -126)
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    22c4:	2200      	movs	r2, #0
    22c6:	e7d2      	b.n	226e <geometry_msgs::Vector3::deserialize(unsigned char*)+0x196>
    22c8:	2200      	movs	r2, #0
    22ca:	e7c7      	b.n	225c <geometry_msgs::Vector3::deserialize(unsigned char*)+0x184>
    22cc:	2200      	movs	r2, #0
    22ce:	e7d7      	b.n	2280 <geometry_msgs::Vector3::deserialize(unsigned char*)+0x1a8>
    22d0:	007fffff 	.word	0x007fffff

000022d4 <geometry_msgs::Quaternion::deserialize(unsigned char*)>:

    virtual int deserialize(unsigned char *inbuffer) override
    22d4:	b5f0      	push	{r4, r5, r6, r7, lr}
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    22d6:	79cf      	ldrb	r7, [r1, #7]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    22d8:	790d      	ldrb	r5, [r1, #4]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    22da:	798b      	ldrb	r3, [r1, #6]
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    22dc:	f891 e005 	ldrb.w	lr, [r1, #5]
    22e0:	4606      	mov	r6, r0
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    22e2:	013a      	lsls	r2, r7, #4

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    22e4:	78c8      	ldrb	r0, [r1, #3]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    22e6:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    22ea:	012d      	lsls	r5, r5, #4
    22ec:	460c      	mov	r4, r1
    22ee:	ea45 1010 	orr.w	r0, r5, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    22f2:	0519      	lsls	r1, r3, #20

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    22f4:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    22f8:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    22fc:	ea40 300e 	orr.w	r0, r0, lr, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    2300:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    2304:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    2306:	ea41 0100 	orr.w	r1, r1, r0
    230a:	b083      	sub	sp, #12
    {
      int offset = 0;
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->x));
    230c:	f106 0004 	add.w	r0, r6, #4

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    2310:	f000 80fc 	beq.w	250c <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x238>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    2314:	f240 457e 	movw	r5, #1150	; 0x47e
    2318:	42ab      	cmp	r3, r5
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    231a:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    231c:	d941      	bls.n	23a2 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0xce>
    231e:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    2322:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    2324:	f027 077f 	bic.w	r7, r7, #127	; 0x7f
    2328:	4313      	orrs	r3, r2
    232a:	ad02      	add	r5, sp, #8
    232c:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
    2330:	f845 3d04 	str.w	r3, [r5, #-4]!

    memcpy(f, &val, sizeof(val));
    2334:	2204      	movs	r2, #4
    2336:	4629      	mov	r1, r5
    2338:	f003 fc1e 	bl	5b78 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    233c:	f894 e00f 	ldrb.w	lr, [r4, #15]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    2340:	7b27      	ldrb	r7, [r4, #12]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    2342:	7ba3      	ldrb	r3, [r4, #14]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    2344:	7ae0      	ldrb	r0, [r4, #11]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    2346:	f894 c00d 	ldrb.w	ip, [r4, #13]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    234a:	ea4f 120e 	mov.w	r2, lr, lsl #4
    234e:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    2352:	013f      	lsls	r7, r7, #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    2354:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    2356:	ea47 1010 	orr.w	r0, r7, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    235a:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    235e:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    2362:	ea40 300c 	orr.w	r0, r0, ip, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    2366:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    236a:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    236c:	ea41 0100 	orr.w	r1, r1, r0
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->y));
    2370:	f106 0008 	add.w	r0, r6, #8

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    2374:	f000 80c1 	beq.w	24fa <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x226>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    2378:	f240 477e 	movw	r7, #1150	; 0x47e
    237c:	42bb      	cmp	r3, r7
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    237e:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    2380:	d81f      	bhi.n	23c2 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0xee>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    2382:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    2386:	f300 80dc 	bgt.w	2542 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x26e>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    238a:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    238e:	f340 80ee 	ble.w	256e <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x29a>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    2392:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    2396:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    2398:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    239c:	40d1      	lsrs	r1, r2
    239e:	2200      	movs	r2, #0
    23a0:	e0ad      	b.n	24fe <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x22a>
    else if (exp - 1023 > 127)
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    23a2:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    23a6:	f300 80d5 	bgt.w	2554 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x280>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    23aa:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    23ae:	f340 80e0 	ble.w	2572 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x29e>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    23b2:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    23b6:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    23b8:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    23bc:	40d1      	lsrs	r1, r2
    23be:	2200      	movs	r2, #0
    23c0:	e0a6      	b.n	2510 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x23c>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    23c2:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    23c6:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    23c8:	f02e 0e7f 	bic.w	lr, lr, #127	; 0x7f
    23cc:	4313      	orrs	r3, r2
    23ce:	ea43 630e 	orr.w	r3, r3, lr, lsl #24

    memcpy(f, &val, sizeof(val));
    23d2:	2204      	movs	r2, #4
    23d4:	4629      	mov	r1, r5
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    23d6:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    23d8:	f003 fbce 	bl	5b78 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    23dc:	f894 e017 	ldrb.w	lr, [r4, #23]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    23e0:	7d27      	ldrb	r7, [r4, #20]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    23e2:	7da3      	ldrb	r3, [r4, #22]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    23e4:	7ce0      	ldrb	r0, [r4, #19]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    23e6:	f894 c015 	ldrb.w	ip, [r4, #21]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    23ea:	ea4f 120e 	mov.w	r2, lr, lsl #4
    23ee:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    23f2:	013f      	lsls	r7, r7, #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    23f4:	0519      	lsls	r1, r3, #20
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    23f6:	ea47 1010 	orr.w	r0, r7, r0, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    23fa:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    23fe:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    2402:	ea40 300c 	orr.w	r0, r0, ip, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    2406:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    240a:	4293      	cmp	r3, r2

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    240c:	ea41 0100 	orr.w	r1, r1, r0
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->z));
    2410:	f106 000c 	add.w	r0, r6, #12

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    2414:	d068      	beq.n	24e8 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x214>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    2416:	f240 477e 	movw	r7, #1150	; 0x47e
    241a:	42bb      	cmp	r3, r7
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    241c:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    241e:	d80f      	bhi.n	2440 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x16c>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    2420:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    2424:	f300 8084 	bgt.w	2530 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x25c>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    2428:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    242c:	f340 809d 	ble.w	256a <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x296>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    2430:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    2434:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    2436:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    243a:	40d1      	lsrs	r1, r2
    243c:	2200      	movs	r2, #0
    243e:	e055      	b.n	24ec <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x218>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    2440:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    2444:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    2446:	f02e 0e7f 	bic.w	lr, lr, #127	; 0x7f
    244a:	4313      	orrs	r3, r2
    244c:	ea43 630e 	orr.w	r3, r3, lr, lsl #24

    memcpy(f, &val, sizeof(val));
    2450:	2204      	movs	r2, #4
    2452:	4629      	mov	r1, r5
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    2454:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    2456:	f003 fb8f 	bl	5b78 <memcpy>
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    245a:	7fe7      	ldrb	r7, [r4, #31]
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    245c:	7f20      	ldrb	r0, [r4, #28]

    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    245e:	7ee1      	ldrb	r1, [r4, #27]
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    2460:	7fa3      	ldrb	r3, [r4, #30]
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    2462:	f894 e01d 	ldrb.w	lr, [r4, #29]
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    2466:	013a      	lsls	r2, r7, #4
    2468:	f402 62fe 	and.w	r2, r2, #2032	; 0x7f0
    // Skip lowest 24 bits
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    246c:	0100      	lsls	r0, r0, #4
    246e:	ea40 1011 	orr.w	r0, r0, r1, lsr #4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    2472:	0519      	lsls	r1, r3, #20

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    2474:	ea42 1313 	orr.w	r3, r2, r3, lsr #4

    if (exp == 2047)
    2478:	f240 72ff 	movw	r2, #2047	; 0x7ff
    inbuffer += 3;

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    247c:	ea40 340e 	orr.w	r4, r0, lr, lsl #12
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    2480:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    2484:	4293      	cmp	r3, r2
      offset += deserializeAvrFloat64(inbuffer + offset, &(this->w));
    2486:	f106 0010 	add.w	r0, r6, #16

    // Copy truncated mantissa.
    mantissa = ((uint32_t)(*(inbuffer++)) >> 4 & 0x0F);
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 4;
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;
    248a:	ea41 0104 	orr.w	r1, r1, r4

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    248e:	d022      	beq.n	24d6 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x202>
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    2490:	f240 447e 	movw	r4, #1150	; 0x47e
    2494:	42a3      	cmp	r3, r4
    mantissa |= ((uint32_t)(*(inbuffer++)) & 0xff) << 12;
    mantissa |= ((uint32_t)(*inbuffer) & 0x0f) << 20;

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;
    2496:	b21a      	sxth	r2, r3

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    2498:	d80d      	bhi.n	24b6 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x1e2>
    {
      exp = 255;
      mantissa = 0; // Too large for float, convert to infinity
    }
    else if (exp - 1023 >= -126)
    249a:	f5b2 7f60 	cmp.w	r2, #896	; 0x380
    249e:	dc3e      	bgt.n	251e <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x24a>
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    24a0:	f5b2 7f5a 	cmp.w	r2, #872	; 0x368
    24a4:	dd5f      	ble.n	2566 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x292>
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
      mantissa >>= ((-126 + 1023) - exp);
    24a6:	f5c2 7260 	rsb	r2, r2, #896	; 0x380
    24aa:	3201      	adds	r2, #1
      exp = 0; // Too small or zero
    }
    else
    {
      // Have to convert to denormalized representation for float
      mantissa |= 0x1000000;
    24ac:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
      mantissa >>= ((-126 + 1023) - exp);
    24b0:	40d1      	lsrs	r1, r2
    24b2:	2200      	movs	r2, #0
    24b4:	e011      	b.n	24da <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x206>

    if (exp == 2047)
    {
      exp = 255; // NaN, infinity etc.
    }
    else if (exp - 1023 > 127)
    24b6:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
    24ba:	2300      	movs	r3, #0
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    24bc:	f027 077f 	bic.w	r7, r7, #127	; 0x7f
    24c0:	4313      	orrs	r3, r2
    24c2:	ea43 6307 	orr.w	r3, r3, r7, lsl #24

    memcpy(f, &val, sizeof(val));
    24c6:	4629      	mov	r1, r5
    24c8:	2204      	movs	r2, #4
    // Put mantissa and exponent into place
    uint32_t val = mantissa;
    val |= static_cast<uint32_t>(exp) << 23;

    // Copy negative sign.
    val |= (static_cast<uint32_t>(*(inbuffer++)) & 0x80) << 24;
    24ca:	9301      	str	r3, [sp, #4]

    memcpy(f, &val, sizeof(val));
    24cc:	f003 fb54 	bl	5b78 <memcpy>
     return offset;
    }
    24d0:	2020      	movs	r0, #32
    24d2:	b003      	add	sp, #12
    24d4:	bdf0      	pop	{r4, r5, r6, r7, pc}

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    24d6:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    24da:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    24de:	4299      	cmp	r1, r3
    24e0:	d024      	beq.n	252c <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x258>
    24e2:	1c4b      	adds	r3, r1, #1
    24e4:	085b      	lsrs	r3, r3, #1
    24e6:	e7e9      	b.n	24bc <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x1e8>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    24e8:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    24ec:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    24f0:	4299      	cmp	r1, r3
    24f2:	d024      	beq.n	253e <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x26a>
    24f4:	1c4b      	adds	r3, r1, #1
    24f6:	085b      	lsrs	r3, r3, #1
    24f8:	e7a5      	b.n	2446 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x172>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    24fa:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    24fe:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    2502:	4299      	cmp	r1, r3
    2504:	d024      	beq.n	2550 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x27c>
    2506:	1c4b      	adds	r3, r1, #1
    2508:	085b      	lsrs	r3, r3, #1
    250a:	e75d      	b.n	23c8 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0xf4>

    // Copy exponent.
    exp = ((uint32_t)(*(inbuffer++)) & 0xf0) >> 4;
    exp |= ((uint32_t)(*inbuffer) & 0x7f) << 4;

    if (exp == 2047)
    250c:	f04f 42ff 	mov.w	r2, #2139095040	; 0x7f800000
      mantissa >>= ((-126 + 1023) - exp);
      exp = 0;
    }

    // Round off mantissa
    if (mantissa != 0xFFFFFF)
    2510:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    2514:	4299      	cmp	r1, r3
    2516:	d024      	beq.n	2562 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x28e>
    2518:	1c4b      	adds	r3, r1, #1
    251a:	085b      	lsrs	r3, r3, #1
    251c:	e702      	b.n	2324 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x50>
    251e:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    2522:	05da      	lsls	r2, r3, #23
    2524:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    2528:	4299      	cmp	r1, r3
    252a:	d1da      	bne.n	24e2 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x20e>
    252c:	4b12      	ldr	r3, [pc, #72]	; (2578 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x2a4>)
    252e:	e7c5      	b.n	24bc <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x1e8>
    2530:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    2534:	05da      	lsls	r2, r3, #23
    2536:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    253a:	4299      	cmp	r1, r3
    253c:	d1da      	bne.n	24f4 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x220>
    253e:	4b0e      	ldr	r3, [pc, #56]	; (2578 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x2a4>)
    2540:	e781      	b.n	2446 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x172>
    2542:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    2546:	05da      	lsls	r2, r3, #23
    2548:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    254c:	4299      	cmp	r1, r3
    254e:	d1da      	bne.n	2506 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x232>
    2550:	4b09      	ldr	r3, [pc, #36]	; (2578 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x2a4>)
    2552:	e739      	b.n	23c8 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0xf4>
    2554:	f5a3 7360 	sub.w	r3, r3, #896	; 0x380
    2558:	05da      	lsls	r2, r3, #23
    255a:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
    255e:	4299      	cmp	r1, r3
    2560:	d1da      	bne.n	2518 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x244>
    2562:	4b05      	ldr	r3, [pc, #20]	; (2578 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x2a4>)
    2564:	e6de      	b.n	2324 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x50>
    }
    else if (exp - 1023 >= -126)
    {
      exp -= 1023 - 127; // Normal case
    }
    else if (exp - 1023 < -150)
    2566:	2200      	movs	r2, #0
    2568:	e7b7      	b.n	24da <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x206>
    256a:	2200      	movs	r2, #0
    256c:	e7be      	b.n	24ec <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x218>
    256e:	2200      	movs	r2, #0
    2570:	e7c5      	b.n	24fe <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x22a>
    2572:	2200      	movs	r2, #0
    2574:	e7cc      	b.n	2510 <geometry_msgs::Quaternion::deserialize(unsigned char*)+0x23c>
    2576:	bf00      	nop
    2578:	007fffff 	.word	0x007fffff

0000257c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)>:
      }
    }
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
    257c:	b5f0      	push	{r4, r5, r6, r7, lr}
  {
    if (id >= 100 && !configured_)
    257e:	2963      	cmp	r1, #99	; 0x63
      }
    }
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
    2580:	b085      	sub	sp, #20
  {
    if (id >= 100 && !configured_)
    2582:	dd03      	ble.n	258c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x10>
    2584:	f890 44f8 	ldrb.w	r4, [r0, #1272]	; 0x4f8
    2588:	2c00      	cmp	r4, #0
    258a:	d046      	beq.n	261a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x9e>
      return 0;

    /* serialize message */
    int l = msg->serialize(message_out + 7);
    258c:	6813      	ldr	r3, [r2, #0]
    258e:	4605      	mov	r5, r0
    2590:	460f      	mov	r7, r1
    2592:	4610      	mov	r0, r2
    2594:	681b      	ldr	r3, [r3, #0]
    2596:	f205 2123 	addw	r1, r5, #547	; 0x223
    259a:	4798      	blx	r3

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    259c:	b2c2      	uxtb	r2, r0
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    259e:	f3c0 2107 	ubfx	r1, r0, #8, #8
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    25a2:	1856      	adds	r6, r2, r1
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    25a4:	f885 221e 	strb.w	r2, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    25a8:	f347 2207 	sbfx	r2, r7, #8, #8
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    25ac:	43f6      	mvns	r6, r6

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    25ae:	23ff      	movs	r3, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    25b0:	f04f 0efe 	mov.w	lr, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    25b4:	b2fc      	uxtb	r4, r7
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    25b6:	f885 2222 	strb.w	r2, [r5, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    25ba:	1c42      	adds	r2, r0, #1
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    25bc:	f885 6220 	strb.w	r6, [r5, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    25c0:	f885 121f 	strb.w	r1, [r5, #543]	; 0x21f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    25c4:	f885 321c 	strb.w	r3, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    25c8:	f885 e21d 	strb.w	lr, [r5, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    25cc:	f885 4221 	strb.w	r4, [r5, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    25d0:	db0d      	blt.n	25ee <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x72>
    25d2:	f200 2122 	addw	r1, r0, #546	; 0x222
    25d6:	4429      	add	r1, r5
    25d8:	f205 2321 	addw	r3, r5, #545	; 0x221
    25dc:	2200      	movs	r2, #0
    25de:	e001      	b.n	25e4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x68>
    25e0:	f813 4f01 	ldrb.w	r4, [r3, #1]!
    25e4:	428b      	cmp	r3, r1
      chk += message_out[i];
    25e6:	4422      	add	r2, r4
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    25e8:	d1fa      	bne.n	25e0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x64>
    25ea:	43d3      	mvns	r3, r2
    25ec:	b2db      	uxtb	r3, r3
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    25ee:	182a      	adds	r2, r5, r0
    25f0:	f100 0408 	add.w	r4, r0, #8

    if (l <= OUTPUT_SIZE)
    25f4:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    25f8:	f882 3223 	strb.w	r3, [r2, #547]	; 0x223

    if (l <= OUTPUT_SIZE)
    25fc:	dc17      	bgt.n	262e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0xb2>
    25fe:	686a      	ldr	r2, [r5, #4]
    2600:	4e35      	ldr	r6, [pc, #212]	; (26d8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x15c>)
    2602:	6813      	ldr	r3, [r2, #0]
    2604:	685b      	ldr	r3, [r3, #4]
    2606:	42b3      	cmp	r3, r6
    {
      hardware_.write(message_out, l);
    2608:	f505 7007 	add.w	r0, r5, #540	; 0x21c
    260c:	d108      	bne.n	2620 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0xa4>
    260e:	4621      	mov	r1, r4
    2610:	f004 fdca 	bl	71a8 <usb_serial_write>
    2614:	4620      	mov	r0, r4
    else
    {
      logerror("Message from device dropped: message larger than buffer.");
      return -1;
    }
  }
    2616:	b005      	add	sp, #20
    2618:	bdf0      	pop	{r4, r5, r6, r7, pc}
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
      return 0;
    261a:	4620      	mov	r0, r4
    else
    {
      logerror("Message from device dropped: message larger than buffer.");
      return -1;
    }
  }
    261c:	b005      	add	sp, #20
    261e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2620:	4601      	mov	r1, r0
    2622:	4610      	mov	r0, r2
    2624:	4622      	mov	r2, r4
    2626:	4798      	blx	r3
    2628:	4620      	mov	r0, r4
    262a:	b005      	add	sp, #20
    262c:	bdf0      	pop	{r4, r5, r6, r7, pc}
      enum { ERROR = 3 };
      enum { FATAL = 4 };

    Log():
      level(0),
      msg("")
    262e:	4a2b      	ldr	r2, [pc, #172]	; (26dc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x160>)
protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    2630:	492b      	ldr	r1, [pc, #172]	; (26e0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x164>)
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    2632:	682b      	ldr	r3, [r5, #0]
    2634:	9201      	str	r2, [sp, #4]

protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    2636:	2003      	movs	r0, #3
    2638:	f88d 0008 	strb.w	r0, [sp, #8]
    l.msg = (char*)msg;
    263c:	9103      	str	r1, [sp, #12]
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    263e:	681b      	ldr	r3, [r3, #0]
    2640:	4a28      	ldr	r2, [pc, #160]	; (26e4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x168>)
    2642:	4293      	cmp	r3, r2
    2644:	d13f      	bne.n	26c6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x14a>
  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
      arr[i] = (var >> (8 * i));
    2646:	2400      	movs	r4, #0
    2648:	2238      	movs	r2, #56	; 0x38
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    264a:	f885 0223 	strb.w	r0, [r5, #547]	; 0x223
    264e:	f885 2224 	strb.w	r2, [r5, #548]	; 0x224
    2652:	f885 4225 	strb.w	r4, [r5, #549]	; 0x225
    2656:	f885 4226 	strb.w	r4, [r5, #550]	; 0x226
    265a:	f885 4227 	strb.w	r4, [r5, #551]	; 0x227
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    265e:	f505 700a 	add.w	r0, r5, #552	; 0x228
    2662:	f003 fa89 	bl	5b78 <memcpy>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    2666:	27ff      	movs	r7, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    2668:	203d      	movs	r0, #61	; 0x3d
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    266a:	23c2      	movs	r3, #194	; 0xc2
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    266c:	26fe      	movs	r6, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    266e:	2107      	movs	r1, #7
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    2670:	f885 021e 	strb.w	r0, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    2674:	f885 3220 	strb.w	r3, [r5, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    2678:	f885 421f 	strb.w	r4, [r5, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    267c:	f885 4222 	strb.w	r4, [r5, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    2680:	4622      	mov	r2, r4

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    2682:	f885 721c 	strb.w	r7, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    2686:	f885 621d 	strb.w	r6, [r5, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    268a:	f885 1221 	strb.w	r1, [r5, #545]	; 0x221
    268e:	f205 2321 	addw	r3, r5, #545	; 0x221
    2692:	f205 205f 	addw	r0, r5, #607	; 0x25f
    2696:	e001      	b.n	269c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x120>
    2698:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    269c:	4298      	cmp	r0, r3
      chk += message_out[i];
    269e:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    26a0:	d1fa      	bne.n	2698 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x11c>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    26a2:	43d2      	mvns	r2, r2
    26a4:	6868      	ldr	r0, [r5, #4]
    26a6:	f885 2260 	strb.w	r2, [r5, #608]	; 0x260
    26aa:	6803      	ldr	r3, [r0, #0]
    26ac:	4a0a      	ldr	r2, [pc, #40]	; (26d8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x15c>)
    26ae:	685b      	ldr	r3, [r3, #4]
    26b0:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    26b2:	f505 7107 	add.w	r1, r5, #540	; 0x21c
    26b6:	d10b      	bne.n	26d0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x154>
    26b8:	4608      	mov	r0, r1
    26ba:	2145      	movs	r1, #69	; 0x45
    26bc:	f004 fd74 	bl	71a8 <usb_serial_write>
    26c0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    26c4:	e7a7      	b.n	2616 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x9a>
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    26c6:	4628      	mov	r0, r5
    26c8:	aa01      	add	r2, sp, #4
    26ca:	2107      	movs	r1, #7
    26cc:	4798      	blx	r3
    26ce:	e7f7      	b.n	26c0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x144>
    26d0:	2245      	movs	r2, #69	; 0x45
    26d2:	4798      	blx	r3
    26d4:	e7f4      	b.n	26c0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x144>
    26d6:	bf00      	nop
    26d8:	00000c49 	.word	0x00000c49
    26dc:	0000a7ec 	.word	0x0000a7ec
    26e0:	0000aadc 	.word	0x0000aadc
    26e4:	0000257d 	.word	0x0000257d

000026e8 <omega_to_pwm(double)>:
  //left_tick_pub.publish(&left_tick);

  average_omega_left = averaging_array(speed_array_left);
}

int omega_to_pwm(double x){
    26e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    26ec:	ec55 4b10 	vmov	r4, r5, d0
    26f0:	b082      	sub	sp, #8
  double pwm_cal;
  int sign;
  if(x < 0){
    26f2:	2200      	movs	r2, #0
    26f4:	2300      	movs	r3, #0
    26f6:	ee10 0a10 	vmov	r0, s0
    26fa:	4629      	mov	r1, r5
    26fc:	f006 fdf2 	bl	92e4 <__aeabi_dcmplt>
    sign = -1;
  }
  else{
    sign = 1;
  }
  if (abs(x) > change_over_point){
    2700:	2200      	movs	r2, #0
  int sign;
  if(x < 0){
    sign = -1;
  }
  else{
    sign = 1;
    2702:	2800      	cmp	r0, #0
  }
  if (abs(x) > change_over_point){
    2704:	f04f 0300 	mov.w	r3, #0
    2708:	4620      	mov	r0, r4
    270a:	4629      	mov	r1, r5
  int sign;
  if(x < 0){
    sign = -1;
  }
  else{
    sign = 1;
    270c:	bf14      	ite	ne
    270e:	f04f 3aff 	movne.w	sl, #4294967295	; 0xffffffff
    2712:	f04f 0a01 	moveq.w	sl, #1
  }
  if (abs(x) > change_over_point){
    2716:	f006 fe03 	bl	9320 <__aeabi_dcmpgt>
    271a:	2200      	movs	r2, #0
    271c:	2800      	cmp	r0, #0
    271e:	f000 80a2 	beq.w	2866 <omega_to_pwm(double)+0x17e>
    2722:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2726:	4620      	mov	r0, r4
    2728:	4629      	mov	r1, r5
    272a:	f006 fdf9 	bl	9320 <__aeabi_dcmpgt>
    272e:	b3b8      	cbz	r0, 27a0 <omega_to_pwm(double)+0xb8>
    pwm_cal = a*pow(abs(x),3)+b*pow(abs(x),2)+c*abs(x)+d;
    2730:	ed9f 1b79 	vldr	d1, [pc, #484]	; 2918 <omega_to_pwm(double)+0x230>
    2734:	ec45 4b10 	vmov	d0, r4, r5
    2738:	f005 f872 	bl	7820 <pow>
    273c:	4622      	mov	r2, r4
    273e:	462b      	mov	r3, r5
    2740:	4620      	mov	r0, r4
    2742:	4629      	mov	r1, r5
    2744:	ed8d 0b00 	vstr	d0, [sp]
    2748:	f006 fb5a 	bl	8e00 <__aeabi_dmul>
    274c:	a374      	add	r3, pc, #464	; (adr r3, 2920 <omega_to_pwm(double)+0x238>)
    274e:	e9d3 2300 	ldrd	r2, r3, [r3]
    2752:	f006 fb55 	bl	8e00 <__aeabi_dmul>
    2756:	ed9d 0b00 	vldr	d0, [sp]
    275a:	a373      	add	r3, pc, #460	; (adr r3, 2928 <omega_to_pwm(double)+0x240>)
    275c:	e9d3 2300 	ldrd	r2, r3, [r3]
    2760:	4606      	mov	r6, r0
    2762:	460f      	mov	r7, r1
    2764:	ec51 0b10 	vmov	r0, r1, d0
    2768:	f006 fb4a 	bl	8e00 <__aeabi_dmul>
    276c:	4602      	mov	r2, r0
    276e:	460b      	mov	r3, r1
    2770:	4630      	mov	r0, r6
    2772:	4639      	mov	r1, r7
    2774:	f006 f992 	bl	8a9c <__adddf3>
    2778:	4606      	mov	r6, r0
    277a:	460f      	mov	r7, r1
    277c:	4620      	mov	r0, r4
    277e:	4629      	mov	r1, r5
    2780:	a36b      	add	r3, pc, #428	; (adr r3, 2930 <omega_to_pwm(double)+0x248>)
    2782:	e9d3 2300 	ldrd	r2, r3, [r3]
    2786:	f006 fb3b 	bl	8e00 <__aeabi_dmul>
    278a:	4632      	mov	r2, r6
    278c:	463b      	mov	r3, r7
    278e:	f006 f985 	bl	8a9c <__adddf3>
    2792:	a369      	add	r3, pc, #420	; (adr r3, 2938 <omega_to_pwm(double)+0x250>)
    2794:	e9d3 2300 	ldrd	r2, r3, [r3]
    2798:	f006 f97e 	bl	8a98 <__aeabi_dsub>
    279c:	4606      	mov	r6, r0
    279e:	460f      	mov	r7, r1
  }
  if (abs(x) <= change_over_point && abs(x) > 0.01){
    27a0:	2200      	movs	r2, #0
    27a2:	2300      	movs	r3, #0
    27a4:	4620      	mov	r0, r4
    27a6:	4629      	mov	r1, r5
    27a8:	f006 fdba 	bl	9320 <__aeabi_dcmpgt>
    27ac:	2200      	movs	r2, #0
    27ae:	b3a8      	cbz	r0, 281c <omega_to_pwm(double)+0x134>
    27b0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    27b4:	4620      	mov	r0, r4
    27b6:	4629      	mov	r1, r5
    27b8:	f006 fd9e 	bl	92f8 <__aeabi_dcmple>
    27bc:	b9b0      	cbnz	r0, 27ec <omega_to_pwm(double)+0x104>
    pwm_cal = a_2*abs(x) + b_2;
  }
  if (pwm_cal>opper_lim){
    27be:	a360      	add	r3, pc, #384	; (adr r3, 2940 <omega_to_pwm(double)+0x258>)
    27c0:	e9d3 2300 	ldrd	r2, r3, [r3]
    27c4:	4630      	mov	r0, r6
    27c6:	4639      	mov	r1, r7
    27c8:	f006 fdaa 	bl	9320 <__aeabi_dcmpgt>
    27cc:	b110      	cbz	r0, 27d4 <omega_to_pwm(double)+0xec>
    pwm_cal = opper_lim;
    27ce:	a75c      	add	r7, pc, #368	; (adr r7, 2940 <omega_to_pwm(double)+0x258>)
    27d0:	e9d7 6700 	ldrd	r6, r7, [r7]
  }
  int pwm_int = sign * pwm_cal;

  return pwm_int;
    27d4:	4650      	mov	r0, sl
    27d6:	f006 faad 	bl	8d34 <__aeabi_i2d>
    27da:	4632      	mov	r2, r6
    27dc:	463b      	mov	r3, r7
    27de:	f006 fb0f 	bl	8e00 <__aeabi_dmul>
    27e2:	f006 fdbd 	bl	9360 <__aeabi_d2iz>
}
    27e6:	b002      	add	sp, #8
    27e8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    sign = 1;
  }
  if (abs(x) > change_over_point){
    pwm_cal = a*pow(abs(x),3)+b*pow(abs(x),2)+c*abs(x)+d;
  }
  if (abs(x) <= change_over_point && abs(x) > 0.01){
    27ec:	a356      	add	r3, pc, #344	; (adr r3, 2948 <omega_to_pwm(double)+0x260>)
    27ee:	e9d3 2300 	ldrd	r2, r3, [r3]
    27f2:	4620      	mov	r0, r4
    27f4:	4629      	mov	r1, r5
    27f6:	f006 fd93 	bl	9320 <__aeabi_dcmpgt>
    27fa:	2800      	cmp	r0, #0
    27fc:	d0df      	beq.n	27be <omega_to_pwm(double)+0xd6>
    pwm_cal = a_2*abs(x) + b_2;
    27fe:	4620      	mov	r0, r4
    2800:	4629      	mov	r1, r5
    2802:	a353      	add	r3, pc, #332	; (adr r3, 2950 <omega_to_pwm(double)+0x268>)
    2804:	e9d3 2300 	ldrd	r2, r3, [r3]
    2808:	f006 fafa 	bl	8e00 <__aeabi_dmul>
    280c:	a352      	add	r3, pc, #328	; (adr r3, 2958 <omega_to_pwm(double)+0x270>)
    280e:	e9d3 2300 	ldrd	r2, r3, [r3]
    2812:	f006 f943 	bl	8a9c <__adddf3>
    2816:	4606      	mov	r6, r0
    2818:	460f      	mov	r7, r1
    281a:	e7d0      	b.n	27be <omega_to_pwm(double)+0xd6>
    sign = 1;
  }
  if (abs(x) > change_over_point){
    pwm_cal = a*pow(abs(x),3)+b*pow(abs(x),2)+c*abs(x)+d;
  }
  if (abs(x) <= change_over_point && abs(x) > 0.01){
    281c:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
    2820:	4620      	mov	r0, r4
    2822:	4629      	mov	r1, r5
    2824:	f006 fd72 	bl	930c <__aeabi_dcmpge>
    2828:	2800      	cmp	r0, #0
    282a:	d0c8      	beq.n	27be <omega_to_pwm(double)+0xd6>
    282c:	2200      	movs	r2, #0
    282e:	2300      	movs	r3, #0
    2830:	4620      	mov	r0, r4
    2832:	4629      	mov	r1, r5
    2834:	f006 fd74 	bl	9320 <__aeabi_dcmpgt>
    2838:	2800      	cmp	r0, #0
    283a:	d1d7      	bne.n	27ec <omega_to_pwm(double)+0x104>
    283c:	a348      	add	r3, pc, #288	; (adr r3, 2960 <omega_to_pwm(double)+0x278>)
    283e:	e9d3 2300 	ldrd	r2, r3, [r3]
    2842:	4620      	mov	r0, r4
    2844:	4629      	mov	r1, r5
    2846:	f006 fd4d 	bl	92e4 <__aeabi_dcmplt>
    284a:	2800      	cmp	r0, #0
    284c:	d0b7      	beq.n	27be <omega_to_pwm(double)+0xd6>
    pwm_cal = a_2*abs(x) + b_2;
    284e:	2200      	movs	r2, #0
    2850:	2300      	movs	r3, #0
    2852:	4620      	mov	r0, r4
    2854:	4629      	mov	r1, r5
    2856:	f006 fd63 	bl	9320 <__aeabi_dcmpgt>
    285a:	2800      	cmp	r0, #0
    285c:	d1cf      	bne.n	27fe <omega_to_pwm(double)+0x116>
    285e:	4620      	mov	r0, r4
    2860:	f105 4100 	add.w	r1, r5, #2147483648	; 0x80000000
    2864:	e7cd      	b.n	2802 <omega_to_pwm(double)+0x11a>
    sign = -1;
  }
  else{
    sign = 1;
  }
  if (abs(x) > change_over_point){
    2866:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
    286a:	4620      	mov	r0, r4
    286c:	4629      	mov	r1, r5
    286e:	f006 fd39 	bl	92e4 <__aeabi_dcmplt>
    2872:	2800      	cmp	r0, #0
    2874:	d094      	beq.n	27a0 <omega_to_pwm(double)+0xb8>
    pwm_cal = a*pow(abs(x),3)+b*pow(abs(x),2)+c*abs(x)+d;
    2876:	2200      	movs	r2, #0
    2878:	2300      	movs	r3, #0
    287a:	4620      	mov	r0, r4
    287c:	4629      	mov	r1, r5
    287e:	f006 fd4f 	bl	9320 <__aeabi_dcmpgt>
    2882:	2800      	cmp	r0, #0
    2884:	f47f af54 	bne.w	2730 <omega_to_pwm(double)+0x48>
    2888:	46a0      	mov	r8, r4
    288a:	f105 4900 	add.w	r9, r5, #2147483648	; 0x80000000
    288e:	ed9f 1b22 	vldr	d1, [pc, #136]	; 2918 <omega_to_pwm(double)+0x230>
    2892:	ec49 8b10 	vmov	d0, r8, r9
    2896:	f004 ffc3 	bl	7820 <pow>
    289a:	a323      	add	r3, pc, #140	; (adr r3, 2928 <omega_to_pwm(double)+0x240>)
    289c:	e9d3 2300 	ldrd	r2, r3, [r3]
    28a0:	ec51 0b10 	vmov	r0, r1, d0
    28a4:	f006 faac 	bl	8e00 <__aeabi_dmul>
    28a8:	2200      	movs	r2, #0
    28aa:	4606      	mov	r6, r0
    28ac:	460f      	mov	r7, r1
    28ae:	2300      	movs	r3, #0
    28b0:	4620      	mov	r0, r4
    28b2:	4629      	mov	r1, r5
    28b4:	f006 fd34 	bl	9320 <__aeabi_dcmpgt>
    28b8:	b9d0      	cbnz	r0, 28f0 <omega_to_pwm(double)+0x208>
    28ba:	4622      	mov	r2, r4
    28bc:	464b      	mov	r3, r9
    28be:	4620      	mov	r0, r4
    28c0:	4649      	mov	r1, r9
    28c2:	f006 fa9d 	bl	8e00 <__aeabi_dmul>
    28c6:	a316      	add	r3, pc, #88	; (adr r3, 2920 <omega_to_pwm(double)+0x238>)
    28c8:	e9d3 2300 	ldrd	r2, r3, [r3]
    28cc:	f006 fa98 	bl	8e00 <__aeabi_dmul>
    28d0:	4632      	mov	r2, r6
    28d2:	463b      	mov	r3, r7
    28d4:	f006 f8e2 	bl	8a9c <__adddf3>
    28d8:	2200      	movs	r2, #0
    28da:	4606      	mov	r6, r0
    28dc:	460f      	mov	r7, r1
    28de:	2300      	movs	r3, #0
    28e0:	4620      	mov	r0, r4
    28e2:	4629      	mov	r1, r5
    28e4:	f006 fd1c 	bl	9320 <__aeabi_dcmpgt>
    28e8:	b980      	cbnz	r0, 290c <omega_to_pwm(double)+0x224>
    28ea:	4620      	mov	r0, r4
    28ec:	4649      	mov	r1, r9
    28ee:	e747      	b.n	2780 <omega_to_pwm(double)+0x98>
    28f0:	4622      	mov	r2, r4
    28f2:	462b      	mov	r3, r5
    28f4:	4620      	mov	r0, r4
    28f6:	4629      	mov	r1, r5
    28f8:	f006 fa82 	bl	8e00 <__aeabi_dmul>
    28fc:	a308      	add	r3, pc, #32	; (adr r3, 2920 <omega_to_pwm(double)+0x238>)
    28fe:	e9d3 2300 	ldrd	r2, r3, [r3]
    2902:	f006 fa7d 	bl	8e00 <__aeabi_dmul>
    2906:	4632      	mov	r2, r6
    2908:	463b      	mov	r3, r7
    290a:	e733      	b.n	2774 <omega_to_pwm(double)+0x8c>
    290c:	4620      	mov	r0, r4
    290e:	4629      	mov	r1, r5
    2910:	e736      	b.n	2780 <omega_to_pwm(double)+0x98>
    2912:	bf00      	nop
    2914:	f3af 8000 	nop.w
    2918:	00000000 	.word	0x00000000
    291c:	40080000 	.word	0x40080000
    2920:	00000000 	.word	0x00000000
    2924:	c00bb22d 	.word	0xc00bb22d
    2928:	a0000000 	.word	0xa0000000
    292c:	3fc84ea4 	.word	0x3fc84ea4
    2930:	20000000 	.word	0x20000000
    2934:	4037c7ae 	.word	0x4037c7ae
    2938:	20000000 	.word	0x20000000
    293c:	40229d2f 	.word	0x40229d2f
    2940:	00000000 	.word	0x00000000
    2944:	406fe000 	.word	0x406fe000
    2948:	40000000 	.word	0x40000000
    294c:	3f847ae1 	.word	0x3f847ae1
    2950:	c0000000 	.word	0xc0000000
    2954:	3ffb851e 	.word	0x3ffb851e
    2958:	a0000000 	.word	0xa0000000
    295c:	4036e147 	.word	0x4036e147
    2960:	40000000 	.word	0x40000000
    2964:	bf847ae1 	.word	0xbf847ae1

00002968 <setPWM(int, int)>:

  return pwm_int;
}


void setPWM(int pwm_right, int pwm_left) {
    2968:	b570      	push	{r4, r5, r6, lr}
  //setting the correct direction of the motor
  direction_indicator_right = 0;
  direction_indicator_left = 0;
    296a:	4a1e      	ldr	r2, [pc, #120]	; (29e4 <setPWM(int, int)+0x7c>)
}


void setPWM(int pwm_right, int pwm_left) {
  //setting the correct direction of the motor
  direction_indicator_right = 0;
    296c:	4e1e      	ldr	r6, [pc, #120]	; (29e8 <setPWM(int, int)+0x80>)
    296e:	2300      	movs	r3, #0
  direction_indicator_left = 0;
  if(pwm_right >= 0){
    2970:	1e05      	subs	r5, r0, #0
}


void setPWM(int pwm_right, int pwm_left) {
  //setting the correct direction of the motor
  direction_indicator_right = 0;
    2972:	6033      	str	r3, [r6, #0]
  direction_indicator_left = 0;
    2974:	6013      	str	r3, [r2, #0]
  if(pwm_right >= 0){
    direction_indicator_right = 1;
    2976:	bfa8      	it	ge
    2978:	2301      	movge	r3, #1

  return pwm_int;
}


void setPWM(int pwm_right, int pwm_left) {
    297a:	460c      	mov	r4, r1
  //setting the correct direction of the motor
  direction_indicator_right = 0;
  direction_indicator_left = 0;
  if(pwm_right >= 0){
    direction_indicator_right = 1;
    297c:	bfa8      	it	ge
    297e:	6033      	strge	r3, [r6, #0]
  }
  if(pwm_left >= 0){
    2980:	2900      	cmp	r1, #0
    direction_indicator_left = 1;
  }
  digitalWrite(right_motor_ina, pwm_right >= 0);
    2982:	ea6f 0105 	mvn.w	r1, r5
  direction_indicator_left = 0;
  if(pwm_right >= 0){
    direction_indicator_right = 1;
  }
  if(pwm_left >= 0){
    direction_indicator_left = 1;
    2986:	bfa8      	it	ge
    2988:	2301      	movge	r3, #1
  }
  digitalWrite(right_motor_ina, pwm_right >= 0);
    298a:	ea4f 71d1 	mov.w	r1, r1, lsr #31
    298e:	f04f 001e 	mov.w	r0, #30
  direction_indicator_left = 0;
  if(pwm_right >= 0){
    direction_indicator_right = 1;
  }
  if(pwm_left >= 0){
    direction_indicator_left = 1;
    2992:	bfa8      	it	ge
    2994:	6013      	strge	r3, [r2, #0]
  }
  digitalWrite(right_motor_ina, pwm_right >= 0);
    2996:	f003 fccf 	bl	6338 <digitalWrite>
  digitalWrite(right_motor_inb, pwm_right < 0);
    299a:	0fe9      	lsrs	r1, r5, #31
    299c:	201c      	movs	r0, #28
    299e:	f003 fccb 	bl	6338 <digitalWrite>
  digitalWrite(left_motor_ina, pwm_left >= 0);
    29a2:	43e1      	mvns	r1, r4
    29a4:	0fc9      	lsrs	r1, r1, #31
    29a6:	2027      	movs	r0, #39	; 0x27
    29a8:	f003 fcc6 	bl	6338 <digitalWrite>
  digitalWrite(left_motor_inb, pwm_left < 0);
    29ac:	0fe1      	lsrs	r1, r4, #31
    29ae:	2025      	movs	r0, #37	; 0x25
    29b0:	f003 fcc2 	bl	6338 <digitalWrite>
  //setting the value of the motor
  pwm_right = abs(pwm_right);
    29b4:	ea85 71e5 	eor.w	r1, r5, r5, asr #31
    29b8:	eba1 71e5 	sub.w	r1, r1, r5, asr #31
  pwm_left = abs(pwm_left);
    29bc:	2c00      	cmp	r4, #0
    29be:	bfb8      	it	lt
    29c0:	4264      	neglt	r4, r4
    pwm_left = 255;
  }
  if (pwm_right > 255) {
    pwm_right = 255;
  }
  analogWrite(right_motor_pwm, pwm_right);
    29c2:	29ff      	cmp	r1, #255	; 0xff
    29c4:	bfa8      	it	ge
    29c6:	21ff      	movge	r1, #255	; 0xff
    29c8:	201d      	movs	r0, #29
    29ca:	f003 fb15 	bl	5ff8 <analogWrite>
  analogWrite(left_motor_pwm, pwm_left);
    29ce:	2cff      	cmp	r4, #255	; 0xff
    29d0:	4621      	mov	r1, r4
    29d2:	f04f 0026 	mov.w	r0, #38	; 0x26
    29d6:	bfa8      	it	ge
    29d8:	21ff      	movge	r1, #255	; 0xff
}
    29da:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  }
  if (pwm_right > 255) {
    pwm_right = 255;
  }
  analogWrite(right_motor_pwm, pwm_right);
  analogWrite(left_motor_pwm, pwm_left);
    29de:	f003 bb0b 	b.w	5ff8 <analogWrite>
    29e2:	bf00      	nop
    29e4:	1fff1d84 	.word	0x1fff1d84
    29e8:	1fff22bc 	.word	0x1fff22bc

000029ec <speed_PID_controller(double, double, double, double, double, double, double)>:
}

void speed_PID_controller(double goal_wheel_speed_r, double current_wheel_speed_r, double last_error_r, double goal_wheel_speed_l, double current_wheel_speed_l, double last_error_l, double elapsed_time){
    29ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    29f0:	b08d      	sub	sp, #52	; 0x34
    29f2:	ec59 8b16 	vmov	r8, r9, d6
    29f6:	ed8d 2b06 	vstr	d2, [sp, #24]
    29fa:	ed8d 5b04 	vstr	d5, [sp, #16]
    29fe:	ed8d 3b02 	vstr	d3, [sp, #8]
    2a02:	ed8d 4b00 	vstr	d4, [sp]
    2a06:	ed8d 0b0a 	vstr	d0, [sp, #40]	; 0x28
    2a0a:	ed8d 1b08 	vstr	d1, [sp, #32]
  //double error_r = goal_wheel_speed_r - current_wheel_speed_r;
  previous_time = micros();
    2a0e:	f003 fc9f 	bl	6350 <micros>
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
    2a12:	ed9d 1b08 	vldr	d1, [sp, #32]
    2a16:	ed9d 0b0a 	vldr	d0, [sp, #40]	; 0x28
  analogWrite(left_motor_pwm, pwm_left);
}

void speed_PID_controller(double goal_wheel_speed_r, double current_wheel_speed_r, double last_error_r, double goal_wheel_speed_l, double current_wheel_speed_l, double last_error_l, double elapsed_time){
  //double error_r = goal_wheel_speed_r - current_wheel_speed_r;
  previous_time = micros();
    2a1a:	4b57      	ldr	r3, [pc, #348]	; (2b78 <speed_PID_controller(double, double, double, double, double, double, double)+0x18c>)
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
    2a1c:	4c57      	ldr	r4, [pc, #348]	; (2b7c <speed_PID_controller(double, double, double, double, double, double, double)+0x190>)
  analogWrite(left_motor_pwm, pwm_left);
}

void speed_PID_controller(double goal_wheel_speed_r, double current_wheel_speed_r, double last_error_r, double goal_wheel_speed_l, double current_wheel_speed_l, double last_error_l, double elapsed_time){
  //double error_r = goal_wheel_speed_r - current_wheel_speed_r;
  previous_time = micros();
    2a1e:	6018      	str	r0, [r3, #0]
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
    2a20:	ec53 2b11 	vmov	r2, r3, d1
    2a24:	ec51 0b10 	vmov	r0, r1, d0
    2a28:	f006 f836 	bl	8a98 <__aeabi_dsub>
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
    2a2c:	ed9d 4b00 	vldr	d4, [sp]
    2a30:	ed9d 3b02 	vldr	d3, [sp, #8]

void speed_PID_controller(double goal_wheel_speed_r, double current_wheel_speed_r, double last_error_r, double goal_wheel_speed_l, double current_wheel_speed_l, double last_error_l, double elapsed_time){
  //double error_r = goal_wheel_speed_r - current_wheel_speed_r;
  previous_time = micros();
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
    2a34:	4682      	mov	sl, r0
    2a36:	468b      	mov	fp, r1
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
    2a38:	ec53 2b14 	vmov	r2, r3, d4
    2a3c:	ec51 0b13 	vmov	r0, r1, d3

void speed_PID_controller(double goal_wheel_speed_r, double current_wheel_speed_r, double last_error_r, double goal_wheel_speed_l, double current_wheel_speed_l, double last_error_l, double elapsed_time){
  //double error_r = goal_wheel_speed_r - current_wheel_speed_r;
  previous_time = micros();
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
    2a40:	e9c4 ab00 	strd	sl, fp, [r4]
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
    2a44:	f006 f828 	bl	8a98 <__aeabi_dsub>
    2a48:	4604      	mov	r4, r0
    2a4a:	460d      	mov	r5, r1
    2a4c:	ec45 4b17 	vmov	d7, r4, r5
    2a50:	4f4b      	ldr	r7, [pc, #300]	; (2b80 <speed_PID_controller(double, double, double, double, double, double, double)+0x194>)
  cum_error_r += error_r * elapsed_time;
    2a52:	4e4c      	ldr	r6, [pc, #304]	; (2b84 <speed_PID_controller(double, double, double, double, double, double, double)+0x198>)
  //double error_r = goal_wheel_speed_r - current_wheel_speed_r;
  previous_time = micros();
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
    2a54:	ed87 7b00 	vstr	d7, [r7]
  cum_error_r += error_r * elapsed_time;
    2a58:	4642      	mov	r2, r8
    2a5a:	464b      	mov	r3, r9
    2a5c:	4650      	mov	r0, sl
    2a5e:	4659      	mov	r1, fp
  //double error_r = goal_wheel_speed_r - current_wheel_speed_r;
  previous_time = micros();
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
    2a60:	e9cd 4500 	strd	r4, r5, [sp]
  cum_error_r += error_r * elapsed_time;
    2a64:	f006 f9cc 	bl	8e00 <__aeabi_dmul>
    2a68:	e9d6 2300 	ldrd	r2, r3, [r6]
    2a6c:	f006 f816 	bl	8a9c <__adddf3>
    2a70:	4604      	mov	r4, r0
    2a72:	460d      	mov	r5, r1
    2a74:	ec45 4b17 	vmov	d7, r4, r5
  cum_error_l += error_l * elapsed_time;
    2a78:	4642      	mov	r2, r8
  previous_time = micros();
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
  cum_error_r += error_r * elapsed_time;
    2a7a:	ed86 7b00 	vstr	d7, [r6]
  cum_error_l += error_l * elapsed_time;
    2a7e:	464b      	mov	r3, r9
    2a80:	e9dd 0100 	ldrd	r0, r1, [sp]
  previous_time = micros();
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
  cum_error_r += error_r * elapsed_time;
    2a84:	e9cd 4502 	strd	r4, r5, [sp, #8]
  cum_error_l += error_l * elapsed_time;
    2a88:	f006 f9ba 	bl	8e00 <__aeabi_dmul>
    2a8c:	4b3e      	ldr	r3, [pc, #248]	; (2b88 <speed_PID_controller(double, double, double, double, double, double, double)+0x19c>)
    2a8e:	e9d3 2300 	ldrd	r2, r3, [r3]
    2a92:	f006 f803 	bl	8a9c <__adddf3>
  double rate_error_r = (error_r - last_error_r) / elapsed_time;
  double rate_error_l = (error_l - last_error_l) / elapsed_time;
  double controller_output_r = error_r * p_gain + cum_error_r * i_gain + rate_error_r * d_gain;
  double controller_output_l = error_l * p_gain + cum_error_l * i_gain + rate_error_l * d_gain;
    2a96:	e9dd 4500 	ldrd	r4, r5, [sp]
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
  cum_error_r += error_r * elapsed_time;
  cum_error_l += error_l * elapsed_time;
    2a9a:	4606      	mov	r6, r0
  double rate_error_r = (error_r - last_error_r) / elapsed_time;
  double rate_error_l = (error_l - last_error_l) / elapsed_time;
  double controller_output_r = error_r * p_gain + cum_error_r * i_gain + rate_error_r * d_gain;
  double controller_output_l = error_l * p_gain + cum_error_l * i_gain + rate_error_l * d_gain;
    2a9c:	4622      	mov	r2, r4
    2a9e:	4620      	mov	r0, r4
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
  cum_error_r += error_r * elapsed_time;
  cum_error_l += error_l * elapsed_time;
    2aa0:	4c39      	ldr	r4, [pc, #228]	; (2b88 <speed_PID_controller(double, double, double, double, double, double, double)+0x19c>)
    2aa2:	460f      	mov	r7, r1
    2aa4:	e9c4 6700 	strd	r6, r7, [r4]
  double rate_error_r = (error_r - last_error_r) / elapsed_time;
  double rate_error_l = (error_l - last_error_l) / elapsed_time;
  double controller_output_r = error_r * p_gain + cum_error_r * i_gain + rate_error_r * d_gain;
  double controller_output_l = error_l * p_gain + cum_error_l * i_gain + rate_error_l * d_gain;
    2aa8:	462b      	mov	r3, r5
    2aaa:	4629      	mov	r1, r5
    2aac:	f005 fff6 	bl	8a9c <__adddf3>
    2ab0:	2200      	movs	r2, #0
    2ab2:	4604      	mov	r4, r0
    2ab4:	460d      	mov	r5, r1
    2ab6:	4b35      	ldr	r3, [pc, #212]	; (2b8c <speed_PID_controller(double, double, double, double, double, double, double)+0x1a0>)
    2ab8:	4630      	mov	r0, r6
    2aba:	4639      	mov	r1, r7
    2abc:	f006 f9a0 	bl	8e00 <__aeabi_dmul>
    2ac0:	4602      	mov	r2, r0
    2ac2:	460b      	mov	r3, r1
    2ac4:	4620      	mov	r0, r4
    2ac6:	4629      	mov	r1, r5
    2ac8:	f005 ffe8 	bl	8a9c <__adddf3>
    2acc:	ed9d 5b04 	vldr	d5, [sp, #16]
    2ad0:	4606      	mov	r6, r0
    2ad2:	ec53 2b15 	vmov	r2, r3, d5
    2ad6:	460f      	mov	r7, r1
    2ad8:	e9dd 0100 	ldrd	r0, r1, [sp]
    2adc:	f005 ffdc 	bl	8a98 <__aeabi_dsub>
    2ae0:	4642      	mov	r2, r8
    2ae2:	464b      	mov	r3, r9
    2ae4:	f006 fab6 	bl	9054 <__aeabi_ddiv>
    2ae8:	2200      	movs	r2, #0
    2aea:	2300      	movs	r3, #0
    2aec:	f006 f988 	bl	8e00 <__aeabi_dmul>
    2af0:	4602      	mov	r2, r0
    2af2:	460b      	mov	r3, r1
    2af4:	4630      	mov	r0, r6
    2af6:	4639      	mov	r1, r7
    2af8:	f005 ffd0 	bl	8a9c <__adddf3>
  double pwm_signal_r = omega_to_pwm(controller_output_r);
    2afc:	4652      	mov	r2, sl
  cum_error_r += error_r * elapsed_time;
  cum_error_l += error_l * elapsed_time;
  double rate_error_r = (error_r - last_error_r) / elapsed_time;
  double rate_error_l = (error_l - last_error_l) / elapsed_time;
  double controller_output_r = error_r * p_gain + cum_error_r * i_gain + rate_error_r * d_gain;
  double controller_output_l = error_l * p_gain + cum_error_l * i_gain + rate_error_l * d_gain;
    2afe:	4606      	mov	r6, r0
    2b00:	460f      	mov	r7, r1
  double pwm_signal_r = omega_to_pwm(controller_output_r);
    2b02:	465b      	mov	r3, fp
    2b04:	4650      	mov	r0, sl
    2b06:	4659      	mov	r1, fp
    2b08:	f005 ffc8 	bl	8a9c <__adddf3>
    2b0c:	2200      	movs	r2, #0
    2b0e:	4604      	mov	r4, r0
    2b10:	460d      	mov	r5, r1
    2b12:	4b1e      	ldr	r3, [pc, #120]	; (2b8c <speed_PID_controller(double, double, double, double, double, double, double)+0x1a0>)
    2b14:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    2b18:	f006 f972 	bl	8e00 <__aeabi_dmul>
    2b1c:	4602      	mov	r2, r0
    2b1e:	460b      	mov	r3, r1
    2b20:	4620      	mov	r0, r4
    2b22:	4629      	mov	r1, r5
    2b24:	f005 ffba 	bl	8a9c <__adddf3>
    2b28:	ed9d 2b06 	vldr	d2, [sp, #24]
    2b2c:	4604      	mov	r4, r0
    2b2e:	ec53 2b12 	vmov	r2, r3, d2
    2b32:	460d      	mov	r5, r1
    2b34:	4650      	mov	r0, sl
    2b36:	4659      	mov	r1, fp
    2b38:	f005 ffae 	bl	8a98 <__aeabi_dsub>
    2b3c:	4642      	mov	r2, r8
    2b3e:	464b      	mov	r3, r9
    2b40:	f006 fa88 	bl	9054 <__aeabi_ddiv>
    2b44:	2200      	movs	r2, #0
    2b46:	2300      	movs	r3, #0
    2b48:	f006 f95a 	bl	8e00 <__aeabi_dmul>
    2b4c:	4602      	mov	r2, r0
    2b4e:	460b      	mov	r3, r1
    2b50:	4620      	mov	r0, r4
    2b52:	4629      	mov	r1, r5
    2b54:	f005 ffa2 	bl	8a9c <__adddf3>
    2b58:	ec41 0b10 	vmov	d0, r0, r1
    2b5c:	f7ff fdc4 	bl	26e8 <omega_to_pwm(double)>
  double pwm_signal_l = omega_to_pwm(controller_output_l);
    2b60:	ec47 6b10 	vmov	d0, r6, r7
  cum_error_l += error_l * elapsed_time;
  double rate_error_r = (error_r - last_error_r) / elapsed_time;
  double rate_error_l = (error_l - last_error_l) / elapsed_time;
  double controller_output_r = error_r * p_gain + cum_error_r * i_gain + rate_error_r * d_gain;
  double controller_output_l = error_l * p_gain + cum_error_l * i_gain + rate_error_l * d_gain;
  double pwm_signal_r = omega_to_pwm(controller_output_r);
    2b64:	4604      	mov	r4, r0
  double pwm_signal_l = omega_to_pwm(controller_output_l);
    2b66:	f7ff fdbf 	bl	26e8 <omega_to_pwm(double)>
  setPWM(pwm_signal_r,pwm_signal_l);
    2b6a:	4601      	mov	r1, r0
    2b6c:	4620      	mov	r0, r4
}
    2b6e:	b00d      	add	sp, #52	; 0x34
    2b70:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  double rate_error_l = (error_l - last_error_l) / elapsed_time;
  double controller_output_r = error_r * p_gain + cum_error_r * i_gain + rate_error_r * d_gain;
  double controller_output_l = error_l * p_gain + cum_error_l * i_gain + rate_error_l * d_gain;
  double pwm_signal_r = omega_to_pwm(controller_output_r);
  double pwm_signal_l = omega_to_pwm(controller_output_l);
  setPWM(pwm_signal_r,pwm_signal_l);
    2b74:	f7ff bef8 	b.w	2968 <setPWM(int, int)>
    2b78:	1fff2b30 	.word	0x1fff2b30
    2b7c:	1fff1458 	.word	0x1fff1458
    2b80:	1fff2b40 	.word	0x1fff2b40
    2b84:	1fff2ad0 	.word	0x1fff2ad0
    2b88:	1fff2a98 	.word	0x1fff2a98
    2b8c:	3fe00000 	.word	0x3fe00000

00002b90 <RGB_led_set(String const&)>:
    //output_number = map(encoder_count,-counts_per_revolution, counts_per_revolution, -2*pi, 2*pi);
  }
  return output_number;
}

void RGB_led_set(const String& color) {
    2b90:	b510      	push	{r4, lr}
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	//unsigned char equals(const __FlashStringHelper *pgmstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
    2b92:	4971      	ldr	r1, [pc, #452]	; (2d58 <RGB_led_set(String const&)+0x1c8>)
    2b94:	4604      	mov	r4, r0
    2b96:	f004 fc8b 	bl	74b0 <String::equals(char const*) const>
  if (color == "red" || color == "Red" || color == "RED") {
    2b9a:	2800      	cmp	r0, #0
    2b9c:	d07a      	beq.n	2c94 <RGB_led_set(String const&)+0x104>
    digitalWrite(RGB_led_green, HIGH);
    2b9e:	2101      	movs	r1, #1
    2ba0:	2002      	movs	r0, #2
    2ba2:	f003 fbc9 	bl	6338 <digitalWrite>
    digitalWrite(RGB_led_blue, HIGH);
    2ba6:	2101      	movs	r1, #1
    2ba8:	2003      	movs	r0, #3
    2baa:	f003 fbc5 	bl	6338 <digitalWrite>
    digitalWrite(RGB_led_red, LOW);
    2bae:	2100      	movs	r1, #0
    2bb0:	2004      	movs	r0, #4
    2bb2:	f003 fbc1 	bl	6338 <digitalWrite>
    2bb6:	4969      	ldr	r1, [pc, #420]	; (2d5c <RGB_led_set(String const&)+0x1cc>)
    2bb8:	4620      	mov	r0, r4
    2bba:	f004 fc79 	bl	74b0 <String::equals(char const*) const>
  }
  if (color == "green" || color == "Green" || color == "GREEN") {
    2bbe:	2800      	cmp	r0, #0
    2bc0:	f000 80bb 	beq.w	2d3a <RGB_led_set(String const&)+0x1aa>
    digitalWrite(RGB_led_green, LOW);
    2bc4:	2100      	movs	r1, #0
    2bc6:	2002      	movs	r0, #2
    2bc8:	f003 fbb6 	bl	6338 <digitalWrite>
    digitalWrite(RGB_led_blue, HIGH);
    2bcc:	2101      	movs	r1, #1
    2bce:	2003      	movs	r0, #3
    2bd0:	f003 fbb2 	bl	6338 <digitalWrite>
    digitalWrite(RGB_led_red, HIGH);
    2bd4:	2101      	movs	r1, #1
    2bd6:	2004      	movs	r0, #4
    2bd8:	f003 fbae 	bl	6338 <digitalWrite>
    2bdc:	4960      	ldr	r1, [pc, #384]	; (2d60 <RGB_led_set(String const&)+0x1d0>)
    2bde:	4620      	mov	r0, r4
    2be0:	f004 fc66 	bl	74b0 <String::equals(char const*) const>
  }
  if (color == "blue" || color == "Blue" || color == "BLUE") {
    2be4:	2800      	cmp	r0, #0
    2be6:	f000 8099 	beq.w	2d1c <RGB_led_set(String const&)+0x18c>
    digitalWrite(RGB_led_green, HIGH);
    2bea:	2101      	movs	r1, #1
    2bec:	2002      	movs	r0, #2
    2bee:	f003 fba3 	bl	6338 <digitalWrite>
    digitalWrite(RGB_led_blue, LOW);
    2bf2:	2100      	movs	r1, #0
    2bf4:	2003      	movs	r0, #3
    2bf6:	f003 fb9f 	bl	6338 <digitalWrite>
    digitalWrite(RGB_led_red, HIGH);
    2bfa:	2101      	movs	r1, #1
    2bfc:	2004      	movs	r0, #4
    2bfe:	f003 fb9b 	bl	6338 <digitalWrite>
    2c02:	4958      	ldr	r1, [pc, #352]	; (2d64 <RGB_led_set(String const&)+0x1d4>)
    2c04:	4620      	mov	r0, r4
    2c06:	f004 fc53 	bl	74b0 <String::equals(char const*) const>
  }
  if (color == "cyan" || color == "Cyan" || color == "CYAN") {
    2c0a:	2800      	cmp	r0, #0
    2c0c:	d078      	beq.n	2d00 <RGB_led_set(String const&)+0x170>
    digitalWrite(RGB_led_green, LOW);
    2c0e:	2100      	movs	r1, #0
    2c10:	2002      	movs	r0, #2
    2c12:	f003 fb91 	bl	6338 <digitalWrite>
    digitalWrite(RGB_led_blue, LOW);
    2c16:	2100      	movs	r1, #0
    2c18:	2003      	movs	r0, #3
    2c1a:	f003 fb8d 	bl	6338 <digitalWrite>
    digitalWrite(RGB_led_red, HIGH);
    2c1e:	2101      	movs	r1, #1
    2c20:	2004      	movs	r0, #4
    2c22:	f003 fb89 	bl	6338 <digitalWrite>
    2c26:	4950      	ldr	r1, [pc, #320]	; (2d68 <RGB_led_set(String const&)+0x1d8>)
    2c28:	4620      	mov	r0, r4
    2c2a:	f004 fc41 	bl	74b0 <String::equals(char const*) const>
  }
  if (color == "purple" || color == "Purple" || color == "PURPLE") {
    2c2e:	2800      	cmp	r0, #0
    2c30:	d059      	beq.n	2ce6 <RGB_led_set(String const&)+0x156>
    digitalWrite(RGB_led_green, HIGH);
    2c32:	2101      	movs	r1, #1
    2c34:	2002      	movs	r0, #2
    2c36:	f003 fb7f 	bl	6338 <digitalWrite>
    digitalWrite(RGB_led_blue, LOW);
    2c3a:	2100      	movs	r1, #0
    2c3c:	2003      	movs	r0, #3
    2c3e:	f003 fb7b 	bl	6338 <digitalWrite>
    digitalWrite(RGB_led_red, LOW);
    2c42:	2100      	movs	r1, #0
    2c44:	2004      	movs	r0, #4
    2c46:	f003 fb77 	bl	6338 <digitalWrite>
    2c4a:	4948      	ldr	r1, [pc, #288]	; (2d6c <RGB_led_set(String const&)+0x1dc>)
    2c4c:	4620      	mov	r0, r4
    2c4e:	f004 fc2f 	bl	74b0 <String::equals(char const*) const>
  }
  if (color == "orange" || color == "Orange" || color == "ORANGE") {
    2c52:	2800      	cmp	r0, #0
    2c54:	d03a      	beq.n	2ccc <RGB_led_set(String const&)+0x13c>
    digitalWrite(RGB_led_green, LOW);
    2c56:	2100      	movs	r1, #0
    2c58:	2002      	movs	r0, #2
    2c5a:	f003 fb6d 	bl	6338 <digitalWrite>
    digitalWrite(RGB_led_blue, HIGH);
    2c5e:	2101      	movs	r1, #1
    2c60:	2003      	movs	r0, #3
    2c62:	f003 fb69 	bl	6338 <digitalWrite>
    digitalWrite(RGB_led_red, LOW);
    2c66:	2100      	movs	r1, #0
    2c68:	2004      	movs	r0, #4
    2c6a:	f003 fb65 	bl	6338 <digitalWrite>
    2c6e:	4940      	ldr	r1, [pc, #256]	; (2d70 <RGB_led_set(String const&)+0x1e0>)
    2c70:	4620      	mov	r0, r4
    2c72:	f004 fc1d 	bl	74b0 <String::equals(char const*) const>
  }
  if (color == "white " || color == "White" || color == "WHITE") {
    2c76:	b1e0      	cbz	r0, 2cb2 <RGB_led_set(String const&)+0x122>
    digitalWrite(RGB_led_green, LOW);
    2c78:	2100      	movs	r1, #0
    2c7a:	2002      	movs	r0, #2
    2c7c:	f003 fb5c 	bl	6338 <digitalWrite>
    digitalWrite(RGB_led_blue, LOW);
    2c80:	2100      	movs	r1, #0
    2c82:	2003      	movs	r0, #3
    2c84:	f003 fb58 	bl	6338 <digitalWrite>
    digitalWrite(RGB_led_red, LOW);
    2c88:	2100      	movs	r1, #0
    2c8a:	2004      	movs	r0, #4
  }
}
    2c8c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    digitalWrite(RGB_led_red, LOW);
  }
  if (color == "white " || color == "White" || color == "WHITE") {
    digitalWrite(RGB_led_green, LOW);
    digitalWrite(RGB_led_blue, LOW);
    digitalWrite(RGB_led_red, LOW);
    2c90:	f003 bb52 	b.w	6338 <digitalWrite>
    2c94:	4937      	ldr	r1, [pc, #220]	; (2d74 <RGB_led_set(String const&)+0x1e4>)
    2c96:	4620      	mov	r0, r4
    2c98:	f004 fc0a 	bl	74b0 <String::equals(char const*) const>
  }
  return output_number;
}

void RGB_led_set(const String& color) {
  if (color == "red" || color == "Red" || color == "RED") {
    2c9c:	2800      	cmp	r0, #0
    2c9e:	f47f af7e 	bne.w	2b9e <RGB_led_set(String const&)+0xe>
    2ca2:	4935      	ldr	r1, [pc, #212]	; (2d78 <RGB_led_set(String const&)+0x1e8>)
    2ca4:	4620      	mov	r0, r4
    2ca6:	f004 fc03 	bl	74b0 <String::equals(char const*) const>
    2caa:	2800      	cmp	r0, #0
    2cac:	f47f af77 	bne.w	2b9e <RGB_led_set(String const&)+0xe>
    2cb0:	e781      	b.n	2bb6 <RGB_led_set(String const&)+0x26>
    2cb2:	4932      	ldr	r1, [pc, #200]	; (2d7c <RGB_led_set(String const&)+0x1ec>)
    2cb4:	4620      	mov	r0, r4
    2cb6:	f004 fbfb 	bl	74b0 <String::equals(char const*) const>
  if (color == "orange" || color == "Orange" || color == "ORANGE") {
    digitalWrite(RGB_led_green, LOW);
    digitalWrite(RGB_led_blue, HIGH);
    digitalWrite(RGB_led_red, LOW);
  }
  if (color == "white " || color == "White" || color == "WHITE") {
    2cba:	2800      	cmp	r0, #0
    2cbc:	d1dc      	bne.n	2c78 <RGB_led_set(String const&)+0xe8>
    2cbe:	4620      	mov	r0, r4
    2cc0:	492f      	ldr	r1, [pc, #188]	; (2d80 <RGB_led_set(String const&)+0x1f0>)
    2cc2:	f004 fbf5 	bl	74b0 <String::equals(char const*) const>
    2cc6:	2800      	cmp	r0, #0
    2cc8:	d1d6      	bne.n	2c78 <RGB_led_set(String const&)+0xe8>
    2cca:	bd10      	pop	{r4, pc}
    2ccc:	492d      	ldr	r1, [pc, #180]	; (2d84 <RGB_led_set(String const&)+0x1f4>)
    2cce:	4620      	mov	r0, r4
    2cd0:	f004 fbee 	bl	74b0 <String::equals(char const*) const>
  if (color == "purple" || color == "Purple" || color == "PURPLE") {
    digitalWrite(RGB_led_green, HIGH);
    digitalWrite(RGB_led_blue, LOW);
    digitalWrite(RGB_led_red, LOW);
  }
  if (color == "orange" || color == "Orange" || color == "ORANGE") {
    2cd4:	2800      	cmp	r0, #0
    2cd6:	d1be      	bne.n	2c56 <RGB_led_set(String const&)+0xc6>
    2cd8:	492b      	ldr	r1, [pc, #172]	; (2d88 <RGB_led_set(String const&)+0x1f8>)
    2cda:	4620      	mov	r0, r4
    2cdc:	f004 fbe8 	bl	74b0 <String::equals(char const*) const>
    2ce0:	2800      	cmp	r0, #0
    2ce2:	d1b8      	bne.n	2c56 <RGB_led_set(String const&)+0xc6>
    2ce4:	e7c3      	b.n	2c6e <RGB_led_set(String const&)+0xde>
    2ce6:	4929      	ldr	r1, [pc, #164]	; (2d8c <RGB_led_set(String const&)+0x1fc>)
    2ce8:	4620      	mov	r0, r4
    2cea:	f004 fbe1 	bl	74b0 <String::equals(char const*) const>
  if (color == "cyan" || color == "Cyan" || color == "CYAN") {
    digitalWrite(RGB_led_green, LOW);
    digitalWrite(RGB_led_blue, LOW);
    digitalWrite(RGB_led_red, HIGH);
  }
  if (color == "purple" || color == "Purple" || color == "PURPLE") {
    2cee:	2800      	cmp	r0, #0
    2cf0:	d19f      	bne.n	2c32 <RGB_led_set(String const&)+0xa2>
    2cf2:	4927      	ldr	r1, [pc, #156]	; (2d90 <RGB_led_set(String const&)+0x200>)
    2cf4:	4620      	mov	r0, r4
    2cf6:	f004 fbdb 	bl	74b0 <String::equals(char const*) const>
    2cfa:	2800      	cmp	r0, #0
    2cfc:	d199      	bne.n	2c32 <RGB_led_set(String const&)+0xa2>
    2cfe:	e7a4      	b.n	2c4a <RGB_led_set(String const&)+0xba>
    2d00:	4924      	ldr	r1, [pc, #144]	; (2d94 <RGB_led_set(String const&)+0x204>)
    2d02:	4620      	mov	r0, r4
    2d04:	f004 fbd4 	bl	74b0 <String::equals(char const*) const>
  if (color == "blue" || color == "Blue" || color == "BLUE") {
    digitalWrite(RGB_led_green, HIGH);
    digitalWrite(RGB_led_blue, LOW);
    digitalWrite(RGB_led_red, HIGH);
  }
  if (color == "cyan" || color == "Cyan" || color == "CYAN") {
    2d08:	2800      	cmp	r0, #0
    2d0a:	d180      	bne.n	2c0e <RGB_led_set(String const&)+0x7e>
    2d0c:	4922      	ldr	r1, [pc, #136]	; (2d98 <RGB_led_set(String const&)+0x208>)
    2d0e:	4620      	mov	r0, r4
    2d10:	f004 fbce 	bl	74b0 <String::equals(char const*) const>
    2d14:	2800      	cmp	r0, #0
    2d16:	f47f af7a 	bne.w	2c0e <RGB_led_set(String const&)+0x7e>
    2d1a:	e784      	b.n	2c26 <RGB_led_set(String const&)+0x96>
    2d1c:	491f      	ldr	r1, [pc, #124]	; (2d9c <RGB_led_set(String const&)+0x20c>)
    2d1e:	4620      	mov	r0, r4
    2d20:	f004 fbc6 	bl	74b0 <String::equals(char const*) const>
  if (color == "green" || color == "Green" || color == "GREEN") {
    digitalWrite(RGB_led_green, LOW);
    digitalWrite(RGB_led_blue, HIGH);
    digitalWrite(RGB_led_red, HIGH);
  }
  if (color == "blue" || color == "Blue" || color == "BLUE") {
    2d24:	2800      	cmp	r0, #0
    2d26:	f47f af60 	bne.w	2bea <RGB_led_set(String const&)+0x5a>
    2d2a:	491d      	ldr	r1, [pc, #116]	; (2da0 <RGB_led_set(String const&)+0x210>)
    2d2c:	4620      	mov	r0, r4
    2d2e:	f004 fbbf 	bl	74b0 <String::equals(char const*) const>
    2d32:	2800      	cmp	r0, #0
    2d34:	f47f af59 	bne.w	2bea <RGB_led_set(String const&)+0x5a>
    2d38:	e763      	b.n	2c02 <RGB_led_set(String const&)+0x72>
    2d3a:	491a      	ldr	r1, [pc, #104]	; (2da4 <RGB_led_set(String const&)+0x214>)
    2d3c:	4620      	mov	r0, r4
    2d3e:	f004 fbb7 	bl	74b0 <String::equals(char const*) const>
  if (color == "red" || color == "Red" || color == "RED") {
    digitalWrite(RGB_led_green, HIGH);
    digitalWrite(RGB_led_blue, HIGH);
    digitalWrite(RGB_led_red, LOW);
  }
  if (color == "green" || color == "Green" || color == "GREEN") {
    2d42:	2800      	cmp	r0, #0
    2d44:	f47f af3e 	bne.w	2bc4 <RGB_led_set(String const&)+0x34>
    2d48:	4917      	ldr	r1, [pc, #92]	; (2da8 <RGB_led_set(String const&)+0x218>)
    2d4a:	4620      	mov	r0, r4
    2d4c:	f004 fbb0 	bl	74b0 <String::equals(char const*) const>
    2d50:	2800      	cmp	r0, #0
    2d52:	f47f af37 	bne.w	2bc4 <RGB_led_set(String const&)+0x34>
    2d56:	e741      	b.n	2bdc <RGB_led_set(String const&)+0x4c>
    2d58:	0000ab18 	.word	0x0000ab18
    2d5c:	0000ab24 	.word	0x0000ab24
    2d60:	0000ab3c 	.word	0x0000ab3c
    2d64:	0000ab54 	.word	0x0000ab54
    2d68:	0000ab6c 	.word	0x0000ab6c
    2d6c:	0000ab84 	.word	0x0000ab84
    2d70:	0000ab9c 	.word	0x0000ab9c
    2d74:	0000ab1c 	.word	0x0000ab1c
    2d78:	0000ab20 	.word	0x0000ab20
    2d7c:	0000aba4 	.word	0x0000aba4
    2d80:	0000abac 	.word	0x0000abac
    2d84:	0000ab8c 	.word	0x0000ab8c
    2d88:	0000ab94 	.word	0x0000ab94
    2d8c:	0000ab74 	.word	0x0000ab74
    2d90:	0000ab7c 	.word	0x0000ab7c
    2d94:	0000ab5c 	.word	0x0000ab5c
    2d98:	0000ab64 	.word	0x0000ab64
    2d9c:	0000ab44 	.word	0x0000ab44
    2da0:	0000ab4c 	.word	0x0000ab4c
    2da4:	0000ab2c 	.word	0x0000ab2c
    2da8:	0000ab34 	.word	0x0000ab34

00002dac <start_up_hi(std_msgs::Int16&)>:
  //wheel_speed.w = goal_omega_left;

  //speed_pub.publish(&wheel_speed);
}

void start_up_hi(std_msgs::Int16& num){
    2dac:	b510      	push	{r4, lr}
  hi = num.data;
    2dae:	f9b0 3004 	ldrsh.w	r3, [r0, #4]
    2db2:	4c0f      	ldr	r4, [pc, #60]	; (2df0 <start_up_hi(std_msgs::Int16&)+0x44>)
  if (hi == 1){
    2db4:	2b01      	cmp	r3, #1
  //wheel_speed.w = goal_omega_left;

  //speed_pub.publish(&wheel_speed);
}

void start_up_hi(std_msgs::Int16& num){
    2db6:	b084      	sub	sp, #16
  hi = num.data;
    2db8:	6023      	str	r3, [r4, #0]
  if (hi == 1){
    2dba:	d00c      	beq.n	2dd6 <start_up_hi(std_msgs::Int16&)+0x2a>
    RGB_led_set("green");
  }
  if (hi == 0){
    2dbc:	b94b      	cbnz	r3, 2dd2 <start_up_hi(std_msgs::Int16&)+0x26>
    RGB_led_set("red");
    2dbe:	490d      	ldr	r1, [pc, #52]	; (2df4 <start_up_hi(std_msgs::Int16&)+0x48>)
    2dc0:	4668      	mov	r0, sp
    2dc2:	f004 fb61 	bl	7488 <String::String(char const*)>
    2dc6:	4668      	mov	r0, sp
    2dc8:	f7ff fee2 	bl	2b90 <RGB_led_set(String const&)>
    2dcc:	4668      	mov	r0, sp
    2dce:	f004 fb1b 	bl	7408 <String::~String()>
  }
}
    2dd2:	b004      	add	sp, #16
    2dd4:	bd10      	pop	{r4, pc}
}

void start_up_hi(std_msgs::Int16& num){
  hi = num.data;
  if (hi == 1){
    RGB_led_set("green");
    2dd6:	4908      	ldr	r1, [pc, #32]	; (2df8 <start_up_hi(std_msgs::Int16&)+0x4c>)
    2dd8:	4668      	mov	r0, sp
    2dda:	f004 fb55 	bl	7488 <String::String(char const*)>
    2dde:	4668      	mov	r0, sp
    2de0:	f7ff fed6 	bl	2b90 <RGB_led_set(String const&)>
    2de4:	4668      	mov	r0, sp
    2de6:	f004 fb0f 	bl	7408 <String::~String()>
    2dea:	6823      	ldr	r3, [r4, #0]
    2dec:	e7e6      	b.n	2dbc <start_up_hi(std_msgs::Int16&)+0x10>
    2dee:	bf00      	nop
    2df0:	1fff1ce0 	.word	0x1fff1ce0
    2df4:	0000ab18 	.word	0x0000ab18
    2df8:	0000ab24 	.word	0x0000ab24
    2dfc:	ffffffff 	.word	0xffffffff

00002e00 <wheel_speed_set(double, double, int)>:
  double pwm_signal_r = omega_to_pwm(controller_output_r);
  double pwm_signal_l = omega_to_pwm(controller_output_l);
  setPWM(pwm_signal_r,pwm_signal_l);
}

void wheel_speed_set(double input_vel_x, double input_omega, int tele_op){
    2e00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2e04:	ed2d 8b04 	vpush	{d8-d9}
  double vel_x_goal;
  double goal_omega;

  if (tele_op == 100){
    2e08:	2864      	cmp	r0, #100	; 0x64
  double pwm_signal_r = omega_to_pwm(controller_output_r);
  double pwm_signal_l = omega_to_pwm(controller_output_l);
  setPWM(pwm_signal_r,pwm_signal_l);
}

void wheel_speed_set(double input_vel_x, double input_omega, int tele_op){
    2e0a:	b089      	sub	sp, #36	; 0x24
  double vel_x_goal;
  double goal_omega;

  if (tele_op == 100){
    2e0c:	f000 8113 	beq.w	3036 <wheel_speed_set(double, double, int)+0x236>
    2e10:	eeb0 8a40 	vmov.f32	s16, s0
    2e14:	eef0 8a60 	vmov.f32	s17, s1
    2e18:	eeb0 9a41 	vmov.f32	s18, s2
    2e1c:	eef0 9a61 	vmov.f32	s19, s3
    RGB_led_set("red");
  }
  if (tele_op == 0 || tele_op == 1){//keyboard tele-op or PS4 controller tele-op
    2e20:	2801      	cmp	r0, #1
    2e22:	d906      	bls.n	2e32 <wheel_speed_set(double, double, int)+0x32>
    pwm_procent_right = int(map(goal_omega_right, 0, 100, 0, 255));
    pwm_procent_left = int(map(goal_omega_left, 0, 100, 0, 255));
    setPWM(pwm_procent_right, pwm_procent_left);
  }

  else if(tele_op == 2){//speed control with speed (PID) controller
    2e24:	2802      	cmp	r0, #2
    2e26:	d06b      	beq.n	2f00 <wheel_speed_set(double, double, int)+0x100>
  //wheel_speed.y = goal_omega;
  //wheel_speed.z = goal_omega_right;
  //wheel_speed.w = goal_omega_left;

  //speed_pub.publish(&wheel_speed);
}
    2e28:	b009      	add	sp, #36	; 0x24
    2e2a:	ecbd 8b04 	vpop	{d8-d9}
    2e2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

  if (tele_op == 100){
    RGB_led_set("red");
  }
  if (tele_op == 0 || tele_op == 1){//keyboard tele-op or PS4 controller tele-op
    if (tele_op == 0){ //keyboard tele-op setting indicator color
    2e32:	2800      	cmp	r0, #0
    2e34:	f000 80fc 	beq.w	3030 <wheel_speed_set(double, double, int)+0x230>
      RGB_led_set("purple");
    }
    if (tele_op == 1){ //PS4 controller tele-op setting indicator color
      RGB_led_set("blue");
    2e38:	498b      	ldr	r1, [pc, #556]	; (3068 <wheel_speed_set(double, double, int)+0x268>)
    2e3a:	a804      	add	r0, sp, #16
  if (tele_op == 100){
    RGB_led_set("red");
  }
  if (tele_op == 0 || tele_op == 1){//keyboard tele-op or PS4 controller tele-op
    if (tele_op == 0){ //keyboard tele-op setting indicator color
      RGB_led_set("purple");
    2e3c:	f004 fb24 	bl	7488 <String::String(char const*)>
    2e40:	a804      	add	r0, sp, #16
    2e42:	f7ff fea5 	bl	2b90 <RGB_led_set(String const&)>
    2e46:	a804      	add	r0, sp, #16
    2e48:	f004 fade 	bl	7408 <String::~String()>
    if (tele_op == 1){ //PS4 controller tele-op setting indicator color
      RGB_led_set("blue");
    }
    // here we assume that the imput is for input_vel_x is between 0 - 1 and
    // input_omega is between 0 - 0.5
    vel_x_goal = input_vel_x * 75;
    2e4c:	a382      	add	r3, pc, #520	; (adr r3, 3058 <wheel_speed_set(double, double, int)+0x258>)
    2e4e:	e9d3 2300 	ldrd	r2, r3, [r3]
    2e52:	ec51 0b18 	vmov	r0, r1, d8
    2e56:	f005 ffd3 	bl	8e00 <__aeabi_dmul>
    goal_omega = input_omega * 50;
    2e5a:	2200      	movs	r2, #0
    if (tele_op == 1){ //PS4 controller tele-op setting indicator color
      RGB_led_set("blue");
    }
    // here we assume that the imput is for input_vel_x is between 0 - 1 and
    // input_omega is between 0 - 0.5
    vel_x_goal = input_vel_x * 75;
    2e5c:	4606      	mov	r6, r0
    2e5e:	460f      	mov	r7, r1
    goal_omega = input_omega * 50;
    2e60:	4b82      	ldr	r3, [pc, #520]	; (306c <wheel_speed_set(double, double, int)+0x26c>)
    2e62:	ec51 0b19 	vmov	r0, r1, d9
    2e66:	f005 ffcb 	bl	8e00 <__aeabi_dmul>
    2e6a:	4680      	mov	r8, r0
    2e6c:	4689      	mov	r9, r1
    goal_omega_right = vel_x_goal + goal_omega;
    2e6e:	4602      	mov	r2, r0
    2e70:	460b      	mov	r3, r1
    2e72:	4630      	mov	r0, r6
    2e74:	4639      	mov	r1, r7
    2e76:	f005 fe11 	bl	8a9c <__adddf3>
    2e7a:	f8df e230 	ldr.w	lr, [pc, #560]	; 30ac <wheel_speed_set(double, double, int)+0x2ac>
    2e7e:	4604      	mov	r4, r0
    2e80:	460d      	mov	r5, r1
    2e82:	e9ce 4500 	strd	r4, r5, [lr]
    goal_omega_left = vel_x_goal - goal_omega;
    2e86:	4642      	mov	r2, r8
    2e88:	464b      	mov	r3, r9
    2e8a:	4630      	mov	r0, r6
    2e8c:	4639      	mov	r1, r7
    2e8e:	f005 fe03 	bl	8a98 <__aeabi_dsub>
    2e92:	f8df e21c 	ldr.w	lr, [pc, #540]	; 30b0 <wheel_speed_set(double, double, int)+0x2b0>
    2e96:	4606      	mov	r6, r0
    2e98:	460f      	mov	r7, r1
    2e9a:	e9ce 6700 	strd	r6, r7, [lr]
    pwm_procent_right = int(map(goal_omega_right, 0, 100, 0, 255));
    2e9e:	a370      	add	r3, pc, #448	; (adr r3, 3060 <wheel_speed_set(double, double, int)+0x260>)
    2ea0:	e9d3 2300 	ldrd	r2, r3, [r3]
    2ea4:	4620      	mov	r0, r4
    2ea6:	4629      	mov	r1, r5
    2ea8:	f005 ffaa 	bl	8e00 <__aeabi_dmul>
    2eac:	2200      	movs	r2, #0
    2eae:	4b70      	ldr	r3, [pc, #448]	; (3070 <wheel_speed_set(double, double, int)+0x270>)
    2eb0:	4d70      	ldr	r5, [pc, #448]	; (3074 <wheel_speed_set(double, double, int)+0x274>)
    2eb2:	f006 f8cf 	bl	9054 <__aeabi_ddiv>
    2eb6:	2200      	movs	r2, #0
    2eb8:	2300      	movs	r3, #0
    2eba:	f005 fdef 	bl	8a9c <__adddf3>
    2ebe:	f006 fa4f 	bl	9360 <__aeabi_d2iz>
    2ec2:	4604      	mov	r4, r0
    pwm_procent_left = int(map(goal_omega_left, 0, 100, 0, 255));
    2ec4:	a366      	add	r3, pc, #408	; (adr r3, 3060 <wheel_speed_set(double, double, int)+0x260>)
    2ec6:	e9d3 2300 	ldrd	r2, r3, [r3]
    2eca:	4630      	mov	r0, r6
    2ecc:	4639      	mov	r1, r7
    // input_omega is between 0 - 0.5
    vel_x_goal = input_vel_x * 75;
    goal_omega = input_omega * 50;
    goal_omega_right = vel_x_goal + goal_omega;
    goal_omega_left = vel_x_goal - goal_omega;
    pwm_procent_right = int(map(goal_omega_right, 0, 100, 0, 255));
    2ece:	602c      	str	r4, [r5, #0]
    pwm_procent_left = int(map(goal_omega_left, 0, 100, 0, 255));
    2ed0:	f005 ff96 	bl	8e00 <__aeabi_dmul>
    2ed4:	2200      	movs	r2, #0
    2ed6:	4b66      	ldr	r3, [pc, #408]	; (3070 <wheel_speed_set(double, double, int)+0x270>)
    2ed8:	f006 f8bc 	bl	9054 <__aeabi_ddiv>
    2edc:	2200      	movs	r2, #0
    2ede:	2300      	movs	r3, #0
    2ee0:	f005 fddc 	bl	8a9c <__adddf3>
    2ee4:	f006 fa3c 	bl	9360 <__aeabi_d2iz>
    2ee8:	4a63      	ldr	r2, [pc, #396]	; (3078 <wheel_speed_set(double, double, int)+0x278>)
    2eea:	4603      	mov	r3, r0
    setPWM(pwm_procent_right, pwm_procent_left);
    2eec:	4619      	mov	r1, r3
    2eee:	4620      	mov	r0, r4
    vel_x_goal = input_vel_x * 75;
    goal_omega = input_omega * 50;
    goal_omega_right = vel_x_goal + goal_omega;
    goal_omega_left = vel_x_goal - goal_omega;
    pwm_procent_right = int(map(goal_omega_right, 0, 100, 0, 255));
    pwm_procent_left = int(map(goal_omega_left, 0, 100, 0, 255));
    2ef0:	6013      	str	r3, [r2, #0]
    setPWM(pwm_procent_right, pwm_procent_left);
    2ef2:	f7ff fd39 	bl	2968 <setPWM(int, int)>
  //wheel_speed.y = goal_omega;
  //wheel_speed.z = goal_omega_right;
  //wheel_speed.w = goal_omega_left;

  //speed_pub.publish(&wheel_speed);
}
    2ef6:	b009      	add	sp, #36	; 0x24
    2ef8:	ecbd 8b04 	vpop	{d8-d9}
    2efc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    pwm_procent_left = int(map(goal_omega_left, 0, 100, 0, 255));
    setPWM(pwm_procent_right, pwm_procent_left);
  }

  else if(tele_op == 2){//speed control with speed (PID) controller
    RGB_led_set("green");
    2f00:	495e      	ldr	r1, [pc, #376]	; (307c <wheel_speed_set(double, double, int)+0x27c>)
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    2f02:	f8df b1a8 	ldr.w	fp, [pc, #424]	; 30ac <wheel_speed_set(double, double, int)+0x2ac>
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    2f06:	f8df a1a8 	ldr.w	sl, [pc, #424]	; 30b0 <wheel_speed_set(double, double, int)+0x2b0>
    pwm_procent_left = int(map(goal_omega_left, 0, 100, 0, 255));
    setPWM(pwm_procent_right, pwm_procent_left);
  }

  else if(tele_op == 2){//speed control with speed (PID) controller
    RGB_led_set("green");
    2f0a:	a804      	add	r0, sp, #16
    2f0c:	f004 fabc 	bl	7488 <String::String(char const*)>
    2f10:	a804      	add	r0, sp, #16
    2f12:	f7ff fe3d 	bl	2b90 <RGB_led_set(String const&)>
    2f16:	a804      	add	r0, sp, #16
    2f18:	f004 fa76 	bl	7408 <String::~String()>
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    2f1c:	ec53 2b18 	vmov	r2, r3, d8
    2f20:	ee18 0a10 	vmov	r0, s16
    2f24:	4619      	mov	r1, r3
    2f26:	f005 fdb9 	bl	8a9c <__adddf3>
    2f2a:	4b55      	ldr	r3, [pc, #340]	; (3080 <wheel_speed_set(double, double, int)+0x280>)
    2f2c:	4606      	mov	r6, r0
    2f2e:	6818      	ldr	r0, [r3, #0]
    2f30:	460f      	mov	r7, r1
    2f32:	f005 ff11 	bl	8d58 <__aeabi_f2d>
    2f36:	ec53 2b19 	vmov	r2, r3, d9
    2f3a:	f005 ff61 	bl	8e00 <__aeabi_dmul>
    2f3e:	4b51      	ldr	r3, [pc, #324]	; (3084 <wheel_speed_set(double, double, int)+0x284>)
    2f40:	ed93 7a00 	vldr	s14, [r3]
    2f44:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
    2f48:	ee67 7a27 	vmul.f32	s15, s14, s15
    2f4c:	4680      	mov	r8, r0
    2f4e:	ee17 0a90 	vmov	r0, s15
    2f52:	4689      	mov	r9, r1
    2f54:	f005 ff00 	bl	8d58 <__aeabi_f2d>
    2f58:	4642      	mov	r2, r8
    2f5a:	4604      	mov	r4, r0
    2f5c:	460d      	mov	r5, r1
    2f5e:	464b      	mov	r3, r9
    2f60:	4630      	mov	r0, r6
    2f62:	4639      	mov	r1, r7
    2f64:	f005 fd9a 	bl	8a9c <__adddf3>
    2f68:	4622      	mov	r2, r4
    2f6a:	462b      	mov	r3, r5
    2f6c:	f006 f872 	bl	9054 <__aeabi_ddiv>
    2f70:	e9cd 0100 	strd	r0, r1, [sp]
    2f74:	ed9d 7b00 	vldr	d7, [sp]
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    2f78:	4642      	mov	r2, r8
    2f7a:	464b      	mov	r3, r9
    2f7c:	4630      	mov	r0, r6
    2f7e:	4639      	mov	r1, r7
  else if(tele_op == 2){//speed control with speed (PID) controller
    RGB_led_set("green");
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    2f80:	ed8b 7b00 	vstr	d7, [fp]
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    2f84:	f005 fd88 	bl	8a98 <__aeabi_dsub>
    2f88:	4622      	mov	r2, r4
    2f8a:	462b      	mov	r3, r5
    2f8c:	f006 f862 	bl	9054 <__aeabi_ddiv>
    double time_elapsed = double(current_time - previous_time);
    2f90:	4a3d      	ldr	r2, [pc, #244]	; (3088 <wheel_speed_set(double, double, int)+0x288>)
    2f92:	4b3e      	ldr	r3, [pc, #248]	; (308c <wheel_speed_set(double, double, int)+0x28c>)
    if(goal_omega_right > 15){
    2f94:	4d3e      	ldr	r5, [pc, #248]	; (3090 <wheel_speed_set(double, double, int)+0x290>)
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    double time_elapsed = double(current_time - previous_time);
    2f96:	681b      	ldr	r3, [r3, #0]
    RGB_led_set("green");
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    2f98:	4606      	mov	r6, r0
    double time_elapsed = double(current_time - previous_time);
    2f9a:	6810      	ldr	r0, [r2, #0]
    RGB_led_set("green");
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    2f9c:	460f      	mov	r7, r1
    double time_elapsed = double(current_time - previous_time);
    2f9e:	1ac0      	subs	r0, r0, r3
    RGB_led_set("green");
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    2fa0:	e9ca 6700 	strd	r6, r7, [sl]
    double time_elapsed = double(current_time - previous_time);
    2fa4:	f005 fec6 	bl	8d34 <__aeabi_i2d>
    if(goal_omega_right > 15){
    2fa8:	2400      	movs	r4, #0
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    double time_elapsed = double(current_time - previous_time);
    2faa:	4680      	mov	r8, r0
    2fac:	4689      	mov	r9, r1
    if(goal_omega_right > 15){
    2fae:	4622      	mov	r2, r4
    2fb0:	462b      	mov	r3, r5
    2fb2:	e9dd 0100 	ldrd	r0, r1, [sp]
    2fb6:	f006 f9b3 	bl	9320 <__aeabi_dcmpgt>
    2fba:	b118      	cbz	r0, 2fc4 <wheel_speed_set(double, double, int)+0x1c4>
      goal_omega_right = 15;
    2fbc:	e9cb 4500 	strd	r4, r5, [fp]
    2fc0:	e9cd 4500 	strd	r4, r5, [sp]
    }
    if(goal_omega_left > 15){
    2fc4:	4d32      	ldr	r5, [pc, #200]	; (3090 <wheel_speed_set(double, double, int)+0x290>)
    2fc6:	2400      	movs	r4, #0
    2fc8:	4630      	mov	r0, r6
    2fca:	4639      	mov	r1, r7
    2fcc:	4622      	mov	r2, r4
    2fce:	462b      	mov	r3, r5
    2fd0:	f006 f9a6 	bl	9320 <__aeabi_dcmpgt>
    2fd4:	b118      	cbz	r0, 2fde <wheel_speed_set(double, double, int)+0x1de>
      goal_omega_left = 15;
    2fd6:	e9ca 4500 	strd	r4, r5, [sl]
    2fda:	4626      	mov	r6, r4
    2fdc:	462f      	mov	r7, r5
    }
    //temp_input_vel = goal_omega_right;
    speed_PID_controller(goal_omega_right, average_omega_right, last_error_right, goal_omega_left, average_omega_left, last_error_left, time_elapsed);
    2fde:	4a2d      	ldr	r2, [pc, #180]	; (3094 <wheel_speed_set(double, double, int)+0x294>)
    2fe0:	4b2d      	ldr	r3, [pc, #180]	; (3098 <wheel_speed_set(double, double, int)+0x298>)
    2fe2:	6810      	ldr	r0, [r2, #0]
    2fe4:	ed93 9b00 	vldr	d9, [r3]
    2fe8:	f005 feb6 	bl	8d58 <__aeabi_f2d>
    2fec:	4b2b      	ldr	r3, [pc, #172]	; (309c <wheel_speed_set(double, double, int)+0x29c>)
    2fee:	4a2c      	ldr	r2, [pc, #176]	; (30a0 <wheel_speed_set(double, double, int)+0x2a0>)
    2ff0:	e9cd 0102 	strd	r0, r1, [sp, #8]
    2ff4:	6818      	ldr	r0, [r3, #0]
    2ff6:	ed92 8b00 	vldr	d8, [r2]
    2ffa:	f005 fead 	bl	8d58 <__aeabi_f2d>
    2ffe:	eeb0 5a49 	vmov.f32	s10, s18
    3002:	eef0 5a69 	vmov.f32	s11, s19
    3006:	eeb0 2a48 	vmov.f32	s4, s16
    300a:	eef0 2a68 	vmov.f32	s5, s17
    300e:	ec49 8b16 	vmov	d6, r8, r9
    3012:	ed9d 4b02 	vldr	d4, [sp, #8]
    3016:	ec47 6b13 	vmov	d3, r6, r7
    301a:	ec41 0b11 	vmov	d1, r0, r1
    301e:	ed9d 0b00 	vldr	d0, [sp]
    3022:	f7ff fce3 	bl	29ec <speed_PID_controller(double, double, double, double, double, double, double)>
  //wheel_speed.y = goal_omega;
  //wheel_speed.z = goal_omega_right;
  //wheel_speed.w = goal_omega_left;

  //speed_pub.publish(&wheel_speed);
}
    3026:	b009      	add	sp, #36	; 0x24
    3028:	ecbd 8b04 	vpop	{d8-d9}
    302c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (tele_op == 100){
    RGB_led_set("red");
  }
  if (tele_op == 0 || tele_op == 1){//keyboard tele-op or PS4 controller tele-op
    if (tele_op == 0){ //keyboard tele-op setting indicator color
      RGB_led_set("purple");
    3030:	a804      	add	r0, sp, #16
    3032:	491c      	ldr	r1, [pc, #112]	; (30a4 <wheel_speed_set(double, double, int)+0x2a4>)
    3034:	e702      	b.n	2e3c <wheel_speed_set(double, double, int)+0x3c>
void wheel_speed_set(double input_vel_x, double input_omega, int tele_op){
  double vel_x_goal;
  double goal_omega;

  if (tele_op == 100){
    RGB_led_set("red");
    3036:	491c      	ldr	r1, [pc, #112]	; (30a8 <wheel_speed_set(double, double, int)+0x2a8>)
    3038:	a804      	add	r0, sp, #16
    303a:	f004 fa25 	bl	7488 <String::String(char const*)>
    303e:	a804      	add	r0, sp, #16
    3040:	f7ff fda6 	bl	2b90 <RGB_led_set(String const&)>
    3044:	a804      	add	r0, sp, #16
    3046:	f004 f9df 	bl	7408 <String::~String()>
  //wheel_speed.y = goal_omega;
  //wheel_speed.z = goal_omega_right;
  //wheel_speed.w = goal_omega_left;

  //speed_pub.publish(&wheel_speed);
}
    304a:	b009      	add	sp, #36	; 0x24
    304c:	ecbd 8b04 	vpop	{d8-d9}
    3050:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3054:	f3af 8000 	nop.w
    3058:	00000000 	.word	0x00000000
    305c:	4052c000 	.word	0x4052c000
    3060:	00000000 	.word	0x00000000
    3064:	406fe000 	.word	0x406fe000
    3068:	0000ab3c 	.word	0x0000ab3c
    306c:	40490000 	.word	0x40490000
    3070:	40590000 	.word	0x40590000
    3074:	1fff1d80 	.word	0x1fff1d80
    3078:	1fff1d68 	.word	0x1fff1d68
    307c:	0000ab24 	.word	0x0000ab24
    3080:	1fff0814 	.word	0x1fff0814
    3084:	1fff0810 	.word	0x1fff0810
    3088:	1fff2b38 	.word	0x1fff2b38
    308c:	1fff2b30 	.word	0x1fff2b30
    3090:	402e0000 	.word	0x402e0000
    3094:	1fff1cb8 	.word	0x1fff1cb8
    3098:	1fff1480 	.word	0x1fff1480
    309c:	1fff148c 	.word	0x1fff148c
    30a0:	1fff1d78 	.word	0x1fff1d78
    30a4:	0000ab6c 	.word	0x0000ab6c
    30a8:	0000ab18 	.word	0x0000ab18
    30ac:	1fff2b10 	.word	0x1fff2b10
    30b0:	1fff1498 	.word	0x1fff1498

000030b4 <cmd_velocity(geometry_msgs::Twist&)>:
  if (hi == 0){
    RGB_led_set("red");
  }
}

void cmd_velocity(geometry_msgs::Twist& cmd_goal) {
    30b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    30b6:	4604      	mov	r4, r0
  double goal_vel_x = cmd_goal.linear.x;
    30b8:	6880      	ldr	r0, [r0, #8]
    30ba:	f005 fe4d 	bl	8d58 <__aeabi_f2d>
    30be:	4606      	mov	r6, r0
  double goal_omega = cmd_goal.angular.z;
    30c0:	6a20      	ldr	r0, [r4, #32]
    RGB_led_set("red");
  }
}

void cmd_velocity(geometry_msgs::Twist& cmd_goal) {
  double goal_vel_x = cmd_goal.linear.x;
    30c2:	460f      	mov	r7, r1
  double goal_omega = cmd_goal.angular.z;
    30c4:	f005 fe48 	bl	8d58 <__aeabi_f2d>
  if (cmd_goal.angular.x == 0){ // here if this is true that means that the robot is being teleoperated
    30c8:	edd4 7a06 	vldr	s15, [r4, #24]
    30cc:	eef5 7a40 	vcmp.f32	s15, #0.0
    30d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  }
}

void cmd_velocity(geometry_msgs::Twist& cmd_goal) {
  double goal_vel_x = cmd_goal.linear.x;
  double goal_omega = cmd_goal.angular.z;
    30d4:	460b      	mov	r3, r1
  if (cmd_goal.angular.x == 0){ // here if this is true that means that the robot is being teleoperated
    bool_tele_op_toggel = 0;
  }
  if (cmd_goal.angular.x == 5){
    30d6:	eeb1 7a04 	vmov.f32	s14, #20	; 0x40a00000  5.0

void cmd_velocity(geometry_msgs::Twist& cmd_goal) {
  double goal_vel_x = cmd_goal.linear.x;
  double goal_omega = cmd_goal.angular.z;
  if (cmd_goal.angular.x == 0){ // here if this is true that means that the robot is being teleoperated
    bool_tele_op_toggel = 0;
    30da:	4922      	ldr	r1, [pc, #136]	; (3164 <cmd_velocity(geometry_msgs::Twist&)+0xb0>)
  }
}

void cmd_velocity(geometry_msgs::Twist& cmd_goal) {
  double goal_vel_x = cmd_goal.linear.x;
  double goal_omega = cmd_goal.angular.z;
    30dc:	4602      	mov	r2, r0
  if (cmd_goal.angular.x == 0){ // here if this is true that means that the robot is being teleoperated
    bool_tele_op_toggel = 0;
  }
  if (cmd_goal.angular.x == 5){
    30de:	eef4 7a47 	vcmp.f32	s15, s14

void cmd_velocity(geometry_msgs::Twist& cmd_goal) {
  double goal_vel_x = cmd_goal.linear.x;
  double goal_omega = cmd_goal.angular.z;
  if (cmd_goal.angular.x == 0){ // here if this is true that means that the robot is being teleoperated
    bool_tele_op_toggel = 0;
    30e2:	bf04      	itt	eq
    30e4:	2000      	moveq	r0, #0
    30e6:	6008      	streq	r0, [r1, #0]
  }
  if (cmd_goal.angular.x == 5){
    30e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    30ec:	d10f      	bne.n	310e <cmd_velocity(geometry_msgs::Twist&)+0x5a>
    bool_tele_op_toggel = 1;
    goal_omega = cmd_goal.linear.y;
    30ee:	68e0      	ldr	r0, [r4, #12]
  double goal_omega = cmd_goal.angular.z;
  if (cmd_goal.angular.x == 0){ // here if this is true that means that the robot is being teleoperated
    bool_tele_op_toggel = 0;
  }
  if (cmd_goal.angular.x == 5){
    bool_tele_op_toggel = 1;
    30f0:	2401      	movs	r4, #1
    30f2:	600c      	str	r4, [r1, #0]
    goal_omega = cmd_goal.linear.y;
    30f4:	f005 fe30 	bl	8d58 <__aeabi_f2d>
    30f8:	4602      	mov	r2, r0
    30fa:	460b      	mov	r3, r1
    30fc:	4620      	mov	r0, r4
    bool_tele_op_toggel = 100;
  }
  //if(tele_op_toggel == 0.5 || tele_op_toggel == -0.5){
  //  bool_tele_op_toggel = !bool_tele_op_toggel;
  //}
  wheel_speed_set(goal_vel_x, goal_omega, bool_tele_op_toggel);
    30fe:	ec43 2b11 	vmov	d1, r2, r3
    3102:	ec47 6b10 	vmov	d0, r6, r7
}
    3106:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    bool_tele_op_toggel = 100;
  }
  //if(tele_op_toggel == 0.5 || tele_op_toggel == -0.5){
  //  bool_tele_op_toggel = !bool_tele_op_toggel;
  //}
  wheel_speed_set(goal_vel_x, goal_omega, bool_tele_op_toggel);
    310a:	f7ff be79 	b.w	2e00 <wheel_speed_set(double, double, int)>
  }
  if (cmd_goal.angular.x == 5){
    bool_tele_op_toggel = 1;
    goal_omega = cmd_goal.linear.y;
  }
  if (cmd_goal.angular.x == 90){
    310e:	ed9f 7a16 	vldr	s14, [pc, #88]	; 3168 <cmd_velocity(geometry_msgs::Twist&)+0xb4>
    3112:	eef4 7a47 	vcmp.f32	s15, s14
    3116:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    311a:	d010      	beq.n	313e <cmd_velocity(geometry_msgs::Twist&)+0x8a>
    bool_tele_op_toggel = 2;
    cum_error_r = 0;
    cum_error_l = 0;
  }
  else if (cmd_goal.angular.x != 0 && cmd_goal.angular.x != 5 && cmd_goal.angular.x != 90){
    311c:	eef5 7a40 	vcmp.f32	s15, #0.0
    3120:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    bool_tele_op_toggel = 100;
    3124:	bf18      	it	ne
    3126:	2064      	movne	r0, #100	; 0x64
  }
  //if(tele_op_toggel == 0.5 || tele_op_toggel == -0.5){
  //  bool_tele_op_toggel = !bool_tele_op_toggel;
  //}
  wheel_speed_set(goal_vel_x, goal_omega, bool_tele_op_toggel);
    3128:	ec43 2b11 	vmov	d1, r2, r3
    312c:	ec47 6b10 	vmov	d0, r6, r7
    3130:	bf0c      	ite	eq
    3132:	6808      	ldreq	r0, [r1, #0]
    bool_tele_op_toggel = 2;
    cum_error_r = 0;
    cum_error_l = 0;
  }
  else if (cmd_goal.angular.x != 0 && cmd_goal.angular.x != 5 && cmd_goal.angular.x != 90){
    bool_tele_op_toggel = 100;
    3134:	6008      	strne	r0, [r1, #0]
  }
  //if(tele_op_toggel == 0.5 || tele_op_toggel == -0.5){
  //  bool_tele_op_toggel = !bool_tele_op_toggel;
  //}
  wheel_speed_set(goal_vel_x, goal_omega, bool_tele_op_toggel);
}
    3136:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    bool_tele_op_toggel = 100;
  }
  //if(tele_op_toggel == 0.5 || tele_op_toggel == -0.5){
  //  bool_tele_op_toggel = !bool_tele_op_toggel;
  //}
  wheel_speed_set(goal_vel_x, goal_omega, bool_tele_op_toggel);
    313a:	f7ff be61 	b.w	2e00 <wheel_speed_set(double, double, int)>
    bool_tele_op_toggel = 1;
    goal_omega = cmd_goal.linear.y;
  }
  if (cmd_goal.angular.x == 90){
    bool_tele_op_toggel = 2;
    cum_error_r = 0;
    313e:	480b      	ldr	r0, [pc, #44]	; (316c <cmd_velocity(geometry_msgs::Twist&)+0xb8>)
    cum_error_l = 0;
    3140:	f8df e02c 	ldr.w	lr, [pc, #44]	; 3170 <cmd_velocity(geometry_msgs::Twist&)+0xbc>
    bool_tele_op_toggel = 1;
    goal_omega = cmd_goal.linear.y;
  }
  if (cmd_goal.angular.x == 90){
    bool_tele_op_toggel = 2;
    cum_error_r = 0;
    3144:	2400      	movs	r4, #0
    3146:	2500      	movs	r5, #0
    3148:	e9c0 4500 	strd	r4, r5, [r0]
    cum_error_l = 0;
    314c:	e9ce 4500 	strd	r4, r5, [lr]
  if (cmd_goal.angular.x == 5){
    bool_tele_op_toggel = 1;
    goal_omega = cmd_goal.linear.y;
  }
  if (cmd_goal.angular.x == 90){
    bool_tele_op_toggel = 2;
    3150:	2002      	movs	r0, #2
    bool_tele_op_toggel = 100;
  }
  //if(tele_op_toggel == 0.5 || tele_op_toggel == -0.5){
  //  bool_tele_op_toggel = !bool_tele_op_toggel;
  //}
  wheel_speed_set(goal_vel_x, goal_omega, bool_tele_op_toggel);
    3152:	ec43 2b11 	vmov	d1, r2, r3
    3156:	ec47 6b10 	vmov	d0, r6, r7
}
    315a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  if (cmd_goal.angular.x == 5){
    bool_tele_op_toggel = 1;
    goal_omega = cmd_goal.linear.y;
  }
  if (cmd_goal.angular.x == 90){
    bool_tele_op_toggel = 2;
    315e:	6008      	str	r0, [r1, #0]
    bool_tele_op_toggel = 100;
  }
  //if(tele_op_toggel == 0.5 || tele_op_toggel == -0.5){
  //  bool_tele_op_toggel = !bool_tele_op_toggel;
  //}
  wheel_speed_set(goal_vel_x, goal_omega, bool_tele_op_toggel);
    3160:	f7ff be4e 	b.w	2e00 <wheel_speed_set(double, double, int)>
    3164:	1fff1ccc 	.word	0x1fff1ccc
    3168:	42b40000 	.word	0x42b40000
    316c:	1fff2ad0 	.word	0x1fff2ad0
    3170:	1fff2a98 	.word	0x1fff2a98

00003174 <setup>:

// Subscribers //
ros::Subscriber<geometry_msgs::Twist> sub_cmd_vel("cmd_vel", &cmd_velocity);
ros::Subscriber<std_msgs::Int16> start_up("stat_up_done", &start_up_hi);

void setup() {
    3174:	b530      	push	{r4, r5, lr}

  /* Start serial, initialize buffers */
  void initNode()
  {
    hardware_.init();
    mode_ = 0;
    3176:	4d68      	ldr	r5, [pc, #416]	; (3318 <setup+0x1a4>)
    3178:	b085      	sub	sp, #20
    317a:	2400      	movs	r4, #0
  nh.initNode();
  pinMode(RGB_led_green, OUTPUT);
    317c:	2101      	movs	r1, #1
    317e:	2002      	movs	r0, #2
    3180:	f8c5 44e4 	str.w	r4, [r5, #1252]	; 0x4e4
    bytes_ = 0;
    3184:	f8c5 44e8 	str.w	r4, [r5, #1256]	; 0x4e8
    index_ = 0;
    3188:	f8c5 44f0 	str.w	r4, [r5, #1264]	; 0x4f0
    topic_ = 0;
    318c:	f8c5 44ec 	str.w	r4, [r5, #1260]	; 0x4ec
    3190:	f003 f8d8 	bl	6344 <pinMode>
  pinMode(RGB_led_blue, OUTPUT);
    3194:	2101      	movs	r1, #1
    3196:	2003      	movs	r0, #3
    3198:	f003 f8d4 	bl	6344 <pinMode>
  pinMode(RGB_led_red, OUTPUT);
    319c:	2101      	movs	r1, #1
    319e:	2004      	movs	r0, #4
    31a0:	f003 f8d0 	bl	6344 <pinMode>
  RGB_led_set("white");
    31a4:	495d      	ldr	r1, [pc, #372]	; (331c <setup+0x1a8>)
    31a6:	4668      	mov	r0, sp
    31a8:	f004 f96e 	bl	7488 <String::String(char const*)>
    31ac:	4668      	mov	r0, sp
    31ae:	f7ff fcef 	bl	2b90 <RGB_led_set(String const&)>
    31b2:	4668      	mov	r0, sp
    31b4:	f004 f928 	bl	7408 <String::~String()>
  pinMode(right_motor_pwm, OUTPUT);
    31b8:	2101      	movs	r1, #1
    31ba:	201d      	movs	r0, #29
    31bc:	f003 f8c2 	bl	6344 <pinMode>
  pinMode(right_motor_ina, OUTPUT);
    31c0:	2101      	movs	r1, #1
    31c2:	201e      	movs	r0, #30
    31c4:	f003 f8be 	bl	6344 <pinMode>
  pinMode(right_motor_inb, OUTPUT);
    31c8:	2101      	movs	r1, #1
    31ca:	201c      	movs	r0, #28
    31cc:	f003 f8ba 	bl	6344 <pinMode>
  pinMode(right_encoder_a, INPUT_PULLUP);
    31d0:	2102      	movs	r1, #2
    31d2:	2018      	movs	r0, #24
    31d4:	f003 f8b6 	bl	6344 <pinMode>
  pinMode(right_encoder_b, INPUT_PULLUP);
    31d8:	2102      	movs	r1, #2
    31da:	2019      	movs	r0, #25
    31dc:	f003 f8b2 	bl	6344 <pinMode>
  pinMode(left_motor_pwm, OUTPUT);
    31e0:	2101      	movs	r1, #1
    31e2:	2026      	movs	r0, #38	; 0x26
    31e4:	f003 f8ae 	bl	6344 <pinMode>
  pinMode(left_motor_ina, OUTPUT);
    31e8:	2101      	movs	r1, #1
    31ea:	2027      	movs	r0, #39	; 0x27
    31ec:	f003 f8aa 	bl	6344 <pinMode>
  pinMode(left_motor_inb, OUTPUT);
    31f0:	2101      	movs	r1, #1
    31f2:	2025      	movs	r0, #37	; 0x25
    31f4:	f003 f8a6 	bl	6344 <pinMode>
  pinMode(left_encoder_a, INPUT_PULLUP);
    31f8:	2102      	movs	r1, #2
    31fa:	2021      	movs	r0, #33	; 0x21
    31fc:	f003 f8a2 	bl	6344 <pinMode>
  pinMode(left_encoder_b, INPUT_PULLUP);
    3200:	2102      	movs	r1, #2
    3202:	2022      	movs	r0, #34	; 0x22
    3204:	f003 f89e 	bl	6344 <pinMode>
  attachInterrupt(digitalPinToInterrupt(right_encoder_a), encoder_count_chage_right, CHANGE);
    3208:	2204      	movs	r2, #4
    320a:	4945      	ldr	r1, [pc, #276]	; (3320 <setup+0x1ac>)
    320c:	2018      	movs	r0, #24
    320e:	f002 fe65 	bl	5edc <attachInterrupt>
  attachInterrupt(digitalPinToInterrupt(right_encoder_b), encoder_count_chage_right, CHANGE);
    3212:	2204      	movs	r2, #4
    3214:	4942      	ldr	r1, [pc, #264]	; (3320 <setup+0x1ac>)
    3216:	2019      	movs	r0, #25
    3218:	f002 fe60 	bl	5edc <attachInterrupt>
  attachInterrupt(digitalPinToInterrupt(left_encoder_a), encoder_count_chage_left, CHANGE);
    321c:	2204      	movs	r2, #4
    321e:	4941      	ldr	r1, [pc, #260]	; (3324 <setup+0x1b0>)
    3220:	2021      	movs	r0, #33	; 0x21
    3222:	f002 fe5b 	bl	5edc <attachInterrupt>
  attachInterrupt(digitalPinToInterrupt(left_encoder_b), encoder_count_chage_left, CHANGE);
    3226:	2204      	movs	r2, #4
    3228:	493e      	ldr	r1, [pc, #248]	; (3324 <setup+0x1b0>)
    322a:	2022      	movs	r0, #34	; 0x22
    322c:	f002 fe56 	bl	5edc <attachInterrupt>
    3230:	f205 427c 	addw	r2, r5, #1148	; 0x47c
  }

  /* Register a new subscriber */
  bool subscribe(Subscriber_& s)
  {
    for (int i = 0; i < MAX_SUBSCRIBERS; i++)
    3234:	4623      	mov	r3, r4
    3236:	4611      	mov	r1, r2
    3238:	e002      	b.n	3240 <setup+0xcc>
    323a:	3301      	adds	r3, #1
    323c:	2b19      	cmp	r3, #25
    323e:	d00a      	beq.n	3256 <setup+0xe2>
    {
      if (subscribers[i] == 0) // empty slot
    3240:	f851 0f04 	ldr.w	r0, [r1, #4]!
    3244:	2800      	cmp	r0, #0
    3246:	d1f8      	bne.n	323a <setup+0xc6>
      {
        subscribers[i] = &s;
    3248:	f503 7090 	add.w	r0, r3, #288	; 0x120
    324c:	4936      	ldr	r1, [pc, #216]	; (3328 <setup+0x1b4>)
    324e:	f845 1020 	str.w	r1, [r5, r0, lsl #2]
        s.id_ = i + 100;
    3252:	3364      	adds	r3, #100	; 0x64
    3254:	604b      	str	r3, [r1, #4]
  }

  /* Register a new subscriber */
  bool subscribe(Subscriber_& s)
  {
    for (int i = 0; i < MAX_SUBSCRIBERS; i++)
    3256:	2300      	movs	r3, #0
    3258:	e002      	b.n	3260 <setup+0xec>
    325a:	3301      	adds	r3, #1
    325c:	2b19      	cmp	r3, #25
    325e:	d00a      	beq.n	3276 <setup+0x102>
    {
      if (subscribers[i] == 0) // empty slot
    3260:	f852 1f04 	ldr.w	r1, [r2, #4]!
    3264:	2900      	cmp	r1, #0
    3266:	d1f8      	bne.n	325a <setup+0xe6>
      {
        subscribers[i] = &s;
    3268:	f503 7190 	add.w	r1, r3, #288	; 0x120
    326c:	4a2f      	ldr	r2, [pc, #188]	; (332c <setup+0x1b8>)
    326e:	f845 2021 	str.w	r2, [r5, r1, lsl #2]
        s.id_ = i + 100;
    3272:	3364      	adds	r3, #100	; 0x64
    3274:	6053      	str	r3, [r2, #4]
    3276:	4a2e      	ldr	r2, [pc, #184]	; (3330 <setup+0x1bc>)
   */

  /* Register a new publisher */
  bool advertise(Publisher & p)
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    3278:	2300      	movs	r3, #0
  }

  /* Register a new subscriber */
  bool subscribe(Subscriber_& s)
  {
    for (int i = 0; i < MAX_SUBSCRIBERS; i++)
    327a:	4611      	mov	r1, r2
    327c:	e002      	b.n	3284 <setup+0x110>
   */

  /* Register a new publisher */
  bool advertise(Publisher & p)
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    327e:	3301      	adds	r3, #1
    3280:	2b19      	cmp	r3, #25
    3282:	d00b      	beq.n	329c <setup+0x128>
    {
      if (publishers[i] == 0) // empty slot
    3284:	f851 0f04 	ldr.w	r0, [r1, #4]!
    3288:	2800      	cmp	r0, #0
    328a:	d1f8      	bne.n	327e <setup+0x10a>
      {
        publishers[i] = &p;
    328c:	4929      	ldr	r1, [pc, #164]	; (3334 <setup+0x1c0>)
    328e:	eb05 0083 	add.w	r0, r5, r3, lsl #2
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    3292:	337d      	adds	r3, #125	; 0x7d
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] == 0) // empty slot
      {
        publishers[i] = &p;
    3294:	f8c0 141c 	str.w	r1, [r0, #1052]	; 0x41c
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    3298:	608b      	str	r3, [r1, #8]
        p.nh_ = this;
    329a:	60cd      	str	r5, [r1, #12]
   */

  /* Register a new publisher */
  bool advertise(Publisher & p)
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    329c:	4924      	ldr	r1, [pc, #144]	; (3330 <setup+0x1bc>)
    329e:	2300      	movs	r3, #0
    32a0:	e002      	b.n	32a8 <setup+0x134>
    32a2:	3301      	adds	r3, #1
    32a4:	2b19      	cmp	r3, #25
    32a6:	d00b      	beq.n	32c0 <setup+0x14c>
    {
      if (publishers[i] == 0) // empty slot
    32a8:	f851 0f04 	ldr.w	r0, [r1, #4]!
    32ac:	2800      	cmp	r0, #0
    32ae:	d1f8      	bne.n	32a2 <setup+0x12e>
      {
        publishers[i] = &p;
    32b0:	4921      	ldr	r1, [pc, #132]	; (3338 <setup+0x1c4>)
    32b2:	eb05 0083 	add.w	r0, r5, r3, lsl #2
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    32b6:	337d      	adds	r3, #125	; 0x7d
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] == 0) // empty slot
      {
        publishers[i] = &p;
    32b8:	f8c0 141c 	str.w	r1, [r0, #1052]	; 0x41c
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    32bc:	608b      	str	r3, [r1, #8]
        p.nh_ = this;
    32be:	60cd      	str	r5, [r1, #12]
   */

  /* Register a new publisher */
  bool advertise(Publisher & p)
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    32c0:	491b      	ldr	r1, [pc, #108]	; (3330 <setup+0x1bc>)
    32c2:	2300      	movs	r3, #0
    32c4:	e002      	b.n	32cc <setup+0x158>
    32c6:	3301      	adds	r3, #1
    32c8:	2b19      	cmp	r3, #25
    32ca:	d00b      	beq.n	32e4 <setup+0x170>
    {
      if (publishers[i] == 0) // empty slot
    32cc:	f851 0f04 	ldr.w	r0, [r1, #4]!
    32d0:	2800      	cmp	r0, #0
    32d2:	d1f8      	bne.n	32c6 <setup+0x152>
      {
        publishers[i] = &p;
    32d4:	4919      	ldr	r1, [pc, #100]	; (333c <setup+0x1c8>)
    32d6:	eb05 0083 	add.w	r0, r5, r3, lsl #2
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    32da:	337d      	adds	r3, #125	; 0x7d
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] == 0) // empty slot
      {
        publishers[i] = &p;
    32dc:	f8c0 141c 	str.w	r1, [r0, #1052]	; 0x41c
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    32e0:	608b      	str	r3, [r1, #8]
        p.nh_ = this;
    32e2:	60cd      	str	r5, [r1, #12]
   */

  /* Register a new publisher */
  bool advertise(Publisher & p)
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    32e4:	2300      	movs	r3, #0
    32e6:	e002      	b.n	32ee <setup+0x17a>
    32e8:	3301      	adds	r3, #1
    32ea:	2b19      	cmp	r3, #25
    32ec:	d00b      	beq.n	3306 <setup+0x192>
    {
      if (publishers[i] == 0) // empty slot
    32ee:	f852 1f04 	ldr.w	r1, [r2, #4]!
    32f2:	2900      	cmp	r1, #0
    32f4:	d1f8      	bne.n	32e8 <setup+0x174>
      {
        publishers[i] = &p;
    32f6:	4a12      	ldr	r2, [pc, #72]	; (3340 <setup+0x1cc>)
    32f8:	eb05 0183 	add.w	r1, r5, r3, lsl #2
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    32fc:	337d      	adds	r3, #125	; 0x7d
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] == 0) // empty slot
      {
        publishers[i] = &p;
    32fe:	f8c1 241c 	str.w	r2, [r1, #1052]	; 0x41c
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    3302:	6093      	str	r3, [r2, #8]
        p.nh_ = this;
    3304:	60d5      	str	r5, [r2, #12]
  nh.advertise(IMU_data_gyro);
  nh.advertise(IMU_data_mag);
  //nh.advertise(measured_angle_pub);


  Wire.begin();
    3306:	480f      	ldr	r0, [pc, #60]	; (3344 <setup+0x1d0>)
    3308:	f002 f8f2 	bl	54f0 <TwoWire::begin()>
  //Wire.beginTransmission(MPU_addr);
  //Wire.write(0x6B);  // PWR_MGMT_1 register
  //Wire.write(0);     // set to zero (wakes up the MPU-6050)
  //Wire.endTransmission(true);
  accelgyro.initialize();
    330c:	480e      	ldr	r0, [pc, #56]	; (3348 <setup+0x1d4>)
    330e:	f002 fbf9 	bl	5b04 <MPU9250::initialize()>


}
    3312:	b005      	add	sp, #20
    3314:	bd30      	pop	{r4, r5, pc}
    3316:	bf00      	nop
    3318:	1fff1d88 	.word	0x1fff1d88
    331c:	0000abb4 	.word	0x0000abb4
    3320:	00000739 	.word	0x00000739
    3324:	000008b9 	.word	0x000008b9
    3328:	1fff1ce4 	.word	0x1fff1ce4
    332c:	1fff2ab4 	.word	0x1fff2ab4
    3330:	1fff21a0 	.word	0x1fff21a0
    3334:	1fff1d4c 	.word	0x1fff1d4c
    3338:	1fff1ca4 	.word	0x1fff1ca4
    333c:	1fff1d24 	.word	0x1fff1d24
    3340:	1fff1d38 	.word	0x1fff1d38
    3344:	1fff0894 	.word	0x1fff0894
    3348:	1fff1c80 	.word	0x1fff1c80
    334c:	ffffffff 	.word	0xffffffff

00003350 <loop>:

void loop() {
    3350:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if(bool_tele_op_toggel == 2){
    3354:	4bc6      	ldr	r3, [pc, #792]	; (3670 <loop+0x320>)
  accelgyro.initialize();


}

void loop() {
    3356:	ed2d 8b04 	vpush	{d8-d9}
  if(bool_tele_op_toggel == 2){
    335a:	681b      	ldr	r3, [r3, #0]
    335c:	2b02      	cmp	r3, #2
  accelgyro.initialize();


}

void loop() {
    335e:	b095      	sub	sp, #84	; 0x54
  if(bool_tele_op_toggel == 2){
    3360:	f000 82e5 	beq.w	392e <loop+0x5de>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3364:	4fc3      	ldr	r7, [pc, #780]	; (3674 <loop+0x324>)
    previous_time = current_time;
    last_error_right = goal_omega_right - average_omega_right;
    last_error_left = goal_omega_left - average_omega_left;
  }

  if(millis() > time_now + period){
    3366:	49c4      	ldr	r1, [pc, #784]	; (3678 <loop+0x328>)
    3368:	4bc4      	ldr	r3, [pc, #784]	; (367c <loop+0x32c>)
    336a:	683a      	ldr	r2, [r7, #0]
    336c:	9207      	str	r2, [sp, #28]
    336e:	6808      	ldr	r0, [r1, #0]
    3370:	681b      	ldr	r3, [r3, #0]
	return ret;
    3372:	9a07      	ldr	r2, [sp, #28]
    3374:	4403      	add	r3, r0
    3376:	4293      	cmp	r3, r2
    3378:	f0c0 818c 	bcc.w	3694 <loop+0x344>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    337c:	683b      	ldr	r3, [r7, #0]

  virtual int spinOnce() override
  {
    /* restart if timed out */
    uint32_t c_time = hardware_.time();
    if ((c_time - last_sync_receive_time) > (SYNC_SECONDS * 2200))
    337e:	4cc0      	ldr	r4, [pc, #768]	; (3680 <loop+0x330>)
    3380:	9309      	str	r3, [sp, #36]	; 0x24
	return ret;
    3382:	9e09      	ldr	r6, [sp, #36]	; 0x24
    3384:	f8d4 3500 	ldr.w	r3, [r4, #1280]	; 0x500
    3388:	f642 22f8 	movw	r2, #11000	; 0x2af8
    338c:	1af3      	subs	r3, r6, r3
    338e:	4293      	cmp	r3, r2
    {
      configured_ = false;
    3390:	bf84      	itt	hi
    3392:	2300      	movhi	r3, #0
    3394:	f884 34f8 	strbhi.w	r3, [r4, #1272]	; 0x4f8
    }

    /* reset if message has timed out */
    if (mode_ != MODE_FIRST_FF)
    3398:	f8d4 34e4 	ldr.w	r3, [r4, #1252]	; 0x4e4
    339c:	4ab8      	ldr	r2, [pc, #736]	; (3680 <loop+0x330>)
    339e:	b133      	cbz	r3, 33ae <loop+0x5e>
    {
      if (c_time > last_msg_timeout_time)
    33a0:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
    33a4:	429e      	cmp	r6, r3
      {
        mode_ = MODE_FIRST_FF;
    33a6:	bf84      	itt	hi
    33a8:	2300      	movhi	r3, #0
    33aa:	f8c2 34e4 	strhi.w	r3, [r2, #1252]	; 0x4e4
    33ae:	f8df 82e0 	ldr.w	r8, [pc, #736]	; 3690 <loop+0x340>
        }
      }
      int data = hardware_.read();
      if (data < 0)
        break;
      checksum_ += data;
    33b2:	4db3      	ldr	r5, [pc, #716]	; (3680 <loop+0x330>)

    /* while available buffer, read data */
    while (true)
    {
      // If a timeout has been specified, check how long spinOnce has been running.
      if (spin_timeout_ > 0)
    33b4:	69a2      	ldr	r2, [r4, #24]
    33b6:	b12a      	cbz	r2, 33c4 <loop+0x74>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    33b8:	683b      	ldr	r3, [r7, #0]
    33ba:	930d      	str	r3, [sp, #52]	; 0x34
	return ret;
    33bc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
      {
        // If the maximum processing timeout has been exceeded, exit with error.
        // The next spinOnce can continue where it left off, or optionally
        // based on the application in use, the hardware buffer could be flushed
        // and start fresh.
        if ((hardware_.time() - c_time) > spin_timeout_)
    33be:	1b9b      	subs	r3, r3, r6
    33c0:	429a      	cmp	r2, r3
    33c2:	d321      	bcc.n	3408 <loop+0xb8>
    33c4:	6860      	ldr	r0, [r4, #4]
      delay(3000); 
#endif
      iostream->begin(baud_);
    }

    int read(){return iostream->read();};
    33c6:	6803      	ldr	r3, [r0, #0]
    33c8:	695b      	ldr	r3, [r3, #20]
    33ca:	4543      	cmp	r3, r8
    33cc:	d16c      	bne.n	34a8 <loop+0x158>
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    33ce:	f003 fe85 	bl	70dc <usb_serial_getchar>
          // Exit the spin, processing timeout exceeded.
          return SPIN_TIMEOUT;
        }
      }
      int data = hardware_.read();
      if (data < 0)
    33d2:	2800      	cmp	r0, #0
    33d4:	db6b      	blt.n	34ae <loop+0x15e>
        break;
      checksum_ += data;
    33d6:	f8d4 34f4 	ldr.w	r3, [r4, #1268]	; 0x4f4
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    33da:	f8d4 24e4 	ldr.w	r2, [r4, #1252]	; 0x4e4
        }
      }
      int data = hardware_.read();
      if (data < 0)
        break;
      checksum_ += data;
    33de:	f8df e2a0 	ldr.w	lr, [pc, #672]	; 3680 <loop+0x330>
    33e2:	4403      	add	r3, r0
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    33e4:	2a07      	cmp	r2, #7
        }
      }
      int data = hardware_.read();
      if (data < 0)
        break;
      checksum_ += data;
    33e6:	f8c4 34f4 	str.w	r3, [r4, #1268]	; 0x4f4
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    33ea:	d04b      	beq.n	3484 <loop+0x134>
        message_in[index_++] = data;
        bytes_--;
        if (bytes_ == 0)                 /* is message complete? if so, checksum */
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_FIRST_FF)
    33ec:	b98a      	cbnz	r2, 3412 <loop+0xc2>
      {
        if (data == 0xff)
    33ee:	28ff      	cmp	r0, #255	; 0xff
    33f0:	f000 80b0 	beq.w	3554 <loop+0x204>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    33f4:	683b      	ldr	r3, [r7, #0]
    33f6:	930c      	str	r3, [sp, #48]	; 0x30
	return ret;
    33f8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
        {
          mode_++;
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
        }
        else if (hardware_.time() - c_time > (SYNC_SECONDS * 1000))
    33fa:	f241 3188 	movw	r1, #5000	; 0x1388
    33fe:	1b9b      	subs	r3, r3, r6
    3400:	428b      	cmp	r3, r1
    3402:	d9d7      	bls.n	33b4 <loop+0x64>
        {
          /* We have been stuck in spinOnce too long, return error */
          configured_ = false;
    3404:	f88e 24f8 	strb.w	r2, [lr, #1272]	; 0x4f8
    speed_pub.publish(&wheel_speed);
  }
  nh.spinOnce();
  //}
  //delay(100);
  }
    3408:	b015      	add	sp, #84	; 0x54
    340a:	ecbd 8b04 	vpop	{d8-d9}
    340e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          return SPIN_TIMEOUT;
        }
      }
      else if (mode_ == MODE_PROTOCOL_VER)
    3412:	2a01      	cmp	r2, #1
    3414:	f000 80a6 	beq.w	3564 <loop+0x214>
          mode_ = MODE_FIRST_FF;
          if (configured_ == false)
            requestSyncTime();  /* send a msg back showing our protocol version */
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
    3418:	2a02      	cmp	r2, #2
    341a:	f000 80ed 	beq.w	35f8 <loop+0x2a8>
        bytes_ = data;
        index_ = 0;
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
    341e:	2a03      	cmp	r2, #3
    3420:	f000 80f5 	beq.w	360e <loop+0x2be>
      {
        bytes_ += data << 8;
        mode_++;
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
    3424:	2a04      	cmp	r2, #4
    3426:	f000 80fc 	beq.w	3622 <loop+0x2d2>
        if ((checksum_ % 256) == 255)
          mode_++;
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
    342a:	2a05      	cmp	r2, #5
    342c:	f000 8109 	beq.w	3642 <loop+0x2f2>
      {
        topic_ = data;
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
    3430:	2a06      	cmp	r2, #6
    3432:	f000 810e 	beq.w	3652 <loop+0x302>
        topic_ += data << 8;
        mode_ = MODE_MESSAGE;
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
    3436:	2a08      	cmp	r2, #8
    3438:	d1bc      	bne.n	33b4 <loop+0x64>
      {
        mode_ = MODE_FIRST_FF;
        if ((checksum_ % 256) == 255)
    343a:	4a92      	ldr	r2, [pc, #584]	; (3684 <loop+0x334>)
    343c:	401a      	ands	r2, r3
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
    343e:	2300      	movs	r3, #0
        if ((checksum_ % 256) == 255)
    3440:	429a      	cmp	r2, r3
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
    3442:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
        if ((checksum_ % 256) == 255)
    3446:	f2c0 8384 	blt.w	3b52 <loop+0x802>
    344a:	2aff      	cmp	r2, #255	; 0xff
    344c:	d1b2      	bne.n	33b4 <loop+0x64>
        {
          if (topic_ == TopicInfo::ID_PUBLISHER)
    344e:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
    3452:	f8df a22c 	ldr.w	sl, [pc, #556]	; 3680 <loop+0x330>
    3456:	2b00      	cmp	r3, #0
    3458:	f000 84f9 	beq.w	3e4e <loop+0xafe>
            negotiateTopics();
            last_sync_time = c_time;
            last_sync_receive_time = c_time;
            return SPIN_ERR;
          }
          else if (topic_ == TopicInfo::ID_TIME)
    345c:	2b0a      	cmp	r3, #10
    345e:	f000 8399 	beq.w	3b94 <loop+0x844>
          {
            syncTime(message_in);
          }
          else if (topic_ == TopicInfo::ID_PARAMETER_REQUEST)
    3462:	2b06      	cmp	r3, #6
    3464:	f000 83cc 	beq.w	3c00 <loop+0x8b0>
          {
            req_param_resp.deserialize(message_in);
            param_received = true;
          }
          else if (topic_ == TopicInfo::ID_TX_STOP)
    3468:	2b0b      	cmp	r3, #11
    346a:	f000 838f 	beq.w	3b8c <loop+0x83c>
          {
            configured_ = false;
          }
          else
          {
            if (subscribers[topic_ - 100])
    346e:	33bc      	adds	r3, #188	; 0xbc
    3470:	f855 0023 	ldr.w	r0, [r5, r3, lsl #2]
    3474:	2800      	cmp	r0, #0
    3476:	d09d      	beq.n	33b4 <loop+0x64>
              subscribers[topic_ - 100]->callback(message_in);
    3478:	6803      	ldr	r3, [r0, #0]
    347a:	f10a 011c 	add.w	r1, sl, #28
    347e:	681b      	ldr	r3, [r3, #0]
    3480:	4798      	blx	r3
    3482:	e797      	b.n	33b4 <loop+0x64>
      if (data < 0)
        break;
      checksum_ += data;
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
      {
        message_in[index_++] = data;
    3484:	f8d5 24f0 	ldr.w	r2, [r5, #1264]	; 0x4f0
        bytes_--;
    3488:	f8d5 34e8 	ldr.w	r3, [r5, #1256]	; 0x4e8
      if (data < 0)
        break;
      checksum_ += data;
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
      {
        message_in[index_++] = data;
    348c:	18a9      	adds	r1, r5, r2
        bytes_--;
    348e:	3b01      	subs	r3, #1
      if (data < 0)
        break;
      checksum_ += data;
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
      {
        message_in[index_++] = data;
    3490:	3201      	adds	r2, #1
    3492:	7708      	strb	r0, [r1, #28]
    3494:	f8c5 24f0 	str.w	r2, [r5, #1264]	; 0x4f0
        bytes_--;
    3498:	f8c5 34e8 	str.w	r3, [r5, #1256]	; 0x4e8
        if (bytes_ == 0)                 /* is message complete? if so, checksum */
    349c:	2b00      	cmp	r3, #0
    349e:	d189      	bne.n	33b4 <loop+0x64>
          mode_ = MODE_MSG_CHECKSUM;
    34a0:	2308      	movs	r3, #8
    34a2:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    34a6:	e785      	b.n	33b4 <loop+0x64>
    34a8:	4798      	blx	r3
          // Exit the spin, processing timeout exceeded.
          return SPIN_TIMEOUT;
        }
      }
      int data = hardware_.read();
      if (data < 0)
    34aa:	2800      	cmp	r0, #0
    34ac:	da93      	bge.n	33d6 <loop+0x86>
        }
      }
    }

    /* occasionally sync time */
    if (configured_ && ((c_time - last_sync_time) > (SYNC_SECONDS * 500)))
    34ae:	f894 34f8 	ldrb.w	r3, [r4, #1272]	; 0x4f8
    34b2:	4873      	ldr	r0, [pc, #460]	; (3680 <loop+0x330>)
    34b4:	2b00      	cmp	r3, #0
    34b6:	d0a7      	beq.n	3408 <loop+0xb8>
    34b8:	f8d0 34fc 	ldr.w	r3, [r0, #1276]	; 0x4fc
    34bc:	f640 12c4 	movw	r2, #2500	; 0x9c4
    34c0:	1af3      	subs	r3, r6, r3
    34c2:	4293      	cmp	r3, r2
    34c4:	d9a0      	bls.n	3408 <loop+0xb8>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    34c6:	23ff      	movs	r3, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    34c8:	21fe      	movs	r1, #254	; 0xfe
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->data.sec >> (8 * 0)) & 0xFF;
    34ca:	2200      	movs	r2, #0

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    34cc:	f880 321c 	strb.w	r3, [r0, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    34d0:	f880 121d 	strb.w	r1, [r0, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    34d4:	23f7      	movs	r3, #247	; 0xf7
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    34d6:	2508      	movs	r5, #8
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    34d8:	210a      	movs	r1, #10
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    34da:	f880 3220 	strb.w	r3, [r0, #544]	; 0x220
    34de:	f880 2223 	strb.w	r2, [r0, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->data.sec >> (8 * 1)) & 0xFF;
    34e2:	f880 2224 	strb.w	r2, [r0, #548]	; 0x224
      *(outbuffer + offset + 2) = (this->data.sec >> (8 * 2)) & 0xFF;
    34e6:	f880 2225 	strb.w	r2, [r0, #549]	; 0x225
      *(outbuffer + offset + 3) = (this->data.sec >> (8 * 3)) & 0xFF;
    34ea:	f880 2226 	strb.w	r2, [r0, #550]	; 0x226
      offset += sizeof(this->data.sec);
      *(outbuffer + offset + 0) = (this->data.nsec >> (8 * 0)) & 0xFF;
    34ee:	f880 2227 	strb.w	r2, [r0, #551]	; 0x227
      *(outbuffer + offset + 1) = (this->data.nsec >> (8 * 1)) & 0xFF;
    34f2:	f880 2228 	strb.w	r2, [r0, #552]	; 0x228
      *(outbuffer + offset + 2) = (this->data.nsec >> (8 * 2)) & 0xFF;
    34f6:	f880 2229 	strb.w	r2, [r0, #553]	; 0x229
      *(outbuffer + offset + 3) = (this->data.nsec >> (8 * 3)) & 0xFF;
    34fa:	f880 222a 	strb.w	r2, [r0, #554]	; 0x22a

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    34fe:	f880 221f 	strb.w	r2, [r0, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3502:	f880 2222 	strb.w	r2, [r0, #546]	; 0x222
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3506:	f880 521e 	strb.w	r5, [r0, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    350a:	f880 1221 	strb.w	r1, [r0, #545]	; 0x221
    350e:	f200 2321 	addw	r3, r0, #545	; 0x221
    3512:	f200 202a 	addw	r0, r0, #554	; 0x22a
    3516:	e001      	b.n	351c <loop+0x1cc>
    3518:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    351c:	4283      	cmp	r3, r0
      chk += message_out[i];
    351e:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3520:	d1fa      	bne.n	3518 <loop+0x1c8>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3522:	43d2      	mvns	r2, r2
    3524:	6860      	ldr	r0, [r4, #4]
    3526:	f884 222b 	strb.w	r2, [r4, #555]	; 0x22b
    void write(uint8_t* data, int length){
      iostream->write(data, length);
    352a:	6803      	ldr	r3, [r0, #0]
    352c:	4a56      	ldr	r2, [pc, #344]	; (3688 <loop+0x338>)
    352e:	685b      	ldr	r3, [r3, #4]
    3530:	4293      	cmp	r3, r2
    3532:	f040 8313 	bne.w	3b5c <loop+0x80c>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    3536:	2110      	movs	r1, #16
    3538:	4854      	ldr	r0, [pc, #336]	; (368c <loop+0x33c>)
    353a:	f003 fe35 	bl	71a8 <usb_serial_write>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    353e:	683b      	ldr	r3, [r7, #0]
    3540:	9311      	str	r3, [sp, #68]	; 0x44
	return ret;
    3542:	9b11      	ldr	r3, [sp, #68]	; 0x44

    /* occasionally sync time */
    if (configured_ && ((c_time - last_sync_time) > (SYNC_SECONDS * 500)))
    {
      requestSyncTime();
      last_sync_time = c_time;
    3544:	f8c4 64fc 	str.w	r6, [r4, #1276]	; 0x4fc

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    rt_time = hardware_.time();
    3548:	60e3      	str	r3, [r4, #12]
    354a:	b015      	add	sp, #84	; 0x54
    354c:	ecbd 8b04 	vpop	{d8-d9}
    3550:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      }
      else if (mode_ == MODE_FIRST_FF)
      {
        if (data == 0xff)
        {
          mode_++;
    3554:	2201      	movs	r2, #1
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
    3556:	f106 0314 	add.w	r3, r6, #20
      }
      else if (mode_ == MODE_FIRST_FF)
      {
        if (data == 0xff)
        {
          mode_++;
    355a:	f8c5 24e4 	str.w	r2, [r5, #1252]	; 0x4e4
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
    355e:	f8c5 3504 	str.w	r3, [r5, #1284]	; 0x504
    3562:	e727      	b.n	33b4 <loop+0x64>
          return SPIN_TIMEOUT;
        }
      }
      else if (mode_ == MODE_PROTOCOL_VER)
      {
        if (data == PROTOCOL_VER)
    3564:	28fe      	cmp	r0, #254	; 0xfe
    3566:	d068      	beq.n	363a <loop+0x2ea>
          mode_++;
        }
        else
        {
          mode_ = MODE_FIRST_FF;
          if (configured_ == false)
    3568:	f895 24f8 	ldrb.w	r2, [r5, #1272]	; 0x4f8
        {
          mode_++;
        }
        else
        {
          mode_ = MODE_FIRST_FF;
    356c:	2300      	movs	r3, #0
    356e:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
          if (configured_ == false)
    3572:	2a00      	cmp	r2, #0
    3574:	f47f af1e 	bne.w	33b4 <loop+0x64>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3578:	23ff      	movs	r3, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    357a:	21fe      	movs	r1, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    357c:	2008      	movs	r0, #8

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    357e:	f885 321c 	strb.w	r3, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    3582:	f885 121d 	strb.w	r1, [r5, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3586:	23f7      	movs	r3, #247	; 0xf7
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3588:	210a      	movs	r1, #10
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    358a:	f885 3220 	strb.w	r3, [r5, #544]	; 0x220
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->data.sec >> (8 * 0)) & 0xFF;
    358e:	f885 2223 	strb.w	r2, [r5, #547]	; 0x223
    3592:	f20e 2321 	addw	r3, lr, #545	; 0x221
      *(outbuffer + offset + 1) = (this->data.sec >> (8 * 1)) & 0xFF;
    3596:	f885 2224 	strb.w	r2, [r5, #548]	; 0x224
      *(outbuffer + offset + 2) = (this->data.sec >> (8 * 2)) & 0xFF;
    359a:	f885 2225 	strb.w	r2, [r5, #549]	; 0x225
      *(outbuffer + offset + 3) = (this->data.sec >> (8 * 3)) & 0xFF;
    359e:	f885 2226 	strb.w	r2, [r5, #550]	; 0x226
      offset += sizeof(this->data.sec);
      *(outbuffer + offset + 0) = (this->data.nsec >> (8 * 0)) & 0xFF;
    35a2:	f885 2227 	strb.w	r2, [r5, #551]	; 0x227
      *(outbuffer + offset + 1) = (this->data.nsec >> (8 * 1)) & 0xFF;
    35a6:	f885 2228 	strb.w	r2, [r5, #552]	; 0x228
      *(outbuffer + offset + 2) = (this->data.nsec >> (8 * 2)) & 0xFF;
    35aa:	f885 2229 	strb.w	r2, [r5, #553]	; 0x229
      *(outbuffer + offset + 3) = (this->data.nsec >> (8 * 3)) & 0xFF;
    35ae:	f885 222a 	strb.w	r2, [r5, #554]	; 0x22a

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    35b2:	f885 221f 	strb.w	r2, [r5, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    35b6:	f885 2222 	strb.w	r2, [r5, #546]	; 0x222
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    35ba:	f885 021e 	strb.w	r0, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    35be:	f885 1221 	strb.w	r1, [r5, #545]	; 0x221
    35c2:	f20e 2e2a 	addw	lr, lr, #554	; 0x22a
    35c6:	e001      	b.n	35cc <loop+0x27c>
    35c8:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    35cc:	4573      	cmp	r3, lr
      chk += message_out[i];
    35ce:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    35d0:	d1fa      	bne.n	35c8 <loop+0x278>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    35d2:	43d2      	mvns	r2, r2
    35d4:	6860      	ldr	r0, [r4, #4]
    35d6:	f884 222b 	strb.w	r2, [r4, #555]	; 0x22b
    35da:	6803      	ldr	r3, [r0, #0]
    35dc:	4a2a      	ldr	r2, [pc, #168]	; (3688 <loop+0x338>)
    35de:	685b      	ldr	r3, [r3, #4]
    35e0:	4293      	cmp	r3, r2
    35e2:	f040 8190 	bne.w	3906 <loop+0x5b6>
    35e6:	2110      	movs	r1, #16
    35e8:	4828      	ldr	r0, [pc, #160]	; (368c <loop+0x33c>)
    35ea:	f003 fddd 	bl	71a8 <usb_serial_write>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    35ee:	683b      	ldr	r3, [r7, #0]
    35f0:	930b      	str	r3, [sp, #44]	; 0x2c
	return ret;
    35f2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    rt_time = hardware_.time();
    35f4:	60e3      	str	r3, [r4, #12]
    35f6:	e6dd      	b.n	33b4 <loop+0x64>
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
        index_ = 0;
    35f8:	2200      	movs	r2, #0
        mode_++;
    35fa:	2303      	movs	r3, #3
            requestSyncTime();  /* send a msg back showing our protocol version */
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
    35fc:	f8c5 04e8 	str.w	r0, [r5, #1256]	; 0x4e8
        index_ = 0;
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
    3600:	f8c5 04f4 	str.w	r0, [r5, #1268]	; 0x4f4
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
        index_ = 0;
    3604:	f8c5 24f0 	str.w	r2, [r5, #1264]	; 0x4f0
        mode_++;
    3608:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
    360c:	e6d2      	b.n	33b4 <loop+0x64>
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
      {
        bytes_ += data << 8;
    360e:	f8d5 34e8 	ldr.w	r3, [r5, #1256]	; 0x4e8
    3612:	eb03 2000 	add.w	r0, r3, r0, lsl #8
        mode_++;
    3616:	2304      	movs	r3, #4
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
      {
        bytes_ += data << 8;
    3618:	f8c5 04e8 	str.w	r0, [r5, #1256]	; 0x4e8
        mode_++;
    361c:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
    3620:	e6c8      	b.n	33b4 <loop+0x64>
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
      {
        if ((checksum_ % 256) == 255)
    3622:	4a18      	ldr	r2, [pc, #96]	; (3684 <loop+0x334>)
    3624:	401a      	ands	r2, r3
    3626:	2a00      	cmp	r2, #0
    3628:	f2c0 817c 	blt.w	3924 <loop+0x5d4>
    362c:	2aff      	cmp	r2, #255	; 0xff
          mode_++;
    362e:	bf0c      	ite	eq
    3630:	2305      	moveq	r3, #5
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
    3632:	2300      	movne	r3, #0
    3634:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    3638:	e6bc      	b.n	33b4 <loop+0x64>
      }
      else if (mode_ == MODE_PROTOCOL_VER)
      {
        if (data == PROTOCOL_VER)
        {
          mode_++;
    363a:	2302      	movs	r3, #2
    363c:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
    3640:	e6b8      	b.n	33b4 <loop+0x64>
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
        mode_++;
    3642:	2306      	movs	r3, #6
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
    3644:	f8c5 04ec 	str.w	r0, [r5, #1260]	; 0x4ec
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
    3648:	f8c5 04f4 	str.w	r0, [r5, #1268]	; 0x4f4
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
        mode_++;
    364c:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
    3650:	e6b0      	b.n	33b4 <loop+0x64>
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    3652:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
        mode_ = MODE_MESSAGE;
        if (bytes_ == 0)
    3656:	f8d5 24e8 	ldr.w	r2, [r5, #1256]	; 0x4e8
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    365a:	eb03 2300 	add.w	r3, r3, r0, lsl #8
        mode_ = MODE_MESSAGE;
    365e:	2107      	movs	r1, #7
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    3660:	f8c5 34ec 	str.w	r3, [r5, #1260]	; 0x4ec
        mode_ = MODE_MESSAGE;
    3664:	f8c5 14e4 	str.w	r1, [r5, #1252]	; 0x4e4
        if (bytes_ == 0)
    3668:	2a00      	cmp	r2, #0
    366a:	f43f af19 	beq.w	34a0 <loop+0x150>
    366e:	e6a1      	b.n	33b4 <loop+0x64>
    3670:	1fff1ccc 	.word	0x1fff1ccc
    3674:	1fff2b4c 	.word	0x1fff2b4c
    3678:	1fff2b00 	.word	0x1fff2b00
    367c:	1fff080c 	.word	0x1fff080c
    3680:	1fff1d88 	.word	0x1fff1d88
    3684:	800000ff 	.word	0x800000ff
    3688:	00000c49 	.word	0x00000c49
    368c:	1fff1fa4 	.word	0x1fff1fa4
    3690:	00000c51 	.word	0x00000c51

    /*wheel_speed.x = average_omega_right;
    wheel_speed.y = average_omega_left;
    wheel_speed.z = temp_input_vel;
    wheel_speed.w = goal_vel_x;*/
    wheel_speed.x = average_omega_right;
    3694:	48d0      	ldr	r0, [pc, #832]	; (39d8 <loop+0x688>)
    wheel_speed.y = average_omega_left;
    3696:	4ad1      	ldr	r2, [pc, #836]	; (39dc <loop+0x68c>)
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3698:	683c      	ldr	r4, [r7, #0]
    wheel_speed.z = error_r;
    369a:	4bd1      	ldr	r3, [pc, #836]	; (39e0 <loop+0x690>)
    369c:	9408      	str	r4, [sp, #32]

    /*wheel_speed.x = average_omega_right;
    wheel_speed.y = average_omega_left;
    wheel_speed.z = temp_input_vel;
    wheel_speed.w = goal_vel_x;*/
    wheel_speed.x = average_omega_right;
    369e:	ed90 9a00 	vldr	s18, [r0]
    36a2:	4cd0      	ldr	r4, [pc, #832]	; (39e4 <loop+0x694>)
    wheel_speed.y = average_omega_left;
    36a4:	edd2 8a00 	vldr	s17, [r2]
	return ret;
    36a8:	9a08      	ldr	r2, [sp, #32]
    last_error_right = goal_omega_right - average_omega_right;
    last_error_left = goal_omega_left - average_omega_left;
  }

  if(millis() > time_now + period){
    time_now = millis();
    36aa:	600a      	str	r2, [r1, #0]

    /*wheel_speed.x = average_omega_right;
    wheel_speed.y = average_omega_left;
    wheel_speed.z = temp_input_vel;
    wheel_speed.w = goal_vel_x;*/
    wheel_speed.x = average_omega_right;
    36ac:	ed84 9a01 	vstr	s18, [r4, #4]
    wheel_speed.y = average_omega_left;
    wheel_speed.z = error_r;
    36b0:	e9d3 0100 	ldrd	r0, r1, [r3]
    /*wheel_speed.x = average_omega_right;
    wheel_speed.y = average_omega_left;
    wheel_speed.z = temp_input_vel;
    wheel_speed.w = goal_vel_x;*/
    wheel_speed.x = average_omega_right;
    wheel_speed.y = average_omega_left;
    36b4:	edc4 8a02 	vstr	s17, [r4, #8]
    wheel_speed.z = error_r;
    36b8:	f005 fe7a 	bl	93b0 <__aeabi_d2f>
    wheel_speed.w = cum_error_r;
    36bc:	4bca      	ldr	r3, [pc, #808]	; (39e8 <loop+0x698>)
    wheel_speed.y = average_omega_left;
    wheel_speed.z = temp_input_vel;
    wheel_speed.w = goal_vel_x;*/
    wheel_speed.x = average_omega_right;
    wheel_speed.y = average_omega_left;
    wheel_speed.z = error_r;
    36be:	60e0      	str	r0, [r4, #12]
    36c0:	ee08 0a10 	vmov	s16, r0
    wheel_speed.w = cum_error_r;
    36c4:	e9d3 0100 	ldrd	r0, r1, [r3]
    36c8:	f005 fe72 	bl	93b0 <__aeabi_d2f>
    36cc:	4bc7      	ldr	r3, [pc, #796]	; (39ec <loop+0x69c>)
    36ce:	4ac8      	ldr	r2, [pc, #800]	; (39f0 <loop+0x6a0>)
    36d0:	6899      	ldr	r1, [r3, #8]
    36d2:	ee07 0a90 	vmov	s15, r0
    36d6:	68d8      	ldr	r0, [r3, #12]
    36d8:	6803      	ldr	r3, [r0, #0]
    36da:	edc4 7a04 	vstr	s15, [r4, #16]
    36de:	681b      	ldr	r3, [r3, #0]
    36e0:	4293      	cmp	r3, r2
    36e2:	f040 820d 	bne.w	3b00 <loop+0x7b0>
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    36e6:	2963      	cmp	r1, #99	; 0x63
    36e8:	dd04      	ble.n	36f4 <loop+0x3a4>
    36ea:	f890 34f8 	ldrb.w	r3, [r0, #1272]	; 0x4f8
    36ee:	2b00      	cmp	r3, #0
    36f0:	f43f ae44 	beq.w	337c <loop+0x2c>
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    36f4:	ee19 3a10 	vmov	r3, s18

    int16_t exp = ((val >> 23) & 255);
    36f8:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    36fc:	2aff      	cmp	r2, #255	; 0xff
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    36fe:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    3702:	f000 8104 	beq.w	390e <loop+0x5be>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    3706:	2a00      	cmp	r2, #0
    3708:	f000 81a2 	beq.w	3a50 <loop+0x700>
    {
      exp += 1023 - 127; // Normal case
    370c:	f502 7260 	add.w	r2, r2, #896	; 0x380
    3710:	0cdc      	lsrs	r4, r3, #19
    3712:	015d      	lsls	r5, r3, #5
    3714:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
    3718:	f3c3 0ec7 	ubfx	lr, r3, #3, #8
    371c:	b2e4      	uxtb	r4, r4
    371e:	f3c2 1607 	ubfx	r6, r2, #4, #8
    3722:	b2ed      	uxtb	r5, r5
    3724:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    3728:	eeb5 9ac0 	vcmpe.f32	s18, #0.0
    372c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    3730:	f880 3228 	strb.w	r3, [r0, #552]	; 0x228
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    3734:	bf44      	itt	mi
    3736:	f066 037f 	ornmi	r3, r6, #127	; 0x7f
    373a:	f880 322a 	strbmi.w	r3, [r0, #554]	; 0x22a
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    373e:	ee18 3a90 	vmov	r3, s17
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    3742:	f04f 0200 	mov.w	r2, #0
    3746:	f880 2223 	strb.w	r2, [r0, #547]	; 0x223
    *(outbuffer++) = 0;
    374a:	f880 2224 	strb.w	r2, [r0, #548]	; 0x224
    *(outbuffer++) = 0;
    374e:	f880 2225 	strb.w	r2, [r0, #549]	; 0x225
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    3752:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;
    3756:	bf58      	it	pl
    3758:	f880 622a 	strbpl.w	r6, [r0, #554]	; 0x22a
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    375c:	2aff      	cmp	r2, #255	; 0xff
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    375e:	f880 5226 	strb.w	r5, [r0, #550]	; 0x226
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    3762:	f880 e227 	strb.w	lr, [r0, #551]	; 0x227
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    3766:	f880 4229 	strb.w	r4, [r0, #553]	; 0x229
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    376a:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    376e:	f000 81da 	beq.w	3b26 <loop+0x7d6>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    3772:	2a00      	cmp	r2, #0
    3774:	f000 814e 	beq.w	3a14 <loop+0x6c4>
    {
      exp += 1023 - 127; // Normal case
    3778:	f502 7260 	add.w	r2, r2, #896	; 0x380
    377c:	0114      	lsls	r4, r2, #4
    377e:	ea44 44d3 	orr.w	r4, r4, r3, lsr #19
    3782:	015d      	lsls	r5, r3, #5
    3784:	f3c3 0ec7 	ubfx	lr, r3, #3, #8
    3788:	b2e4      	uxtb	r4, r4
    378a:	f3c2 1607 	ubfx	r6, r2, #4, #8
    378e:	b2ed      	uxtb	r5, r5
    3790:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    3794:	eef5 8ac0 	vcmpe.f32	s17, #0.0
    3798:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    379c:	f880 3230 	strb.w	r3, [r0, #560]	; 0x230
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    37a0:	bf44      	itt	mi
    37a2:	f066 037f 	ornmi	r3, r6, #127	; 0x7f
    37a6:	f880 3232 	strbmi.w	r3, [r0, #562]	; 0x232
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    37aa:	ee18 3a10 	vmov	r3, s16
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    37ae:	f04f 0200 	mov.w	r2, #0
    37b2:	f880 222b 	strb.w	r2, [r0, #555]	; 0x22b
    *(outbuffer++) = 0;
    37b6:	f880 222c 	strb.w	r2, [r0, #556]	; 0x22c
    *(outbuffer++) = 0;
    37ba:	f880 222d 	strb.w	r2, [r0, #557]	; 0x22d
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    37be:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;
    37c2:	bf58      	it	pl
    37c4:	f880 6232 	strbpl.w	r6, [r0, #562]	; 0x232
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    37c8:	2aff      	cmp	r2, #255	; 0xff
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    37ca:	f880 522e 	strb.w	r5, [r0, #558]	; 0x22e
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    37ce:	f880 e22f 	strb.w	lr, [r0, #559]	; 0x22f
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    37d2:	f880 4231 	strb.w	r4, [r0, #561]	; 0x231
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    37d6:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    37da:	f000 8199 	beq.w	3b10 <loop+0x7c0>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    37de:	2a00      	cmp	r2, #0
    37e0:	f000 8154 	beq.w	3a8c <loop+0x73c>
    {
      exp += 1023 - 127; // Normal case
    37e4:	f502 7260 	add.w	r2, r2, #896	; 0x380
    37e8:	0cdc      	lsrs	r4, r3, #19
    37ea:	015d      	lsls	r5, r3, #5
    37ec:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
    37f0:	f3c3 0ec7 	ubfx	lr, r3, #3, #8
    37f4:	b2e4      	uxtb	r4, r4
    37f6:	f3c2 1607 	ubfx	r6, r2, #4, #8
    37fa:	b2ed      	uxtb	r5, r5
    37fc:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    3800:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
    3804:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    3808:	f880 3238 	strb.w	r3, [r0, #568]	; 0x238
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    380c:	bf44      	itt	mi
    380e:	f066 037f 	ornmi	r3, r6, #127	; 0x7f
    3812:	f880 323a 	strbmi.w	r3, [r0, #570]	; 0x23a
   *
   */
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));
    3816:	ee17 3a90 	vmov	r3, s15
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    381a:	f04f 0200 	mov.w	r2, #0
    381e:	f880 2233 	strb.w	r2, [r0, #563]	; 0x233
    *(outbuffer++) = 0;
    3822:	f880 2234 	strb.w	r2, [r0, #564]	; 0x234
    *(outbuffer++) = 0;
    3826:	f880 2235 	strb.w	r2, [r0, #565]	; 0x235
  static int serializeAvrFloat64(unsigned char* outbuffer, const float f)
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    382a:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;
    382e:	bf58      	it	pl
    3830:	f880 623a 	strbpl.w	r6, [r0, #570]	; 0x23a
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    3834:	2aff      	cmp	r2, #255	; 0xff
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    3836:	f880 5236 	strb.w	r5, [r0, #566]	; 0x236
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    383a:	f880 e237 	strb.w	lr, [r0, #567]	; 0x237
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    383e:	f880 4239 	strb.w	r4, [r0, #569]	; 0x239
  {
    int32_t val;
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;
    3842:	f3c3 0316 	ubfx	r3, r3, #0, #23

    if (exp == 255)
    3846:	f000 8179 	beq.w	3b3c <loop+0x7ec>
    {
      exp = 2047; // Special value for NaN, infinity etc.
    }
    else if (exp != 0)
    384a:	2a00      	cmp	r2, #0
    384c:	f000 813b 	beq.w	3ac6 <loop+0x776>
    {
      exp += 1023 - 127; // Normal case
    3850:	f502 7260 	add.w	r2, r2, #896	; 0x380
    3854:	0cdc      	lsrs	r4, r3, #19
    3856:	015d      	lsls	r5, r3, #5
    3858:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
    385c:	f3c3 0ec7 	ubfx	lr, r3, #3, #8
    3860:	b2e4      	uxtb	r4, r4
    3862:	f3c2 1607 	ubfx	r6, r2, #4, #8
    3866:	b2ed      	uxtb	r5, r5
    3868:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    386c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    3870:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    3874:	f04f 0200 	mov.w	r2, #0
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    3878:	f880 3240 	strb.w	r3, [r0, #576]	; 0x240
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    387c:	f880 4241 	strb.w	r4, [r0, #577]	; 0x241
    *(outbuffer++) = (exp >> 4) & 0x7F;

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    3880:	bf48      	it	mi
    3882:	f066 037f 	ornmi	r3, r6, #127	; 0x7f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3886:	f04f 04ff 	mov.w	r4, #255	; 0xff
    }

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    388a:	f880 523e 	strb.w	r5, [r0, #574]	; 0x23e
          exp--;
      }
      mantissa &= 0x7FFFFF;
    }

    *(outbuffer++) = 0;
    388e:	f880 223b 	strb.w	r2, [r0, #571]	; 0x23b
    *(outbuffer++) = 0;
    3892:	f880 223c 	strb.w	r2, [r0, #572]	; 0x23c
    *(outbuffer++) = 0;
    3896:	f880 223d 	strb.w	r2, [r0, #573]	; 0x23d
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    *(outbuffer++) = (mantissa >> 11) & 0xff;
    *(outbuffer++) = ((exp << 4) & 0xF0) | ((mantissa >> 19) & 0x0F);
    *(outbuffer++) = (exp >> 4) & 0x7F;
    389a:	bf54      	ite	pl
    389c:	f880 6242 	strbpl.w	r6, [r0, #578]	; 0x242

    // Mark negative bit as necessary.
    if (f < 0)
    {
      *(outbuffer - 1) |= 0x80;
    38a0:	f880 3242 	strbmi.w	r3, [r0, #578]	; 0x242
    message_out[1] = PROTOCOL_VER;
    38a4:	26fe      	movs	r6, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    38a6:	23df      	movs	r3, #223	; 0xdf
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    38a8:	2520      	movs	r5, #32
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    38aa:	2200      	movs	r2, #0

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    38ac:	f880 421c 	strb.w	r4, [r0, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    38b0:	b2cc      	uxtb	r4, r1
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    38b2:	f341 2107 	sbfx	r1, r1, #8, #8
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    38b6:	f880 3220 	strb.w	r3, [r0, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    38ba:	f880 1222 	strb.w	r1, [r0, #546]	; 0x222

    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = 0;
    *(outbuffer++) = (mantissa << 5) & 0xff;
    *(outbuffer++) = (mantissa >> 3) & 0xff;
    38be:	f880 e23f 	strb.w	lr, [r0, #575]	; 0x23f
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    38c2:	f880 621d 	strb.w	r6, [r0, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    38c6:	f880 521e 	strb.w	r5, [r0, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    38ca:	f880 221f 	strb.w	r2, [r0, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    38ce:	f880 4221 	strb.w	r4, [r0, #545]	; 0x221
    38d2:	f200 2321 	addw	r3, r0, #545	; 0x221
    38d6:	f200 2142 	addw	r1, r0, #578	; 0x242
    38da:	e001      	b.n	38e0 <loop+0x590>
    38dc:	f813 4f01 	ldrb.w	r4, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    38e0:	428b      	cmp	r3, r1
      chk += message_out[i];
    38e2:	4422      	add	r2, r4
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    38e4:	d1fa      	bne.n	38dc <loop+0x58c>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    38e6:	43d2      	mvns	r2, r2
    38e8:	6844      	ldr	r4, [r0, #4]
    38ea:	f880 2243 	strb.w	r2, [r0, #579]	; 0x243
    38ee:	6823      	ldr	r3, [r4, #0]
    38f0:	4a40      	ldr	r2, [pc, #256]	; (39f4 <loop+0x6a4>)
    38f2:	685b      	ldr	r3, [r3, #4]
    38f4:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    38f6:	f500 7007 	add.w	r0, r0, #540	; 0x21c
    38fa:	f040 8104 	bne.w	3b06 <loop+0x7b6>
    38fe:	2128      	movs	r1, #40	; 0x28
    3900:	f003 fc52 	bl	71a8 <usb_serial_write>
    3904:	e53a      	b.n	337c <loop+0x2c>
    3906:	2210      	movs	r2, #16
    3908:	493b      	ldr	r1, [pc, #236]	; (39f8 <loop+0x6a8>)
    390a:	4798      	blx	r3
    390c:	e66f      	b.n	35ee <loop+0x29e>
    390e:	015d      	lsls	r5, r3, #5
    3910:	0cdc      	lsrs	r4, r3, #19
    3912:	f3c3 0ec7 	ubfx	lr, r3, #3, #8
    3916:	b2ed      	uxtb	r5, r5
    3918:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    391c:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    3920:	267f      	movs	r6, #127	; 0x7f
    3922:	e701      	b.n	3728 <loop+0x3d8>
        bytes_ += data << 8;
        mode_++;
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
      {
        if ((checksum_ % 256) == 255)
    3924:	3a01      	subs	r2, #1
    3926:	f062 02ff 	orn	r2, r2, #255	; 0xff
    392a:	3201      	adds	r2, #1
    392c:	e67e      	b.n	362c <loop+0x2dc>
}

void loop() {
  if(bool_tele_op_toggel == 2){
    current_time = micros();
    double time_elapsed = double(current_time - previous_time)*pow(10,-6);
    392e:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 3a08 <loop+0x6b8>

}

void loop() {
  if(bool_tele_op_toggel == 2){
    current_time = micros();
    3932:	f8df b0d8 	ldr.w	fp, [pc, #216]	; 3a0c <loop+0x6bc>
    double time_elapsed = double(current_time - previous_time)*pow(10,-6);
    speed_PID_controller(goal_omega_right, average_omega_right, last_error_right, goal_omega_left, average_omega_left, last_error_left, time_elapsed);
    3936:	4e29      	ldr	r6, [pc, #164]	; (39dc <loop+0x68c>)
    3938:	f8df a09c 	ldr.w	sl, [pc, #156]	; 39d8 <loop+0x688>
    393c:	4c2f      	ldr	r4, [pc, #188]	; (39fc <loop+0x6ac>)
    393e:	4d30      	ldr	r5, [pc, #192]	; (3a00 <loop+0x6b0>)
    3940:	4f30      	ldr	r7, [pc, #192]	; (3a04 <loop+0x6b4>)
    3942:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 3a10 <loop+0x6c0>

}

void loop() {
  if(bool_tele_op_toggel == 2){
    current_time = micros();
    3946:	f002 fd03 	bl	6350 <micros>
    double time_elapsed = double(current_time - previous_time)*pow(10,-6);
    speed_PID_controller(goal_omega_right, average_omega_right, last_error_right, goal_omega_left, average_omega_left, last_error_left, time_elapsed);
    394a:	f8d9 3000 	ldr.w	r3, [r9]

}

void loop() {
  if(bool_tele_op_toggel == 2){
    current_time = micros();
    394e:	f8cb 0000 	str.w	r0, [fp]
    double time_elapsed = double(current_time - previous_time)*pow(10,-6);
    speed_PID_controller(goal_omega_right, average_omega_right, last_error_right, goal_omega_left, average_omega_left, last_error_left, time_elapsed);
    3952:	1ac0      	subs	r0, r0, r3
    3954:	f005 f9ee 	bl	8d34 <__aeabi_i2d>
    3958:	a31d      	add	r3, pc, #116	; (adr r3, 39d0 <loop+0x680>)
    395a:	e9d3 2300 	ldrd	r2, r3, [r3]
    395e:	f005 fa4f 	bl	8e00 <__aeabi_dmul>
    3962:	e9cd 0102 	strd	r0, r1, [sp, #8]
    3966:	6830      	ldr	r0, [r6, #0]
    3968:	f005 f9f6 	bl	8d58 <__aeabi_f2d>
    396c:	e9cd 0100 	strd	r0, r1, [sp]
    3970:	f8da 0000 	ldr.w	r0, [sl]
    3974:	f005 f9f0 	bl	8d58 <__aeabi_f2d>
    3978:	ed94 5b00 	vldr	d5, [r4]
    397c:	ec41 0b11 	vmov	d1, r0, r1
    3980:	ed95 3b00 	vldr	d3, [r5]
    3984:	ed97 2b00 	vldr	d2, [r7]
    3988:	ed9d 6b02 	vldr	d6, [sp, #8]
    398c:	ed9d 4b00 	vldr	d4, [sp]
    3990:	ed98 0b00 	vldr	d0, [r8]
    3994:	f7ff f82a 	bl	29ec <speed_PID_controller(double, double, double, double, double, double, double)>

    previous_time = current_time;
    3998:	f8db 3000 	ldr.w	r3, [fp]
    399c:	f8c9 3000 	str.w	r3, [r9]
    last_error_right = goal_omega_right - average_omega_right;
    39a0:	f8da 0000 	ldr.w	r0, [sl]
    39a4:	f005 f9d8 	bl	8d58 <__aeabi_f2d>
    39a8:	4602      	mov	r2, r0
    39aa:	460b      	mov	r3, r1
    39ac:	e9d8 0100 	ldrd	r0, r1, [r8]
    39b0:	f005 f872 	bl	8a98 <__aeabi_dsub>
    39b4:	e9c7 0100 	strd	r0, r1, [r7]
    last_error_left = goal_omega_left - average_omega_left;
    39b8:	6830      	ldr	r0, [r6, #0]
    39ba:	f005 f9cd 	bl	8d58 <__aeabi_f2d>
    39be:	4602      	mov	r2, r0
    39c0:	460b      	mov	r3, r1
    39c2:	e9d5 0100 	ldrd	r0, r1, [r5]
    39c6:	f005 f867 	bl	8a98 <__aeabi_dsub>
    39ca:	e9c4 0100 	strd	r0, r1, [r4]
    39ce:	e4c9      	b.n	3364 <loop+0x14>
    39d0:	a0b5ed8d 	.word	0xa0b5ed8d
    39d4:	3eb0c6f7 	.word	0x3eb0c6f7
    39d8:	1fff148c 	.word	0x1fff148c
    39dc:	1fff1cb8 	.word	0x1fff1cb8
    39e0:	1fff1458 	.word	0x1fff1458
    39e4:	1fff2ad8 	.word	0x1fff2ad8
    39e8:	1fff2ad0 	.word	0x1fff2ad0
    39ec:	1fff1d4c 	.word	0x1fff1d4c
    39f0:	0000257d 	.word	0x0000257d
    39f4:	00000c49 	.word	0x00000c49
    39f8:	1fff1fa4 	.word	0x1fff1fa4
    39fc:	1fff1480 	.word	0x1fff1480
    3a00:	1fff1498 	.word	0x1fff1498
    3a04:	1fff1d78 	.word	0x1fff1d78
    3a08:	1fff2b30 	.word	0x1fff2b30
    3a0c:	1fff2b38 	.word	0x1fff2b38
    3a10:	1fff2b10 	.word	0x1fff2b10
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    3a14:	2b00      	cmp	r3, #0
    3a16:	f000 80b4 	beq.w	3b82 <loop+0x832>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    3a1a:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    3a1c:	021e      	lsls	r6, r3, #8
    3a1e:	f100 81f9 	bmi.w	3e14 <loop+0xac4>
    3a22:	f44f 7460 	mov.w	r4, #896	; 0x380
    3a26:	3c01      	subs	r4, #1
      {
          mantissa <<= 1;
    3a28:	005b      	lsls	r3, r3, #1
    3a2a:	b2a2      	uxth	r2, r4
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    3a2c:	021d      	lsls	r5, r3, #8
    3a2e:	b214      	sxth	r4, r2
    3a30:	d5f9      	bpl.n	3a26 <loop+0x6d6>
    3a32:	0112      	lsls	r2, r2, #4
    3a34:	b2d2      	uxtb	r2, r2
    3a36:	f3c4 1606 	ubfx	r6, r4, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    3a3a:	f3c3 0316 	ubfx	r3, r3, #0, #23
    3a3e:	015d      	lsls	r5, r3, #5
    3a40:	ea42 44d3 	orr.w	r4, r2, r3, lsr #19
    3a44:	f3c3 0ec7 	ubfx	lr, r3, #3, #8
    3a48:	b2ed      	uxtb	r5, r5
    3a4a:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    3a4e:	e6a1      	b.n	3794 <loop+0x444>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    3a50:	2b00      	cmp	r3, #0
    3a52:	f000 8091 	beq.w	3b78 <loop+0x828>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    3a56:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    3a58:	021e      	lsls	r6, r3, #8
    3a5a:	f100 81e1 	bmi.w	3e20 <loop+0xad0>
    3a5e:	f44f 7460 	mov.w	r4, #896	; 0x380
    3a62:	3c01      	subs	r4, #1
      {
          mantissa <<= 1;
    3a64:	005b      	lsls	r3, r3, #1
    3a66:	b2a2      	uxth	r2, r4
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    3a68:	021d      	lsls	r5, r3, #8
    3a6a:	b214      	sxth	r4, r2
    3a6c:	d5f9      	bpl.n	3a62 <loop+0x712>
    3a6e:	0112      	lsls	r2, r2, #4
    3a70:	b2d2      	uxtb	r2, r2
    3a72:	f3c4 1606 	ubfx	r6, r4, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    3a76:	f3c3 0316 	ubfx	r3, r3, #0, #23
    3a7a:	015d      	lsls	r5, r3, #5
    3a7c:	ea42 44d3 	orr.w	r4, r2, r3, lsr #19
    3a80:	f3c3 0ec7 	ubfx	lr, r3, #3, #8
    3a84:	b2ed      	uxtb	r5, r5
    3a86:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    3a8a:	e64d      	b.n	3728 <loop+0x3d8>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    3a8c:	2b00      	cmp	r3, #0
    3a8e:	d06e      	beq.n	3b6e <loop+0x81e>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    3a90:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    3a92:	021e      	lsls	r6, r3, #8
    3a94:	f100 81c2 	bmi.w	3e1c <loop+0xacc>
    3a98:	f44f 7460 	mov.w	r4, #896	; 0x380
    3a9c:	3c01      	subs	r4, #1
      {
          mantissa <<= 1;
    3a9e:	005b      	lsls	r3, r3, #1
    3aa0:	b2a2      	uxth	r2, r4
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    3aa2:	021d      	lsls	r5, r3, #8
    3aa4:	b214      	sxth	r4, r2
    3aa6:	d5f9      	bpl.n	3a9c <loop+0x74c>
    3aa8:	0112      	lsls	r2, r2, #4
    3aaa:	b2d2      	uxtb	r2, r2
    3aac:	f3c4 1606 	ubfx	r6, r4, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    3ab0:	f3c3 0316 	ubfx	r3, r3, #0, #23
    3ab4:	015d      	lsls	r5, r3, #5
    3ab6:	ea42 44d3 	orr.w	r4, r2, r3, lsr #19
    3aba:	f3c3 0ec7 	ubfx	lr, r3, #3, #8
    3abe:	b2ed      	uxtb	r5, r5
    3ac0:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    3ac4:	e69c      	b.n	3800 <loop+0x4b0>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    3ac6:	2b00      	cmp	r3, #0
    3ac8:	d04c      	beq.n	3b64 <loop+0x814>
    }
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
    3aca:	005b      	lsls	r3, r3, #1
      while (!(mantissa & 0x800000))
    3acc:	021e      	lsls	r6, r3, #8
    3ace:	f100 81a3 	bmi.w	3e18 <loop+0xac8>
    3ad2:	f44f 7460 	mov.w	r4, #896	; 0x380
    3ad6:	3c01      	subs	r4, #1
      {
          mantissa <<= 1;
    3ad8:	005b      	lsls	r3, r3, #1
    3ada:	b2a2      	uxth	r2, r4
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    3adc:	021d      	lsls	r5, r3, #8
    3ade:	b214      	sxth	r4, r2
    3ae0:	d5f9      	bpl.n	3ad6 <loop+0x786>
    3ae2:	0112      	lsls	r2, r2, #4
    3ae4:	b2d2      	uxtb	r2, r2
    3ae6:	f3c4 1606 	ubfx	r6, r4, #4, #7
      {
          mantissa <<= 1;
          exp--;
      }
      mantissa &= 0x7FFFFF;
    3aea:	f3c3 0316 	ubfx	r3, r3, #0, #23
    3aee:	015d      	lsls	r5, r3, #5
    3af0:	ea42 44d3 	orr.w	r4, r2, r3, lsr #19
    3af4:	f3c3 0ec7 	ubfx	lr, r3, #3, #8
    3af8:	b2ed      	uxtb	r5, r5
    3afa:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    3afe:	e6b5      	b.n	386c <loop+0x51c>
    3b00:	4622      	mov	r2, r4
    3b02:	4798      	blx	r3
    3b04:	e43a      	b.n	337c <loop+0x2c>
    3b06:	4601      	mov	r1, r0
    3b08:	2228      	movs	r2, #40	; 0x28
    3b0a:	4620      	mov	r0, r4
    3b0c:	4798      	blx	r3
    3b0e:	e435      	b.n	337c <loop+0x2c>
    3b10:	015d      	lsls	r5, r3, #5
    3b12:	0cdc      	lsrs	r4, r3, #19
    3b14:	f3c3 0ec7 	ubfx	lr, r3, #3, #8
    3b18:	b2ed      	uxtb	r5, r5
    3b1a:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    3b1e:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    memcpy(&val, &f, sizeof(val));

    int16_t exp = ((val >> 23) & 255);
    uint32_t mantissa = val & 0x7FFFFF;

    if (exp == 255)
    3b22:	267f      	movs	r6, #127	; 0x7f
    3b24:	e66c      	b.n	3800 <loop+0x4b0>
    3b26:	015d      	lsls	r5, r3, #5
    3b28:	0cdc      	lsrs	r4, r3, #19
    3b2a:	f3c3 0ec7 	ubfx	lr, r3, #3, #8
    3b2e:	b2ed      	uxtb	r5, r5
    3b30:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    3b34:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    3b38:	267f      	movs	r6, #127	; 0x7f
    3b3a:	e62b      	b.n	3794 <loop+0x444>
    3b3c:	015d      	lsls	r5, r3, #5
    3b3e:	0cdc      	lsrs	r4, r3, #19
    3b40:	f3c3 0ec7 	ubfx	lr, r3, #3, #8
    3b44:	b2ed      	uxtb	r5, r5
    3b46:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
    3b4a:	f3c3 23c7 	ubfx	r3, r3, #11, #8
    3b4e:	267f      	movs	r6, #127	; 0x7f
    3b50:	e68c      	b.n	386c <loop+0x51c>
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
        if ((checksum_ % 256) == 255)
    3b52:	3a01      	subs	r2, #1
    3b54:	f062 02ff 	orn	r2, r2, #255	; 0xff
    3b58:	3201      	adds	r2, #1
    3b5a:	e476      	b.n	344a <loop+0xfa>
    3b5c:	2210      	movs	r2, #16
    3b5e:	49d1      	ldr	r1, [pc, #836]	; (3ea4 <loop+0xb54>)
    3b60:	4798      	blx	r3
    3b62:	e4ec      	b.n	353e <loop+0x1ee>
    }
    else if (exp != 0)
    {
      exp += 1023 - 127; // Normal case
    }
    else if (!mantissa)
    3b64:	461e      	mov	r6, r3
    3b66:	461c      	mov	r4, r3
    3b68:	469e      	mov	lr, r3
    3b6a:	461d      	mov	r5, r3
    3b6c:	e67e      	b.n	386c <loop+0x51c>
    3b6e:	461e      	mov	r6, r3
    3b70:	461c      	mov	r4, r3
    3b72:	469e      	mov	lr, r3
    3b74:	461d      	mov	r5, r3
    3b76:	e643      	b.n	3800 <loop+0x4b0>
    3b78:	461e      	mov	r6, r3
    3b7a:	461c      	mov	r4, r3
    3b7c:	469e      	mov	lr, r3
    3b7e:	461d      	mov	r5, r3
    3b80:	e5d2      	b.n	3728 <loop+0x3d8>
    3b82:	461e      	mov	r6, r3
    3b84:	461c      	mov	r4, r3
    3b86:	469e      	mov	lr, r3
    3b88:	461d      	mov	r5, r3
    3b8a:	e603      	b.n	3794 <loop+0x444>
            req_param_resp.deserialize(message_in);
            param_received = true;
          }
          else if (topic_ == TopicInfo::ID_TX_STOP)
          {
            configured_ = false;
    3b8c:	2300      	movs	r3, #0
    3b8e:	f885 34f8 	strb.w	r3, [r5, #1272]	; 0x4f8
    3b92:	e40f      	b.n	33b4 <loop+0x64>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3b94:	683b      	ldr	r3, [r7, #0]
    3b96:	930e      	str	r3, [sp, #56]	; 0x38
	return ret;
    3b98:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  }

  void syncTime(uint8_t * data)
  {
    std_msgs::Time t;
    uint32_t offset = hardware_.time() - rt_time;
    3b9a:	68ea      	ldr	r2, [r5, #12]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3b9c:	6839      	ldr	r1, [r7, #0]
    3b9e:	9110      	str	r1, [sp, #64]	; 0x40
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    3ba0:	49c1      	ldr	r1, [pc, #772]	; (3ea8 <loop+0xb58>)
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    3ba2:	6a28      	ldr	r0, [r5, #32]
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    3ba4:	f8df c318 	ldr.w	ip, [pc, #792]	; 3ec0 <loop+0xb70>
	return ret;
    3ba8:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
  }

  void syncTime(uint8_t * data)
  {
    std_msgs::Time t;
    uint32_t offset = hardware_.time() - rt_time;
    3bac:	1a9b      	subs	r3, r3, r2
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    3bae:	fba1 1e03 	umull	r1, lr, r1, r3
    3bb2:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    3bb6:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    3bba:	4484      	add	ip, r0
    3bbc:	48bb      	ldr	r0, [pc, #748]	; (3eac <loop+0xb5c>)
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    3bbe:	69ea      	ldr	r2, [r5, #28]
    3bc0:	fb01 331e 	mls	r3, r1, lr, r3
    3bc4:	fb00 cc03 	mla	ip, r0, r3, ip
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    3bc8:	4bb7      	ldr	r3, [pc, #732]	; (3ea8 <loop+0xb58>)
    3bca:	fba3 3b09 	umull	r3, fp, r3, r9
    3bce:	ea4f 1b9b 	mov.w	fp, fp, lsr #6
    3bd2:	3a01      	subs	r2, #1
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    3bd4:	fb01 911b 	mls	r1, r1, fp, r9
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    3bd8:	4472      	add	r2, lr
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    3bda:	fb00 c311 	mls	r3, r0, r1, ip
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    3bde:	ebcb 0202 	rsb	r2, fp, r2
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    normalizeSecNSec(sec_offset, nsec_offset);
    3be2:	f10a 0114 	add.w	r1, sl, #20
    3be6:	f10a 0010 	add.w	r0, sl, #16

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    3bea:	616b      	str	r3, [r5, #20]
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    3bec:	612a      	str	r2, [r5, #16]
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    normalizeSecNSec(sec_offset, nsec_offset);
    3bee:	f001 ffaf 	bl	5b50 <ros::normalizeSecNSec(unsigned long&, unsigned long&)>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3bf2:	683b      	ldr	r3, [r7, #0]
    3bf4:	930f      	str	r3, [sp, #60]	; 0x3c
	return ret;
    3bf6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    t.deserialize(data);
    t.data.sec += offset / 1000;
    t.data.nsec += (offset % 1000) * 1000000UL;

    this->setNow(t.data);
    last_sync_receive_time = hardware_.time();
    3bf8:	f8c5 3500 	str.w	r3, [r5, #1280]	; 0x500
    3bfc:	f7ff bbda 	b.w	33b4 <loop+0x64>
    {
      int offset = 0;
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    3c00:	f8d5 901c 	ldr.w	r9, [r5, #28]
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
    3c04:	f8d5 3510 	ldr.w	r3, [r5, #1296]	; 0x510
    3c08:	4599      	cmp	r9, r3
    3c0a:	d907      	bls.n	3c1c <loop+0x8cc>
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
    3c0c:	ea4f 0189 	mov.w	r1, r9, lsl #2
    3c10:	f8d5 0518 	ldr.w	r0, [r5, #1304]	; 0x518
    3c14:	f005 ffc8 	bl	9ba8 <realloc>
    3c18:	f8c5 0518 	str.w	r0, [r5, #1304]	; 0x518
      ints_length = ints_lengthT;
    3c1c:	f8c4 9510 	str.w	r9, [r4, #1296]	; 0x510
      for( uint32_t i = 0; i < ints_length; i++){
    3c20:	f1b9 0f00 	cmp.w	r9, #0
    3c24:	f000 8101 	beq.w	3e2a <loop+0xada>
    3c28:	f8df 9298 	ldr.w	r9, [pc, #664]	; 3ec4 <loop+0xb74>
    3c2c:	f04f 0a04 	mov.w	sl, #4
    3c30:	f04f 0b00 	mov.w	fp, #0
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
    3c34:	f899 1022 	ldrb.w	r1, [r9, #34]	; 0x22
    3c38:	f899 3021 	ldrb.w	r3, [r9, #33]	; 0x21
    3c3c:	f899 2020 	ldrb.w	r2, [r9, #32]
    3c40:	f899 e023 	ldrb.w	lr, [r9, #35]	; 0x23
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
    3c44:	f8d4 0518 	ldr.w	r0, [r4, #1304]	; 0x518
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
    3c48:	0409      	lsls	r1, r1, #16
    3c4a:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
    3c4e:	4313      	orrs	r3, r2
    3c50:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
    3c54:	eb00 008b 	add.w	r0, r0, fp, lsl #2
    3c58:	4995      	ldr	r1, [pc, #596]	; (3eb0 <loop+0xb60>)
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
    3c5a:	f8c4 3514 	str.w	r3, [r4, #1300]	; 0x514
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
    3c5e:	2204      	movs	r2, #4
    3c60:	f001 ff8a 	bl	5b78 <memcpy>
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
      ints_length = ints_lengthT;
      for( uint32_t i = 0; i < ints_length; i++){
    3c64:	f8d4 3510 	ldr.w	r3, [r4, #1296]	; 0x510
    3c68:	f10b 0b01 	add.w	fp, fp, #1
    3c6c:	455b      	cmp	r3, fp
    3c6e:	4651      	mov	r1, sl
    3c70:	f109 0904 	add.w	r9, r9, #4
    3c74:	f10a 0a04 	add.w	sl, sl, #4
    3c78:	d8dc      	bhi.n	3c34 <loop+0x8e4>
    3c7a:	f101 0b08 	add.w	fp, r1, #8
    3c7e:	f101 000b 	add.w	r0, r1, #11
    3c82:	f101 0e05 	add.w	lr, r1, #5
    3c86:	f101 0c06 	add.w	ip, r1, #6
    3c8a:	f101 0907 	add.w	r9, r1, #7
    3c8e:	f101 0309 	add.w	r3, r1, #9
    3c92:	f101 020a 	add.w	r2, r1, #10
    3c96:	310c      	adds	r1, #12
    3c98:	f8cd a008 	str.w	sl, [sp, #8]
    3c9c:	9000      	str	r0, [sp, #0]
    3c9e:	46da      	mov	sl, fp
    3ca0:	9104      	str	r1, [sp, #16]
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    3ca2:	44a4      	add	ip, r4
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    3ca4:	9802      	ldr	r0, [sp, #8]
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    3ca6:	f89c c01c 	ldrb.w	ip, [ip, #28]
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
    3caa:	44a6      	add	lr, r4
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    3cac:	4420      	add	r0, r4
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    3cae:	f89e 101c 	ldrb.w	r1, [lr, #28]
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    3cb2:	7f00      	ldrb	r0, [r0, #28]
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    3cb4:	44a1      	add	r9, r4
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    3cb6:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
    3cba:	ea4c 2c01 	orr.w	ip, ip, r1, lsl #8
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    3cbe:	f899 e01c 	ldrb.w	lr, [r9, #28]
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
    3cc2:	f8d4 151c 	ldr.w	r1, [r4, #1308]	; 0x51c
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    3cc6:	ea4c 0c00 	orr.w	ip, ip, r0
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    3cca:	ea4c 690e 	orr.w	r9, ip, lr, lsl #24
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
    3cce:	4589      	cmp	r9, r1
    3cd0:	d90b      	bls.n	3cea <loop+0x99a>
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
    3cd2:	ea4f 0189 	mov.w	r1, r9, lsl #2
    3cd6:	f8d5 0524 	ldr.w	r0, [r5, #1316]	; 0x524
    3cda:	9305      	str	r3, [sp, #20]
    3cdc:	9202      	str	r2, [sp, #8]
    3cde:	f005 ff63 	bl	9ba8 <realloc>
    3ce2:	9b05      	ldr	r3, [sp, #20]
    3ce4:	9a02      	ldr	r2, [sp, #8]
    3ce6:	f8c5 0524 	str.w	r0, [r5, #1316]	; 0x524
      floats_length = floats_lengthT;
    3cea:	f8c4 951c 	str.w	r9, [r4, #1308]	; 0x51c
      for( uint32_t i = 0; i < floats_length; i++){
    3cee:	f1b9 0f00 	cmp.w	r9, #0
    3cf2:	f000 8097 	beq.w	3e24 <loop+0xad4>
    3cf6:	eb05 0b0a 	add.w	fp, r5, sl
    3cfa:	f04f 0900 	mov.w	r9, #0
    3cfe:	9600      	str	r6, [sp, #0]
      } u_st_floats;
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    3d00:	f89b 101e 	ldrb.w	r1, [fp, #30]
    3d04:	f89b 301d 	ldrb.w	r3, [fp, #29]
    3d08:	f89b 201c 	ldrb.w	r2, [fp, #28]
    3d0c:	f89b e01f 	ldrb.w	lr, [fp, #31]
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    3d10:	f8d4 0524 	ldr.w	r0, [r4, #1316]	; 0x524
      } u_st_floats;
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    3d14:	0409      	lsls	r1, r1, #16
    3d16:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
    3d1a:	4313      	orrs	r3, r2
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    3d1c:	4965      	ldr	r1, [pc, #404]	; (3eb4 <loop+0xb64>)
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
    3d1e:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
    3d22:	600b      	str	r3, [r1, #0]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    3d24:	eb00 0089 	add.w	r0, r0, r9, lsl #2
    3d28:	2204      	movs	r2, #4
    3d2a:	f001 ff25 	bl	5b78 <memcpy>
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
      floats_length = floats_lengthT;
      for( uint32_t i = 0; i < floats_length; i++){
    3d2e:	f8d4 351c 	ldr.w	r3, [r4, #1308]	; 0x51c
    3d32:	f109 0901 	add.w	r9, r9, #1
    3d36:	454b      	cmp	r3, r9
    3d38:	4651      	mov	r1, sl
    3d3a:	f10b 0b04 	add.w	fp, fp, #4
    3d3e:	f10a 0a04 	add.w	sl, sl, #4
    3d42:	d8dd      	bhi.n	3d00 <loop+0x9b0>
    3d44:	1dc8      	adds	r0, r1, #7
    3d46:	9e00      	ldr	r6, [sp, #0]
    3d48:	9000      	str	r0, [sp, #0]
    3d4a:	46d3      	mov	fp, sl
    3d4c:	1d4b      	adds	r3, r1, #5
    3d4e:	1d8a      	adds	r2, r1, #6
    3d50:	f101 0908 	add.w	r9, r1, #8
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    3d54:	4422      	add	r2, r4
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
    3d56:	4423      	add	r3, r4
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    3d58:	7f11      	ldrb	r1, [r2, #28]
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    3d5a:	9a00      	ldr	r2, [sp, #0]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    3d5c:	7f18      	ldrb	r0, [r3, #28]
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
    3d5e:	f8d4 3528 	ldr.w	r3, [r4, #1320]	; 0x528
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    3d62:	4422      	add	r2, r4
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    3d64:	44a3      	add	fp, r4
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    3d66:	4696      	mov	lr, r2
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    3d68:	0409      	lsls	r1, r1, #16
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    3d6a:	f89b 201c 	ldrb.w	r2, [fp, #28]
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    3d6e:	f89e a01c 	ldrb.w	sl, [lr, #28]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    3d72:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
    3d76:	430a      	orrs	r2, r1
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    3d78:	ea42 6a0a 	orr.w	sl, r2, sl, lsl #24
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
    3d7c:	459a      	cmp	sl, r3
    3d7e:	d907      	bls.n	3d90 <loop+0xa40>
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
    3d80:	ea4f 018a 	mov.w	r1, sl, lsl #2
    3d84:	f8d5 0530 	ldr.w	r0, [r5, #1328]	; 0x530
    3d88:	f005 ff0e 	bl	9ba8 <realloc>
    3d8c:	f8c5 0530 	str.w	r0, [r5, #1328]	; 0x530
      strings_length = strings_lengthT;
    3d90:	f8c4 a528 	str.w	sl, [r4, #1320]	; 0x528
      for( uint32_t i = 0; i < strings_length; i++){
    3d94:	f1ba 0f00 	cmp.w	sl, #0
    3d98:	d037      	beq.n	3e0a <loop+0xaba>
    3d9a:	f04f 0b00 	mov.w	fp, #0
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    3d9e:	46da      	mov	sl, fp
    3da0:	f109 011c 	add.w	r1, r9, #28
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
      uint32_t length_st_strings;
      arrToVar(length_st_strings, (inbuffer + offset));
    3da4:	2300      	movs	r3, #0
    3da6:	4421      	add	r1, r4

  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    3da8:	469e      	mov	lr, r3
    for (size_t i = 0; i < sizeof(V); i++)
      var |= (arr[i] << (8 * i));
    3daa:	f811 2b01 	ldrb.w	r2, [r1], #1
    3dae:	409a      	lsls	r2, r3
    3db0:	3308      	adds	r3, #8
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
    3db2:	2b20      	cmp	r3, #32
      var |= (arr[i] << (8 * i));
    3db4:	ea4e 0e02 	orr.w	lr, lr, r2
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
    3db8:	d1f7      	bne.n	3daa <loop+0xa5a>
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
    3dba:	f109 0004 	add.w	r0, r9, #4
    3dbe:	4486      	add	lr, r0
    3dc0:	4586      	cmp	lr, r0
    3dc2:	d909      	bls.n	3dd8 <loop+0xa88>
    3dc4:	f109 031f 	add.w	r3, r9, #31
    3dc8:	4423      	add	r3, r4
    3dca:	4602      	mov	r2, r0
    3dcc:	3201      	adds	r2, #1
          inbuffer[k-1]=inbuffer[k];
    3dce:	7859      	ldrb	r1, [r3, #1]
    3dd0:	f803 1b01 	strb.w	r1, [r3], #1
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
      uint32_t length_st_strings;
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
    3dd4:	4596      	cmp	lr, r2
    3dd6:	d8f9      	bhi.n	3dcc <loop+0xa7c>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    3dd8:	eb04 020e 	add.w	r2, r4, lr
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    3ddc:	4936      	ldr	r1, [pc, #216]	; (3eb8 <loop+0xb68>)
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    3dde:	f882 a01b 	strb.w	sl, [r2, #27]
      this->st_strings = (char *)(inbuffer + offset-1);
    3de2:	1e43      	subs	r3, r0, #1
    3de4:	f5a1 62a2 	sub.w	r2, r1, #1296	; 0x510
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    3de8:	f8d4 0530 	ldr.w	r0, [r4, #1328]	; 0x530
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
    3dec:	4413      	add	r3, r2
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    3dee:	eb00 008b 	add.w	r0, r0, fp, lsl #2
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
    3df2:	f8c4 352c 	str.w	r3, [r4, #1324]	; 0x52c
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    3df6:	2204      	movs	r2, #4
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
    3df8:	46f1      	mov	r9, lr
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    3dfa:	f001 febd 	bl	5b78 <memcpy>
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
    3dfe:	f8d4 3528 	ldr.w	r3, [r4, #1320]	; 0x528
    3e02:	f10b 0b01 	add.w	fp, fp, #1
    3e06:	455b      	cmp	r3, fp
    3e08:	d8ca      	bhi.n	3da0 <loop+0xa50>
            syncTime(message_in);
          }
          else if (topic_ == TopicInfo::ID_PARAMETER_REQUEST)
          {
            req_param_resp.deserialize(message_in);
            param_received = true;
    3e0a:	2301      	movs	r3, #1
    3e0c:	f884 3508 	strb.w	r3, [r4, #1288]	; 0x508
    3e10:	f7ff bad0 	b.w	33b4 <loop+0x64>
    else
    {
      // Denormalized value in float, will fit as normalized value in double
      exp += 1023 - 127;
      mantissa <<= 1;
      while (!(mantissa & 0x800000))
    3e14:	2638      	movs	r6, #56	; 0x38
    3e16:	e610      	b.n	3a3a <loop+0x6ea>
    3e18:	2638      	movs	r6, #56	; 0x38
    3e1a:	e666      	b.n	3aea <loop+0x79a>
    3e1c:	2638      	movs	r6, #56	; 0x38
    3e1e:	e647      	b.n	3ab0 <loop+0x760>
    3e20:	2638      	movs	r6, #56	; 0x38
    3e22:	e628      	b.n	3a76 <loop+0x726>
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
      floats_length = floats_lengthT;
      for( uint32_t i = 0; i < floats_length; i++){
    3e24:	f8dd 9010 	ldr.w	r9, [sp, #16]
    3e28:	e794      	b.n	3d54 <loop+0xa04>
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
      ints_length = ints_lengthT;
      for( uint32_t i = 0; i < ints_length; i++){
    3e2a:	230c      	movs	r3, #12
    3e2c:	f04f 0b08 	mov.w	fp, #8
    3e30:	9304      	str	r3, [sp, #16]
    3e32:	2104      	movs	r1, #4
    3e34:	230b      	movs	r3, #11
    3e36:	9300      	str	r3, [sp, #0]
    3e38:	46da      	mov	sl, fp
    3e3a:	220a      	movs	r2, #10
    3e3c:	2309      	movs	r3, #9
    3e3e:	f04f 0907 	mov.w	r9, #7
    3e42:	f04f 0c06 	mov.w	ip, #6
    3e46:	f04f 0e05 	mov.w	lr, #5
    3e4a:	9102      	str	r1, [sp, #8]
    3e4c:	e729      	b.n	3ca2 <loop+0x952>
    3e4e:	469b      	mov	fp, r3
  {
    if (id >= 100 && !configured_)
      return 0;

    /* serialize message */
    int l = msg->serialize(message_out + 7);
    3e50:	f20a 2123 	addw	r1, sl, #547	; 0x223
    public:
      typedef ros::Time _data_type;
      _data_type data;

    Time():
      data()
    3e54:	4b19      	ldr	r3, [pc, #100]	; (3ebc <loop+0xb6c>)
    3e56:	9311      	str	r3, [sp, #68]	; 0x44
    3e58:	a811      	add	r0, sp, #68	; 0x44
    3e5a:	4691      	mov	r9, r2
class Time
{
public:
  uint32_t sec, nsec;

  Time() : sec(0), nsec(0) {}
    3e5c:	f8cd b048 	str.w	fp, [sp, #72]	; 0x48
    3e60:	f8cd b04c 	str.w	fp, [sp, #76]	; 0x4c
    3e64:	f7fc fb02 	bl	46c <std_msgs::Time::serialize(unsigned char*) const>

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3e68:	b2c1      	uxtb	r1, r0
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3e6a:	f3c0 2207 	ubfx	r2, r0, #8, #8
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3e6e:	188b      	adds	r3, r1, r2
    3e70:	43db      	mvns	r3, r3
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3e72:	f88a 121e 	strb.w	r1, [sl, #542]	; 0x21e
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    3e76:	25fe      	movs	r5, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3e78:	f88a 3220 	strb.w	r3, [sl, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3e7c:	210a      	movs	r1, #10
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3e7e:	1c43      	adds	r3, r0, #1

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3e80:	f88a 921c 	strb.w	r9, [sl, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3e84:	f88a b222 	strb.w	fp, [sl, #546]	; 0x222

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3e88:	f88a 221f 	strb.w	r2, [sl, #543]	; 0x21f
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    3e8c:	f88a 521d 	strb.w	r5, [sl, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3e90:	f88a 1221 	strb.w	r1, [sl, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3e94:	db21      	blt.n	3eda <loop+0xb8a>
    3e96:	f200 2522 	addw	r5, r0, #546	; 0x222
    3e9a:	465b      	mov	r3, fp
    3e9c:	4455      	add	r5, sl
    3e9e:	f20a 2221 	addw	r2, sl, #545	; 0x221
    3ea2:	e013      	b.n	3ecc <loop+0xb7c>
    3ea4:	1fff1fa4 	.word	0x1fff1fa4
    3ea8:	10624dd3 	.word	0x10624dd3
    3eac:	000f4240 	.word	0x000f4240
    3eb0:	1fff229c 	.word	0x1fff229c
    3eb4:	1fff22a8 	.word	0x1fff22a8
    3eb8:	1fff22b4 	.word	0x1fff22b4
    3ebc:	0000a7bc 	.word	0x0000a7bc
    3ec0:	3b9aca00 	.word	0x3b9aca00
    3ec4:	1fff1d88 	.word	0x1fff1d88
    3ec8:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    3ecc:	42aa      	cmp	r2, r5
      chk += message_out[i];
    3ece:	440b      	add	r3, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3ed0:	d1fa      	bne.n	3ec8 <loop+0xb78>
    3ed2:	ea6f 0903 	mvn.w	r9, r3
    3ed6:	fa5f f989 	uxtb.w	r9, r9
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3eda:	1823      	adds	r3, r4, r0
    3edc:	f100 0208 	add.w	r2, r0, #8

    if (l <= OUTPUT_SIZE)
    3ee0:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3ee4:	f883 9223 	strb.w	r9, [r3, #547]	; 0x223
    3ee8:	49d1      	ldr	r1, [pc, #836]	; (4230 <loop+0xee0>)

    if (l <= OUTPUT_SIZE)
    3eea:	f300 8247 	bgt.w	437c <loop+0x102c>
    3eee:	6848      	ldr	r0, [r1, #4]
    3ef0:	6803      	ldr	r3, [r0, #0]
    3ef2:	f501 7107 	add.w	r1, r1, #540	; 0x21c
    3ef6:	685b      	ldr	r3, [r3, #4]
    3ef8:	4798      	blx	r3
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3efa:	683b      	ldr	r3, [r7, #0]
    3efc:	930a      	str	r3, [sp, #40]	; 0x28
    3efe:	4fcd      	ldr	r7, [pc, #820]	; (4234 <loop+0xee4>)
	return ret;
    3f00:	9b0a      	ldr	r3, [sp, #40]	; 0x28

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    rt_time = hardware_.time();
    3f02:	60e3      	str	r3, [r4, #12]
    3f04:	f107 0364 	add.w	r3, r7, #100	; 0x64
    3f08:	9300      	str	r3, [sp, #0]
      memcpy(outbuffer + offset, this->message_type, length_message_type);
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    3f0a:	f5a7 6583 	sub.w	r5, r7, #1048	; 0x418
  {
    rosserial_msgs::TopicInfo ti;
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
    3f0e:	f857 3f04 	ldr.w	r3, [r7, #4]!
    3f12:	2b00      	cmp	r3, #0
    3f14:	f000 80b8 	beq.w	4088 <loop+0xd38>
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    3f18:	6858      	ldr	r0, [r3, #4]
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
    3f1a:	689a      	ldr	r2, [r3, #8]
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    3f1c:	6801      	ldr	r1, [r0, #0]
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
    3f1e:	9202      	str	r2, [sp, #8]
        ti.topic_name = (char *) publishers[i]->topic_;
    3f20:	f8d3 b000 	ldr.w	fp, [r3]
        ti.message_type = (char *) publishers[i]->msg_->getType();
    3f24:	688b      	ldr	r3, [r1, #8]
    3f26:	4798      	blx	r3
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    3f28:	683b      	ldr	r3, [r7, #0]
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    3f2a:	4682      	mov	sl, r0
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    3f2c:	6858      	ldr	r0, [r3, #4]
    3f2e:	6803      	ldr	r3, [r0, #0]
    3f30:	68db      	ldr	r3, [r3, #12]
    3f32:	4798      	blx	r3
    3f34:	683b      	ldr	r3, [r7, #0]
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    3f36:	9a02      	ldr	r2, [sp, #8]
    3f38:	f8d3 8010 	ldr.w	r8, [r3, #16]
    3f3c:	f1b8 0f63 	cmp.w	r8, #99	; 0x63
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    3f40:	4681      	mov	r9, r0
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    3f42:	dd04      	ble.n	3f4e <loop+0xbfe>
    3f44:	f894 34f8 	ldrb.w	r3, [r4, #1272]	; 0x4f8
    3f48:	2b00      	cmp	r3, #0
    3f4a:	f000 809d 	beq.w	4088 <loop+0xd38>

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    3f4e:	f3c2 2307 	ubfx	r3, r2, #8, #8
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    3f52:	f884 2223 	strb.w	r2, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    3f56:	f884 3224 	strb.w	r3, [r4, #548]	; 0x224
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    3f5a:	4658      	mov	r0, fp
    3f5c:	f006 fa10 	bl	a380 <strlen>
    3f60:	4603      	mov	r3, r0
  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
      arr[i] = (var >> (8 * i));
    3f62:	ea4f 6e13 	mov.w	lr, r3, lsr #24
    3f66:	0a02      	lsrs	r2, r0, #8
    3f68:	0c00      	lsrs	r0, r0, #16
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
    3f6a:	4659      	mov	r1, fp
    3f6c:	f884 3225 	strb.w	r3, [r4, #549]	; 0x225
    3f70:	f884 2226 	strb.w	r2, [r4, #550]	; 0x226
    3f74:	f884 0227 	strb.w	r0, [r4, #551]	; 0x227
    3f78:	461a      	mov	r2, r3
    3f7a:	f884 e228 	strb.w	lr, [r4, #552]	; 0x228
    3f7e:	48ae      	ldr	r0, [pc, #696]	; (4238 <loop+0xee8>)
    3f80:	9302      	str	r3, [sp, #8]
    3f82:	f001 fdf9 	bl	5b78 <memcpy>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
    3f86:	4650      	mov	r0, sl
    3f88:	f006 f9fa 	bl	a380 <strlen>
    3f8c:	9b02      	ldr	r3, [sp, #8]
    3f8e:	4602      	mov	r2, r0
    3f90:	f203 2029 	addw	r0, r3, #553	; 0x229
    3f94:	4420      	add	r0, r4
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
    3f96:	3306      	adds	r3, #6
      uint32_t length_message_type = strlen(this->message_type);
    3f98:	2100      	movs	r1, #0
    3f9a:	fa22 fe01 	lsr.w	lr, r2, r1
    3f9e:	3108      	adds	r1, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3fa0:	2920      	cmp	r1, #32
      arr[i] = (var >> (8 * i));
    3fa2:	f800 eb01 	strb.w	lr, [r0], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3fa6:	d1f8      	bne.n	3f9a <loop+0xc4a>
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    3fa8:	48a4      	ldr	r0, [pc, #656]	; (423c <loop+0xeec>)
    3faa:	3304      	adds	r3, #4
    3fac:	4651      	mov	r1, sl
    3fae:	4418      	add	r0, r3
      offset += length_message_type;
    3fb0:	eb02 0a03 	add.w	sl, r2, r3
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    3fb4:	f001 fde0 	bl	5b78 <memcpy>
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
    3fb8:	4648      	mov	r0, r9
    3fba:	f006 f9e1 	bl	a380 <strlen>
    3fbe:	f20a 2223 	addw	r2, sl, #547	; 0x223
    3fc2:	4683      	mov	fp, r0
    3fc4:	4422      	add	r2, r4
    3fc6:	2300      	movs	r3, #0
      arr[i] = (var >> (8 * i));
    3fc8:	fa2b f103 	lsr.w	r1, fp, r3
    3fcc:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3fce:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
    3fd0:	f802 1b01 	strb.w	r1, [r2], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3fd4:	d1f8      	bne.n	3fc8 <loop+0xc78>
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    3fd6:	4b99      	ldr	r3, [pc, #612]	; (423c <loop+0xeec>)
    3fd8:	f10a 0a04 	add.w	sl, sl, #4
    3fdc:	4649      	mov	r1, r9
    3fde:	eb03 000a 	add.w	r0, r3, sl
    3fe2:	465a      	mov	r2, fp
    3fe4:	f001 fdc8 	bl	5b78 <memcpy>
      offset += length_md5sum;
    3fe8:	eb0b 000a 	add.w	r0, fp, sl
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
    3fec:	f100 0e04 	add.w	lr, r0, #4
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    3ff0:	1821      	adds	r1, r4, r0
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3ff2:	fa5f f98e 	uxtb.w	r9, lr
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3ff6:	f3ce 2c07 	ubfx	ip, lr, #8, #8
    3ffa:	2200      	movs	r2, #0
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    3ffc:	2302      	movs	r3, #2
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3ffe:	eb09 0b0c 	add.w	fp, r9, ip
    4002:	f881 3224 	strb.w	r3, [r1, #548]	; 0x224
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    4006:	f881 2223 	strb.w	r2, [r1, #547]	; 0x223
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
    400a:	f881 2225 	strb.w	r2, [r1, #549]	; 0x225
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
    400e:	f881 2226 	strb.w	r2, [r1, #550]	; 0x226
    4012:	ea6f 0b0b 	mvn.w	fp, fp
    message_out[5] = (uint8_t)((int16_t)id & 255);
    4016:	fa5f f188 	uxtb.w	r1, r8

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    401a:	23ff      	movs	r3, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    401c:	f04f 0afe 	mov.w	sl, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    4020:	f348 2807 	sbfx	r8, r8, #8, #8

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    4024:	f1be 3fff 	cmp.w	lr, #4294967295	; 0xffffffff
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    4028:	f884 b220 	strb.w	fp, [r4, #544]	; 0x220
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    402c:	f884 921e 	strb.w	r9, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    4030:	f884 c21f 	strb.w	ip, [r4, #543]	; 0x21f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    4034:	f884 321c 	strb.w	r3, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    4038:	f884 a21d 	strb.w	sl, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    403c:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    4040:	f884 8222 	strb.w	r8, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    4044:	db0b      	blt.n	405e <loop+0xd0e>
    4046:	f200 2026 	addw	r0, r0, #550	; 0x226
    404a:	4b7d      	ldr	r3, [pc, #500]	; (4240 <loop+0xef0>)
    404c:	4428      	add	r0, r5
    404e:	e001      	b.n	4054 <loop+0xd04>
    4050:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    4054:	4283      	cmp	r3, r0
      chk += message_out[i];
    4056:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    4058:	d1fa      	bne.n	4050 <loop+0xd00>
    405a:	43d3      	mvns	r3, r2
    405c:	b2db      	uxtb	r3, r3
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    405e:	eb04 010e 	add.w	r1, r4, lr
    4062:	f10e 0208 	add.w	r2, lr, #8

    if (l <= OUTPUT_SIZE)
    4066:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    406a:	f881 3223 	strb.w	r3, [r1, #547]	; 0x223

    if (l <= OUTPUT_SIZE)
    406e:	f300 8139 	bgt.w	42e4 <loop+0xf94>
    4072:	6868      	ldr	r0, [r5, #4]
    4074:	4973      	ldr	r1, [pc, #460]	; (4244 <loop+0xef4>)
    4076:	6803      	ldr	r3, [r0, #0]
    4078:	685b      	ldr	r3, [r3, #4]
    407a:	428b      	cmp	r3, r1
    407c:	f040 80e8 	bne.w	4250 <loop+0xf00>
    4080:	4611      	mov	r1, r2
    4082:	4871      	ldr	r0, [pc, #452]	; (4248 <loop+0xef8>)
    4084:	f003 f890 	bl	71a8 <usb_serial_write>

  void negotiateTopics()
  {
    rosserial_msgs::TopicInfo ti;
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    4088:	9b00      	ldr	r3, [sp, #0]
    408a:	429f      	cmp	r7, r3
    408c:	f47f af3f 	bne.w	3f0e <loop+0xbbe>
    4090:	f8df b1b8 	ldr.w	fp, [pc, #440]	; 424c <loop+0xefc>
      memcpy(outbuffer + offset, this->message_type, length_message_type);
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    4094:	9602      	str	r6, [sp, #8]
    4096:	f5ab 659c 	sub.w	r5, fp, #1248	; 0x4e0
    409a:	461e      	mov	r6, r3
        publish(publishers[i]->getEndpointType(), &ti);
      }
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
    409c:	f856 0f04 	ldr.w	r0, [r6, #4]!
    40a0:	2800      	cmp	r0, #0
    40a2:	f000 80b4 	beq.w	420e <loop+0xebe>
      {
        ti.topic_id = subscribers[i]->id_;
    40a6:	e890 000c 	ldmia.w	r0, {r2, r3}
    40aa:	9300      	str	r3, [sp, #0]
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
    40ac:	6892      	ldr	r2, [r2, #8]
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
    40ae:	f8d0 a008 	ldr.w	sl, [r0, #8]
        ti.message_type = (char *) subscribers[i]->getMsgType();
    40b2:	4790      	blx	r2
    40b4:	4681      	mov	r9, r0
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
    40b6:	6830      	ldr	r0, [r6, #0]
    40b8:	6802      	ldr	r2, [r0, #0]
    40ba:	68d2      	ldr	r2, [r2, #12]
    40bc:	4790      	blx	r2
    40be:	4680      	mov	r8, r0
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
    40c0:	6830      	ldr	r0, [r6, #0]
    40c2:	6802      	ldr	r2, [r0, #0]
    40c4:	6852      	ldr	r2, [r2, #4]
    40c6:	4790      	blx	r2
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    40c8:	2863      	cmp	r0, #99	; 0x63
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
    40ca:	4607      	mov	r7, r0
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    40cc:	9b00      	ldr	r3, [sp, #0]
    40ce:	dd04      	ble.n	40da <loop+0xd8a>
    40d0:	f894 24f8 	ldrb.w	r2, [r4, #1272]	; 0x4f8
    40d4:	2a00      	cmp	r2, #0
    40d6:	f000 809a 	beq.w	420e <loop+0xebe>

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    40da:	f3c3 2207 	ubfx	r2, r3, #8, #8
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    40de:	f884 3223 	strb.w	r3, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    40e2:	f884 2224 	strb.w	r2, [r4, #548]	; 0x224
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    40e6:	4650      	mov	r0, sl
    40e8:	f006 f94a 	bl	a380 <strlen>
    40ec:	4603      	mov	r3, r0
      arr[i] = (var >> (8 * i));
    40ee:	ea4f 6e13 	mov.w	lr, r3, lsr #24
    40f2:	0a02      	lsrs	r2, r0, #8
    40f4:	0c00      	lsrs	r0, r0, #16
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
    40f6:	4651      	mov	r1, sl
    40f8:	f884 3225 	strb.w	r3, [r4, #549]	; 0x225
    40fc:	f884 2226 	strb.w	r2, [r4, #550]	; 0x226
    4100:	f884 0227 	strb.w	r0, [r4, #551]	; 0x227
    4104:	461a      	mov	r2, r3
    4106:	f884 e228 	strb.w	lr, [r4, #552]	; 0x228
    410a:	484b      	ldr	r0, [pc, #300]	; (4238 <loop+0xee8>)
    410c:	9300      	str	r3, [sp, #0]
    410e:	f001 fd33 	bl	5b78 <memcpy>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
    4112:	4648      	mov	r0, r9
    4114:	f006 f934 	bl	a380 <strlen>
    4118:	9b00      	ldr	r3, [sp, #0]
    411a:	4602      	mov	r2, r0
    411c:	f203 2029 	addw	r0, r3, #553	; 0x229
    4120:	4420      	add	r0, r4
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
    4122:	3306      	adds	r3, #6
      uint32_t length_message_type = strlen(this->message_type);
    4124:	2100      	movs	r1, #0
    4126:	fa22 fe01 	lsr.w	lr, r2, r1
    412a:	3108      	adds	r1, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    412c:	2920      	cmp	r1, #32
      arr[i] = (var >> (8 * i));
    412e:	f800 eb01 	strb.w	lr, [r0], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    4132:	d1f8      	bne.n	4126 <loop+0xdd6>
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    4134:	4841      	ldr	r0, [pc, #260]	; (423c <loop+0xeec>)
    4136:	3304      	adds	r3, #4
    4138:	4649      	mov	r1, r9
    413a:	4418      	add	r0, r3
      offset += length_message_type;
    413c:	eb02 0903 	add.w	r9, r2, r3
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    4140:	f001 fd1a 	bl	5b78 <memcpy>
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
    4144:	4640      	mov	r0, r8
    4146:	f006 f91b 	bl	a380 <strlen>
    414a:	f209 2223 	addw	r2, r9, #547	; 0x223
    414e:	4682      	mov	sl, r0
    4150:	4422      	add	r2, r4
    4152:	2300      	movs	r3, #0
      arr[i] = (var >> (8 * i));
    4154:	fa2a f103 	lsr.w	r1, sl, r3
    4158:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    415a:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
    415c:	f802 1b01 	strb.w	r1, [r2], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    4160:	d1f8      	bne.n	4154 <loop+0xe04>
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    4162:	4b36      	ldr	r3, [pc, #216]	; (423c <loop+0xeec>)
    4164:	f109 0904 	add.w	r9, r9, #4
    4168:	4641      	mov	r1, r8
    416a:	eb03 0009 	add.w	r0, r3, r9
    416e:	4652      	mov	r2, sl
    4170:	f001 fd02 	bl	5b78 <memcpy>
      offset += length_md5sum;
    4174:	eb0a 0009 	add.w	r0, sl, r9
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
    4178:	f100 0e04 	add.w	lr, r0, #4
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    417c:	fa5f f88e 	uxtb.w	r8, lr
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    4180:	f3ce 2c07 	ubfx	ip, lr, #8, #8
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    4184:	eb04 0900 	add.w	r9, r4, r0
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    4188:	eb08 010c 	add.w	r1, r8, ip
    418c:	2200      	movs	r2, #0
    418e:	43c9      	mvns	r1, r1
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    4190:	2302      	movs	r3, #2
    4192:	f889 3224 	strb.w	r3, [r9, #548]	; 0x224
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    4196:	f889 2223 	strb.w	r2, [r9, #547]	; 0x223
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
    419a:	f889 2225 	strb.w	r2, [r9, #549]	; 0x225
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
    419e:	f889 2226 	strb.w	r2, [r9, #550]	; 0x226

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    41a2:	23ff      	movs	r3, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    41a4:	f04f 09fe 	mov.w	r9, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    41a8:	f884 1220 	strb.w	r1, [r4, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    41ac:	f1be 3fff 	cmp.w	lr, #4294967295	; 0xffffffff
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    41b0:	b2f9      	uxtb	r1, r7
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    41b2:	f347 2707 	sbfx	r7, r7, #8, #8
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    41b6:	f884 821e 	strb.w	r8, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    41ba:	f884 c21f 	strb.w	ip, [r4, #543]	; 0x21f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    41be:	f884 321c 	strb.w	r3, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    41c2:	f884 921d 	strb.w	r9, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    41c6:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    41ca:	f884 7222 	strb.w	r7, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    41ce:	db0b      	blt.n	41e8 <loop+0xe98>
    41d0:	f200 2026 	addw	r0, r0, #550	; 0x226
    41d4:	4b1a      	ldr	r3, [pc, #104]	; (4240 <loop+0xef0>)
    41d6:	4428      	add	r0, r5
    41d8:	e001      	b.n	41de <loop+0xe8e>
    41da:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    41de:	4283      	cmp	r3, r0
      chk += message_out[i];
    41e0:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    41e2:	d1fa      	bne.n	41da <loop+0xe8a>
    41e4:	43d3      	mvns	r3, r2
    41e6:	b2db      	uxtb	r3, r3
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    41e8:	eb04 010e 	add.w	r1, r4, lr
    41ec:	f10e 0208 	add.w	r2, lr, #8

    if (l <= OUTPUT_SIZE)
    41f0:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    41f4:	f881 3223 	strb.w	r3, [r1, #547]	; 0x223

    if (l <= OUTPUT_SIZE)
    41f8:	dc2d      	bgt.n	4256 <loop+0xf06>
    41fa:	6868      	ldr	r0, [r5, #4]
    41fc:	4911      	ldr	r1, [pc, #68]	; (4244 <loop+0xef4>)
    41fe:	6803      	ldr	r3, [r0, #0]
    4200:	685b      	ldr	r3, [r3, #4]
    4202:	428b      	cmp	r3, r1
    4204:	d110      	bne.n	4228 <loop+0xed8>
    4206:	4611      	mov	r1, r2
    4208:	480f      	ldr	r0, [pc, #60]	; (4248 <loop+0xef8>)
    420a:	f002 ffcd 	bl	71a8 <usb_serial_write>
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
        ti.buffer_size = OUTPUT_SIZE;
        publish(publishers[i]->getEndpointType(), &ti);
      }
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    420e:	455e      	cmp	r6, fp
    4210:	f47f af44 	bne.w	409c <loop+0xd4c>
    4214:	9e02      	ldr	r6, [sp, #8]
        {
          if (topic_ == TopicInfo::ID_PUBLISHER)
          {
            requestSyncTime();
            negotiateTopics();
            last_sync_time = c_time;
    4216:	f8c4 64fc 	str.w	r6, [r4, #1276]	; 0x4fc
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
      }
    }
    configured_ = true;
    421a:	2301      	movs	r3, #1
          if (topic_ == TopicInfo::ID_PUBLISHER)
          {
            requestSyncTime();
            negotiateTopics();
            last_sync_time = c_time;
            last_sync_receive_time = c_time;
    421c:	f8c4 6500 	str.w	r6, [r4, #1280]	; 0x500
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
      }
    }
    configured_ = true;
    4220:	f884 34f8 	strb.w	r3, [r4, #1272]	; 0x4f8
    4224:	f7ff b8f0 	b.w	3408 <loop+0xb8>
    4228:	4907      	ldr	r1, [pc, #28]	; (4248 <loop+0xef8>)
    422a:	4798      	blx	r3
    422c:	e7ef      	b.n	420e <loop+0xebe>
    422e:	bf00      	nop
    4230:	1fff1d88 	.word	0x1fff1d88
    4234:	1fff21a0 	.word	0x1fff21a0
    4238:	1fff1fb1 	.word	0x1fff1fb1
    423c:	1fff1fab 	.word	0x1fff1fab
    4240:	1fff1fa9 	.word	0x1fff1fa9
    4244:	00000c49 	.word	0x00000c49
    4248:	1fff1fa4 	.word	0x1fff1fa4
    424c:	1fff2268 	.word	0x1fff2268
    4250:	494c      	ldr	r1, [pc, #304]	; (4384 <loop+0x1034>)
    4252:	4798      	blx	r3
    4254:	e718      	b.n	4088 <loop+0xd38>
    4256:	f8df e134 	ldr.w	lr, [pc, #308]	; 438c <loop+0x103c>
    425a:	4f4b      	ldr	r7, [pc, #300]	; (4388 <loop+0x1038>)
    425c:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    4260:	c70f      	stmia	r7!, {r0, r1, r2, r3}
    4262:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    4266:	c70f      	stmia	r7!, {r0, r1, r2, r3}
    4268:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    426c:	c70f      	stmia	r7!, {r0, r1, r2, r3}
    426e:	e89e 0003 	ldmia.w	lr, {r0, r1}
      arr[i] = (var >> (8 * i));
    4272:	2300      	movs	r3, #0
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    4274:	f04f 0c03 	mov.w	ip, #3
    4278:	f04f 0e38 	mov.w	lr, #56	; 0x38

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    427c:	22ff      	movs	r2, #255	; 0xff
    427e:	f885 c223 	strb.w	ip, [r5, #547]	; 0x223
    4282:	f885 e224 	strb.w	lr, [r5, #548]	; 0x224
    message_out[1] = PROTOCOL_VER;
    4286:	f04f 0cfe 	mov.w	ip, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    428a:	f04f 0e3d 	mov.w	lr, #61	; 0x3d
    428e:	f885 3225 	strb.w	r3, [r5, #549]	; 0x225
    4292:	f885 3226 	strb.w	r3, [r5, #550]	; 0x226
    4296:	f885 3227 	strb.w	r3, [r5, #551]	; 0x227
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    429a:	e887 0003 	stmia.w	r7, {r0, r1}
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    429e:	20c2      	movs	r0, #194	; 0xc2

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    42a0:	f885 221c 	strb.w	r2, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    42a4:	2207      	movs	r2, #7
    42a6:	f1a7 0137 	sub.w	r1, r7, #55	; 0x37

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    42aa:	f885 321f 	strb.w	r3, [r5, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    42ae:	f885 3222 	strb.w	r3, [r5, #546]	; 0x222
    42b2:	3707      	adds	r7, #7
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    42b4:	f885 c21d 	strb.w	ip, [r5, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    42b8:	f885 e21e 	strb.w	lr, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    42bc:	f885 0220 	strb.w	r0, [r5, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    42c0:	f885 2221 	strb.w	r2, [r5, #545]	; 0x221
    42c4:	e001      	b.n	42ca <loop+0xf7a>
    42c6:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    42ca:	428f      	cmp	r7, r1
      chk += message_out[i];
    42cc:	4413      	add	r3, r2
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    42ce:	d1fa      	bne.n	42c6 <loop+0xf76>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    42d0:	43db      	mvns	r3, r3
    42d2:	6860      	ldr	r0, [r4, #4]
    42d4:	f884 3260 	strb.w	r3, [r4, #608]	; 0x260
    42d8:	6803      	ldr	r3, [r0, #0]
    42da:	492a      	ldr	r1, [pc, #168]	; (4384 <loop+0x1034>)
    42dc:	685b      	ldr	r3, [r3, #4]
    42de:	2245      	movs	r2, #69	; 0x45
    42e0:	4798      	blx	r3
    42e2:	e794      	b.n	420e <loop+0xebe>
    42e4:	f8df c0a4 	ldr.w	ip, [pc, #164]	; 438c <loop+0x103c>
    42e8:	f8df e09c 	ldr.w	lr, [pc, #156]	; 4388 <loop+0x1038>
    42ec:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    42f0:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    42f4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    42f8:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    42fc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    4300:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    4304:	e89c 0003 	ldmia.w	ip, {r0, r1}
    4308:	2300      	movs	r3, #0
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    430a:	f04f 0803 	mov.w	r8, #3
    430e:	f04f 0c38 	mov.w	ip, #56	; 0x38

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    4312:	22ff      	movs	r2, #255	; 0xff
    4314:	f885 8223 	strb.w	r8, [r5, #547]	; 0x223
    4318:	f885 c224 	strb.w	ip, [r5, #548]	; 0x224
    message_out[1] = PROTOCOL_VER;
    431c:	f04f 08fe 	mov.w	r8, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    4320:	f04f 0c3d 	mov.w	ip, #61	; 0x3d
    4324:	f885 3225 	strb.w	r3, [r5, #549]	; 0x225
    4328:	f885 3226 	strb.w	r3, [r5, #550]	; 0x226
    432c:	f885 3227 	strb.w	r3, [r5, #551]	; 0x227
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    4330:	e88e 0003 	stmia.w	lr, {r0, r1}
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    4334:	20c2      	movs	r0, #194	; 0xc2

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    4336:	f885 221c 	strb.w	r2, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    433a:	2207      	movs	r2, #7
    433c:	f1ae 0137 	sub.w	r1, lr, #55	; 0x37

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    4340:	f885 321f 	strb.w	r3, [r5, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    4344:	f885 3222 	strb.w	r3, [r5, #546]	; 0x222
    4348:	f10e 0e07 	add.w	lr, lr, #7
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    434c:	f885 821d 	strb.w	r8, [r5, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    4350:	f885 c21e 	strb.w	ip, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    4354:	f885 0220 	strb.w	r0, [r5, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    4358:	f885 2221 	strb.w	r2, [r5, #545]	; 0x221
    435c:	e001      	b.n	4362 <loop+0x1012>
    435e:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    4362:	4571      	cmp	r1, lr
      chk += message_out[i];
    4364:	4413      	add	r3, r2
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    4366:	d1fa      	bne.n	435e <loop+0x100e>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    4368:	43db      	mvns	r3, r3
    436a:	6860      	ldr	r0, [r4, #4]
    436c:	f884 3260 	strb.w	r3, [r4, #608]	; 0x260
    4370:	6803      	ldr	r3, [r0, #0]
    4372:	4904      	ldr	r1, [pc, #16]	; (4384 <loop+0x1034>)
    4374:	685b      	ldr	r3, [r3, #4]
    4376:	2245      	movs	r2, #69	; 0x45
    4378:	4798      	blx	r3
    437a:	e685      	b.n	4088 <loop+0xd38>
    437c:	4608      	mov	r0, r1
    437e:	f7fd fa2f 	bl	17e0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.9] [clone .constprop.11]>
    4382:	e5ba      	b.n	3efa <loop+0xbaa>
    4384:	1fff1fa4 	.word	0x1fff1fa4
    4388:	1fff1fb0 	.word	0x1fff1fb0
    438c:	0000aadc 	.word	0x0000aadc

00004390 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()>:
    bool v = advertise(srv.pub);
    bool w = subscribe(srv);
    return v && w;
  }

  void negotiateTopics()
    4390:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4394:	b08d      	sub	sp, #52	; 0x34
    TopicInfo():
      topic_id(0),
      topic_name(""),
      message_type(""),
      md5sum(""),
      buffer_size(0)
    4396:	4ac8      	ldr	r2, [pc, #800]	; (46b8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x328>)
    4398:	4bc8      	ldr	r3, [pc, #800]	; (46bc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x32c>)
    439a:	9206      	str	r2, [sp, #24]
    439c:	2200      	movs	r2, #0
    439e:	4604      	mov	r4, r0
    43a0:	f500 6683 	add.w	r6, r0, #1048	; 0x418
    43a4:	f200 457c 	addw	r5, r0, #1148	; 0x47c
    43a8:	f8ad 201c 	strh.w	r2, [sp, #28]
    43ac:	920b      	str	r2, [sp, #44]	; 0x2c
    43ae:	9308      	str	r3, [sp, #32]
    43b0:	9309      	str	r3, [sp, #36]	; 0x24
    43b2:	930a      	str	r3, [sp, #40]	; 0x28
  {
    rosserial_msgs::TopicInfo ti;
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
    43b4:	f856 3f04 	ldr.w	r3, [r6, #4]!
    43b8:	2b00      	cmp	r3, #0
    43ba:	f000 80c2 	beq.w	4542 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    43be:	6858      	ldr	r0, [r3, #4]
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
    43c0:	681f      	ldr	r7, [r3, #0]
        ti.message_type = (char *) publishers[i]->msg_->getType();
    43c2:	6801      	ldr	r1, [r0, #0]
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
    43c4:	689a      	ldr	r2, [r3, #8]
        ti.topic_name = (char *) publishers[i]->topic_;
    43c6:	9708      	str	r7, [sp, #32]
        ti.message_type = (char *) publishers[i]->msg_->getType();
    43c8:	688b      	ldr	r3, [r1, #8]
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
    43ca:	f8ad 201c 	strh.w	r2, [sp, #28]
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    43ce:	4798      	blx	r3
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    43d0:	6833      	ldr	r3, [r6, #0]
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    43d2:	9009      	str	r0, [sp, #36]	; 0x24
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    43d4:	6858      	ldr	r0, [r3, #4]
    43d6:	6803      	ldr	r3, [r0, #0]
    43d8:	68db      	ldr	r3, [r3, #12]
    43da:	4798      	blx	r3
        ti.buffer_size = OUTPUT_SIZE;
        publish(publishers[i]->getEndpointType(), &ti);
    43dc:	6823      	ldr	r3, [r4, #0]
    43de:	6831      	ldr	r1, [r6, #0]
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    43e0:	900a      	str	r0, [sp, #40]	; 0x28
        ti.buffer_size = OUTPUT_SIZE;
    43e2:	f44f 7200 	mov.w	r2, #512	; 0x200
        publish(publishers[i]->getEndpointType(), &ti);
    43e6:	681b      	ldr	r3, [r3, #0]
    43e8:	f8d1 8010 	ldr.w	r8, [r1, #16]
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
        ti.buffer_size = OUTPUT_SIZE;
    43ec:	920b      	str	r2, [sp, #44]	; 0x2c
    43ee:	4ab4      	ldr	r2, [pc, #720]	; (46c0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x330>)
    43f0:	4293      	cmp	r3, r2
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    43f2:	4682      	mov	sl, r0
    43f4:	f040 818c 	bne.w	4710 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x380>
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    43f8:	f1b8 0f63 	cmp.w	r8, #99	; 0x63
    43fc:	dd04      	ble.n	4408 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x78>
    43fe:	f894 34f8 	ldrb.w	r3, [r4, #1272]	; 0x4f8
    4402:	2b00      	cmp	r3, #0
    4404:	f000 809d 	beq.w	4542 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    4408:	f8bd 301c 	ldrh.w	r3, [sp, #28]
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    440c:	f8dd 9020 	ldr.w	r9, [sp, #32]
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    4410:	f884 3223 	strb.w	r3, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    4414:	0a1b      	lsrs	r3, r3, #8
    4416:	f884 3224 	strb.w	r3, [r4, #548]	; 0x224
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    441a:	4648      	mov	r0, r9
    441c:	f005 ffb0 	bl	a380 <strlen>
    4420:	4607      	mov	r7, r0
    4422:	0e3b      	lsrs	r3, r7, #24
    4424:	0c3a      	lsrs	r2, r7, #16
    4426:	0a00      	lsrs	r0, r0, #8
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
    4428:	4649      	mov	r1, r9
    442a:	f884 3228 	strb.w	r3, [r4, #552]	; 0x228
    442e:	f884 7225 	strb.w	r7, [r4, #549]	; 0x225
    4432:	f884 0226 	strb.w	r0, [r4, #550]	; 0x226
    4436:	f884 2227 	strb.w	r2, [r4, #551]	; 0x227
    443a:	f204 2029 	addw	r0, r4, #553	; 0x229
    443e:	463a      	mov	r2, r7
    4440:	f001 fb9a 	bl	5b78 <memcpy>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
    4444:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
    4448:	4658      	mov	r0, fp
    444a:	f005 ff99 	bl	a380 <strlen>
      return 0;

    /* serialize message */
    int l = msg->serialize(message_out + 7);
    444e:	f204 2923 	addw	r9, r4, #547	; 0x223
    4452:	1d79      	adds	r1, r7, #5
    4454:	4602      	mov	r2, r0
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
    4456:	3706      	adds	r7, #6
    4458:	4449      	add	r1, r9
      uint32_t length_message_type = strlen(this->message_type);
    445a:	2300      	movs	r3, #0
    445c:	fa22 f003 	lsr.w	r0, r2, r3
    4460:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    4462:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
    4464:	f801 0f01 	strb.w	r0, [r1, #1]!

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    4468:	d1f8      	bne.n	445c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0xcc>
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    446a:	3704      	adds	r7, #4
    446c:	4659      	mov	r1, fp
    446e:	eb09 0007 	add.w	r0, r9, r7
      offset += length_message_type;
    4472:	4417      	add	r7, r2
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    4474:	f001 fb80 	bl	5b78 <memcpy>
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
    4478:	4650      	mov	r0, sl
    447a:	f005 ff81 	bl	a380 <strlen>
    447e:	eb09 0307 	add.w	r3, r9, r7
    4482:	4683      	mov	fp, r0
    4484:	2200      	movs	r2, #0
      arr[i] = (var >> (8 * i));
    4486:	fa2b f102 	lsr.w	r1, fp, r2
    448a:	3208      	adds	r2, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    448c:	2a20      	cmp	r2, #32
      arr[i] = (var >> (8 * i));
    448e:	f803 1b01 	strb.w	r1, [r3], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    4492:	d1f8      	bne.n	4486 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0xf6>
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    4494:	3704      	adds	r7, #4
    4496:	4651      	mov	r1, sl
    4498:	eb09 0007 	add.w	r0, r9, r7
    449c:	465a      	mov	r2, fp
    449e:	f001 fb6b 	bl	5b78 <memcpy>
      offset += length_md5sum;
    44a2:	eb0b 0307 	add.w	r3, fp, r7
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
    44a6:	1d1f      	adds	r7, r3, #4
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    44a8:	eb09 0103 	add.w	r1, r9, r3

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    44ac:	fa5f fa87 	uxtb.w	sl, r7
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    44b0:	f3c7 2c07 	ubfx	ip, r7, #8, #8
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    44b4:	2200      	movs	r2, #0
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    44b6:	eb0a 0e0c 	add.w	lr, sl, ip
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    44ba:	f04f 0b02 	mov.w	fp, #2
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    44be:	f809 2003 	strb.w	r2, [r9, r3]
    44c2:	ea6f 0e0e 	mvn.w	lr, lr
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
    44c6:	708a      	strb	r2, [r1, #2]
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
    44c8:	70ca      	strb	r2, [r1, #3]
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    44ca:	f881 b001 	strb.w	fp, [r1, #1]

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    44ce:	20ff      	movs	r0, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    44d0:	fa5f f188 	uxtb.w	r1, r8
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    44d4:	f04f 09fe 	mov.w	r9, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    44d8:	f348 2807 	sbfx	r8, r8, #8, #8

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    44dc:	f1b7 3fff 	cmp.w	r7, #4294967295	; 0xffffffff
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    44e0:	f884 e220 	strb.w	lr, [r4, #544]	; 0x220
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    44e4:	f884 a21e 	strb.w	sl, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    44e8:	f884 c21f 	strb.w	ip, [r4, #543]	; 0x21f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    44ec:	f884 021c 	strb.w	r0, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    44f0:	f884 921d 	strb.w	r9, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    44f4:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    44f8:	f884 8222 	strb.w	r8, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    44fc:	f2c0 81b4 	blt.w	4868 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4d8>
    4500:	f203 2326 	addw	r3, r3, #550	; 0x226
    4504:	18e0      	adds	r0, r4, r3
    4506:	f204 2321 	addw	r3, r4, #545	; 0x221
    450a:	e001      	b.n	4510 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x180>
    450c:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    4510:	4298      	cmp	r0, r3
      chk += message_out[i];
    4512:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    4514:	d1fa      	bne.n	450c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x17c>
    4516:	43d2      	mvns	r2, r2
    4518:	b2d2      	uxtb	r2, r2
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    451a:	19e3      	adds	r3, r4, r7
    451c:	f107 0108 	add.w	r1, r7, #8

    if (l <= OUTPUT_SIZE)
    4520:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    4524:	f883 2223 	strb.w	r2, [r3, #547]	; 0x223

    if (l <= OUTPUT_SIZE)
    4528:	f300 8106 	bgt.w	4738 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x3a8>
    452c:	6867      	ldr	r7, [r4, #4]
    452e:	4a65      	ldr	r2, [pc, #404]	; (46c4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x334>)
    4530:	683b      	ldr	r3, [r7, #0]
    4532:	685b      	ldr	r3, [r3, #4]
    4534:	4293      	cmp	r3, r2
    {
      hardware_.write(message_out, l);
    4536:	f504 7007 	add.w	r0, r4, #540	; 0x21c
    453a:	f040 80f3 	bne.w	4724 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x394>
    453e:	f002 fe33 	bl	71a8 <usb_serial_write>

  void negotiateTopics()
  {
    rosserial_msgs::TopicInfo ti;
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    4542:	42ae      	cmp	r6, r5
    4544:	f47f af36 	bne.w	43b4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x24>
    4548:	f8df 9174 	ldr.w	r9, [pc, #372]	; 46c0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x330>
    454c:	f504 689c 	add.w	r8, r4, #1248	; 0x4e0
        publish(publishers[i]->getEndpointType(), &ti);
      }
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
    4550:	f855 0f04 	ldr.w	r0, [r5, #4]!
    4554:	2800      	cmp	r0, #0
    4556:	f000 80d2 	beq.w	46fe <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x36e>
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
    455a:	6881      	ldr	r1, [r0, #8]
        ti.message_type = (char *) subscribers[i]->getMsgType();
    455c:	6803      	ldr	r3, [r0, #0]
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
    455e:	6842      	ldr	r2, [r0, #4]
        ti.topic_name = (char *) subscribers[i]->topic_;
    4560:	9108      	str	r1, [sp, #32]
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
    4562:	f8ad 201c 	strh.w	r2, [sp, #28]
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
    4566:	689b      	ldr	r3, [r3, #8]
    4568:	4798      	blx	r3
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
    456a:	682b      	ldr	r3, [r5, #0]
    {
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
    456c:	9009      	str	r0, [sp, #36]	; 0x24
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
    456e:	681a      	ldr	r2, [r3, #0]
    4570:	4618      	mov	r0, r3
    4572:	68d3      	ldr	r3, [r2, #12]
    4574:	4798      	blx	r3
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
    4576:	682b      	ldr	r3, [r5, #0]
    4578:	6821      	ldr	r1, [r4, #0]
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
    457a:	900a      	str	r0, [sp, #40]	; 0x28
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
    457c:	681a      	ldr	r2, [r3, #0]
    457e:	680e      	ldr	r6, [r1, #0]
    4580:	6852      	ldr	r2, [r2, #4]
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
    4582:	f44f 7100 	mov.w	r1, #512	; 0x200
        publish(subscribers[i]->getEndpointType(), &ti);
    4586:	4618      	mov	r0, r3
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
    4588:	910b      	str	r1, [sp, #44]	; 0x2c
        publish(subscribers[i]->getEndpointType(), &ti);
    458a:	4790      	blx	r2
    458c:	454e      	cmp	r6, r9
    458e:	4607      	mov	r7, r0
    4590:	f040 80c3 	bne.w	471a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x38a>
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    4594:	2863      	cmp	r0, #99	; 0x63
    4596:	dd04      	ble.n	45a2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x212>
    4598:	f894 34f8 	ldrb.w	r3, [r4, #1272]	; 0x4f8
    459c:	2b00      	cmp	r3, #0
    459e:	f000 80ae 	beq.w	46fe <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x36e>
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    45a2:	f8bd 301c 	ldrh.w	r3, [sp, #28]
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    45a6:	9e08      	ldr	r6, [sp, #32]
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    45a8:	f884 3223 	strb.w	r3, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    45ac:	0a1b      	lsrs	r3, r3, #8
    45ae:	f884 3224 	strb.w	r3, [r4, #548]	; 0x224
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    45b2:	4630      	mov	r0, r6
    45b4:	f005 fee4 	bl	a380 <strlen>
    45b8:	4682      	mov	sl, r0
      arr[i] = (var >> (8 * i));
    45ba:	ea4f 631a 	mov.w	r3, sl, lsr #24
    45be:	ea4f 421a 	mov.w	r2, sl, lsr #16
    45c2:	0a00      	lsrs	r0, r0, #8
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
    45c4:	4631      	mov	r1, r6
    45c6:	f884 3228 	strb.w	r3, [r4, #552]	; 0x228
    45ca:	f884 a225 	strb.w	sl, [r4, #549]	; 0x225
    45ce:	f884 0226 	strb.w	r0, [r4, #550]	; 0x226
    45d2:	f884 2227 	strb.w	r2, [r4, #551]	; 0x227
    45d6:	f204 2029 	addw	r0, r4, #553	; 0x229
    45da:	4652      	mov	r2, sl
    45dc:	f001 facc 	bl	5b78 <memcpy>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
    45e0:	9909      	ldr	r1, [sp, #36]	; 0x24
    45e2:	9101      	str	r1, [sp, #4]
    45e4:	4608      	mov	r0, r1
    45e6:	f005 fecb 	bl	a380 <strlen>
      return 0;

    /* serialize message */
    int l = msg->serialize(message_out + 7);
    45ea:	f204 2623 	addw	r6, r4, #547	; 0x223
    45ee:	f10a 0205 	add.w	r2, sl, #5
    45f2:	9901      	ldr	r1, [sp, #4]
    45f4:	4683      	mov	fp, r0
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
    45f6:	f10a 0a06 	add.w	sl, sl, #6
    45fa:	4432      	add	r2, r6
      uint32_t length_message_type = strlen(this->message_type);
    45fc:	2300      	movs	r3, #0
    45fe:	fa2b f003 	lsr.w	r0, fp, r3
    4602:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    4604:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
    4606:	f802 0f01 	strb.w	r0, [r2, #1]!

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    460a:	d1f8      	bne.n	45fe <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x26e>
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    460c:	f10a 0a04 	add.w	sl, sl, #4
    4610:	465a      	mov	r2, fp
    4612:	eb06 000a 	add.w	r0, r6, sl
    4616:	f001 faaf 	bl	5b78 <memcpy>
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
    461a:	990a      	ldr	r1, [sp, #40]	; 0x28
    461c:	9101      	str	r1, [sp, #4]
    461e:	4608      	mov	r0, r1
    4620:	f005 feae 	bl	a380 <strlen>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
      offset += length_message_type;
    4624:	44d3      	add	fp, sl
      uint32_t length_md5sum = strlen(this->md5sum);
    4626:	9901      	ldr	r1, [sp, #4]
    4628:	4682      	mov	sl, r0
    462a:	eb06 030b 	add.w	r3, r6, fp
    462e:	2200      	movs	r2, #0
      arr[i] = (var >> (8 * i));
    4630:	fa2a f002 	lsr.w	r0, sl, r2
    4634:	3208      	adds	r2, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    4636:	2a20      	cmp	r2, #32
      arr[i] = (var >> (8 * i));
    4638:	f803 0b01 	strb.w	r0, [r3], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    463c:	d1f8      	bne.n	4630 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x2a0>
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    463e:	f10b 0b04 	add.w	fp, fp, #4
    4642:	eb06 000b 	add.w	r0, r6, fp
    4646:	4652      	mov	r2, sl
    4648:	f001 fa96 	bl	5b78 <memcpy>
      offset += length_md5sum;
    464c:	eb0a 030b 	add.w	r3, sl, fp
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
    4650:	1d1a      	adds	r2, r3, #4
      offset += length_md5sum;
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
    4652:	990b      	ldr	r1, [sp, #44]	; 0x2c
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    4654:	54f1      	strb	r1, [r6, r3]

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    4656:	fa5f fc82 	uxtb.w	ip, r2
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    465a:	f3c2 2e07 	ubfx	lr, r2, #8, #8
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    465e:	441e      	add	r6, r3
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    4660:	eb0c 000e 	add.w	r0, ip, lr
    4664:	ea4f 2b11 	mov.w	fp, r1, lsr #8
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
    4668:	ea4f 4a11 	mov.w	sl, r1, lsr #16
    466c:	43c0      	mvns	r0, r0
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
    466e:	0e09      	lsrs	r1, r1, #24
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    4670:	f886 b001 	strb.w	fp, [r6, #1]
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
    4674:	f886 a002 	strb.w	sl, [r6, #2]
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
    4678:	70f1      	strb	r1, [r6, #3]

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    467a:	f04f 0bff 	mov.w	fp, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    467e:	b2f9      	uxtb	r1, r7
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    4680:	f04f 0afe 	mov.w	sl, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    4684:	f347 2707 	sbfx	r7, r7, #8, #8
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    4688:	f884 0220 	strb.w	r0, [r4, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    468c:	1c50      	adds	r0, r2, #1
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    468e:	f884 c21e 	strb.w	ip, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    4692:	f884 e21f 	strb.w	lr, [r4, #543]	; 0x21f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    4696:	f884 b21c 	strb.w	fp, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    469a:	f884 a21d 	strb.w	sl, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    469e:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    46a2:	f884 7222 	strb.w	r7, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    46a6:	db18      	blt.n	46da <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x34a>
    46a8:	f203 2326 	addw	r3, r3, #550	; 0x226
    46ac:	18e6      	adds	r6, r4, r3
    46ae:	2000      	movs	r0, #0
    46b0:	f204 2321 	addw	r3, r4, #545	; 0x221
    46b4:	e00a      	b.n	46cc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x33c>
    46b6:	bf00      	nop
    46b8:	0000a7d4 	.word	0x0000a7d4
    46bc:	0000ab14 	.word	0x0000ab14
    46c0:	0000257d 	.word	0x0000257d
    46c4:	00000c49 	.word	0x00000c49
    46c8:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    46cc:	42b3      	cmp	r3, r6
      chk += message_out[i];
    46ce:	4408      	add	r0, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    46d0:	d1fa      	bne.n	46c8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x338>
    46d2:	ea6f 0b00 	mvn.w	fp, r0
    46d6:	fa5f fb8b 	uxtb.w	fp, fp
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    46da:	18a3      	adds	r3, r4, r2
    46dc:	f102 0108 	add.w	r1, r2, #8

    if (l <= OUTPUT_SIZE)
    46e0:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    46e4:	f883 b223 	strb.w	fp, [r3, #547]	; 0x223

    if (l <= OUTPUT_SIZE)
    46e8:	dc71      	bgt.n	47ce <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x43e>
    46ea:	6866      	ldr	r6, [r4, #4]
    46ec:	4a65      	ldr	r2, [pc, #404]	; (4884 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4f4>)
    46ee:	6833      	ldr	r3, [r6, #0]
    46f0:	685b      	ldr	r3, [r3, #4]
    46f2:	4293      	cmp	r3, r2
    {
      hardware_.write(message_out, l);
    46f4:	f504 7007 	add.w	r0, r4, #540	; 0x21c
    46f8:	d119      	bne.n	472e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x39e>
    46fa:	f002 fd55 	bl	71a8 <usb_serial_write>
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
        ti.buffer_size = OUTPUT_SIZE;
        publish(publishers[i]->getEndpointType(), &ti);
      }
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    46fe:	45a8      	cmp	r8, r5
    4700:	f47f af26 	bne.w	4550 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1c0>
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
      }
    }
    configured_ = true;
    4704:	2301      	movs	r3, #1
    4706:	f884 34f8 	strb.w	r3, [r4, #1272]	; 0x4f8
  }
    470a:	b00d      	add	sp, #52	; 0x34
    470c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
        ti.buffer_size = OUTPUT_SIZE;
        publish(publishers[i]->getEndpointType(), &ti);
    4710:	4641      	mov	r1, r8
    4712:	aa06      	add	r2, sp, #24
    4714:	4620      	mov	r0, r4
    4716:	4798      	blx	r3
    4718:	e713      	b.n	4542 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
    471a:	4601      	mov	r1, r0
    471c:	aa06      	add	r2, sp, #24
    471e:	4620      	mov	r0, r4
    4720:	47b0      	blx	r6
    4722:	e7ec      	b.n	46fe <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x36e>
    4724:	460a      	mov	r2, r1
    4726:	4601      	mov	r1, r0
    4728:	4638      	mov	r0, r7
    472a:	4798      	blx	r3
    472c:	e709      	b.n	4542 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
    472e:	460a      	mov	r2, r1
    4730:	4601      	mov	r1, r0
    4732:	4630      	mov	r0, r6
    4734:	4798      	blx	r3
    4736:	e7e2      	b.n	46fe <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x36e>
      enum { ERROR = 3 };
      enum { FATAL = 4 };

    Log():
      level(0),
      msg("")
    4738:	4a53      	ldr	r2, [pc, #332]	; (4888 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4f8>)
    473a:	9203      	str	r2, [sp, #12]

protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    473c:	2103      	movs	r1, #3
    l.msg = (char*)msg;
    473e:	4a53      	ldr	r2, [pc, #332]	; (488c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4fc>)
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    4740:	6823      	ldr	r3, [r4, #0]
protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    4742:	9205      	str	r2, [sp, #20]

protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    4744:	f88d 1010 	strb.w	r1, [sp, #16]
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    4748:	681b      	ldr	r3, [r3, #0]
    474a:	4a51      	ldr	r2, [pc, #324]	; (4890 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x500>)
    474c:	4293      	cmp	r3, r2
    474e:	f040 8086 	bne.w	485e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4ce>
      arr[i] = (var >> (8 * i));
    4752:	2700      	movs	r7, #0
    4754:	2238      	movs	r2, #56	; 0x38
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    4756:	f884 1223 	strb.w	r1, [r4, #547]	; 0x223
    475a:	f884 2224 	strb.w	r2, [r4, #548]	; 0x224
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    475e:	494b      	ldr	r1, [pc, #300]	; (488c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4fc>)
    4760:	f884 7225 	strb.w	r7, [r4, #549]	; 0x225
    4764:	f884 7226 	strb.w	r7, [r4, #550]	; 0x226
    4768:	f884 7227 	strb.w	r7, [r4, #551]	; 0x227
    476c:	f504 700a 	add.w	r0, r4, #552	; 0x228
    4770:	f001 fa02 	bl	5b78 <memcpy>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    4774:	21ff      	movs	r1, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    4776:	203d      	movs	r0, #61	; 0x3d
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    4778:	23c2      	movs	r3, #194	; 0xc2
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    477a:	f04f 0efe 	mov.w	lr, #254	; 0xfe

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    477e:	f884 121c 	strb.w	r1, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    4782:	2107      	movs	r1, #7
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    4784:	f884 021e 	strb.w	r0, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    4788:	f884 3220 	strb.w	r3, [r4, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    478c:	f884 721f 	strb.w	r7, [r4, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    4790:	f884 7222 	strb.w	r7, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    4794:	463a      	mov	r2, r7
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    4796:	f884 e21d 	strb.w	lr, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    479a:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    479e:	f204 2321 	addw	r3, r4, #545	; 0x221
    47a2:	f204 205f 	addw	r0, r4, #607	; 0x25f
    47a6:	e001      	b.n	47ac <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x41c>
    47a8:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    47ac:	4298      	cmp	r0, r3
      chk += message_out[i];
    47ae:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    47b0:	d1fa      	bne.n	47a8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x418>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    47b2:	43d2      	mvns	r2, r2
    47b4:	6860      	ldr	r0, [r4, #4]
    47b6:	f884 2260 	strb.w	r2, [r4, #608]	; 0x260
    47ba:	6803      	ldr	r3, [r0, #0]
    47bc:	4a31      	ldr	r2, [pc, #196]	; (4884 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4f4>)
    47be:	685b      	ldr	r3, [r3, #4]
    47c0:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    47c2:	f504 7107 	add.w	r1, r4, #540	; 0x21c
    47c6:	d159      	bne.n	487c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4ec>
    47c8:	4608      	mov	r0, r1
    47ca:	2145      	movs	r1, #69	; 0x45
    47cc:	e6b7      	b.n	453e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1ae>
      enum { ERROR = 3 };
      enum { FATAL = 4 };

    Log():
      level(0),
      msg("")
    47ce:	4a2e      	ldr	r2, [pc, #184]	; (4888 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4f8>)
    47d0:	9203      	str	r2, [sp, #12]

protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    47d2:	2103      	movs	r1, #3
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    47d4:	6823      	ldr	r3, [r4, #0]
protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    47d6:	4a2d      	ldr	r2, [pc, #180]	; (488c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4fc>)
    47d8:	9205      	str	r2, [sp, #20]

protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    47da:	f88d 1010 	strb.w	r1, [sp, #16]
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    47de:	681b      	ldr	r3, [r3, #0]
    47e0:	454b      	cmp	r3, r9
    47e2:	d146      	bne.n	4872 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4e2>
    47e4:	2600      	movs	r6, #0
    47e6:	2238      	movs	r2, #56	; 0x38
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    47e8:	f884 1223 	strb.w	r1, [r4, #547]	; 0x223
    47ec:	f884 2224 	strb.w	r2, [r4, #548]	; 0x224
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    47f0:	4926      	ldr	r1, [pc, #152]	; (488c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4fc>)
    47f2:	f884 6225 	strb.w	r6, [r4, #549]	; 0x225
    47f6:	f884 6226 	strb.w	r6, [r4, #550]	; 0x226
    47fa:	f884 6227 	strb.w	r6, [r4, #551]	; 0x227
    47fe:	f504 700a 	add.w	r0, r4, #552	; 0x228
    4802:	f001 f9b9 	bl	5b78 <memcpy>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    4806:	21ff      	movs	r1, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    4808:	203d      	movs	r0, #61	; 0x3d
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    480a:	23c2      	movs	r3, #194	; 0xc2
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    480c:	27fe      	movs	r7, #254	; 0xfe

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    480e:	f884 121c 	strb.w	r1, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    4812:	2107      	movs	r1, #7
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    4814:	f884 021e 	strb.w	r0, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    4818:	f884 3220 	strb.w	r3, [r4, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    481c:	f884 621f 	strb.w	r6, [r4, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    4820:	f884 6222 	strb.w	r6, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    4824:	4632      	mov	r2, r6
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    4826:	f884 721d 	strb.w	r7, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    482a:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    482e:	f204 2321 	addw	r3, r4, #545	; 0x221
    4832:	f204 205f 	addw	r0, r4, #607	; 0x25f
    4836:	e001      	b.n	483c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4ac>
    4838:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    483c:	4283      	cmp	r3, r0
      chk += message_out[i];
    483e:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    4840:	d1fa      	bne.n	4838 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4a8>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    4842:	43d2      	mvns	r2, r2
    4844:	6860      	ldr	r0, [r4, #4]
    4846:	f884 2260 	strb.w	r2, [r4, #608]	; 0x260
    484a:	6803      	ldr	r3, [r0, #0]
    484c:	4a0d      	ldr	r2, [pc, #52]	; (4884 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4f4>)
    484e:	685b      	ldr	r3, [r3, #4]
    4850:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    4852:	f504 7107 	add.w	r1, r4, #540	; 0x21c
    4856:	d109      	bne.n	486c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4dc>
    4858:	4608      	mov	r0, r1
    485a:	2145      	movs	r1, #69	; 0x45
    485c:	e74d      	b.n	46fa <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x36a>
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    485e:	aa03      	add	r2, sp, #12
    4860:	2107      	movs	r1, #7
    4862:	4620      	mov	r0, r4
    4864:	4798      	blx	r3
    4866:	e66c      	b.n	4542 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    4868:	4602      	mov	r2, r0
    486a:	e656      	b.n	451a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x18a>
    486c:	2245      	movs	r2, #69	; 0x45
    486e:	4798      	blx	r3
    4870:	e745      	b.n	46fe <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x36e>
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    4872:	aa03      	add	r2, sp, #12
    4874:	2107      	movs	r1, #7
    4876:	4620      	mov	r0, r4
    4878:	4798      	blx	r3
    487a:	e740      	b.n	46fe <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x36e>
    487c:	2245      	movs	r2, #69	; 0x45
    487e:	4798      	blx	r3
    4880:	e65f      	b.n	4542 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
    4882:	bf00      	nop
    4884:	00000c49 	.word	0x00000c49
    4888:	0000a7ec 	.word	0x0000a7ec
    488c:	0000aadc 	.word	0x0000aadc
    4890:	0000257d 	.word	0x0000257d

00004894 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()>:
  /* This function goes in your loop() function, it handles
   *  serial input and callbacks for subscribers.
   */


  virtual int spinOnce() override
    4894:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4898:	4ebb      	ldr	r6, [pc, #748]	; (4b88 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x2f4>)
    489a:	b093      	sub	sp, #76	; 0x4c
    489c:	6833      	ldr	r3, [r6, #0]
    489e:	9306      	str	r3, [sp, #24]
	return ret;
    48a0:	9d06      	ldr	r5, [sp, #24]
  {
    /* restart if timed out */
    uint32_t c_time = hardware_.time();
    if ((c_time - last_sync_receive_time) > (SYNC_SECONDS * 2200))
    48a2:	f8d0 3500 	ldr.w	r3, [r0, #1280]	; 0x500
    48a6:	f642 22f8 	movw	r2, #11000	; 0x2af8
    48aa:	1aeb      	subs	r3, r5, r3
    48ac:	4293      	cmp	r3, r2
    {
      configured_ = false;
    48ae:	bf84      	itt	hi
    48b0:	2300      	movhi	r3, #0
    48b2:	f880 34f8 	strbhi.w	r3, [r0, #1272]	; 0x4f8
    }

    /* reset if message has timed out */
    if (mode_ != MODE_FIRST_FF)
    48b6:	f8d0 34e4 	ldr.w	r3, [r0, #1252]	; 0x4e4
  /* This function goes in your loop() function, it handles
   *  serial input and callbacks for subscribers.
   */


  virtual int spinOnce() override
    48ba:	4604      	mov	r4, r0
    {
      configured_ = false;
    }

    /* reset if message has timed out */
    if (mode_ != MODE_FIRST_FF)
    48bc:	b133      	cbz	r3, 48cc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x38>
    {
      if (c_time > last_msg_timeout_time)
    48be:	f8d0 3504 	ldr.w	r3, [r0, #1284]	; 0x504
    48c2:	42ab      	cmp	r3, r5
      {
        mode_ = MODE_FIRST_FF;
    48c4:	bf3c      	itt	cc
    48c6:	2300      	movcc	r3, #0
    48c8:	f8c0 34e4 	strcc.w	r3, [r0, #1252]	; 0x4e4
    48cc:	4faf      	ldr	r7, [pc, #700]	; (4b8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x2f8>)

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    48ce:	f8df 92d0 	ldr.w	r9, [pc, #720]	; 4ba0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x30c>

    /* while available buffer, read data */
    while (true)
    {
      // If a timeout has been specified, check how long spinOnce has been running.
      if (spin_timeout_ > 0)
    48d2:	69a2      	ldr	r2, [r4, #24]
    48d4:	b132      	cbz	r2, 48e4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x50>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    48d6:	6833      	ldr	r3, [r6, #0]
    48d8:	9307      	str	r3, [sp, #28]
	return ret;
    48da:	9b07      	ldr	r3, [sp, #28]
      {
        // If the maximum processing timeout has been exceeded, exit with error.
        // The next spinOnce can continue where it left off, or optionally
        // based on the application in use, the hardware buffer could be flushed
        // and start fresh.
        if ((hardware_.time() - c_time) > spin_timeout_)
    48dc:	1b5b      	subs	r3, r3, r5
    48de:	429a      	cmp	r2, r3
    48e0:	f0c0 811b 	bcc.w	4b1a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x286>
    48e4:	6860      	ldr	r0, [r4, #4]
      delay(3000); 
#endif
      iostream->begin(baud_);
    }

    int read(){return iostream->read();};
    48e6:	6803      	ldr	r3, [r0, #0]
    48e8:	695b      	ldr	r3, [r3, #20]
    48ea:	42bb      	cmp	r3, r7
    48ec:	d166      	bne.n	49bc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x128>
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    48ee:	f002 fbf5 	bl	70dc <usb_serial_getchar>
          // Exit the spin, processing timeout exceeded.
          return SPIN_TIMEOUT;
        }
      }
      int data = hardware_.read();
      if (data < 0)
    48f2:	2800      	cmp	r0, #0
    48f4:	db65      	blt.n	49c2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x12e>
        break;
      checksum_ += data;
    48f6:	f8d4 34f4 	ldr.w	r3, [r4, #1268]	; 0x4f4
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    48fa:	f8d4 24e4 	ldr.w	r2, [r4, #1252]	; 0x4e4
        }
      }
      int data = hardware_.read();
      if (data < 0)
        break;
      checksum_ += data;
    48fe:	4403      	add	r3, r0
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    4900:	2a07      	cmp	r2, #7
        }
      }
      int data = hardware_.read();
      if (data < 0)
        break;
      checksum_ += data;
    4902:	f8c4 34f4 	str.w	r3, [r4, #1268]	; 0x4f4
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    4906:	d047      	beq.n	4998 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x104>
        message_in[index_++] = data;
        bytes_--;
        if (bytes_ == 0)                 /* is message complete? if so, checksum */
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_FIRST_FF)
    4908:	b982      	cbnz	r2, 492c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x98>
      {
        if (data == 0xff)
    490a:	28ff      	cmp	r0, #255	; 0xff
    490c:	d069      	beq.n	49e2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x14e>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    490e:	6833      	ldr	r3, [r6, #0]
    4910:	9308      	str	r3, [sp, #32]
	return ret;
    4912:	9b08      	ldr	r3, [sp, #32]
        {
          mode_++;
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
        }
        else if (hardware_.time() - c_time > (SYNC_SECONDS * 1000))
    4914:	f241 3188 	movw	r1, #5000	; 0x1388
    4918:	1b5b      	subs	r3, r3, r5
    491a:	428b      	cmp	r3, r1
    491c:	d9d9      	bls.n	48d2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
        {
          /* We have been stuck in spinOnce too long, return error */
          configured_ = false;
    491e:	f884 24f8 	strb.w	r2, [r4, #1272]	; 0x4f8
          return SPIN_TIMEOUT;
    4922:	f06f 0001 	mvn.w	r0, #1
      requestSyncTime();
      last_sync_time = c_time;
    }

    return SPIN_OK;
  }
    4926:	b013      	add	sp, #76	; 0x4c
    4928:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          /* We have been stuck in spinOnce too long, return error */
          configured_ = false;
          return SPIN_TIMEOUT;
        }
      }
      else if (mode_ == MODE_PROTOCOL_VER)
    492c:	2a01      	cmp	r2, #1
    492e:	d060      	beq.n	49f2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x15e>
          mode_ = MODE_FIRST_FF;
          if (configured_ == false)
            requestSyncTime();  /* send a msg back showing our protocol version */
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
    4930:	2a02      	cmp	r2, #2
    4932:	f000 80b6 	beq.w	4aa2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x20e>
        bytes_ = data;
        index_ = 0;
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
    4936:	2a03      	cmp	r2, #3
    4938:	f000 80be 	beq.w	4ab8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x224>
      {
        bytes_ += data << 8;
        mode_++;
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
    493c:	2a04      	cmp	r2, #4
    493e:	f000 80c5 	beq.w	4acc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x238>
        if ((checksum_ % 256) == 255)
          mode_++;
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
    4942:	2a05      	cmp	r2, #5
    4944:	f000 80d2 	beq.w	4aec <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x258>
      {
        topic_ = data;
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
    4948:	2a06      	cmp	r2, #6
    494a:	f000 80d7 	beq.w	4afc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x268>
        topic_ += data << 8;
        mode_ = MODE_MESSAGE;
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
    494e:	2a08      	cmp	r2, #8
    4950:	d1bf      	bne.n	48d2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
      {
        mode_ = MODE_FIRST_FF;
        if ((checksum_ % 256) == 255)
    4952:	4a8f      	ldr	r2, [pc, #572]	; (4b90 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x2fc>)
    4954:	401a      	ands	r2, r3
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
    4956:	2300      	movs	r3, #0
        if ((checksum_ % 256) == 255)
    4958:	429a      	cmp	r2, r3
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
    495a:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
        if ((checksum_ % 256) == 255)
    495e:	f2c0 814d 	blt.w	4bfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x368>
    4962:	2aff      	cmp	r2, #255	; 0xff
    4964:	d1b5      	bne.n	48d2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
        {
          if (topic_ == TopicInfo::ID_PUBLISHER)
    4966:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
    496a:	2b00      	cmp	r3, #0
    496c:	f000 82d0 	beq.w	4f10 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x67c>
            negotiateTopics();
            last_sync_time = c_time;
            last_sync_receive_time = c_time;
            return SPIN_ERR;
          }
          else if (topic_ == TopicInfo::ID_TIME)
    4970:	2b0a      	cmp	r3, #10
    4972:	f000 827a 	beq.w	4e6a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x5d6>
          {
            syncTime(message_in);
          }
          else if (topic_ == TopicInfo::ID_PARAMETER_REQUEST)
    4976:	2b06      	cmp	r3, #6
    4978:	f000 8153 	beq.w	4c22 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x38e>
          {
            req_param_resp.deserialize(message_in);
            param_received = true;
          }
          else if (topic_ == TopicInfo::ID_TX_STOP)
    497c:	2b0b      	cmp	r3, #11
    497e:	f000 8142 	beq.w	4c06 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x372>
          {
            configured_ = false;
          }
          else
          {
            if (subscribers[topic_ - 100])
    4982:	33bc      	adds	r3, #188	; 0xbc
    4984:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
    4988:	2800      	cmp	r0, #0
    498a:	d0a2      	beq.n	48d2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
              subscribers[topic_ - 100]->callback(message_in);
    498c:	6803      	ldr	r3, [r0, #0]
    498e:	f104 011c 	add.w	r1, r4, #28
    4992:	681b      	ldr	r3, [r3, #0]
    4994:	4798      	blx	r3
    4996:	e79c      	b.n	48d2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
      if (data < 0)
        break;
      checksum_ += data;
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
      {
        message_in[index_++] = data;
    4998:	f8d4 34f0 	ldr.w	r3, [r4, #1264]	; 0x4f0
    499c:	18e2      	adds	r2, r4, r3
    499e:	3301      	adds	r3, #1
    49a0:	f8c4 34f0 	str.w	r3, [r4, #1264]	; 0x4f0
    49a4:	7710      	strb	r0, [r2, #28]
        bytes_--;
    49a6:	f8d4 34e8 	ldr.w	r3, [r4, #1256]	; 0x4e8
    49aa:	3b01      	subs	r3, #1
    49ac:	f8c4 34e8 	str.w	r3, [r4, #1256]	; 0x4e8
        if (bytes_ == 0)                 /* is message complete? if so, checksum */
    49b0:	2b00      	cmp	r3, #0
    49b2:	d18e      	bne.n	48d2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
          mode_ = MODE_MSG_CHECKSUM;
    49b4:	2308      	movs	r3, #8
    49b6:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    49ba:	e78a      	b.n	48d2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
    49bc:	4798      	blx	r3
          // Exit the spin, processing timeout exceeded.
          return SPIN_TIMEOUT;
        }
      }
      int data = hardware_.read();
      if (data < 0)
    49be:	2800      	cmp	r0, #0
    49c0:	da99      	bge.n	48f6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x62>
        }
      }
    }

    /* occasionally sync time */
    if (configured_ && ((c_time - last_sync_time) > (SYNC_SECONDS * 500)))
    49c2:	f894 04f8 	ldrb.w	r0, [r4, #1272]	; 0x4f8
    49c6:	2800      	cmp	r0, #0
    49c8:	d0ad      	beq.n	4926 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x92>
    49ca:	f8d4 34fc 	ldr.w	r3, [r4, #1276]	; 0x4fc
    49ce:	f640 12c4 	movw	r2, #2500	; 0x9c4
    49d2:	1aeb      	subs	r3, r5, r3
    49d4:	4293      	cmp	r3, r2
    49d6:	f200 80a5 	bhi.w	4b24 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x290>
    {
      requestSyncTime();
      last_sync_time = c_time;
    }

    return SPIN_OK;
    49da:	2000      	movs	r0, #0
  }
    49dc:	b013      	add	sp, #76	; 0x4c
    49de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      }
      else if (mode_ == MODE_FIRST_FF)
      {
        if (data == 0xff)
        {
          mode_++;
    49e2:	2201      	movs	r2, #1
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
    49e4:	f105 0314 	add.w	r3, r5, #20
      }
      else if (mode_ == MODE_FIRST_FF)
      {
        if (data == 0xff)
        {
          mode_++;
    49e8:	f8c4 24e4 	str.w	r2, [r4, #1252]	; 0x4e4
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
    49ec:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
    49f0:	e76f      	b.n	48d2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
          return SPIN_TIMEOUT;
        }
      }
      else if (mode_ == MODE_PROTOCOL_VER)
      {
        if (data == PROTOCOL_VER)
    49f2:	28fe      	cmp	r0, #254	; 0xfe
    49f4:	d076      	beq.n	4ae4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x250>
          mode_++;
        }
        else
        {
          mode_ = MODE_FIRST_FF;
          if (configured_ == false)
    49f6:	f894 24f8 	ldrb.w	r2, [r4, #1272]	; 0x4f8
        {
          mode_++;
        }
        else
        {
          mode_ = MODE_FIRST_FF;
    49fa:	2300      	movs	r3, #0
    49fc:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
          if (configured_ == false)
    4a00:	2a00      	cmp	r2, #0
    4a02:	f47f af66 	bne.w	48d2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
    4a06:	4963      	ldr	r1, [pc, #396]	; (4b94 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x300>)
   */

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    4a08:	6823      	ldr	r3, [r4, #0]
    4a0a:	910f      	str	r1, [sp, #60]	; 0x3c
    4a0c:	681b      	ldr	r3, [r3, #0]
    4a0e:	4962      	ldr	r1, [pc, #392]	; (4b98 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x304>)
    4a10:	9210      	str	r2, [sp, #64]	; 0x40
    4a12:	428b      	cmp	r3, r1
    4a14:	9211      	str	r2, [sp, #68]	; 0x44
    4a16:	f040 80e7 	bne.w	4be8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x354>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    4a1a:	21ff      	movs	r1, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    4a1c:	2008      	movs	r0, #8
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    4a1e:	23f7      	movs	r3, #247	; 0xf7
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    4a20:	f04f 0efe 	mov.w	lr, #254	; 0xfe

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    4a24:	f884 121c 	strb.w	r1, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    4a28:	210a      	movs	r1, #10
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    4a2a:	f884 021e 	strb.w	r0, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    4a2e:	f884 3220 	strb.w	r3, [r4, #544]	; 0x220
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->data.sec >> (8 * 0)) & 0xFF;
    4a32:	f884 2223 	strb.w	r2, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->data.sec >> (8 * 1)) & 0xFF;
    4a36:	f884 2224 	strb.w	r2, [r4, #548]	; 0x224
      *(outbuffer + offset + 2) = (this->data.sec >> (8 * 2)) & 0xFF;
    4a3a:	f884 2225 	strb.w	r2, [r4, #549]	; 0x225
      *(outbuffer + offset + 3) = (this->data.sec >> (8 * 3)) & 0xFF;
    4a3e:	f884 2226 	strb.w	r2, [r4, #550]	; 0x226
      offset += sizeof(this->data.sec);
      *(outbuffer + offset + 0) = (this->data.nsec >> (8 * 0)) & 0xFF;
    4a42:	f884 2227 	strb.w	r2, [r4, #551]	; 0x227
      *(outbuffer + offset + 1) = (this->data.nsec >> (8 * 1)) & 0xFF;
    4a46:	f884 2228 	strb.w	r2, [r4, #552]	; 0x228
      *(outbuffer + offset + 2) = (this->data.nsec >> (8 * 2)) & 0xFF;
    4a4a:	f884 2229 	strb.w	r2, [r4, #553]	; 0x229
      *(outbuffer + offset + 3) = (this->data.nsec >> (8 * 3)) & 0xFF;
    4a4e:	f884 222a 	strb.w	r2, [r4, #554]	; 0x22a

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    4a52:	f884 221f 	strb.w	r2, [r4, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    4a56:	f884 2222 	strb.w	r2, [r4, #546]	; 0x222
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    4a5a:	f884 e21d 	strb.w	lr, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    4a5e:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    4a62:	f204 2321 	addw	r3, r4, #545	; 0x221
    4a66:	f204 202a 	addw	r0, r4, #554	; 0x22a
    4a6a:	e001      	b.n	4a70 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x1dc>
    4a6c:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    4a70:	4298      	cmp	r0, r3
      chk += message_out[i];
    4a72:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    4a74:	d1fa      	bne.n	4a6c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x1d8>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    4a76:	43d2      	mvns	r2, r2
    4a78:	f8d4 e004 	ldr.w	lr, [r4, #4]
    4a7c:	f884 222b 	strb.w	r2, [r4, #555]	; 0x22b
    void write(uint8_t* data, int length){
      iostream->write(data, length);
    4a80:	f8de 3000 	ldr.w	r3, [lr]
    4a84:	4a45      	ldr	r2, [pc, #276]	; (4b9c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x308>)
    4a86:	685b      	ldr	r3, [r3, #4]
    4a88:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    4a8a:	f504 7007 	add.w	r0, r4, #540	; 0x21c
    4a8e:	f040 80b0 	bne.w	4bf2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x35e>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    4a92:	2110      	movs	r1, #16
    4a94:	f002 fb88 	bl	71a8 <usb_serial_write>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4a98:	6833      	ldr	r3, [r6, #0]
    4a9a:	9309      	str	r3, [sp, #36]	; 0x24
	return ret;
    4a9c:	9b09      	ldr	r3, [sp, #36]	; 0x24

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    rt_time = hardware_.time();
    4a9e:	60e3      	str	r3, [r4, #12]
    4aa0:	e717      	b.n	48d2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
        index_ = 0;
    4aa2:	2200      	movs	r2, #0
        mode_++;
    4aa4:	2303      	movs	r3, #3
            requestSyncTime();  /* send a msg back showing our protocol version */
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
    4aa6:	f8c4 04e8 	str.w	r0, [r4, #1256]	; 0x4e8
        index_ = 0;
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
    4aaa:	f8c4 04f4 	str.w	r0, [r4, #1268]	; 0x4f4
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
        index_ = 0;
    4aae:	f8c4 24f0 	str.w	r2, [r4, #1264]	; 0x4f0
        mode_++;
    4ab2:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    4ab6:	e70c      	b.n	48d2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
      {
        bytes_ += data << 8;
    4ab8:	f8d4 34e8 	ldr.w	r3, [r4, #1256]	; 0x4e8
    4abc:	eb03 2000 	add.w	r0, r3, r0, lsl #8
        mode_++;
    4ac0:	2304      	movs	r3, #4
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
      {
        bytes_ += data << 8;
    4ac2:	f8c4 04e8 	str.w	r0, [r4, #1256]	; 0x4e8
        mode_++;
    4ac6:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    4aca:	e702      	b.n	48d2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
      {
        if ((checksum_ % 256) == 255)
    4acc:	4a30      	ldr	r2, [pc, #192]	; (4b90 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x2fc>)
    4ace:	401a      	ands	r2, r3
    4ad0:	2a00      	cmp	r2, #0
    4ad2:	f2c0 8084 	blt.w	4bde <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x34a>
    4ad6:	2aff      	cmp	r2, #255	; 0xff
          mode_++;
    4ad8:	bf0c      	ite	eq
    4ada:	2305      	moveq	r3, #5
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
    4adc:	2300      	movne	r3, #0
    4ade:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    4ae2:	e6f6      	b.n	48d2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
      }
      else if (mode_ == MODE_PROTOCOL_VER)
      {
        if (data == PROTOCOL_VER)
        {
          mode_++;
    4ae4:	2302      	movs	r3, #2
    4ae6:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    4aea:	e6f2      	b.n	48d2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
        mode_++;
    4aec:	2306      	movs	r3, #6
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
    4aee:	f8c4 04ec 	str.w	r0, [r4, #1260]	; 0x4ec
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
    4af2:	f8c4 04f4 	str.w	r0, [r4, #1268]	; 0x4f4
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
        mode_++;
    4af6:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    4afa:	e6ea      	b.n	48d2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    4afc:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
        mode_ = MODE_MESSAGE;
        if (bytes_ == 0)
    4b00:	f8d4 24e8 	ldr.w	r2, [r4, #1256]	; 0x4e8
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    4b04:	eb03 2300 	add.w	r3, r3, r0, lsl #8
        mode_ = MODE_MESSAGE;
    4b08:	2107      	movs	r1, #7
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    4b0a:	f8c4 34ec 	str.w	r3, [r4, #1260]	; 0x4ec
        mode_ = MODE_MESSAGE;
    4b0e:	f8c4 14e4 	str.w	r1, [r4, #1252]	; 0x4e4
        if (bytes_ == 0)
    4b12:	2a00      	cmp	r2, #0
    4b14:	f43f af4e 	beq.w	49b4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x120>
    4b18:	e6db      	b.n	48d2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
        // based on the application in use, the hardware buffer could be flushed
        // and start fresh.
        if ((hardware_.time() - c_time) > spin_timeout_)
        {
          // Exit the spin, processing timeout exceeded.
          return SPIN_TIMEOUT;
    4b1a:	f06f 0001 	mvn.w	r0, #1
      requestSyncTime();
      last_sync_time = c_time;
    }

    return SPIN_OK;
  }
    4b1e:	b013      	add	sp, #76	; 0x4c
    4b20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    public:
      typedef ros::Time _data_type;
      _data_type data;

    Time():
      data()
    4b24:	4a1b      	ldr	r2, [pc, #108]	; (4b94 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x300>)
   */

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    4b26:	6823      	ldr	r3, [r4, #0]
    4b28:	920f      	str	r2, [sp, #60]	; 0x3c
    4b2a:	681b      	ldr	r3, [r3, #0]
    4b2c:	491a      	ldr	r1, [pc, #104]	; (4b98 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x304>)
    4b2e:	2200      	movs	r2, #0
    4b30:	428b      	cmp	r3, r1
    4b32:	9210      	str	r2, [sp, #64]	; 0x40
    4b34:	9211      	str	r2, [sp, #68]	; 0x44
    4b36:	d16a      	bne.n	4c0e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x37a>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    4b38:	21ff      	movs	r1, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    4b3a:	2008      	movs	r0, #8
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    4b3c:	23f7      	movs	r3, #247	; 0xf7
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    4b3e:	27fe      	movs	r7, #254	; 0xfe

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    4b40:	f884 121c 	strb.w	r1, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    4b44:	210a      	movs	r1, #10
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    4b46:	f884 021e 	strb.w	r0, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    4b4a:	f884 3220 	strb.w	r3, [r4, #544]	; 0x220
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->data.sec >> (8 * 0)) & 0xFF;
    4b4e:	f884 2223 	strb.w	r2, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->data.sec >> (8 * 1)) & 0xFF;
    4b52:	f884 2224 	strb.w	r2, [r4, #548]	; 0x224
      *(outbuffer + offset + 2) = (this->data.sec >> (8 * 2)) & 0xFF;
    4b56:	f884 2225 	strb.w	r2, [r4, #549]	; 0x225
      *(outbuffer + offset + 3) = (this->data.sec >> (8 * 3)) & 0xFF;
    4b5a:	f884 2226 	strb.w	r2, [r4, #550]	; 0x226
      offset += sizeof(this->data.sec);
      *(outbuffer + offset + 0) = (this->data.nsec >> (8 * 0)) & 0xFF;
    4b5e:	f884 2227 	strb.w	r2, [r4, #551]	; 0x227
      *(outbuffer + offset + 1) = (this->data.nsec >> (8 * 1)) & 0xFF;
    4b62:	f884 2228 	strb.w	r2, [r4, #552]	; 0x228
      *(outbuffer + offset + 2) = (this->data.nsec >> (8 * 2)) & 0xFF;
    4b66:	f884 2229 	strb.w	r2, [r4, #553]	; 0x229
      *(outbuffer + offset + 3) = (this->data.nsec >> (8 * 3)) & 0xFF;
    4b6a:	f884 222a 	strb.w	r2, [r4, #554]	; 0x22a

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    4b6e:	f884 221f 	strb.w	r2, [r4, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    4b72:	f884 2222 	strb.w	r2, [r4, #546]	; 0x222
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    4b76:	f884 721d 	strb.w	r7, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    4b7a:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    4b7e:	f204 2321 	addw	r3, r4, #545	; 0x221
    4b82:	f204 202a 	addw	r0, r4, #554	; 0x22a
    4b86:	e00f      	b.n	4ba8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x314>
    4b88:	1fff2b4c 	.word	0x1fff2b4c
    4b8c:	00000c51 	.word	0x00000c51
    4b90:	800000ff 	.word	0x800000ff
    4b94:	0000a7bc 	.word	0x0000a7bc
    4b98:	0000257d 	.word	0x0000257d
    4b9c:	00000c49 	.word	0x00000c49
    4ba0:	000f4240 	.word	0x000f4240
    4ba4:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    4ba8:	4283      	cmp	r3, r0
      chk += message_out[i];
    4baa:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    4bac:	d1fa      	bne.n	4ba4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x310>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    4bae:	43d2      	mvns	r2, r2
    4bb0:	6867      	ldr	r7, [r4, #4]
    4bb2:	f884 222b 	strb.w	r2, [r4, #555]	; 0x22b
    4bb6:	683b      	ldr	r3, [r7, #0]
    4bb8:	4ad2      	ldr	r2, [pc, #840]	; (4f04 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x670>)
    4bba:	685b      	ldr	r3, [r3, #4]
    4bbc:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    4bbe:	f504 7007 	add.w	r0, r4, #540	; 0x21c
    4bc2:	d129      	bne.n	4c18 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x384>
    4bc4:	2110      	movs	r1, #16
    4bc6:	f002 faef 	bl	71a8 <usb_serial_write>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4bca:	6833      	ldr	r3, [r6, #0]
    4bcc:	930b      	str	r3, [sp, #44]	; 0x2c
	return ret;
    4bce:	9b0b      	ldr	r3, [sp, #44]	; 0x2c

    /* occasionally sync time */
    if (configured_ && ((c_time - last_sync_time) > (SYNC_SECONDS * 500)))
    {
      requestSyncTime();
      last_sync_time = c_time;
    4bd0:	f8c4 54fc 	str.w	r5, [r4, #1276]	; 0x4fc
    }

    return SPIN_OK;
    4bd4:	2000      	movs	r0, #0

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    rt_time = hardware_.time();
    4bd6:	60e3      	str	r3, [r4, #12]
      requestSyncTime();
      last_sync_time = c_time;
    }

    return SPIN_OK;
  }
    4bd8:	b013      	add	sp, #76	; 0x4c
    4bda:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        bytes_ += data << 8;
        mode_++;
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
      {
        if ((checksum_ % 256) == 255)
    4bde:	3a01      	subs	r2, #1
    4be0:	f062 02ff 	orn	r2, r2, #255	; 0xff
    4be4:	3201      	adds	r2, #1
    4be6:	e776      	b.n	4ad6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x242>
   */

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    4be8:	aa0f      	add	r2, sp, #60	; 0x3c
    4bea:	210a      	movs	r1, #10
    4bec:	4620      	mov	r0, r4
    4bee:	4798      	blx	r3
    4bf0:	e752      	b.n	4a98 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x204>
    4bf2:	4601      	mov	r1, r0
    4bf4:	2210      	movs	r2, #16
    4bf6:	4670      	mov	r0, lr
    4bf8:	4798      	blx	r3
    4bfa:	e74d      	b.n	4a98 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x204>
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
        if ((checksum_ % 256) == 255)
    4bfc:	3a01      	subs	r2, #1
    4bfe:	f062 02ff 	orn	r2, r2, #255	; 0xff
    4c02:	3201      	adds	r2, #1
    4c04:	e6ad      	b.n	4962 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0xce>
            req_param_resp.deserialize(message_in);
            param_received = true;
          }
          else if (topic_ == TopicInfo::ID_TX_STOP)
          {
            configured_ = false;
    4c06:	2300      	movs	r3, #0
    4c08:	f884 34f8 	strb.w	r3, [r4, #1272]	; 0x4f8
    4c0c:	e661      	b.n	48d2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
   */

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    4c0e:	aa0f      	add	r2, sp, #60	; 0x3c
    4c10:	210a      	movs	r1, #10
    4c12:	4620      	mov	r0, r4
    4c14:	4798      	blx	r3
    4c16:	e7d8      	b.n	4bca <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x336>
    4c18:	4601      	mov	r1, r0
    4c1a:	2210      	movs	r2, #16
    4c1c:	4638      	mov	r0, r7
    4c1e:	4798      	blx	r3
    4c20:	e7d3      	b.n	4bca <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x336>
    {
      int offset = 0;
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    4c22:	7f22      	ldrb	r2, [r4, #28]
    4c24:	7f63      	ldrb	r3, [r4, #29]
    4c26:	f894 801e 	ldrb.w	r8, [r4, #30]
    4c2a:	7fe1      	ldrb	r1, [r4, #31]
    4c2c:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    4c30:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
    4c34:	f8d4 2510 	ldr.w	r2, [r4, #1296]	; 0x510
    {
      int offset = 0;
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    4c38:	ea43 6801 	orr.w	r8, r3, r1, lsl #24
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
    4c3c:	4590      	cmp	r8, r2
          {
            syncTime(message_in);
          }
          else if (topic_ == TopicInfo::ID_PARAMETER_REQUEST)
          {
            req_param_resp.deserialize(message_in);
    4c3e:	f104 0b1c 	add.w	fp, r4, #28
    4c42:	d907      	bls.n	4c54 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c0>
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
    4c44:	ea4f 0188 	mov.w	r1, r8, lsl #2
    4c48:	f8d4 0518 	ldr.w	r0, [r4, #1304]	; 0x518
    4c4c:	f004 ffac 	bl	9ba8 <realloc>
    4c50:	f8c4 0518 	str.w	r0, [r4, #1304]	; 0x518
      ints_length = ints_lengthT;
    4c54:	f8c4 8510 	str.w	r8, [r4, #1296]	; 0x510
      for( uint32_t i = 0; i < ints_length; i++){
    4c58:	f1b8 0f00 	cmp.w	r8, #0
    4c5c:	f000 8173 	beq.w	4f46 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x6b2>
    4c60:	f204 5314 	addw	r3, r4, #1300	; 0x514
    4c64:	9301      	str	r3, [sp, #4]
    4c66:	2300      	movs	r3, #0
    4c68:	9502      	str	r5, [sp, #8]
    4c6a:	46d8      	mov	r8, fp
    4c6c:	4625      	mov	r5, r4
    4c6e:	f04f 0a04 	mov.w	sl, #4
    4c72:	461c      	mov	r4, r3
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
    4c74:	f898 2006 	ldrb.w	r2, [r8, #6]
    4c78:	f898 0005 	ldrb.w	r0, [r8, #5]
    4c7c:	f898 1004 	ldrb.w	r1, [r8, #4]
    4c80:	f898 e007 	ldrb.w	lr, [r8, #7]
    4c84:	0412      	lsls	r2, r2, #16
    4c86:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
    4c8a:	430a      	orrs	r2, r1
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
    4c8c:	f8d5 0518 	ldr.w	r0, [r5, #1304]	; 0x518
    4c90:	9901      	ldr	r1, [sp, #4]
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
    4c92:	ea42 620e 	orr.w	r2, r2, lr, lsl #24
    4c96:	f8c5 2514 	str.w	r2, [r5, #1300]	; 0x514
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
    4c9a:	eb00 0084 	add.w	r0, r0, r4, lsl #2
    4c9e:	2204      	movs	r2, #4
    4ca0:	f000 ff6a 	bl	5b78 <memcpy>
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
      ints_length = ints_lengthT;
      for( uint32_t i = 0; i < ints_length; i++){
    4ca4:	f8d5 2510 	ldr.w	r2, [r5, #1296]	; 0x510
    4ca8:	3401      	adds	r4, #1
    4caa:	42a2      	cmp	r2, r4
    4cac:	4650      	mov	r0, sl
    4cae:	f108 0804 	add.w	r8, r8, #4
    4cb2:	f10a 0a04 	add.w	sl, sl, #4
    4cb6:	d8dd      	bhi.n	4c74 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e0>
    4cb8:	f100 0109 	add.w	r1, r0, #9
    4cbc:	9101      	str	r1, [sp, #4]
    4cbe:	f100 010b 	add.w	r1, r0, #11
    4cc2:	462c      	mov	r4, r5
    4cc4:	f100 0208 	add.w	r2, r0, #8
    4cc8:	9d02      	ldr	r5, [sp, #8]
    4cca:	9102      	str	r1, [sp, #8]
    4ccc:	f100 010c 	add.w	r1, r0, #12
    4cd0:	f8cd a00c 	str.w	sl, [sp, #12]
    4cd4:	4613      	mov	r3, r2
    4cd6:	f100 0e05 	add.w	lr, r0, #5
    4cda:	f100 0c06 	add.w	ip, r0, #6
    4cde:	f100 0807 	add.w	r8, r0, #7
    4ce2:	f100 0a0a 	add.w	sl, r0, #10
    4ce6:	9104      	str	r1, [sp, #16]
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    4ce8:	f81b 000c 	ldrb.w	r0, [fp, ip]
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    4cec:	9903      	ldr	r1, [sp, #12]
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    4cee:	f81b e00e 	ldrb.w	lr, [fp, lr]
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    4cf2:	f81b c001 	ldrb.w	ip, [fp, r1]
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    4cf6:	f81b 8008 	ldrb.w	r8, [fp, r8]
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
    4cfa:	f8d4 151c 	ldr.w	r1, [r4, #1308]	; 0x51c
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    4cfe:	0400      	lsls	r0, r0, #16
    4d00:	ea40 200e 	orr.w	r0, r0, lr, lsl #8
    4d04:	ea40 0c0c 	orr.w	ip, r0, ip
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    4d08:	ea4c 6808 	orr.w	r8, ip, r8, lsl #24
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
    4d0c:	4588      	cmp	r8, r1
    4d0e:	d90b      	bls.n	4d28 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x494>
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
    4d10:	ea4f 0188 	mov.w	r1, r8, lsl #2
    4d14:	f8d4 0524 	ldr.w	r0, [r4, #1316]	; 0x524
    4d18:	9305      	str	r3, [sp, #20]
    4d1a:	9203      	str	r2, [sp, #12]
    4d1c:	f004 ff44 	bl	9ba8 <realloc>
    4d20:	9b05      	ldr	r3, [sp, #20]
    4d22:	9a03      	ldr	r2, [sp, #12]
    4d24:	f8c4 0524 	str.w	r0, [r4, #1316]	; 0x524
      floats_length = floats_lengthT;
    4d28:	f8c4 851c 	str.w	r8, [r4, #1308]	; 0x51c
      for( uint32_t i = 0; i < floats_length; i++){
    4d2c:	f1b8 0f00 	cmp.w	r8, #0
    4d30:	f000 8106 	beq.w	4f40 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x6ac>
    4d34:	f504 62a4 	add.w	r2, r4, #1312	; 0x520
    4d38:	9201      	str	r2, [sp, #4]
    4d3a:	f204 520c 	addw	r2, r4, #1292	; 0x50c
    4d3e:	9503      	str	r5, [sp, #12]
    4d40:	eb0b 0a03 	add.w	sl, fp, r3
    4d44:	4625      	mov	r5, r4
    4d46:	f04f 0800 	mov.w	r8, #0
    4d4a:	9202      	str	r2, [sp, #8]
    4d4c:	461c      	mov	r4, r3
      } u_st_floats;
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    4d4e:	f89a 0002 	ldrb.w	r0, [sl, #2]
    4d52:	f89a 2001 	ldrb.w	r2, [sl, #1]
    4d56:	f89a 1000 	ldrb.w	r1, [sl]
    4d5a:	f89a e003 	ldrb.w	lr, [sl, #3]
      this->st_floats = u_st_floats.real;
    4d5e:	9b02      	ldr	r3, [sp, #8]
      } u_st_floats;
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    4d60:	0400      	lsls	r0, r0, #16
    4d62:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    4d66:	430a      	orrs	r2, r1
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    4d68:	f8d5 0524 	ldr.w	r0, [r5, #1316]	; 0x524
    4d6c:	9901      	ldr	r1, [sp, #4]
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
    4d6e:	ea42 620e 	orr.w	r2, r2, lr, lsl #24
    4d72:	615a      	str	r2, [r3, #20]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    4d74:	eb00 0088 	add.w	r0, r0, r8, lsl #2
    4d78:	2204      	movs	r2, #4
    4d7a:	f000 fefd 	bl	5b78 <memcpy>
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
      floats_length = floats_lengthT;
      for( uint32_t i = 0; i < floats_length; i++){
    4d7e:	f8d5 251c 	ldr.w	r2, [r5, #1308]	; 0x51c
    4d82:	f108 0801 	add.w	r8, r8, #1
    4d86:	4542      	cmp	r2, r8
    4d88:	4621      	mov	r1, r4
    4d8a:	f10a 0a04 	add.w	sl, sl, #4
    4d8e:	f104 0404 	add.w	r4, r4, #4
    4d92:	d8dc      	bhi.n	4d4e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x4ba>
    4d94:	4623      	mov	r3, r4
    4d96:	461a      	mov	r2, r3
    4d98:	1d4b      	adds	r3, r1, #5
    4d9a:	462c      	mov	r4, r5
    4d9c:	9301      	str	r3, [sp, #4]
    4d9e:	9d03      	ldr	r5, [sp, #12]
    4da0:	1dcb      	adds	r3, r1, #7
    4da2:	f101 0a06 	add.w	sl, r1, #6
    4da6:	9302      	str	r3, [sp, #8]
    4da8:	f101 0808 	add.w	r8, r1, #8
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    4dac:	9b01      	ldr	r3, [sp, #4]
    4dae:	f81b 000a 	ldrb.w	r0, [fp, sl]
    4db2:	f81b 1003 	ldrb.w	r1, [fp, r3]
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    4db6:	f81b 3002 	ldrb.w	r3, [fp, r2]
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    4dba:	9a02      	ldr	r2, [sp, #8]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    4dbc:	0400      	lsls	r0, r0, #16
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    4dbe:	f81b a002 	ldrb.w	sl, [fp, r2]
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
    4dc2:	f8d4 2528 	ldr.w	r2, [r4, #1320]	; 0x528
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    4dc6:	ea40 2101 	orr.w	r1, r0, r1, lsl #8
    4dca:	430b      	orrs	r3, r1
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    4dcc:	ea43 6a0a 	orr.w	sl, r3, sl, lsl #24
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
    4dd0:	4592      	cmp	sl, r2
    4dd2:	d907      	bls.n	4de4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x550>
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
    4dd4:	ea4f 018a 	mov.w	r1, sl, lsl #2
    4dd8:	f8d4 0530 	ldr.w	r0, [r4, #1328]	; 0x530
    4ddc:	f004 fee4 	bl	9ba8 <realloc>
    4de0:	f8c4 0530 	str.w	r0, [r4, #1328]	; 0x530
      strings_length = strings_lengthT;
    4de4:	f8c4 a528 	str.w	sl, [r4, #1320]	; 0x528
      for( uint32_t i = 0; i < strings_length; i++){
    4de8:	f1ba 0f00 	cmp.w	sl, #0
    4dec:	d039      	beq.n	4e62 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x5ce>
    4dee:	f204 532c 	addw	r3, r4, #1324	; 0x52c
    4df2:	f04f 0a00 	mov.w	sl, #0
    4df6:	9301      	str	r3, [sp, #4]
      uint32_t length_st_strings;
      arrToVar(length_st_strings, (inbuffer + offset));
    4df8:	2300      	movs	r3, #0

  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    4dfa:	469e      	mov	lr, r3
    4dfc:	eb0b 0108 	add.w	r1, fp, r8
    for (size_t i = 0; i < sizeof(V); i++)
      var |= (arr[i] << (8 * i));
    4e00:	f811 2b01 	ldrb.w	r2, [r1], #1
    4e04:	409a      	lsls	r2, r3
    4e06:	3308      	adds	r3, #8
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
    4e08:	2b20      	cmp	r3, #32
      var |= (arr[i] << (8 * i));
    4e0a:	ea4e 0e02 	orr.w	lr, lr, r2
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
    4e0e:	d1f7      	bne.n	4e00 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x56c>
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
    4e10:	f108 0104 	add.w	r1, r8, #4
    4e14:	448e      	add	lr, r1
    4e16:	4571      	cmp	r1, lr
    4e18:	d20a      	bcs.n	4e30 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x59c>
    4e1a:	f108 0303 	add.w	r3, r8, #3
    4e1e:	445b      	add	r3, fp
    4e20:	460a      	mov	r2, r1
    4e22:	3201      	adds	r2, #1
          inbuffer[k-1]=inbuffer[k];
    4e24:	f813 0f01 	ldrb.w	r0, [r3, #1]!
    4e28:	f803 0c01 	strb.w	r0, [r3, #-1]
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
      uint32_t length_st_strings;
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
    4e2c:	4572      	cmp	r2, lr
    4e2e:	d3f8      	bcc.n	4e22 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x58e>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    4e30:	eb0b 020e 	add.w	r2, fp, lr
      this->st_strings = (char *)(inbuffer + offset-1);
    4e34:	1e4b      	subs	r3, r1, #1
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    4e36:	f04f 0100 	mov.w	r1, #0
    4e3a:	f802 1c01 	strb.w	r1, [r2, #-1]
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    4e3e:	f8d4 0530 	ldr.w	r0, [r4, #1328]	; 0x530
    4e42:	9901      	ldr	r1, [sp, #4]
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
    4e44:	445b      	add	r3, fp
    4e46:	f8c4 352c 	str.w	r3, [r4, #1324]	; 0x52c
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    4e4a:	eb00 008a 	add.w	r0, r0, sl, lsl #2
    4e4e:	2204      	movs	r2, #4
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
    4e50:	46f0      	mov	r8, lr
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    4e52:	f000 fe91 	bl	5b78 <memcpy>
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
    4e56:	f8d4 3528 	ldr.w	r3, [r4, #1320]	; 0x528
    4e5a:	f10a 0a01 	add.w	sl, sl, #1
    4e5e:	4553      	cmp	r3, sl
    4e60:	d8ca      	bhi.n	4df8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x564>
            param_received = true;
    4e62:	2301      	movs	r3, #1
    4e64:	f884 3508 	strb.w	r3, [r4, #1288]	; 0x508
    4e68:	e533      	b.n	48d2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4e6a:	6833      	ldr	r3, [r6, #0]
    4e6c:	930c      	str	r3, [sp, #48]	; 0x30
	return ret;
    4e6e:	980c      	ldr	r0, [sp, #48]	; 0x30
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    4e70:	f894 2020 	ldrb.w	r2, [r4, #32]
    4e74:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4e78:	6833      	ldr	r3, [r6, #0]
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    4e7a:	f894 801d 	ldrb.w	r8, [r4, #29]
    4e7e:	f894 a01c 	ldrb.w	sl, [r4, #28]
    4e82:	930e      	str	r3, [sp, #56]	; 0x38
  }

  void syncTime(uint8_t * data)
  {
    std_msgs::Time t;
    uint32_t offset = hardware_.time() - rt_time;
    4e84:	68e3      	ldr	r3, [r4, #12]
    4e86:	f894 e01e 	ldrb.w	lr, [r4, #30]
    4e8a:	f894 b01f 	ldrb.w	fp, [r4, #31]
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    4e8e:	ea42 2c01 	orr.w	ip, r2, r1, lsl #8
    4e92:	f894 1022 	ldrb.w	r1, [r4, #34]	; 0x22
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    4e96:	4a1c      	ldr	r2, [pc, #112]	; (4f08 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x674>)
  }

  void syncTime(uint8_t * data)
  {
    std_msgs::Time t;
    uint32_t offset = hardware_.time() - rt_time;
    4e98:	1ac0      	subs	r0, r0, r3
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    4e9a:	ea4a 2308 	orr.w	r3, sl, r8, lsl #8
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    4e9e:	f894 a023 	ldrb.w	sl, [r4, #35]	; 0x23
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    4ea2:	fba2 8200 	umull	r8, r2, r2, r0
    4ea6:	ea4c 4101 	orr.w	r1, ip, r1, lsl #16
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    4eaa:	ea43 4e0e 	orr.w	lr, r3, lr, lsl #16
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    4eae:	f8df 805c 	ldr.w	r8, [pc, #92]	; 4f0c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x678>
	return ret;
    4eb2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    4eb4:	ea41 6a0a 	orr.w	sl, r1, sl, lsl #24
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    4eb8:	ea4e 610b 	orr.w	r1, lr, fp, lsl #24
    4ebc:	44d0      	add	r8, sl
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    4ebe:	f101 3aff 	add.w	sl, r1, #4294967295	; 0xffffffff
    4ec2:	4911      	ldr	r1, [pc, #68]	; (4f08 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x674>)
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    4ec4:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    4ec8:	fba1 1e03 	umull	r1, lr, r1, r3
    4ecc:	0992      	lsrs	r2, r2, #6
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    4ece:	fb0c 0012 	mls	r0, ip, r2, r0
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    4ed2:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    4ed6:	fb09 8000 	mla	r0, r9, r0, r8
    4eda:	fb0c 331e 	mls	r3, ip, lr, r3
    4ede:	4621      	mov	r1, r4
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    4ee0:	4452      	add	r2, sl
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    4ee2:	fb09 0313 	mls	r3, r9, r3, r0
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    4ee6:	ebce 0202 	rsb	r2, lr, r2
    4eea:	6122      	str	r2, [r4, #16]
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    normalizeSecNSec(sec_offset, nsec_offset);
    4eec:	f104 0010 	add.w	r0, r4, #16

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    4ef0:	f841 3f14 	str.w	r3, [r1, #20]!
    normalizeSecNSec(sec_offset, nsec_offset);
    4ef4:	f000 fe2c 	bl	5b50 <ros::normalizeSecNSec(unsigned long&, unsigned long&)>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4ef8:	6833      	ldr	r3, [r6, #0]
    4efa:	930d      	str	r3, [sp, #52]	; 0x34
	return ret;
    4efc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    t.deserialize(data);
    t.data.sec += offset / 1000;
    t.data.nsec += (offset % 1000) * 1000000UL;

    this->setNow(t.data);
    last_sync_receive_time = hardware_.time();
    4efe:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
    4f02:	e4e6      	b.n	48d2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3e>
    4f04:	00000c49 	.word	0x00000c49
    4f08:	10624dd3 	.word	0x10624dd3
    4f0c:	3b9aca00 	.word	0x3b9aca00
   */

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    4f10:	6822      	ldr	r2, [r4, #0]
    public:
      typedef ros::Time _data_type;
      _data_type data;

    Time():
      data()
    4f12:	4916      	ldr	r1, [pc, #88]	; (4f6c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x6d8>)
    4f14:	910f      	str	r1, [sp, #60]	; 0x3c
    4f16:	9310      	str	r3, [sp, #64]	; 0x40
    4f18:	9311      	str	r3, [sp, #68]	; 0x44
    4f1a:	210a      	movs	r1, #10
    4f1c:	6813      	ldr	r3, [r2, #0]
    4f1e:	4620      	mov	r0, r4
    4f20:	aa0f      	add	r2, sp, #60	; 0x3c
    4f22:	4798      	blx	r3
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4f24:	6833      	ldr	r3, [r6, #0]
    4f26:	930a      	str	r3, [sp, #40]	; 0x28
	return ret;
    4f28:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    rt_time = hardware_.time();
    4f2a:	60e3      	str	r3, [r4, #12]
        if ((checksum_ % 256) == 255)
        {
          if (topic_ == TopicInfo::ID_PUBLISHER)
          {
            requestSyncTime();
            negotiateTopics();
    4f2c:	4620      	mov	r0, r4
    4f2e:	f7ff fa2f 	bl	4390 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()>
            last_sync_time = c_time;
    4f32:	f8c4 54fc 	str.w	r5, [r4, #1276]	; 0x4fc
            last_sync_receive_time = c_time;
    4f36:	f8c4 5500 	str.w	r5, [r4, #1280]	; 0x500
            return SPIN_ERR;
    4f3a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    4f3e:	e4f2      	b.n	4926 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x92>
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
      floats_length = floats_lengthT;
      for( uint32_t i = 0; i < floats_length; i++){
    4f40:	f8dd 8010 	ldr.w	r8, [sp, #16]
    4f44:	e732      	b.n	4dac <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x518>
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
      ints_length = ints_lengthT;
      for( uint32_t i = 0; i < ints_length; i++){
    4f46:	210c      	movs	r1, #12
    4f48:	9104      	str	r1, [sp, #16]
    4f4a:	210b      	movs	r1, #11
    4f4c:	9102      	str	r1, [sp, #8]
    4f4e:	2109      	movs	r1, #9
    4f50:	2208      	movs	r2, #8
    4f52:	9101      	str	r1, [sp, #4]
    4f54:	2104      	movs	r1, #4
    4f56:	4613      	mov	r3, r2
    4f58:	f04f 0a0a 	mov.w	sl, #10
    4f5c:	f04f 0807 	mov.w	r8, #7
    4f60:	f04f 0c06 	mov.w	ip, #6
    4f64:	f04f 0e05 	mov.w	lr, #5
    4f68:	9103      	str	r1, [sp, #12]
    4f6a:	e6bd      	b.n	4ce8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x454>
    4f6c:	0000a7bc 	.word	0x0000a7bc

00004f70 <_GLOBAL__sub_I_error_l>:
    speed_pub.publish(&wheel_speed);
  }
  nh.spinOnce();
  //}
  //delay(100);
  }
    4f70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
int left_count_tick;
float wheel_base = 0.229;            // needs to be updated and use the right unit (proberbly meters)
float wheel_radius = 0.04;           // needs to be updated and use the right unit (proberbly meters)
int16_t accel_X, accel_Y, accel_Z, tmp, gyro_X, gyro_Y, gyro_Z, mx, my, mz;
long publisher_timer;
MPU9250 accelgyro;
    4f72:	486b      	ldr	r0, [pc, #428]	; (5120 <_GLOBAL__sub_I_error_l+0x1b0>)
template<class Hardware,
         int MAX_SUBSCRIBERS = 25,
         int MAX_PUBLISHERS = 25,
         int INPUT_SIZE = 512,
         int OUTPUT_SIZE = 512>
class NodeHandle_ : public NodeHandleBase_
    4f74:	4d6b      	ldr	r5, [pc, #428]	; (5124 <_GLOBAL__sub_I_error_l+0x1b4>)
      /* Leonardo support */
      iostream = &Serial1;
#elif defined(USE_TEENSY_HW_SERIAL) or defined(USE_STM32_HW_SERIAL)
      iostream = &Serial1;
#else
      iostream = &Serial;
    4f76:	4e6c      	ldr	r6, [pc, #432]	; (5128 <_GLOBAL__sub_I_error_l+0x1b8>)
    4f78:	f000 fdc0 	bl	5afc <MPU9250::MPU9250()>
    4f7c:	4b6b      	ldr	r3, [pc, #428]	; (512c <_GLOBAL__sub_I_error_l+0x1bc>)
    4f7e:	602b      	str	r3, [r5, #0]
    4f80:	2400      	movs	r4, #0
#endif
      baud_ = 57600;
    4f82:	f44f 4361 	mov.w	r3, #57600	; 0xe100
    4f86:	f44f 7700 	mov.w	r7, #512	; 0x200
    4f8a:	60ab      	str	r3, [r5, #8]
    4f8c:	4621      	mov	r1, r4
    4f8e:	463a      	mov	r2, r7
      /* Leonardo support */
      iostream = &Serial1;
#elif defined(USE_TEENSY_HW_SERIAL) or defined(USE_STM32_HW_SERIAL)
      iostream = &Serial1;
#else
      iostream = &Serial;
    4f90:	606e      	str	r6, [r5, #4]
    4f92:	f105 001c 	add.w	r0, r5, #28
    4f96:	60ec      	str	r4, [r5, #12]
    4f98:	612c      	str	r4, [r5, #16]
    4f9a:	616c      	str	r4, [r5, #20]
    4f9c:	61ac      	str	r4, [r5, #24]
    4f9e:	2664      	movs	r6, #100	; 0x64
    4fa0:	f004 fdb0 	bl	9b04 <memset>
    4fa4:	463a      	mov	r2, r7
    4fa6:	4621      	mov	r1, r4
    4fa8:	f505 7007 	add.w	r0, r5, #540	; 0x21c
    4fac:	f004 fdaa 	bl	9b04 <memset>
    4fb0:	4621      	mov	r1, r4
    4fb2:	4632      	mov	r2, r6
    4fb4:	f205 401c 	addw	r0, r5, #1052	; 0x41c
    4fb8:	f004 fda4 	bl	9b04 <memset>
    4fbc:	4632      	mov	r2, r6
    4fbe:	4621      	mov	r1, r4
    4fc0:	f505 6090 	add.w	r0, r5, #1152	; 0x480
    4fc4:	f004 fd9e 	bl	9b04 <memset>
      _strings_type * strings;

    RequestParamResponse():
      ints_length(0), st_ints(), ints(nullptr),
      floats_length(0), st_floats(), floats(nullptr),
      strings_length(0), st_strings(), strings(nullptr)
    4fc8:	4859      	ldr	r0, [pc, #356]	; (5130 <_GLOBAL__sub_I_error_l+0x1c0>)
    4fca:	f8c5 44e4 	str.w	r4, [r5, #1252]	; 0x4e4
    4fce:	f8c5 44e8 	str.w	r4, [r5, #1256]	; 0x4e8
    4fd2:	f8c5 44ec 	str.w	r4, [r5, #1260]	; 0x4ec
    4fd6:	f8c5 44f0 	str.w	r4, [r5, #1264]	; 0x4f0
    4fda:	f8c5 44f4 	str.w	r4, [r5, #1268]	; 0x4f4
    4fde:	f885 44f8 	strb.w	r4, [r5, #1272]	; 0x4f8
    4fe2:	f8c5 44fc 	str.w	r4, [r5, #1276]	; 0x4fc
    4fe6:	f8c5 4500 	str.w	r4, [r5, #1280]	; 0x500
    4fea:	f8c5 4504 	str.w	r4, [r5, #1284]	; 0x504
    4fee:	f885 4508 	strb.w	r4, [r5, #1288]	; 0x508
    4ff2:	f8c5 4510 	str.w	r4, [r5, #1296]	; 0x510
    4ff6:	f8c5 4514 	str.w	r4, [r5, #1300]	; 0x514
    4ffa:	f8c5 4518 	str.w	r4, [r5, #1304]	; 0x518
    4ffe:	f8c5 451c 	str.w	r4, [r5, #1308]	; 0x51c
    5002:	f8c5 4524 	str.w	r4, [r5, #1316]	; 0x524
    5006:	f8c5 4528 	str.w	r4, [r5, #1320]	; 0x528
    500a:	f8c5 452c 	str.w	r4, [r5, #1324]	; 0x52c
    500e:	f8c5 4530 	str.w	r4, [r5, #1328]	; 0x530
    5012:	f8c5 050c 	str.w	r0, [r5, #1292]	; 0x50c
    5016:	f505 65a4 	add.w	r5, r5, #1312	; 0x520
    501a:	2300      	movs	r3, #0
    public:
      typedef int16_t _data_type;
      _data_type data;

    Int16():
      data(0)
    501c:	4945      	ldr	r1, [pc, #276]	; (5134 <_GLOBAL__sub_I_error_l+0x1c4>)
{
public:
  Publisher(const char * topic_name, Msg * msg, int endpoint = rosserial_msgs::TopicInfo::ID_PUBLISHER) :
    topic_(topic_name),
    msg_(msg),
    endpoint_(endpoint) {};
    501e:	4a46      	ldr	r2, [pc, #280]	; (5138 <_GLOBAL__sub_I_error_l+0x1c8>)
    5020:	f8df e18c 	ldr.w	lr, [pc, #396]	; 51b0 <_GLOBAL__sub_I_error_l+0x240>
    public:
      typedef float _data_type;
      _data_type data;

    Float32():
      data(0)
    5024:	4e45      	ldr	r6, [pc, #276]	; (513c <_GLOBAL__sub_I_error_l+0x1cc>)
    5026:	4f46      	ldr	r7, [pc, #280]	; (5140 <_GLOBAL__sub_I_error_l+0x1d0>)
    5028:	602b      	str	r3, [r5, #0]
    502a:	4d46      	ldr	r5, [pc, #280]	; (5144 <_GLOBAL__sub_I_error_l+0x1d4>)
    502c:	f8df c184 	ldr.w	ip, [pc, #388]	; 51b4 <_GLOBAL__sub_I_error_l+0x244>
    5030:	4845      	ldr	r0, [pc, #276]	; (5148 <_GLOBAL__sub_I_error_l+0x1d8>)
    5032:	808c      	strh	r4, [r1, #4]
    5034:	600f      	str	r7, [r1, #0]
    5036:	6051      	str	r1, [r2, #4]
    5038:	f8ce 5000 	str.w	r5, [lr]
    503c:	4943      	ldr	r1, [pc, #268]	; (514c <_GLOBAL__sub_I_error_l+0x1dc>)
    503e:	4d44      	ldr	r5, [pc, #272]	; (5150 <_GLOBAL__sub_I_error_l+0x1e0>)
    5040:	6114      	str	r4, [r2, #16]
    5042:	6011      	str	r1, [r2, #0]
    5044:	6035      	str	r5, [r6, #0]

    Quaternion():
      x(0),
      y(0),
      z(0),
      w(0)
    5046:	4a43      	ldr	r2, [pc, #268]	; (5154 <_GLOBAL__sub_I_error_l+0x1e4>)
    5048:	4943      	ldr	r1, [pc, #268]	; (5158 <_GLOBAL__sub_I_error_l+0x1e8>)
    504a:	4d44      	ldr	r5, [pc, #272]	; (515c <_GLOBAL__sub_I_error_l+0x1ec>)
    504c:	f8cc 7000 	str.w	r7, [ip]
    5050:	f8ac 4004 	strh.w	r4, [ip, #4]
    5054:	f8ce c004 	str.w	ip, [lr, #4]
    5058:	f8ce 4010 	str.w	r4, [lr, #16]
    505c:	6073      	str	r3, [r6, #4]
    505e:	6005      	str	r5, [r0, #0]
    5060:	6046      	str	r6, [r0, #4]
    5062:	6104      	str	r4, [r0, #16]
    5064:	483e      	ldr	r0, [pc, #248]	; (5160 <_GLOBAL__sub_I_error_l+0x1f0>)
      _z_type z;

    Vector3():
      x(0),
      y(0),
      z(0)
    5066:	4d3f      	ldr	r5, [pc, #252]	; (5164 <_GLOBAL__sub_I_error_l+0x1f4>)
    5068:	f8df e14c 	ldr.w	lr, [pc, #332]	; 51b8 <_GLOBAL__sub_I_error_l+0x248>
    506c:	6010      	str	r0, [r2, #0]
    506e:	6053      	str	r3, [r2, #4]
    5070:	6093      	str	r3, [r2, #8]
    5072:	60d3      	str	r3, [r2, #12]
    5074:	604a      	str	r2, [r1, #4]
    5076:	6113      	str	r3, [r2, #16]
    5078:	4a3b      	ldr	r2, [pc, #236]	; (5168 <_GLOBAL__sub_I_error_l+0x1f8>)
    507a:	483c      	ldr	r0, [pc, #240]	; (516c <_GLOBAL__sub_I_error_l+0x1fc>)
    507c:	4e3c      	ldr	r6, [pc, #240]	; (5170 <_GLOBAL__sub_I_error_l+0x200>)
    507e:	610c      	str	r4, [r1, #16]
    5080:	600a      	str	r2, [r1, #0]
    5082:	493c      	ldr	r1, [pc, #240]	; (5174 <_GLOBAL__sub_I_error_l+0x204>)
    5084:	f8ce 5004 	str.w	r5, [lr, #4]
    5088:	6029      	str	r1, [r5, #0]
    508a:	606b      	str	r3, [r5, #4]
    508c:	60ab      	str	r3, [r5, #8]
    508e:	60eb      	str	r3, [r5, #12]
    5090:	4d39      	ldr	r5, [pc, #228]	; (5178 <_GLOBAL__sub_I_error_l+0x208>)
    5092:	4a3a      	ldr	r2, [pc, #232]	; (517c <_GLOBAL__sub_I_error_l+0x20c>)
    5094:	f8ce 4010 	str.w	r4, [lr, #16]
    5098:	f8ce 5000 	str.w	r5, [lr]
    509c:	6070      	str	r0, [r6, #4]
    509e:	f8df e11c 	ldr.w	lr, [pc, #284]	; 51bc <_GLOBAL__sub_I_error_l+0x24c>
    50a2:	6001      	str	r1, [r0, #0]
    50a4:	6043      	str	r3, [r0, #4]
    50a6:	6083      	str	r3, [r0, #8]
    50a8:	60c3      	str	r3, [r0, #12]
    50aa:	4835      	ldr	r0, [pc, #212]	; (5180 <_GLOBAL__sub_I_error_l+0x210>)
    50ac:	4d35      	ldr	r5, [pc, #212]	; (5184 <_GLOBAL__sub_I_error_l+0x214>)
    50ae:	6134      	str	r4, [r6, #16]
    50b0:	6030      	str	r0, [r6, #0]
  typedef void(*CallbackT)(const MsgT&);
  MsgT msg;

  Subscriber(const char * topic_name, CallbackT cb, int endpoint = rosserial_msgs::TopicInfo::ID_SUBSCRIBER) :
    cb_(cb),
    endpoint_(endpoint)
    50b2:	4835      	ldr	r0, [pc, #212]	; (5188 <_GLOBAL__sub_I_error_l+0x218>)
    50b4:	4e35      	ldr	r6, [pc, #212]	; (518c <_GLOBAL__sub_I_error_l+0x21c>)
    50b6:	f8ce 2004 	str.w	r2, [lr, #4]
    50ba:	6011      	str	r1, [r2, #0]
    50bc:	6053      	str	r3, [r2, #4]
    50be:	6093      	str	r3, [r2, #8]
    50c0:	60d3      	str	r3, [r2, #12]
    50c2:	4a33      	ldr	r2, [pc, #204]	; (5190 <_GLOBAL__sub_I_error_l+0x220>)
    50c4:	f8ce 4010 	str.w	r4, [lr, #16]
    50c8:	f8ce 2000 	str.w	r2, [lr]
    50cc:	6029      	str	r1, [r5, #0]
    50ce:	4a31      	ldr	r2, [pc, #196]	; (5194 <_GLOBAL__sub_I_error_l+0x224>)
    50d0:	606b      	str	r3, [r5, #4]
    50d2:	f8df c0ec 	ldr.w	ip, [pc, #236]	; 51c0 <_GLOBAL__sub_I_error_l+0x250>
    50d6:	60c7      	str	r7, [r0, #12]
    50d8:	8204      	strh	r4, [r0, #16]
    50da:	4f2f      	ldr	r7, [pc, #188]	; (5198 <_GLOBAL__sub_I_error_l+0x228>)
    50dc:	6075      	str	r5, [r6, #4]
    50de:	6134      	str	r4, [r6, #16]
    50e0:	60ab      	str	r3, [r5, #8]
    50e2:	2401      	movs	r4, #1
    50e4:	60eb      	str	r3, [r5, #12]
    50e6:	f8df e0dc 	ldr.w	lr, [pc, #220]	; 51c4 <_GLOBAL__sub_I_error_l+0x254>
  {
    topic_ = topic_name;
    50ea:	4d2c      	ldr	r5, [pc, #176]	; (519c <_GLOBAL__sub_I_error_l+0x22c>)
    50ec:	6037      	str	r7, [r6, #0]
    50ee:	6085      	str	r5, [r0, #8]
  typedef void(*CallbackT)(const MsgT&);
  MsgT msg;

  Subscriber(const char * topic_name, CallbackT cb, int endpoint = rosserial_msgs::TopicInfo::ID_SUBSCRIBER) :
    cb_(cb),
    endpoint_(endpoint)
    50f0:	4f2b      	ldr	r7, [pc, #172]	; (51a0 <_GLOBAL__sub_I_error_l+0x230>)
    50f2:	f8c0 c000 	str.w	ip, [r0]
    50f6:	f8c0 e014 	str.w	lr, [r0, #20]
      typedef geometry_msgs::Vector3 _angular_type;
      _angular_type angular;

    Twist():
      linear(),
      angular()
    50fa:	4e2a      	ldr	r6, [pc, #168]	; (51a4 <_GLOBAL__sub_I_error_l+0x234>)
    50fc:	4d2a      	ldr	r5, [pc, #168]	; (51a8 <_GLOBAL__sub_I_error_l+0x238>)
    50fe:	6184      	str	r4, [r0, #24]
  {
    topic_ = topic_name;
    5100:	482a      	ldr	r0, [pc, #168]	; (51ac <_GLOBAL__sub_I_error_l+0x23c>)
  typedef void(*CallbackT)(const MsgT&);
  MsgT msg;

  Subscriber(const char * topic_name, CallbackT cb, int endpoint = rosserial_msgs::TopicInfo::ID_SUBSCRIBER) :
    cb_(cb),
    endpoint_(endpoint)
    5102:	6354      	str	r4, [r2, #52]	; 0x34
    5104:	6111      	str	r1, [r2, #16]
    5106:	6153      	str	r3, [r2, #20]
    5108:	6193      	str	r3, [r2, #24]
    510a:	61d3      	str	r3, [r2, #28]
    510c:	6211      	str	r1, [r2, #32]
    510e:	6253      	str	r3, [r2, #36]	; 0x24
    5110:	6293      	str	r3, [r2, #40]	; 0x28
    5112:	62d3      	str	r3, [r2, #44]	; 0x2c
    5114:	6017      	str	r7, [r2, #0]
    5116:	60d6      	str	r6, [r2, #12]
    5118:	6315      	str	r5, [r2, #48]	; 0x30
  {
    topic_ = topic_name;
    511a:	6090      	str	r0, [r2, #8]
    511c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    511e:	bf00      	nop
    5120:	1fff1c80 	.word	0x1fff1c80
    5124:	1fff1d88 	.word	0x1fff1d88
    5128:	1fff0b2c 	.word	0x1fff0b2c
    512c:	0000a894 	.word	0x0000a894
    5130:	0000a804 	.word	0x0000a804
    5134:	1fff1d1c 	.word	0x1fff1d1c
    5138:	1fff1468 	.word	0x1fff1468
    513c:	1fff2b04 	.word	0x1fff2b04
    5140:	0000a81c 	.word	0x0000a81c
    5144:	0000abc8 	.word	0x0000abc8
    5148:	1fff2aa0 	.word	0x1fff2aa0
    514c:	0000abbc 	.word	0x0000abbc
    5150:	0000a834 	.word	0x0000a834
    5154:	1fff2ad8 	.word	0x1fff2ad8
    5158:	1fff1d4c 	.word	0x1fff1d4c
    515c:	0000abd4 	.word	0x0000abd4
    5160:	0000a864 	.word	0x0000a864
    5164:	1fff14a0 	.word	0x1fff14a0
    5168:	0000abe0 	.word	0x0000abe0
    516c:	1fff1cd0 	.word	0x1fff1cd0
    5170:	1fff1d24 	.word	0x1fff1d24
    5174:	0000a84c 	.word	0x0000a84c
    5178:	0000abf0 	.word	0x0000abf0
    517c:	1fff1cbc 	.word	0x1fff1cbc
    5180:	0000abf8 	.word	0x0000abf8
    5184:	1fff1444 	.word	0x1fff1444
    5188:	1fff2ab4 	.word	0x1fff2ab4
    518c:	1fff2b1c 	.word	0x1fff2b1c
    5190:	0000ac04 	.word	0x0000ac04
    5194:	1fff1ce4 	.word	0x1fff1ce4
    5198:	0000ac0c 	.word	0x0000ac0c
    519c:	0000ac24 	.word	0x0000ac24
    51a0:	0000a8a8 	.word	0x0000a8a8
    51a4:	0000a87c 	.word	0x0000a87c
    51a8:	000030b5 	.word	0x000030b5
    51ac:	0000ac1c 	.word	0x0000ac1c
    51b0:	1fff1c90 	.word	0x1fff1c90
    51b4:	1fff2aec 	.word	0x1fff2aec
    51b8:	1fff1ca4 	.word	0x1fff1ca4
    51bc:	1fff1d38 	.word	0x1fff1d38
    51c0:	0000a8c0 	.word	0x0000a8c0
    51c4:	00002dad 	.word	0x00002dad

000051c8 <TwoWire::available()>:
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    51c8:	f890 2039 	ldrb.w	r2, [r0, #57]	; 0x39
    51cc:	f890 0038 	ldrb.w	r0, [r0, #56]	; 0x38
	}
    51d0:	1a10      	subs	r0, r2, r0
    51d2:	4770      	bx	lr

000051d4 <TwoWire::read()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    51d4:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
    51d8:	f890 2039 	ldrb.w	r2, [r0, #57]	; 0x39
    51dc:	429a      	cmp	r2, r3
    51de:	d905      	bls.n	51ec <TwoWire::read()+0x18>
		return rxBuffer[rxBufferIndex++];
    51e0:	1c5a      	adds	r2, r3, #1
    51e2:	4403      	add	r3, r0
    51e4:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    51e8:	7e18      	ldrb	r0, [r3, #24]
    51ea:	4770      	bx	lr
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    51ec:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		return rxBuffer[rxBufferIndex++];
	}
    51f0:	4770      	bx	lr
    51f2:	bf00      	nop

000051f4 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)>:
 * @param length Number of bytes to read
 * @param data Buffer to store read data in
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Number of bytes read (-1 indicates failure)
 */
int8_t I2Cdev::readBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t *data, uint16_t timeout, void *wireObj) {
    51f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    51f8:	f8df a144 	ldr.w	sl, [pc, #324]	; 5340 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x14c>

    int8_t count = 0;
    uint32_t t1 = millis();

    #if (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
        TwoWire *useWire = &Wire;
    51fc:	4d4e      	ldr	r5, [pc, #312]	; (5338 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x144>)
    51fe:	f8da 6000 	ldr.w	r6, [sl]
 * @param length Number of bytes to read
 * @param data Buffer to store read data in
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Number of bytes read (-1 indicates failure)
 */
int8_t I2Cdev::readBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t *data, uint16_t timeout, void *wireObj) {
    5202:	b08d      	sub	sp, #52	; 0x34
    5204:	4699      	mov	r9, r3
    5206:	9c17      	ldr	r4, [sp, #92]	; 0x5c
    5208:	9609      	str	r6, [sp, #36]	; 0x24
    520a:	9006      	str	r0, [sp, #24]
    520c:	9107      	str	r1, [sp, #28]
	return ret;
    520e:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
    5212:	f8bd 6058 	ldrh.w	r6, [sp, #88]	; 0x58
            // Adds official support for repeated start condition, yay!

            // I2C/TWI subsystem uses internal buffer that breaks with large data requests
            // so if user requests more than I2CDEVLIB_WIRE_BUFFER_LENGTH bytes, we have to do it in
            // smaller chunks instead of all at once
            for (int k = 0; k < length; k += min((int)length, I2CDEVLIB_WIRE_BUFFER_LENGTH)) {
    5216:	9204      	str	r2, [sp, #16]

    int8_t count = 0;
    uint32_t t1 = millis();

    #if (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
        TwoWire *useWire = &Wire;
    5218:	2c00      	cmp	r4, #0
    521a:	bf08      	it	eq
    521c:	462c      	moveq	r4, r5
            // Adds official support for repeated start condition, yay!

            // I2C/TWI subsystem uses internal buffer that breaks with large data requests
            // so if user requests more than I2CDEVLIB_WIRE_BUFFER_LENGTH bytes, we have to do it in
            // smaller chunks instead of all at once
            for (int k = 0; k < length; k += min((int)length, I2CDEVLIB_WIRE_BUFFER_LENGTH)) {
    521e:	2a00      	cmp	r2, #0
    5220:	d076      	beq.n	5310 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x11c>
    5222:	0043      	lsls	r3, r0, #1
    5224:	2a20      	cmp	r2, #32
    5226:	4610      	mov	r0, r2
    5228:	b2db      	uxtb	r3, r3
    522a:	bfa8      	it	ge
    522c:	2220      	movge	r2, #32
    522e:	4f43      	ldr	r7, [pc, #268]	; (533c <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x148>)
    5230:	f8df 8110 	ldr.w	r8, [pc, #272]	; 5344 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x150>
    5234:	9205      	str	r2, [sp, #20]
    5236:	9303      	str	r3, [sp, #12]
    5238:	9202      	str	r2, [sp, #8]
    523a:	9001      	str	r0, [sp, #4]
    523c:	2500      	movs	r5, #0
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    523e:	f89d 200c 	ldrb.w	r2, [sp, #12]
    5242:	f884 203b 	strb.w	r2, [r4, #59]	; 0x3b
                useWire->beginTransmission(devAddr);
                useWire->write(regAddr);
    5246:	6823      	ldr	r3, [r4, #0]
    5248:	9907      	ldr	r1, [sp, #28]
		transmitting = 1;
    524a:	f04f 0201 	mov.w	r2, #1
    524e:	f884 205e 	strb.w	r2, [r4, #94]	; 0x5e
		txBufferLength = 1;
    5252:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
    5256:	681b      	ldr	r3, [r3, #0]
    5258:	4620      	mov	r0, r4
    525a:	4798      	blx	r3
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    525c:	2101      	movs	r1, #1
    525e:	4620      	mov	r0, r4
    5260:	f000 fa9e 	bl	57a0 <TwoWire::endTransmission(unsigned char)>
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    5264:	f89d 300c 	ldrb.w	r3, [sp, #12]
    5268:	f884 303b 	strb.w	r3, [r4, #59]	; 0x3b
		transmitting = 1;
    526c:	f04f 0301 	mov.w	r3, #1
    5270:	f884 305e 	strb.w	r3, [r4, #94]	; 0x5e
		txBufferLength = 1;
    5274:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
//#include <algorithm> // this isn't really needed, is it?  (slows down compiling)
#include <utility>
// https://forum.pjrc.com/threads/44596-Teensyduino-1-37-Beta-2-(Arduino-1-8-3-support)?p=145150&viewfull=1#post145150
template<class A, class B>
constexpr auto min(A&& a, B&& b) -> decltype(a < b ? std::forward<A>(a) : std::forward<B>(b)) {
  return a < b ? std::forward<A>(a) : std::forward<B>(b);
    5278:	9b01      	ldr	r3, [sp, #4]
	uint8_t endTransmission(void) {
		return endTransmission(1);
	}
	uint8_t requestFrom(uint8_t address, uint8_t quantity, uint8_t sendStop);
	uint8_t requestFrom(uint8_t address, uint8_t quantity) {
		return requestFrom(address, quantity, (uint8_t)1);
    527a:	9906      	ldr	r1, [sp, #24]
    527c:	2b1f      	cmp	r3, #31
    527e:	bfd4      	ite	le
    5280:	b2da      	uxtble	r2, r3
    5282:	2220      	movgt	r2, #32
    5284:	2301      	movs	r3, #1
    5286:	4620      	mov	r0, r4
    5288:	f000 fb14 	bl	58b4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>
                useWire->endTransmission();
                useWire->beginTransmission(devAddr);
                useWire->requestFrom((uint8_t)devAddr, (uint8_t)min((int)length - k, I2CDEVLIB_WIRE_BUFFER_LENGTH));
        
                for (; useWire->available() && (timeout == 0 || millis() - t1 < timeout); count++) {
    528c:	6823      	ldr	r3, [r4, #0]
    528e:	691b      	ldr	r3, [r3, #16]
    5290:	42bb      	cmp	r3, r7
    5292:	d126      	bne.n	52e2 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xee>
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    5294:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
    5298:	f894 0038 	ldrb.w	r0, [r4, #56]	; 0x38
    529c:	1a18      	subs	r0, r3, r0
    529e:	b320      	cbz	r0, 52ea <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xf6>
    52a0:	b13e      	cbz	r6, 52b2 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xbe>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    52a2:	f8da 3000 	ldr.w	r3, [sl]
    52a6:	930a      	str	r3, [sp, #40]	; 0x28
	return ret;
    52a8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    52aa:	ebcb 0303 	rsb	r3, fp, r3
    52ae:	42b3      	cmp	r3, r6
    52b0:	d21b      	bcs.n	52ea <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xf6>
                    data[count] = useWire->read();
    52b2:	6823      	ldr	r3, [r4, #0]
    52b4:	695b      	ldr	r3, [r3, #20]
    52b6:	4543      	cmp	r3, r8
    52b8:	eb09 0205 	add.w	r2, r9, r5
    52bc:	d120      	bne.n	5300 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x10c>
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    52be:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
    52c2:	f894 1039 	ldrb.w	r1, [r4, #57]	; 0x39
    52c6:	4299      	cmp	r1, r3
    52c8:	d920      	bls.n	530c <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x118>
		return rxBuffer[rxBufferIndex++];
    52ca:	1c59      	adds	r1, r3, #1
    52cc:	4423      	add	r3, r4
    52ce:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
    52d2:	7e18      	ldrb	r0, [r3, #24]
    52d4:	7010      	strb	r0, [r2, #0]
                useWire->write(regAddr);
                useWire->endTransmission();
                useWire->beginTransmission(devAddr);
                useWire->requestFrom((uint8_t)devAddr, (uint8_t)min((int)length - k, I2CDEVLIB_WIRE_BUFFER_LENGTH));
        
                for (; useWire->available() && (timeout == 0 || millis() - t1 < timeout); count++) {
    52d6:	6823      	ldr	r3, [r4, #0]
    52d8:	691b      	ldr	r3, [r3, #16]
    52da:	3501      	adds	r5, #1
    52dc:	42bb      	cmp	r3, r7
    52de:	b26d      	sxtb	r5, r5
    52e0:	d0d8      	beq.n	5294 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xa0>
    52e2:	4620      	mov	r0, r4
    52e4:	4798      	blx	r3
    52e6:	2800      	cmp	r0, #0
    52e8:	d1da      	bne.n	52a0 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xac>
    52ea:	9a01      	ldr	r2, [sp, #4]
    52ec:	9b05      	ldr	r3, [sp, #20]
            // Adds official support for repeated start condition, yay!

            // I2C/TWI subsystem uses internal buffer that breaks with large data requests
            // so if user requests more than I2CDEVLIB_WIRE_BUFFER_LENGTH bytes, we have to do it in
            // smaller chunks instead of all at once
            for (int k = 0; k < length; k += min((int)length, I2CDEVLIB_WIRE_BUFFER_LENGTH)) {
    52ee:	9904      	ldr	r1, [sp, #16]
    52f0:	1ad2      	subs	r2, r2, r3
    52f2:	9201      	str	r2, [sp, #4]
    52f4:	9a02      	ldr	r2, [sp, #8]
    52f6:	428a      	cmp	r2, r1
    52f8:	4413      	add	r3, r2
    52fa:	da0a      	bge.n	5312 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x11e>
    52fc:	9302      	str	r3, [sp, #8]
    52fe:	e79e      	b.n	523e <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x4a>
    5300:	9200      	str	r2, [sp, #0]
                useWire->endTransmission();
                useWire->beginTransmission(devAddr);
                useWire->requestFrom((uint8_t)devAddr, (uint8_t)min((int)length - k, I2CDEVLIB_WIRE_BUFFER_LENGTH));
        
                for (; useWire->available() && (timeout == 0 || millis() - t1 < timeout); count++) {
                    data[count] = useWire->read();
    5302:	4620      	mov	r0, r4
    5304:	4798      	blx	r3
    5306:	9a00      	ldr	r2, [sp, #0]
    5308:	b2c0      	uxtb	r0, r0
    530a:	e7e3      	b.n	52d4 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xe0>
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    530c:	20ff      	movs	r0, #255	; 0xff
    530e:	e7e1      	b.n	52d4 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xe0>
        Serial.print(" bytes from 0x");
        Serial.print(regAddr, HEX);
        Serial.print("...");
    #endif

    int8_t count = 0;
    5310:	9d04      	ldr	r5, [sp, #16]
        }

    #endif

    // check for timeout
    if (timeout > 0 && millis() - t1 >= timeout && count < length) count = -1; // timeout
    5312:	b166      	cbz	r6, 532e <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x13a>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5314:	f8da 3000 	ldr.w	r3, [sl]
    5318:	930b      	str	r3, [sp, #44]	; 0x2c
	return ret;
    531a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    531c:	ebcb 0b03 	rsb	fp, fp, r3
    5320:	45b3      	cmp	fp, r6
    5322:	d304      	bcc.n	532e <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x13a>
    5324:	9b04      	ldr	r3, [sp, #16]
    5326:	429d      	cmp	r5, r3
    5328:	bfb8      	it	lt
    532a:	f04f 35ff 	movlt.w	r5, #4294967295	; 0xffffffff
        Serial.print(count, DEC);
        Serial.println(" read).");
    #endif

    return count;
}
    532e:	4628      	mov	r0, r5
    5330:	b00d      	add	sp, #52	; 0x34
    5332:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5336:	bf00      	nop
    5338:	1fff0894 	.word	0x1fff0894
    533c:	000051c9 	.word	0x000051c9
    5340:	1fff2b4c 	.word	0x1fff2b4c
    5344:	000051d5 	.word	0x000051d5

00005348 <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*, void*)>:
 * @param regAddr First register address to write to
 * @param length Number of bytes to write
 * @param data Buffer to copy new data from
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t* data, void *wireObj) {
    5348:	b570      	push	{r4, r5, r6, lr}
    534a:	9d04      	ldr	r5, [sp, #16]
        Serial.print("...");
    #endif
    uint8_t status = 0;

#if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE
    TwoWire *useWire = &Wire;
    534c:	4c13      	ldr	r4, [pc, #76]	; (539c <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*, void*)+0x54>)
    534e:	2d00      	cmp	r5, #0
    5350:	bf08      	it	eq
    5352:	4625      	moveq	r5, r4
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    5354:	0040      	lsls	r0, r0, #1
        useWire->send((uint8_t) regAddr); // send address
    #elif ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100) \
            || (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE && ARDUINO >= 100) \
            || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
        useWire->beginTransmission(devAddr);
        useWire->write((uint8_t) regAddr); // send address
    5356:	682c      	ldr	r4, [r5, #0]
    5358:	f885 003b 	strb.w	r0, [r5, #59]	; 0x3b
		transmitting = 1;
    535c:	2001      	movs	r0, #1
    535e:	f885 005e 	strb.w	r0, [r5, #94]	; 0x5e
		txBufferLength = 1;
    5362:	f885 005d 	strb.w	r0, [r5, #93]	; 0x5d
 * @param regAddr First register address to write to
 * @param length Number of bytes to write
 * @param data Buffer to copy new data from
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t* data, void *wireObj) {
    5366:	4616      	mov	r6, r2
        useWire->send((uint8_t) regAddr); // send address
    #elif ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100) \
            || (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE && ARDUINO >= 100) \
            || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
        useWire->beginTransmission(devAddr);
        useWire->write((uint8_t) regAddr); // send address
    5368:	4628      	mov	r0, r5
    536a:	6822      	ldr	r2, [r4, #0]
 * @param regAddr First register address to write to
 * @param length Number of bytes to write
 * @param data Buffer to copy new data from
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t* data, void *wireObj) {
    536c:	461c      	mov	r4, r3
        useWire->send((uint8_t) regAddr); // send address
    #elif ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100) \
            || (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE && ARDUINO >= 100) \
            || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
        useWire->beginTransmission(devAddr);
        useWire->write((uint8_t) regAddr); // send address
    536e:	4790      	blx	r2
    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE)
        Fastwire::beginTransmission(devAddr);
        Fastwire::write(regAddr);
    #endif
    for (uint8_t i = 0; i < length; i++) {
    5370:	b15e      	cbz	r6, 538a <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*, void*)+0x42>
    5372:	3e01      	subs	r6, #1
    5374:	fa54 f686 	uxtab	r6, r4, r6
    5378:	3c01      	subs	r4, #1
        #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)
            useWire->send((uint8_t) data[i]);
        #elif ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100) \
                || (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE && ARDUINO >= 100) \
                || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
            useWire->write((uint8_t) data[i]);
    537a:	682b      	ldr	r3, [r5, #0]
    537c:	f814 1f01 	ldrb.w	r1, [r4, #1]!
    5380:	681b      	ldr	r3, [r3, #0]
    5382:	4628      	mov	r0, r5
    5384:	4798      	blx	r3
        useWire->write((uint8_t) regAddr); // send address
    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE)
        Fastwire::beginTransmission(devAddr);
        Fastwire::write(regAddr);
    #endif
    for (uint8_t i = 0; i < length; i++) {
    5386:	42b4      	cmp	r4, r6
    5388:	d1f7      	bne.n	537a <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*, void*)+0x32>
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    538a:	4628      	mov	r0, r5
    538c:	2101      	movs	r1, #1
    538e:	f000 fa07 	bl	57a0 <TwoWire::endTransmission(unsigned char)>
        //status = Fastwire::endTransmission();
    #endif
    #ifdef I2CDEV_SERIAL_DEBUG
        Serial.println(". Done.");
    #endif
    return status == 0;
    5392:	fab0 f080 	clz	r0, r0
    5396:	0940      	lsrs	r0, r0, #5
}
    5398:	bd70      	pop	{r4, r5, r6, pc}
    539a:	bf00      	nop
    539c:	1fff0894 	.word	0x1fff0894

000053a0 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char, void*)>:
 * @param regAddr Register regAddr to write to
 * @param bitNum Bit position to write (0-7)
 * @param value New bit value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    53a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint8_t b;
    readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj);
    53a4:	4c14      	ldr	r4, [pc, #80]	; (53f8 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char, void*)+0x58>)
 * @param regAddr Register regAddr to write to
 * @param bitNum Bit position to write (0-7)
 * @param value New bit value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    53a6:	b084      	sub	sp, #16
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    53a8:	8824      	ldrh	r4, [r4, #0]
 * @param regAddr Register regAddr to write to
 * @param bitNum Bit position to write (0-7)
 * @param value New bit value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    53aa:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    53ac:	9400      	str	r4, [sp, #0]
 * @param regAddr Register regAddr to write to
 * @param bitNum Bit position to write (0-7)
 * @param value New bit value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    53ae:	4698      	mov	r8, r3
    53b0:	4614      	mov	r4, r2
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    53b2:	f10d 030e 	add.w	r3, sp, #14
    53b6:	2201      	movs	r2, #1
    53b8:	9501      	str	r5, [sp, #4]
 * @param regAddr Register regAddr to write to
 * @param bitNum Bit position to write (0-7)
 * @param value New bit value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    53ba:	4606      	mov	r6, r0
    53bc:	460f      	mov	r7, r1
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    53be:	f7ff ff19 	bl	51f4 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)>
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    uint8_t b;
    readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj);
    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
    53c2:	2201      	movs	r2, #1
    53c4:	f89d 300e 	ldrb.w	r3, [sp, #14]
    53c8:	fa02 f404 	lsl.w	r4, r2, r4
    53cc:	f1b8 0f00 	cmp.w	r8, #0
    53d0:	d10f      	bne.n	53f2 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char, void*)+0x52>
    53d2:	ea23 0404 	bic.w	r4, r3, r4
    53d6:	ab04      	add	r3, sp, #16
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data, void *wireObj) {
    return writeBytes(devAddr, regAddr, 1, &data, wireObj);
    53d8:	9500      	str	r5, [sp, #0]
    53da:	4639      	mov	r1, r7
    53dc:	f803 4d01 	strb.w	r4, [r3, #-1]!
    53e0:	4630      	mov	r0, r6
    53e2:	2201      	movs	r2, #1
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    uint8_t b;
    readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj);
    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
    53e4:	f88d 400e 	strb.w	r4, [sp, #14]
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data, void *wireObj) {
    return writeBytes(devAddr, regAddr, 1, &data, wireObj);
    53e8:	f7ff ffae 	bl	5348 <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*, void*)>
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    uint8_t b;
    readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj);
    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
    return writeByte(devAddr, regAddr, b, wireObj);
}
    53ec:	b004      	add	sp, #16
    53ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    uint8_t b;
    readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj);
    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
    53f2:	431c      	orrs	r4, r3
    53f4:	b2e4      	uxtb	r4, r4
    53f6:	e7ee      	b.n	53d6 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char, void*)+0x36>
    53f8:	1fff0824 	.word	0x1fff0824

000053fc <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, void*)>:
 * @param bitStart First bit position to write (0-7)
 * @param length Number of bits to write (not more than 8)
 * @param data Right-aligned value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data, void *wireObj) {
    53fc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    // 00011100 mask byte
    // 10101111 original value (sample)
    // 10100011 original & ~mask
    // 10101011 masked | value
    uint8_t b;
    if (readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj) != 0) {
    5400:	4c19      	ldr	r4, [pc, #100]	; (5468 <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, void*)+0x6c>)
 * @param bitStart First bit position to write (0-7)
 * @param length Number of bits to write (not more than 8)
 * @param data Right-aligned value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data, void *wireObj) {
    5402:	b085      	sub	sp, #20
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    5404:	8824      	ldrh	r4, [r4, #0]
 * @param bitStart First bit position to write (0-7)
 * @param length Number of bits to write (not more than 8)
 * @param data Right-aligned value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data, void *wireObj) {
    5406:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    5408:	9400      	str	r4, [sp, #0]
 * @param bitStart First bit position to write (0-7)
 * @param length Number of bits to write (not more than 8)
 * @param data Right-aligned value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data, void *wireObj) {
    540a:	4691      	mov	r9, r2
    540c:	4698      	mov	r8, r3
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    540e:	9501      	str	r5, [sp, #4]
    5410:	f10d 030e 	add.w	r3, sp, #14
    5414:	2201      	movs	r2, #1
 * @param bitStart First bit position to write (0-7)
 * @param length Number of bits to write (not more than 8)
 * @param data Right-aligned value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data, void *wireObj) {
    5416:	4606      	mov	r6, r0
    5418:	460f      	mov	r7, r1
    541a:	f89d 4030 	ldrb.w	r4, [sp, #48]	; 0x30
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    541e:	f7ff fee9 	bl	51f4 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)>
    // 00011100 mask byte
    // 10101111 original value (sample)
    // 10100011 original & ~mask
    // 10101011 masked | value
    uint8_t b;
    if (readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj) != 0) {
    5422:	b1e8      	cbz	r0, 5460 <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, void*)+0x64>
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
    5424:	ebc8 0909 	rsb	r9, r8, r9
    5428:	2201      	movs	r2, #1
    542a:	4491      	add	r9, r2
    542c:	fa02 f808 	lsl.w	r8, r2, r8
        data <<= (bitStart - length + 1); // shift data into correct position
    5430:	fa04 f109 	lsl.w	r1, r4, r9
    // 10101111 original value (sample)
    // 10100011 original & ~mask
    // 10101011 masked | value
    uint8_t b;
    if (readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj) != 0) {
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
    5434:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
        data <<= (bitStart - length + 1); // shift data into correct position
        data &= mask; // zero all non-important bits in data
        b &= ~(mask); // zero all important bits in existing byte
        b |= data; // combine data with existing byte
    5438:	f89d 400e 	ldrb.w	r4, [sp, #14]
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data, void *wireObj) {
    return writeBytes(devAddr, regAddr, 1, &data, wireObj);
    543c:	9500      	str	r5, [sp, #0]
    // 10101111 original value (sample)
    // 10100011 original & ~mask
    // 10101011 masked | value
    uint8_t b;
    if (readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj) != 0) {
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
    543e:	fa03 f809 	lsl.w	r8, r3, r9
        data <<= (bitStart - length + 1); // shift data into correct position
    5442:	b2c9      	uxtb	r1, r1
        data &= mask; // zero all non-important bits in data
        b &= ~(mask); // zero all important bits in existing byte
        b |= data; // combine data with existing byte
    5444:	ea01 0108 	and.w	r1, r1, r8
    5448:	ea24 0408 	bic.w	r4, r4, r8
    544c:	ab04      	add	r3, sp, #16
    544e:	430c      	orrs	r4, r1
    5450:	f803 4d01 	strb.w	r4, [r3, #-1]!
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data, void *wireObj) {
    return writeBytes(devAddr, regAddr, 1, &data, wireObj);
    5454:	4639      	mov	r1, r7
    5456:	4630      	mov	r0, r6
    if (readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj) != 0) {
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
        data <<= (bitStart - length + 1); // shift data into correct position
        data &= mask; // zero all non-important bits in data
        b &= ~(mask); // zero all important bits in existing byte
        b |= data; // combine data with existing byte
    5458:	f88d 400e 	strb.w	r4, [sp, #14]
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data, void *wireObj) {
    return writeBytes(devAddr, regAddr, 1, &data, wireObj);
    545c:	f7ff ff74 	bl	5348 <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*, void*)>
        b |= data; // combine data with existing byte
        return writeByte(devAddr, regAddr, b, wireObj);
    } else {
        return false;
    }
}
    5460:	b005      	add	sp, #20
    5462:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    5466:	bf00      	nop
    5468:	1fff0824 	.word	0x1fff0824

0000546c <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
    546c:	2000      	movs	r0, #0
    546e:	4770      	bx	lr

00005470 <TwoWire::peek()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    5470:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
    5474:	f890 2039 	ldrb.w	r2, [r0, #57]	; 0x39
    5478:	429a      	cmp	r2, r3
		return rxBuffer[rxBufferIndex];
    547a:	bf86      	itte	hi
    547c:	181b      	addhi	r3, r3, r0
    547e:	7e18      	ldrbhi	r0, [r3, #24]
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    5480:	f04f 30ff 	movls.w	r0, #4294967295	; 0xffffffff
		return rxBuffer[rxBufferIndex];
	}
    5484:	4770      	bx	lr
    5486:	bf00      	nop

00005488 <TwoWire::flush()>:
	virtual void flush(void) {
    5488:	4770      	bx	lr
    548a:	bf00      	nop

0000548c <TwoWire::write(unsigned char const*, unsigned int)>:
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    548c:	b538      	push	{r3, r4, r5, lr}
    548e:	4605      	mov	r5, r0
	if (transmitting || slave_mode) {
    5490:	f8b0 005e 	ldrh.w	r0, [r0, #94]	; 0x5e
    5494:	b190      	cbz	r0, 54bc <TwoWire::write(unsigned char const*, unsigned int)+0x30>
		size_t avail = BUFFER_LENGTH+1 - txBufferLength;
    5496:	f895 305d 	ldrb.w	r3, [r5, #93]	; 0x5d
    549a:	4614      	mov	r4, r2
    549c:	f1c3 0221 	rsb	r2, r3, #33	; 0x21
		if (quantity > avail) {
    54a0:	4294      	cmp	r4, r2
    54a2:	d80c      	bhi.n	54be <TwoWire::write(unsigned char const*, unsigned int)+0x32>
			quantity = avail;
			setWriteError();
		}
		memcpy(txBuffer + txBufferLength, data, quantity);
    54a4:	f105 003b 	add.w	r0, r5, #59	; 0x3b
    54a8:	4418      	add	r0, r3
    54aa:	4622      	mov	r2, r4
    54ac:	f000 fb64 	bl	5b78 <memcpy>
		txBufferLength += quantity;
    54b0:	f895 305d 	ldrb.w	r3, [r5, #93]	; 0x5d
    54b4:	4423      	add	r3, r4
    54b6:	f885 305d 	strb.w	r3, [r5, #93]	; 0x5d
    54ba:	4620      	mov	r0, r4
		return quantity;
	}
	return 0;
}
    54bc:	bd38      	pop	{r3, r4, r5, pc}
	// format warnings are too pedantic - disable until newer toolchain offers better...
	// https://forum.pjrc.com/threads/62473?p=256873&viewfull=1#post256873
	int printf(const char *format, ...) /*__attribute__ ((format (printf, 2, 3)))*/;
	int printf(const __FlashStringHelper *format, ...);
  protected:
	void setWriteError(int err = 1) { write_error = err; }
    54be:	2001      	movs	r0, #1
    54c0:	4614      	mov	r4, r2
    54c2:	7128      	strb	r0, [r5, #4]
    54c4:	e7ee      	b.n	54a4 <TwoWire::write(unsigned char const*, unsigned int)+0x18>
    54c6:	bf00      	nop

000054c8 <TwoWire::write(unsigned char)>:
//  I2C0_C2      // I2C Control Register 2
//  I2C0_FLT     // I2C Programmable Input Glitch Filter register

size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
    54c8:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
    54cc:	b16b      	cbz	r3, 54ea <TwoWire::write(unsigned char)+0x22>
		if (txBufferLength >= BUFFER_LENGTH+1) {
    54ce:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
    54d2:	2b20      	cmp	r3, #32
    54d4:	d807      	bhi.n	54e6 <TwoWire::write(unsigned char)+0x1e>
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    54d6:	18c2      	adds	r2, r0, r3
    54d8:	3301      	adds	r3, #1
    54da:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d
		return 1;
    54de:	2001      	movs	r0, #1
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    54e0:	f882 103b 	strb.w	r1, [r2, #59]	; 0x3b
    54e4:	4770      	bx	lr
    54e6:	2301      	movs	r3, #1
    54e8:	7103      	strb	r3, [r0, #4]
size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
    54ea:	2000      	movs	r0, #0
    54ec:	4770      	bx	lr
    54ee:	bf00      	nop

000054f0 <TwoWire::begin()>:
void TwoWire::begin(void)
{
	//serial_begin(BAUD2DIV(115200));
	//serial_print("\nWire Begin\n");

	rxBufferIndex = 0;
    54f0:	2300      	movs	r3, #0
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    54f2:	6942      	ldr	r2, [r0, #20]
void TwoWire::begin(void)
{
	//serial_begin(BAUD2DIV(115200));
	//serial_print("\nWire Begin\n");

	rxBufferIndex = 0;
    54f4:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
	rxBufferLength = 0;
    54f8:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
	txBufferIndex = 0;
    54fc:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c
	txBufferLength = 0;
    5500:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d
	transmitting = 0;
    5504:	f880 305e 	strb.w	r3, [r0, #94]	; 0x5e
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
    5508:	f880 305f 	strb.w	r3, [r0, #95]	; 0x5f
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    550c:	ca06      	ldmia	r2, {r1, r2}

void sda_rising_isr0(void);
void sda_rising_isr1(void);

void TwoWire::begin(void)
{
    550e:	b430      	push	{r4, r5}
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    5510:	680d      	ldr	r5, [r1, #0]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    5512:	6904      	ldr	r4, [r0, #16]
	rxBufferIndex = 0;
	rxBufferLength = 0;
	txBufferIndex = 0;
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
    5514:	6643      	str	r3, [r0, #100]	; 0x64
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    5516:	432a      	orrs	r2, r5
	rxBufferLength = 0;
	txBufferIndex = 0;
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
    5518:	6683      	str	r3, [r0, #104]	; 0x68
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    551a:	600a      	str	r2, [r1, #0]
	port().C1 = 0;
    551c:	70a3      	strb	r3, [r4, #2]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    551e:	6942      	ldr	r2, [r0, #20]
    5520:	f890 3061 	ldrb.w	r3, [r0, #97]	; 0x61
    5524:	4916      	ldr	r1, [pc, #88]	; (5580 <TwoWire::begin()+0x90>)
	//pinMode(4, OUTPUT);
}

void TwoWire::setClock(uint32_t frequency)
{
	if (!(hardware.clock_gate_register & hardware.clock_gate_mask)) return;
    5526:	6814      	ldr	r4, [r2, #0]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    5528:	4413      	add	r3, r2
    552a:	7a1d      	ldrb	r5, [r3, #8]
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    552c:	7b5b      	ldrb	r3, [r3, #13]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    552e:	eb01 05c5 	add.w	r5, r1, r5, lsl #3
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    5532:	021b      	lsls	r3, r3, #8
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    5534:	686d      	ldr	r5, [r5, #4]
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    5536:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    553a:	f043 0364 	orr.w	r3, r3, #100	; 0x64
    553e:	602b      	str	r3, [r5, #0]
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    5540:	f890 3062 	ldrb.w	r3, [r0, #98]	; 0x62
    5544:	4413      	add	r3, r2
    5546:	7c9d      	ldrb	r5, [r3, #18]
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    5548:	7ddb      	ldrb	r3, [r3, #23]
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    554a:	eb01 01c5 	add.w	r1, r1, r5, lsl #3
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    554e:	021b      	lsls	r3, r3, #8
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    5550:	6849      	ldr	r1, [r1, #4]
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    5552:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    5556:	f043 0364 	orr.w	r3, r3, #100	; 0x64
    555a:	600b      	str	r3, [r1, #0]
	//pinMode(4, OUTPUT);
}

void TwoWire::setClock(uint32_t frequency)
{
	if (!(hardware.clock_gate_register & hardware.clock_gate_mask)) return;
    555c:	6821      	ldr	r1, [r4, #0]
    555e:	6853      	ldr	r3, [r2, #4]
    5560:	4219      	tst	r1, r3
    5562:	d005      	beq.n	5570 <TwoWire::begin()+0x80>
    5564:	6903      	ldr	r3, [r0, #16]
		port().F = I2C_F_DIV64; // 1.0 MHz
	}
	port().FLT = 4;
#elif F_BUS == 60000000
	if (frequency < 400000) {
		port().F = 0x2C;	// 104 kHz
    5566:	222c      	movs	r2, #44	; 0x2c
    5568:	705a      	strb	r2, [r3, #1]
    556a:	6903      	ldr	r3, [r0, #16]
	} else if (frequency < 1000000) {
		port().F = 0x1C; // 416 kHz
	} else {
		port().F = 0x12; // 938 kHz
	}
	port().FLT = 4;
    556c:	2204      	movs	r2, #4
    556e:	719a      	strb	r2, [r3, #6]
    5570:	6903      	ldr	r3, [r0, #16]
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	setClock(100000);
	port().C2 = I2C_C2_HDRS;
    5572:	2220      	movs	r2, #32
    5574:	715a      	strb	r2, [r3, #5]
    5576:	6903      	ldr	r3, [r0, #16]
	port().C1 = I2C_C1_IICEN;
    5578:	2280      	movs	r2, #128	; 0x80
    557a:	709a      	strb	r2, [r3, #2]
	//pinMode(3, OUTPUT);
	//pinMode(4, OUTPUT);
}
    557c:	bc30      	pop	{r4, r5}
    557e:	4770      	bx	lr
    5580:	0000acb8 	.word	0x0000acb8

00005584 <TwoWire::isr()>:
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    5584:	b538      	push	{r3, r4, r5, lr}
    5586:	6902      	ldr	r2, [r0, #16]
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
    5588:	78d4      	ldrb	r4, [r2, #3]
    558a:	b2e4      	uxtb	r4, r4
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    558c:	06e1      	lsls	r1, r4, #27
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    558e:	4605      	mov	r5, r0
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    5590:	d524      	bpl.n	55dc <TwoWire::isr()+0x58>
		// Arbitration Lost
		port().S = I2C_S_ARBL;
    5592:	2310      	movs	r3, #16
    5594:	70d3      	strb	r3, [r2, #3]
		if (receiving && rxBufferLength > 0) {
			// TODO: does this detect the STOP condition in slave receive mode?


		}
		if (!(status & I2C_S_IAAS)) return;
    5596:	0663      	lsls	r3, r4, #25
    5598:	d51f      	bpl.n	55da <TwoWire::isr()+0x56>
	}
	if (status & I2C_S_IAAS) {
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
    559a:	f004 0404 	and.w	r4, r4, #4
    559e:	f004 03ff 	and.w	r3, r4, #255	; 0xff
    55a2:	2c00      	cmp	r4, #0
    55a4:	d05a      	beq.n	565c <TwoWire::isr()+0xd8>
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
    55a6:	4942      	ldr	r1, [pc, #264]	; (56b0 <TwoWire::isr()+0x12c>)
			txBufferLength = 0;
			if (user_onRequest != NULL) {
    55a8:	6e6a      	ldr	r2, [r5, #100]	; 0x64
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
    55aa:	2300      	movs	r3, #0
    55ac:	700b      	strb	r3, [r1, #0]
			txBufferLength = 0;
    55ae:	f885 305d 	strb.w	r3, [r5, #93]	; 0x5d
			if (user_onRequest != NULL) {
    55b2:	2a00      	cmp	r2, #0
    55b4:	d066      	beq.n	5684 <TwoWire::isr()+0x100>
				user_onRequest();
    55b6:	4790      	blx	r2
			}
			if (txBufferLength == 0) {
    55b8:	f895 305d 	ldrb.w	r3, [r5, #93]	; 0x5d
    55bc:	2b00      	cmp	r3, #0
    55be:	d061      	beq.n	5684 <TwoWire::isr()+0x100>
    55c0:	692b      	ldr	r3, [r5, #16]
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
				txBuffer[0] = 0;
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    55c2:	22d0      	movs	r2, #208	; 0xd0
    55c4:	709a      	strb	r2, [r3, #2]
    55c6:	692b      	ldr	r3, [r5, #16]
			port().D = txBuffer[0];
    55c8:	f895 203b 	ldrb.w	r2, [r5, #59]	; 0x3b
    55cc:	711a      	strb	r2, [r3, #4]
    55ce:	692b      	ldr	r3, [r5, #16]
			txBufferIndex = 1;
    55d0:	2201      	movs	r2, #1
    55d2:	f885 205c 	strb.w	r2, [r5, #92]	; 0x5c
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    55d6:	2202      	movs	r2, #2
    55d8:	70da      	strb	r2, [r3, #3]
    55da:	bd38      	pop	{r3, r4, r5, pc}


		}
		if (!(status & I2C_S_IAAS)) return;
	}
	if (status & I2C_S_IAAS) {
    55dc:	f004 0340 	and.w	r3, r4, #64	; 0x40
    55e0:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    55e4:	2b00      	cmp	r3, #0
    55e6:	d1d8      	bne.n	559a <TwoWire::isr()+0x16>
		}
		port().S = I2C_S_IICIF;
		return;
	}
	#if defined(WIRE_HAS_STOP_INTERRUPT)
	c1 = port().FLT;
    55e8:	7993      	ldrb	r3, [r2, #6]
    55ea:	b2db      	uxtb	r3, r3
	if ((c1 & I2C_FLT_STOPF) && (c1 & I2C_FLT_STOPIE)) {
    55ec:	f003 0160 	and.w	r1, r3, #96	; 0x60
    55f0:	2960      	cmp	r1, #96	; 0x60
    55f2:	d04e      	beq.n	5692 <TwoWire::isr()+0x10e>
			rxBufferIndex = 0;
			user_onReceive(rxBufferLength);
		}
	}
	#endif
	c1 = port().C1;
    55f4:	7893      	ldrb	r3, [r2, #2]
	if (c1 & I2C_C1_TX) {
    55f6:	f003 0310 	and.w	r3, r3, #16
    55fa:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    55fe:	b1b3      	cbz	r3, 562e <TwoWire::isr()+0xaa>
		// Continue Slave Transmit
		//serial_print("t");
		if ((status & I2C_S_RXAK) == 0) {
    5600:	f014 0401 	ands.w	r4, r4, #1
    5604:	d137      	bne.n	5676 <TwoWire::isr()+0xf2>
			//serial_print(".");
			// Master ACK'd previous byte
			if (txBufferIndex < txBufferLength) {
    5606:	f895 305c 	ldrb.w	r3, [r5, #92]	; 0x5c
    560a:	f895 105d 	ldrb.w	r1, [r5, #93]	; 0x5d
    560e:	4299      	cmp	r1, r3
    5610:	d94b      	bls.n	56aa <TwoWire::isr()+0x126>
				port().D = txBuffer[txBufferIndex++];
    5612:	1c59      	adds	r1, r3, #1
    5614:	442b      	add	r3, r5
    5616:	f885 105c 	strb.w	r1, [r5, #92]	; 0x5c
    561a:	f893 303b 	ldrb.w	r3, [r3, #59]	; 0x3b
    561e:	7113      	strb	r3, [r2, #4]
    5620:	692b      	ldr	r3, [r5, #16]
			} else {
				port().D = 0;
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    5622:	22d0      	movs	r2, #208	; 0xd0
    5624:	709a      	strb	r2, [r3, #2]
    5626:	692b      	ldr	r3, [r5, #16]
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    5628:	2202      	movs	r2, #2
    562a:	70da      	strb	r2, [r3, #3]
    562c:	e7d5      	b.n	55da <TwoWire::isr()+0x56>
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
			data = port().D;
		}
	} else {
		// Continue Slave Receive
		irqcount = 0;
    562e:	f885 1060 	strb.w	r1, [r5, #96]	; 0x60
		#ifdef WIRE_HAS_STOP_INTERRUPT
		port().FLT |= I2C_FLT_STOPIE;
    5632:	7993      	ldrb	r3, [r2, #6]
    5634:	f043 0320 	orr.w	r3, r3, #32
    5638:	7193      	strb	r3, [r2, #6]
    563a:	692b      	ldr	r3, [r5, #16]
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    563c:	f895 1039 	ldrb.w	r1, [r5, #57]	; 0x39
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    5640:	791a      	ldrb	r2, [r3, #4]
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    5642:	291f      	cmp	r1, #31
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    5644:	b2d2      	uxtb	r2, r2
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    5646:	d8c6      	bhi.n	55d6 <TwoWire::isr()+0x52>
    5648:	4819      	ldr	r0, [pc, #100]	; (56b0 <TwoWire::isr()+0x12c>)
    564a:	7800      	ldrb	r0, [r0, #0]
    564c:	2800      	cmp	r0, #0
    564e:	d0c2      	beq.n	55d6 <TwoWire::isr()+0x52>
			rxBuffer[rxBufferLength++] = data;
    5650:	1868      	adds	r0, r5, r1
    5652:	3101      	adds	r1, #1
    5654:	f885 1039 	strb.w	r1, [r5, #57]	; 0x39
    5658:	7602      	strb	r2, [r0, #24]
    565a:	e7bc      	b.n	55d6 <TwoWire::isr()+0x52>
    565c:	692a      	ldr	r2, [r5, #16]
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
			rxBufferLength = 0;
    565e:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
    5662:	23c0      	movs	r3, #192	; 0xc0
    5664:	7093      	strb	r3, [r2, #2]
    5666:	692b      	ldr	r3, [r5, #16]
			port().D = txBuffer[0];
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
    5668:	4a11      	ldr	r2, [pc, #68]	; (56b0 <TwoWire::isr()+0x12c>)
			rxBufferLength = 0;
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
			data = port().D;
    566a:	7919      	ldrb	r1, [r3, #4]
			port().D = txBuffer[0];
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
    566c:	2101      	movs	r1, #1
    566e:	7011      	strb	r1, [r2, #0]
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    5670:	2202      	movs	r2, #2
    5672:	70da      	strb	r2, [r3, #3]
    5674:	e7b1      	b.n	55da <TwoWire::isr()+0x56>
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
		} else {
			//serial_print("*");
			// Master did not ACK previous byte
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
    5676:	23c0      	movs	r3, #192	; 0xc0
    5678:	7093      	strb	r3, [r2, #2]
    567a:	692b      	ldr	r3, [r5, #16]
			data = port().D;
    567c:	791a      	ldrb	r2, [r3, #4]
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    567e:	2202      	movs	r2, #2
    5680:	70da      	strb	r2, [r3, #3]
    5682:	e7aa      	b.n	55da <TwoWire::isr()+0x56>
			}
			if (txBufferLength == 0) {
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
    5684:	2201      	movs	r2, #1
				txBuffer[0] = 0;
    5686:	2300      	movs	r3, #0
			}
			if (txBufferLength == 0) {
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
    5688:	f885 205d 	strb.w	r2, [r5, #93]	; 0x5d
				txBuffer[0] = 0;
    568c:	f885 303b 	strb.w	r3, [r5, #59]	; 0x3b
    5690:	e796      	b.n	55c0 <TwoWire::isr()+0x3c>
		return;
	}
	#if defined(WIRE_HAS_STOP_INTERRUPT)
	c1 = port().FLT;
	if ((c1 & I2C_FLT_STOPF) && (c1 & I2C_FLT_STOPIE)) {
		port().FLT = c1 & ~I2C_FLT_STOPIE;
    5692:	f003 03df 	and.w	r3, r3, #223	; 0xdf
    5696:	7193      	strb	r3, [r2, #6]
		if (user_onReceive != NULL) {
    5698:	6eab      	ldr	r3, [r5, #104]	; 0x68
    569a:	b123      	cbz	r3, 56a6 <TwoWire::isr()+0x122>
			rxBufferIndex = 0;
    569c:	f885 0038 	strb.w	r0, [r5, #56]	; 0x38
			user_onReceive(rxBufferLength);
    56a0:	f895 0039 	ldrb.w	r0, [r5, #57]	; 0x39
    56a4:	4798      	blx	r3
    56a6:	692a      	ldr	r2, [r5, #16]
    56a8:	e7a4      	b.n	55f4 <TwoWire::isr()+0x70>
			//serial_print(".");
			// Master ACK'd previous byte
			if (txBufferIndex < txBufferLength) {
				port().D = txBuffer[txBufferIndex++];
			} else {
				port().D = 0;
    56aa:	7114      	strb	r4, [r2, #4]
    56ac:	e7b8      	b.n	5620 <TwoWire::isr()+0x9c>
    56ae:	bf00      	nop
    56b0:	1fff2b48 	.word	0x1fff2b48

000056b4 <TwoWire::wait_idle()>:
	}
	return 0;
}

bool TwoWire::wait_idle(void)
{
    56b4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    56b8:	4f37      	ldr	r7, [pc, #220]	; (5798 <L_1438_delayMicroseconds+0x18>)
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    56ba:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 579c <L_1438_delayMicroseconds+0x1c>
    56be:	683b      	ldr	r3, [r7, #0]
    56c0:	6902      	ldr	r2, [r0, #16]
	}
	return 0;
}

bool TwoWire::wait_idle(void)
{
    56c2:	b082      	sub	sp, #8
    56c4:	4606      	mov	r6, r0
    56c6:	9300      	str	r3, [sp, #0]
	return ret;
    56c8:	f8dd 8000 	ldr.w	r8, [sp]
	bool reset=false;
    56cc:	2100      	movs	r1, #0
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    56ce:	f44f 7596 	mov.w	r5, #300	; 0x12c
	uint8_t i2c_status(void) {
		return port().S;
    56d2:	78d3      	ldrb	r3, [r2, #3]
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    56d4:	069b      	lsls	r3, r3, #26
    56d6:	d55b      	bpl.n	5790 <L_1438_delayMicroseconds+0x10>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    56d8:	683b      	ldr	r3, [r7, #0]
    56da:	9301      	str	r3, [sp, #4]
	return ret;
    56dc:	9b01      	ldr	r3, [sp, #4]
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
    56de:	ebc8 0303 	rsb	r3, r8, r3
#if 1
		if (waited > 15 && !reset) {
    56e2:	2b0f      	cmp	r3, #15
    56e4:	d9f5      	bls.n	56d2 <TwoWire::wait_idle()+0x1e>
    56e6:	b149      	cbz	r1, 56fc <TwoWire::wait_idle()+0x48>
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			delayMicroseconds(10);
			continue;
		}
#endif
		if (waited > 16) {
    56e8:	2b10      	cmp	r3, #16
    56ea:	d0f2      	beq.n	56d2 <TwoWire::wait_idle()+0x1e>
			// bus stuck busy too long
			port().C1 = 0;
    56ec:	2000      	movs	r0, #0
    56ee:	7090      	strb	r0, [r2, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    56f0:	6933      	ldr	r3, [r6, #16]
			port().C1 = I2C_C1_IICEN;
    56f2:	2280      	movs	r2, #128	; 0x80
    56f4:	709a      	strb	r2, [r3, #2]
			//return 4; // timeout waiting for bus
			return false;
		}
	}
	return true;
}
    56f6:	b002      	add	sp, #8
    56f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uint32_t waited = millis() - wait_begin;
#if 1
		if (waited > 15 && !reset) {
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
    56fc:	6972      	ldr	r2, [r6, #20]
    56fe:	f896 3061 	ldrb.w	r3, [r6, #97]	; 0x61
    5702:	4413      	add	r3, r2
			pinMode(sda_pin, INPUT_DISABLE);
    5704:	2105      	movs	r1, #5
    5706:	7a18      	ldrb	r0, [r3, #8]
    5708:	f000 fe1c 	bl	6344 <pinMode>
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
    570c:	6972      	ldr	r2, [r6, #20]
    570e:	f896 3061 	ldrb.w	r3, [r6, #97]	; 0x61
    5712:	4413      	add	r3, r2
			pinMode(scl_pin, OUTPUT);
    5714:	2101      	movs	r1, #1
		if (waited > 15 && !reset) {
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
    5716:	f893 a012 	ldrb.w	sl, [r3, #18]
			pinMode(scl_pin, OUTPUT);
    571a:	4650      	mov	r0, sl
    571c:	f000 fe12 	bl	6344 <pinMode>
    5720:	2409      	movs	r4, #9
			for (int i=0; i < 9; i++) {
				digitalWrite(scl_pin, LOW);
    5722:	2100      	movs	r1, #0
    5724:	4650      	mov	r0, sl
    5726:	f000 fe07 	bl	6338 <digitalWrite>
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    572a:	462b      	mov	r3, r5

0000572c <L_1373_delayMicroseconds>:
    572c:	3b01      	subs	r3, #1
    572e:	d1fd      	bne.n	572c <L_1373_delayMicroseconds>
				delayMicroseconds(5);
				digitalWrite(scl_pin, HIGH);
    5730:	2101      	movs	r1, #1
    5732:	4650      	mov	r0, sl
    5734:	f000 fe00 	bl	6338 <digitalWrite>
    5738:	462b      	mov	r3, r5

0000573a <L_1387_delayMicroseconds>:
    573a:	3b01      	subs	r3, #1
    573c:	d1fd      	bne.n	573a <L_1387_delayMicroseconds>
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
			pinMode(scl_pin, OUTPUT);
			for (int i=0; i < 9; i++) {
    573e:	3c01      	subs	r4, #1
    5740:	d1ef      	bne.n	5722 <TwoWire::wait_idle()+0x6e>
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    5742:	6970      	ldr	r0, [r6, #20]
    5744:	f896 1061 	ldrb.w	r1, [r6, #97]	; 0x61
    5748:	4401      	add	r1, r0
    574a:	f44f 7216 	mov.w	r2, #600	; 0x258
    574e:	7a0c      	ldrb	r4, [r1, #8]
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    5750:	7b4b      	ldrb	r3, [r1, #13]
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    5752:	eb09 01c4 	add.w	r1, r9, r4, lsl #3
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    5756:	021b      	lsls	r3, r3, #8
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    5758:	6849      	ldr	r1, [r1, #4]
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    575a:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    575e:	f043 0364 	orr.w	r3, r3, #100	; 0x64
    5762:	600b      	str	r3, [r1, #0]
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    5764:	f896 3062 	ldrb.w	r3, [r6, #98]	; 0x62
    5768:	4403      	add	r3, r0
    576a:	7c99      	ldrb	r1, [r3, #18]
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    576c:	7ddb      	ldrb	r3, [r3, #23]
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    576e:	eb09 01c1 	add.w	r1, r9, r1, lsl #3
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    5772:	021b      	lsls	r3, r3, #8
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    5774:	6849      	ldr	r1, [r1, #4]
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    5776:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    577a:	f043 0364 	orr.w	r3, r3, #100	; 0x64
    577e:	600b      	str	r3, [r1, #0]

00005780 <L_1438_delayMicroseconds>:
    5780:	3a01      	subs	r2, #1
    5782:	d1fd      	bne.n	5780 <L_1438_delayMicroseconds>
    5784:	6932      	ldr	r2, [r6, #16]
	uint8_t i2c_status(void) {
		return port().S;
    5786:	78d3      	ldrb	r3, [r2, #3]
{
	bool reset=false;
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    5788:	069b      	lsls	r3, r3, #26
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
#if 1
		if (waited > 15 && !reset) {
			reset = true;
    578a:	f04f 0101 	mov.w	r1, #1
{
	bool reset=false;
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    578e:	d4a3      	bmi.n	56d8 <TwoWire::wait_idle()+0x24>
			//Serial.println("abort");
			//return 4; // timeout waiting for bus
			return false;
		}
	}
	return true;
    5790:	2001      	movs	r0, #1
}
    5792:	b002      	add	sp, #8
    5794:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5798:	1fff2b4c 	.word	0x1fff2b4c
    579c:	0000acb8 	.word	0x0000acb8

000057a0 <TwoWire::endTransmission(unsigned char)>:

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    57a0:	b5f0      	push	{r4, r5, r6, r7, lr}
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    57a2:	6903      	ldr	r3, [r0, #16]
	uint8_t i, status, ret=0;
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    57a4:	2212      	movs	r2, #18
    57a6:	70da      	strb	r2, [r3, #3]
    57a8:	6902      	ldr	r2, [r0, #16]
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    57aa:	7893      	ldrb	r3, [r2, #2]
    57ac:	f003 0320 	and.w	r3, r3, #32
	}
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    57b0:	b085      	sub	sp, #20
    57b2:	4604      	mov	r4, r0
    57b4:	460d      	mov	r5, r1
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    57b6:	2b00      	cmp	r3, #0
    57b8:	d05e      	beq.n	5878 <TwoWire::endTransmission(unsigned char)+0xd8>
		// we are already the bus master, so send a repeated start
		//Serial.print("rstart:");
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
    57ba:	23b4      	movs	r3, #180	; 0xb4
    57bc:	7093      	strb	r3, [r2, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    57be:	493c      	ldr	r1, [pc, #240]	; (58b0 <TwoWire::endTransmission(unsigned char)+0x110>)
    57c0:	6922      	ldr	r2, [r4, #16]
    57c2:	680b      	ldr	r3, [r1, #0]
    57c4:	9300      	str	r3, [sp, #0]
	return ret;
    57c6:	9e00      	ldr	r6, [sp, #0]
    57c8:	e005      	b.n	57d6 <TwoWire::endTransmission(unsigned char)+0x36>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    57ca:	680b      	ldr	r3, [r1, #0]
    57cc:	9301      	str	r3, [sp, #4]
	return ret;
    57ce:	9b01      	ldr	r3, [sp, #4]
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		//Serial.write('*') ;
		if (millis() - wait_begin > 4) {
    57d0:	1b9b      	subs	r3, r3, r6
    57d2:	2b04      	cmp	r3, #4
    57d4:	d842      	bhi.n	585c <TwoWire::endTransmission(unsigned char)+0xbc>
	uint8_t i2c_status(void) {
		return port().S;
    57d6:	78d3      	ldrb	r3, [r2, #3]
	}
	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
    57d8:	f003 0320 	and.w	r3, r3, #32
    57dc:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    57e0:	2b00      	cmp	r3, #0
    57e2:	d0f2      	beq.n	57ca <TwoWire::endTransmission(unsigned char)+0x2a>
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
    57e4:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
    57e8:	2b00      	cmp	r3, #0
    57ea:	d031      	beq.n	5850 <TwoWire::endTransmission(unsigned char)+0xb0>
    57ec:	f04f 0e00 	mov.w	lr, #0
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
			}
		}
		port().S = I2C_S_IICIF;
    57f0:	f04f 0c02 	mov.w	ip, #2
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
		port().D = txBuffer[i];
    57f4:	eb04 030e 	add.w	r3, r4, lr
    57f8:	f893 303b 	ldrb.w	r3, [r3, #59]	; 0x3b
    57fc:	7113      	strb	r3, [r2, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    57fe:	680b      	ldr	r3, [r1, #0]
    5800:	9303      	str	r3, [sp, #12]
	return ret;
    5802:	9f03      	ldr	r7, [sp, #12]
    5804:	6920      	ldr	r0, [r4, #16]
    5806:	e007      	b.n	5818 <TwoWire::endTransmission(unsigned char)+0x78>
		//Serial.write('^');
		wait_begin = millis();
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
    5808:	069b      	lsls	r3, r3, #26
    580a:	d50d      	bpl.n	5828 <TwoWire::endTransmission(unsigned char)+0x88>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    580c:	680b      	ldr	r3, [r1, #0]
    580e:	9302      	str	r3, [sp, #8]
	return ret;
    5810:	9b02      	ldr	r3, [sp, #8]
			if (millis() - wait_begin > 5) {
    5812:	1bdb      	subs	r3, r3, r7
    5814:	2b05      	cmp	r3, #5
    5816:	d828      	bhi.n	586a <TwoWire::endTransmission(unsigned char)+0xca>
    5818:	78c3      	ldrb	r3, [r0, #3]
    581a:	b2db      	uxtb	r3, r3
		port().D = txBuffer[i];
		//Serial.write('^');
		wait_begin = millis();
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
    581c:	f003 0202 	and.w	r2, r3, #2
    5820:	f002 06ff 	and.w	r6, r2, #255	; 0xff
    5824:	2a00      	cmp	r2, #0
    5826:	d0ef      	beq.n	5808 <TwoWire::endTransmission(unsigned char)+0x68>
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
			}
		}
		port().S = I2C_S_IICIF;
    5828:	f880 c003 	strb.w	ip, [r0, #3]
    582c:	6926      	ldr	r6, [r4, #16]
    582e:	78f3      	ldrb	r3, [r6, #3]
    5830:	b2db      	uxtb	r3, r3
		//Serial.write('$');
		status = i2c_status();
		if ((status & I2C_S_ARBL)) {
    5832:	06df      	lsls	r7, r3, #27
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    5834:	4632      	mov	r2, r6
    5836:	d42d      	bmi.n	5894 <TwoWire::endTransmission(unsigned char)+0xf4>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("endTransmission err4\n");
			ret = 4; // 4:other error
			break;
		}
		if (!(status & I2C_S_BUSY)) {
    5838:	069f      	lsls	r7, r3, #26
    583a:	d52b      	bpl.n	5894 <TwoWire::endTransmission(unsigned char)+0xf4>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("endTransmission err5\n");
			ret = 4; // 4:other error
			break;
		}
		if (status & I2C_S_RXAK) {
    583c:	07db      	lsls	r3, r3, #31
    583e:	d431      	bmi.n	58a4 <TwoWire::endTransmission(unsigned char)+0x104>
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
    5840:	f10e 0e01 	add.w	lr, lr, #1
    5844:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
    5848:	fa5f fe8e 	uxtb.w	lr, lr
    584c:	4573      	cmp	r3, lr
    584e:	d8d1      	bhi.n	57f4 <TwoWire::endTransmission(unsigned char)+0x54>
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
	uint8_t i, status, ret=0;
    5850:	2000      	movs	r0, #0
			}
			sendStop = 1;
			break;
		}
	}
	if (sendStop) {
    5852:	bb1d      	cbnz	r5, 589c <TwoWire::endTransmission(unsigned char)+0xfc>
		// send the stop condition
		port().C1 = I2C_C1_IICEN;
		// TODO: do we wait for this somehow?
	}
	transmitting = 0;
    5854:	2300      	movs	r3, #0
    5856:	f884 305e 	strb.w	r3, [r4, #94]	; 0x5e
    585a:	e004      	b.n	5866 <TwoWire::endTransmission(unsigned char)+0xc6>
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		//Serial.write('*') ;
		if (millis() - wait_begin > 4) {
			port().C1 = 0;
    585c:	7090      	strb	r0, [r2, #2]
    585e:	6923      	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    5860:	2280      	movs	r2, #128	; 0x80
    5862:	709a      	strb	r2, [r3, #2]
			//Serial.println("abort2");
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
    5864:	2004      	movs	r0, #4
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    5866:	b005      	add	sp, #20
    5868:	bdf0      	pop	{r4, r5, r6, r7, pc}
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
    586a:	7086      	strb	r6, [r0, #2]
    586c:	6923      	ldr	r3, [r4, #16]
				port().C1 = I2C_C1_IICEN;
    586e:	2280      	movs	r2, #128	; 0x80
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
    5870:	2004      	movs	r0, #4
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
				port().C1 = I2C_C1_IICEN;
    5872:	709a      	strb	r2, [r3, #2]
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    5874:	b005      	add	sp, #20
    5876:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5878:	f003 06ff 	and.w	r6, r3, #255	; 0xff
		// we are already the bus master, so send a repeated start
		//Serial.print("rstart:");
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
    587c:	f7ff ff1a 	bl	56b4 <TwoWire::wait_idle()>
    5880:	b910      	cbnz	r0, 5888 <TwoWire::endTransmission(unsigned char)+0xe8>
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
    5882:	2004      	movs	r0, #4
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    5884:	b005      	add	sp, #20
    5886:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5888:	6923      	ldr	r3, [r4, #16]
		if (!wait_idle()) {
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
    588a:	f884 605f 	strb.w	r6, [r4, #95]	; 0x5f
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    588e:	22b0      	movs	r2, #176	; 0xb0
    5890:	709a      	strb	r2, [r3, #2]
    5892:	e794      	b.n	57be <TwoWire::endTransmission(unsigned char)+0x1e>
			ret = 4; // 4:other error
			break;
		}
		if (!(status & I2C_S_BUSY)) {
			// suddenly lost control of the bus!
			port().C1 = I2C_C1_IICEN;
    5894:	2380      	movs	r3, #128	; 0x80
    5896:	70b3      	strb	r3, [r6, #2]
			//Serial.printf("endTransmission err5\n");
			ret = 4; // 4:other error
    5898:	2004      	movs	r0, #4
    589a:	e7da      	b.n	5852 <TwoWire::endTransmission(unsigned char)+0xb2>
    589c:	6926      	ldr	r6, [r4, #16]
			break;
		}
	}
	if (sendStop) {
		// send the stop condition
		port().C1 = I2C_C1_IICEN;
    589e:	2380      	movs	r3, #128	; 0x80
    58a0:	70b3      	strb	r3, [r6, #2]
    58a2:	e7d7      	b.n	5854 <TwoWire::endTransmission(unsigned char)+0xb4>
			if (i == 0) {
				//Serial.printf("endTransmission err6\n");
				ret = 2; // 2:received NACK on transmit of address
			} else {
				//Serial.printf("endTransmission err7\n");
				ret = 3; // 3:received NACK on transmit of data 
    58a4:	f1be 0f00 	cmp.w	lr, #0
    58a8:	bf0c      	ite	eq
    58aa:	2002      	moveq	r0, #2
    58ac:	2003      	movne	r0, #3
    58ae:	e7f6      	b.n	589e <TwoWire::endTransmission(unsigned char)+0xfe>
    58b0:	1fff2b4c 	.word	0x1fff2b4c

000058b4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>:
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    58b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    58b8:	6906      	ldr	r6, [r0, #16]
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
	uint32_t wait_begin;

	rxBufferIndex = 0;
    58ba:	2500      	movs	r5, #0
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    58bc:	2712      	movs	r7, #18
{
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
	uint32_t wait_begin;

	rxBufferIndex = 0;
    58be:	f880 5038 	strb.w	r5, [r0, #56]	; 0x38
	rxBufferLength = 0;
    58c2:	f880 5039 	strb.w	r5, [r0, #57]	; 0x39
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    58c6:	70f7      	strb	r7, [r6, #3]
    58c8:	f8d0 c010 	ldr.w	ip, [r0, #16]
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    58cc:	f89c e002 	ldrb.w	lr, [ip, #2]
    58d0:	f00e 0e20 	and.w	lr, lr, #32
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    58d4:	b088      	sub	sp, #32
    58d6:	4604      	mov	r4, r0
    58d8:	4688      	mov	r8, r1
    58da:	4615      	mov	r5, r2
    58dc:	461e      	mov	r6, r3
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    58de:	f1be 0f00 	cmp.w	lr, #0
    58e2:	d049      	beq.n	5978 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xc4>
		// we are already the bus master, so send a repeated start
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
    58e4:	23b4      	movs	r3, #180	; 0xb4
    58e6:	f88c 3002 	strb.w	r3, [ip, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    58ea:	4b7a      	ldr	r3, [pc, #488]	; (5ad4 <L_2952_delayMicroseconds+0x1e>)
    58ec:	6921      	ldr	r1, [r4, #16]
    58ee:	681a      	ldr	r2, [r3, #0]
    58f0:	9200      	str	r2, [sp, #0]
	return ret;
    58f2:	f8dd e000 	ldr.w	lr, [sp]
    58f6:	e006      	b.n	5906 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x52>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    58f8:	681a      	ldr	r2, [r3, #0]
    58fa:	9201      	str	r2, [sp, #4]
	return ret;
    58fc:	9801      	ldr	r0, [sp, #4]
	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		if (millis() - wait_begin > 4) {
    58fe:	ebce 0000 	rsb	r0, lr, r0
    5902:	2804      	cmp	r0, #4
    5904:	d830      	bhi.n	5968 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xb4>
	uint8_t i2c_status(void) {
		return port().S;
    5906:	78c8      	ldrb	r0, [r1, #3]
    5908:	f000 0020 	and.w	r0, r0, #32

	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
    590c:	f000 07ff 	and.w	r7, r0, #255	; 0xff
    5910:	2800      	cmp	r0, #0
    5912:	d0f1      	beq.n	58f8 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x44>
			//Serial.printf("requestFrom err2\n");
			return 0; // error generating start condition
		}
	}
	// send the address
	port().D = (address << 1) | 1;
    5914:	ea4f 0248 	mov.w	r2, r8, lsl #1
    5918:	f042 0201 	orr.w	r2, r2, #1
    591c:	b2d2      	uxtb	r2, r2
    591e:	710a      	strb	r2, [r1, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5920:	681a      	ldr	r2, [r3, #0]
    5922:	9202      	str	r2, [sp, #8]
	return ret;
    5924:	f8dd e008 	ldr.w	lr, [sp, #8]
    5928:	6920      	ldr	r0, [r4, #16]
    592a:	e006      	b.n	593a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x86>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    592c:	681a      	ldr	r2, [r3, #0]
    592e:	9203      	str	r2, [sp, #12]
	return ret;
    5930:	9903      	ldr	r1, [sp, #12]
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
    5932:	ebce 0101 	rsb	r1, lr, r1
    5936:	2905      	cmp	r1, #5
    5938:	d82a      	bhi.n	5990 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xdc>
		}
	}
	// send the address
	port().D = (address << 1) | 1;
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
    593a:	78c1      	ldrb	r1, [r0, #3]
    593c:	f001 0102 	and.w	r1, r1, #2
    5940:	f001 07ff 	and.w	r7, r1, #255	; 0xff
    5944:	2900      	cmp	r1, #0
    5946:	d0f1      	beq.n	592c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x78>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("requestFrom err3\n");
			return 0; // clock stretch too long (during address)
		}
	}
	port().S = I2C_S_IICIF;
    5948:	f04f 0c02 	mov.w	ip, #2
    594c:	f880 c003 	strb.w	ip, [r0, #3]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    5950:	6922      	ldr	r2, [r4, #16]
	uint8_t i2c_status(void) {
		return port().S;
    5952:	78d1      	ldrb	r1, [r2, #3]
	status = i2c_status();
	if ((status & I2C_S_RXAK) || (status & I2C_S_ARBL)) {
    5954:	f011 0711 	ands.w	r7, r1, #17
    5958:	d122      	bne.n	59a0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xec>
		// or we lost bus arbitration to another master
		port().C1 = I2C_C1_IICEN;
		//Serial.printf("requestFrom err4\n");
		return 0;
	}
	if (length == 0) {
    595a:	bb2d      	cbnz	r5, 59a8 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf4>
		// TODO: does anybody really do zero length reads?
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
    595c:	2e00      	cmp	r6, #0
    595e:	bf0c      	ite	eq
    5960:	23a0      	moveq	r3, #160	; 0xa0
    5962:	2380      	movne	r3, #128	; 0x80
    5964:	7093      	strb	r3, [r2, #2]
		//Serial.printf("requestFrom err5\n");
		return 0;
    5966:	e003      	b.n	5970 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		if (millis() - wait_begin > 4) {
			port().C1 = 0;
    5968:	708f      	strb	r7, [r1, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    596a:	6923      	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    596c:	2280      	movs	r2, #128	; 0x80
    596e:	709a      	strb	r2, [r3, #2]
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
	rxBufferLength = count;
	return count;
}
    5970:	4638      	mov	r0, r7
    5972:	b008      	add	sp, #32
    5974:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5978:	f00e 07ff 	and.w	r7, lr, #255	; 0xff
	if (port().C1 & I2C_C1_MST) {
		// we are already the bus master, so send a repeated start
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
    597c:	f7ff fe9a 	bl	56b4 <TwoWire::wait_idle()>
    5980:	2800      	cmp	r0, #0
    5982:	d0f5      	beq.n	5970 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
    5984:	6923      	ldr	r3, [r4, #16]
			//Serial.printf("requestFrom err1\n");
			return 0; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
    5986:	f884 705f 	strb.w	r7, [r4, #95]	; 0x5f
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    598a:	22b0      	movs	r2, #176	; 0xb0
    598c:	709a      	strb	r2, [r3, #2]
    598e:	e7ac      	b.n	58ea <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x36>
	// send the address
	port().D = (address << 1) | 1;
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
    5990:	7087      	strb	r7, [r0, #2]
    5992:	6923      	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    5994:	2280      	movs	r2, #128	; 0x80
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
	rxBufferLength = count;
	return count;
}
    5996:	4638      	mov	r0, r7
	port().D = (address << 1) | 1;
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
    5998:	709a      	strb	r2, [r3, #2]
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
	rxBufferLength = count;
	return count;
}
    599a:	b008      	add	sp, #32
    599c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	port().S = I2C_S_IICIF;
	status = i2c_status();
	if ((status & I2C_S_RXAK) || (status & I2C_S_ARBL)) {
		// the slave device did not acknowledge
		// or we lost bus arbitration to another master
		port().C1 = I2C_C1_IICEN;
    59a0:	2380      	movs	r3, #128	; 0x80
    59a2:	7093      	strb	r3, [r2, #2]
		//Serial.printf("requestFrom err4\n");
		return 0;
    59a4:	2700      	movs	r7, #0
    59a6:	e7e3      	b.n	5970 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
		// TODO: does anybody really do zero length reads?
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
		//Serial.printf("requestFrom err5\n");
		return 0;
	} else if (length == 1) {
    59a8:	2d01      	cmp	r5, #1
    59aa:	d078      	beq.n	5a9e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1ea>
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
    59ac:	21a0      	movs	r1, #160	; 0xa0
    59ae:	7091      	strb	r1, [r2, #2]
    59b0:	6921      	ldr	r1, [r4, #16]
	}
	tmp = port().D; // initiate the first receive
    59b2:	790a      	ldrb	r2, [r1, #4]
    59b4:	46be      	mov	lr, r7
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
    59b6:	4667      	mov	r7, ip
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    59b8:	f04f 0ca8 	mov.w	ip, #168	; 0xa8
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    59bc:	681a      	ldr	r2, [r3, #0]
    59be:	9204      	str	r2, [sp, #16]
	return ret;
    59c0:	9804      	ldr	r0, [sp, #16]
    59c2:	e005      	b.n	59d0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x11c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    59c4:	681a      	ldr	r2, [r3, #0]
    59c6:	9205      	str	r2, [sp, #20]
	return ret;
    59c8:	9a05      	ldr	r2, [sp, #20]
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
			if (millis() - wait_begin > 5) {
    59ca:	1a12      	subs	r2, r2, r0
    59cc:	2a05      	cmp	r2, #5
    59ce:	d84d      	bhi.n	5a6c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1b8>
	}
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
    59d0:	78ca      	ldrb	r2, [r1, #3]
    59d2:	f002 0202 	and.w	r2, r2, #2
    59d6:	f002 08ff 	and.w	r8, r2, #255	; 0xff
    59da:	2a00      	cmp	r2, #0
    59dc:	d0f2      	beq.n	59c4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x110>
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
    59de:	70cf      	strb	r7, [r1, #3]
    59e0:	6921      	ldr	r1, [r4, #16]
		status = port().S;
    59e2:	78ca      	ldrb	r2, [r1, #3]
    59e4:	b2d2      	uxtb	r2, r2
		if ((status & I2C_S_ARBL)) {
    59e6:	f012 0f10 	tst.w	r2, #16
    59ea:	4608      	mov	r0, r1
    59ec:	d15d      	bne.n	5aaa <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f6>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7a\n");
			return count;
		}
		if (!(status & I2C_S_BUSY)) {
    59ee:	0692      	lsls	r2, r2, #26
    59f0:	d55b      	bpl.n	5aaa <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f6>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
    59f2:	3d01      	subs	r5, #1
    59f4:	b2ed      	uxtb	r5, r5
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    59f6:	2d01      	cmp	r5, #1
    59f8:	d04c      	beq.n	5a94 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1e0>
		if (count < BUFFER_LENGTH) {
    59fa:	f1be 0f1f 	cmp.w	lr, #31
    59fe:	d93e      	bls.n	5a7e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1ca>
			rxBuffer[count++] = port().D;
		} else {
			tmp = port().D;
    5a00:	790a      	ldrb	r2, [r1, #4]
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
	}
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
    5a02:	2d01      	cmp	r5, #1
    5a04:	d1da      	bne.n	59bc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x108>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5a06:	681a      	ldr	r2, [r3, #0]
    5a08:	9206      	str	r2, [sp, #24]
	return ret;
    5a0a:	9d06      	ldr	r5, [sp, #24]
    5a0c:	e005      	b.n	5a1a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x166>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5a0e:	681a      	ldr	r2, [r3, #0]
    5a10:	9207      	str	r2, [sp, #28]
	return ret;
    5a12:	9a07      	ldr	r2, [sp, #28]
			tmp = port().D;
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
    5a14:	1b52      	subs	r2, r2, r5
    5a16:	2a05      	cmp	r2, #5
    5a18:	d856      	bhi.n	5ac8 <L_2952_delayMicroseconds+0x12>
		} else {
			tmp = port().D;
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
    5a1a:	78c2      	ldrb	r2, [r0, #3]
    5a1c:	f002 0202 	and.w	r2, r2, #2
    5a20:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    5a24:	2a00      	cmp	r2, #0
    5a26:	d0f2      	beq.n	5a0e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x15a>
			rxBufferLength = count;
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
		}
	}
	port().S = I2C_S_IICIF;
    5a28:	2302      	movs	r3, #2
    5a2a:	70c3      	strb	r3, [r0, #3]
    5a2c:	6922      	ldr	r2, [r4, #16]
	status = port().S;
    5a2e:	78d3      	ldrb	r3, [r2, #3]
    5a30:	b2db      	uxtb	r3, r3
	if ((status & I2C_S_ARBL)) {
    5a32:	06d9      	lsls	r1, r3, #27
    5a34:	d43b      	bmi.n	5aae <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1fa>
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
		//Serial.printf("requestFrom err9a\n");
		return count;
	}
	if (!(status & I2C_S_BUSY)) {
    5a36:	069b      	lsls	r3, r3, #26
    5a38:	d537      	bpl.n	5aaa <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f6>
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//Serial.printf("requestFrom err9b\n");
		return count;
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    5a3a:	23b0      	movs	r3, #176	; 0xb0
	if (count < BUFFER_LENGTH) {
    5a3c:	f1be 0f1f 	cmp.w	lr, #31
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//Serial.printf("requestFrom err9b\n");
		return count;
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    5a40:	7093      	strb	r3, [r2, #2]
	if (count < BUFFER_LENGTH) {
    5a42:	d843      	bhi.n	5acc <L_2952_delayMicroseconds+0x16>
    5a44:	6922      	ldr	r2, [r4, #16]
		rxBuffer[count++] = port().D;
    5a46:	eb04 030e 	add.w	r3, r4, lr
    5a4a:	7912      	ldrb	r2, [r2, #4]
    5a4c:	761a      	strb	r2, [r3, #24]
    5a4e:	f10e 0e01 	add.w	lr, lr, #1
    5a52:	fa5f fe8e 	uxtb.w	lr, lr
	} else {
		tmp = port().D;
	}
#if F_CPU > 120000000
	__asm__("nop");
    5a56:	bf00      	nop
	__asm__("nop");
    5a58:	bf00      	nop
	__asm__("nop");
    5a5a:	bf00      	nop
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
    5a5c:	b116      	cbz	r6, 5a64 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1b0>
    5a5e:	6923      	ldr	r3, [r4, #16]
    5a60:	2280      	movs	r2, #128	; 0x80
    5a62:	709a      	strb	r2, [r3, #2]
	rxBufferLength = count;
    5a64:	f884 e039 	strb.w	lr, [r4, #57]	; 0x39
	return count;
    5a68:	4677      	mov	r7, lr
    5a6a:	e781      	b.n	5970 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
    5a6c:	f881 8002 	strb.w	r8, [r1, #2]
    5a70:	6923      	ldr	r3, [r4, #16]
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
    5a72:	2280      	movs	r2, #128	; 0x80
    5a74:	709a      	strb	r2, [r3, #2]
			rxBufferLength = count;
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
    5a76:	4677      	mov	r7, lr
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
			rxBufferLength = count;
    5a78:	f884 e039 	strb.w	lr, [r4, #57]	; 0x39
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
    5a7c:	e778      	b.n	5970 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
		if (count < BUFFER_LENGTH) {
			rxBuffer[count++] = port().D;
    5a7e:	eb04 020e 	add.w	r2, r4, lr
    5a82:	f891 8004 	ldrb.w	r8, [r1, #4]
    5a86:	f882 8018 	strb.w	r8, [r2, #24]
    5a8a:	f10e 0e01 	add.w	lr, lr, #1
    5a8e:	fa5f fe8e 	uxtb.w	lr, lr
    5a92:	e7b6      	b.n	5a02 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x14e>
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    5a94:	f881 c002 	strb.w	ip, [r1, #2]
    5a98:	6921      	ldr	r1, [r4, #16]
    5a9a:	4608      	mov	r0, r1
    5a9c:	e7ad      	b.n	59fa <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x146>
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
		//Serial.printf("requestFrom err5\n");
		return 0;
	} else if (length == 1) {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    5a9e:	21a8      	movs	r1, #168	; 0xa8
    5aa0:	7091      	strb	r1, [r2, #2]
    5aa2:	6920      	ldr	r0, [r4, #16]


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
    5aa4:	46be      	mov	lr, r7
	} else if (length == 1) {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
	}
	tmp = port().D; // initiate the first receive
    5aa6:	7902      	ldrb	r2, [r0, #4]
    5aa8:	e7ad      	b.n	5a06 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x152>
    5aaa:	4677      	mov	r7, lr
    5aac:	e760      	b.n	5970 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
	if ((status & I2C_S_ARBL)) {
		// we lost bus arbitration to another master
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//digitalWriteFast(13, HIGH);
		port().S = I2C_S_ARBL;
    5aae:	2110      	movs	r1, #16
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    5ab0:	f44f 7396 	mov.w	r3, #300	; 0x12c
    5ab4:	70d1      	strb	r1, [r2, #3]

00005ab6 <L_2952_delayMicroseconds>:
    5ab6:	3b01      	subs	r3, #1
    5ab8:	d1fd      	bne.n	5ab6 <L_2952_delayMicroseconds>
    5aba:	6922      	ldr	r2, [r4, #16]
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
    5abc:	7893      	ldrb	r3, [r2, #2]
    5abe:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		//Serial.printf("requestFrom err9a\n");
		return count;
    5ac2:	4677      	mov	r7, lr
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//digitalWriteFast(13, HIGH);
		port().S = I2C_S_ARBL;
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
    5ac4:	7093      	strb	r3, [r2, #2]
		//Serial.printf("requestFrom err9a\n");
		return count;
    5ac6:	e753      	b.n	5970 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
    5ac8:	7081      	strb	r1, [r0, #2]
    5aca:	e7d1      	b.n	5a70 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1bc>
    5acc:	6923      	ldr	r3, [r4, #16]
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
	if (count < BUFFER_LENGTH) {
		rxBuffer[count++] = port().D;
	} else {
		tmp = port().D;
    5ace:	791b      	ldrb	r3, [r3, #4]
    5ad0:	e7c1      	b.n	5a56 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1a2>
    5ad2:	bf00      	nop
    5ad4:	1fff2b4c 	.word	0x1fff2b4c

00005ad8 <i2c0_isr>:
#define MAKE_CONST(x) (__builtin_constant_p(x) ? (x) : (x))

#ifdef WIRE_IMPLEMENT_WIRE
constexpr uintptr_t i2c0_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C0));
TwoWire Wire(i2c0_addr, TwoWire::i2c0_hardware);
void i2c0_isr(void) { Wire.isr(); }
    5ad8:	4801      	ldr	r0, [pc, #4]	; (5ae0 <i2c0_isr+0x8>)
    5ada:	f7ff bd53 	b.w	5584 <TwoWire::isr()>
    5ade:	bf00      	nop
    5ae0:	1fff0894 	.word	0x1fff0894

00005ae4 <i2c1_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE1
constexpr uintptr_t i2c1_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C1));
TwoWire Wire1(i2c1_addr, TwoWire::i2c1_hardware);
void i2c1_isr(void) { Wire1.isr(); }
    5ae4:	4801      	ldr	r0, [pc, #4]	; (5aec <i2c1_isr+0x8>)
    5ae6:	f7ff bd4d 	b.w	5584 <TwoWire::isr()>
    5aea:	bf00      	nop
    5aec:	1fff0900 	.word	0x1fff0900

00005af0 <i2c2_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE2
constexpr uintptr_t i2c2_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C2));
TwoWire Wire2(i2c2_addr, TwoWire::i2c2_hardware);
void i2c2_isr(void) { Wire2.isr(); }
    5af0:	4801      	ldr	r0, [pc, #4]	; (5af8 <i2c2_isr+0x8>)
    5af2:	f7ff bd47 	b.w	5584 <TwoWire::isr()>
    5af6:	bf00      	nop
    5af8:	1fff0828 	.word	0x1fff0828

00005afc <MPU9250::MPU9250()>:

/** Default constructor, uses default I2C address.
 * @see MPU9250_DEFAULT_ADDRESS
 */
MPU9250::MPU9250() {
    devAddr = MPU9250_DEFAULT_ADDRESS;
    5afc:	2368      	movs	r3, #104	; 0x68
    5afe:	7003      	strb	r3, [r0, #0]
}
    5b00:	4770      	bx	lr
    5b02:	bf00      	nop

00005b04 <MPU9250::initialize()>:
 * after start-up). This function also sets both the accelerometer and the gyroscope
 * to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets
 * the clock source to use the X Gyro for reference, which is slightly better than
 * the default internal clock source.
 */
void MPU9250::initialize() {
    5b04:	b530      	push	{r4, r5, lr}
    5b06:	b083      	sub	sp, #12
 * @see getSleepEnabled()
 * @see MPU9250_RA_PWR_MGMT_1
 * @see MPU9250_PWR1_SLEEP_BIT
 */
void MPU9250::setSleepEnabled(bool enabled) {
    I2Cdev::writeBit(devAddr, MPU9250_RA_PWR_MGMT_1, MPU9250_PWR1_SLEEP_BIT, enabled);
    5b08:	2400      	movs	r4, #0
 * after start-up). This function also sets both the accelerometer and the gyroscope
 * to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets
 * the clock source to use the X Gyro for reference, which is slightly better than
 * the default internal clock source.
 */
void MPU9250::initialize() {
    5b0a:	4605      	mov	r5, r0
 * @see getSleepEnabled()
 * @see MPU9250_RA_PWR_MGMT_1
 * @see MPU9250_PWR1_SLEEP_BIT
 */
void MPU9250::setSleepEnabled(bool enabled) {
    I2Cdev::writeBit(devAddr, MPU9250_RA_PWR_MGMT_1, MPU9250_PWR1_SLEEP_BIT, enabled);
    5b0c:	4623      	mov	r3, r4
    5b0e:	7800      	ldrb	r0, [r0, #0]
    5b10:	9400      	str	r4, [sp, #0]
    5b12:	2206      	movs	r2, #6
    5b14:	216b      	movs	r1, #107	; 0x6b
    5b16:	f7ff fc43 	bl	53a0 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char, void*)>
 * @see MPU9250_RA_PWR_MGMT_1
 * @see MPU9250_PWR1_CLKSEL_BIT
 * @see MPU9250_PWR1_CLKSEL_LENGTH
 */
void MPU9250::setClockSource(uint8_t source) {
    I2Cdev::writeBits(devAddr, MPU9250_RA_PWR_MGMT_1, MPU9250_PWR1_CLKSEL_BIT, MPU9250_PWR1_CLKSEL_LENGTH, source);
    5b1a:	2301      	movs	r3, #1
    5b1c:	7828      	ldrb	r0, [r5, #0]
    5b1e:	9300      	str	r3, [sp, #0]
    5b20:	9401      	str	r4, [sp, #4]
    5b22:	2303      	movs	r3, #3
    5b24:	2202      	movs	r2, #2
    5b26:	216b      	movs	r1, #107	; 0x6b
    5b28:	f7ff fc68 	bl	53fc <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, void*)>
 * @see MPU9250_RA_GYRO_CONFIG
 * @see MPU9250_GCONFIG_FS_SEL_BIT
 * @see MPU9250_GCONFIG_FS_SEL_LENGTH
 */
void MPU9250::setFullScaleGyroRange(uint8_t range) {
    I2Cdev::writeBits(devAddr, MPU9250_RA_GYRO_CONFIG, MPU9250_GCONFIG_FS_SEL_BIT, MPU9250_GCONFIG_FS_SEL_LENGTH, range);
    5b2c:	7828      	ldrb	r0, [r5, #0]
    5b2e:	9401      	str	r4, [sp, #4]
    5b30:	9400      	str	r4, [sp, #0]
    5b32:	2302      	movs	r3, #2
    5b34:	2204      	movs	r2, #4
    5b36:	211b      	movs	r1, #27
    5b38:	f7ff fc60 	bl	53fc <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, void*)>
/** Set full-scale accelerometer range.
 * @param range New full-scale accelerometer range setting
 * @see getFullScaleAccelRange()
 */
void MPU9250::setFullScaleAccelRange(uint8_t range) {
    I2Cdev::writeBits(devAddr, MPU9250_RA_ACCEL_CONFIG, MPU9250_ACONFIG_AFS_SEL_BIT, MPU9250_ACONFIG_AFS_SEL_LENGTH, range);
    5b3c:	7828      	ldrb	r0, [r5, #0]
    5b3e:	9401      	str	r4, [sp, #4]
    5b40:	9400      	str	r4, [sp, #0]
    5b42:	2302      	movs	r3, #2
    5b44:	2204      	movs	r2, #4
    5b46:	211c      	movs	r1, #28
    5b48:	f7ff fc58 	bl	53fc <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, void*)>
void MPU9250::initialize() {
    setSleepEnabled(false); // thanks to Jack Elston for pointing this one out!
    setClockSource(MPU9250_CLOCK_PLL_XGYRO);
    setFullScaleGyroRange(MPU9250_GYRO_FS_250);
    setFullScaleAccelRange(MPU9250_ACCEL_FS_2);
}
    5b4c:	b003      	add	sp, #12
    5b4e:	bd30      	pop	{r4, r5, pc}

00005b50 <ros::normalizeSecNSec(unsigned long&, unsigned long&)>:
#include "ros/time.h"

namespace ros
{
void normalizeSecNSec(uint32_t& sec, uint32_t& nsec)
{
    5b50:	b470      	push	{r4, r5, r6}
  uint32_t nsec_part = nsec % 1000000000UL;
    5b52:	680d      	ldr	r5, [r1, #0]
  uint32_t sec_part = nsec / 1000000000UL;
  sec += sec_part;
    5b54:	4b06      	ldr	r3, [pc, #24]	; (5b70 <ros::normalizeSecNSec(unsigned long&, unsigned long&)+0x20>)
    5b56:	6804      	ldr	r4, [r0, #0]
  nsec = nsec_part;
    5b58:	4e06      	ldr	r6, [pc, #24]	; (5b74 <ros::normalizeSecNSec(unsigned long&, unsigned long&)+0x24>)
{
void normalizeSecNSec(uint32_t& sec, uint32_t& nsec)
{
  uint32_t nsec_part = nsec % 1000000000UL;
  uint32_t sec_part = nsec / 1000000000UL;
  sec += sec_part;
    5b5a:	0a6a      	lsrs	r2, r5, #9
    5b5c:	fba3 3202 	umull	r3, r2, r3, r2
    5b60:	09d3      	lsrs	r3, r2, #7
    5b62:	441c      	add	r4, r3
  nsec = nsec_part;
    5b64:	fb06 5313 	mls	r3, r6, r3, r5
{
void normalizeSecNSec(uint32_t& sec, uint32_t& nsec)
{
  uint32_t nsec_part = nsec % 1000000000UL;
  uint32_t sec_part = nsec / 1000000000UL;
  sec += sec_part;
    5b68:	6004      	str	r4, [r0, #0]
  nsec = nsec_part;
    5b6a:	600b      	str	r3, [r1, #0]
}
    5b6c:	bc70      	pop	{r4, r5, r6}
    5b6e:	4770      	bx	lr
    5b70:	00044b83 	.word	0x00044b83
    5b74:	3b9aca00 	.word	0x3b9aca00

00005b78 <memcpy>:
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
#else
	push	{r0}
    5b78:	b401      	push	{r0}
#endif
	orr	r3, r1, r0
    5b7a:	ea41 0300 	orr.w	r3, r1, r0
	ands	r3, r3, #3
    5b7e:	f013 0303 	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    5b82:	d16f      	bne.n	5c64 <memcpy+0xec>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    5b84:	3a40      	subs	r2, #64	; 0x40
	blo	.Lmid_block
    5b86:	d341      	bcc.n	5c0c <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    5b88:	f851 3b04 	ldr.w	r3, [r1], #4
    5b8c:	f840 3b04 	str.w	r3, [r0], #4
    5b90:	f851 3b04 	ldr.w	r3, [r1], #4
    5b94:	f840 3b04 	str.w	r3, [r0], #4
    5b98:	f851 3b04 	ldr.w	r3, [r1], #4
    5b9c:	f840 3b04 	str.w	r3, [r0], #4
    5ba0:	f851 3b04 	ldr.w	r3, [r1], #4
    5ba4:	f840 3b04 	str.w	r3, [r0], #4
    5ba8:	f851 3b04 	ldr.w	r3, [r1], #4
    5bac:	f840 3b04 	str.w	r3, [r0], #4
    5bb0:	f851 3b04 	ldr.w	r3, [r1], #4
    5bb4:	f840 3b04 	str.w	r3, [r0], #4
    5bb8:	f851 3b04 	ldr.w	r3, [r1], #4
    5bbc:	f840 3b04 	str.w	r3, [r0], #4
    5bc0:	f851 3b04 	ldr.w	r3, [r1], #4
    5bc4:	f840 3b04 	str.w	r3, [r0], #4
    5bc8:	f851 3b04 	ldr.w	r3, [r1], #4
    5bcc:	f840 3b04 	str.w	r3, [r0], #4
    5bd0:	f851 3b04 	ldr.w	r3, [r1], #4
    5bd4:	f840 3b04 	str.w	r3, [r0], #4
    5bd8:	f851 3b04 	ldr.w	r3, [r1], #4
    5bdc:	f840 3b04 	str.w	r3, [r0], #4
    5be0:	f851 3b04 	ldr.w	r3, [r1], #4
    5be4:	f840 3b04 	str.w	r3, [r0], #4
    5be8:	f851 3b04 	ldr.w	r3, [r1], #4
    5bec:	f840 3b04 	str.w	r3, [r0], #4
    5bf0:	f851 3b04 	ldr.w	r3, [r1], #4
    5bf4:	f840 3b04 	str.w	r3, [r0], #4
    5bf8:	f851 3b04 	ldr.w	r3, [r1], #4
    5bfc:	f840 3b04 	str.w	r3, [r0], #4
    5c00:	f851 3b04 	ldr.w	r3, [r1], #4
    5c04:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    5c08:	3a40      	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    5c0a:	d2bd      	bcs.n	5b88 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    5c0c:	3230      	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    5c0e:	d311      	bcc.n	5c34 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    5c10:	f851 3b04 	ldr.w	r3, [r1], #4
    5c14:	f840 3b04 	str.w	r3, [r0], #4
    5c18:	f851 3b04 	ldr.w	r3, [r1], #4
    5c1c:	f840 3b04 	str.w	r3, [r0], #4
    5c20:	f851 3b04 	ldr.w	r3, [r1], #4
    5c24:	f840 3b04 	str.w	r3, [r0], #4
    5c28:	f851 3b04 	ldr.w	r3, [r1], #4
    5c2c:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    5c30:	3a10      	subs	r2, #16
	bhs	.Lmid_block_loop
    5c32:	d2ed      	bcs.n	5c10 <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    5c34:	320c      	adds	r2, #12
	blo	.Lcopy_less_than_4
    5c36:	d305      	bcc.n	5c44 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    5c38:	f851 3b04 	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    5c3c:	f840 3b04 	str.w	r3, [r0], #4
	subs	r2, #4
    5c40:	3a04      	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    5c42:	d2f9      	bcs.n	5c38 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    5c44:	3204      	adds	r2, #4
	beq	.Ldone
    5c46:	d00a      	beq.n	5c5e <memcpy+0xe6>

	lsls	r2, r2, #31
    5c48:	07d2      	lsls	r2, r2, #31
	itt ne
    5c4a:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    5c4c:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    5c50:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc	.Ldone
    5c54:	d303      	bcc.n	5c5e <memcpy+0xe6>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
	strh	r3, [r0]
#else
	ldrb	r3, [r1]
    5c56:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    5c58:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    5c5a:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    5c5c:	7043      	strb	r3, [r0, #1]

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    5c5e:	bc01      	pop	{r0}
#endif
	bx	lr
    5c60:	4770      	bx	lr
    5c62:	bf00      	nop
	beq	.Ldst_aligned
#else
	/* if len < 12, misalignment adjustment has more overhead than
	just byte-to-byte copy.  Also, len must >=8 to guarantee code
	afterward work correctly.  */
	cmp	r2, #12
    5c64:	2a0c      	cmp	r2, #12
	blo	.Lbyte_copy
    5c66:	d34a      	bcc.n	5cfe <memcpy+0x186>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    5c68:	f010 0303 	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    5c6c:	d011      	beq.n	5c92 <memcpy+0x11a>

	rsb	r3, #4
    5c6e:	f1c3 0304 	rsb	r3, r3, #4
	subs	r2, r3
    5c72:	1ad2      	subs	r2, r2, r3

	lsls    r3, r3, #31
    5c74:	07db      	lsls	r3, r3, #31
	itt ne
    5c76:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    5c78:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    5c7c:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    5c80:	d307      	bcc.n	5c92 <memcpy+0x11a>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
	strh    r3, [r0], #2
	b	.Ldst_aligned
#else
	ldrb    r3, [r1], #1
    5c82:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    5c86:	f800 3b01 	strb.w	r3, [r0], #1
	ldrb    r3, [r1], #1
    5c8a:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    5c8e:	f800 3b01 	strb.w	r3, [r0], #1
	/* Now that dst is aligned */
.Ldst_aligned:
	/* if r1 is aligned now, it means r0/r1 has the same misalignment,
	and they are both aligned now.  Go aligned copy.  */
	ands	r3, r1, #3
    5c92:	f011 0303 	ands.w	r3, r1, #3
	beq	.Lbig_block
    5c96:	f43f af75 	beq.w	5b84 <memcpy+0xc>

	/* dst is aligned, but src isn't.  Misaligned copy.  */

	push	{r4, r5}
    5c9a:	b430      	push	{r4, r5}
	subs	r2, #4
    5c9c:	3a04      	subs	r2, #4

	/* Backward r1 by misaligned bytes, to make r1 aligned.
	Since we need to restore r1 to unaligned address after the loop,
	we need keep the offset bytes to ip and sub it from r1 afterward.  */
	subs	r1, r3
    5c9e:	1ac9      	subs	r1, r1, r3
	rsb	ip, r3, #4
    5ca0:	f1c3 0c04 	rsb	ip, r3, #4

	/* Pre-load on word */
	ldr	r4, [r1], #4
    5ca4:	f851 4b04 	ldr.w	r4, [r1], #4

	cmp	r3, #2
    5ca8:	2b02      	cmp	r3, #2
	beq	.Lmisaligned_copy_2_2
    5caa:	d019      	beq.n	5ce0 <memcpy+0x168>
	cmp	r3, #3
    5cac:	2b03      	cmp	r3, #3
	beq	.Lmisaligned_copy_3_1
    5cae:	d00b      	beq.n	5cc8 <memcpy+0x150>
	subs	r2, #4
	bhs	1b
	.endm

.Lmisaligned_copy_1_3:
	mis_src_copy shift=8
    5cb0:	0a24      	lsrs	r4, r4, #8
    5cb2:	f851 3b04 	ldr.w	r3, [r1], #4
    5cb6:	061d      	lsls	r5, r3, #24
    5cb8:	ea44 0405 	orr.w	r4, r4, r5
    5cbc:	f840 4b04 	str.w	r4, [r0], #4
    5cc0:	461c      	mov	r4, r3
    5cc2:	3a04      	subs	r2, #4
    5cc4:	d2f4      	bcs.n	5cb0 <memcpy+0x138>
	b	.Lsrc_misaligned_tail
    5cc6:	e016      	b.n	5cf6 <memcpy+0x17e>

.Lmisaligned_copy_3_1:
	mis_src_copy shift=24
    5cc8:	0e24      	lsrs	r4, r4, #24
    5cca:	f851 3b04 	ldr.w	r3, [r1], #4
    5cce:	021d      	lsls	r5, r3, #8
    5cd0:	ea44 0405 	orr.w	r4, r4, r5
    5cd4:	f840 4b04 	str.w	r4, [r0], #4
    5cd8:	461c      	mov	r4, r3
    5cda:	3a04      	subs	r2, #4
    5cdc:	d2f4      	bcs.n	5cc8 <memcpy+0x150>
	b	.Lsrc_misaligned_tail
    5cde:	e00a      	b.n	5cf6 <memcpy+0x17e>

.Lmisaligned_copy_2_2:
	/* For 2_2 misalignment, ldr is still faster than 2 x ldrh.  */
	mis_src_copy shift=16
    5ce0:	0c24      	lsrs	r4, r4, #16
    5ce2:	f851 3b04 	ldr.w	r3, [r1], #4
    5ce6:	041d      	lsls	r5, r3, #16
    5ce8:	ea44 0405 	orr.w	r4, r4, r5
    5cec:	f840 4b04 	str.w	r4, [r0], #4
    5cf0:	461c      	mov	r4, r3
    5cf2:	3a04      	subs	r2, #4
    5cf4:	d2f4      	bcs.n	5ce0 <memcpy+0x168>

.Lsrc_misaligned_tail:
	adds	r2, #4
    5cf6:	3204      	adds	r2, #4
	subs	r1, ip
    5cf8:	ebb1 010c 	subs.w	r1, r1, ip
	pop	{r4, r5}
    5cfc:	bc30      	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    5cfe:	3a04      	subs	r2, #4
	blo	.Lcopy_less_than_4
    5d00:	d3a0      	bcc.n	5c44 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    5d02:	3a01      	subs	r2, #1
	ldrb    r3, [r1], #1
    5d04:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    5d08:	f800 3b01 	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    5d0c:	d2f9      	bcs.n	5d02 <memcpy+0x18a>

	ldrb	r3, [r1]
    5d0e:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    5d10:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    5d12:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    5d14:	7043      	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    5d16:	788b      	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    5d18:	7083      	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    5d1a:	bc01      	pop	{r0}
#endif
	bx	lr
    5d1c:	4770      	bx	lr
    5d1e:	bf00      	nop

00005d20 <fault_isr>:
void _init_Teensyduino_internal_(void) __attribute__((noinline));
void __libc_init_array(void);


void fault_isr(void)
{
    5d20:	b508      	push	{r3, lr}
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    5d22:	4c10      	ldr	r4, [pc, #64]	; (5d64 <fault_isr+0x44>)
    5d24:	e008      	b.n	5d38 <fault_isr+0x18>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    5d26:	6823      	ldr	r3, [r4, #0]
    5d28:	0559      	lsls	r1, r3, #21
    5d2a:	d40d      	bmi.n	5d48 <fault_isr+0x28>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    5d2c:	6823      	ldr	r3, [r4, #0]
    5d2e:	051a      	lsls	r2, r3, #20
    5d30:	d40f      	bmi.n	5d52 <fault_isr+0x32>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    5d32:	6823      	ldr	r3, [r4, #0]
    5d34:	04db      	lsls	r3, r3, #19
    5d36:	d411      	bmi.n	5d5c <fault_isr+0x3c>
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    5d38:	6823      	ldr	r3, [r4, #0]
    5d3a:	0358      	lsls	r0, r3, #13
    5d3c:	d5f3      	bpl.n	5d26 <fault_isr+0x6>
    5d3e:	f000 fceb 	bl	6718 <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    5d42:	6823      	ldr	r3, [r4, #0]
    5d44:	0559      	lsls	r1, r3, #21
    5d46:	d5f1      	bpl.n	5d2c <fault_isr+0xc>
    5d48:	f000 f80e 	bl	5d68 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    5d4c:	6823      	ldr	r3, [r4, #0]
    5d4e:	051a      	lsls	r2, r3, #20
    5d50:	d5ef      	bpl.n	5d32 <fault_isr+0x12>
    5d52:	f000 f809 	bl	5d68 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    5d56:	6823      	ldr	r3, [r4, #0]
    5d58:	04db      	lsls	r3, r3, #19
    5d5a:	d5ed      	bpl.n	5d38 <fault_isr+0x18>
    5d5c:	f000 f804 	bl	5d68 <unused_isr>
    5d60:	e7ea      	b.n	5d38 <fault_isr+0x18>
    5d62:	bf00      	nop
    5d64:	40048034 	.word	0x40048034

00005d68 <unused_isr>:
	}
}

void unused_isr(void)
{
    5d68:	b508      	push	{r3, lr}
	fault_isr();
    5d6a:	f7ff ffd9 	bl	5d20 <fault_isr>
    5d6e:	bf00      	nop

00005d70 <startup_early_hook>:
extern void rtc_set(unsigned long t);


static void startup_default_early_hook(void) {
#if defined(KINETISK)
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    5d70:	4b01      	ldr	r3, [pc, #4]	; (5d78 <startup_early_hook+0x8>)
    5d72:	2210      	movs	r2, #16
    5d74:	801a      	strh	r2, [r3, #0]
    5d76:	4770      	bx	lr
    5d78:	40052000 	.word	0x40052000

00005d7c <startup_late_hook>:
#elif defined(KINETISL)
	SIM_COPC = 0;  // disable the watchdog
#endif
}
static void startup_default_late_hook(void) {}
    5d7c:	4770      	bx	lr
    5d7e:	bf00      	nop

00005d80 <_sbrk>:

void * _sbrk(int incr)
{
	char *prev, *stack;

	prev = __brkval;
    5d80:	4909      	ldr	r1, [pc, #36]	; (5da8 <_sbrk+0x28>)

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

void * _sbrk(int incr)
{
    5d82:	b508      	push	{r3, lr}
	char *prev, *stack;

	prev = __brkval;
    5d84:	680b      	ldr	r3, [r1, #0]
	if (incr != 0) {
    5d86:	b130      	cbz	r0, 5d96 <_sbrk+0x16>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
    5d88:	466a      	mov	r2, sp
		if (prev + incr >= stack - STACK_MARGIN) {
    5d8a:	4418      	add	r0, r3
    5d8c:	f5a2 5200 	sub.w	r2, r2, #8192	; 0x2000
    5d90:	4290      	cmp	r0, r2
    5d92:	d202      	bcs.n	5d9a <_sbrk+0x1a>
			errno = ENOMEM;
			return (void *)-1;
		}
		__brkval = prev + incr;
    5d94:	6008      	str	r0, [r1, #0]
	}
	return prev;
    5d96:	4618      	mov	r0, r3
}
    5d98:	bd08      	pop	{r3, pc}

	prev = __brkval;
	if (incr != 0) {
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
		if (prev + incr >= stack - STACK_MARGIN) {
			errno = ENOMEM;
    5d9a:	f003 fb59 	bl	9450 <__errno>
    5d9e:	230c      	movs	r3, #12
    5da0:	6003      	str	r3, [r0, #0]
			return (void *)-1;
    5da2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    5da6:	bd08      	pop	{r3, pc}
    5da8:	1fff096c 	.word	0x1fff096c

00005dac <kinetis_hsrun_disable>:


#if defined(HAS_KINETIS_HSRUN) && F_CPU > 120000000
int kinetis_hsrun_disable(void)
{
	if (SMC_PMSTAT == SMC_PMSTAT_HSRUN) {
    5dac:	4a08      	ldr	r2, [pc, #32]	; (5dd0 <kinetis_hsrun_disable+0x24>)
    5dae:	7813      	ldrb	r3, [r2, #0]
    5db0:	2b80      	cmp	r3, #128	; 0x80
    5db2:	d001      	beq.n	5db8 <kinetis_hsrun_disable+0xc>
		// Then turn off HSRUN mode
		SMC_PMCTRL = SMC_PMCTRL_RUNM(0);
		while (SMC_PMSTAT == SMC_PMSTAT_HSRUN) ; // wait
		return 1;
	}
	return 0;
    5db4:	2000      	movs	r0, #0
}
    5db6:	4770      	bx	lr
		#elif F_CPU == 192000000 && F_BUS == 64000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(2, 2, 2, 8); // ok
		#elif F_CPU == 192000000 && F_BUS == 96000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 7); // ok
		#elif F_CPU == 180000000 && F_BUS == 60000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(2, 2, 2, 8); // ok
    5db8:	4906      	ldr	r1, [pc, #24]	; (5dd4 <kinetis_hsrun_disable+0x28>)
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 5); // ok
		#else
			return 0;
		#endif
		// Then turn off HSRUN mode
		SMC_PMCTRL = SMC_PMCTRL_RUNM(0);
    5dba:	4b07      	ldr	r3, [pc, #28]	; (5dd8 <kinetis_hsrun_disable+0x2c>)
		#elif F_CPU == 192000000 && F_BUS == 64000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(2, 2, 2, 8); // ok
		#elif F_CPU == 192000000 && F_BUS == 96000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 7); // ok
		#elif F_CPU == 180000000 && F_BUS == 60000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(2, 2, 2, 8); // ok
    5dbc:	4807      	ldr	r0, [pc, #28]	; (5ddc <kinetis_hsrun_disable+0x30>)
    5dbe:	6008      	str	r0, [r1, #0]
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 5); // ok
		#else
			return 0;
		#endif
		// Then turn off HSRUN mode
		SMC_PMCTRL = SMC_PMCTRL_RUNM(0);
    5dc0:	2100      	movs	r1, #0
    5dc2:	7019      	strb	r1, [r3, #0]
		while (SMC_PMSTAT == SMC_PMSTAT_HSRUN) ; // wait
    5dc4:	7813      	ldrb	r3, [r2, #0]
    5dc6:	2b80      	cmp	r3, #128	; 0x80
    5dc8:	d0fc      	beq.n	5dc4 <kinetis_hsrun_disable+0x18>
		return 1;
    5dca:	2001      	movs	r0, #1
    5dcc:	4770      	bx	lr
    5dce:	bf00      	nop
    5dd0:	4007e003 	.word	0x4007e003
    5dd4:	40048044 	.word	0x40048044
    5dd8:	4007e001 	.word	0x4007e001
    5ddc:	22280000 	.word	0x22280000

00005de0 <kinetis_hsrun_enable>:
	return 0;
}

int kinetis_hsrun_enable(void)
{
	if (SMC_PMSTAT == SMC_PMSTAT_RUN) {
    5de0:	4a09      	ldr	r2, [pc, #36]	; (5e08 <kinetis_hsrun_enable+0x28>)
    5de2:	7813      	ldrb	r3, [r2, #0]
    5de4:	2b01      	cmp	r3, #1
    5de6:	d001      	beq.n	5dec <kinetis_hsrun_enable+0xc>
		#else
			return 0;
		#endif
		return 1;
	}
	return 0;
    5de8:	2000      	movs	r0, #0
}
    5dea:	4770      	bx	lr

int kinetis_hsrun_enable(void)
{
	if (SMC_PMSTAT == SMC_PMSTAT_RUN) {
		// Turn HSRUN mode on
		SMC_PMCTRL = SMC_PMCTRL_RUNM(3);
    5dec:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    5df0:	f503 23fc 	add.w	r3, r3, #516096	; 0x7e000
    5df4:	2160      	movs	r1, #96	; 0x60
    5df6:	7019      	strb	r1, [r3, #0]
		while (SMC_PMSTAT != SMC_PMSTAT_HSRUN) {;} // wait
    5df8:	7813      	ldrb	r3, [r2, #0]
    5dfa:	2b80      	cmp	r3, #128	; 0x80
    5dfc:	d1fc      	bne.n	5df8 <kinetis_hsrun_enable+0x18>
		#elif F_CPU == 192000000 && F_BUS == 64000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 2, 0, 6);
		#elif F_CPU == 192000000 && F_BUS == 96000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 1, 0, 6);
		#elif F_CPU == 180000000 && F_BUS == 60000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 2, 0, 6);
    5dfe:	4b03      	ldr	r3, [pc, #12]	; (5e0c <kinetis_hsrun_enable+0x2c>)
    5e00:	4a03      	ldr	r2, [pc, #12]	; (5e10 <kinetis_hsrun_enable+0x30>)
    5e02:	601a      	str	r2, [r3, #0]
		#elif F_CPU == 144000000 && F_BUS == 72000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 1, 0, 4);
		#else
			return 0;
		#endif
		return 1;
    5e04:	2001      	movs	r0, #1
    5e06:	4770      	bx	lr
    5e08:	4007e003 	.word	0x4007e003
    5e0c:	40048044 	.word	0x40048044
    5e10:	02060000 	.word	0x02060000

00005e14 <dummy_isr>:
	{((volatile uint8_t *)&CORE_PIN26_PORTREG + (CORE_PIN26_BIT >> 3)), &CORE_PIN26_CONFIG, (1<<(CORE_PIN26_BIT & 7))}
};

#endif

static void dummy_isr() {};
    5e14:	4770      	bx	lr
    5e16:	bf00      	nop

00005e18 <digitalWrite.part.1>:



// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
    5e18:	b410      	push	{r4}
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
    5e1a:	4b11      	ldr	r3, [pc, #68]	; (5e60 <digitalWrite.part.1+0x48>)
    5e1c:	f853 2030 	ldr.w	r2, [r3, r0, lsl #3]
    5e20:	f892 4280 	ldrb.w	r4, [r2, #640]	; 0x280
    5e24:	b134      	cbz	r4, 5e34 <digitalWrite.part.1+0x1c>
		if (val) {
			*portSetRegister(pin) = 1;
    5e26:	2301      	movs	r3, #1
void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
    5e28:	b179      	cbz	r1, 5e4a <digitalWrite.part.1+0x32>
			*portSetRegister(pin) = 1;
    5e2a:	f882 3080 	strb.w	r3, [r2, #128]	; 0x80
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    5e2e:	f85d 4b04 	ldr.w	r4, [sp], #4
    5e32:	4770      	bx	lr
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
    5e34:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
    5e38:	685b      	ldr	r3, [r3, #4]
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    5e3a:	681a      	ldr	r2, [r3, #0]
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
    5e3c:	b951      	cbnz	r1, 5e54 <digitalWrite.part.1+0x3c>
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
			//*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else {
			// TODO use bitband for atomic read-mod-write
			*config &= ~(PORT_PCR_PE);
    5e3e:	f022 0202 	bic.w	r2, r2, #2
    5e42:	601a      	str	r2, [r3, #0]
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    5e44:	f85d 4b04 	ldr.w	r4, [sp], #4
    5e48:	4770      	bx	lr
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
			*portSetRegister(pin) = 1;
		} else {
			*portClearRegister(pin) = 1;
    5e4a:	f882 3100 	strb.w	r3, [r2, #256]	; 0x100
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    5e4e:	f85d 4b04 	ldr.w	r4, [sp], #4
    5e52:	4770      	bx	lr
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    5e54:	f042 0203 	orr.w	r2, r2, #3
    5e58:	601a      	str	r2, [r3, #0]
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    5e5a:	f85d 4b04 	ldr.w	r4, [sp], #4
    5e5e:	4770      	bx	lr
    5e60:	0000acb8 	.word	0x0000acb8

00005e64 <pinMode.part.2>:
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    5e64:	4a1c      	ldr	r2, [pc, #112]	; (5ed8 <pinMode.part.2+0x74>)
    5e66:	eb02 03c0 	add.w	r3, r2, r0, lsl #3

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    5e6a:	2901      	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    5e6c:	685b      	ldr	r3, [r3, #4]

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    5e6e:	d011      	beq.n	5e94 <pinMode.part.2+0x30>
    5e70:	2904      	cmp	r1, #4
    5e72:	d01b      	beq.n	5eac <pinMode.part.2+0x48>
		} else {
		    *config &= ~PORT_PCR_ODE;
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
    5e74:	f852 0030 	ldr.w	r0, [r2, r0, lsl #3]
    5e78:	2200      	movs	r2, #0
    5e7a:	f880 2280 	strb.w	r2, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
    5e7e:	b129      	cbz	r1, 5e8c <pinMode.part.2+0x28>
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
    5e80:	2902      	cmp	r1, #2
    5e82:	d020      	beq.n	5ec6 <pinMode.part.2+0x62>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else if (mode == INPUT_PULLDOWN) {
    5e84:	2903      	cmp	r1, #3
    5e86:	d022      	beq.n	5ece <pinMode.part.2+0x6a>
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    5e88:	601a      	str	r2, [r3, #0]
    5e8a:	4770      	bx	lr
		*portModeRegister(pin) = 0;
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
    5e8c:	f44f 7280 	mov.w	r2, #256	; 0x100
    5e90:	601a      	str	r2, [r3, #0]
    5e92:	4770      	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    5e94:	f852 0030 	ldr.w	r0, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    5e98:	f44f 72a2 	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    5e9c:	f880 1280 	strb.w	r1, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    5ea0:	601a      	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    5ea2:	681a      	ldr	r2, [r3, #0]
    5ea4:	f022 0220 	bic.w	r2, r2, #32
    5ea8:	601a      	str	r2, [r3, #0]
    5eaa:	4770      	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    5eac:	f852 1030 	ldr.w	r1, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    5eb0:	f44f 72a2 	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    5eb4:	2001      	movs	r0, #1
    5eb6:	f881 0280 	strb.w	r0, [r1, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    5eba:	601a      	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
    5ebc:	681a      	ldr	r2, [r3, #0]
    5ebe:	f042 0220 	orr.w	r2, r2, #32
    5ec2:	601a      	str	r2, [r3, #0]
    5ec4:	4770      	bx	lr
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    5ec6:	f240 1203 	movw	r2, #259	; 0x103
    5eca:	601a      	str	r2, [r3, #0]
    5ecc:	4770      	bx	lr
		} else if (mode == INPUT_PULLDOWN) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    5ece:	f44f 7281 	mov.w	r2, #258	; 0x102
    5ed2:	601a      	str	r2, [r3, #0]
    5ed4:	4770      	bx	lr
    5ed6:	bf00      	nop
    5ed8:	0000acb8 	.word	0x0000acb8

00005edc <attachInterrupt>:
void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
    5edc:	283f      	cmp	r0, #63	; 0x3f
    5ede:	d848      	bhi.n	5f72 <attachInterrupt+0x96>
{
	_VectorsRam[irq + 16] = function;
}

void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
    5ee0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	switch (mode) {
    5ee2:	2a04      	cmp	r2, #4
    5ee4:	d844      	bhi.n	5f70 <attachInterrupt+0x94>
    5ee6:	e8df f002 	tbb	[pc, r2]
    5eea:	4b48      	.short	0x4b48
    5eec:	034e      	.short	0x034e
    5eee:	45          	.byte	0x45
    5eef:	00          	.byte	0x00
    5ef0:	f44f 2610 	mov.w	r6, #589824	; 0x90000
	  case LOW:	mask = 0x08; break;
	  case HIGH:	mask = 0x0C; break;
	  default: return;
	}
	mask = (mask << 16) | 0x01000000;
	config = portConfigRegister(pin);
    5ef4:	4b2b      	ldr	r3, [pc, #172]	; (5fa4 <attachInterrupt+0xc8>)
    5ef6:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
    5efa:	460d      	mov	r5, r1
    5efc:	685c      	ldr	r4, [r3, #4]
	if ((*config & 0x00000700) == 0) {
    5efe:	6821      	ldr	r1, [r4, #0]
    5f00:	f411 61e0 	ands.w	r1, r1, #1792	; 0x700
    5f04:	d048      	beq.n	5f98 <attachInterrupt+0xbc>
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    5f06:	4b28      	ldr	r3, [pc, #160]	; (5fa8 <attachInterrupt+0xcc>)
    5f08:	4a28      	ldr	r2, [pc, #160]	; (5fac <attachInterrupt+0xd0>)
    5f0a:	4929      	ldr	r1, [pc, #164]	; (5fb0 <attachInterrupt+0xd4>)
    5f0c:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    5f10:	f104 4240 	add.w	r2, r4, #3221225472	; 0xc0000000
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    5f14:	4827      	ldr	r0, [pc, #156]	; (5fb4 <attachInterrupt+0xd8>)
    5f16:	f8c3 1134 	str.w	r1, [r3, #308]	; 0x134

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    5f1a:	f5a2 2192 	sub.w	r1, r2, #299008	; 0x49000
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    5f1e:	4f26      	ldr	r7, [pc, #152]	; (5fb8 <attachInterrupt+0xdc>)
    5f20:	f8c3 0130 	str.w	r0, [r3, #304]	; 0x130

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    5f24:	297c      	cmp	r1, #124	; 0x7c
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    5f26:	4825      	ldr	r0, [pc, #148]	; (5fbc <attachInterrupt+0xe0>)
    5f28:	f8c3 7138 	str.w	r7, [r3, #312]	; 0x138
    5f2c:	f8c3 013c 	str.w	r0, [r3, #316]	; 0x13c

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    5f30:	d92c      	bls.n	5f8c <attachInterrupt+0xb0>
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
    5f32:	f5a2 2394 	sub.w	r3, r2, #303104	; 0x4a000
    5f36:	2b7c      	cmp	r3, #124	; 0x7c
    5f38:	d92a      	bls.n	5f90 <attachInterrupt+0xb4>
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
    5f3a:	f5a2 2396 	sub.w	r3, r2, #307200	; 0x4b000
    5f3e:	2b7c      	cmp	r3, #124	; 0x7c
    5f40:	d928      	bls.n	5f94 <attachInterrupt+0xb8>
	else if(&PORTD_PCR0 <= config && config <= &PORTD_PCR31) isr_table = isr_table_portD;
    5f42:	f5a2 2398 	sub.w	r3, r2, #311296	; 0x4c000
    5f46:	2b7c      	cmp	r3, #124	; 0x7c
    5f48:	d929      	bls.n	5f9e <attachInterrupt+0xc2>
	else if(&PORTE_PCR0 <= config && config <= &PORTE_PCR31) isr_table = isr_table_portE;
    5f4a:	f5a2 229a 	sub.w	r2, r2, #315392	; 0x4d000
    5f4e:	2a7c      	cmp	r2, #124	; 0x7c
    5f50:	d827      	bhi.n	5fa2 <attachInterrupt+0xc6>
    5f52:	481b      	ldr	r0, [pc, #108]	; (5fc0 <attachInterrupt+0xe4>)
	attachInterruptVector(IRQ_PORTD, port_D_isr);
	attachInterruptVector(IRQ_PORTE, port_E_isr);
	voidFuncPtr* isr_table = getIsrTable(config);
	if(!isr_table) return;
	uint32_t pin_index = getPinIndex(config);
	__disable_irq();
    5f54:	b672      	cpsid	i
	cfg = *config;
    5f56:	6823      	ldr	r3, [r4, #0]
	cfg &= ~0x000F0000;		// disable any previous interrupt
    5f58:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    5f5c:	f043 7280 	orr.w	r2, r3, #16777216	; 0x1000000
	*config = cfg;
	isr_table[pin_index] = function;	// set the function pointer
    5f60:	f3c4 0184 	ubfx	r1, r4, #2, #5
	cfg |= mask;
    5f64:	4316      	orrs	r6, r2
	if(!isr_table) return;
	uint32_t pin_index = getPinIndex(config);
	__disable_irq();
	cfg = *config;
	cfg &= ~0x000F0000;		// disable any previous interrupt
	*config = cfg;
    5f66:	6023      	str	r3, [r4, #0]
	isr_table[pin_index] = function;	// set the function pointer
    5f68:	f840 5021 	str.w	r5, [r0, r1, lsl #2]
	cfg |= mask;
	*config = cfg;			// enable the new interrupt
    5f6c:	6026      	str	r6, [r4, #0]
	__enable_irq();
    5f6e:	b662      	cpsie	i
    5f70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5f72:	4770      	bx	lr
{
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	switch (mode) {
    5f74:	f44f 2630 	mov.w	r6, #720896	; 0xb0000
    5f78:	e7bc      	b.n	5ef4 <attachInterrupt+0x18>
	  case CHANGE:	mask = 0x0B; break;
	  case RISING:	mask = 0x09; break;
	  case FALLING:	mask = 0x0A; break;
	  case LOW:	mask = 0x08; break;
    5f7a:	f44f 2600 	mov.w	r6, #524288	; 0x80000
    5f7e:	e7b9      	b.n	5ef4 <attachInterrupt+0x18>
	  case HIGH:	mask = 0x0C; break;
    5f80:	f44f 2640 	mov.w	r6, #786432	; 0xc0000
    5f84:	e7b6      	b.n	5ef4 <attachInterrupt+0x18>
{
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	switch (mode) {
    5f86:	f44f 2620 	mov.w	r6, #655360	; 0xa0000
    5f8a:	e7b3      	b.n	5ef4 <attachInterrupt+0x18>

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    5f8c:	480d      	ldr	r0, [pc, #52]	; (5fc4 <attachInterrupt+0xe8>)
    5f8e:	e7e1      	b.n	5f54 <attachInterrupt+0x78>
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
    5f90:	480d      	ldr	r0, [pc, #52]	; (5fc8 <attachInterrupt+0xec>)
    5f92:	e7df      	b.n	5f54 <attachInterrupt+0x78>
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
    5f94:	480d      	ldr	r0, [pc, #52]	; (5fcc <attachInterrupt+0xf0>)
    5f96:	e7dd      	b.n	5f54 <attachInterrupt+0x78>
    5f98:	f7ff ff64 	bl	5e64 <pinMode.part.2>
    5f9c:	e7b3      	b.n	5f06 <attachInterrupt+0x2a>
	else if(&PORTD_PCR0 <= config && config <= &PORTD_PCR31) isr_table = isr_table_portD;
    5f9e:	480c      	ldr	r0, [pc, #48]	; (5fd0 <attachInterrupt+0xf4>)
    5fa0:	e7d8      	b.n	5f54 <attachInterrupt+0x78>
    5fa2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5fa4:	0000acb8 	.word	0x0000acb8
    5fa8:	1fff0200 	.word	0x1fff0200
    5fac:	1fff07e1 	.word	0x1fff07e1
    5fb0:	1fff0789 	.word	0x1fff0789
    5fb4:	1fff07b5 	.word	0x1fff07b5
    5fb8:	1fff075d 	.word	0x1fff075d
    5fbc:	1fff0731 	.word	0x1fff0731
    5fc0:	1fff0ab8 	.word	0x1fff0ab8
    5fc4:	1fff0970 	.word	0x1fff0970
    5fc8:	1fff09e8 	.word	0x1fff09e8
    5fcc:	1fff0a48 	.word	0x1fff0a48
    5fd0:	1fff0a78 	.word	0x1fff0a78

00005fd4 <rtc_set>:
{
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
    5fd4:	b430      	push	{r4, r5}
	RTC_SR = 0;
    5fd6:	4b05      	ldr	r3, [pc, #20]	; (5fec <rtc_set+0x18>)
	RTC_TPR = 0;
    5fd8:	4d05      	ldr	r5, [pc, #20]	; (5ff0 <rtc_set+0x1c>)
	RTC_TSR = t;
    5fda:	4c06      	ldr	r4, [pc, #24]	; (5ff4 <rtc_set+0x20>)
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    5fdc:	2200      	movs	r2, #0
	RTC_TPR = 0;
	RTC_TSR = t;
	RTC_SR = RTC_SR_TCE;
    5fde:	2110      	movs	r1, #16
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    5fe0:	601a      	str	r2, [r3, #0]
	RTC_TPR = 0;
    5fe2:	602a      	str	r2, [r5, #0]
	RTC_TSR = t;
    5fe4:	6020      	str	r0, [r4, #0]
	RTC_SR = RTC_SR_TCE;
    5fe6:	6019      	str	r1, [r3, #0]
}
    5fe8:	bc30      	pop	{r4, r5}
    5fea:	4770      	bx	lr
    5fec:	4003d014 	.word	0x4003d014
    5ff0:	4003d004 	.word	0x4003d004
    5ff4:	4003d000 	.word	0x4003d000

00005ff8 <analogWrite>:
// FTM is clocked by the bus clock, either 24 or 48 MHz
// input capture can be FTM1_CH0, CMP0 or CMP1 or USB start of frame
// 24 MHz with reload 49152 to match Arduino's speed = 488.28125 Hz

void analogWrite(uint8_t pin, int val)
{
    5ff8:	b538      	push	{r3, r4, r5, lr}
		}
		analogWriteDAC0(val);
		return;
	}
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (pin == A21 || pin == A22) {
    5ffa:	f1a0 0342 	sub.w	r3, r0, #66	; 0x42
    5ffe:	2b01      	cmp	r3, #1
// FTM is clocked by the bus clock, either 24 or 48 MHz
// input capture can be FTM1_CH0, CMP0 or CMP1 or USB start of frame
// 24 MHz with reload 49152 to match Arduino's speed = 488.28125 Hz

void analogWrite(uint8_t pin, int val)
{
    6000:	4604      	mov	r4, r0
		}
		analogWriteDAC0(val);
		return;
	}
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (pin == A21 || pin == A22) {
    6002:	d924      	bls.n	604e <analogWrite+0x56>
		return;
	}
#endif

	max = 1 << analog_write_res;
	if (val <= 0) {
    6004:	2900      	cmp	r1, #0
    6006:	dd7a      	ble.n	60fe <analogWrite+0x106>
		else analogWriteDAC1(val);
		return;
	}
#endif

	max = 1 << analog_write_res;
    6008:	4b99      	ldr	r3, [pc, #612]	; (6270 <analogWrite+0x278>)
    600a:	781b      	ldrb	r3, [r3, #0]
	if (val <= 0) {
		digitalWrite(pin, LOW);
		pinMode(pin, OUTPUT);	// TODO: implement OUTPUT_LOW
		return;
	} else if (val >= max) {
    600c:	2501      	movs	r5, #1
    600e:	fa05 f203 	lsl.w	r2, r5, r3
    6012:	428a      	cmp	r2, r1
    6014:	d802      	bhi.n	601c <analogWrite+0x24>

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    6016:	283f      	cmp	r0, #63	; 0x3f
    6018:	d92c      	bls.n	6074 <analogWrite+0x7c>
    601a:	bd38      	pop	{r3, r4, r5, pc}
	//serial_phex32(val);
	//serial_print("\n");
	//serial_print("analog_write_res = ");
	//serial_phex(analog_write_res);
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
    601c:	1ec2      	subs	r2, r0, #3
    601e:	2a01      	cmp	r2, #1
    6020:	d930      	bls.n	6084 <analogWrite+0x8c>
		cval = ((uint32_t)val * (uint32_t)(FTM1_MOD + 1)) >> analog_write_res;
#if defined(FTM2_CH0_PIN)
	} else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
    6022:	f1a0 021d 	sub.w	r2, r0, #29
    6026:	2a01      	cmp	r2, #1
    6028:	d978      	bls.n	611c <analogWrite+0x124>
		cval = ((uint32_t)val * (uint32_t)(FTM2_MOD + 1)) >> analog_write_res;
#endif
#if defined(FTM3_CH0_PIN)
	} else if (pin == FTM3_CH0_PIN || pin == FTM3_CH1_PIN || pin == FTM3_CH2_PIN
    602a:	280e      	cmp	r0, #14
    602c:	d95b      	bls.n	60e6 <analogWrite+0xee>
	  || pin == FTM3_CH3_PIN || pin == FTM3_CH4_PIN || pin == FTM3_CH5_PIN
    602e:	f1a4 0223 	sub.w	r2, r4, #35	; 0x23
    6032:	2a03      	cmp	r2, #3
    6034:	d95c      	bls.n	60f0 <analogWrite+0xf8>
	  || pin == FTM3_CH6_PIN || pin == FTM3_CH7_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM3_MOD + 1)) >> analog_write_res;
#endif
#if defined(TPM1_CH0_PIN)
	} else if (pin == TPM1_CH0_PIN || pin == TPM1_CH1_PIN) {
    6036:	f1a4 0210 	sub.w	r2, r4, #16
    603a:	2a01      	cmp	r2, #1
		cval = ((uint32_t)val * (uint32_t)(TPM1_MOD + 1)) >> analog_write_res;
    603c:	bf94      	ite	ls
    603e:	4a8d      	ldrls	r2, [pc, #564]	; (6274 <analogWrite+0x27c>)
#endif
	} else {
		cval = ((uint32_t)val * (uint32_t)(FTM0_MOD + 1)) >> analog_write_res;
    6040:	4a8d      	ldrhi	r2, [pc, #564]	; (6278 <analogWrite+0x280>)
    6042:	6812      	ldr	r2, [r2, #0]
    6044:	fb02 1201 	mla	r2, r2, r1, r1
    6048:	fa22 f303 	lsr.w	r3, r2, r3
    604c:	e020      	b.n	6090 <analogWrite+0x98>
		analogWriteDAC0(val);
		return;
	}
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (pin == A21 || pin == A22) {
		uint8_t res = analog_write_res;
    604e:	4b88      	ldr	r3, [pc, #544]	; (6270 <analogWrite+0x278>)
    6050:	781b      	ldrb	r3, [r3, #0]
		if (res < 12) {
    6052:	2b0b      	cmp	r3, #11
    6054:	d90a      	bls.n	606c <analogWrite+0x74>
			val <<= 12 - res;
		} else if (res > 12) {
    6056:	2b0c      	cmp	r3, #12
			val >>= res - 12;
    6058:	bf1c      	itt	ne
    605a:	3b0c      	subne	r3, #12
    605c:	4119      	asrne	r1, r3
		}
		if (pin == A21) analogWriteDAC0(val);
    605e:	2c42      	cmp	r4, #66	; 0x42
    6060:	4608      	mov	r0, r1
    6062:	d057      	beq.n	6114 <analogWrite+0x11c>
#endif
	  default:
		digitalWrite(pin, (val > 127) ? HIGH : LOW);
		pinMode(pin, OUTPUT);
	}
}
    6064:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			val <<= 12 - res;
		} else if (res > 12) {
			val >>= res - 12;
		}
		if (pin == A21) analogWriteDAC0(val);
		else analogWriteDAC1(val);
    6068:	f001 bb52 	b.w	7710 <analogWriteDAC1>
	}
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (pin == A21 || pin == A22) {
		uint8_t res = analog_write_res;
		if (res < 12) {
			val <<= 12 - res;
    606c:	f1c3 030c 	rsb	r3, r3, #12
    6070:	4099      	lsls	r1, r3
    6072:	e7f4      	b.n	605e <analogWrite+0x66>
    6074:	4629      	mov	r1, r5
    6076:	f7ff fecf 	bl	5e18 <digitalWrite.part.1>
    607a:	4629      	mov	r1, r5
#endif
	  default:
		digitalWrite(pin, (val > 127) ? HIGH : LOW);
		pinMode(pin, OUTPUT);
	}
}
    607c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    6080:	f7ff bef0 	b.w	5e64 <pinMode.part.2>
	//serial_print("\n");
	//serial_print("analog_write_res = ");
	//serial_phex(analog_write_res);
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM1_MOD + 1)) >> analog_write_res;
    6084:	4a7d      	ldr	r2, [pc, #500]	; (627c <analogWrite+0x284>)
    6086:	6812      	ldr	r2, [r2, #0]
    6088:	fb02 1201 	mla	r2, r2, r1, r1
    608c:	fa22 f303 	lsr.w	r3, r2, r3
		cval = ((uint32_t)val * (uint32_t)(FTM0_MOD + 1)) >> analog_write_res;
	}
	//serial_print("cval = ");
	//serial_phex32(cval);
	//serial_print("\n");
	switch (pin) {
    6090:	1ea2      	subs	r2, r4, #2
    6092:	2a24      	cmp	r2, #36	; 0x24
    6094:	f200 80e3 	bhi.w	625e <analogWrite+0x266>
    6098:	e8df f012 	tbh	[pc, r2, lsl #1]
    609c:	00d300da 	.word	0x00d300da
    60a0:	00c500cc 	.word	0x00c500cc
    60a4:	00b700be 	.word	0x00b700be
    60a8:	00a900b0 	.word	0x00a900b0
    60ac:	00e100a2 	.word	0x00e100a2
    60b0:	00e100e1 	.word	0x00e100e1
    60b4:	00e1009b 	.word	0x00e1009b
    60b8:	008d0094 	.word	0x008d0094
    60bc:	00e100e1 	.word	0x00e100e1
    60c0:	007f0086 	.word	0x007f0086
    60c4:	00710078 	.word	0x00710078
    60c8:	00e100e1 	.word	0x00e100e1
    60cc:	00e100e1 	.word	0x00e100e1
    60d0:	006a00e1 	.word	0x006a00e1
    60d4:	00e10063 	.word	0x00e10063
    60d8:	00e100e1 	.word	0x00e100e1
    60dc:	005c00e1 	.word	0x005c00e1
    60e0:	004e0055 	.word	0x004e0055
    60e4:	0047      	.short	0x0047
#if defined(FTM2_CH0_PIN)
	} else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM2_MOD + 1)) >> analog_write_res;
#endif
#if defined(FTM3_CH0_PIN)
	} else if (pin == FTM3_CH0_PIN || pin == FTM3_CH1_PIN || pin == FTM3_CH2_PIN
    60e6:	f244 1284 	movw	r2, #16772	; 0x4184
    60ea:	40c2      	lsrs	r2, r0
    60ec:	07d2      	lsls	r2, r2, #31
    60ee:	d59e      	bpl.n	602e <analogWrite+0x36>
	  || pin == FTM3_CH3_PIN || pin == FTM3_CH4_PIN || pin == FTM3_CH5_PIN
	  || pin == FTM3_CH6_PIN || pin == FTM3_CH7_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM3_MOD + 1)) >> analog_write_res;
    60f0:	4a63      	ldr	r2, [pc, #396]	; (6280 <analogWrite+0x288>)
    60f2:	6812      	ldr	r2, [r2, #0]
    60f4:	fb02 1201 	mla	r2, r2, r1, r1
    60f8:	fa22 f303 	lsr.w	r3, r2, r3
    60fc:	e7c8      	b.n	6090 <analogWrite+0x98>

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    60fe:	283f      	cmp	r0, #63	; 0x3f
    6100:	d88b      	bhi.n	601a <analogWrite+0x22>
    6102:	2100      	movs	r1, #0
    6104:	f7ff fe88 	bl	5e18 <digitalWrite.part.1>
    6108:	4620      	mov	r0, r4
    610a:	2101      	movs	r1, #1
#endif
	  default:
		digitalWrite(pin, (val > 127) ? HIGH : LOW);
		pinMode(pin, OUTPUT);
	}
}
    610c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    6110:	f7ff bea8 	b.w	5e64 <pinMode.part.2>
    6114:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		if (res < 12) {
			val <<= 12 - res;
		} else if (res > 12) {
			val >>= res - 12;
		}
		if (pin == A21) analogWriteDAC0(val);
    6118:	f001 badc 	b.w	76d4 <analogWriteDAC0>
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM1_MOD + 1)) >> analog_write_res;
#if defined(FTM2_CH0_PIN)
	} else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM2_MOD + 1)) >> analog_write_res;
    611c:	4a59      	ldr	r2, [pc, #356]	; (6284 <analogWrite+0x28c>)
    611e:	6812      	ldr	r2, [r2, #0]
    6120:	fb02 1201 	mla	r2, r2, r1, r1
    6124:	fa22 f303 	lsr.w	r3, r2, r3
    6128:	e7b2      	b.n	6090 <analogWrite+0x98>
		FTM_PINCFG(FTM3_CH6_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH7_PIN
	  case FTM3_CH7_PIN:
		FTM3_C7V = cval;
    612a:	4957      	ldr	r1, [pc, #348]	; (6288 <analogWrite+0x290>)
		FTM_PINCFG(FTM3_CH7_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    612c:	4a57      	ldr	r2, [pc, #348]	; (628c <analogWrite+0x294>)
		FTM_PINCFG(FTM3_CH6_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH7_PIN
	  case FTM3_CH7_PIN:
		FTM3_C7V = cval;
    612e:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH7_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6130:	f44f 7351 	mov.w	r3, #836	; 0x344
    6134:	6013      	str	r3, [r2, #0]
		break;
    6136:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH5_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH6_PIN
	  case FTM3_CH6_PIN:
		FTM3_C6V = cval;
    6138:	4955      	ldr	r1, [pc, #340]	; (6290 <analogWrite+0x298>)
		FTM_PINCFG(FTM3_CH6_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    613a:	4a56      	ldr	r2, [pc, #344]	; (6294 <analogWrite+0x29c>)
		FTM_PINCFG(FTM3_CH5_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH6_PIN
	  case FTM3_CH6_PIN:
		FTM3_C6V = cval;
    613c:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH6_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    613e:	f44f 7351 	mov.w	r3, #836	; 0x344
    6142:	6013      	str	r3, [r2, #0]
		break;
    6144:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH4_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH5_PIN
	  case FTM3_CH5_PIN:
		FTM3_C5V = cval;
    6146:	4954      	ldr	r1, [pc, #336]	; (6298 <analogWrite+0x2a0>)
		FTM_PINCFG(FTM3_CH5_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6148:	4a54      	ldr	r2, [pc, #336]	; (629c <analogWrite+0x2a4>)
		FTM_PINCFG(FTM3_CH4_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH5_PIN
	  case FTM3_CH5_PIN:
		FTM3_C5V = cval;
    614a:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH5_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    614c:	f44f 7351 	mov.w	r3, #836	; 0x344
    6150:	6013      	str	r3, [r2, #0]
		break;
    6152:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH4_PIN
	  case FTM3_CH4_PIN:
		FTM3_C4V = cval;
    6154:	4952      	ldr	r1, [pc, #328]	; (62a0 <analogWrite+0x2a8>)
		FTM_PINCFG(FTM3_CH4_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6156:	4a53      	ldr	r2, [pc, #332]	; (62a4 <analogWrite+0x2ac>)
		FTM_PINCFG(FTM3_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH4_PIN
	  case FTM3_CH4_PIN:
		FTM3_C4V = cval;
    6158:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH4_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    615a:	f44f 7351 	mov.w	r3, #836	; 0x344
    615e:	6013      	str	r3, [r2, #0]
		break;
    6160:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH1_PIN
	  case FTM2_CH1_PIN: // PTB19, FTM1_CH1
		FTM2_C1V = cval;
    6162:	4951      	ldr	r1, [pc, #324]	; (62a8 <analogWrite+0x2b0>)
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6164:	4a51      	ldr	r2, [pc, #324]	; (62ac <analogWrite+0x2b4>)
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH1_PIN
	  case FTM2_CH1_PIN: // PTB19, FTM1_CH1
		FTM2_C1V = cval;
    6166:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6168:	f44f 7351 	mov.w	r3, #836	; 0x344
    616c:	6013      	str	r3, [r2, #0]
		break;
    616e:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH0_PIN
	  case FTM2_CH0_PIN: // PTB18, FTM2_CH0
		FTM2_C0V = cval;
    6170:	494f      	ldr	r1, [pc, #316]	; (62b0 <analogWrite+0x2b8>)
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6172:	4a50      	ldr	r2, [pc, #320]	; (62b4 <analogWrite+0x2bc>)
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH0_PIN
	  case FTM2_CH0_PIN: // PTB18, FTM2_CH0
		FTM2_C0V = cval;
    6174:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6176:	f44f 7351 	mov.w	r3, #836	; 0x344
    617a:	6013      	str	r3, [r2, #0]
		break;
    617c:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH1_PIN
	  case FTM0_CH1_PIN: // PTC2, FTM0_CH1
		FTM0_C1V = cval;
    617e:	494e      	ldr	r1, [pc, #312]	; (62b8 <analogWrite+0x2c0>)
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6180:	4a4e      	ldr	r2, [pc, #312]	; (62bc <analogWrite+0x2c4>)
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH1_PIN
	  case FTM0_CH1_PIN: // PTC2, FTM0_CH1
		FTM0_C1V = cval;
    6182:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6184:	f240 4344 	movw	r3, #1092	; 0x444
    6188:	6013      	str	r3, [r2, #0]
		break;
    618a:	bd38      	pop	{r3, r4, r5, pc}
	//serial_phex32(cval);
	//serial_print("\n");
	switch (pin) {
#ifdef FTM0_CH0_PIN
	  case FTM0_CH0_PIN: // PTC1, FTM0_CH0
		FTM0_C0V = cval;
    618c:	494c      	ldr	r1, [pc, #304]	; (62c0 <analogWrite+0x2c8>)
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    618e:	4a4d      	ldr	r2, [pc, #308]	; (62c4 <analogWrite+0x2cc>)
	//serial_phex32(cval);
	//serial_print("\n");
	switch (pin) {
#ifdef FTM0_CH0_PIN
	  case FTM0_CH0_PIN: // PTC1, FTM0_CH0
		FTM0_C0V = cval;
    6190:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6192:	f240 4344 	movw	r3, #1092	; 0x444
    6196:	6013      	str	r3, [r2, #0]
		break;
    6198:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH6_PIN
	  case FTM0_CH6_PIN: // PTD6, FTM0_CH6
		FTM0_C6V = cval;
    619a:	494b      	ldr	r1, [pc, #300]	; (62c8 <analogWrite+0x2d0>)
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    619c:	4a4b      	ldr	r2, [pc, #300]	; (62cc <analogWrite+0x2d4>)
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH6_PIN
	  case FTM0_CH6_PIN: // PTD6, FTM0_CH6
		FTM0_C6V = cval;
    619e:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    61a0:	f240 4344 	movw	r3, #1092	; 0x444
    61a4:	6013      	str	r3, [r2, #0]
		break;
    61a6:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH5_PIN
	  case FTM0_CH5_PIN: // PTD5, FTM0_CH5
		FTM0_C5V = cval;
    61a8:	4949      	ldr	r1, [pc, #292]	; (62d0 <analogWrite+0x2d8>)
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    61aa:	4a4a      	ldr	r2, [pc, #296]	; (62d4 <analogWrite+0x2dc>)
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH5_PIN
	  case FTM0_CH5_PIN: // PTD5, FTM0_CH5
		FTM0_C5V = cval;
    61ac:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    61ae:	f240 4344 	movw	r3, #1092	; 0x444
    61b2:	6013      	str	r3, [r2, #0]
		break;
    61b4:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(TPM1_CH0_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef TPM1_CH1_PIN
	  case TPM1_CH1_PIN:
		TPM1_C1V = cval;
    61b6:	4948      	ldr	r1, [pc, #288]	; (62d8 <analogWrite+0x2e0>)
		FTM_PINCFG(TPM1_CH1_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
    61b8:	4a48      	ldr	r2, [pc, #288]	; (62dc <analogWrite+0x2e4>)
		FTM_PINCFG(TPM1_CH0_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef TPM1_CH1_PIN
	  case TPM1_CH1_PIN:
		TPM1_C1V = cval;
    61ba:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(TPM1_CH1_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
    61bc:	f240 6344 	movw	r3, #1604	; 0x644
    61c0:	6013      	str	r3, [r2, #0]
		break;
    61c2:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH7_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef TPM1_CH0_PIN
	  case TPM1_CH0_PIN:
		TPM1_C0V = cval;
    61c4:	4946      	ldr	r1, [pc, #280]	; (62e0 <analogWrite+0x2e8>)
		FTM_PINCFG(TPM1_CH0_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
    61c6:	4a47      	ldr	r2, [pc, #284]	; (62e4 <analogWrite+0x2ec>)
		FTM_PINCFG(FTM3_CH7_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef TPM1_CH0_PIN
	  case TPM1_CH0_PIN:
		TPM1_C0V = cval;
    61c8:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(TPM1_CH0_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
    61ca:	f240 6344 	movw	r3, #1604	; 0x644
    61ce:	6013      	str	r3, [r2, #0]
		break;
    61d0:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH1_PIN
	  case FTM3_CH1_PIN:
		FTM3_C1V = cval;
    61d2:	4945      	ldr	r1, [pc, #276]	; (62e8 <analogWrite+0x2f0>)
		FTM_PINCFG(FTM3_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    61d4:	4a45      	ldr	r2, [pc, #276]	; (62ec <analogWrite+0x2f4>)
		FTM_PINCFG(FTM3_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH1_PIN
	  case FTM3_CH1_PIN:
		FTM3_C1V = cval;
    61d6:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    61d8:	f240 4344 	movw	r3, #1092	; 0x444
    61dc:	6013      	str	r3, [r2, #0]
		break;
    61de:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH3_PIN
	  case FTM0_CH3_PIN: // PTC4, FTM0_CH3
		FTM0_C3V = cval;
    61e0:	4943      	ldr	r1, [pc, #268]	; (62f0 <analogWrite+0x2f8>)
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    61e2:	4a44      	ldr	r2, [pc, #272]	; (62f4 <analogWrite+0x2fc>)
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH3_PIN
	  case FTM0_CH3_PIN: // PTC4, FTM0_CH3
		FTM0_C3V = cval;
    61e4:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    61e6:	f240 4344 	movw	r3, #1092	; 0x444
    61ea:	6013      	str	r3, [r2, #0]
		break;
    61ec:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH2_PIN
	  case FTM0_CH2_PIN: // PTC3, FTM0_CH2
		FTM0_C2V = cval;
    61ee:	4942      	ldr	r1, [pc, #264]	; (62f8 <analogWrite+0x300>)
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    61f0:	4a42      	ldr	r2, [pc, #264]	; (62fc <analogWrite+0x304>)
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH2_PIN
	  case FTM0_CH2_PIN: // PTC3, FTM0_CH2
		FTM0_C2V = cval;
    61f2:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    61f4:	f240 4344 	movw	r3, #1092	; 0x444
    61f8:	6013      	str	r3, [r2, #0]
		break;
    61fa:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH3_PIN
	  case FTM3_CH3_PIN:
		FTM3_C3V = cval;
    61fc:	4940      	ldr	r1, [pc, #256]	; (6300 <analogWrite+0x308>)
		FTM_PINCFG(FTM3_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    61fe:	4a41      	ldr	r2, [pc, #260]	; (6304 <analogWrite+0x30c>)
		FTM_PINCFG(FTM3_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH3_PIN
	  case FTM3_CH3_PIN:
		FTM3_C3V = cval;
    6200:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6202:	f240 4344 	movw	r3, #1092	; 0x444
    6206:	6013      	str	r3, [r2, #0]
		break;
    6208:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH2_PIN
	  case FTM3_CH2_PIN:
		FTM3_C2V = cval;
    620a:	493f      	ldr	r1, [pc, #252]	; (6308 <analogWrite+0x310>)
		FTM_PINCFG(FTM3_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    620c:	4a3f      	ldr	r2, [pc, #252]	; (630c <analogWrite+0x314>)
		FTM_PINCFG(FTM3_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH2_PIN
	  case FTM3_CH2_PIN:
		FTM3_C2V = cval;
    620e:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6210:	f240 4344 	movw	r3, #1092	; 0x444
    6214:	6013      	str	r3, [r2, #0]
		break;
    6216:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH4_PIN
	  case FTM0_CH4_PIN: // PTD4, FTM0_CH4
		FTM0_C4V = cval;
    6218:	493d      	ldr	r1, [pc, #244]	; (6310 <analogWrite+0x318>)
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    621a:	4a3e      	ldr	r2, [pc, #248]	; (6314 <analogWrite+0x31c>)
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH4_PIN
	  case FTM0_CH4_PIN: // PTD4, FTM0_CH4
		FTM0_C4V = cval;
    621c:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    621e:	f240 4344 	movw	r3, #1092	; 0x444
    6222:	6013      	str	r3, [r2, #0]
		break;
    6224:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH7_PIN
	  case FTM0_CH7_PIN: // PTD7, FTM0_CH7
		FTM0_C7V = cval;
    6226:	493c      	ldr	r1, [pc, #240]	; (6318 <analogWrite+0x320>)
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6228:	4a3c      	ldr	r2, [pc, #240]	; (631c <analogWrite+0x324>)
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH7_PIN
	  case FTM0_CH7_PIN: // PTD7, FTM0_CH7
		FTM0_C7V = cval;
    622a:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    622c:	f240 4344 	movw	r3, #1092	; 0x444
    6230:	6013      	str	r3, [r2, #0]
		break;
    6232:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH1_PIN
	  case FTM1_CH1_PIN: // PTA13, FTM1_CH1
		FTM1_C1V = cval;
    6234:	493a      	ldr	r1, [pc, #232]	; (6320 <analogWrite+0x328>)
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6236:	4a3b      	ldr	r2, [pc, #236]	; (6324 <analogWrite+0x32c>)
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH1_PIN
	  case FTM1_CH1_PIN: // PTA13, FTM1_CH1
		FTM1_C1V = cval;
    6238:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    623a:	f44f 7351 	mov.w	r3, #836	; 0x344
    623e:	6013      	str	r3, [r2, #0]
		break;
    6240:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH0_PIN
	  case FTM1_CH0_PIN: // PTA12, FTM1_CH0
		FTM1_C0V = cval;
    6242:	4939      	ldr	r1, [pc, #228]	; (6328 <analogWrite+0x330>)
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6244:	4a39      	ldr	r2, [pc, #228]	; (632c <analogWrite+0x334>)
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH0_PIN
	  case FTM1_CH0_PIN: // PTA12, FTM1_CH0
		FTM1_C0V = cval;
    6246:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6248:	f44f 7351 	mov.w	r3, #836	; 0x344
    624c:	6013      	str	r3, [r2, #0]
		break;
    624e:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH0_PIN
	  case FTM3_CH0_PIN:
		FTM3_C0V = cval;
    6250:	4937      	ldr	r1, [pc, #220]	; (6330 <analogWrite+0x338>)
		FTM_PINCFG(FTM3_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6252:	4a38      	ldr	r2, [pc, #224]	; (6334 <analogWrite+0x33c>)
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH0_PIN
	  case FTM3_CH0_PIN:
		FTM3_C0V = cval;
    6254:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6256:	f240 4344 	movw	r3, #1092	; 0x444
    625a:	6013      	str	r3, [r2, #0]
		break;
    625c:	bd38      	pop	{r3, r4, r5, pc}

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    625e:	2c3f      	cmp	r4, #63	; 0x3f
    6260:	f63f aedb 	bhi.w	601a <analogWrite+0x22>
    6264:	297f      	cmp	r1, #127	; 0x7f
    6266:	bfd4      	ite	le
    6268:	2100      	movle	r1, #0
    626a:	2101      	movgt	r1, #1
    626c:	4620      	mov	r0, r4
    626e:	e749      	b.n	6104 <analogWrite+0x10c>
    6270:	1fff0b24 	.word	0x1fff0b24
    6274:	400c9008 	.word	0x400c9008
    6278:	40038008 	.word	0x40038008
    627c:	40039008 	.word	0x40039008
    6280:	400b9008 	.word	0x400b9008
    6284:	400b8008 	.word	0x400b8008
    6288:	400b9048 	.word	0x400b9048
    628c:	4004b02c 	.word	0x4004b02c
    6290:	400b9040 	.word	0x400b9040
    6294:	4004b028 	.word	0x4004b028
    6298:	400b9038 	.word	0x400b9038
    629c:	4004b024 	.word	0x4004b024
    62a0:	400b9030 	.word	0x400b9030
    62a4:	4004b020 	.word	0x4004b020
    62a8:	400b8018 	.word	0x400b8018
    62ac:	4004a04c 	.word	0x4004a04c
    62b0:	400b8010 	.word	0x400b8010
    62b4:	4004a048 	.word	0x4004a048
    62b8:	40038018 	.word	0x40038018
    62bc:	4004b008 	.word	0x4004b008
    62c0:	40038010 	.word	0x40038010
    62c4:	4004b004 	.word	0x4004b004
    62c8:	40038040 	.word	0x40038040
    62cc:	4004c018 	.word	0x4004c018
    62d0:	40038038 	.word	0x40038038
    62d4:	4004c014 	.word	0x4004c014
    62d8:	400c9018 	.word	0x400c9018
    62dc:	4004a004 	.word	0x4004a004
    62e0:	400c9010 	.word	0x400c9010
    62e4:	4004a000 	.word	0x4004a000
    62e8:	400b9018 	.word	0x400b9018
    62ec:	4004c004 	.word	0x4004c004
    62f0:	40038028 	.word	0x40038028
    62f4:	4004b010 	.word	0x4004b010
    62f8:	40038020 	.word	0x40038020
    62fc:	4004b00c 	.word	0x4004b00c
    6300:	400b9028 	.word	0x400b9028
    6304:	4004c00c 	.word	0x4004c00c
    6308:	400b9020 	.word	0x400b9020
    630c:	4004c008 	.word	0x4004c008
    6310:	40038030 	.word	0x40038030
    6314:	4004c010 	.word	0x4004c010
    6318:	40038048 	.word	0x40038048
    631c:	4004c01c 	.word	0x4004c01c
    6320:	40039018 	.word	0x40039018
    6324:	40049034 	.word	0x40049034
    6328:	40039010 	.word	0x40039010
    632c:	40049030 	.word	0x40049030
    6330:	400b9010 	.word	0x400b9010
    6334:	4004c000 	.word	0x4004c000

00006338 <digitalWrite>:
    6338:	283f      	cmp	r0, #63	; 0x3f
    633a:	d801      	bhi.n	6340 <digitalWrite+0x8>
    633c:	f7ff bd6c 	b.w	5e18 <digitalWrite.part.1>
    6340:	4770      	bx	lr
    6342:	bf00      	nop

00006344 <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    6344:	283f      	cmp	r0, #63	; 0x3f
    6346:	d801      	bhi.n	634c <pinMode+0x8>
    6348:	f7ff bd8c 	b.w	5e64 <pinMode.part.2>
    634c:	4770      	bx	lr
    634e:	bf00      	nop

00006350 <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    6350:	b672      	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    6352:	490d      	ldr	r1, [pc, #52]	; (6388 <micros+0x38>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    6354:	4b0d      	ldr	r3, [pc, #52]	; (638c <micros+0x3c>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    6356:	4a0e      	ldr	r2, [pc, #56]	; (6390 <micros+0x40>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    6358:	681b      	ldr	r3, [r3, #0]
	count = systick_millis_count;
    635a:	6808      	ldr	r0, [r1, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    635c:	6812      	ldr	r2, [r2, #0]
	__enable_irq();
    635e:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    6360:	0152      	lsls	r2, r2, #5
    6362:	d502      	bpl.n	636a <micros+0x1a>
    6364:	2b32      	cmp	r3, #50	; 0x32
    6366:	bf88      	it	hi
    6368:	3001      	addhi	r0, #1
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    636a:	f5c3 332f 	rsb	r3, r3, #179200	; 0x2bc00
    636e:	4909      	ldr	r1, [pc, #36]	; (6394 <micros+0x44>)
    6370:	f203 331f 	addw	r3, r3, #799	; 0x31f
    6374:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    6378:	089b      	lsrs	r3, r3, #2
    637a:	fba1 1303 	umull	r1, r3, r1, r3
    637e:	fb02 f000 	mul.w	r0, r2, r0
}
    6382:	eb00 0093 	add.w	r0, r0, r3, lsr #2
    6386:	4770      	bx	lr
    6388:	1fff2b4c 	.word	0x1fff2b4c
    638c:	e000e018 	.word	0xe000e018
    6390:	e000ed04 	.word	0xe000ed04
    6394:	16c16c17 	.word	0x16c16c17

00006398 <delay>:

void delay(uint32_t ms)
{
    6398:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    639c:	4605      	mov	r5, r0

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    639e:	b672      	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    63a0:	4f22      	ldr	r7, [pc, #136]	; (642c <delay+0x94>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    63a2:	4b23      	ldr	r3, [pc, #140]	; (6430 <delay+0x98>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    63a4:	4a23      	ldr	r2, [pc, #140]	; (6434 <delay+0x9c>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    63a6:	681b      	ldr	r3, [r3, #0]
	count = systick_millis_count;
    63a8:	683c      	ldr	r4, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    63aa:	6812      	ldr	r2, [r2, #0]
	__enable_irq();
    63ac:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    63ae:	0152      	lsls	r2, r2, #5
    63b0:	d502      	bpl.n	63b8 <delay+0x20>
    63b2:	2b32      	cmp	r3, #50	; 0x32
    63b4:	bf88      	it	hi
    63b6:	3401      	addhi	r4, #1

void delay(uint32_t ms)
{
	uint32_t start = micros();

	if (ms > 0) {
    63b8:	b3b5      	cbz	r5, 6428 <delay+0x90>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    63ba:	f5c3 332f 	rsb	r3, r3, #179200	; 0x2bc00
    63be:	f203 331f 	addw	r3, r3, #799	; 0x31f
    63c2:	4e1d      	ldr	r6, [pc, #116]	; (6438 <delay+0xa0>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    63c4:	f8df 9068 	ldr.w	r9, [pc, #104]	; 6430 <delay+0x98>
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    63c8:	f8df 8068 	ldr.w	r8, [pc, #104]	; 6434 <delay+0x9c>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    63cc:	089b      	lsrs	r3, r3, #2
    63ce:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    63d2:	fba6 1303 	umull	r1, r3, r6, r3
    63d6:	fb02 f404 	mul.w	r4, r2, r4
    63da:	eb04 0493 	add.w	r4, r4, r3, lsr #2

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    63de:	b672      	cpsid	i
	current = SYST_CVR;
    63e0:	f8d9 1000 	ldr.w	r1, [r9]
	count = systick_millis_count;
    63e4:	683a      	ldr	r2, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    63e6:	f8d8 e000 	ldr.w	lr, [r8]
	__enable_irq();
    63ea:	b662      	cpsie	i
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    63ec:	f5c1 332f 	rsb	r3, r1, #179200	; 0x2bc00
    63f0:	f203 331f 	addw	r3, r3, #799	; 0x31f
    63f4:	089b      	lsrs	r3, r3, #2
    63f6:	fba6 0303 	umull	r0, r3, r6, r3
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    63fa:	f01e 6f80 	tst.w	lr, #67108864	; 0x4000000
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    63fe:	ebc4 0393 	rsb	r3, r4, r3, lsr #2
    6402:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    6406:	d002      	beq.n	640e <delay+0x76>
    6408:	2932      	cmp	r1, #50	; 0x32
    640a:	bf88      	it	hi
    640c:	3201      	addhi	r2, #1
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    640e:	fb00 3302 	mla	r3, r0, r2, r3
    6412:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    6416:	d304      	bcc.n	6422 <delay+0x8a>
				ms--;
				if (ms == 0) return;
    6418:	3d01      	subs	r5, #1
    641a:	d005      	beq.n	6428 <delay+0x90>
				start += 1000;
    641c:	f504 747a 	add.w	r4, r4, #1000	; 0x3e8
    6420:	e7dd      	b.n	63de <delay+0x46>
			}
			yield();
    6422:	f001 f871 	bl	7508 <yield>
		}
    6426:	e7da      	b.n	63de <delay+0x46>
    6428:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    642c:	1fff2b4c 	.word	0x1fff2b4c
    6430:	e000e018 	.word	0xe000e018
    6434:	e000ed04 	.word	0xe000ed04
    6438:	16c16c17 	.word	0x16c16c17

0000643c <_init_Teensyduino_internal_>:
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
    643c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    643e:	4b4e      	ldr	r3, [pc, #312]	; (6578 <_init_Teensyduino_internal_+0x13c>)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    6440:	484e      	ldr	r0, [pc, #312]	; (657c <_init_Teensyduino_internal_+0x140>)
	FTM0_MOD = DEFAULT_FTM_MOD;
    6442:	f8df c15c 	ldr.w	ip, [pc, #348]	; 65a0 <_init_Teensyduino_internal_+0x164>
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
    6446:	4c4e      	ldr	r4, [pc, #312]	; (6580 <_init_Teensyduino_internal_+0x144>)
	FTM0_C2SC = 0x28;
    6448:	494e      	ldr	r1, [pc, #312]	; (6584 <_init_Teensyduino_internal_+0x148>)
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    644a:	f8df e158 	ldr.w	lr, [pc, #344]	; 65a4 <_init_Teensyduino_internal_+0x168>
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
    644e:	4e4e      	ldr	r6, [pc, #312]	; (6588 <_init_Teensyduino_internal_+0x14c>)
	FTM0_C4SC = 0x28;
    6450:	4d4e      	ldr	r5, [pc, #312]	; (658c <_init_Teensyduino_internal_+0x150>)
	FTM0_C5SC = 0x28;
    6452:	4f4f      	ldr	r7, [pc, #316]	; (6590 <_init_Teensyduino_internal_+0x154>)
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    6454:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    6458:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    645a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    645e:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    6460:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
    6464:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    6466:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    646a:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    646c:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    6470:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    6472:	2200      	movs	r2, #0
    6474:	6002      	str	r2, [r0, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    6476:	2328      	movs	r3, #40	; 0x28
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
    6478:	f64e 70ff 	movw	r0, #61439	; 0xefff
    647c:	f8cc 0000 	str.w	r0, [ip]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    6480:	f8ce 3000 	str.w	r3, [lr]
	FTM0_C1SC = 0x28;
    6484:	6023      	str	r3, [r4, #0]
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    6486:	f50e 2e01 	add.w	lr, lr, #528384	; 0x81000
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
    648a:	600b      	str	r3, [r1, #0]
	FTM0_C3SC = 0x28;
    648c:	6033      	str	r3, [r6, #0]
	FTM0_C4SC = 0x28;
    648e:	602b      	str	r3, [r5, #0]
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    6490:	f506 2600 	add.w	r6, r6, #524288	; 0x80000
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
    6494:	603b      	str	r3, [r7, #0]
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
    6496:	f505 2500 	add.w	r5, r5, #524288	; 0x80000
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
    649a:	62a3      	str	r3, [r4, #40]	; 0x28
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
    649c:	f507 2700 	add.w	r7, r7, #524288	; 0x80000
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
    64a0:	628b      	str	r3, [r1, #40]	; 0x28
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
    64a2:	f504 2401 	add.w	r4, r4, #528384	; 0x81000
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
    64a6:	f501 2101 	add.w	r1, r1, #528384	; 0x81000
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    64aa:	f606 76e8 	addw	r6, r6, #4072	; 0xfe8
	FTM3_C1SC = 0x28;
    64ae:	f605 75e8 	addw	r5, r5, #4072	; 0xfe8
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
    64b2:	f507 677f 	add.w	r7, r7, #4080	; 0xff0
	FTM3_C4SC = 0x28;
    64b6:	3110      	adds	r1, #16
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    64b8:	f10e 0e10 	add.w	lr, lr, #16
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
    64bc:	3420      	adds	r4, #32
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    64be:	6033      	str	r3, [r6, #0]
	FTM3_C1SC = 0x28;
    64c0:	602b      	str	r3, [r5, #0]
	FTM3_C2SC = 0x28;
    64c2:	f8ce 3000 	str.w	r3, [lr]
	FTM3_C3SC = 0x28;
    64c6:	603b      	str	r3, [r7, #0]
	FTM3_C4SC = 0x28;
    64c8:	600b      	str	r3, [r1, #0]
	FTM3_C5SC = 0x28;
    64ca:	6023      	str	r3, [r4, #0]
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    64cc:	4c31      	ldr	r4, [pc, #196]	; (6594 <_init_Teensyduino_internal_+0x158>)
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
    64ce:	61bb      	str	r3, [r7, #24]
	FTM3_C7SC = 0x28;
    64d0:	618b      	str	r3, [r1, #24]
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    64d2:	2109      	movs	r1, #9
    64d4:	6021      	str	r1, [r4, #0]
	FTM1_CNT = 0;
    64d6:	f5a7 2700 	sub.w	r7, r7, #524288	; 0x80000
	FTM1_MOD = DEFAULT_FTM_MOD;
    64da:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
    64de:	3f20      	subs	r7, #32
	FTM1_MOD = DEFAULT_FTM_MOD;
    64e0:	3408      	adds	r4, #8
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
    64e2:	603a      	str	r2, [r7, #0]
	FTM1_MOD = DEFAULT_FTM_MOD;
    64e4:	6020      	str	r0, [r4, #0]
	FTM1_C0SC = 0x28;
    64e6:	60bb      	str	r3, [r7, #8]
	FTM1_C1SC = 0x28;
    64e8:	60e3      	str	r3, [r4, #12]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    64ea:	f847 1c04 	str.w	r1, [r7, #-4]
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    64ee:	f504 24fd 	add.w	r4, r4, #518144	; 0x7e800
	FTM2_MOD = DEFAULT_FTM_MOD;
    64f2:	f507 27fe 	add.w	r7, r7, #520192	; 0x7f000
    64f6:	3704      	adds	r7, #4
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    64f8:	f204 74fc 	addw	r4, r4, #2044	; 0x7fc
    64fc:	6022      	str	r2, [r4, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
    64fe:	6038      	str	r0, [r7, #0]
	FTM2_C0SC = 0x28;
    6500:	60a3      	str	r3, [r4, #8]
	FTM2_C1SC = 0x28;
    6502:	60fb      	str	r3, [r7, #12]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    6504:	f844 1c04 	str.w	r1, [r4, #-4]
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
	FTM2_MOD = DEFAULT_FTM_MOD;
	FTM2_C0SC = 0x28;
    6508:	3408      	adds	r4, #8
	FTM2_C1SC = 0x28;
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
    650a:	f604 74fc 	addw	r4, r4, #4092	; 0xffc
	FTM2_C0SC = 0x28;
	FTM2_C1SC = 0x28;
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
    650e:	f8c7 2ffc 	str.w	r2, [r7, #4092]	; 0xffc
	FTM3_MOD = DEFAULT_FTM_MOD;
    6512:	6020      	str	r0, [r4, #0]
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    6514:	f5a4 24e1 	sub.w	r4, r4, #460800	; 0x70800
    6518:	f2a4 74dc 	subw	r4, r4, #2012	; 0x7dc
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
	FTM3_C0SC = 0x28;
    651c:	6033      	str	r3, [r6, #0]
	FTM3_C1SC = 0x28;
    651e:	602b      	str	r3, [r5, #0]
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    6520:	f8c7 1ff8 	str.w	r1, [r7, #4088]	; 0xff8
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    6524:	6821      	ldr	r1, [r4, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    6526:	481c      	ldr	r0, [pc, #112]	; (6598 <_init_Teensyduino_internal_+0x15c>)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    6528:	f441 7100 	orr.w	r1, r1, #512	; 0x200
    652c:	6021      	str	r1, [r4, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    652e:	6801      	ldr	r1, [r0, #0]
	TPM1_CNT = 0;
	TPM1_MOD = 32767;
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    6530:	4c1a      	ldr	r4, [pc, #104]	; (659c <_init_Teensyduino_internal_+0x160>)
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
	TPM1_CNT = 0;
    6532:	f50e 4e7f 	add.w	lr, lr, #65280	; 0xff00
    6536:	f10e 0ee8 	add.w	lr, lr, #232	; 0xe8
	TPM1_MOD = 32767;
    653a:	f507 3788 	add.w	r7, r7, #69632	; 0x11000
	TPM1_C0SC = 0x28;
    653e:	f506 3680 	add.w	r6, r6, #65536	; 0x10000
	TPM1_C1SC = 0x28;
    6542:	f505 3580 	add.w	r5, r5, #65536	; 0x10000
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    6546:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
    654a:	6001      	str	r1, [r0, #0]
	TPM1_CNT = 0;
    654c:	f8ce 2000 	str.w	r2, [lr]
	TPM1_MOD = 32767;
    6550:	f647 71ff 	movw	r1, #32767	; 0x7fff
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    6554:	2208      	movs	r2, #8
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
	TPM1_CNT = 0;
	TPM1_MOD = 32767;
    6556:	6039      	str	r1, [r7, #0]
	TPM1_C0SC = 0x28;
    6558:	6033      	str	r3, [r6, #0]
	TPM1_C1SC = 0x28;
    655a:	602b      	str	r3, [r5, #0]
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    655c:	6022      	str	r2, [r4, #0]
#endif
	analog_init();
    655e:	f001 f849 	bl	75f4 <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
    6562:	2019      	movs	r0, #25
    6564:	f7ff ff18 	bl	6398 <delay>
	usb_init();
    6568:	f000 fd10 	bl	6f8c <usb_init>
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    656c:	f240 1013 	movw	r0, #275	; 0x113
}
    6570:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
	usb_init();
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    6574:	f7ff bf10 	b.w	6398 <delay>
    6578:	e000e104 	.word	0xe000e104
    657c:	40038004 	.word	0x40038004
    6580:	40038014 	.word	0x40038014
    6584:	4003801c 	.word	0x4003801c
    6588:	40038024 	.word	0x40038024
    658c:	4003802c 	.word	0x4003802c
    6590:	40038034 	.word	0x40038034
    6594:	40038000 	.word	0x40038000
    6598:	40048004 	.word	0x40048004
    659c:	400c9000 	.word	0x400c9000
    65a0:	40038008 	.word	0x40038008
    65a4:	4003800c 	.word	0x4003800c

000065a8 <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    65a8:	1e43      	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    65aa:	2b03      	cmp	r3, #3
    65ac:	d814      	bhi.n	65d8 <usb_rx+0x30>
	__disable_irq();
    65ae:	b672      	cpsid	i
	ret = rx_first[endpoint];
    65b0:	490a      	ldr	r1, [pc, #40]	; (65dc <usb_rx+0x34>)
    65b2:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
	if (ret) {
    65b6:	b168      	cbz	r0, 65d4 <usb_rx+0x2c>




usb_packet_t *usb_rx(uint32_t endpoint)
{
    65b8:	b470      	push	{r4, r5, r6}
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
    65ba:	4c09      	ldr	r4, [pc, #36]	; (65e0 <usb_rx+0x38>)
    65bc:	8805      	ldrh	r5, [r0, #0]
    65be:	f834 2013 	ldrh.w	r2, [r4, r3, lsl #1]
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
    65c2:	6846      	ldr	r6, [r0, #4]
    65c4:	f841 6023 	str.w	r6, [r1, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    65c8:	1b52      	subs	r2, r2, r5
    65ca:	f824 2013 	strh.w	r2, [r4, r3, lsl #1]
	}
	__enable_irq();
    65ce:	b662      	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    65d0:	bc70      	pop	{r4, r5, r6}
    65d2:	4770      	bx	lr
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
	}
	__enable_irq();
    65d4:	b662      	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    65d6:	4770      	bx	lr

usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    65d8:	2000      	movs	r0, #0
    65da:	4770      	bx	lr
    65dc:	1fff2ba8 	.word	0x1fff2ba8
    65e0:	1fff2cb0 	.word	0x1fff2cb0

000065e4 <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    65e4:	3801      	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    65e6:	2803      	cmp	r0, #3
    65e8:	d80b      	bhi.n	6602 <usb_tx_packet_count+0x1e>
	__disable_irq();
    65ea:	b672      	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    65ec:	4b07      	ldr	r3, [pc, #28]	; (660c <usb_tx_packet_count+0x28>)
    65ee:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    65f2:	b143      	cbz	r3, 6606 <usb_tx_packet_count+0x22>
    65f4:	2000      	movs	r0, #0
    65f6:	685b      	ldr	r3, [r3, #4]
    65f8:	3001      	adds	r0, #1
    65fa:	2b00      	cmp	r3, #0
    65fc:	d1fb      	bne.n	65f6 <usb_tx_packet_count+0x12>
	__enable_irq();
    65fe:	b662      	cpsie	i
	return count;
    6600:	4770      	bx	lr
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
    6602:	2000      	movs	r0, #0
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
	__enable_irq();
	return count;
}
    6604:	4770      	bx	lr
// https://forum.pjrc.com/threads/58663?p=223513&viewfull=1#post223513
//
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;
    6606:	4618      	mov	r0, r3
    6608:	e7f9      	b.n	65fe <usb_tx_packet_count+0x1a>
    660a:	bf00      	nop
    660c:	1fff2bfc 	.word	0x1fff2bfc

00006610 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    6610:	b4f0      	push	{r4, r5, r6, r7}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    6612:	b672      	cpsid	i
void usb_rx_memory(usb_packet_t *packet)
{
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
    6614:	491a      	ldr	r1, [pc, #104]	; (6680 <usb_rx_memory+0x70>)
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
    6616:	4e1b      	ldr	r6, [pc, #108]	; (6684 <usb_rx_memory+0x74>)
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    6618:	2301      	movs	r3, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    661a:	f811 4b01 	ldrb.w	r4, [r1], #1
			if (table[index(i, RX, EVEN)].desc == 0) {
    661e:	4f19      	ldr	r7, [pc, #100]	; (6684 <usb_rx_memory+0x74>)
    6620:	009a      	lsls	r2, r3, #2
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    6622:	0724      	lsls	r4, r4, #28
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    6624:	f042 0501 	orr.w	r5, r2, #1
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    6628:	d505      	bpl.n	6636 <usb_rx_memory+0x26>
			if (table[index(i, RX, EVEN)].desc == 0) {
    662a:	f856 4032 	ldr.w	r4, [r6, r2, lsl #3]
    662e:	b164      	cbz	r4, 664a <usb_rx_memory+0x3a>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    6630:	f856 2035 	ldr.w	r2, [r6, r5, lsl #3]
    6634:	b1ba      	cbz	r2, 6666 <usb_rx_memory+0x56>
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    6636:	3301      	adds	r3, #1
    6638:	2b05      	cmp	r3, #5
    663a:	d1ee      	bne.n	661a <usb_rx_memory+0xa>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    663c:	b662      	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    663e:	4b12      	ldr	r3, [pc, #72]	; (6688 <usb_rx_memory+0x78>)
    6640:	2200      	movs	r2, #0
    6642:	701a      	strb	r2, [r3, #0]
	usb_free(packet);
	return;
}
    6644:	bcf0      	pop	{r4, r5, r6, r7}
	__enable_irq();
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
    6646:	f000 bd23 	b.w	7090 <usb_free>
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    664a:	4c0f      	ldr	r4, [pc, #60]	; (6688 <usb_rx_memory+0x78>)
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    664c:	4d0f      	ldr	r5, [pc, #60]	; (668c <usb_rx_memory+0x7c>)
				usb_rx_memory_needed--;
    664e:	7821      	ldrb	r1, [r4, #0]
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    6650:	eb07 1343 	add.w	r3, r7, r3, lsl #5
    6654:	3008      	adds	r0, #8
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    6656:	3901      	subs	r1, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    6658:	6058      	str	r0, [r3, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    665a:	7021      	strb	r1, [r4, #0]
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    665c:	f847 5032 	str.w	r5, [r7, r2, lsl #3]
				usb_rx_memory_needed--;
				__enable_irq();
    6660:	b662      	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
	return;
}
    6662:	bcf0      	pop	{r4, r5, r6, r7}
    6664:	4770      	bx	lr
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    6666:	4a08      	ldr	r2, [pc, #32]	; (6688 <usb_rx_memory+0x78>)
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    6668:	4909      	ldr	r1, [pc, #36]	; (6690 <usb_rx_memory+0x80>)
				usb_rx_memory_needed--;
    666a:	7813      	ldrb	r3, [r2, #0]
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    666c:	eb07 04c5 	add.w	r4, r7, r5, lsl #3
    6670:	3008      	adds	r0, #8
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    6672:	3b01      	subs	r3, #1
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    6674:	6060      	str	r0, [r4, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    6676:	7013      	strb	r3, [r2, #0]
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    6678:	f847 1035 	str.w	r1, [r7, r5, lsl #3]
				usb_rx_memory_needed--;
				__enable_irq();
    667c:	b662      	cpsie	i
				//serial_phex(i);
				//serial_print(",odd\n");
				return;
    667e:	e7f0      	b.n	6662 <usb_rx_memory+0x52>
    6680:	0000aee0 	.word	0x0000aee0
    6684:	1fff0000 	.word	0x1fff0000
    6688:	1fff2c25 	.word	0x1fff2c25
    668c:	00400088 	.word	0x00400088
    6690:	004000c8 	.word	0x004000c8

00006694 <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    6694:	1e43      	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    6696:	2b03      	cmp	r3, #3
    6698:	d81d      	bhi.n	66d6 <usb_tx+0x42>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    669a:	4a1b      	ldr	r2, [pc, #108]	; (6708 <usb_tx+0x74>)
    669c:	0140      	lsls	r0, r0, #5
    669e:	f040 0010 	orr.w	r0, r0, #16

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
    66a2:	b430      	push	{r4, r5}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    66a4:	4410      	add	r0, r2
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
	__disable_irq();
    66a6:	b672      	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    66a8:	4c18      	ldr	r4, [pc, #96]	; (670c <usb_tx+0x78>)
    66aa:	5ce2      	ldrb	r2, [r4, r3]
    66ac:	2a03      	cmp	r2, #3
    66ae:	d81b      	bhi.n	66e8 <usb_tx+0x54>
    66b0:	e8df f002 	tbb	[pc, r2]
    66b4:	17151202 	.word	0x17151202
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    66b8:	2203      	movs	r2, #3
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    66ba:	880d      	ldrh	r5, [r1, #0]
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    66bc:	54e2      	strb	r2, [r4, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    66be:	f010 0f08 	tst.w	r0, #8
    66c2:	bf14      	ite	ne
    66c4:	23c8      	movne	r3, #200	; 0xc8
    66c6:	2388      	moveq	r3, #136	; 0x88
    66c8:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    66cc:	3108      	adds	r1, #8
    66ce:	6041      	str	r1, [r0, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    66d0:	6003      	str	r3, [r0, #0]
	__enable_irq();
    66d2:	b662      	cpsie	i
}
    66d4:	bc30      	pop	{r4, r5}
    66d6:	4770      	bx	lr
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    66d8:	3008      	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    66da:	2202      	movs	r2, #2
		break;
    66dc:	e7ed      	b.n	66ba <usb_tx+0x26>
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    66de:	2205      	movs	r2, #5
    66e0:	e7eb      	b.n	66ba <usb_tx+0x26>
		break;
	  case TX_STATE_ODD_FREE:
		b++;
    66e2:	3008      	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    66e4:	2204      	movs	r2, #4
		break;
    66e6:	e7e8      	b.n	66ba <usb_tx+0x26>
	  default:
		if (tx_first[endpoint] == NULL) {
    66e8:	4a09      	ldr	r2, [pc, #36]	; (6710 <usb_tx+0x7c>)
    66ea:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    66ee:	b138      	cbz	r0, 6700 <usb_tx+0x6c>
			tx_first[endpoint] = packet;
		} else {
			tx_last[endpoint]->next = packet;
    66f0:	4a08      	ldr	r2, [pc, #32]	; (6714 <usb_tx+0x80>)
    66f2:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    66f6:	6041      	str	r1, [r0, #4]
		}
		tx_last[endpoint] = packet;
    66f8:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		__enable_irq();
    66fc:	b662      	cpsie	i
		return;
    66fe:	e7e9      	b.n	66d4 <usb_tx+0x40>
		b++;
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
		break;
	  default:
		if (tx_first[endpoint] == NULL) {
			tx_first[endpoint] = packet;
    6700:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    6704:	4a03      	ldr	r2, [pc, #12]	; (6714 <usb_tx+0x80>)
    6706:	e7f7      	b.n	66f8 <usb_tx+0x64>
    6708:	1fff0000 	.word	0x1fff0000
    670c:	1fff2c34 	.word	0x1fff2c34
    6710:	1fff2bfc 	.word	0x1fff2bfc
    6714:	1fff2c0c 	.word	0x1fff2c0c

00006718 <usb_isr>:
}



void usb_isr(void)
{
    6718:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    671c:	f8df b314 	ldr.w	fp, [pc, #788]	; 6a34 <usb_isr+0x31c>
		USB0_ISTAT = USB_ISTAT_SOFTOK;
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
		uint8_t endpoint;
		stat = USB0_STAT;
    6720:	f8df a314 	ldr.w	sl, [pc, #788]	; 6a38 <usb_isr+0x320>
}



void usb_isr(void)
{
    6724:	b087      	sub	sp, #28
    6726:	e044      	b.n	67b2 <usb_isr+0x9a>
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    6728:	4fad      	ldr	r7, [pc, #692]	; (69e0 <usb_isr+0x2c8>)
    672a:	ea4f 0893 	mov.w	r8, r3, lsr #2
    672e:	eb07 09c8 	add.w	r9, r7, r8, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    6732:	3e01      	subs	r6, #1
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    6734:	f8d9 2004 	ldr.w	r2, [r9, #4]
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    6738:	f003 0308 	and.w	r3, r3, #8
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    673c:	b2f6      	uxtb	r6, r6
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    673e:	f1a2 0008 	sub.w	r0, r2, #8
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    6742:	f003 04ff 	and.w	r4, r3, #255	; 0xff
    6746:	2b00      	cmp	r3, #0
    6748:	f040 8103 	bne.w	6952 <usb_isr+0x23a>
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
    674c:	f857 3038 	ldr.w	r3, [r7, r8, lsl #3]
    6750:	0c1b      	lsrs	r3, r3, #16
    6752:	b299      	uxth	r1, r3
    6754:	f822 1c08 	strh.w	r1, [r2, #-8]
				if (packet->len > 0) {
    6758:	2b00      	cmp	r3, #0
    675a:	f000 80f1 	beq.w	6940 <usb_isr+0x228>
					packet->index = 0;
					packet->next = NULL;
					if (rx_first[endpoint] == NULL) {
    675e:	4ba1      	ldr	r3, [pc, #644]	; (69e4 <usb_isr+0x2cc>)
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
				if (packet->len > 0) {
					packet->index = 0;
    6760:	f822 4c06 	strh.w	r4, [r2, #-6]
					packet->next = NULL;
    6764:	f842 4c04 	str.w	r4, [r2, #-4]
					if (rx_first[endpoint] == NULL) {
    6768:	f853 2026 	ldr.w	r2, [r3, r6, lsl #2]
    676c:	2a00      	cmp	r2, #0
    676e:	f000 816c 	beq.w	6a4a <usb_isr+0x332>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
    6772:	4d9d      	ldr	r5, [pc, #628]	; (69e8 <usb_isr+0x2d0>)
    6774:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
    6778:	6058      	str	r0, [r3, #4]
					}
					rx_last[endpoint] = packet;
					usb_rx_byte_count_data[endpoint] += packet->len;
    677a:	4c9c      	ldr	r4, [pc, #624]	; (69ec <usb_isr+0x2d4>)
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
					}
					rx_last[endpoint] = packet;
    677c:	f845 0026 	str.w	r0, [r5, r6, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    6780:	f834 3016 	ldrh.w	r3, [r4, r6, lsl #1]
    6784:	4419      	add	r1, r3
    6786:	f824 1016 	strh.w	r1, [r4, r6, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
    678a:	f000 fc61 	bl	7050 <usb_malloc>
					if (packet) {
    678e:	2800      	cmp	r0, #0
    6790:	f000 8154 	beq.w	6a3c <usb_isr+0x324>
						b->addr = packet->buf;
						b->desc = BDT_DESC(64,
    6794:	4a96      	ldr	r2, [pc, #600]	; (69f0 <usb_isr+0x2d8>)
    6796:	4b97      	ldr	r3, [pc, #604]	; (69f4 <usb_isr+0x2dc>)
    6798:	f019 0f08 	tst.w	r9, #8
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    679c:	f100 0008 	add.w	r0, r0, #8
						b->desc = BDT_DESC(64,
    67a0:	bf18      	it	ne
    67a2:	4613      	movne	r3, r2
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    67a4:	f8c9 0004 	str.w	r0, [r9, #4]
						b->desc = BDT_DESC(64,
    67a8:	f847 3038 	str.w	r3, [r7, r8, lsl #3]
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    67ac:	2308      	movs	r3, #8
    67ae:	f88b 3000 	strb.w	r3, [fp]
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    67b2:	f89b 4000 	ldrb.w	r4, [fp]
    67b6:	b2e4      	uxtb	r4, r4

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    67b8:	0760      	lsls	r0, r4, #29
    67ba:	d51b      	bpl.n	67f4 <usb_isr+0xdc>
		if (usb_configuration) {
    67bc:	4b8e      	ldr	r3, [pc, #568]	; (69f8 <usb_isr+0x2e0>)
    67be:	781b      	ldrb	r3, [r3, #0]
    67c0:	b1ab      	cbz	r3, 67ee <usb_isr+0xd6>
			t = usb_reboot_timer;
    67c2:	498e      	ldr	r1, [pc, #568]	; (69fc <usb_isr+0x2e4>)
    67c4:	780a      	ldrb	r2, [r1, #0]
			if (t) {
    67c6:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    67ca:	b12a      	cbz	r2, 67d8 <usb_isr+0xc0>
				usb_reboot_timer = --t;
    67cc:	3b01      	subs	r3, #1
    67ce:	b2db      	uxtb	r3, r3
    67d0:	700b      	strb	r3, [r1, #0]
				if (!t) _reboot_Teensyduino_();
    67d2:	2b00      	cmp	r3, #0
    67d4:	f000 83b5 	beq.w	6f42 <usb_isr+0x82a>
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
    67d8:	4989      	ldr	r1, [pc, #548]	; (6a00 <usb_isr+0x2e8>)
    67da:	780a      	ldrb	r2, [r1, #0]
			if (t) {
    67dc:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    67e0:	b12a      	cbz	r2, 67ee <usb_isr+0xd6>
				usb_cdc_transmit_flush_timer = --t;
    67e2:	3b01      	subs	r3, #1
    67e4:	b2db      	uxtb	r3, r3
    67e6:	700b      	strb	r3, [r1, #0]
				if (t == 0) usb_serial_flush_callback();
    67e8:	2b00      	cmp	r3, #0
    67ea:	f000 80f6 	beq.w	69da <usb_isr+0x2c2>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    67ee:	2304      	movs	r3, #4
    67f0:	f88b 3000 	strb.w	r3, [fp]
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    67f4:	f004 0308 	and.w	r3, r4, #8
    67f8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    67fc:	2b00      	cmp	r3, #0
    67fe:	f000 80d5 	beq.w	69ac <usb_isr+0x294>
		uint8_t endpoint;
		stat = USB0_STAT;
    6802:	f89a 3000 	ldrb.w	r3, [sl]
    6806:	b2db      	uxtb	r3, r3
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
    6808:	091e      	lsrs	r6, r3, #4
    680a:	d18d      	bne.n	6728 <usb_isr+0x10>
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    680c:	089c      	lsrs	r4, r3, #2
    680e:	4f74      	ldr	r7, [pc, #464]	; (69e0 <usb_isr+0x2c8>)
	pid = BDT_PID(b->desc);
    6810:	f857 2034 	ldr.w	r2, [r7, r4, lsl #3]
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    6814:	eb07 01c4 	add.w	r1, r7, r4, lsl #3
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    6818:	f3c2 0283 	ubfx	r2, r2, #2, #4
    681c:	3a01      	subs	r2, #1
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
	//count = b->desc >> 16;
	buf = b->addr;
    681e:	6849      	ldr	r1, [r1, #4]
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    6820:	2a0c      	cmp	r2, #12
    6822:	d87e      	bhi.n	6922 <usb_isr+0x20a>
    6824:	e8df f002 	tbb	[pc, r2]
    6828:	7d7d8181 	.word	0x7d7d8181
    682c:	7d7d7d7d 	.word	0x7d7d7d7d
    6830:	7d7d7d42 	.word	0x7d7d7d42
    6834:	07          	.byte	0x07
    6835:	00          	.byte	0x00
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    6836:	6808      	ldr	r0, [r1, #0]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    6838:	4b72      	ldr	r3, [pc, #456]	; (6a04 <usb_isr+0x2ec>)
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    683a:	4d73      	ldr	r5, [pc, #460]	; (6a08 <usb_isr+0x2f0>)
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    683c:	9301      	str	r3, [sp, #4]
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    683e:	4b6c      	ldr	r3, [pc, #432]	; (69f0 <usb_isr+0x2d8>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    6840:	684a      	ldr	r2, [r1, #4]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    6842:	4e72      	ldr	r6, [pc, #456]	; (6a0c <usb_isr+0x2f4>)
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    6844:	f847 3034 	str.w	r3, [r7, r4, lsl #3]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    6848:	b281      	uxth	r1, r0
    684a:	f240 6481 	movw	r4, #1665	; 0x681
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    684e:	4b6d      	ldr	r3, [pc, #436]	; (6a04 <usb_isr+0x2ec>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    6850:	606a      	str	r2, [r5, #4]
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    6852:	6028      	str	r0, [r5, #0]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    6854:	2200      	movs	r2, #0
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    6856:	2001      	movs	r0, #1
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    6858:	42a1      	cmp	r1, r4
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    685a:	613a      	str	r2, [r7, #16]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    685c:	601a      	str	r2, [r3, #0]
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
    685e:	61ba      	str	r2, [r7, #24]
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    6860:	7030      	strb	r0, [r6, #0]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    6862:	f200 80f6 	bhi.w	6a52 <usb_isr+0x33a>
    6866:	f5b1 6fd0 	cmp.w	r1, #1664	; 0x680
    686a:	f080 82e8 	bcs.w	6e3e <usb_isr+0x726>
    686e:	f5b1 7f81 	cmp.w	r1, #258	; 0x102
    6872:	f000 82d3 	beq.w	6e1c <usb_isr+0x704>
    6876:	f200 81d8 	bhi.w	6c2a <usb_isr+0x512>
    687a:	2980      	cmp	r1, #128	; 0x80
    687c:	f000 814d 	beq.w	6b1a <usb_isr+0x402>
    6880:	2982      	cmp	r1, #130	; 0x82
    6882:	f040 8292 	bne.w	6daa <usb_isr+0x692>
    6886:	88a9      	ldrh	r1, [r5, #4]
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    6888:	4b61      	ldr	r3, [pc, #388]	; (6a10 <usb_isr+0x2f8>)
    688a:	f001 017f 	and.w	r1, r1, #127	; 0x7f
		datalen = 2;
		data = reply_buffer;
		break;
	  case 0x0082: // GET_STATUS (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS) {
    688e:	2904      	cmp	r1, #4
    6890:	f200 828c 	bhi.w	6dac <usb_isr+0x694>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    6894:	4c5f      	ldr	r4, [pc, #380]	; (6a14 <usb_isr+0x2fc>)
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    6896:	0089      	lsls	r1, r1, #2
    6898:	440b      	add	r3, r1
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    689a:	7022      	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    689c:	7062      	strb	r2, [r4, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    689e:	781a      	ldrb	r2, [r3, #0]
    68a0:	0793      	lsls	r3, r2, #30
    68a2:	f140 8338 	bpl.w	6f16 <usb_isr+0x7fe>
    68a6:	7020      	strb	r0, [r4, #0]
		data = reply_buffer;
		datalen = 2;
    68a8:	2002      	movs	r0, #2
    68aa:	e13a      	b.n	6b22 <usb_isr+0x40a>
		//serial_print("PID=IN:");
		//serial_phex(stat);
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
    68ac:	4b55      	ldr	r3, [pc, #340]	; (6a04 <usb_isr+0x2ec>)
    68ae:	9301      	str	r3, [sp, #4]
    68b0:	681a      	ldr	r2, [r3, #0]
		if (data) {
    68b2:	b362      	cbz	r2, 690e <usb_isr+0x1f6>
			size = ep0_tx_len;
    68b4:	4b58      	ldr	r3, [pc, #352]	; (6a18 <usb_isr+0x300>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    68b6:	4959      	ldr	r1, [pc, #356]	; (6a1c <usb_isr+0x304>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    68b8:	4e54      	ldr	r6, [pc, #336]	; (6a0c <usb_isr+0x2f4>)
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
    68ba:	8818      	ldrh	r0, [r3, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    68bc:	780c      	ldrb	r4, [r1, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    68be:	f896 e000 	ldrb.w	lr, [r6]
    68c2:	2840      	cmp	r0, #64	; 0x40
    68c4:	4605      	mov	r5, r0
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    68c6:	f084 0c01 	eor.w	ip, r4, #1
    68ca:	bf28      	it	cs
    68cc:	2540      	movcs	r5, #64	; 0x40
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    68ce:	f044 0402 	orr.w	r4, r4, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    68d2:	f1be 0f00 	cmp.w	lr, #0
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    68d6:	f881 c000 	strb.w	ip, [r1]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    68da:	eba0 0005 	sub.w	r0, r0, r5
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    68de:	eb07 0cc4 	add.w	ip, r7, r4, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    68e2:	bf0c      	ite	eq
    68e4:	2188      	moveq	r1, #136	; 0x88
    68e6:	21c8      	movne	r1, #200	; 0xc8
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    68e8:	b280      	uxth	r0, r0
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    68ea:	f08e 0e01 	eor.w	lr, lr, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    68ee:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    68f2:	f8cc 2004 	str.w	r2, [ip, #4]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    68f6:	8018      	strh	r0, [r3, #0]
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    68f8:	f886 e000 	strb.w	lr, [r6]
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    68fc:	442a      	add	r2, r5
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    68fe:	f847 1034 	str.w	r1, [r7, r4, lsl #3]
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    6902:	b910      	cbnz	r0, 690a <usb_isr+0x1f2>
    6904:	2d40      	cmp	r5, #64	; 0x40
    6906:	bf18      	it	ne
    6908:	2200      	movne	r2, #0
    690a:	9b01      	ldr	r3, [sp, #4]
    690c:	601a      	str	r2, [r3, #0]
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    690e:	4b3e      	ldr	r3, [pc, #248]	; (6a08 <usb_isr+0x2f0>)
    6910:	881a      	ldrh	r2, [r3, #0]
    6912:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
    6916:	d104      	bne.n	6922 <usb_isr+0x20a>
			setup.bRequest = 0;
    6918:	2100      	movs	r1, #0
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    691a:	789a      	ldrb	r2, [r3, #2]
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
			setup.bRequest = 0;
    691c:	7059      	strb	r1, [r3, #1]
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    691e:	4b40      	ldr	r3, [pc, #256]	; (6a20 <usb_isr+0x308>)
    6920:	701a      	strb	r2, [r3, #0]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    6922:	4a40      	ldr	r2, [pc, #256]	; (6a24 <usb_isr+0x30c>)
    6924:	2301      	movs	r3, #1
    6926:	7013      	strb	r3, [r2, #0]
    6928:	e740      	b.n	67ac <usb_isr+0x94>
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
		break;
	case 0x01:  // OUT transaction received from host
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    692a:	4a37      	ldr	r2, [pc, #220]	; (6a08 <usb_isr+0x2f0>)
    692c:	8815      	ldrh	r5, [r2, #0]
    692e:	f242 0021 	movw	r0, #8225	; 0x2021
    6932:	4285      	cmp	r5, r0
    6934:	f000 8152 	beq.w	6bdc <usb_isr+0x4c4>
		if (usb_audio_set_feature(&setup, buf)) {
			endpoint0_transmit(NULL, 0);
		}
#endif
		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    6938:	4a2d      	ldr	r2, [pc, #180]	; (69f0 <usb_isr+0x2d8>)
    693a:	f847 2034 	str.w	r2, [r7, r4, lsl #3]
    693e:	e7f0      	b.n	6922 <usb_isr+0x20a>
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
					}
				} else {
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    6940:	4a2b      	ldr	r2, [pc, #172]	; (69f0 <usb_isr+0x2d8>)
    6942:	4b2c      	ldr	r3, [pc, #176]	; (69f4 <usb_isr+0x2dc>)
    6944:	f019 0f08 	tst.w	r9, #8
    6948:	bf18      	it	ne
    694a:	4613      	movne	r3, r2
    694c:	f847 3038 	str.w	r3, [r7, r8, lsl #3]
    6950:	e72c      	b.n	67ac <usb_isr+0x94>
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
    6952:	f000 fb9d 	bl	7090 <usb_free>
				packet = tx_first[endpoint];
    6956:	4a34      	ldr	r2, [pc, #208]	; (6a28 <usb_isr+0x310>)
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    6958:	4934      	ldr	r1, [pc, #208]	; (6a2c <usb_isr+0x314>)
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
    695a:	f852 3026 	ldr.w	r3, [r2, r6, lsl #2]
				if (packet) {
    695e:	2b00      	cmp	r3, #0
    6960:	f000 812d 	beq.w	6bbe <usb_isr+0x4a6>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    6964:	6858      	ldr	r0, [r3, #4]
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    6966:	5d8c      	ldrb	r4, [r1, r6]
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    6968:	f842 0026 	str.w	r0, [r2, r6, lsl #2]
					b->addr = packet->buf;
    696c:	f103 0208 	add.w	r2, r3, #8
    6970:	f8c9 2004 	str.w	r2, [r9, #4]
					switch (tx_state[endpoint]) {
    6974:	2c03      	cmp	r4, #3
    6976:	d805      	bhi.n	6984 <usb_isr+0x26c>
    6978:	e8df f004 	tbb	[pc, r4]
    697c:	02150f12 	.word	0x02150f12
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    6980:	2204      	movs	r2, #4
    6982:	558a      	strb	r2, [r1, r6]
						break;
					  default:
						break;
					}
					b->desc = BDT_DESC(packet->len,
    6984:	881a      	ldrh	r2, [r3, #0]
    6986:	f019 0f08 	tst.w	r9, #8
    698a:	bf0c      	ite	eq
    698c:	2388      	moveq	r3, #136	; 0x88
    698e:	23c8      	movne	r3, #200	; 0xc8
    6990:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    6994:	f847 3038 	str.w	r3, [r7, r8, lsl #3]
    6998:	e708      	b.n	67ac <usb_isr+0x94>
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    699a:	2202      	movs	r2, #2
    699c:	558a      	strb	r2, [r1, r6]
						break;
    699e:	e7f1      	b.n	6984 <usb_isr+0x26c>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    69a0:	2203      	movs	r2, #3
    69a2:	558a      	strb	r2, [r1, r6]
						break;
    69a4:	e7ee      	b.n	6984 <usb_isr+0x26c>
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    69a6:	2205      	movs	r2, #5
    69a8:	558a      	strb	r2, [r1, r6]
						break;
    69aa:	e7eb      	b.n	6984 <usb_isr+0x26c>
		goto restart;
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    69ac:	07e0      	lsls	r0, r4, #31
    69ae:	f100 8178 	bmi.w	6ca2 <usb_isr+0x58a>
		USB0_CTL = USB_CTL_USBENSOFEN;
		return;
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    69b2:	0621      	lsls	r1, r4, #24
    69b4:	f100 81a2 	bmi.w	6cfc <usb_isr+0x5e4>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    69b8:	07a2      	lsls	r2, r4, #30
    69ba:	d506      	bpl.n	69ca <usb_isr+0x2b2>
		uint8_t err = USB0_ERRSTAT;
    69bc:	4a1c      	ldr	r2, [pc, #112]	; (6a30 <usb_isr+0x318>)
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    69be:	491d      	ldr	r1, [pc, #116]	; (6a34 <usb_isr+0x31c>)
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    69c0:	7813      	ldrb	r3, [r2, #0]
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    69c2:	2002      	movs	r0, #2
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    69c4:	b2db      	uxtb	r3, r3
		USB0_ERRSTAT = err;
    69c6:	7013      	strb	r3, [r2, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    69c8:	7008      	strb	r0, [r1, #0]
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    69ca:	06e3      	lsls	r3, r4, #27
    69cc:	d502      	bpl.n	69d4 <usb_isr+0x2bc>
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    69ce:	4b19      	ldr	r3, [pc, #100]	; (6a34 <usb_isr+0x31c>)
    69d0:	2210      	movs	r2, #16
    69d2:	701a      	strb	r2, [r3, #0]
	}

}
    69d4:	b007      	add	sp, #28
    69d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
			if (t) {
				usb_cdc_transmit_flush_timer = --t;
				if (t == 0) usb_serial_flush_callback();
    69da:	f000 fcc5 	bl	7368 <usb_serial_flush_callback>
    69de:	e706      	b.n	67ee <usb_isr+0xd6>
    69e0:	1fff0000 	.word	0x1fff0000
    69e4:	1fff2ba8 	.word	0x1fff2ba8
    69e8:	1fff2b54 	.word	0x1fff2b54
    69ec:	1fff2cb0 	.word	0x1fff2cb0
    69f0:	004000c8 	.word	0x004000c8
    69f4:	00400088 	.word	0x00400088
    69f8:	1fff2c30 	.word	0x1fff2c30
    69fc:	1fff2bb9 	.word	0x1fff2bb9
    6a00:	1fff2c38 	.word	0x1fff2c38
    6a04:	1fff2b50 	.word	0x1fff2b50
    6a08:	1fff2c1c 	.word	0x1fff2c1c
    6a0c:	1fff2bb8 	.word	0x1fff2bb8
    6a10:	400720c0 	.word	0x400720c0
    6a14:	1fff2c28 	.word	0x1fff2c28
    6a18:	1fff2b64 	.word	0x1fff2b64
    6a1c:	1fff2c24 	.word	0x1fff2c24
    6a20:	40072098 	.word	0x40072098
    6a24:	40072094 	.word	0x40072094
    6a28:	1fff2bfc 	.word	0x1fff2bfc
    6a2c:	1fff2c34 	.word	0x1fff2c34
    6a30:	40072088 	.word	0x40072088
    6a34:	40072080 	.word	0x40072080
    6a38:	40072090 	.word	0x40072090
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
    6a3c:	4ab7      	ldr	r2, [pc, #732]	; (6d1c <usb_isr+0x604>)
						b->desc = BDT_DESC(64,
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
    6a3e:	f847 0038 	str.w	r0, [r7, r8, lsl #3]
						usb_rx_memory_needed++;
    6a42:	7813      	ldrb	r3, [r2, #0]
    6a44:	3301      	adds	r3, #1
    6a46:	7013      	strb	r3, [r2, #0]
    6a48:	e6b0      	b.n	67ac <usb_isr+0x94>
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[endpoint] = packet;
    6a4a:	f843 0026 	str.w	r0, [r3, r6, lsl #2]
    6a4e:	4db4      	ldr	r5, [pc, #720]	; (6d20 <usb_isr+0x608>)
    6a50:	e693      	b.n	677a <usb_isr+0x62>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    6a52:	f242 0421 	movw	r4, #8225	; 0x2021
    6a56:	42a1      	cmp	r1, r4
    6a58:	f000 80ad 	beq.w	6bb6 <usb_isr+0x49e>
    6a5c:	f200 810e 	bhi.w	6c7c <usb_isr+0x564>
    6a60:	f5b1 6f08 	cmp.w	r1, #2176	; 0x880
    6a64:	f000 8154 	beq.w	6d10 <usb_isr+0x5f8>
    6a68:	f5b1 6f10 	cmp.w	r1, #2304	; 0x900
    6a6c:	f040 819d 	bne.w	6daa <usb_isr+0x692>
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
    6a70:	4aac      	ldr	r2, [pc, #688]	; (6d24 <usb_isr+0x60c>)
    6a72:	78a9      	ldrb	r1, [r5, #2]
    6a74:	7011      	strb	r1, [r2, #0]
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
			if (table[i].desc & BDT_OWN) {
    6a76:	4dac      	ldr	r5, [pc, #688]	; (6d28 <usb_isr+0x610>)
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    6a78:	2404      	movs	r4, #4
    6a7a:	e002      	b.n	6a82 <usb_isr+0x36a>
    6a7c:	3401      	adds	r4, #1
    6a7e:	2c14      	cmp	r4, #20
    6a80:	d00c      	beq.n	6a9c <usb_isr+0x384>
			if (table[i].desc & BDT_OWN) {
    6a82:	f857 3034 	ldr.w	r3, [r7, r4, lsl #3]
    6a86:	0619      	lsls	r1, r3, #24
    6a88:	d5f8      	bpl.n	6a7c <usb_isr+0x364>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    6a8a:	eb05 03c4 	add.w	r3, r5, r4, lsl #3
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    6a8e:	3401      	adds	r4, #1
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    6a90:	6858      	ldr	r0, [r3, #4]
    6a92:	3808      	subs	r0, #8
    6a94:	f000 fafc 	bl	7090 <usb_free>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    6a98:	2c14      	cmp	r4, #20
    6a9a:	d1f2      	bne.n	6a82 <usb_isr+0x36a>
    6a9c:	49a3      	ldr	r1, [pc, #652]	; (6d2c <usb_isr+0x614>)
    6a9e:	4ba4      	ldr	r3, [pc, #656]	; (6d30 <usb_isr+0x618>)
    6aa0:	4aa4      	ldr	r2, [pc, #656]	; (6d34 <usb_isr+0x61c>)
    6aa2:	9102      	str	r1, [sp, #8]
    6aa4:	49a4      	ldr	r1, [pc, #656]	; (6d38 <usb_isr+0x620>)
    6aa6:	4ca5      	ldr	r4, [pc, #660]	; (6d3c <usb_isr+0x624>)
    6aa8:	4d9d      	ldr	r5, [pc, #628]	; (6d20 <usb_isr+0x608>)
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    6aaa:	9403      	str	r4, [sp, #12]
    6aac:	9605      	str	r6, [sp, #20]
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    6aae:	f04f 0900 	mov.w	r9, #0
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    6ab2:	4688      	mov	r8, r1
    6ab4:	461c      	mov	r4, r3
    6ab6:	4616      	mov	r6, r2
    6ab8:	9504      	str	r5, [sp, #16]
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    6aba:	6820      	ldr	r0, [r4, #0]
			while (p) {
    6abc:	b128      	cbz	r0, 6aca <usb_isr+0x3b2>
				n = p->next;
    6abe:	6845      	ldr	r5, [r0, #4]
				usb_free(p);
    6ac0:	f000 fae6 	bl	7090 <usb_free>
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
			while (p) {
    6ac4:	4628      	mov	r0, r5
    6ac6:	2d00      	cmp	r5, #0
    6ac8:	d1f9      	bne.n	6abe <usb_isr+0x3a6>
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
    6aca:	2300      	movs	r3, #0
    6acc:	6023      	str	r3, [r4, #0]
			rx_last[i] = NULL;
    6ace:	9b04      	ldr	r3, [sp, #16]
			p = tx_first[i];
    6ad0:	6830      	ldr	r0, [r6, #0]
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
    6ad2:	461a      	mov	r2, r3
    6ad4:	2300      	movs	r3, #0
    6ad6:	f842 3029 	str.w	r3, [r2, r9, lsl #2]
			p = tx_first[i];
			while (p) {
    6ada:	b128      	cbz	r0, 6ae8 <usb_isr+0x3d0>
				n = p->next;
    6adc:	6845      	ldr	r5, [r0, #4]
				usb_free(p);
    6ade:	f000 fad7 	bl	7090 <usb_free>
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
			p = tx_first[i];
			while (p) {
    6ae2:	4628      	mov	r0, r5
    6ae4:	2d00      	cmp	r5, #0
    6ae6:	d1f9      	bne.n	6adc <usb_isr+0x3c4>
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    6ae8:	2200      	movs	r2, #0
    6aea:	6032      	str	r2, [r6, #0]
			tx_last[i] = NULL;
    6aec:	9a02      	ldr	r2, [sp, #8]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    6aee:	f898 3000 	ldrb.w	r3, [r8]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    6af2:	4611      	mov	r1, r2
    6af4:	2200      	movs	r2, #0
    6af6:	f841 2b04 	str.w	r2, [r1], #4
			usb_rx_byte_count_data[i] = 0;
    6afa:	9a03      	ldr	r2, [sp, #12]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    6afc:	9102      	str	r1, [sp, #8]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    6afe:	3b02      	subs	r3, #2
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    6b00:	f04f 0100 	mov.w	r1, #0
    6b04:	f822 1019 	strh.w	r1, [r2, r9, lsl #1]
			switch (tx_state[i]) {
    6b08:	2b03      	cmp	r3, #3
    6b0a:	f200 81b4 	bhi.w	6e76 <usb_isr+0x75e>
    6b0e:	e8df f013 	tbh	[pc, r3, lsl #1]
    6b12:	01e2      	.short	0x01e2
    6b14:	01e201ae 	.word	0x01e201ae
    6b18:	01ae      	.short	0x01ae
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    6b1a:	4c89      	ldr	r4, [pc, #548]	; (6d40 <usb_isr+0x628>)
		reply_buffer[1] = 0;
		datalen = 2;
    6b1c:	2002      	movs	r0, #2
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    6b1e:	7022      	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    6b20:	7062      	strb	r2, [r4, #1]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    6b22:	88ea      	ldrh	r2, [r5, #6]
    6b24:	4282      	cmp	r2, r0
    6b26:	f080 820d 	bcs.w	6f44 <usb_isr+0x82c>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    6b2a:	4986      	ldr	r1, [pc, #536]	; (6d44 <usb_isr+0x62c>)
    6b2c:	780d      	ldrb	r5, [r1, #0]
    6b2e:	2a40      	cmp	r2, #64	; 0x40
    6b30:	f045 0e02 	orr.w	lr, r5, #2
    6b34:	4694      	mov	ip, r2
    6b36:	eb07 00ce 	add.w	r0, r7, lr, lsl #3
    6b3a:	bf28      	it	cs
    6b3c:	f04f 0c40 	movcs.w	ip, #64	; 0x40
    6b40:	eb04 030c 	add.w	r3, r4, ip
    6b44:	6044      	str	r4, [r0, #4]
    6b46:	9302      	str	r3, [sp, #8]
    6b48:	ebcc 0002 	rsb	r0, ip, r2
    6b4c:	ea4f 480c 	mov.w	r8, ip, lsl #16
    6b50:	f04f 0901 	mov.w	r9, #1
    6b54:	2200      	movs	r2, #0
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6b56:	24c8      	movs	r4, #200	; 0xc8
    6b58:	ea44 0308 	orr.w	r3, r4, r8
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    6b5c:	f085 0401 	eor.w	r4, r5, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6b60:	f847 303e 	str.w	r3, [r7, lr, lsl #3]
	ep0_tx_data_toggle ^= 1;
    6b64:	7032      	strb	r2, [r6, #0]
	ep0_tx_bdt_bank ^= 1;
    6b66:	700c      	strb	r4, [r1, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6b68:	f8df e1bc 	ldr.w	lr, [pc, #444]	; 6d28 <usb_isr+0x610>
	ep0_tx_data_toggle ^= 1;
    6b6c:	4b76      	ldr	r3, [pc, #472]	; (6d48 <usb_isr+0x630>)
	ep0_tx_bdt_bank ^= 1;
    6b6e:	f8df 81d4 	ldr.w	r8, [pc, #468]	; 6d44 <usb_isr+0x62c>
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    6b72:	2800      	cmp	r0, #0
    6b74:	f040 8120 	bne.w	6db8 <usb_isr+0x6a0>
    6b78:	f1bc 0f40 	cmp.w	ip, #64	; 0x40
    6b7c:	d11b      	bne.n	6bb6 <usb_isr+0x49e>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    6b7e:	f044 0402 	orr.w	r4, r4, #2
    6b82:	eb07 03c4 	add.w	r3, r7, r4, lsl #3
    6b86:	9f02      	ldr	r7, [sp, #8]
    6b88:	f8df e19c 	ldr.w	lr, [pc, #412]	; 6d28 <usb_isr+0x610>
    6b8c:	605f      	str	r7, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6b8e:	2a00      	cmp	r2, #0
    6b90:	f040 8127 	bne.w	6de2 <usb_isr+0x6ca>
    6b94:	0402      	lsls	r2, r0, #16
    6b96:	f042 0288 	orr.w	r2, r2, #136	; 0x88
	ep0_tx_data_toggle ^= 1;
    6b9a:	f886 9000 	strb.w	r9, [r6]
	ep0_tx_bdt_bank ^= 1;
    6b9e:	700d      	strb	r5, [r1, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    6ba0:	4407      	add	r7, r0
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6ba2:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    6ba6:	463b      	mov	r3, r7
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    6ba8:	2840      	cmp	r0, #64	; 0x40
    6baa:	d104      	bne.n	6bb6 <usb_isr+0x49e>
    6bac:	2000      	movs	r0, #0

	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
    6bae:	4a67      	ldr	r2, [pc, #412]	; (6d4c <usb_isr+0x634>)
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    6bb0:	9901      	ldr	r1, [sp, #4]
	ep0_tx_len = datalen;
    6bb2:	8010      	strh	r0, [r2, #0]
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    6bb4:	600b      	str	r3, [r1, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    6bb6:	4a66      	ldr	r2, [pc, #408]	; (6d50 <usb_isr+0x638>)
    6bb8:	2301      	movs	r3, #1
    6bba:	7013      	strb	r3, [r2, #0]
    6bbc:	e6b1      	b.n	6922 <usb_isr+0x20a>
					}
					b->desc = BDT_DESC(packet->len,
						((uint32_t)b & 8) ? DATA1 : DATA0);
				} else {
					//serial_print("tx no packet\n");
					switch (tx_state[endpoint]) {
    6bbe:	5d8b      	ldrb	r3, [r1, r6]
    6bc0:	2b03      	cmp	r3, #3
    6bc2:	f200 8124 	bhi.w	6e0e <usb_isr+0x6f6>
    6bc6:	a201      	add	r2, pc, #4	; (adr r2, 6bcc <usb_isr+0x4b4>)
    6bc8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    6bcc:	000067ad 	.word	0x000067ad
    6bd0:	000067ad 	.word	0x000067ad
    6bd4:	00006cf1 	.word	0x00006cf1
    6bd8:	00006cf7 	.word	0x00006cf7
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
			int i;
			uint32_t *line_coding = NULL;
			switch (setup.wIndex) {
    6bdc:	8892      	ldrh	r2, [r2, #4]
    6bde:	b962      	cbnz	r2, 6bfa <usb_isr+0x4e2>
    6be0:	4a5c      	ldr	r2, [pc, #368]	; (6d54 <usb_isr+0x63c>)
    6be2:	1dcd      	adds	r5, r1, #7
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
					//serial_phex(*buf);
					*dst++ = *buf++;
    6be4:	f811 3b01 	ldrb.w	r3, [r1], #1
    6be8:	f802 3f01 	strb.w	r3, [r2, #1]!
#endif
			}
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
    6bec:	428d      	cmp	r5, r1
    6bee:	d1f9      	bne.n	6be4 <usb_isr+0x4cc>
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    6bf0:	4a59      	ldr	r2, [pc, #356]	; (6d58 <usb_isr+0x640>)
    6bf2:	6812      	ldr	r2, [r2, #0]
    6bf4:	2a86      	cmp	r2, #134	; 0x86
    6bf6:	f000 80c9 	beq.w	6d8c <usb_isr+0x674>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    6bfa:	4952      	ldr	r1, [pc, #328]	; (6d44 <usb_isr+0x62c>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6bfc:	4e52      	ldr	r6, [pc, #328]	; (6d48 <usb_isr+0x630>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    6bfe:	7808      	ldrb	r0, [r1, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6c00:	7832      	ldrb	r2, [r6, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    6c02:	f040 0502 	orr.w	r5, r0, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    6c06:	f080 0001 	eor.w	r0, r0, #1
    6c0a:	7008      	strb	r0, [r1, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    6c0c:	eb07 01c5 	add.w	r1, r7, r5, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6c10:	2a00      	cmp	r2, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    6c12:	f04f 0000 	mov.w	r0, #0
    6c16:	6048      	str	r0, [r1, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    6c18:	f082 0201 	eor.w	r2, r2, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6c1c:	bf0c      	ite	eq
    6c1e:	2188      	moveq	r1, #136	; 0x88
    6c20:	21c8      	movne	r1, #200	; 0xc8
    6c22:	f847 1035 	str.w	r1, [r7, r5, lsl #3]
	ep0_tx_data_toggle ^= 1;
    6c26:	7032      	strb	r2, [r6, #0]
    6c28:	e686      	b.n	6938 <usb_isr+0x220>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    6c2a:	f240 3202 	movw	r2, #770	; 0x302
    6c2e:	4291      	cmp	r1, r2
    6c30:	f040 80b0 	bne.w	6d94 <usb_isr+0x67c>
    6c34:	88a9      	ldrh	r1, [r5, #4]
    6c36:	f001 017f 	and.w	r1, r1, #127	; 0x7f
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
		// TODO: do we need to clear the data toggle here?
		break;
	  case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    6c3a:	2904      	cmp	r1, #4
    6c3c:	f200 80b5 	bhi.w	6daa <usb_isr+0x692>
    6c40:	886a      	ldrh	r2, [r5, #2]
    6c42:	2a00      	cmp	r2, #0
    6c44:	f040 80b1 	bne.w	6daa <usb_isr+0x692>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    6c48:	4c44      	ldr	r4, [pc, #272]	; (6d5c <usb_isr+0x644>)
    6c4a:	0089      	lsls	r1, r1, #2
    6c4c:	440c      	add	r4, r1
    6c4e:	4681      	mov	r9, r0
    6c50:	7821      	ldrb	r1, [r4, #0]
    6c52:	f041 0102 	orr.w	r1, r1, #2
    6c56:	7021      	strb	r1, [r4, #0]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    6c58:	2000      	movs	r0, #0
    6c5a:	9002      	str	r0, [sp, #8]
    6c5c:	4680      	mov	r8, r0
    6c5e:	4684      	mov	ip, r0
    6c60:	4604      	mov	r4, r0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    6c62:	4938      	ldr	r1, [pc, #224]	; (6d44 <usb_isr+0x62c>)
    6c64:	780d      	ldrb	r5, [r1, #0]
    6c66:	f045 0e02 	orr.w	lr, r5, #2
    6c6a:	eb07 03ce 	add.w	r3, r7, lr, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6c6e:	f1b9 0f00 	cmp.w	r9, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    6c72:	605c      	str	r4, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6c74:	bf0c      	ite	eq
    6c76:	2488      	moveq	r4, #136	; 0x88
    6c78:	24c8      	movne	r4, #200	; 0xc8
    6c7a:	e76d      	b.n	6b58 <usb_isr+0x440>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    6c7c:	f242 2421 	movw	r4, #8737	; 0x2221
    6c80:	42a1      	cmp	r1, r4
    6c82:	f040 808e 	bne.w	6da2 <usb_isr+0x68a>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    6c86:	88a9      	ldrh	r1, [r5, #4]
    6c88:	2900      	cmp	r1, #0
    6c8a:	f040 8142 	bne.w	6f12 <usb_isr+0x7fa>
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    6c8e:	4b34      	ldr	r3, [pc, #208]	; (6d60 <usb_isr+0x648>)
    6c90:	4a34      	ldr	r2, [pc, #208]	; (6d64 <usb_isr+0x64c>)
			usb_cdc_line_rtsdtr = setup.wValue;
    6c92:	4c35      	ldr	r4, [pc, #212]	; (6d68 <usb_isr+0x650>)
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    6c94:	681b      	ldr	r3, [r3, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    6c96:	78ad      	ldrb	r5, [r5, #2]
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    6c98:	6013      	str	r3, [r2, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    6c9a:	4681      	mov	r9, r0
    6c9c:	460a      	mov	r2, r1
    6c9e:	7025      	strb	r5, [r4, #0]
    6ca0:	e7da      	b.n	6c58 <usb_isr+0x540>

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    6ca2:	492b      	ldr	r1, [pc, #172]	; (6d50 <usb_isr+0x638>)
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    6ca4:	4b20      	ldr	r3, [pc, #128]	; (6d28 <usb_isr+0x610>)
    6ca6:	4831      	ldr	r0, [pc, #196]	; (6d6c <usb_isr+0x654>)
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    6ca8:	4e26      	ldr	r6, [pc, #152]	; (6d44 <usb_isr+0x62c>)
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    6caa:	f8df c0b0 	ldr.w	ip, [pc, #176]	; 6d5c <usb_isr+0x644>

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    6cae:	4d30      	ldr	r5, [pc, #192]	; (6d70 <usb_isr+0x658>)
		USB0_ISTAT = 0xFF;
    6cb0:	f8df e0d4 	ldr.w	lr, [pc, #212]	; 6d88 <usb_isr+0x670>

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    6cb4:	4f2f      	ldr	r7, [pc, #188]	; (6d74 <usb_isr+0x65c>)

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    6cb6:	2402      	movs	r4, #2
    6cb8:	700c      	strb	r4, [r1, #0]
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    6cba:	4c2f      	ldr	r4, [pc, #188]	; (6d78 <usb_isr+0x660>)
		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    6cbc:	6018      	str	r0, [r3, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    6cbe:	605c      	str	r4, [r3, #4]
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    6cc0:	6098      	str	r0, [r3, #8]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    6cc2:	482e      	ldr	r0, [pc, #184]	; (6d7c <usb_isr+0x664>)
    6cc4:	60d8      	str	r0, [r3, #12]
		table[index(0, TX, EVEN)].desc = 0;
    6cc6:	611a      	str	r2, [r3, #16]
		table[index(0, TX, ODD)].desc = 0;
    6cc8:	619a      	str	r2, [r3, #24]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    6cca:	230d      	movs	r3, #13
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    6ccc:	7032      	strb	r2, [r6, #0]
		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    6cce:	4c2c      	ldr	r4, [pc, #176]	; (6d80 <usb_isr+0x668>)
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    6cd0:	f88c 3000 	strb.w	r3, [ip]

		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
    6cd4:	4e2b      	ldr	r6, [pc, #172]	; (6d84 <usb_isr+0x66c>)

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    6cd6:	23ff      	movs	r3, #255	; 0xff
    6cd8:	702b      	strb	r3, [r5, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    6cda:	2001      	movs	r0, #1
		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    6cdc:	259f      	movs	r5, #159	; 0x9f
		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
		USB0_ISTAT = 0xFF;
    6cde:	f88e 3000 	strb.w	r3, [lr]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    6ce2:	703a      	strb	r2, [r7, #0]

		// enable other interrupts
		USB0_ERREN = 0xFF;
    6ce4:	7033      	strb	r3, [r6, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    6ce6:	7025      	strb	r5, [r4, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    6ce8:	7008      	strb	r0, [r1, #0]
	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
	}

}
    6cea:	b007      	add	sp, #28
    6cec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    6cf0:	2300      	movs	r3, #0
    6cf2:	558b      	strb	r3, [r1, r6]
						break;
    6cf4:	e55a      	b.n	67ac <usb_isr+0x94>
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    6cf6:	2301      	movs	r3, #1
    6cf8:	558b      	strb	r3, [r1, r6]
						break;
    6cfa:	e557      	b.n	67ac <usb_isr+0x94>
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    6cfc:	4917      	ldr	r1, [pc, #92]	; (6d5c <usb_isr+0x644>)
		USB0_ISTAT = USB_ISTAT_STALL;
    6cfe:	4b22      	ldr	r3, [pc, #136]	; (6d88 <usb_isr+0x670>)
    6d00:	2280      	movs	r2, #128	; 0x80
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    6d02:	200d      	movs	r0, #13
    6d04:	7008      	strb	r0, [r1, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    6d06:	701a      	strb	r2, [r3, #0]
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    6d08:	07a2      	lsls	r2, r4, #30
    6d0a:	f57f ae5e 	bpl.w	69ca <usb_isr+0x2b2>
    6d0e:	e655      	b.n	69bc <usb_isr+0x2a4>
			}
#endif
		}
		break;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    6d10:	4a04      	ldr	r2, [pc, #16]	; (6d24 <usb_isr+0x60c>)
    6d12:	4c0b      	ldr	r4, [pc, #44]	; (6d40 <usb_isr+0x628>)
    6d14:	7812      	ldrb	r2, [r2, #0]
    6d16:	7022      	strb	r2, [r4, #0]
    6d18:	e703      	b.n	6b22 <usb_isr+0x40a>
    6d1a:	bf00      	nop
    6d1c:	1fff2c25 	.word	0x1fff2c25
    6d20:	1fff2b54 	.word	0x1fff2b54
    6d24:	1fff2c30 	.word	0x1fff2c30
    6d28:	1fff0000 	.word	0x1fff0000
    6d2c:	1fff2c0c 	.word	0x1fff2c0c
    6d30:	1fff2ba8 	.word	0x1fff2ba8
    6d34:	1fff2bfc 	.word	0x1fff2bfc
    6d38:	1fff2c34 	.word	0x1fff2c34
    6d3c:	1fff2cb0 	.word	0x1fff2cb0
    6d40:	1fff2c28 	.word	0x1fff2c28
    6d44:	1fff2c24 	.word	0x1fff2c24
    6d48:	1fff2bb8 	.word	0x1fff2bb8
    6d4c:	1fff2b64 	.word	0x1fff2b64
    6d50:	40072094 	.word	0x40072094
    6d54:	1fff2cb7 	.word	0x1fff2cb7
    6d58:	1fff2cb8 	.word	0x1fff2cb8
    6d5c:	400720c0 	.word	0x400720c0
    6d60:	1fff2b4c 	.word	0x1fff2b4c
    6d64:	1fff2cc0 	.word	0x1fff2cc0
    6d68:	1fff2c48 	.word	0x1fff2c48
    6d6c:	00400088 	.word	0x00400088
    6d70:	40072088 	.word	0x40072088
    6d74:	40072098 	.word	0x40072098
    6d78:	1fff2b68 	.word	0x1fff2b68
    6d7c:	1fff2bbc 	.word	0x1fff2bbc
    6d80:	40072084 	.word	0x40072084
    6d84:	4007208c 	.word	0x4007208c
    6d88:	40072080 	.word	0x40072080
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    6d8c:	4a75      	ldr	r2, [pc, #468]	; (6f64 <usb_isr+0x84c>)
    6d8e:	210f      	movs	r1, #15
    6d90:	7011      	strb	r1, [r2, #0]
    6d92:	e732      	b.n	6bfa <usb_isr+0x4e2>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    6d94:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
    6d98:	d107      	bne.n	6daa <usb_isr+0x692>
    6d9a:	2200      	movs	r2, #0
    6d9c:	f04f 0901 	mov.w	r9, #1
    6da0:	e75a      	b.n	6c58 <usb_isr+0x540>
    6da2:	f242 3221 	movw	r2, #8993	; 0x2321
    6da6:	4291      	cmp	r1, r2
    6da8:	d0f7      	beq.n	6d9a <usb_isr+0x682>
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    6daa:	4b6f      	ldr	r3, [pc, #444]	; (6f68 <usb_isr+0x850>)
    6dac:	220f      	movs	r2, #15
    6dae:	701a      	strb	r2, [r3, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    6db0:	4a6e      	ldr	r2, [pc, #440]	; (6f6c <usb_isr+0x854>)
    6db2:	2301      	movs	r3, #1
    6db4:	7013      	strb	r3, [r2, #0]
    6db6:	e5b4      	b.n	6922 <usb_isr+0x20a>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
    6db8:	2840      	cmp	r0, #64	; 0x40
    6dba:	f67f aee0 	bls.w	6b7e <usb_isr+0x466>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    6dbe:	f044 0402 	orr.w	r4, r4, #2
    6dc2:	eb0e 01c4 	add.w	r1, lr, r4, lsl #3
    6dc6:	9e02      	ldr	r6, [sp, #8]
    6dc8:	604e      	str	r6, [r1, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6dca:	b1aa      	cbz	r2, 6df8 <usb_isr+0x6e0>
	ep0_tx_data_toggle ^= 1;
    6dcc:	f883 9000 	strb.w	r9, [r3]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6dd0:	4a67      	ldr	r2, [pc, #412]	; (6f70 <usb_isr+0x858>)
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    6dd2:	f888 5000 	strb.w	r5, [r8]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    6dd6:	4633      	mov	r3, r6
    6dd8:	3840      	subs	r0, #64	; 0x40
    6dda:	3340      	adds	r3, #64	; 0x40
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6ddc:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
    6de0:	e6e5      	b.n	6bae <usb_isr+0x496>
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    6de2:	9b02      	ldr	r3, [sp, #8]
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    6de4:	f886 9000 	strb.w	r9, [r6]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6de8:	0402      	lsls	r2, r0, #16
    6dea:	f042 02c8 	orr.w	r2, r2, #200	; 0xc8
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    6dee:	700d      	strb	r5, [r1, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    6df0:	4403      	add	r3, r0
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6df2:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
    6df6:	e6d7      	b.n	6ba8 <usb_isr+0x490>
	ep0_tx_data_toggle ^= 1;
    6df8:	f883 9000 	strb.w	r9, [r3]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    6dfc:	9b02      	ldr	r3, [sp, #8]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6dfe:	4a5d      	ldr	r2, [pc, #372]	; (6f74 <usb_isr+0x85c>)
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    6e00:	f888 5000 	strb.w	r5, [r8]
    6e04:	3840      	subs	r0, #64	; 0x40
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    6e06:	3340      	adds	r3, #64	; 0x40
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6e08:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
    6e0c:	e6cf      	b.n	6bae <usb_isr+0x496>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
						break;
					  default:
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    6e0e:	f019 0f08 	tst.w	r9, #8
    6e12:	bf0c      	ite	eq
    6e14:	2302      	moveq	r3, #2
    6e16:	2303      	movne	r3, #3
    6e18:	558b      	strb	r3, [r1, r6]
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
    6e1a:	e4c7      	b.n	67ac <usb_isr+0x94>
    6e1c:	88a9      	ldrh	r1, [r5, #4]
    6e1e:	f001 017f 	and.w	r1, r1, #127	; 0x7f
		data = reply_buffer;
		datalen = 2;
		break;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    6e22:	2904      	cmp	r1, #4
    6e24:	d8c1      	bhi.n	6daa <usb_isr+0x692>
    6e26:	886a      	ldrh	r2, [r5, #2]
    6e28:	2a00      	cmp	r2, #0
    6e2a:	d1be      	bne.n	6daa <usb_isr+0x692>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    6e2c:	4c4e      	ldr	r4, [pc, #312]	; (6f68 <usb_isr+0x850>)
    6e2e:	0089      	lsls	r1, r1, #2
    6e30:	440c      	add	r4, r1
    6e32:	4681      	mov	r9, r0
    6e34:	7821      	ldrb	r1, [r4, #0]
    6e36:	f021 0102 	bic.w	r1, r1, #2
    6e3a:	7021      	strb	r1, [r4, #0]
    6e3c:	e70c      	b.n	6c58 <usb_isr+0x540>
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
    6e3e:	4a4e      	ldr	r2, [pc, #312]	; (6f78 <usb_isr+0x860>)
    6e40:	6854      	ldr	r4, [r2, #4]
    6e42:	2c00      	cmp	r4, #0
    6e44:	d0b1      	beq.n	6daa <usb_isr+0x692>
    6e46:	8868      	ldrh	r0, [r5, #2]
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    6e48:	f8b5 e004 	ldrh.w	lr, [r5, #4]
    6e4c:	e003      	b.n	6e56 <usb_isr+0x73e>
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
    6e4e:	320c      	adds	r2, #12
			if (list->addr == NULL) break;
    6e50:	6854      	ldr	r4, [r2, #4]
    6e52:	2c00      	cmp	r4, #0
    6e54:	d0a9      	beq.n	6daa <usb_isr+0x692>
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    6e56:	8813      	ldrh	r3, [r2, #0]
    6e58:	4283      	cmp	r3, r0
    6e5a:	d1f8      	bne.n	6e4e <usb_isr+0x736>
    6e5c:	8853      	ldrh	r3, [r2, #2]
    6e5e:	4573      	cmp	r3, lr
    6e60:	d1f5      	bne.n	6e4e <usb_isr+0x736>
				data = list->addr;
				if ((setup.wValue >> 8) == 3) {
    6e62:	0a00      	lsrs	r0, r0, #8
    6e64:	2803      	cmp	r0, #3
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    6e66:	bf0c      	ite	eq
    6e68:	7820      	ldrbeq	r0, [r4, #0]
				} else {
					datalen = list->length;
    6e6a:	8910      	ldrhne	r0, [r2, #8]
    6e6c:	e659      	b.n	6b22 <usb_isr+0x40a>
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    6e6e:	f04f 0301 	mov.w	r3, #1
    6e72:	f888 3000 	strb.w	r3, [r8]
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
    6e76:	f109 0901 	add.w	r9, r9, #1
    6e7a:	f1b9 0f04 	cmp.w	r9, #4
    6e7e:	f104 0404 	add.w	r4, r4, #4
    6e82:	f106 0604 	add.w	r6, r6, #4
    6e86:	f108 0801 	add.w	r8, r8, #1
    6e8a:	f47f ae16 	bne.w	6aba <usb_isr+0x3a2>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    6e8e:	4b3b      	ldr	r3, [pc, #236]	; (6f7c <usb_isr+0x864>)
    6e90:	9e05      	ldr	r6, [sp, #20]
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
    6e92:	4d3b      	ldr	r5, [pc, #236]	; (6f80 <usb_isr+0x868>)
		cfg = usb_endpoint_config_table;
    6e94:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 6f88 <usb_isr+0x870>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    6e98:	2000      	movs	r0, #0
    6e9a:	7018      	strb	r0, [r3, #0]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    6e9c:	f04f 0901 	mov.w	r9, #1
			epconf = *cfg++;
    6ea0:	f818 3b01 	ldrb.w	r3, [r8], #1
			*reg = epconf;
    6ea4:	f805 3b04 	strb.w	r3, [r5], #4
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    6ea8:	071a      	lsls	r2, r3, #28
    6eaa:	d419      	bmi.n	6ee0 <usb_isr+0x7c8>
    6eac:	ea4f 0489 	mov.w	r4, r9, lsl #2
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    6eb0:	f044 0202 	orr.w	r2, r4, #2
			table[index(i, TX, ODD)].desc = 0;
    6eb4:	f044 0403 	orr.w	r4, r4, #3
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    6eb8:	2300      	movs	r3, #0
    6eba:	f847 3032 	str.w	r3, [r7, r2, lsl #3]
			table[index(i, TX, ODD)].desc = 0;
    6ebe:	f847 3034 	str.w	r3, [r7, r4, lsl #3]
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    6ec2:	4b30      	ldr	r3, [pc, #192]	; (6f84 <usb_isr+0x86c>)
    6ec4:	429d      	cmp	r5, r3
    6ec6:	f109 0901 	add.w	r9, r9, #1
    6eca:	d1e9      	bne.n	6ea0 <usb_isr+0x788>
    6ecc:	f896 9000 	ldrb.w	r9, [r6]
    6ed0:	f089 0201 	eor.w	r2, r9, #1
    6ed4:	e6c0      	b.n	6c58 <usb_isr+0x540>
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
			  case TX_STATE_EVEN_FREE:
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    6ed6:	f04f 0300 	mov.w	r3, #0
    6eda:	f888 3000 	strb.w	r3, [r8]
    6ede:	e7ca      	b.n	6e76 <usb_isr+0x75e>
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
    6ee0:	f000 f8b6 	bl	7050 <usb_malloc>
				if (p) {
    6ee4:	b318      	cbz	r0, 6f2e <usb_isr+0x816>
					table[index(i, RX, EVEN)].addr = p->buf;
    6ee6:	eb07 1349 	add.w	r3, r7, r9, lsl #5
    6eea:	ea4f 0489 	mov.w	r4, r9, lsl #2
    6eee:	3008      	adds	r0, #8
    6ef0:	6058      	str	r0, [r3, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    6ef2:	4b20      	ldr	r3, [pc, #128]	; (6f74 <usb_isr+0x85c>)
    6ef4:	f847 3034 	str.w	r3, [r7, r4, lsl #3]
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
    6ef8:	f000 f8aa 	bl	7050 <usb_malloc>
				if (p) {
    6efc:	b168      	cbz	r0, 6f1a <usb_isr+0x802>
					table[index(i, RX, ODD)].addr = p->buf;
    6efe:	f044 0301 	orr.w	r3, r4, #1
    6f02:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
    6f06:	3008      	adds	r0, #8
    6f08:	6050      	str	r0, [r2, #4]
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    6f0a:	4a19      	ldr	r2, [pc, #100]	; (6f70 <usb_isr+0x858>)
    6f0c:	f847 2033 	str.w	r2, [r7, r3, lsl #3]
    6f10:	e7ce      	b.n	6eb0 <usb_isr+0x798>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    6f12:	4681      	mov	r9, r0
    6f14:	e6a0      	b.n	6c58 <usb_isr+0x540>
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
		data = reply_buffer;
		datalen = 2;
    6f16:	2002      	movs	r0, #2
    6f18:	e603      	b.n	6b22 <usb_isr+0x40a>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
    6f1a:	4b18      	ldr	r3, [pc, #96]	; (6f7c <usb_isr+0x864>)
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    6f1c:	f044 0201 	orr.w	r2, r4, #1
					usb_rx_memory_needed++;
    6f20:	781b      	ldrb	r3, [r3, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    6f22:	f847 0032 	str.w	r0, [r7, r2, lsl #3]
					usb_rx_memory_needed++;
    6f26:	4a15      	ldr	r2, [pc, #84]	; (6f7c <usb_isr+0x864>)
    6f28:	3301      	adds	r3, #1
    6f2a:	7013      	strb	r3, [r2, #0]
    6f2c:	e7c0      	b.n	6eb0 <usb_isr+0x798>
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
    6f2e:	4b13      	ldr	r3, [pc, #76]	; (6f7c <usb_isr+0x864>)
    6f30:	4a12      	ldr	r2, [pc, #72]	; (6f7c <usb_isr+0x864>)
    6f32:	781b      	ldrb	r3, [r3, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    6f34:	ea4f 0489 	mov.w	r4, r9, lsl #2
					usb_rx_memory_needed++;
    6f38:	3301      	adds	r3, #1
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    6f3a:	f847 0034 	str.w	r0, [r7, r4, lsl #3]
					usb_rx_memory_needed++;
    6f3e:	7013      	strb	r3, [r2, #0]
    6f40:	e7da      	b.n	6ef8 <usb_isr+0x7e0>


void _reboot_Teensyduino_(void)
{
	// TODO: initialize R0 with a code....
	__asm__ volatile("bkpt");
    6f42:	be00      	bkpt	0x0000
    6f44:	2840      	cmp	r0, #64	; 0x40
    6f46:	4684      	mov	ip, r0
    6f48:	bf28      	it	cs
    6f4a:	f04f 0c40 	movcs.w	ip, #64	; 0x40
    6f4e:	eb04 030c 	add.w	r3, r4, ip
    6f52:	ebcc 0000 	rsb	r0, ip, r0
    6f56:	ea4f 480c 	mov.w	r8, ip, lsl #16
    6f5a:	9302      	str	r3, [sp, #8]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    6f5c:	2200      	movs	r2, #0
    6f5e:	f04f 0901 	mov.w	r9, #1
    6f62:	e67e      	b.n	6c62 <usb_isr+0x54a>
    6f64:	1fff2bb9 	.word	0x1fff2bb9
    6f68:	400720c0 	.word	0x400720c0
    6f6c:	40072094 	.word	0x40072094
    6f70:	004000c8 	.word	0x004000c8
    6f74:	00400088 	.word	0x00400088
    6f78:	0000aee4 	.word	0x0000aee4
    6f7c:	1fff2c25 	.word	0x1fff2c25
    6f80:	400720c4 	.word	0x400720c4
    6f84:	400720d4 	.word	0x400720d4
    6f88:	0000aee0 	.word	0x0000aee0

00006f8c <usb_init>:
}



void usb_init(void)
{
    6f8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    6f8e:	f000 fc03 	bl	7798 <usb_init_serialnumber>

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    6f92:	2300      	movs	r3, #0
    6f94:	4924      	ldr	r1, [pc, #144]	; (7028 <usb_init+0x9c>)
		table[i].desc = 0;
    6f96:	461a      	mov	r2, r3
		table[i].addr = 0;
    6f98:	eb01 00c3 	add.w	r0, r1, r3, lsl #3
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
		table[i].desc = 0;
    6f9c:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    6fa0:	3301      	adds	r3, #1
    6fa2:	2b14      	cmp	r3, #20
		table[i].desc = 0;
		table[i].addr = 0;
    6fa4:	6042      	str	r2, [r0, #4]
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
		table[i].desc = 0;
    6fa6:	f04f 0400 	mov.w	r4, #0
    6faa:	481f      	ldr	r0, [pc, #124]	; (7028 <usb_init+0x9c>)
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    6fac:	d1f4      	bne.n	6f98 <usb_init+0xc>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    6fae:	491f      	ldr	r1, [pc, #124]	; (702c <usb_init+0xa0>)
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    6fb0:	4a1f      	ldr	r2, [pc, #124]	; (7030 <usb_init+0xa4>)
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    6fb2:	680b      	ldr	r3, [r1, #0]
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
#endif
#if F_CPU == 180000000 || F_CPU == 216000000 || F_CPU == 256000000
	// if using IRC48M, turn on the USB clock recovery hardware
	USB0_CLK_RECOVER_IRC_EN = USB_CLK_RECOVER_IRC_EN_IRC_EN | USB_CLK_RECOVER_IRC_EN_REG_EN;
    6fb4:	f8df c090 	ldr.w	ip, [pc, #144]	; 7048 <usb_init+0xbc>
	USB0_CLK_RECOVER_CTRL = USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN |
    6fb8:	4e1e      	ldr	r6, [pc, #120]	; (7034 <usb_init+0xa8>)
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    6fba:	4f1f      	ldr	r7, [pc, #124]	; (7038 <usb_init+0xac>)
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    6fbc:	4d1f      	ldr	r5, [pc, #124]	; (703c <usb_init+0xb0>)

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    6fbe:	f8df e08c 	ldr.w	lr, [pc, #140]	; 704c <usb_init+0xc0>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    6fc2:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    6fc6:	600b      	str	r3, [r1, #0]
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    6fc8:	6813      	ldr	r3, [r2, #0]
    6fca:	f043 7340 	orr.w	r3, r3, #50331648	; 0x3000000
    6fce:	6013      	str	r3, [r2, #0]
#endif
#if F_CPU == 180000000 || F_CPU == 216000000 || F_CPU == 256000000
	// if using IRC48M, turn on the USB clock recovery hardware
	USB0_CLK_RECOVER_IRC_EN = USB_CLK_RECOVER_IRC_EN_IRC_EN | USB_CLK_RECOVER_IRC_EN_REG_EN;
    6fd0:	2303      	movs	r3, #3
    6fd2:	f88c 3000 	strb.w	r3, [ip]
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    6fd6:	f501 3128 	add.w	r1, r1, #172032	; 0x2a000
	MPU_RGDAAC0 |= 0x03000000;
#endif
#if F_CPU == 180000000 || F_CPU == 216000000 || F_CPU == 256000000
	// if using IRC48M, turn on the USB clock recovery hardware
	USB0_CLK_RECOVER_IRC_EN = USB_CLK_RECOVER_IRC_EN_IRC_EN | USB_CLK_RECOVER_IRC_EN_REG_EN;
	USB0_CLK_RECOVER_CTRL = USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN |
    6fda:	23a0      	movs	r3, #160	; 0xa0
    6fdc:	7033      	strb	r3, [r6, #0]
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    6fde:	317c      	adds	r1, #124	; 0x7c
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    6fe0:	f502 22c9 	add.w	r2, r2, #411648	; 0x64800
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    6fe4:	f3c0 2307 	ubfx	r3, r0, #8, #8
    6fe8:	703b      	strb	r3, [r7, #0]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    6fea:	3210      	adds	r2, #16
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    6fec:	f3c0 4307 	ubfx	r3, r0, #16, #8
    6ff0:	700b      	strb	r3, [r1, #0]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    6ff2:	0e00      	lsrs	r0, r0, #24

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    6ff4:	23ff      	movs	r3, #255	; 0xff
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    6ff6:	7028      	strb	r0, [r5, #0]

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    6ff8:	f88e 3000 	strb.w	r3, [lr]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    6ffc:	4d10      	ldr	r5, [pc, #64]	; (7040 <usb_init+0xb4>)
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
    6ffe:	f80c 3cbc 	strb.w	r3, [ip, #-188]
	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    7002:	4810      	ldr	r0, [pc, #64]	; (7044 <usb_init+0xb8>)
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    7004:	7013      	strb	r3, [r2, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    7006:	2301      	movs	r3, #1
    7008:	f806 3cac 	strb.w	r3, [r6, #-172]
	USB0_USBCTRL = 0;
    700c:	f881 4050 	strb.w	r4, [r1, #80]	; 0x50

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    7010:	2670      	movs	r6, #112	; 0x70
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    7012:	f44f 1400 	mov.w	r4, #2097152	; 0x200000

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    7016:	2110      	movs	r1, #16
	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    7018:	f807 3c18 	strb.w	r3, [r7, #-24]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    701c:	702e      	strb	r6, [r5, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    701e:	6004      	str	r4, [r0, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    7020:	f882 10f8 	strb.w	r1, [r2, #248]	; 0xf8
    7024:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7026:	bf00      	nop
    7028:	1fff0000 	.word	0x1fff0000
    702c:	40048034 	.word	0x40048034
    7030:	4000d800 	.word	0x4000d800
    7034:	40072140 	.word	0x40072140
    7038:	4007209c 	.word	0x4007209c
    703c:	400720b4 	.word	0x400720b4
    7040:	e000e435 	.word	0xe000e435
    7044:	e000e104 	.word	0xe000e104
    7048:	40072144 	.word	0x40072144
    704c:	40072080 	.word	0x40072080

00007050 <usb_malloc>:
usb_packet_t * usb_malloc(void)
{
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    7050:	b672      	cpsid	i
	avail = usb_buffer_available;
    7052:	480d      	ldr	r0, [pc, #52]	; (7088 <usb_malloc+0x38>)
    7054:	6802      	ldr	r2, [r0, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    7056:	fab2 f382 	clz	r3, r2
	if (n >= NUM_USB_BUFFERS) {
    705a:	2b0b      	cmp	r3, #11
    705c:	dc10      	bgt.n	7080 <usb_malloc+0x30>
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    705e:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    7062:	40d9      	lsrs	r1, r3
    7064:	ea22 0201 	bic.w	r2, r2, r1
    7068:	6002      	str	r2, [r0, #0]
	__enable_irq();
    706a:	b662      	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    706c:	4807      	ldr	r0, [pc, #28]	; (708c <usb_malloc+0x3c>)
    706e:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
    7072:	00db      	lsls	r3, r3, #3
    7074:	18c2      	adds	r2, r0, r3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    7076:	2100      	movs	r1, #0
    7078:	50c1      	str	r1, [r0, r3]
	*(uint32_t *)(p + 4) = 0;
	return (usb_packet_t *)p;
    707a:	4610      	mov	r0, r2
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
	*(uint32_t *)(p + 4) = 0;
    707c:	6051      	str	r1, [r2, #4]
	return (usb_packet_t *)p;
}
    707e:	4770      	bx	lr

	__disable_irq();
	avail = usb_buffer_available;
	n = __builtin_clz(avail); // clz = count leading zeros
	if (n >= NUM_USB_BUFFERS) {
		__enable_irq();
    7080:	b662      	cpsie	i
		return NULL;
    7082:	2000      	movs	r0, #0
    7084:	4770      	bx	lr
    7086:	bf00      	nop
    7088:	1fff0b28 	.word	0x1fff0b28
    708c:	1fff03d0 	.word	0x1fff03d0

00007090 <usb_free>:
void usb_free(usb_packet_t *p)
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    7090:	4b0d      	ldr	r3, [pc, #52]	; (70c8 <usb_free+0x38>)
    7092:	4a0e      	ldr	r2, [pc, #56]	; (70cc <usb_free+0x3c>)
    7094:	1ac3      	subs	r3, r0, r3
    7096:	fba2 2303 	umull	r2, r3, r2, r3
    709a:	091b      	lsrs	r3, r3, #4
	if (n >= NUM_USB_BUFFERS) return;
    709c:	2b0b      	cmp	r3, #11
    709e:	d80c      	bhi.n	70ba <usb_free+0x2a>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    70a0:	4a0b      	ldr	r2, [pc, #44]	; (70d0 <usb_free+0x40>)
    70a2:	7812      	ldrb	r2, [r2, #0]
    70a4:	b952      	cbnz	r2, 70bc <usb_free+0x2c>
		usb_rx_memory(p);
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    70a6:	b672      	cpsid	i
	usb_buffer_available |= mask;
    70a8:	480a      	ldr	r0, [pc, #40]	; (70d4 <usb_free+0x44>)
    70aa:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    70ae:	6802      	ldr	r2, [r0, #0]
    70b0:	fa21 f303 	lsr.w	r3, r1, r3
    70b4:	431a      	orrs	r2, r3
    70b6:	6002      	str	r2, [r0, #0]
	__enable_irq();
    70b8:	b662      	cpsie	i
    70ba:	4770      	bx	lr
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    70bc:	4a06      	ldr	r2, [pc, #24]	; (70d8 <usb_free+0x48>)
    70be:	7812      	ldrb	r2, [r2, #0]
    70c0:	2a00      	cmp	r2, #0
    70c2:	d0f0      	beq.n	70a6 <usb_free+0x16>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    70c4:	f7ff baa4 	b.w	6610 <usb_rx_memory>
    70c8:	1fff03d0 	.word	0x1fff03d0
    70cc:	38e38e39 	.word	0x38e38e39
    70d0:	1fff2c25 	.word	0x1fff2c25
    70d4:	1fff0b28 	.word	0x1fff0b28
    70d8:	1fff2c30 	.word	0x1fff2c30

000070dc <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    70dc:	b538      	push	{r3, r4, r5, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    70de:	4d0f      	ldr	r5, [pc, #60]	; (711c <usb_serial_getchar+0x40>)
    70e0:	6828      	ldr	r0, [r5, #0]
    70e2:	b178      	cbz	r0, 7104 <usb_serial_getchar+0x28>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    70e4:	8843      	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
    70e6:	8802      	ldrh	r2, [r0, #0]
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    70e8:	18c1      	adds	r1, r0, r3
    70ea:	3301      	adds	r3, #1
	if (i >= rx_packet->len) {
    70ec:	4293      	cmp	r3, r2
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    70ee:	7a0c      	ldrb	r4, [r1, #8]
	if (i >= rx_packet->len) {
    70f0:	d202      	bcs.n	70f8 <usb_serial_getchar+0x1c>
		usb_free(rx_packet);
		rx_packet = NULL;
	} else {
		rx_packet->index = i;
    70f2:	8043      	strh	r3, [r0, #2]
	}
	return c;
    70f4:	4620      	mov	r0, r4
}
    70f6:	bd38      	pop	{r3, r4, r5, pc}
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
    70f8:	f7ff ffca 	bl	7090 <usb_free>
		rx_packet = NULL;
    70fc:	2300      	movs	r3, #0
	} else {
		rx_packet->index = i;
	}
	return c;
    70fe:	4620      	mov	r0, r4
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
		rx_packet = NULL;
    7100:	602b      	str	r3, [r5, #0]
    7102:	bd38      	pop	{r3, r4, r5, pc}
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    7104:	4b06      	ldr	r3, [pc, #24]	; (7120 <usb_serial_getchar+0x44>)
    7106:	781b      	ldrb	r3, [r3, #0]
    7108:	b12b      	cbz	r3, 7116 <usb_serial_getchar+0x3a>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    710a:	2003      	movs	r0, #3
    710c:	f7ff fa4c 	bl	65a8 <usb_rx>
    7110:	6028      	str	r0, [r5, #0]
		if (!rx_packet) return -1;
    7112:	2800      	cmp	r0, #0
    7114:	d1e6      	bne.n	70e4 <usb_serial_getchar+0x8>
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    7116:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    711a:	bd38      	pop	{r3, r4, r5, pc}
    711c:	1fff2c44 	.word	0x1fff2c44
    7120:	1fff2c30 	.word	0x1fff2c30

00007124 <usb_serial_peekchar>:
	return c;
}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    7124:	b510      	push	{r4, lr}
	if (!rx_packet) {
    7126:	4c09      	ldr	r4, [pc, #36]	; (714c <usb_serial_peekchar+0x28>)
    7128:	6820      	ldr	r0, [r4, #0]
    712a:	b118      	cbz	r0, 7134 <usb_serial_peekchar+0x10>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
	return rx_packet->buf[rx_packet->index];
    712c:	8843      	ldrh	r3, [r0, #2]
    712e:	4418      	add	r0, r3
    7130:	7a00      	ldrb	r0, [r0, #8]
}
    7132:	bd10      	pop	{r4, pc}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    7134:	4b06      	ldr	r3, [pc, #24]	; (7150 <usb_serial_peekchar+0x2c>)
    7136:	781b      	ldrb	r3, [r3, #0]
    7138:	b12b      	cbz	r3, 7146 <usb_serial_peekchar+0x22>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    713a:	2003      	movs	r0, #3
    713c:	f7ff fa34 	bl	65a8 <usb_rx>
    7140:	6020      	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    7142:	2800      	cmp	r0, #0
    7144:	d1f2      	bne.n	712c <usb_serial_peekchar+0x8>

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    7146:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    714a:	bd10      	pop	{r4, pc}
    714c:	1fff2c44 	.word	0x1fff2c44
    7150:	1fff2c30 	.word	0x1fff2c30

00007154 <usb_serial_available>:
// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    7154:	4b04      	ldr	r3, [pc, #16]	; (7168 <usb_serial_available+0x14>)
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    7156:	4a05      	ldr	r2, [pc, #20]	; (716c <usb_serial_available+0x18>)
    7158:	681b      	ldr	r3, [r3, #0]

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    715a:	8890      	ldrh	r0, [r2, #4]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    715c:	b11b      	cbz	r3, 7166 <usb_serial_available+0x12>
    715e:	881a      	ldrh	r2, [r3, #0]
    7160:	885b      	ldrh	r3, [r3, #2]
    7162:	1ad3      	subs	r3, r2, r3
    7164:	4418      	add	r0, r3
	return count;
}
    7166:	4770      	bx	lr
    7168:	1fff2c44 	.word	0x1fff2c44
    716c:	1fff2cb0 	.word	0x1fff2cb0

00007170 <usb_serial_flush_input>:
// discard any buffered input
void usb_serial_flush_input(void)
{
	usb_packet_t *rx;

	if (!usb_configuration) return;
    7170:	4b0b      	ldr	r3, [pc, #44]	; (71a0 <usb_serial_flush_input+0x30>)
    7172:	781b      	ldrb	r3, [r3, #0]
    7174:	b19b      	cbz	r3, 719e <usb_serial_flush_input+0x2e>
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    7176:	b510      	push	{r4, lr}
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
    7178:	4c0a      	ldr	r4, [pc, #40]	; (71a4 <usb_serial_flush_input+0x34>)
    717a:	6820      	ldr	r0, [r4, #0]
    717c:	b148      	cbz	r0, 7192 <usb_serial_flush_input+0x22>
		usb_free(rx_packet);
    717e:	f7ff ff87 	bl	7090 <usb_free>
		rx_packet = NULL;
    7182:	2300      	movs	r3, #0
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    7184:	2003      	movs	r0, #3
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
    7186:	6023      	str	r3, [r4, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    7188:	f7ff fa0e 	bl	65a8 <usb_rx>
		if (!rx) break;
    718c:	b130      	cbz	r0, 719c <usb_serial_flush_input+0x2c>
		usb_free(rx);
    718e:	f7ff ff7f 	bl	7090 <usb_free>
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    7192:	2003      	movs	r0, #3
    7194:	f7ff fa08 	bl	65a8 <usb_rx>
		if (!rx) break;
    7198:	2800      	cmp	r0, #0
    719a:	d1f8      	bne.n	718e <usb_serial_flush_input+0x1e>
    719c:	bd10      	pop	{r4, pc}
    719e:	4770      	bx	lr
    71a0:	1fff2c30 	.word	0x1fff2c30
    71a4:	1fff2c44 	.word	0x1fff2c44

000071a8 <usb_serial_write>:
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    71a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    71ac:	f8df 90f8 	ldr.w	r9, [pc, #248]	; 72a8 <usb_serial_write+0x100>
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    71b0:	b083      	sub	sp, #12
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    71b2:	2201      	movs	r2, #1
    71b4:	f889 2000 	strb.w	r2, [r9]
	while (size > 0) {
    71b8:	9101      	str	r1, [sp, #4]
    71ba:	b369      	cbz	r1, 7218 <usb_serial_write+0x70>
    71bc:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 72ac <usb_serial_write+0x104>
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    71c0:	4f35      	ldr	r7, [pc, #212]	; (7298 <usb_serial_write+0xf0>)
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    71c2:	9e01      	ldr	r6, [sp, #4]
    71c4:	4683      	mov	fp, r0
		if (!tx_packet) {
    71c6:	f8d8 0000 	ldr.w	r0, [r8]
    71ca:	b3b0      	cbz	r0, 723a <usb_serial_write+0x92>
    71cc:	4d33      	ldr	r5, [pc, #204]	; (729c <usb_serial_write+0xf4>)
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
    71ce:	8844      	ldrh	r4, [r0, #2]
    71d0:	f1c4 0140 	rsb	r1, r4, #64	; 0x40
    71d4:	42b1      	cmp	r1, r6
    71d6:	bf28      	it	cs
    71d8:	4631      	movcs	r1, r6
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    71da:	eb04 0e01 	add.w	lr, r4, r1
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    71de:	2200      	movs	r2, #0
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    71e0:	fa1f fe8e 	uxth.w	lr, lr
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    71e4:	702a      	strb	r2, [r5, #0]
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
    71e6:	1a76      	subs	r6, r6, r1
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    71e8:	f8a0 e002 	strh.w	lr, [r0, #2]
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
    71ec:	f100 0208 	add.w	r2, r0, #8
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
    71f0:	b151      	cbz	r1, 7208 <usb_serial_write+0x60>
    71f2:	3c01      	subs	r4, #1
    71f4:	4422      	add	r2, r4
    71f6:	4459      	add	r1, fp
    71f8:	f81b 4b01 	ldrb.w	r4, [fp], #1
    71fc:	f802 4f01 	strb.w	r4, [r2, #1]!
    7200:	458b      	cmp	fp, r1
    7202:	d1f9      	bne.n	71f8 <usb_serial_write+0x50>
    7204:	f8b0 e002 	ldrh.w	lr, [r0, #2]
		if (tx_packet->index >= CDC_TX_SIZE) {
    7208:	f1be 0f3f 	cmp.w	lr, #63	; 0x3f
    720c:	d80b      	bhi.n	7226 <usb_serial_write+0x7e>
			tx_packet->len = CDC_TX_SIZE;
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    720e:	4a24      	ldr	r2, [pc, #144]	; (72a0 <usb_serial_write+0xf8>)
    7210:	2105      	movs	r1, #5
    7212:	7011      	strb	r1, [r2, #0]
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    7214:	2e00      	cmp	r6, #0
    7216:	d1d6      	bne.n	71c6 <usb_serial_write+0x1e>
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
    7218:	9801      	ldr	r0, [sp, #4]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
    721a:	2300      	movs	r3, #0
    721c:	f889 3000 	strb.w	r3, [r9]
	return ret;
}
    7220:	b003      	add	sp, #12
    7222:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
		if (tx_packet->index >= CDC_TX_SIZE) {
			tx_packet->len = CDC_TX_SIZE;
    7226:	2240      	movs	r2, #64	; 0x40
    7228:	8002      	strh	r2, [r0, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    722a:	4601      	mov	r1, r0
    722c:	2004      	movs	r0, #4
    722e:	f7ff fa31 	bl	6694 <usb_tx>
			tx_packet = NULL;
    7232:	2200      	movs	r2, #0
    7234:	f8c8 2000 	str.w	r2, [r8]
    7238:	e7e9      	b.n	720e <usb_serial_write+0x66>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    723a:	783a      	ldrb	r2, [r7, #0]
    723c:	b322      	cbz	r2, 7288 <usb_serial_write+0xe0>
    723e:	4c19      	ldr	r4, [pc, #100]	; (72a4 <usb_serial_write+0xfc>)
    7240:	4d16      	ldr	r5, [pc, #88]	; (729c <usb_serial_write+0xf4>)
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
    7242:	f04f 0a01 	mov.w	sl, #1
    7246:	e007      	b.n	7258 <usb_serial_write+0xb0>
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    7248:	3c01      	subs	r4, #1
    724a:	d016      	beq.n	727a <usb_serial_write+0xd2>
    724c:	782a      	ldrb	r2, [r5, #0]
    724e:	b9a2      	cbnz	r2, 727a <usb_serial_write+0xd2>
					transmit_previous_timeout = 1;
					return -1;
				}
				yield();
    7250:	f000 f95a 	bl	7508 <yield>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    7254:	783a      	ldrb	r2, [r7, #0]
    7256:	b1ba      	cbz	r2, 7288 <usb_serial_write+0xe0>
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    7258:	2004      	movs	r0, #4
    725a:	f7ff f9c3 	bl	65e4 <usb_tx_packet_count>
    725e:	2807      	cmp	r0, #7
    7260:	d8f2      	bhi.n	7248 <usb_serial_write+0xa0>
					tx_noautoflush = 1;
    7262:	f889 a000 	strb.w	sl, [r9]
					tx_packet = usb_malloc();
    7266:	f7ff fef3 	bl	7050 <usb_malloc>
    726a:	f8c8 0000 	str.w	r0, [r8]
					if (tx_packet) break;
    726e:	2800      	cmp	r0, #0
    7270:	d1ad      	bne.n	71ce <usb_serial_write+0x26>
					tx_noautoflush = 0;
    7272:	4b0d      	ldr	r3, [pc, #52]	; (72a8 <usb_serial_write+0x100>)
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    7274:	3c01      	subs	r4, #1
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
    7276:	7018      	strb	r0, [r3, #0]
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    7278:	d1e8      	bne.n	724c <usb_serial_write+0xa4>
					transmit_previous_timeout = 1;
    727a:	2301      	movs	r3, #1
					return -1;
    727c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
					transmit_previous_timeout = 1;
    7280:	702b      	strb	r3, [r5, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    7282:	b003      	add	sp, #12
    7284:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    7288:	2300      	movs	r3, #0
					return -1;
    728a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    728e:	f889 3000 	strb.w	r3, [r9]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    7292:	b003      	add	sp, #12
    7294:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7298:	1fff2c30 	.word	0x1fff2c30
    729c:	1fff2c40 	.word	0x1fff2c40
    72a0:	1fff2c38 	.word	0x1fff2c38
    72a4:	00014821 	.word	0x00014821
    72a8:	1fff2c39 	.word	0x1fff2c39
    72ac:	1fff2c3c 	.word	0x1fff2c3c

000072b0 <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    72b0:	b500      	push	{lr}
    72b2:	b083      	sub	sp, #12
    72b4:	ab02      	add	r3, sp, #8
	return usb_serial_write(&c, 1);
    72b6:	2101      	movs	r1, #1
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    72b8:	f803 0d01 	strb.w	r0, [r3, #-1]!
	return usb_serial_write(&c, 1);
    72bc:	4618      	mov	r0, r3
    72be:	f7ff ff73 	bl	71a8 <usb_serial_write>
}
    72c2:	b003      	add	sp, #12
    72c4:	f85d fb04 	ldr.w	pc, [sp], #4

000072c8 <usb_serial_write_buffer_free>:
	tx_noautoflush = 0;
	return ret;
}

int usb_serial_write_buffer_free(void)
{
    72c8:	b538      	push	{r3, r4, r5, lr}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
    72ca:	4d0e      	ldr	r5, [pc, #56]	; (7304 <usb_serial_write_buffer_free+0x3c>)

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    72cc:	4c0e      	ldr	r4, [pc, #56]	; (7308 <usb_serial_write_buffer_free+0x40>)
	if (!tx_packet) {
    72ce:	6828      	ldr	r0, [r5, #0]

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    72d0:	2301      	movs	r3, #1
    72d2:	7023      	strb	r3, [r4, #0]
	if (!tx_packet) {
    72d4:	b128      	cbz	r0, 72e2 <usb_serial_write_buffer_free+0x1a>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    72d6:	8840      	ldrh	r0, [r0, #2]
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    72d8:	2300      	movs	r3, #0
    72da:	7023      	strb	r3, [r4, #0]
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    72dc:	f1c0 0040 	rsb	r0, r0, #64	; 0x40
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
	return len;
}
    72e0:	bd38      	pop	{r3, r4, r5, pc}
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    72e2:	4b0a      	ldr	r3, [pc, #40]	; (730c <usb_serial_write_buffer_free+0x44>)
    72e4:	781b      	ldrb	r3, [r3, #0]
    72e6:	b913      	cbnz	r3, 72ee <usb_serial_write_buffer_free+0x26>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    72e8:	2000      	movs	r0, #0
    72ea:	7020      	strb	r0, [r4, #0]
			return 0;
    72ec:	bd38      	pop	{r3, r4, r5, pc}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    72ee:	2004      	movs	r0, #4
    72f0:	f7ff f978 	bl	65e4 <usb_tx_packet_count>
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    72f4:	2807      	cmp	r0, #7
    72f6:	d8f7      	bhi.n	72e8 <usb_serial_write_buffer_free+0x20>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
    72f8:	f7ff feaa 	bl	7050 <usb_malloc>
    72fc:	6028      	str	r0, [r5, #0]
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    72fe:	2800      	cmp	r0, #0
    7300:	d1e9      	bne.n	72d6 <usb_serial_write_buffer_free+0xe>
    7302:	e7f1      	b.n	72e8 <usb_serial_write_buffer_free+0x20>
    7304:	1fff2c3c 	.word	0x1fff2c3c
    7308:	1fff2c39 	.word	0x1fff2c39
    730c:	1fff2c30 	.word	0x1fff2c30

00007310 <usb_serial_flush_output>:
	tx_noautoflush = 0;
	return len;
}

void usb_serial_flush_output(void)
{
    7310:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!usb_configuration) return;
    7312:	4b11      	ldr	r3, [pc, #68]	; (7358 <usb_serial_flush_output+0x48>)
    7314:	781b      	ldrb	r3, [r3, #0]
    7316:	b18b      	cbz	r3, 733c <usb_serial_flush_output+0x2c>
	tx_noautoflush = 1;
	if (tx_packet) {
    7318:	4e10      	ldr	r6, [pc, #64]	; (735c <usb_serial_flush_output+0x4c>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    731a:	4d11      	ldr	r5, [pc, #68]	; (7360 <usb_serial_flush_output+0x50>)
	if (tx_packet) {
    731c:	6834      	ldr	r4, [r6, #0]
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    731e:	2701      	movs	r7, #1
    7320:	702f      	strb	r7, [r5, #0]
	if (tx_packet) {
    7322:	b164      	cbz	r4, 733e <usb_serial_flush_output+0x2e>
		usb_cdc_transmit_flush_timer = 0;
    7324:	4a0f      	ldr	r2, [pc, #60]	; (7364 <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
    7326:	8863      	ldrh	r3, [r4, #2]
void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
    7328:	2700      	movs	r7, #0
    732a:	7017      	strb	r7, [r2, #0]
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    732c:	4621      	mov	r1, r4
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
    732e:	8023      	strh	r3, [r4, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    7330:	2004      	movs	r0, #4
    7332:	f7ff f9af 	bl	6694 <usb_tx>
		tx_packet = NULL;
    7336:	6037      	str	r7, [r6, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
	tx_noautoflush = 0;
    7338:	2300      	movs	r3, #0
    733a:	702b      	strb	r3, [r5, #0]
    733c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    733e:	f7ff fe87 	bl	7050 <usb_malloc>
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    7342:	4b08      	ldr	r3, [pc, #32]	; (7364 <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
    7344:	b128      	cbz	r0, 7352 <usb_serial_flush_output+0x42>
			usb_cdc_transmit_flush_timer = 0;
			usb_tx(CDC_TX_ENDPOINT, tx);
    7346:	4601      	mov	r1, r0
    7348:	2004      	movs	r0, #4
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    734a:	701c      	strb	r4, [r3, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    734c:	f7ff f9a2 	bl	6694 <usb_tx>
    7350:	e7f2      	b.n	7338 <usb_serial_flush_output+0x28>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    7352:	701f      	strb	r7, [r3, #0]
    7354:	e7f0      	b.n	7338 <usb_serial_flush_output+0x28>
    7356:	bf00      	nop
    7358:	1fff2c30 	.word	0x1fff2c30
    735c:	1fff2c3c 	.word	0x1fff2c3c
    7360:	1fff2c39 	.word	0x1fff2c39
    7364:	1fff2c38 	.word	0x1fff2c38

00007368 <usb_serial_flush_callback>:
	}
	tx_noautoflush = 0;
}

void usb_serial_flush_callback(void)
{
    7368:	b538      	push	{r3, r4, r5, lr}
	if (tx_noautoflush) return;
    736a:	4b0e      	ldr	r3, [pc, #56]	; (73a4 <usb_serial_flush_callback+0x3c>)
    736c:	781b      	ldrb	r3, [r3, #0]
    736e:	b973      	cbnz	r3, 738e <usb_serial_flush_callback+0x26>
	if (tx_packet) {
    7370:	4c0d      	ldr	r4, [pc, #52]	; (73a8 <usb_serial_flush_callback+0x40>)
    7372:	6821      	ldr	r1, [r4, #0]
    7374:	b161      	cbz	r1, 7390 <usb_serial_flush_callback+0x28>
    7376:	f003 05ff 	and.w	r5, r3, #255	; 0xff
		tx_packet->len = tx_packet->index;
    737a:	884b      	ldrh	r3, [r1, #2]
    737c:	800b      	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    737e:	2004      	movs	r0, #4
    7380:	f7ff f988 	bl	6694 <usb_tx>
		tx_packet = NULL;
    7384:	6025      	str	r5, [r4, #0]
    7386:	bd38      	pop	{r3, r4, r5, pc}
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
    7388:	4b08      	ldr	r3, [pc, #32]	; (73ac <usb_serial_flush_callback+0x44>)
    738a:	2201      	movs	r2, #1
    738c:	701a      	strb	r2, [r3, #0]
    738e:	bd38      	pop	{r3, r4, r5, pc}
	if (tx_packet) {
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    7390:	f7ff fe5e 	bl	7050 <usb_malloc>
		if (tx) {
    7394:	2800      	cmp	r0, #0
    7396:	d0f7      	beq.n	7388 <usb_serial_flush_callback+0x20>
			usb_tx(CDC_TX_ENDPOINT, tx);
    7398:	4601      	mov	r1, r0
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    739a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
    739e:	2004      	movs	r0, #4
    73a0:	f7ff b978 	b.w	6694 <usb_tx>
    73a4:	1fff2c39 	.word	0x1fff2c39
    73a8:	1fff2c3c 	.word	0x1fff2c3c
    73ac:	1fff2c38 	.word	0x1fff2c38

000073b0 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    73b0:	b570      	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    73b2:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    73b6:	b672      	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    73b8:	4c0c      	ldr	r4, [pc, #48]	; (73ec <EventResponder::runFromInterrupt()+0x3c>)
    73ba:	6820      	ldr	r0, [r4, #0]
		if (first) {
    73bc:	b180      	cbz	r0, 73e0 <EventResponder::runFromInterrupt()+0x30>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    73be:	4e0c      	ldr	r6, [pc, #48]	; (73f0 <EventResponder::runFromInterrupt()+0x40>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    73c0:	2500      	movs	r5, #0
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
    73c2:	6943      	ldr	r3, [r0, #20]
    73c4:	6023      	str	r3, [r4, #0]
			if (firstInterrupt) {
    73c6:	b173      	cbz	r3, 73e6 <EventResponder::runFromInterrupt()+0x36>
				firstInterrupt->_prev = nullptr;
    73c8:	619d      	str	r5, [r3, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    73ca:	b902      	cbnz	r2, 73ce <EventResponder::runFromInterrupt()+0x1e>
    73cc:	b662      	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    73ce:	7745      	strb	r5, [r0, #29]
			(*(first->_function))(*first);
    73d0:	6883      	ldr	r3, [r0, #8]
    73d2:	4798      	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    73d4:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    73d8:	b672      	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    73da:	6820      	ldr	r0, [r4, #0]
		if (first) {
    73dc:	2800      	cmp	r0, #0
    73de:	d1f0      	bne.n	73c2 <EventResponder::runFromInterrupt()+0x12>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    73e0:	b902      	cbnz	r2, 73e4 <EventResponder::runFromInterrupt()+0x34>
    73e2:	b662      	cpsie	i
    73e4:	bd70      	pop	{r4, r5, r6, pc}
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    73e6:	6033      	str	r3, [r6, #0]
    73e8:	e7ef      	b.n	73ca <EventResponder::runFromInterrupt()+0x1a>
    73ea:	bf00      	nop
    73ec:	1fff2c4c 	.word	0x1fff2c4c
    73f0:	1fff2c50 	.word	0x1fff2c50

000073f4 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    73f4:	f7ff bfdc 	b.w	73b0 <EventResponder::runFromInterrupt()>

000073f8 <systick_isr>:

extern "C" volatile uint32_t systick_millis_count;

void systick_isr(void)
{
	systick_millis_count++;
    73f8:	4a02      	ldr	r2, [pc, #8]	; (7404 <systick_isr+0xc>)
    73fa:	6813      	ldr	r3, [r2, #0]
    73fc:	3301      	adds	r3, #1
    73fe:	6013      	str	r3, [r2, #0]
    7400:	4770      	bx	lr
    7402:	bf00      	nop
    7404:	1fff2b4c 	.word	0x1fff2b4c

00007408 <String::~String()>:
	init();
	char buf[40];
	*this = dtostrf(num, digits + 2, digits, buf);
}

String::~String()
    7408:	b510      	push	{r4, lr}
    740a:	4604      	mov	r4, r0
{
	free(buffer);
    740c:	6800      	ldr	r0, [r0, #0]
    740e:	f002 f855 	bl	94bc <free>
}
    7412:	4620      	mov	r0, r4
    7414:	bd10      	pop	{r4, pc}
    7416:	bf00      	nop

00007418 <String::reserve(unsigned int)>:
	len = 0;
	flags = 0;
}

unsigned char String::reserve(unsigned int size)
{
    7418:	b538      	push	{r3, r4, r5, lr}
	if (capacity >= size) return 1;
    741a:	6843      	ldr	r3, [r0, #4]
    741c:	428b      	cmp	r3, r1
    741e:	d301      	bcc.n	7424 <String::reserve(unsigned int)+0xc>
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    7420:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
    7422:	bd38      	pop	{r3, r4, r5, pc}
    7424:	460d      	mov	r5, r1
    7426:	4604      	mov	r4, r0

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
    7428:	3101      	adds	r1, #1
    742a:	6800      	ldr	r0, [r0, #0]
    742c:	f002 fbbc 	bl	9ba8 <realloc>
	if (newbuffer) {
    7430:	2800      	cmp	r0, #0
    7432:	d0f6      	beq.n	7422 <String::reserve(unsigned int)+0xa>

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    7434:	68a3      	ldr	r3, [r4, #8]
unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
	if (newbuffer) {
		buffer = newbuffer;
		capacity = maxStrLen;
    7436:	e884 0021 	stmia.w	r4, {r0, r5}

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    743a:	2b00      	cmp	r3, #0
    743c:	d1f0      	bne.n	7420 <String::reserve(unsigned int)+0x8>
    743e:	7003      	strb	r3, [r0, #0]
    7440:	e7ee      	b.n	7420 <String::reserve(unsigned int)+0x8>
    7442:	bf00      	nop

00007444 <String::copy(char const*, unsigned int)>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
    7444:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7446:	4604      	mov	r4, r0
	if (length == 0) {
    7448:	4615      	mov	r5, r2
    744a:	b932      	cbnz	r2, 745a <String::copy(char const*, unsigned int)+0x16>
		if (buffer) buffer[0] = 0;
    744c:	6803      	ldr	r3, [r0, #0]
    744e:	b103      	cbz	r3, 7452 <String::copy(char const*, unsigned int)+0xe>
    7450:	701a      	strb	r2, [r3, #0]
		len = 0;
    7452:	2300      	movs	r3, #0
    7454:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    7456:	4620      	mov	r0, r4
    7458:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    745a:	460e      	mov	r6, r1
	if (length == 0) {
		if (buffer) buffer[0] = 0;
		len = 0;
		return *this;
	}
	if (!reserve(length)) {
    745c:	4611      	mov	r1, r2
    745e:	f7ff ffdb 	bl	7418 <String::reserve(unsigned int)>
    7462:	4607      	mov	r7, r0
    7464:	b948      	cbnz	r0, 747a <String::copy(char const*, unsigned int)+0x36>
		if (buffer) {
    7466:	6820      	ldr	r0, [r4, #0]
    7468:	b110      	cbz	r0, 7470 <String::copy(char const*, unsigned int)+0x2c>
			free(buffer);
    746a:	f002 f827 	bl	94bc <free>
			buffer = NULL;
    746e:	6027      	str	r7, [r4, #0]
		}
		len = capacity = 0;
    7470:	2300      	movs	r3, #0
    7472:	6063      	str	r3, [r4, #4]
    7474:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    7476:	4620      	mov	r0, r4
    7478:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			buffer = NULL;
		}
		len = capacity = 0;
		return *this;
	}
	len = length;
    747a:	60a5      	str	r5, [r4, #8]
	strcpy(buffer, cstr);
    747c:	4631      	mov	r1, r6
    747e:	6820      	ldr	r0, [r4, #0]
    7480:	f002 ff0c 	bl	a29c <strcpy>
	return *this;
    7484:	e7e7      	b.n	7456 <String::copy(char const*, unsigned int)+0x12>
    7486:	bf00      	nop

00007488 <String::String(char const*)>:

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    7488:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    748a:	2300      	movs	r3, #0

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    748c:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    748e:	6003      	str	r3, [r0, #0]
	capacity = 0;
    7490:	6043      	str	r3, [r0, #4]
	len = 0;
    7492:	6083      	str	r3, [r0, #8]
	flags = 0;
    7494:	7303      	strb	r3, [r0, #12]
/*********************************************/

String::String(const char *cstr)
{
	init();
	if (cstr) copy(cstr, strlen(cstr));
    7496:	b141      	cbz	r1, 74aa <String::String(char const*)+0x22>
    7498:	4608      	mov	r0, r1
    749a:	460d      	mov	r5, r1
    749c:	f002 ff70 	bl	a380 <strlen>
    74a0:	4629      	mov	r1, r5
    74a2:	4602      	mov	r2, r0
    74a4:	4620      	mov	r0, r4
    74a6:	f7ff ffcd 	bl	7444 <String::copy(char const*, unsigned int)>
}
    74aa:	4620      	mov	r0, r4
    74ac:	bd38      	pop	{r3, r4, r5, pc}
    74ae:	bf00      	nop

000074b0 <String::equals(char const*) const>:
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    74b0:	6882      	ldr	r2, [r0, #8]
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
    74b2:	b508      	push	{r3, lr}
    74b4:	460b      	mov	r3, r1
	if (len == 0) return (cstr == NULL || *cstr == 0);
    74b6:	b92a      	cbnz	r2, 74c4 <String::equals(char const*) const+0x14>
    74b8:	b171      	cbz	r1, 74d8 <String::equals(char const*) const+0x28>
	if (cstr == NULL) return buffer[0] == 0;
    74ba:	7818      	ldrb	r0, [r3, #0]
    74bc:	fab0 f080 	clz	r0, r0
    74c0:	0940      	lsrs	r0, r0, #5
    74c2:	bd08      	pop	{r3, pc}
    74c4:	b131      	cbz	r1, 74d4 <String::equals(char const*) const+0x24>
	return strcmp(buffer, cstr) == 0;
    74c6:	6800      	ldr	r0, [r0, #0]
    74c8:	f002 fd7e 	bl	9fc8 <strcmp>
    74cc:	fab0 f080 	clz	r0, r0
    74d0:	0940      	lsrs	r0, r0, #5
}
    74d2:	bd08      	pop	{r3, pc}
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
	if (cstr == NULL) return buffer[0] == 0;
    74d4:	6803      	ldr	r3, [r0, #0]
    74d6:	e7f0      	b.n	74ba <String::equals(char const*) const+0xa>
    74d8:	2001      	movs	r0, #1
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    74da:	bd08      	pop	{r3, pc}

000074dc <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    74dc:	b508      	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    74de:	f7fb fe49 	bl	3174 <setup>
	while (1) {
		loop();
    74e2:	f7fb ff35 	bl	3350 <loop>
		yield();
    74e6:	f000 f80f 	bl	7508 <yield>
    74ea:	e7fa      	b.n	74e2 <main+0x6>

000074ec <usb_serial_class::clear()>:
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    74ec:	f7ff be40 	b.w	7170 <usb_serial_flush_input>

000074f0 <usb_serial_class::peek()>:
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    74f0:	f7ff be18 	b.w	7124 <usb_serial_peekchar>

000074f4 <usb_serial_class::available()>:
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    74f4:	f7ff be2e 	b.w	7154 <usb_serial_available>

000074f8 <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    74f8:	f7ff bf0a 	b.w	7310 <usb_serial_flush_output>

000074fc <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    74fc:	f7ff bee4 	b.w	72c8 <usb_serial_write_buffer_free>

00007500 <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    7500:	4608      	mov	r0, r1
    7502:	f7ff bed5 	b.w	72b0 <usb_serial_putchar>
    7506:	bf00      	nop

00007508 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    7508:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    750c:	4e31      	ldr	r6, [pc, #196]	; (75d4 <yield+0xcc>)
    750e:	7833      	ldrb	r3, [r6, #0]
    7510:	b193      	cbz	r3, 7538 <yield+0x30>
	if (running) return; // TODO: does this need to be atomic?
    7512:	4f31      	ldr	r7, [pc, #196]	; (75d8 <yield+0xd0>)
    7514:	783a      	ldrb	r2, [r7, #0]
    7516:	b97a      	cbnz	r2, 7538 <yield+0x30>
	running = 1;
    7518:	2201      	movs	r2, #1


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    751a:	07d9      	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    751c:	703a      	strb	r2, [r7, #0]


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    751e:	d436      	bmi.n	758e <yield+0x86>
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIALUSB2) {
		if (SerialUSB2.available()) serialEventUSB2();
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    7520:	079a      	lsls	r2, r3, #30
    7522:	d419      	bmi.n	7558 <yield+0x50>
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    7524:	2200      	movs	r2, #0
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    7526:	075b      	lsls	r3, r3, #29
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    7528:	703a      	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    752a:	d505      	bpl.n	7538 <yield+0x30>
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;  
    752c:	4b2b      	ldr	r3, [pc, #172]	; (75dc <yield+0xd4>)
    752e:	681a      	ldr	r2, [r3, #0]
    7530:	b112      	cbz	r2, 7538 <yield+0x30>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    7532:	f3ef 8205 	mrs	r2, IPSR
		if (ipsr != 0) return;
    7536:	b10a      	cbz	r2, 753c <yield+0x34>
    7538:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    753c:	f3ef 8110 	mrs	r1, PRIMASK
		__disable_irq();
    7540:	b672      	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    7542:	6818      	ldr	r0, [r3, #0]
		if (first == nullptr) {
    7544:	b118      	cbz	r0, 754e <yield+0x46>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    7546:	4c26      	ldr	r4, [pc, #152]	; (75e0 <yield+0xd8>)
    7548:	7822      	ldrb	r2, [r4, #0]
    754a:	2a00      	cmp	r2, #0
    754c:	d02e      	beq.n	75ac <yield+0xa4>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    754e:	2900      	cmp	r1, #0
    7550:	d1f2      	bne.n	7538 <yield+0x30>
    7552:	b662      	cpsie	i
    7554:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    7558:	f8df 8090 	ldr.w	r8, [pc, #144]	; 75ec <yield+0xe4>
    755c:	f898 2000 	ldrb.w	r2, [r8]
    7560:	2a00      	cmp	r2, #0
    7562:	d0df      	beq.n	7524 <yield+0x1c>
    7564:	f8df 9088 	ldr.w	r9, [pc, #136]	; 75f0 <yield+0xe8>
    7568:	2400      	movs	r4, #0
    756a:	e005      	b.n	7578 <yield+0x70>
    756c:	3401      	adds	r4, #1
    756e:	f898 3000 	ldrb.w	r3, [r8]
    7572:	b2e4      	uxtb	r4, r4
    7574:	42a3      	cmp	r3, r4
    7576:	d912      	bls.n	759e <yield+0x96>
			s_serials_with_serial_events[i]->doYieldCode();
    7578:	f859 5024 	ldr.w	r5, [r9, r4, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
	static uint8_t 			s_count_serials_with_serial_events;
	void 		(* const _serialEvent)(); 
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*_serialEvent)();
    757c:	682b      	ldr	r3, [r5, #0]
    757e:	4628      	mov	r0, r5
    7580:	691b      	ldr	r3, [r3, #16]
    7582:	4798      	blx	r3
    7584:	2800      	cmp	r0, #0
    7586:	d0f1      	beq.n	756c <yield+0x64>
    7588:	692b      	ldr	r3, [r5, #16]
    758a:	4798      	blx	r3
    758c:	e7ee      	b.n	756c <yield+0x64>
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    758e:	f7ff fde1 	bl	7154 <usb_serial_available>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    7592:	b9c8      	cbnz	r0, 75c8 <yield+0xc0>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    7594:	4b13      	ldr	r3, [pc, #76]	; (75e4 <yield+0xdc>)
    7596:	781b      	ldrb	r3, [r3, #0]
    7598:	b91b      	cbnz	r3, 75a2 <yield+0x9a>
    759a:	7833      	ldrb	r3, [r6, #0]
    759c:	e7c0      	b.n	7520 <yield+0x18>
    759e:	7833      	ldrb	r3, [r6, #0]
    75a0:	e7c0      	b.n	7524 <yield+0x1c>
    75a2:	7833      	ldrb	r3, [r6, #0]
    75a4:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    75a8:	7033      	strb	r3, [r6, #0]
    75aa:	e7b9      	b.n	7520 <yield+0x18>
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
		firstYield = first->_next;
    75ac:	6945      	ldr	r5, [r0, #20]
    75ae:	601d      	str	r5, [r3, #0]
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    75b0:	2301      	movs	r3, #1
    75b2:	7023      	strb	r3, [r4, #0]
		firstYield = first->_next;
		if (firstYield) {
    75b4:	b15d      	cbz	r5, 75ce <yield+0xc6>
			firstYield->_prev = nullptr;
    75b6:	61aa      	str	r2, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    75b8:	b901      	cbnz	r1, 75bc <yield+0xb4>
    75ba:	b662      	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    75bc:	2500      	movs	r5, #0
    75be:	7745      	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    75c0:	6883      	ldr	r3, [r0, #8]
    75c2:	4798      	blx	r3
		runningFromYield = false;
    75c4:	7025      	strb	r5, [r4, #0]
    75c6:	e7b7      	b.n	7538 <yield+0x30>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    75c8:	f000 f928 	bl	781c <serialEvent()>
    75cc:	e7e2      	b.n	7594 <yield+0x8c>
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
    75ce:	4b06      	ldr	r3, [pc, #24]	; (75e8 <yield+0xe0>)
    75d0:	601d      	str	r5, [r3, #0]
    75d2:	e7f1      	b.n	75b8 <yield+0xb0>
    75d4:	1fff0b3c 	.word	0x1fff0b3c
    75d8:	1fff2c5d 	.word	0x1fff2c5d
    75dc:	1fff2c58 	.word	0x1fff2c58
    75e0:	1fff2c5c 	.word	0x1fff2c5c
    75e4:	1fff0be2 	.word	0x1fff0be2
    75e8:	1fff2c54 	.word	0x1fff2c54
    75ec:	1fff2c78 	.word	0x1fff2c78
    75f0:	1fff2c60 	.word	0x1fff2c60

000075f4 <analog_init>:
#else
#error "F_BUS must be 128, 120, 108, 96, 90, 80, 72, 64, 60, 56, 54, 48, 40, 36, 24, 4 or 2 MHz"
#endif

void analog_init(void)
{
    75f4:	b430      	push	{r4, r5}
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    75f6:	4829      	ldr	r0, [pc, #164]	; (769c <analog_init+0xa8>)
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    75f8:	4a29      	ldr	r2, [pc, #164]	; (76a0 <analog_init+0xac>)
	#endif

	if (analog_config_bits == 8) {
    75fa:	4b2a      	ldr	r3, [pc, #168]	; (76a4 <analog_init+0xb0>)
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    75fc:	4d2a      	ldr	r5, [pc, #168]	; (76a8 <analog_init+0xb4>)
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    75fe:	2460      	movs	r4, #96	; 0x60
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    7600:	21e1      	movs	r1, #225	; 0xe1
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    7602:	7004      	strb	r4, [r0, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    7604:	7011      	strb	r1, [r2, #0]
	#endif

	if (analog_config_bits == 8) {
    7606:	781b      	ldrb	r3, [r3, #0]
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    7608:	4c28      	ldr	r4, [pc, #160]	; (76ac <analog_init+0xb8>)
	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
    760a:	2b08      	cmp	r3, #8
    760c:	d030      	beq.n	7670 <analog_init+0x7c>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    760e:	2b0a      	cmp	r3, #10
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    7610:	4827      	ldr	r0, [pc, #156]	; (76b0 <analog_init+0xbc>)
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    7612:	4928      	ldr	r1, [pc, #160]	; (76b4 <analog_init+0xc0>)
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    7614:	d037      	beq.n	7686 <analog_init+0x92>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    7616:	2b0c      	cmp	r3, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    7618:	bf0c      	ite	eq
    761a:	2235      	moveq	r2, #53	; 0x35
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    761c:	225d      	movne	r2, #93	; 0x5d
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    761e:	2312      	movs	r3, #18
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    7620:	602a      	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    7622:	6023      	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    7624:	6002      	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    7626:	600b      	str	r3, [r1, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    7628:	4b23      	ldr	r3, [pc, #140]	; (76b8 <analog_init+0xc4>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    762a:	4924      	ldr	r1, [pc, #144]	; (76bc <analog_init+0xc8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    762c:	781b      	ldrb	r3, [r3, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    762e:	4a24      	ldr	r2, [pc, #144]	; (76c0 <analog_init+0xcc>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    7630:	b1bb      	cbz	r3, 7662 <analog_init+0x6e>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    7632:	2301      	movs	r3, #1
    7634:	600b      	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    7636:	6013      	str	r3, [r2, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    7638:	4b22      	ldr	r3, [pc, #136]	; (76c4 <analog_init+0xd0>)
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    763a:	4923      	ldr	r1, [pc, #140]	; (76c8 <analog_init+0xd4>)
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    763c:	781b      	ldrb	r3, [r3, #0]
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    763e:	4a23      	ldr	r2, [pc, #140]	; (76cc <analog_init+0xd8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
    7640:	2b01      	cmp	r3, #1
    7642:	d926      	bls.n	7692 <analog_init+0x9e>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
    7644:	2b04      	cmp	r3, #4
    7646:	d90f      	bls.n	7668 <analog_init+0x74>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
    7648:	2b08      	cmp	r3, #8
    764a:	d91e      	bls.n	768a <analog_init+0x96>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#endif
	} else if (num <= 16) {
    764c:	2b10      	cmp	r3, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    764e:	bf94      	ite	ls
    7650:	2386      	movls	r3, #134	; 0x86
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    7652:	2387      	movhi	r3, #135	; 0x87
    7654:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    7656:	6013      	str	r3, [r2, #0]
		#endif
	}
	calibrating = 1;
    7658:	4b1d      	ldr	r3, [pc, #116]	; (76d0 <analog_init+0xdc>)
    765a:	2201      	movs	r2, #1
    765c:	701a      	strb	r2, [r3, #0]
}
    765e:	bc30      	pop	{r4, r5}
    7660:	4770      	bx	lr
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    7662:	600b      	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    7664:	6013      	str	r3, [r2, #0]
    7666:	e7e7      	b.n	7638 <analog_init+0x44>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    7668:	2384      	movs	r3, #132	; 0x84
    766a:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    766c:	6013      	str	r3, [r2, #0]
    766e:	e7f3      	b.n	7658 <analog_init+0x64>

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    7670:	f500 208e 	add.w	r0, r0, #290816	; 0x47000
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    7674:	490f      	ldr	r1, [pc, #60]	; (76b4 <analog_init+0xc0>)

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    7676:	3008      	adds	r0, #8
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    7678:	2221      	movs	r2, #33	; 0x21
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    767a:	2313      	movs	r3, #19
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    767c:	602a      	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    767e:	6023      	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    7680:	6002      	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    7682:	600b      	str	r3, [r1, #0]
    7684:	e7d0      	b.n	7628 <analog_init+0x34>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    7686:	2239      	movs	r2, #57	; 0x39
    7688:	e7f7      	b.n	767a <analog_init+0x86>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    768a:	2385      	movs	r3, #133	; 0x85
    768c:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    768e:	6013      	str	r3, [r2, #0]
    7690:	e7e2      	b.n	7658 <analog_init+0x64>
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    7692:	2380      	movs	r3, #128	; 0x80
    7694:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    7696:	6013      	str	r3, [r2, #0]
    7698:	e7de      	b.n	7658 <analog_init+0x64>
    769a:	bf00      	nop
    769c:	40074000 	.word	0x40074000
    76a0:	40074001 	.word	0x40074001
    76a4:	1fff0b3d 	.word	0x1fff0b3d
    76a8:	4003b008 	.word	0x4003b008
    76ac:	4003b00c 	.word	0x4003b00c
    76b0:	400bb008 	.word	0x400bb008
    76b4:	400bb00c 	.word	0x400bb00c
    76b8:	1fff2c5f 	.word	0x1fff2c5f
    76bc:	4003b020 	.word	0x4003b020
    76c0:	400bb020 	.word	0x400bb020
    76c4:	1fff0b3e 	.word	0x1fff0b3e
    76c8:	4003b024 	.word	0x4003b024
    76cc:	400bb024 	.word	0x400bb024
    76d0:	1fff2c5e 	.word	0x1fff2c5e

000076d4 <analogWriteDAC0>:
typedef int16_t __attribute__((__may_alias__)) aliased_int16_t;

void analogWriteDAC0(int val)
{
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_DAC0;
    76d4:	4a0a      	ldr	r2, [pc, #40]	; (7700 <analogWriteDAC0+0x2c>)
	if (analog_reference_internal) {
    76d6:	490b      	ldr	r1, [pc, #44]	; (7704 <analogWriteDAC0+0x30>)
typedef int16_t __attribute__((__may_alias__)) aliased_int16_t;

void analogWriteDAC0(int val)
{
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_DAC0;
    76d8:	6813      	ldr	r3, [r2, #0]
    76da:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    76de:	6013      	str	r3, [r2, #0]
	if (analog_reference_internal) {
    76e0:	780b      	ldrb	r3, [r1, #0]
    76e2:	b943      	cbnz	r3, 76f6 <analogWriteDAC0+0x22>
		DAC0_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC0_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
    76e4:	4b08      	ldr	r3, [pc, #32]	; (7708 <analogWriteDAC0+0x34>)
    76e6:	22c0      	movs	r2, #192	; 0xc0
    76e8:	701a      	strb	r2, [r3, #0]
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095

	*(volatile aliased_int16_t *)&(DAC0_DAT0L) = val;
    76ea:	4b08      	ldr	r3, [pc, #32]	; (770c <analogWriteDAC0+0x38>)
	if (analog_reference_internal) {
		DAC0_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC0_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095
    76ec:	f380 000c 	usat	r0, #12, r0

	*(volatile aliased_int16_t *)&(DAC0_DAT0L) = val;
    76f0:	b200      	sxth	r0, r0
    76f2:	8018      	strh	r0, [r3, #0]
    76f4:	4770      	bx	lr
void analogWriteDAC0(int val)
{
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_DAC0;
	if (analog_reference_internal) {
		DAC0_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
    76f6:	4b04      	ldr	r3, [pc, #16]	; (7708 <analogWriteDAC0+0x34>)
    76f8:	2280      	movs	r2, #128	; 0x80
    76fa:	701a      	strb	r2, [r3, #0]
    76fc:	e7f5      	b.n	76ea <analogWriteDAC0+0x16>
    76fe:	bf00      	nop
    7700:	4004802c 	.word	0x4004802c
    7704:	1fff2c5f 	.word	0x1fff2c5f
    7708:	400cc021 	.word	0x400cc021
    770c:	400cc000 	.word	0x400cc000

00007710 <analogWriteDAC1>:


#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
void analogWriteDAC1(int val)
{
	SIM_SCGC2 |= SIM_SCGC2_DAC1;
    7710:	4a0a      	ldr	r2, [pc, #40]	; (773c <analogWriteDAC1+0x2c>)
	if (analog_reference_internal) {
    7712:	490b      	ldr	r1, [pc, #44]	; (7740 <analogWriteDAC1+0x30>)


#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
void analogWriteDAC1(int val)
{
	SIM_SCGC2 |= SIM_SCGC2_DAC1;
    7714:	6813      	ldr	r3, [r2, #0]
    7716:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    771a:	6013      	str	r3, [r2, #0]
	if (analog_reference_internal) {
    771c:	780b      	ldrb	r3, [r1, #0]
    771e:	b943      	cbnz	r3, 7732 <analogWriteDAC1+0x22>
		DAC1_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC1_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
    7720:	4b08      	ldr	r3, [pc, #32]	; (7744 <analogWriteDAC1+0x34>)
    7722:	22c0      	movs	r2, #192	; 0xc0
    7724:	701a      	strb	r2, [r3, #0]
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095

	*(volatile aliased_int16_t *)&(DAC1_DAT0L) = val;
    7726:	4b08      	ldr	r3, [pc, #32]	; (7748 <analogWriteDAC1+0x38>)
	if (analog_reference_internal) {
		DAC1_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC1_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095
    7728:	f380 000c 	usat	r0, #12, r0

	*(volatile aliased_int16_t *)&(DAC1_DAT0L) = val;
    772c:	b200      	sxth	r0, r0
    772e:	8018      	strh	r0, [r3, #0]
    7730:	4770      	bx	lr
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
void analogWriteDAC1(int val)
{
	SIM_SCGC2 |= SIM_SCGC2_DAC1;
	if (analog_reference_internal) {
		DAC1_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
    7732:	4b04      	ldr	r3, [pc, #16]	; (7744 <analogWriteDAC1+0x34>)
    7734:	2280      	movs	r2, #128	; 0x80
    7736:	701a      	strb	r2, [r3, #0]
    7738:	e7f5      	b.n	7726 <analogWriteDAC1+0x16>
    773a:	bf00      	nop
    773c:	4004802c 	.word	0x4004802c
    7740:	1fff2c5f 	.word	0x1fff2c5f
    7744:	400cd021 	.word	0x400cd021
    7748:	400cd000 	.word	0x400cd000

0000774c <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    774c:	b4f0      	push	{r4, r5, r6, r7}
    774e:	1e4d      	subs	r5, r1, #1
    7750:	462e      	mov	r6, r5
	unsigned digit;
	int i=0, j;
    7752:	2400      	movs	r4, #0
    7754:	e000      	b.n	7758 <ultoa+0xc>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    7756:	3401      	adds	r4, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
    7758:	fbb0 f3f2 	udiv	r3, r0, r2
    775c:	fb02 0013 	mls	r0, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    7760:	2809      	cmp	r0, #9
    7762:	f100 0730 	add.w	r7, r0, #48	; 0x30
    7766:	bf8a      	itet	hi
    7768:	3037      	addhi	r0, #55	; 0x37
    776a:	b2f8      	uxtbls	r0, r7
    776c:	b2c0      	uxtbhi	r0, r0
    776e:	f806 0f01 	strb.w	r0, [r6, #1]!
		val /= radix;
		if (val == 0) break;
    7772:	4618      	mov	r0, r3
    7774:	2b00      	cmp	r3, #0
    7776:	d1ee      	bne.n	7756 <ultoa+0xa>
		i++;
	}
	buf[i + 1] = 0;
    7778:	190a      	adds	r2, r1, r4
    777a:	7053      	strb	r3, [r2, #1]
	for (j=0; j < i; j++, i--) {
    777c:	b14c      	cbz	r4, 7792 <ultoa+0x46>
		t = buf[j];
		buf[j] = buf[i];
    777e:	7810      	ldrb	r0, [r2, #0]
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
		t = buf[j];
    7780:	f815 6f01 	ldrb.w	r6, [r5, #1]!
		buf[j] = buf[i];
    7784:	7028      	strb	r0, [r5, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    7786:	3301      	adds	r3, #1
    7788:	1ae0      	subs	r0, r4, r3
    778a:	4283      	cmp	r3, r0
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
    778c:	f802 6901 	strb.w	r6, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    7790:	dbf5      	blt.n	777e <ultoa+0x32>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    7792:	4608      	mov	r0, r1
    7794:	bcf0      	pop	{r4, r5, r6, r7}
    7796:	4770      	bx	lr

00007798 <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    7798:	b510      	push	{r4, lr}
    779a:	b084      	sub	sp, #16
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    779c:	b672      	cpsid	i
	FTFL_FCCOB1 = 15;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
    779e:	f7fe fb05 	bl	5dac <kinetis_hsrun_disable>
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    77a2:	4a18      	ldr	r2, [pc, #96]	; (7804 <usb_init_serialnumber+0x6c>)
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    77a4:	4b18      	ldr	r3, [pc, #96]	; (7808 <usb_init_serialnumber+0x70>)
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    77a6:	4919      	ldr	r1, [pc, #100]	; (780c <usb_init_serialnumber+0x74>)
    77a8:	6011      	str	r1, [r2, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    77aa:	2270      	movs	r2, #112	; 0x70
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    77ac:	2180      	movs	r1, #128	; 0x80
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    77ae:	701a      	strb	r2, [r3, #0]
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    77b0:	461a      	mov	r2, r3
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    77b2:	7019      	strb	r1, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    77b4:	7813      	ldrb	r3, [r2, #0]
    77b6:	061b      	lsls	r3, r3, #24
    77b8:	d5fc      	bpl.n	77b4 <usb_init_serialnumber+0x1c>
	num = *(uint32_t *)&FTFL_FCCOBB;
    77ba:	4b15      	ldr	r3, [pc, #84]	; (7810 <usb_init_serialnumber+0x78>)
    77bc:	681c      	ldr	r4, [r3, #0]
	kinetis_hsrun_enable();
    77be:	f7fe fb0f 	bl	5de0 <kinetis_hsrun_enable>
#endif
	__enable_irq();
    77c2:	b662      	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    77c4:	4b13      	ldr	r3, [pc, #76]	; (7814 <usb_init_serialnumber+0x7c>)
    77c6:	429c      	cmp	r4, r3
    77c8:	bf9c      	itt	ls
    77ca:	eb04 0484 	addls.w	r4, r4, r4, lsl #2
    77ce:	0064      	lslls	r4, r4, #1
	ultoa(num, buf, 10);
    77d0:	4620      	mov	r0, r4
    77d2:	4c11      	ldr	r4, [pc, #68]	; (7818 <usb_init_serialnumber+0x80>)
    77d4:	a901      	add	r1, sp, #4
    77d6:	220a      	movs	r2, #10
    77d8:	f7ff ffb8 	bl	774c <ultoa>
    77dc:	a901      	add	r1, sp, #4
    77de:	4620      	mov	r0, r4
	for (i=0; i<10; i++) {
    77e0:	2300      	movs	r3, #0
		char c = buf[i];
    77e2:	f811 2b01 	ldrb.w	r2, [r1], #1
    77e6:	3301      	adds	r3, #1
		if (!c) break;
    77e8:	b13a      	cbz	r2, 77fa <usb_init_serialnumber+0x62>
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    77ea:	2b0a      	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    77ec:	f820 2f02 	strh.w	r2, [r0, #2]!
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    77f0:	d1f7      	bne.n	77e2 <usb_init_serialnumber+0x4a>
    77f2:	2316      	movs	r3, #22
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    77f4:	7023      	strb	r3, [r4, #0]
}
    77f6:	b004      	add	sp, #16
    77f8:	bd10      	pop	{r4, pc}
    77fa:	005b      	lsls	r3, r3, #1
    77fc:	b2db      	uxtb	r3, r3
	for (i=0; i<10; i++) {
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    77fe:	7023      	strb	r3, [r4, #0]
}
    7800:	b004      	add	sp, #16
    7802:	bd10      	pop	{r4, pc}
    7804:	40020004 	.word	0x40020004
    7808:	40020000 	.word	0x40020000
    780c:	41070000 	.word	0x41070000
    7810:	4002000c 	.word	0x4002000c
    7814:	0098967f 	.word	0x0098967f
    7818:	1fff0bcc 	.word	0x1fff0bcc

0000781c <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    781c:	4770      	bx	lr
    781e:	bf00      	nop

00007820 <pow>:
    7820:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7824:	ed2d 8b02 	vpush	{d8}
    7828:	f8df a324 	ldr.w	sl, [pc, #804]	; 7b50 <pow+0x330>
    782c:	b08b      	sub	sp, #44	; 0x2c
    782e:	ec57 6b10 	vmov	r6, r7, d0
    7832:	ec55 4b11 	vmov	r4, r5, d1
    7836:	f000 f98f 	bl	7b58 <__ieee754_pow>
    783a:	f99a 8000 	ldrsb.w	r8, [sl]
    783e:	eeb0 8a40 	vmov.f32	s16, s0
    7842:	eef0 8a60 	vmov.f32	s17, s1
    7846:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
    784a:	d048      	beq.n	78de <pow+0xbe>
    784c:	4622      	mov	r2, r4
    784e:	462b      	mov	r3, r5
    7850:	4620      	mov	r0, r4
    7852:	4629      	mov	r1, r5
    7854:	f001 fd6e 	bl	9334 <__aeabi_dcmpun>
    7858:	4683      	mov	fp, r0
    785a:	2800      	cmp	r0, #0
    785c:	d13f      	bne.n	78de <pow+0xbe>
    785e:	4632      	mov	r2, r6
    7860:	463b      	mov	r3, r7
    7862:	4630      	mov	r0, r6
    7864:	4639      	mov	r1, r7
    7866:	f001 fd65 	bl	9334 <__aeabi_dcmpun>
    786a:	4681      	mov	r9, r0
    786c:	2800      	cmp	r0, #0
    786e:	f040 8090 	bne.w	7992 <pow+0x172>
    7872:	4630      	mov	r0, r6
    7874:	4639      	mov	r1, r7
    7876:	2200      	movs	r2, #0
    7878:	2300      	movs	r3, #0
    787a:	f001 fd29 	bl	92d0 <__aeabi_dcmpeq>
    787e:	2800      	cmp	r0, #0
    7880:	d036      	beq.n	78f0 <pow+0xd0>
    7882:	2200      	movs	r2, #0
    7884:	2300      	movs	r3, #0
    7886:	4620      	mov	r0, r4
    7888:	4629      	mov	r1, r5
    788a:	f001 fd21 	bl	92d0 <__aeabi_dcmpeq>
    788e:	4683      	mov	fp, r0
    7890:	b1b8      	cbz	r0, 78c2 <pow+0xa2>
    7892:	ed9f 7ba5 	vldr	d7, [pc, #660]	; 7b28 <pow+0x308>
    7896:	2201      	movs	r2, #1
    7898:	4ba9      	ldr	r3, [pc, #676]	; (7b40 <pow+0x320>)
    789a:	f8cd 9020 	str.w	r9, [sp, #32]
    789e:	9200      	str	r2, [sp, #0]
    78a0:	e9cd 6702 	strd	r6, r7, [sp, #8]
    78a4:	e9cd 4504 	strd	r4, r5, [sp, #16]
    78a8:	ed8d 7b06 	vstr	d7, [sp, #24]
    78ac:	9301      	str	r3, [sp, #4]
    78ae:	f1b8 0f00 	cmp.w	r8, #0
    78b2:	d05b      	beq.n	796c <pow+0x14c>
    78b4:	ed9f 0b9e 	vldr	d0, [pc, #632]	; 7b30 <pow+0x310>
    78b8:	b00b      	add	sp, #44	; 0x2c
    78ba:	ecbd 8b02 	vpop	{d8}
    78be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    78c2:	ec45 4b10 	vmov	d0, r4, r5
    78c6:	f000 ffa7 	bl	8818 <finite>
    78ca:	b140      	cbz	r0, 78de <pow+0xbe>
    78cc:	2200      	movs	r2, #0
    78ce:	2300      	movs	r3, #0
    78d0:	4620      	mov	r0, r4
    78d2:	4629      	mov	r1, r5
    78d4:	f001 fd06 	bl	92e4 <__aeabi_dcmplt>
    78d8:	2800      	cmp	r0, #0
    78da:	f040 80c5 	bne.w	7a68 <pow+0x248>
    78de:	eeb0 0a48 	vmov.f32	s0, s16
    78e2:	eef0 0a68 	vmov.f32	s1, s17
    78e6:	b00b      	add	sp, #44	; 0x2c
    78e8:	ecbd 8b02 	vpop	{d8}
    78ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    78f0:	eeb0 0a48 	vmov.f32	s0, s16
    78f4:	eef0 0a68 	vmov.f32	s1, s17
    78f8:	f000 ff8e 	bl	8818 <finite>
    78fc:	4680      	mov	r8, r0
    78fe:	2800      	cmp	r0, #0
    7900:	d061      	beq.n	79c6 <pow+0x1a6>
    7902:	f04f 0800 	mov.w	r8, #0
    7906:	f04f 0900 	mov.w	r9, #0
    790a:	ec51 0b18 	vmov	r0, r1, d8
    790e:	4642      	mov	r2, r8
    7910:	464b      	mov	r3, r9
    7912:	f001 fcdd 	bl	92d0 <__aeabi_dcmpeq>
    7916:	2800      	cmp	r0, #0
    7918:	d0e1      	beq.n	78de <pow+0xbe>
    791a:	ec47 6b10 	vmov	d0, r6, r7
    791e:	f000 ff7b 	bl	8818 <finite>
    7922:	2800      	cmp	r0, #0
    7924:	d0db      	beq.n	78de <pow+0xbe>
    7926:	ec45 4b10 	vmov	d0, r4, r5
    792a:	f000 ff75 	bl	8818 <finite>
    792e:	2800      	cmp	r0, #0
    7930:	d0d5      	beq.n	78de <pow+0xbe>
    7932:	f99a 3000 	ldrsb.w	r3, [sl]
    7936:	4a82      	ldr	r2, [pc, #520]	; (7b40 <pow+0x320>)
    7938:	9201      	str	r2, [sp, #4]
    793a:	2104      	movs	r1, #4
    793c:	2200      	movs	r2, #0
    793e:	2b02      	cmp	r3, #2
    7940:	e9cd 6702 	strd	r6, r7, [sp, #8]
    7944:	e9cd 4504 	strd	r4, r5, [sp, #16]
    7948:	e9cd 8906 	strd	r8, r9, [sp, #24]
    794c:	9100      	str	r1, [sp, #0]
    794e:	9208      	str	r2, [sp, #32]
    7950:	d003      	beq.n	795a <pow+0x13a>
    7952:	4668      	mov	r0, sp
    7954:	f000 ff68 	bl	8828 <matherr>
    7958:	b970      	cbnz	r0, 7978 <pow+0x158>
    795a:	f001 fd79 	bl	9450 <__errno>
    795e:	2322      	movs	r3, #34	; 0x22
    7960:	6003      	str	r3, [r0, #0]
    7962:	e009      	b.n	7978 <pow+0x158>
    7964:	ed9f 7b70 	vldr	d7, [pc, #448]	; 7b28 <pow+0x308>
    7968:	ed8d 7b06 	vstr	d7, [sp, #24]
    796c:	4668      	mov	r0, sp
    796e:	f000 ff5b 	bl	8828 <matherr>
    7972:	2800      	cmp	r0, #0
    7974:	f000 808e 	beq.w	7a94 <pow+0x274>
    7978:	9b08      	ldr	r3, [sp, #32]
    797a:	b11b      	cbz	r3, 7984 <pow+0x164>
    797c:	f001 fd68 	bl	9450 <__errno>
    7980:	9b08      	ldr	r3, [sp, #32]
    7982:	6003      	str	r3, [r0, #0]
    7984:	ed9d 0b06 	vldr	d0, [sp, #24]
    7988:	b00b      	add	sp, #44	; 0x2c
    798a:	ecbd 8b02 	vpop	{d8}
    798e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7992:	2200      	movs	r2, #0
    7994:	2300      	movs	r3, #0
    7996:	4620      	mov	r0, r4
    7998:	4629      	mov	r1, r5
    799a:	f001 fc99 	bl	92d0 <__aeabi_dcmpeq>
    799e:	2800      	cmp	r0, #0
    79a0:	d09d      	beq.n	78de <pow+0xbe>
    79a2:	ed9f 0b63 	vldr	d0, [pc, #396]	; 7b30 <pow+0x310>
    79a6:	4b66      	ldr	r3, [pc, #408]	; (7b40 <pow+0x320>)
    79a8:	f8cd b020 	str.w	fp, [sp, #32]
    79ac:	2201      	movs	r2, #1
    79ae:	f1b8 0f02 	cmp.w	r8, #2
    79b2:	e9cd 6702 	strd	r6, r7, [sp, #8]
    79b6:	e9cd 4504 	strd	r4, r5, [sp, #16]
    79ba:	ed8d 0b06 	vstr	d0, [sp, #24]
    79be:	e88d 000c 	stmia.w	sp, {r2, r3}
    79c2:	d1d3      	bne.n	796c <pow+0x14c>
    79c4:	e78f      	b.n	78e6 <pow+0xc6>
    79c6:	ec47 6b10 	vmov	d0, r6, r7
    79ca:	f000 ff25 	bl	8818 <finite>
    79ce:	2800      	cmp	r0, #0
    79d0:	d097      	beq.n	7902 <pow+0xe2>
    79d2:	ec45 4b10 	vmov	d0, r4, r5
    79d6:	f000 ff1f 	bl	8818 <finite>
    79da:	2800      	cmp	r0, #0
    79dc:	d091      	beq.n	7902 <pow+0xe2>
    79de:	ec53 2b18 	vmov	r2, r3, d8
    79e2:	ee18 0a10 	vmov	r0, s16
    79e6:	4619      	mov	r1, r3
    79e8:	f001 fca4 	bl	9334 <__aeabi_dcmpun>
    79ec:	2800      	cmp	r0, #0
    79ee:	d17c      	bne.n	7aea <pow+0x2ca>
    79f0:	2303      	movs	r3, #3
    79f2:	f99a 8000 	ldrsb.w	r8, [sl]
    79f6:	9300      	str	r3, [sp, #0]
    79f8:	4b51      	ldr	r3, [pc, #324]	; (7b40 <pow+0x320>)
    79fa:	9008      	str	r0, [sp, #32]
    79fc:	e9cd 6702 	strd	r6, r7, [sp, #8]
    7a00:	e9cd 4504 	strd	r4, r5, [sp, #16]
    7a04:	9301      	str	r3, [sp, #4]
    7a06:	f1b8 0f00 	cmp.w	r8, #0
    7a0a:	d148      	bne.n	7a9e <pow+0x27e>
    7a0c:	f8df 9144 	ldr.w	r9, [pc, #324]	; 7b54 <pow+0x334>
    7a10:	f04f 4860 	mov.w	r8, #3758096384	; 0xe0000000
    7a14:	2200      	movs	r2, #0
    7a16:	2300      	movs	r3, #0
    7a18:	4630      	mov	r0, r6
    7a1a:	4639      	mov	r1, r7
    7a1c:	e9cd 8906 	strd	r8, r9, [sp, #24]
    7a20:	f001 fc60 	bl	92e4 <__aeabi_dcmplt>
    7a24:	2800      	cmp	r0, #0
    7a26:	d094      	beq.n	7952 <pow+0x132>
    7a28:	2200      	movs	r2, #0
    7a2a:	4b46      	ldr	r3, [pc, #280]	; (7b44 <pow+0x324>)
    7a2c:	4620      	mov	r0, r4
    7a2e:	4629      	mov	r1, r5
    7a30:	f001 f9e6 	bl	8e00 <__aeabi_dmul>
    7a34:	4604      	mov	r4, r0
    7a36:	460d      	mov	r5, r1
    7a38:	ec45 4b10 	vmov	d0, r4, r5
    7a3c:	f000 ff00 	bl	8840 <rint>
    7a40:	4620      	mov	r0, r4
    7a42:	ec53 2b10 	vmov	r2, r3, d0
    7a46:	4629      	mov	r1, r5
    7a48:	f001 fc42 	bl	92d0 <__aeabi_dcmpeq>
    7a4c:	2800      	cmp	r0, #0
    7a4e:	d149      	bne.n	7ae4 <pow+0x2c4>
    7a50:	4b3d      	ldr	r3, [pc, #244]	; (7b48 <pow+0x328>)
    7a52:	f99a 8000 	ldrsb.w	r8, [sl]
    7a56:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
    7a5a:	e9cd 2306 	strd	r2, r3, [sp, #24]
    7a5e:	f1b8 0f02 	cmp.w	r8, #2
    7a62:	f47f af76 	bne.w	7952 <pow+0x132>
    7a66:	e778      	b.n	795a <pow+0x13a>
    7a68:	4a35      	ldr	r2, [pc, #212]	; (7b40 <pow+0x320>)
    7a6a:	f99a 3000 	ldrsb.w	r3, [sl]
    7a6e:	f8cd b020 	str.w	fp, [sp, #32]
    7a72:	2101      	movs	r1, #1
    7a74:	e9cd 6702 	strd	r6, r7, [sp, #8]
    7a78:	e9cd 4504 	strd	r4, r5, [sp, #16]
    7a7c:	e88d 0006 	stmia.w	sp, {r1, r2}
    7a80:	2b00      	cmp	r3, #0
    7a82:	f43f af6f 	beq.w	7964 <pow+0x144>
    7a86:	4931      	ldr	r1, [pc, #196]	; (7b4c <pow+0x32c>)
    7a88:	2000      	movs	r0, #0
    7a8a:	2b02      	cmp	r3, #2
    7a8c:	e9cd 0106 	strd	r0, r1, [sp, #24]
    7a90:	f47f af6c 	bne.w	796c <pow+0x14c>
    7a94:	f001 fcdc 	bl	9450 <__errno>
    7a98:	2321      	movs	r3, #33	; 0x21
    7a9a:	6003      	str	r3, [r0, #0]
    7a9c:	e76c      	b.n	7978 <pow+0x158>
    7a9e:	ed9f 7b26 	vldr	d7, [pc, #152]	; 7b38 <pow+0x318>
    7aa2:	2200      	movs	r2, #0
    7aa4:	2300      	movs	r3, #0
    7aa6:	4630      	mov	r0, r6
    7aa8:	4639      	mov	r1, r7
    7aaa:	ed8d 7b06 	vstr	d7, [sp, #24]
    7aae:	f001 fc19 	bl	92e4 <__aeabi_dcmplt>
    7ab2:	2800      	cmp	r0, #0
    7ab4:	d0d3      	beq.n	7a5e <pow+0x23e>
    7ab6:	2200      	movs	r2, #0
    7ab8:	4b22      	ldr	r3, [pc, #136]	; (7b44 <pow+0x324>)
    7aba:	4620      	mov	r0, r4
    7abc:	4629      	mov	r1, r5
    7abe:	f001 f99f 	bl	8e00 <__aeabi_dmul>
    7ac2:	4604      	mov	r4, r0
    7ac4:	460d      	mov	r5, r1
    7ac6:	ec45 4b10 	vmov	d0, r4, r5
    7aca:	f000 feb9 	bl	8840 <rint>
    7ace:	4620      	mov	r0, r4
    7ad0:	ec53 2b10 	vmov	r2, r3, d0
    7ad4:	4629      	mov	r1, r5
    7ad6:	f001 fbfb 	bl	92d0 <__aeabi_dcmpeq>
    7ada:	b918      	cbnz	r0, 7ae4 <pow+0x2c4>
    7adc:	4b1b      	ldr	r3, [pc, #108]	; (7b4c <pow+0x32c>)
    7ade:	2200      	movs	r2, #0
    7ae0:	e9cd 2306 	strd	r2, r3, [sp, #24]
    7ae4:	f99a 8000 	ldrsb.w	r8, [sl]
    7ae8:	e7b9      	b.n	7a5e <pow+0x23e>
    7aea:	4b15      	ldr	r3, [pc, #84]	; (7b40 <pow+0x320>)
    7aec:	f99a 9000 	ldrsb.w	r9, [sl]
    7af0:	f8cd 8020 	str.w	r8, [sp, #32]
    7af4:	2201      	movs	r2, #1
    7af6:	e9cd 6702 	strd	r6, r7, [sp, #8]
    7afa:	e9cd 4504 	strd	r4, r5, [sp, #16]
    7afe:	e88d 000c 	stmia.w	sp, {r2, r3}
    7b02:	f1b9 0f00 	cmp.w	r9, #0
    7b06:	f43f af2d 	beq.w	7964 <pow+0x144>
    7b0a:	2200      	movs	r2, #0
    7b0c:	2300      	movs	r3, #0
    7b0e:	4610      	mov	r0, r2
    7b10:	4619      	mov	r1, r3
    7b12:	f001 fa9f 	bl	9054 <__aeabi_ddiv>
    7b16:	f1b9 0f02 	cmp.w	r9, #2
    7b1a:	e9cd 0106 	strd	r0, r1, [sp, #24]
    7b1e:	d0b9      	beq.n	7a94 <pow+0x274>
    7b20:	e724      	b.n	796c <pow+0x14c>
    7b22:	bf00      	nop
    7b24:	f3af 8000 	nop.w
	...
    7b34:	3ff00000 	.word	0x3ff00000
    7b38:	00000000 	.word	0x00000000
    7b3c:	7ff00000 	.word	0x7ff00000
    7b40:	0000af38 	.word	0x0000af38
    7b44:	3fe00000 	.word	0x3fe00000
    7b48:	c7efffff 	.word	0xc7efffff
    7b4c:	fff00000 	.word	0xfff00000
    7b50:	1fff0be3 	.word	0x1fff0be3
    7b54:	47efffff 	.word	0x47efffff

00007b58 <__ieee754_pow>:
    7b58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7b5c:	ec51 0b11 	vmov	r0, r1, d1
    7b60:	f021 4800 	bic.w	r8, r1, #2147483648	; 0x80000000
    7b64:	ea58 0400 	orrs.w	r4, r8, r0
    7b68:	b093      	sub	sp, #76	; 0x4c
    7b6a:	d03c      	beq.n	7be6 <__ieee754_pow+0x8e>
    7b6c:	ec53 2b10 	vmov	r2, r3, d0
    7b70:	4e6d      	ldr	r6, [pc, #436]	; (7d28 <__ieee754_pow+0x1d0>)
    7b72:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
    7b76:	42b4      	cmp	r4, r6
    7b78:	ee10 aa10 	vmov	sl, s0
    7b7c:	461d      	mov	r5, r3
    7b7e:	dc2b      	bgt.n	7bd8 <__ieee754_pow+0x80>
    7b80:	4689      	mov	r9, r1
    7b82:	ee11 ea10 	vmov	lr, s2
    7b86:	d026      	beq.n	7bd6 <__ieee754_pow+0x7e>
    7b88:	45b0      	cmp	r8, r6
    7b8a:	dc25      	bgt.n	7bd8 <__ieee754_pow+0x80>
    7b8c:	4e66      	ldr	r6, [pc, #408]	; (7d28 <__ieee754_pow+0x1d0>)
    7b8e:	45b0      	cmp	r8, r6
    7b90:	d077      	beq.n	7c82 <__ieee754_pow+0x12a>
    7b92:	2d00      	cmp	r5, #0
    7b94:	4616      	mov	r6, r2
    7b96:	461f      	mov	r7, r3
    7b98:	e9cd 0100 	strd	r0, r1, [sp]
    7b9c:	db75      	blt.n	7c8a <__ieee754_pow+0x132>
    7b9e:	f04f 0b00 	mov.w	fp, #0
    7ba2:	f1be 0f00 	cmp.w	lr, #0
    7ba6:	d12d      	bne.n	7c04 <__ieee754_pow+0xac>
    7ba8:	4b5f      	ldr	r3, [pc, #380]	; (7d28 <__ieee754_pow+0x1d0>)
    7baa:	4598      	cmp	r8, r3
    7bac:	f000 8089 	beq.w	7cc2 <__ieee754_pow+0x16a>
    7bb0:	4b5e      	ldr	r3, [pc, #376]	; (7d2c <__ieee754_pow+0x1d4>)
    7bb2:	4598      	cmp	r8, r3
    7bb4:	d05e      	beq.n	7c74 <__ieee754_pow+0x11c>
    7bb6:	f1b9 4f80 	cmp.w	r9, #1073741824	; 0x40000000
    7bba:	f000 83de 	beq.w	837a <__ieee754_pow+0x822>
    7bbe:	4b5c      	ldr	r3, [pc, #368]	; (7d30 <__ieee754_pow+0x1d8>)
    7bc0:	4599      	cmp	r9, r3
    7bc2:	d11f      	bne.n	7c04 <__ieee754_pow+0xac>
    7bc4:	2d00      	cmp	r5, #0
    7bc6:	db1d      	blt.n	7c04 <__ieee754_pow+0xac>
    7bc8:	ec47 6b10 	vmov	d0, r6, r7
    7bcc:	b013      	add	sp, #76	; 0x4c
    7bce:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7bd2:	f000 bd49 	b.w	8668 <__ieee754_sqrt>
    7bd6:	b15a      	cbz	r2, 7bf0 <__ieee754_pow+0x98>
    7bd8:	f104 4440 	add.w	r4, r4, #3221225472	; 0xc0000000
    7bdc:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
    7be0:	ea54 030a 	orrs.w	r3, r4, sl
    7be4:	d106      	bne.n	7bf4 <__ieee754_pow+0x9c>
    7be6:	ed9f 0b4a 	vldr	d0, [pc, #296]	; 7d10 <__ieee754_pow+0x1b8>
    7bea:	b013      	add	sp, #76	; 0x4c
    7bec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7bf0:	45a0      	cmp	r8, r4
    7bf2:	ddcb      	ble.n	7b8c <__ieee754_pow+0x34>
    7bf4:	484f      	ldr	r0, [pc, #316]	; (7d34 <__ieee754_pow+0x1dc>)
    7bf6:	b013      	add	sp, #76	; 0x4c
    7bf8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7bfc:	f000 be18 	b.w	8830 <nan>
    7c00:	f04f 0b00 	mov.w	fp, #0
    7c04:	ec47 6b10 	vmov	d0, r6, r7
    7c08:	f000 fdfe 	bl	8808 <fabs>
    7c0c:	ec51 0b10 	vmov	r0, r1, d0
    7c10:	f1ba 0f00 	cmp.w	sl, #0
    7c14:	d01e      	beq.n	7c54 <__ieee754_pow+0xfc>
    7c16:	0fed      	lsrs	r5, r5, #31
    7c18:	f105 3aff 	add.w	sl, r5, #4294967295	; 0xffffffff
    7c1c:	ea5b 030a 	orrs.w	r3, fp, sl
    7c20:	d063      	beq.n	7cea <__ieee754_pow+0x192>
    7c22:	4b45      	ldr	r3, [pc, #276]	; (7d38 <__ieee754_pow+0x1e0>)
    7c24:	4598      	cmp	r8, r3
    7c26:	f340 808d 	ble.w	7d44 <__ieee754_pow+0x1ec>
    7c2a:	f103 7304 	add.w	r3, r3, #34603008	; 0x2100000
    7c2e:	4598      	cmp	r8, r3
    7c30:	f340 8438 	ble.w	84a4 <__ieee754_pow+0x94c>
    7c34:	4b41      	ldr	r3, [pc, #260]	; (7d3c <__ieee754_pow+0x1e4>)
    7c36:	429c      	cmp	r4, r3
    7c38:	dd62      	ble.n	7d00 <__ieee754_pow+0x1a8>
    7c3a:	f1b9 0f00 	cmp.w	r9, #0
    7c3e:	dd62      	ble.n	7d06 <__ieee754_pow+0x1ae>
    7c40:	a335      	add	r3, pc, #212	; (adr r3, 7d18 <__ieee754_pow+0x1c0>)
    7c42:	e9d3 2300 	ldrd	r2, r3, [r3]
    7c46:	4610      	mov	r0, r2
    7c48:	4619      	mov	r1, r3
    7c4a:	f001 f8d9 	bl	8e00 <__aeabi_dmul>
    7c4e:	ec41 0b10 	vmov	d0, r0, r1
    7c52:	e7ca      	b.n	7bea <__ieee754_pow+0x92>
    7c54:	b124      	cbz	r4, 7c60 <__ieee754_pow+0x108>
    7c56:	4b35      	ldr	r3, [pc, #212]	; (7d2c <__ieee754_pow+0x1d4>)
    7c58:	f025 4240 	bic.w	r2, r5, #3221225472	; 0xc0000000
    7c5c:	429a      	cmp	r2, r3
    7c5e:	d1da      	bne.n	7c16 <__ieee754_pow+0xbe>
    7c60:	f1b9 0f00 	cmp.w	r9, #0
    7c64:	f2c0 83cb 	blt.w	83fe <__ieee754_pow+0x8a6>
    7c68:	2d00      	cmp	r5, #0
    7c6a:	f2c0 8374 	blt.w	8356 <__ieee754_pow+0x7fe>
    7c6e:	ec41 0b10 	vmov	d0, r0, r1
    7c72:	e7ba      	b.n	7bea <__ieee754_pow+0x92>
    7c74:	f1b9 0f00 	cmp.w	r9, #0
    7c78:	f2c0 847a 	blt.w	8570 <__ieee754_pow+0xa18>
    7c7c:	ec47 6b10 	vmov	d0, r6, r7
    7c80:	e7b3      	b.n	7bea <__ieee754_pow+0x92>
    7c82:	f1be 0f00 	cmp.w	lr, #0
    7c86:	d084      	beq.n	7b92 <__ieee754_pow+0x3a>
    7c88:	e7a6      	b.n	7bd8 <__ieee754_pow+0x80>
    7c8a:	4b2d      	ldr	r3, [pc, #180]	; (7d40 <__ieee754_pow+0x1e8>)
    7c8c:	4598      	cmp	r8, r3
    7c8e:	dc29      	bgt.n	7ce4 <__ieee754_pow+0x18c>
    7c90:	f1a3 7354 	sub.w	r3, r3, #55574528	; 0x3500000
    7c94:	4598      	cmp	r8, r3
    7c96:	dd82      	ble.n	7b9e <__ieee754_pow+0x46>
    7c98:	ea4f 5328 	mov.w	r3, r8, asr #20
    7c9c:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
    7ca0:	2b14      	cmp	r3, #20
    7ca2:	f340 847f 	ble.w	85a4 <__ieee754_pow+0xa4c>
    7ca6:	f1c3 0334 	rsb	r3, r3, #52	; 0x34
    7caa:	fa2e f203 	lsr.w	r2, lr, r3
    7cae:	fa02 f303 	lsl.w	r3, r2, r3
    7cb2:	459e      	cmp	lr, r3
    7cb4:	f47f af73 	bne.w	7b9e <__ieee754_pow+0x46>
    7cb8:	f002 0201 	and.w	r2, r2, #1
    7cbc:	f1c2 0b02 	rsb	fp, r2, #2
    7cc0:	e76f      	b.n	7ba2 <__ieee754_pow+0x4a>
    7cc2:	f104 4340 	add.w	r3, r4, #3221225472	; 0xc0000000
    7cc6:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
    7cca:	ea53 030a 	orrs.w	r3, r3, sl
    7cce:	d08a      	beq.n	7be6 <__ieee754_pow+0x8e>
    7cd0:	4b1a      	ldr	r3, [pc, #104]	; (7d3c <__ieee754_pow+0x1e4>)
    7cd2:	429c      	cmp	r4, r3
    7cd4:	f340 8385 	ble.w	83e2 <__ieee754_pow+0x88a>
    7cd8:	f1b9 0f00 	cmp.w	r9, #0
    7cdc:	db13      	blt.n	7d06 <__ieee754_pow+0x1ae>
    7cde:	ed9d 0b00 	vldr	d0, [sp]
    7ce2:	e782      	b.n	7bea <__ieee754_pow+0x92>
    7ce4:	f04f 0b02 	mov.w	fp, #2
    7ce8:	e75b      	b.n	7ba2 <__ieee754_pow+0x4a>
    7cea:	4632      	mov	r2, r6
    7cec:	463b      	mov	r3, r7
    7cee:	4610      	mov	r0, r2
    7cf0:	4619      	mov	r1, r3
    7cf2:	f000 fed1 	bl	8a98 <__aeabi_dsub>
    7cf6:	4602      	mov	r2, r0
    7cf8:	460b      	mov	r3, r1
    7cfa:	f001 f9ab 	bl	9054 <__aeabi_ddiv>
    7cfe:	e7b6      	b.n	7c6e <__ieee754_pow+0x116>
    7d00:	f1b9 0f00 	cmp.w	r9, #0
    7d04:	db9c      	blt.n	7c40 <__ieee754_pow+0xe8>
    7d06:	ed9f 0b06 	vldr	d0, [pc, #24]	; 7d20 <__ieee754_pow+0x1c8>
    7d0a:	e76e      	b.n	7bea <__ieee754_pow+0x92>
    7d0c:	f3af 8000 	nop.w
    7d10:	00000000 	.word	0x00000000
    7d14:	3ff00000 	.word	0x3ff00000
    7d18:	8800759c 	.word	0x8800759c
    7d1c:	7e37e43c 	.word	0x7e37e43c
	...
    7d28:	7ff00000 	.word	0x7ff00000
    7d2c:	3ff00000 	.word	0x3ff00000
    7d30:	3fe00000 	.word	0x3fe00000
    7d34:	0000ab14 	.word	0x0000ab14
    7d38:	41e00000 	.word	0x41e00000
    7d3c:	3fefffff 	.word	0x3fefffff
    7d40:	433fffff 	.word	0x433fffff
    7d44:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    7d48:	f04f 0200 	mov.w	r2, #0
    7d4c:	da05      	bge.n	7d5a <__ieee754_pow+0x202>
    7d4e:	4bd6      	ldr	r3, [pc, #856]	; (80a8 <__ieee754_pow+0x550>)
    7d50:	f001 f856 	bl	8e00 <__aeabi_dmul>
    7d54:	f06f 0234 	mvn.w	r2, #52	; 0x34
    7d58:	460c      	mov	r4, r1
    7d5a:	1523      	asrs	r3, r4, #20
    7d5c:	4ed3      	ldr	r6, [pc, #844]	; (80ac <__ieee754_pow+0x554>)
    7d5e:	f3c4 0413 	ubfx	r4, r4, #0, #20
    7d62:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
    7d66:	4413      	add	r3, r2
    7d68:	f044 557f 	orr.w	r5, r4, #1069547520	; 0x3fc00000
    7d6c:	42b4      	cmp	r4, r6
    7d6e:	461a      	mov	r2, r3
    7d70:	930d      	str	r3, [sp, #52]	; 0x34
    7d72:	f445 1540 	orr.w	r5, r5, #3145728	; 0x300000
    7d76:	f340 8349 	ble.w	840c <__ieee754_pow+0x8b4>
    7d7a:	4bcd      	ldr	r3, [pc, #820]	; (80b0 <__ieee754_pow+0x558>)
    7d7c:	429c      	cmp	r4, r3
    7d7e:	f340 842d 	ble.w	85dc <__ieee754_pow+0xa84>
    7d82:	ed9f 7bb3 	vldr	d7, [pc, #716]	; 8050 <__ieee754_pow+0x4f8>
    7d86:	ed8d 7b08 	vstr	d7, [sp, #32]
    7d8a:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
    7d8e:	ed9f 7bb2 	vldr	d7, [pc, #712]	; 8058 <__ieee754_pow+0x500>
    7d92:	4613      	mov	r3, r2
    7d94:	ed8d 7b06 	vstr	d7, [sp, #24]
    7d98:	3301      	adds	r3, #1
    7d9a:	930d      	str	r3, [sp, #52]	; 0x34
    7d9c:	f5a5 1580 	sub.w	r5, r5, #1048576	; 0x100000
    7da0:	f04f 0800 	mov.w	r8, #0
    7da4:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    7da8:	4629      	mov	r1, r5
    7daa:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
    7dae:	f000 fe73 	bl	8a98 <__aeabi_dsub>
    7db2:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    7db6:	4606      	mov	r6, r0
    7db8:	460f      	mov	r7, r1
    7dba:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    7dbe:	f000 fe6d 	bl	8a9c <__adddf3>
    7dc2:	4602      	mov	r2, r0
    7dc4:	460b      	mov	r3, r1
    7dc6:	2000      	movs	r0, #0
    7dc8:	49ba      	ldr	r1, [pc, #744]	; (80b4 <__ieee754_pow+0x55c>)
    7dca:	f001 f943 	bl	9054 <__aeabi_ddiv>
    7dce:	4603      	mov	r3, r0
    7dd0:	460c      	mov	r4, r1
    7dd2:	e9cd 3410 	strd	r3, r4, [sp, #64]	; 0x40
    7dd6:	4602      	mov	r2, r0
    7dd8:	460b      	mov	r3, r1
    7dda:	4630      	mov	r0, r6
    7ddc:	4639      	mov	r1, r7
    7dde:	f001 f80f 	bl	8e00 <__aeabi_dmul>
    7de2:	106b      	asrs	r3, r5, #1
    7de4:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    7de8:	f503 2300 	add.w	r3, r3, #524288	; 0x80000
    7dec:	eb03 0508 	add.w	r5, r3, r8
    7df0:	460a      	mov	r2, r1
    7df2:	2300      	movs	r3, #0
    7df4:	4601      	mov	r1, r0
    7df6:	e9cd 1202 	strd	r1, r2, [sp, #8]
    7dfa:	9302      	str	r3, [sp, #8]
    7dfc:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
    7e00:	2400      	movs	r4, #0
    7e02:	e9cd 1204 	strd	r1, r2, [sp, #16]
    7e06:	462b      	mov	r3, r5
    7e08:	4622      	mov	r2, r4
    7e0a:	4640      	mov	r0, r8
    7e0c:	4649      	mov	r1, r9
    7e0e:	f000 fff7 	bl	8e00 <__aeabi_dmul>
    7e12:	4602      	mov	r2, r0
    7e14:	460b      	mov	r3, r1
    7e16:	4630      	mov	r0, r6
    7e18:	4639      	mov	r1, r7
    7e1a:	f000 fe3d 	bl	8a98 <__aeabi_dsub>
    7e1e:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    7e22:	4606      	mov	r6, r0
    7e24:	460f      	mov	r7, r1
    7e26:	4620      	mov	r0, r4
    7e28:	4629      	mov	r1, r5
    7e2a:	f000 fe35 	bl	8a98 <__aeabi_dsub>
    7e2e:	4602      	mov	r2, r0
    7e30:	460b      	mov	r3, r1
    7e32:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    7e36:	f000 fe2f 	bl	8a98 <__aeabi_dsub>
    7e3a:	4642      	mov	r2, r8
    7e3c:	464b      	mov	r3, r9
    7e3e:	f000 ffdf 	bl	8e00 <__aeabi_dmul>
    7e42:	4602      	mov	r2, r0
    7e44:	460b      	mov	r3, r1
    7e46:	4630      	mov	r0, r6
    7e48:	4639      	mov	r1, r7
    7e4a:	f000 fe25 	bl	8a98 <__aeabi_dsub>
    7e4e:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
    7e52:	f000 ffd5 	bl	8e00 <__aeabi_dmul>
    7e56:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
    7e5a:	e9cd 0106 	strd	r0, r1, [sp, #24]
    7e5e:	4622      	mov	r2, r4
    7e60:	462b      	mov	r3, r5
    7e62:	4620      	mov	r0, r4
    7e64:	4629      	mov	r1, r5
    7e66:	f000 ffcb 	bl	8e00 <__aeabi_dmul>
    7e6a:	a37d      	add	r3, pc, #500	; (adr r3, 8060 <__ieee754_pow+0x508>)
    7e6c:	e9d3 2300 	ldrd	r2, r3, [r3]
    7e70:	4604      	mov	r4, r0
    7e72:	460d      	mov	r5, r1
    7e74:	f000 ffc4 	bl	8e00 <__aeabi_dmul>
    7e78:	a37b      	add	r3, pc, #492	; (adr r3, 8068 <__ieee754_pow+0x510>)
    7e7a:	e9d3 2300 	ldrd	r2, r3, [r3]
    7e7e:	f000 fe0d 	bl	8a9c <__adddf3>
    7e82:	4622      	mov	r2, r4
    7e84:	462b      	mov	r3, r5
    7e86:	f000 ffbb 	bl	8e00 <__aeabi_dmul>
    7e8a:	a379      	add	r3, pc, #484	; (adr r3, 8070 <__ieee754_pow+0x518>)
    7e8c:	e9d3 2300 	ldrd	r2, r3, [r3]
    7e90:	f000 fe04 	bl	8a9c <__adddf3>
    7e94:	4622      	mov	r2, r4
    7e96:	462b      	mov	r3, r5
    7e98:	f000 ffb2 	bl	8e00 <__aeabi_dmul>
    7e9c:	a376      	add	r3, pc, #472	; (adr r3, 8078 <__ieee754_pow+0x520>)
    7e9e:	e9d3 2300 	ldrd	r2, r3, [r3]
    7ea2:	f000 fdfb 	bl	8a9c <__adddf3>
    7ea6:	4622      	mov	r2, r4
    7ea8:	462b      	mov	r3, r5
    7eaa:	f000 ffa9 	bl	8e00 <__aeabi_dmul>
    7eae:	a374      	add	r3, pc, #464	; (adr r3, 8080 <__ieee754_pow+0x528>)
    7eb0:	e9d3 2300 	ldrd	r2, r3, [r3]
    7eb4:	f000 fdf2 	bl	8a9c <__adddf3>
    7eb8:	4622      	mov	r2, r4
    7eba:	462b      	mov	r3, r5
    7ebc:	f000 ffa0 	bl	8e00 <__aeabi_dmul>
    7ec0:	a371      	add	r3, pc, #452	; (adr r3, 8088 <__ieee754_pow+0x530>)
    7ec2:	e9d3 2300 	ldrd	r2, r3, [r3]
    7ec6:	f000 fde9 	bl	8a9c <__adddf3>
    7eca:	4622      	mov	r2, r4
    7ecc:	4606      	mov	r6, r0
    7ece:	460f      	mov	r7, r1
    7ed0:	462b      	mov	r3, r5
    7ed2:	4620      	mov	r0, r4
    7ed4:	4629      	mov	r1, r5
    7ed6:	f000 ff93 	bl	8e00 <__aeabi_dmul>
    7eda:	4602      	mov	r2, r0
    7edc:	460b      	mov	r3, r1
    7ede:	4630      	mov	r0, r6
    7ee0:	4639      	mov	r1, r7
    7ee2:	f000 ff8d 	bl	8e00 <__aeabi_dmul>
    7ee6:	4642      	mov	r2, r8
    7ee8:	4604      	mov	r4, r0
    7eea:	460d      	mov	r5, r1
    7eec:	464b      	mov	r3, r9
    7eee:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    7ef2:	f000 fdd3 	bl	8a9c <__adddf3>
    7ef6:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    7efa:	f000 ff81 	bl	8e00 <__aeabi_dmul>
    7efe:	4622      	mov	r2, r4
    7f00:	462b      	mov	r3, r5
    7f02:	f000 fdcb 	bl	8a9c <__adddf3>
    7f06:	4642      	mov	r2, r8
    7f08:	4606      	mov	r6, r0
    7f0a:	460f      	mov	r7, r1
    7f0c:	464b      	mov	r3, r9
    7f0e:	4640      	mov	r0, r8
    7f10:	4649      	mov	r1, r9
    7f12:	f000 ff75 	bl	8e00 <__aeabi_dmul>
    7f16:	2200      	movs	r2, #0
    7f18:	4b67      	ldr	r3, [pc, #412]	; (80b8 <__ieee754_pow+0x560>)
    7f1a:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
    7f1e:	f000 fdbd 	bl	8a9c <__adddf3>
    7f22:	4632      	mov	r2, r6
    7f24:	463b      	mov	r3, r7
    7f26:	f000 fdb9 	bl	8a9c <__adddf3>
    7f2a:	9802      	ldr	r0, [sp, #8]
    7f2c:	460d      	mov	r5, r1
    7f2e:	4604      	mov	r4, r0
    7f30:	4622      	mov	r2, r4
    7f32:	462b      	mov	r3, r5
    7f34:	4640      	mov	r0, r8
    7f36:	4649      	mov	r1, r9
    7f38:	f000 ff62 	bl	8e00 <__aeabi_dmul>
    7f3c:	2200      	movs	r2, #0
    7f3e:	4680      	mov	r8, r0
    7f40:	4689      	mov	r9, r1
    7f42:	4b5d      	ldr	r3, [pc, #372]	; (80b8 <__ieee754_pow+0x560>)
    7f44:	4620      	mov	r0, r4
    7f46:	4629      	mov	r1, r5
    7f48:	f000 fda6 	bl	8a98 <__aeabi_dsub>
    7f4c:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
    7f50:	f000 fda2 	bl	8a98 <__aeabi_dsub>
    7f54:	4602      	mov	r2, r0
    7f56:	460b      	mov	r3, r1
    7f58:	4630      	mov	r0, r6
    7f5a:	4639      	mov	r1, r7
    7f5c:	f000 fd9c 	bl	8a98 <__aeabi_dsub>
    7f60:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    7f64:	f000 ff4c 	bl	8e00 <__aeabi_dmul>
    7f68:	4622      	mov	r2, r4
    7f6a:	4606      	mov	r6, r0
    7f6c:	460f      	mov	r7, r1
    7f6e:	462b      	mov	r3, r5
    7f70:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    7f74:	f000 ff44 	bl	8e00 <__aeabi_dmul>
    7f78:	4602      	mov	r2, r0
    7f7a:	460b      	mov	r3, r1
    7f7c:	4630      	mov	r0, r6
    7f7e:	4639      	mov	r1, r7
    7f80:	f000 fd8c 	bl	8a9c <__adddf3>
    7f84:	4606      	mov	r6, r0
    7f86:	460f      	mov	r7, r1
    7f88:	4602      	mov	r2, r0
    7f8a:	460b      	mov	r3, r1
    7f8c:	4640      	mov	r0, r8
    7f8e:	4649      	mov	r1, r9
    7f90:	e9cd 8904 	strd	r8, r9, [sp, #16]
    7f94:	f000 fd82 	bl	8a9c <__adddf3>
    7f98:	9802      	ldr	r0, [sp, #8]
    7f9a:	a33d      	add	r3, pc, #244	; (adr r3, 8090 <__ieee754_pow+0x538>)
    7f9c:	e9d3 2300 	ldrd	r2, r3, [r3]
    7fa0:	4604      	mov	r4, r0
    7fa2:	460d      	mov	r5, r1
    7fa4:	f000 ff2c 	bl	8e00 <__aeabi_dmul>
    7fa8:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    7fac:	4680      	mov	r8, r0
    7fae:	4689      	mov	r9, r1
    7fb0:	4620      	mov	r0, r4
    7fb2:	4629      	mov	r1, r5
    7fb4:	f000 fd70 	bl	8a98 <__aeabi_dsub>
    7fb8:	4602      	mov	r2, r0
    7fba:	460b      	mov	r3, r1
    7fbc:	4630      	mov	r0, r6
    7fbe:	4639      	mov	r1, r7
    7fc0:	f000 fd6a 	bl	8a98 <__aeabi_dsub>
    7fc4:	a334      	add	r3, pc, #208	; (adr r3, 8098 <__ieee754_pow+0x540>)
    7fc6:	e9d3 2300 	ldrd	r2, r3, [r3]
    7fca:	f000 ff19 	bl	8e00 <__aeabi_dmul>
    7fce:	a334      	add	r3, pc, #208	; (adr r3, 80a0 <__ieee754_pow+0x548>)
    7fd0:	e9d3 2300 	ldrd	r2, r3, [r3]
    7fd4:	4606      	mov	r6, r0
    7fd6:	460f      	mov	r7, r1
    7fd8:	4620      	mov	r0, r4
    7fda:	4629      	mov	r1, r5
    7fdc:	f000 ff10 	bl	8e00 <__aeabi_dmul>
    7fe0:	4602      	mov	r2, r0
    7fe2:	460b      	mov	r3, r1
    7fe4:	4630      	mov	r0, r6
    7fe6:	4639      	mov	r1, r7
    7fe8:	f000 fd58 	bl	8a9c <__adddf3>
    7fec:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
    7ff0:	f000 fd54 	bl	8a9c <__adddf3>
    7ff4:	4606      	mov	r6, r0
    7ff6:	980d      	ldr	r0, [sp, #52]	; 0x34
    7ff8:	460f      	mov	r7, r1
    7ffa:	f000 fe9b 	bl	8d34 <__aeabi_i2d>
    7ffe:	4632      	mov	r2, r6
    8000:	4604      	mov	r4, r0
    8002:	460d      	mov	r5, r1
    8004:	463b      	mov	r3, r7
    8006:	4640      	mov	r0, r8
    8008:	4649      	mov	r1, r9
    800a:	f000 fd47 	bl	8a9c <__adddf3>
    800e:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
    8012:	f000 fd43 	bl	8a9c <__adddf3>
    8016:	4622      	mov	r2, r4
    8018:	462b      	mov	r3, r5
    801a:	f000 fd3f 	bl	8a9c <__adddf3>
    801e:	9802      	ldr	r0, [sp, #8]
    8020:	4622      	mov	r2, r4
    8022:	462b      	mov	r3, r5
    8024:	e9cd 0102 	strd	r0, r1, [sp, #8]
    8028:	f000 fd36 	bl	8a98 <__aeabi_dsub>
    802c:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
    8030:	f000 fd32 	bl	8a98 <__aeabi_dsub>
    8034:	4642      	mov	r2, r8
    8036:	464b      	mov	r3, r9
    8038:	f000 fd2e 	bl	8a98 <__aeabi_dsub>
    803c:	4602      	mov	r2, r0
    803e:	460b      	mov	r3, r1
    8040:	4630      	mov	r0, r6
    8042:	4639      	mov	r1, r7
    8044:	f000 fd28 	bl	8a98 <__aeabi_dsub>
    8048:	4680      	mov	r8, r0
    804a:	4689      	mov	r9, r1
    804c:	e036      	b.n	80bc <__ieee754_pow+0x564>
    804e:	bf00      	nop
	...
    805c:	3ff00000 	.word	0x3ff00000
    8060:	4a454eef 	.word	0x4a454eef
    8064:	3fca7e28 	.word	0x3fca7e28
    8068:	93c9db65 	.word	0x93c9db65
    806c:	3fcd864a 	.word	0x3fcd864a
    8070:	a91d4101 	.word	0xa91d4101
    8074:	3fd17460 	.word	0x3fd17460
    8078:	518f264d 	.word	0x518f264d
    807c:	3fd55555 	.word	0x3fd55555
    8080:	db6fabff 	.word	0xdb6fabff
    8084:	3fdb6db6 	.word	0x3fdb6db6
    8088:	33333303 	.word	0x33333303
    808c:	3fe33333 	.word	0x3fe33333
    8090:	e0000000 	.word	0xe0000000
    8094:	3feec709 	.word	0x3feec709
    8098:	dc3a03fd 	.word	0xdc3a03fd
    809c:	3feec709 	.word	0x3feec709
    80a0:	145b01f5 	.word	0x145b01f5
    80a4:	be3e2fe0 	.word	0xbe3e2fe0
    80a8:	43400000 	.word	0x43400000
    80ac:	0003988e 	.word	0x0003988e
    80b0:	000bb679 	.word	0x000bb679
    80b4:	3ff00000 	.word	0x3ff00000
    80b8:	40080000 	.word	0x40080000
    80bc:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
    80c0:	ea53 030a 	orrs.w	r3, r3, sl
    80c4:	f000 8188 	beq.w	83d8 <__ieee754_pow+0x880>
    80c8:	ed9f 7bd7 	vldr	d7, [pc, #860]	; 8428 <__ieee754_pow+0x8d0>
    80cc:	ed8d 7b06 	vstr	d7, [sp, #24]
    80d0:	e9dd ab00 	ldrd	sl, fp, [sp]
    80d4:	4653      	mov	r3, sl
    80d6:	465c      	mov	r4, fp
    80d8:	e9cd 3400 	strd	r3, r4, [sp]
    80dc:	2300      	movs	r3, #0
    80de:	9300      	str	r3, [sp, #0]
    80e0:	e9dd 4500 	ldrd	r4, r5, [sp]
    80e4:	4650      	mov	r0, sl
    80e6:	4622      	mov	r2, r4
    80e8:	462b      	mov	r3, r5
    80ea:	4659      	mov	r1, fp
    80ec:	f000 fcd4 	bl	8a98 <__aeabi_dsub>
    80f0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    80f4:	f000 fe84 	bl	8e00 <__aeabi_dmul>
    80f8:	4652      	mov	r2, sl
    80fa:	4606      	mov	r6, r0
    80fc:	460f      	mov	r7, r1
    80fe:	465b      	mov	r3, fp
    8100:	4640      	mov	r0, r8
    8102:	4649      	mov	r1, r9
    8104:	f000 fe7c 	bl	8e00 <__aeabi_dmul>
    8108:	4602      	mov	r2, r0
    810a:	460b      	mov	r3, r1
    810c:	4630      	mov	r0, r6
    810e:	4639      	mov	r1, r7
    8110:	f000 fcc4 	bl	8a9c <__adddf3>
    8114:	4622      	mov	r2, r4
    8116:	4680      	mov	r8, r0
    8118:	4689      	mov	r9, r1
    811a:	462b      	mov	r3, r5
    811c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    8120:	e9cd 8904 	strd	r8, r9, [sp, #16]
    8124:	f000 fe6c 	bl	8e00 <__aeabi_dmul>
    8128:	460b      	mov	r3, r1
    812a:	4602      	mov	r2, r0
    812c:	4606      	mov	r6, r0
    812e:	460f      	mov	r7, r1
    8130:	4640      	mov	r0, r8
    8132:	4649      	mov	r1, r9
    8134:	f000 fcb2 	bl	8a9c <__adddf3>
    8138:	4bd5      	ldr	r3, [pc, #852]	; (8490 <__ieee754_pow+0x938>)
    813a:	4299      	cmp	r1, r3
    813c:	4604      	mov	r4, r0
    813e:	460d      	mov	r5, r1
    8140:	468a      	mov	sl, r1
    8142:	f340 8123 	ble.w	838c <__ieee754_pow+0x834>
    8146:	f101 433f 	add.w	r3, r1, #3204448256	; 0xbf000000
    814a:	f503 03e0 	add.w	r3, r3, #7340032	; 0x700000
    814e:	4303      	orrs	r3, r0
    8150:	f040 8218 	bne.w	8584 <__ieee754_pow+0xa2c>
    8154:	a3b6      	add	r3, pc, #728	; (adr r3, 8430 <__ieee754_pow+0x8d8>)
    8156:	e9d3 2300 	ldrd	r2, r3, [r3]
    815a:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    815e:	f000 fc9d 	bl	8a9c <__adddf3>
    8162:	4632      	mov	r2, r6
    8164:	4680      	mov	r8, r0
    8166:	4689      	mov	r9, r1
    8168:	463b      	mov	r3, r7
    816a:	4620      	mov	r0, r4
    816c:	4629      	mov	r1, r5
    816e:	f000 fc93 	bl	8a98 <__aeabi_dsub>
    8172:	4602      	mov	r2, r0
    8174:	460b      	mov	r3, r1
    8176:	4640      	mov	r0, r8
    8178:	4649      	mov	r1, r9
    817a:	f001 f8d1 	bl	9320 <__aeabi_dcmpgt>
    817e:	2800      	cmp	r0, #0
    8180:	f040 8200 	bne.w	8584 <__ieee754_pow+0xa2c>
    8184:	46a8      	mov	r8, r5
    8186:	ea4f 5328 	mov.w	r3, r8, asr #20
    818a:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    818e:	f2a3 33fe 	subw	r3, r3, #1022	; 0x3fe
    8192:	fa42 f303 	asr.w	r3, r2, r3
    8196:	4453      	add	r3, sl
    8198:	f3c3 520a 	ubfx	r2, r3, #20, #11
    819c:	4dbd      	ldr	r5, [pc, #756]	; (8494 <__ieee754_pow+0x93c>)
    819e:	f2a2 32ff 	subw	r2, r2, #1023	; 0x3ff
    81a2:	4115      	asrs	r5, r2
    81a4:	f3c3 0b13 	ubfx	fp, r3, #0, #20
    81a8:	2000      	movs	r0, #0
    81aa:	f1c2 0414 	rsb	r4, r2, #20
    81ae:	ea23 0105 	bic.w	r1, r3, r5
    81b2:	f44b 1b80 	orr.w	fp, fp, #1048576	; 0x100000
    81b6:	f1ba 0f00 	cmp.w	sl, #0
    81ba:	4602      	mov	r2, r0
    81bc:	460b      	mov	r3, r1
    81be:	fa4b fb04 	asr.w	fp, fp, r4
    81c2:	4630      	mov	r0, r6
    81c4:	4639      	mov	r1, r7
    81c6:	bfb8      	it	lt
    81c8:	f1cb 0b00 	rsblt	fp, fp, #0
    81cc:	f000 fc64 	bl	8a98 <__aeabi_dsub>
    81d0:	4602      	mov	r2, r0
    81d2:	460b      	mov	r3, r1
    81d4:	4606      	mov	r6, r0
    81d6:	460f      	mov	r7, r1
    81d8:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    81dc:	f000 fc5e 	bl	8a9c <__adddf3>
    81e0:	ea4f 5a0b 	mov.w	sl, fp, lsl #20
    81e4:	2400      	movs	r4, #0
    81e6:	a394      	add	r3, pc, #592	; (adr r3, 8438 <__ieee754_pow+0x8e0>)
    81e8:	e9d3 2300 	ldrd	r2, r3, [r3]
    81ec:	4620      	mov	r0, r4
    81ee:	460d      	mov	r5, r1
    81f0:	f000 fe06 	bl	8e00 <__aeabi_dmul>
    81f4:	4632      	mov	r2, r6
    81f6:	4680      	mov	r8, r0
    81f8:	4689      	mov	r9, r1
    81fa:	463b      	mov	r3, r7
    81fc:	4620      	mov	r0, r4
    81fe:	4629      	mov	r1, r5
    8200:	f000 fc4a 	bl	8a98 <__aeabi_dsub>
    8204:	4602      	mov	r2, r0
    8206:	460b      	mov	r3, r1
    8208:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    820c:	f000 fc44 	bl	8a98 <__aeabi_dsub>
    8210:	a38b      	add	r3, pc, #556	; (adr r3, 8440 <__ieee754_pow+0x8e8>)
    8212:	e9d3 2300 	ldrd	r2, r3, [r3]
    8216:	f000 fdf3 	bl	8e00 <__aeabi_dmul>
    821a:	a38b      	add	r3, pc, #556	; (adr r3, 8448 <__ieee754_pow+0x8f0>)
    821c:	e9d3 2300 	ldrd	r2, r3, [r3]
    8220:	4606      	mov	r6, r0
    8222:	460f      	mov	r7, r1
    8224:	4620      	mov	r0, r4
    8226:	4629      	mov	r1, r5
    8228:	f000 fdea 	bl	8e00 <__aeabi_dmul>
    822c:	4602      	mov	r2, r0
    822e:	460b      	mov	r3, r1
    8230:	4630      	mov	r0, r6
    8232:	4639      	mov	r1, r7
    8234:	f000 fc32 	bl	8a9c <__adddf3>
    8238:	4606      	mov	r6, r0
    823a:	460f      	mov	r7, r1
    823c:	4602      	mov	r2, r0
    823e:	460b      	mov	r3, r1
    8240:	4640      	mov	r0, r8
    8242:	4649      	mov	r1, r9
    8244:	f000 fc2a 	bl	8a9c <__adddf3>
    8248:	4642      	mov	r2, r8
    824a:	464b      	mov	r3, r9
    824c:	4604      	mov	r4, r0
    824e:	460d      	mov	r5, r1
    8250:	f000 fc22 	bl	8a98 <__aeabi_dsub>
    8254:	4602      	mov	r2, r0
    8256:	460b      	mov	r3, r1
    8258:	4630      	mov	r0, r6
    825a:	4639      	mov	r1, r7
    825c:	f000 fc1c 	bl	8a98 <__aeabi_dsub>
    8260:	4622      	mov	r2, r4
    8262:	4680      	mov	r8, r0
    8264:	4689      	mov	r9, r1
    8266:	462b      	mov	r3, r5
    8268:	4620      	mov	r0, r4
    826a:	4629      	mov	r1, r5
    826c:	f000 fdc8 	bl	8e00 <__aeabi_dmul>
    8270:	a377      	add	r3, pc, #476	; (adr r3, 8450 <__ieee754_pow+0x8f8>)
    8272:	e9d3 2300 	ldrd	r2, r3, [r3]
    8276:	4606      	mov	r6, r0
    8278:	460f      	mov	r7, r1
    827a:	f000 fdc1 	bl	8e00 <__aeabi_dmul>
    827e:	a376      	add	r3, pc, #472	; (adr r3, 8458 <__ieee754_pow+0x900>)
    8280:	e9d3 2300 	ldrd	r2, r3, [r3]
    8284:	f000 fc08 	bl	8a98 <__aeabi_dsub>
    8288:	4632      	mov	r2, r6
    828a:	463b      	mov	r3, r7
    828c:	f000 fdb8 	bl	8e00 <__aeabi_dmul>
    8290:	a373      	add	r3, pc, #460	; (adr r3, 8460 <__ieee754_pow+0x908>)
    8292:	e9d3 2300 	ldrd	r2, r3, [r3]
    8296:	f000 fc01 	bl	8a9c <__adddf3>
    829a:	4632      	mov	r2, r6
    829c:	463b      	mov	r3, r7
    829e:	f000 fdaf 	bl	8e00 <__aeabi_dmul>
    82a2:	a371      	add	r3, pc, #452	; (adr r3, 8468 <__ieee754_pow+0x910>)
    82a4:	e9d3 2300 	ldrd	r2, r3, [r3]
    82a8:	f000 fbf6 	bl	8a98 <__aeabi_dsub>
    82ac:	4632      	mov	r2, r6
    82ae:	463b      	mov	r3, r7
    82b0:	f000 fda6 	bl	8e00 <__aeabi_dmul>
    82b4:	a36e      	add	r3, pc, #440	; (adr r3, 8470 <__ieee754_pow+0x918>)
    82b6:	e9d3 2300 	ldrd	r2, r3, [r3]
    82ba:	f000 fbef 	bl	8a9c <__adddf3>
    82be:	4632      	mov	r2, r6
    82c0:	463b      	mov	r3, r7
    82c2:	f000 fd9d 	bl	8e00 <__aeabi_dmul>
    82c6:	4602      	mov	r2, r0
    82c8:	460b      	mov	r3, r1
    82ca:	4620      	mov	r0, r4
    82cc:	4629      	mov	r1, r5
    82ce:	f000 fbe3 	bl	8a98 <__aeabi_dsub>
    82d2:	4606      	mov	r6, r0
    82d4:	460f      	mov	r7, r1
    82d6:	4602      	mov	r2, r0
    82d8:	460b      	mov	r3, r1
    82da:	4620      	mov	r0, r4
    82dc:	4629      	mov	r1, r5
    82de:	f000 fd8f 	bl	8e00 <__aeabi_dmul>
    82e2:	2200      	movs	r2, #0
    82e4:	e9cd 0100 	strd	r0, r1, [sp]
    82e8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    82ec:	4630      	mov	r0, r6
    82ee:	4639      	mov	r1, r7
    82f0:	f000 fbd2 	bl	8a98 <__aeabi_dsub>
    82f4:	4602      	mov	r2, r0
    82f6:	460b      	mov	r3, r1
    82f8:	e9dd 0100 	ldrd	r0, r1, [sp]
    82fc:	f000 feaa 	bl	9054 <__aeabi_ddiv>
    8300:	4642      	mov	r2, r8
    8302:	4606      	mov	r6, r0
    8304:	460f      	mov	r7, r1
    8306:	464b      	mov	r3, r9
    8308:	4620      	mov	r0, r4
    830a:	4629      	mov	r1, r5
    830c:	f000 fd78 	bl	8e00 <__aeabi_dmul>
    8310:	4642      	mov	r2, r8
    8312:	464b      	mov	r3, r9
    8314:	f000 fbc2 	bl	8a9c <__adddf3>
    8318:	4602      	mov	r2, r0
    831a:	460b      	mov	r3, r1
    831c:	4630      	mov	r0, r6
    831e:	4639      	mov	r1, r7
    8320:	f000 fbba 	bl	8a98 <__aeabi_dsub>
    8324:	4622      	mov	r2, r4
    8326:	462b      	mov	r3, r5
    8328:	f000 fbb6 	bl	8a98 <__aeabi_dsub>
    832c:	4602      	mov	r2, r0
    832e:	460b      	mov	r3, r1
    8330:	2000      	movs	r0, #0
    8332:	4959      	ldr	r1, [pc, #356]	; (8498 <__ieee754_pow+0x940>)
    8334:	f000 fbb0 	bl	8a98 <__aeabi_dsub>
    8338:	448a      	add	sl, r1
    833a:	f5ba 1f80 	cmp.w	sl, #1048576	; 0x100000
    833e:	4602      	mov	r2, r0
    8340:	460b      	mov	r3, r1
    8342:	f2c0 815b 	blt.w	85fc <__ieee754_pow+0xaa4>
    8346:	4651      	mov	r1, sl
    8348:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    834c:	f000 fd58 	bl	8e00 <__aeabi_dmul>
    8350:	ec41 0b10 	vmov	d0, r0, r1
    8354:	e449      	b.n	7bea <__ieee754_pow+0x92>
    8356:	f104 4440 	add.w	r4, r4, #3221225472	; 0xc0000000
    835a:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
    835e:	ea54 030b 	orrs.w	r3, r4, fp
    8362:	f000 8137 	beq.w	85d4 <__ieee754_pow+0xa7c>
    8366:	f1bb 0f01 	cmp.w	fp, #1
    836a:	f47f ac80 	bne.w	7c6e <__ieee754_pow+0x116>
    836e:	4602      	mov	r2, r0
    8370:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
    8374:	ec43 2b10 	vmov	d0, r2, r3
    8378:	e437      	b.n	7bea <__ieee754_pow+0x92>
    837a:	4632      	mov	r2, r6
    837c:	463b      	mov	r3, r7
    837e:	4630      	mov	r0, r6
    8380:	4639      	mov	r1, r7
    8382:	f000 fd3d 	bl	8e00 <__aeabi_dmul>
    8386:	ec41 0b10 	vmov	d0, r0, r1
    838a:	e42e      	b.n	7bea <__ieee754_pow+0x92>
    838c:	4b43      	ldr	r3, [pc, #268]	; (849c <__ieee754_pow+0x944>)
    838e:	f021 4800 	bic.w	r8, r1, #2147483648	; 0x80000000
    8392:	4598      	cmp	r8, r3
    8394:	f340 8115 	ble.w	85c2 <__ieee754_pow+0xa6a>
    8398:	4b41      	ldr	r3, [pc, #260]	; (84a0 <__ieee754_pow+0x948>)
    839a:	440b      	add	r3, r1
    839c:	4303      	orrs	r3, r0
    839e:	d10c      	bne.n	83ba <__ieee754_pow+0x862>
    83a0:	4632      	mov	r2, r6
    83a2:	463b      	mov	r3, r7
    83a4:	f000 fb78 	bl	8a98 <__aeabi_dsub>
    83a8:	4602      	mov	r2, r0
    83aa:	460b      	mov	r3, r1
    83ac:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    83b0:	f000 ffa2 	bl	92f8 <__aeabi_dcmple>
    83b4:	2800      	cmp	r0, #0
    83b6:	f43f aee6 	beq.w	8186 <__ieee754_pow+0x62e>
    83ba:	a32f      	add	r3, pc, #188	; (adr r3, 8478 <__ieee754_pow+0x920>)
    83bc:	e9d3 2300 	ldrd	r2, r3, [r3]
    83c0:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    83c4:	f000 fd1c 	bl	8e00 <__aeabi_dmul>
    83c8:	a32b      	add	r3, pc, #172	; (adr r3, 8478 <__ieee754_pow+0x920>)
    83ca:	e9d3 2300 	ldrd	r2, r3, [r3]
    83ce:	f000 fd17 	bl	8e00 <__aeabi_dmul>
    83d2:	ec41 0b10 	vmov	d0, r0, r1
    83d6:	e408      	b.n	7bea <__ieee754_pow+0x92>
    83d8:	ed9f 7b29 	vldr	d7, [pc, #164]	; 8480 <__ieee754_pow+0x928>
    83dc:	ed8d 7b06 	vstr	d7, [sp, #24]
    83e0:	e676      	b.n	80d0 <__ieee754_pow+0x578>
    83e2:	f1b9 0f00 	cmp.w	r9, #0
    83e6:	f6bf ac8e 	bge.w	7d06 <__ieee754_pow+0x1ae>
    83ea:	e9dd 3400 	ldrd	r3, r4, [sp]
    83ee:	ee00 3a10 	vmov	s0, r3
    83f2:	f104 4300 	add.w	r3, r4, #2147483648	; 0x80000000
    83f6:	ee00 3a90 	vmov	s1, r3
    83fa:	f7ff bbf6 	b.w	7bea <__ieee754_pow+0x92>
    83fe:	4602      	mov	r2, r0
    8400:	460b      	mov	r3, r1
    8402:	2000      	movs	r0, #0
    8404:	4924      	ldr	r1, [pc, #144]	; (8498 <__ieee754_pow+0x940>)
    8406:	f000 fe25 	bl	9054 <__aeabi_ddiv>
    840a:	e42d      	b.n	7c68 <__ieee754_pow+0x110>
    840c:	ed9f 7b1e 	vldr	d7, [pc, #120]	; 8488 <__ieee754_pow+0x930>
    8410:	ed8d 7b08 	vstr	d7, [sp, #32]
    8414:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
    8418:	ed9f 7b03 	vldr	d7, [pc, #12]	; 8428 <__ieee754_pow+0x8d0>
    841c:	f04f 0800 	mov.w	r8, #0
    8420:	ed8d 7b06 	vstr	d7, [sp, #24]
    8424:	e4be      	b.n	7da4 <__ieee754_pow+0x24c>
    8426:	bf00      	nop
    8428:	00000000 	.word	0x00000000
    842c:	3ff00000 	.word	0x3ff00000
    8430:	652b82fe 	.word	0x652b82fe
    8434:	3c971547 	.word	0x3c971547
    8438:	00000000 	.word	0x00000000
    843c:	3fe62e43 	.word	0x3fe62e43
    8440:	fefa39ef 	.word	0xfefa39ef
    8444:	3fe62e42 	.word	0x3fe62e42
    8448:	0ca86c39 	.word	0x0ca86c39
    844c:	be205c61 	.word	0xbe205c61
    8450:	72bea4d0 	.word	0x72bea4d0
    8454:	3e663769 	.word	0x3e663769
    8458:	c5d26bf1 	.word	0xc5d26bf1
    845c:	3ebbbd41 	.word	0x3ebbbd41
    8460:	af25de2c 	.word	0xaf25de2c
    8464:	3f11566a 	.word	0x3f11566a
    8468:	16bebd93 	.word	0x16bebd93
    846c:	3f66c16c 	.word	0x3f66c16c
    8470:	5555553e 	.word	0x5555553e
    8474:	3fc55555 	.word	0x3fc55555
    8478:	c2f8f359 	.word	0xc2f8f359
    847c:	01a56e1f 	.word	0x01a56e1f
    8480:	00000000 	.word	0x00000000
    8484:	bff00000 	.word	0xbff00000
	...
    8490:	408fffff 	.word	0x408fffff
    8494:	000fffff 	.word	0x000fffff
    8498:	3ff00000 	.word	0x3ff00000
    849c:	4090cbff 	.word	0x4090cbff
    84a0:	3f6f3400 	.word	0x3f6f3400
    84a4:	4b6c      	ldr	r3, [pc, #432]	; (8658 <__ieee754_pow+0xb00>)
    84a6:	429c      	cmp	r4, r3
    84a8:	f77f ac2a 	ble.w	7d00 <__ieee754_pow+0x1a8>
    84ac:	4b6b      	ldr	r3, [pc, #428]	; (865c <__ieee754_pow+0xb04>)
    84ae:	429c      	cmp	r4, r3
    84b0:	f73f abc3 	bgt.w	7c3a <__ieee754_pow+0xe2>
    84b4:	2200      	movs	r2, #0
    84b6:	4b69      	ldr	r3, [pc, #420]	; (865c <__ieee754_pow+0xb04>)
    84b8:	f000 faee 	bl	8a98 <__aeabi_dsub>
    84bc:	a356      	add	r3, pc, #344	; (adr r3, 8618 <__ieee754_pow+0xac0>)
    84be:	e9d3 2300 	ldrd	r2, r3, [r3]
    84c2:	4604      	mov	r4, r0
    84c4:	460d      	mov	r5, r1
    84c6:	f000 fc9b 	bl	8e00 <__aeabi_dmul>
    84ca:	a355      	add	r3, pc, #340	; (adr r3, 8620 <__ieee754_pow+0xac8>)
    84cc:	e9d3 2300 	ldrd	r2, r3, [r3]
    84d0:	4680      	mov	r8, r0
    84d2:	4689      	mov	r9, r1
    84d4:	4620      	mov	r0, r4
    84d6:	4629      	mov	r1, r5
    84d8:	f000 fc92 	bl	8e00 <__aeabi_dmul>
    84dc:	2200      	movs	r2, #0
    84de:	e9cd 0102 	strd	r0, r1, [sp, #8]
    84e2:	4b5f      	ldr	r3, [pc, #380]	; (8660 <__ieee754_pow+0xb08>)
    84e4:	4620      	mov	r0, r4
    84e6:	4629      	mov	r1, r5
    84e8:	f000 fc8a 	bl	8e00 <__aeabi_dmul>
    84ec:	4602      	mov	r2, r0
    84ee:	460b      	mov	r3, r1
    84f0:	a14d      	add	r1, pc, #308	; (adr r1, 8628 <__ieee754_pow+0xad0>)
    84f2:	e9d1 0100 	ldrd	r0, r1, [r1]
    84f6:	f000 facf 	bl	8a98 <__aeabi_dsub>
    84fa:	4622      	mov	r2, r4
    84fc:	462b      	mov	r3, r5
    84fe:	f000 fc7f 	bl	8e00 <__aeabi_dmul>
    8502:	4602      	mov	r2, r0
    8504:	460b      	mov	r3, r1
    8506:	2000      	movs	r0, #0
    8508:	4956      	ldr	r1, [pc, #344]	; (8664 <__ieee754_pow+0xb0c>)
    850a:	f000 fac5 	bl	8a98 <__aeabi_dsub>
    850e:	4622      	mov	r2, r4
    8510:	462b      	mov	r3, r5
    8512:	4606      	mov	r6, r0
    8514:	460f      	mov	r7, r1
    8516:	4620      	mov	r0, r4
    8518:	4629      	mov	r1, r5
    851a:	f000 fc71 	bl	8e00 <__aeabi_dmul>
    851e:	4602      	mov	r2, r0
    8520:	460b      	mov	r3, r1
    8522:	4630      	mov	r0, r6
    8524:	4639      	mov	r1, r7
    8526:	f000 fc6b 	bl	8e00 <__aeabi_dmul>
    852a:	a341      	add	r3, pc, #260	; (adr r3, 8630 <__ieee754_pow+0xad8>)
    852c:	e9d3 2300 	ldrd	r2, r3, [r3]
    8530:	f000 fc66 	bl	8e00 <__aeabi_dmul>
    8534:	4602      	mov	r2, r0
    8536:	460b      	mov	r3, r1
    8538:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    853c:	f000 faac 	bl	8a98 <__aeabi_dsub>
    8540:	4602      	mov	r2, r0
    8542:	460b      	mov	r3, r1
    8544:	4604      	mov	r4, r0
    8546:	460d      	mov	r5, r1
    8548:	4640      	mov	r0, r8
    854a:	4649      	mov	r1, r9
    854c:	f000 faa6 	bl	8a9c <__adddf3>
    8550:	4642      	mov	r2, r8
    8552:	464b      	mov	r3, r9
    8554:	2000      	movs	r0, #0
    8556:	e9cd 0102 	strd	r0, r1, [sp, #8]
    855a:	f000 fa9d 	bl	8a98 <__aeabi_dsub>
    855e:	4602      	mov	r2, r0
    8560:	460b      	mov	r3, r1
    8562:	4620      	mov	r0, r4
    8564:	4629      	mov	r1, r5
    8566:	f000 fa97 	bl	8a98 <__aeabi_dsub>
    856a:	4680      	mov	r8, r0
    856c:	4689      	mov	r9, r1
    856e:	e5a5      	b.n	80bc <__ieee754_pow+0x564>
    8570:	4632      	mov	r2, r6
    8572:	463b      	mov	r3, r7
    8574:	2000      	movs	r0, #0
    8576:	4939      	ldr	r1, [pc, #228]	; (865c <__ieee754_pow+0xb04>)
    8578:	f000 fd6c 	bl	9054 <__aeabi_ddiv>
    857c:	ec41 0b10 	vmov	d0, r0, r1
    8580:	f7ff bb33 	b.w	7bea <__ieee754_pow+0x92>
    8584:	a32c      	add	r3, pc, #176	; (adr r3, 8638 <__ieee754_pow+0xae0>)
    8586:	e9d3 2300 	ldrd	r2, r3, [r3]
    858a:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    858e:	f000 fc37 	bl	8e00 <__aeabi_dmul>
    8592:	a329      	add	r3, pc, #164	; (adr r3, 8638 <__ieee754_pow+0xae0>)
    8594:	e9d3 2300 	ldrd	r2, r3, [r3]
    8598:	f000 fc32 	bl	8e00 <__aeabi_dmul>
    859c:	ec41 0b10 	vmov	d0, r0, r1
    85a0:	f7ff bb23 	b.w	7bea <__ieee754_pow+0x92>
    85a4:	f1be 0f00 	cmp.w	lr, #0
    85a8:	f47f ab2a 	bne.w	7c00 <__ieee754_pow+0xa8>
    85ac:	f1c3 0314 	rsb	r3, r3, #20
    85b0:	fa48 f203 	asr.w	r2, r8, r3
    85b4:	fa02 f303 	lsl.w	r3, r2, r3
    85b8:	4598      	cmp	r8, r3
    85ba:	d027      	beq.n	860c <__ieee754_pow+0xab4>
    85bc:	46f3      	mov	fp, lr
    85be:	f7ff baf7 	b.w	7bb0 <__ieee754_pow+0x58>
    85c2:	4b28      	ldr	r3, [pc, #160]	; (8664 <__ieee754_pow+0xb0c>)
    85c4:	4598      	cmp	r8, r3
    85c6:	f73f adde 	bgt.w	8186 <__ieee754_pow+0x62e>
    85ca:	e9dd 3400 	ldrd	r3, r4, [sp]
    85ce:	469a      	mov	sl, r3
    85d0:	469b      	mov	fp, r3
    85d2:	e607      	b.n	81e4 <__ieee754_pow+0x68c>
    85d4:	4602      	mov	r2, r0
    85d6:	460b      	mov	r3, r1
    85d8:	f7ff bb89 	b.w	7cee <__ieee754_pow+0x196>
    85dc:	ed9f 7b18 	vldr	d7, [pc, #96]	; 8640 <__ieee754_pow+0xae8>
    85e0:	ed8d 7b08 	vstr	d7, [sp, #32]
    85e4:	ed9f 7b18 	vldr	d7, [pc, #96]	; 8648 <__ieee754_pow+0xaf0>
    85e8:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
    85ec:	ed9f 7b18 	vldr	d7, [pc, #96]	; 8650 <__ieee754_pow+0xaf8>
    85f0:	f44f 2880 	mov.w	r8, #262144	; 0x40000
    85f4:	ed8d 7b06 	vstr	d7, [sp, #24]
    85f8:	f7ff bbd4 	b.w	7da4 <__ieee754_pow+0x24c>
    85fc:	4658      	mov	r0, fp
    85fe:	ec43 2b10 	vmov	d0, r2, r3
    8602:	f000 f9b1 	bl	8968 <scalbn>
    8606:	ec51 0b10 	vmov	r0, r1, d0
    860a:	e69d      	b.n	8348 <__ieee754_pow+0x7f0>
    860c:	f002 0201 	and.w	r2, r2, #1
    8610:	f1c2 0b02 	rsb	fp, r2, #2
    8614:	f7ff bacc 	b.w	7bb0 <__ieee754_pow+0x58>
    8618:	60000000 	.word	0x60000000
    861c:	3ff71547 	.word	0x3ff71547
    8620:	f85ddf44 	.word	0xf85ddf44
    8624:	3e54ae0b 	.word	0x3e54ae0b
    8628:	55555555 	.word	0x55555555
    862c:	3fd55555 	.word	0x3fd55555
    8630:	652b82fe 	.word	0x652b82fe
    8634:	3ff71547 	.word	0x3ff71547
    8638:	8800759c 	.word	0x8800759c
    863c:	7e37e43c 	.word	0x7e37e43c
    8640:	40000000 	.word	0x40000000
    8644:	3fe2b803 	.word	0x3fe2b803
    8648:	43cfd006 	.word	0x43cfd006
    864c:	3e4cfdeb 	.word	0x3e4cfdeb
    8650:	00000000 	.word	0x00000000
    8654:	3ff80000 	.word	0x3ff80000
    8658:	3feffffe 	.word	0x3feffffe
    865c:	3ff00000 	.word	0x3ff00000
    8660:	3fd00000 	.word	0x3fd00000
    8664:	3fe00000 	.word	0x3fe00000

00008668 <__ieee754_sqrt>:
    8668:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    866c:	4965      	ldr	r1, [pc, #404]	; (8804 <__ieee754_sqrt+0x19c>)
    866e:	ec55 4b10 	vmov	r4, r5, d0
    8672:	460e      	mov	r6, r1
    8674:	4029      	ands	r1, r5
    8676:	42b1      	cmp	r1, r6
    8678:	f000 8097 	beq.w	87aa <__ieee754_sqrt+0x142>
    867c:	2d00      	cmp	r5, #0
    867e:	462b      	mov	r3, r5
    8680:	ee10 2a10 	vmov	r2, s0
    8684:	dd74      	ble.n	8770 <__ieee754_sqrt+0x108>
    8686:	152f      	asrs	r7, r5, #20
    8688:	d07f      	beq.n	878a <__ieee754_sqrt+0x122>
    868a:	f2a7 37ff 	subw	r7, r7, #1023	; 0x3ff
    868e:	f3c3 0313 	ubfx	r3, r3, #0, #20
    8692:	07f9      	lsls	r1, r7, #31
    8694:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    8698:	d465      	bmi.n	8766 <__ieee754_sqrt+0xfe>
    869a:	eb03 71d2 	add.w	r1, r3, r2, lsr #31
    869e:	2600      	movs	r6, #0
    86a0:	440b      	add	r3, r1
    86a2:	107f      	asrs	r7, r7, #1
    86a4:	0052      	lsls	r2, r2, #1
    86a6:	46b6      	mov	lr, r6
    86a8:	2016      	movs	r0, #22
    86aa:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
    86ae:	eb0e 0401 	add.w	r4, lr, r1
    86b2:	429c      	cmp	r4, r3
    86b4:	ea4f 75d2 	mov.w	r5, r2, lsr #31
    86b8:	ea4f 0242 	mov.w	r2, r2, lsl #1
    86bc:	dc03      	bgt.n	86c6 <__ieee754_sqrt+0x5e>
    86be:	1b1b      	subs	r3, r3, r4
    86c0:	eb04 0e01 	add.w	lr, r4, r1
    86c4:	440e      	add	r6, r1
    86c6:	3801      	subs	r0, #1
    86c8:	eb05 0343 	add.w	r3, r5, r3, lsl #1
    86cc:	ea4f 0151 	mov.w	r1, r1, lsr #1
    86d0:	d1ed      	bne.n	86ae <__ieee754_sqrt+0x46>
    86d2:	4684      	mov	ip, r0
    86d4:	2420      	movs	r4, #32
    86d6:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    86da:	e009      	b.n	86f0 <__ieee754_sqrt+0x88>
    86dc:	d020      	beq.n	8720 <__ieee754_sqrt+0xb8>
    86de:	eb03 75d2 	add.w	r5, r3, r2, lsr #31
    86e2:	3c01      	subs	r4, #1
    86e4:	ea4f 0151 	mov.w	r1, r1, lsr #1
    86e8:	442b      	add	r3, r5
    86ea:	ea4f 0242 	mov.w	r2, r2, lsl #1
    86ee:	d020      	beq.n	8732 <__ieee754_sqrt+0xca>
    86f0:	459e      	cmp	lr, r3
    86f2:	eb01 050c 	add.w	r5, r1, ip
    86f6:	daf1      	bge.n	86dc <__ieee754_sqrt+0x74>
    86f8:	2d00      	cmp	r5, #0
    86fa:	eb05 0c01 	add.w	ip, r5, r1
    86fe:	db09      	blt.n	8714 <__ieee754_sqrt+0xac>
    8700:	46f0      	mov	r8, lr
    8702:	4295      	cmp	r5, r2
    8704:	ebce 0303 	rsb	r3, lr, r3
    8708:	d900      	bls.n	870c <__ieee754_sqrt+0xa4>
    870a:	3b01      	subs	r3, #1
    870c:	1b52      	subs	r2, r2, r5
    870e:	4408      	add	r0, r1
    8710:	46c6      	mov	lr, r8
    8712:	e7e4      	b.n	86de <__ieee754_sqrt+0x76>
    8714:	f1bc 0f00 	cmp.w	ip, #0
    8718:	dbf2      	blt.n	8700 <__ieee754_sqrt+0x98>
    871a:	f10e 0801 	add.w	r8, lr, #1
    871e:	e7f0      	b.n	8702 <__ieee754_sqrt+0x9a>
    8720:	4295      	cmp	r5, r2
    8722:	d81e      	bhi.n	8762 <__ieee754_sqrt+0xfa>
    8724:	2d00      	cmp	r5, #0
    8726:	eb05 0c01 	add.w	ip, r5, r1
    872a:	db50      	blt.n	87ce <__ieee754_sqrt+0x166>
    872c:	4698      	mov	r8, r3
    872e:	2300      	movs	r3, #0
    8730:	e7ec      	b.n	870c <__ieee754_sqrt+0xa4>
    8732:	4313      	orrs	r3, r2
    8734:	d004      	beq.n	8740 <__ieee754_sqrt+0xd8>
    8736:	1c42      	adds	r2, r0, #1
    8738:	d04d      	beq.n	87d6 <__ieee754_sqrt+0x16e>
    873a:	f000 0301 	and.w	r3, r0, #1
    873e:	4418      	add	r0, r3
    8740:	0840      	lsrs	r0, r0, #1
    8742:	1071      	asrs	r1, r6, #1
    8744:	07f3      	lsls	r3, r6, #31
    8746:	f101 517f 	add.w	r1, r1, #1069547520	; 0x3fc00000
    874a:	f501 1100 	add.w	r1, r1, #2097152	; 0x200000
    874e:	bf48      	it	mi
    8750:	f040 4000 	orrmi.w	r0, r0, #2147483648	; 0x80000000
    8754:	eb01 5307 	add.w	r3, r1, r7, lsl #20
    8758:	4602      	mov	r2, r0
    875a:	ec43 2b10 	vmov	d0, r2, r3
    875e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8762:	4673      	mov	r3, lr
    8764:	e7bb      	b.n	86de <__ieee754_sqrt+0x76>
    8766:	005b      	lsls	r3, r3, #1
    8768:	eb03 73d2 	add.w	r3, r3, r2, lsr #31
    876c:	0052      	lsls	r2, r2, #1
    876e:	e794      	b.n	869a <__ieee754_sqrt+0x32>
    8770:	f025 4100 	bic.w	r1, r5, #2147483648	; 0x80000000
    8774:	4321      	orrs	r1, r4
    8776:	d028      	beq.n	87ca <__ieee754_sqrt+0x162>
    8778:	bbad      	cbnz	r5, 87e6 <__ieee754_sqrt+0x17e>
    877a:	462f      	mov	r7, r5
    877c:	0ad3      	lsrs	r3, r2, #11
    877e:	3f15      	subs	r7, #21
    8780:	0552      	lsls	r2, r2, #21
    8782:	2b00      	cmp	r3, #0
    8784:	d0fa      	beq.n	877c <__ieee754_sqrt+0x114>
    8786:	02dd      	lsls	r5, r3, #11
    8788:	d428      	bmi.n	87dc <__ieee754_sqrt+0x174>
    878a:	2100      	movs	r1, #0
    878c:	e000      	b.n	8790 <__ieee754_sqrt+0x128>
    878e:	4601      	mov	r1, r0
    8790:	005b      	lsls	r3, r3, #1
    8792:	02dc      	lsls	r4, r3, #11
    8794:	f101 0001 	add.w	r0, r1, #1
    8798:	d5f9      	bpl.n	878e <__ieee754_sqrt+0x126>
    879a:	f1c0 0420 	rsb	r4, r0, #32
    879e:	fa22 f404 	lsr.w	r4, r2, r4
    87a2:	4323      	orrs	r3, r4
    87a4:	1a7f      	subs	r7, r7, r1
    87a6:	4082      	lsls	r2, r0
    87a8:	e76f      	b.n	868a <__ieee754_sqrt+0x22>
    87aa:	ee10 2a10 	vmov	r2, s0
    87ae:	462b      	mov	r3, r5
    87b0:	ee10 0a10 	vmov	r0, s0
    87b4:	4629      	mov	r1, r5
    87b6:	f000 fb23 	bl	8e00 <__aeabi_dmul>
    87ba:	4622      	mov	r2, r4
    87bc:	462b      	mov	r3, r5
    87be:	f000 f96d 	bl	8a9c <__adddf3>
    87c2:	ec41 0b10 	vmov	d0, r0, r1
    87c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    87ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    87ce:	f1bc 0f00 	cmp.w	ip, #0
    87d2:	daa2      	bge.n	871a <__ieee754_sqrt+0xb2>
    87d4:	e7aa      	b.n	872c <__ieee754_sqrt+0xc4>
    87d6:	3601      	adds	r6, #1
    87d8:	4620      	mov	r0, r4
    87da:	e7b2      	b.n	8742 <__ieee754_sqrt+0xda>
    87dc:	2420      	movs	r4, #32
    87de:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    87e2:	2000      	movs	r0, #0
    87e4:	e7db      	b.n	879e <__ieee754_sqrt+0x136>
    87e6:	ee10 2a10 	vmov	r2, s0
    87ea:	462b      	mov	r3, r5
    87ec:	4620      	mov	r0, r4
    87ee:	4629      	mov	r1, r5
    87f0:	f000 f952 	bl	8a98 <__aeabi_dsub>
    87f4:	4602      	mov	r2, r0
    87f6:	460b      	mov	r3, r1
    87f8:	f000 fc2c 	bl	9054 <__aeabi_ddiv>
    87fc:	ec41 0b10 	vmov	d0, r0, r1
    8800:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8804:	7ff00000 	.word	0x7ff00000

00008808 <fabs>:
    8808:	ec53 2b10 	vmov	r2, r3, d0
    880c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    8810:	ec43 2b10 	vmov	d0, r2, r3
    8814:	4770      	bx	lr
    8816:	bf00      	nop

00008818 <finite>:
    8818:	ee10 3a90 	vmov	r3, s1
    881c:	f043 4000 	orr.w	r0, r3, #2147483648	; 0x80000000
    8820:	f500 1080 	add.w	r0, r0, #1048576	; 0x100000
    8824:	0fc0      	lsrs	r0, r0, #31
    8826:	4770      	bx	lr

00008828 <matherr>:
    8828:	2000      	movs	r0, #0
    882a:	4770      	bx	lr
    882c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

00008830 <nan>:
    8830:	ed9f 0b01 	vldr	d0, [pc, #4]	; 8838 <nan+0x8>
    8834:	4770      	bx	lr
    8836:	bf00      	nop
    8838:	00000000 	.word	0x00000000
    883c:	7ff80000 	.word	0x7ff80000

00008840 <rint>:
    8840:	b5f0      	push	{r4, r5, r6, r7, lr}
    8842:	ec53 2b10 	vmov	r2, r3, d0
    8846:	f3c3 560a 	ubfx	r6, r3, #20, #11
    884a:	f2a6 30ff 	subw	r0, r6, #1023	; 0x3ff
    884e:	2813      	cmp	r0, #19
    8850:	b083      	sub	sp, #12
    8852:	4619      	mov	r1, r3
    8854:	ea4f 74d3 	mov.w	r4, r3, lsr #31
    8858:	ee10 5a10 	vmov	r5, s0
    885c:	dc2f      	bgt.n	88be <rint+0x7e>
    885e:	2800      	cmp	r0, #0
    8860:	db49      	blt.n	88f6 <rint+0xb6>
    8862:	4e3f      	ldr	r6, [pc, #252]	; (8960 <rint+0x120>)
    8864:	4106      	asrs	r6, r0
    8866:	ea03 0706 	and.w	r7, r3, r6
    886a:	4317      	orrs	r7, r2
    886c:	d02c      	beq.n	88c8 <rint+0x88>
    886e:	0876      	lsrs	r6, r6, #1
    8870:	4033      	ands	r3, r6
    8872:	431d      	orrs	r5, r3
    8874:	d00c      	beq.n	8890 <rint+0x50>
    8876:	f44f 2380 	mov.w	r3, #262144	; 0x40000
    887a:	2813      	cmp	r0, #19
    887c:	ea21 0606 	bic.w	r6, r1, r6
    8880:	fa43 f100 	asr.w	r1, r3, r0
    8884:	ea41 0106 	orr.w	r1, r1, r6
    8888:	bf0c      	ite	eq
    888a:	f04f 4500 	moveq.w	r5, #2147483648	; 0x80000000
    888e:	2500      	movne	r5, #0
    8890:	4834      	ldr	r0, [pc, #208]	; (8964 <rint+0x124>)
    8892:	eb00 04c4 	add.w	r4, r0, r4, lsl #3
    8896:	462a      	mov	r2, r5
    8898:	e9d4 4500 	ldrd	r4, r5, [r4]
    889c:	4610      	mov	r0, r2
    889e:	462b      	mov	r3, r5
    88a0:	4622      	mov	r2, r4
    88a2:	f000 f8fb 	bl	8a9c <__adddf3>
    88a6:	e9cd 0100 	strd	r0, r1, [sp]
    88aa:	4622      	mov	r2, r4
    88ac:	462b      	mov	r3, r5
    88ae:	e9dd 0100 	ldrd	r0, r1, [sp]
    88b2:	f000 f8f1 	bl	8a98 <__aeabi_dsub>
    88b6:	ec41 0b10 	vmov	d0, r0, r1
    88ba:	b003      	add	sp, #12
    88bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    88be:	2833      	cmp	r0, #51	; 0x33
    88c0:	dd06      	ble.n	88d0 <rint+0x90>
    88c2:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
    88c6:	d042      	beq.n	894e <rint+0x10e>
    88c8:	ec43 2b10 	vmov	d0, r2, r3
    88cc:	b003      	add	sp, #12
    88ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
    88d0:	f2a6 4613 	subw	r6, r6, #1043	; 0x413
    88d4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    88d8:	40f0      	lsrs	r0, r6
    88da:	4202      	tst	r2, r0
    88dc:	d0f4      	beq.n	88c8 <rint+0x88>
    88de:	0840      	lsrs	r0, r0, #1
    88e0:	4202      	tst	r2, r0
    88e2:	d0d5      	beq.n	8890 <rint+0x50>
    88e4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    88e8:	ea25 0000 	bic.w	r0, r5, r0
    88ec:	fa43 f606 	asr.w	r6, r3, r6
    88f0:	ea46 0500 	orr.w	r5, r6, r0
    88f4:	e7cc      	b.n	8890 <rint+0x50>
    88f6:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
    88fa:	4310      	orrs	r0, r2
    88fc:	ee10 7a10 	vmov	r7, s0
    8900:	d0e2      	beq.n	88c8 <rint+0x88>
    8902:	f3c3 0013 	ubfx	r0, r3, #0, #20
    8906:	4307      	orrs	r7, r0
    8908:	4278      	negs	r0, r7
    890a:	4307      	orrs	r7, r0
    890c:	4815      	ldr	r0, [pc, #84]	; (8964 <rint+0x124>)
    890e:	0c59      	lsrs	r1, r3, #17
    8910:	0b3f      	lsrs	r7, r7, #12
    8912:	0449      	lsls	r1, r1, #17
    8914:	f407 2700 	and.w	r7, r7, #524288	; 0x80000
    8918:	eb00 00c4 	add.w	r0, r0, r4, lsl #3
    891c:	ea47 0301 	orr.w	r3, r7, r1
    8920:	e9d0 6700 	ldrd	r6, r7, [r0]
    8924:	4619      	mov	r1, r3
    8926:	4610      	mov	r0, r2
    8928:	463b      	mov	r3, r7
    892a:	4632      	mov	r2, r6
    892c:	f000 f8b6 	bl	8a9c <__adddf3>
    8930:	e9cd 0100 	strd	r0, r1, [sp]
    8934:	463b      	mov	r3, r7
    8936:	4632      	mov	r2, r6
    8938:	e9dd 0100 	ldrd	r0, r1, [sp]
    893c:	f000 f8ac 	bl	8a98 <__aeabi_dsub>
    8940:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
    8944:	ea43 71c4 	orr.w	r1, r3, r4, lsl #31
    8948:	ec41 0b10 	vmov	d0, r0, r1
    894c:	e7be      	b.n	88cc <rint+0x8c>
    894e:	ee10 0a10 	vmov	r0, s0
    8952:	4619      	mov	r1, r3
    8954:	f000 f8a2 	bl	8a9c <__adddf3>
    8958:	ec41 0b10 	vmov	d0, r0, r1
    895c:	e7b6      	b.n	88cc <rint+0x8c>
    895e:	bf00      	nop
    8960:	000fffff 	.word	0x000fffff
    8964:	0000af40 	.word	0x0000af40

00008968 <scalbn>:
    8968:	ec53 2b10 	vmov	r2, r3, d0
    896c:	b570      	push	{r4, r5, r6, lr}
    896e:	f3c3 540a 	ubfx	r4, r3, #20, #11
    8972:	4619      	mov	r1, r3
    8974:	4605      	mov	r5, r0
    8976:	bb14      	cbnz	r4, 89be <scalbn+0x56>
    8978:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
    897c:	4311      	orrs	r1, r2
    897e:	d02a      	beq.n	89d6 <scalbn+0x6e>
    8980:	4619      	mov	r1, r3
    8982:	2200      	movs	r2, #0
    8984:	4b38      	ldr	r3, [pc, #224]	; (8a68 <scalbn+0x100>)
    8986:	4e39      	ldr	r6, [pc, #228]	; (8a6c <scalbn+0x104>)
    8988:	ee10 0a10 	vmov	r0, s0
    898c:	f000 fa38 	bl	8e00 <__aeabi_dmul>
    8990:	42b5      	cmp	r5, r6
    8992:	4602      	mov	r2, r0
    8994:	460b      	mov	r3, r1
    8996:	db1f      	blt.n	89d8 <scalbn+0x70>
    8998:	f3c1 540a 	ubfx	r4, r1, #20, #11
    899c:	3c36      	subs	r4, #54	; 0x36
    899e:	442c      	add	r4, r5
    89a0:	f240 70fe 	movw	r0, #2046	; 0x7fe
    89a4:	4284      	cmp	r4, r0
    89a6:	dc1f      	bgt.n	89e8 <scalbn+0x80>
    89a8:	2c00      	cmp	r4, #0
    89aa:	dd2d      	ble.n	8a08 <scalbn+0xa0>
    89ac:	f021 41ff 	bic.w	r1, r1, #2139095040	; 0x7f800000
    89b0:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
    89b4:	ea41 5304 	orr.w	r3, r1, r4, lsl #20
    89b8:	ec43 2b10 	vmov	d0, r2, r3
    89bc:	bd70      	pop	{r4, r5, r6, pc}
    89be:	f240 70ff 	movw	r0, #2047	; 0x7ff
    89c2:	4284      	cmp	r4, r0
    89c4:	d1eb      	bne.n	899e <scalbn+0x36>
    89c6:	ee10 0a10 	vmov	r0, s0
    89ca:	4619      	mov	r1, r3
    89cc:	f000 f866 	bl	8a9c <__adddf3>
    89d0:	ec41 0b10 	vmov	d0, r0, r1
    89d4:	bd70      	pop	{r4, r5, r6, pc}
    89d6:	bd70      	pop	{r4, r5, r6, pc}
    89d8:	a31f      	add	r3, pc, #124	; (adr r3, 8a58 <scalbn+0xf0>)
    89da:	e9d3 2300 	ldrd	r2, r3, [r3]
    89de:	f000 fa0f 	bl	8e00 <__aeabi_dmul>
    89e2:	ec41 0b10 	vmov	d0, r0, r1
    89e6:	bd70      	pop	{r4, r5, r6, pc}
    89e8:	ec43 2b11 	vmov	d1, r2, r3
    89ec:	ed9f 0b1c 	vldr	d0, [pc, #112]	; 8a60 <scalbn+0xf8>
    89f0:	f000 f840 	bl	8a74 <copysign>
    89f4:	a31a      	add	r3, pc, #104	; (adr r3, 8a60 <scalbn+0xf8>)
    89f6:	e9d3 2300 	ldrd	r2, r3, [r3]
    89fa:	ec51 0b10 	vmov	r0, r1, d0
    89fe:	f000 f9ff 	bl	8e00 <__aeabi_dmul>
    8a02:	ec41 0b10 	vmov	d0, r0, r1
    8a06:	bd70      	pop	{r4, r5, r6, pc}
    8a08:	f114 0f35 	cmn.w	r4, #53	; 0x35
    8a0c:	da13      	bge.n	8a36 <scalbn+0xce>
    8a0e:	f24c 3150 	movw	r1, #50000	; 0xc350
    8a12:	428d      	cmp	r5, r1
    8a14:	ec43 2b11 	vmov	d1, r2, r3
    8a18:	dce8      	bgt.n	89ec <scalbn+0x84>
    8a1a:	ed9f 0b0f 	vldr	d0, [pc, #60]	; 8a58 <scalbn+0xf0>
    8a1e:	f000 f829 	bl	8a74 <copysign>
    8a22:	a30d      	add	r3, pc, #52	; (adr r3, 8a58 <scalbn+0xf0>)
    8a24:	e9d3 2300 	ldrd	r2, r3, [r3]
    8a28:	ec51 0b10 	vmov	r0, r1, d0
    8a2c:	f000 f9e8 	bl	8e00 <__aeabi_dmul>
    8a30:	ec41 0b10 	vmov	d0, r0, r1
    8a34:	bd70      	pop	{r4, r5, r6, pc}
    8a36:	f021 41ff 	bic.w	r1, r1, #2139095040	; 0x7f800000
    8a3a:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
    8a3e:	3436      	adds	r4, #54	; 0x36
    8a40:	ea41 5304 	orr.w	r3, r1, r4, lsl #20
    8a44:	4610      	mov	r0, r2
    8a46:	4619      	mov	r1, r3
    8a48:	2200      	movs	r2, #0
    8a4a:	4b09      	ldr	r3, [pc, #36]	; (8a70 <scalbn+0x108>)
    8a4c:	f000 f9d8 	bl	8e00 <__aeabi_dmul>
    8a50:	ec41 0b10 	vmov	d0, r0, r1
    8a54:	bd70      	pop	{r4, r5, r6, pc}
    8a56:	bf00      	nop
    8a58:	c2f8f359 	.word	0xc2f8f359
    8a5c:	01a56e1f 	.word	0x01a56e1f
    8a60:	8800759c 	.word	0x8800759c
    8a64:	7e37e43c 	.word	0x7e37e43c
    8a68:	43500000 	.word	0x43500000
    8a6c:	ffff3cb0 	.word	0xffff3cb0
    8a70:	3c900000 	.word	0x3c900000

00008a74 <copysign>:
    8a74:	ec53 2b10 	vmov	r2, r3, d0
    8a78:	ee11 0a90 	vmov	r0, s3
    8a7c:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
    8a80:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
    8a84:	ea41 0300 	orr.w	r3, r1, r0
    8a88:	ec43 2b10 	vmov	d0, r2, r3
    8a8c:	4770      	bx	lr
    8a8e:	bf00      	nop

00008a90 <__aeabi_drsub>:
    8a90:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
    8a94:	e002      	b.n	8a9c <__adddf3>
    8a96:	bf00      	nop

00008a98 <__aeabi_dsub>:
    8a98:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

00008a9c <__adddf3>:
    8a9c:	b530      	push	{r4, r5, lr}
    8a9e:	ea4f 0441 	mov.w	r4, r1, lsl #1
    8aa2:	ea4f 0543 	mov.w	r5, r3, lsl #1
    8aa6:	ea94 0f05 	teq	r4, r5
    8aaa:	bf08      	it	eq
    8aac:	ea90 0f02 	teqeq	r0, r2
    8ab0:	bf1f      	itttt	ne
    8ab2:	ea54 0c00 	orrsne.w	ip, r4, r0
    8ab6:	ea55 0c02 	orrsne.w	ip, r5, r2
    8aba:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
    8abe:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    8ac2:	f000 80e2 	beq.w	8c8a <__adddf3+0x1ee>
    8ac6:	ea4f 5454 	mov.w	r4, r4, lsr #21
    8aca:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
    8ace:	bfb8      	it	lt
    8ad0:	426d      	neglt	r5, r5
    8ad2:	dd0c      	ble.n	8aee <__adddf3+0x52>
    8ad4:	442c      	add	r4, r5
    8ad6:	ea80 0202 	eor.w	r2, r0, r2
    8ada:	ea81 0303 	eor.w	r3, r1, r3
    8ade:	ea82 0000 	eor.w	r0, r2, r0
    8ae2:	ea83 0101 	eor.w	r1, r3, r1
    8ae6:	ea80 0202 	eor.w	r2, r0, r2
    8aea:	ea81 0303 	eor.w	r3, r1, r3
    8aee:	2d36      	cmp	r5, #54	; 0x36
    8af0:	bf88      	it	hi
    8af2:	bd30      	pophi	{r4, r5, pc}
    8af4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    8af8:	ea4f 3101 	mov.w	r1, r1, lsl #12
    8afc:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
    8b00:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
    8b04:	d002      	beq.n	8b0c <__adddf3+0x70>
    8b06:	4240      	negs	r0, r0
    8b08:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    8b0c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
    8b10:	ea4f 3303 	mov.w	r3, r3, lsl #12
    8b14:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
    8b18:	d002      	beq.n	8b20 <__adddf3+0x84>
    8b1a:	4252      	negs	r2, r2
    8b1c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    8b20:	ea94 0f05 	teq	r4, r5
    8b24:	f000 80a7 	beq.w	8c76 <__adddf3+0x1da>
    8b28:	f1a4 0401 	sub.w	r4, r4, #1
    8b2c:	f1d5 0e20 	rsbs	lr, r5, #32
    8b30:	db0d      	blt.n	8b4e <__adddf3+0xb2>
    8b32:	fa02 fc0e 	lsl.w	ip, r2, lr
    8b36:	fa22 f205 	lsr.w	r2, r2, r5
    8b3a:	1880      	adds	r0, r0, r2
    8b3c:	f141 0100 	adc.w	r1, r1, #0
    8b40:	fa03 f20e 	lsl.w	r2, r3, lr
    8b44:	1880      	adds	r0, r0, r2
    8b46:	fa43 f305 	asr.w	r3, r3, r5
    8b4a:	4159      	adcs	r1, r3
    8b4c:	e00e      	b.n	8b6c <__adddf3+0xd0>
    8b4e:	f1a5 0520 	sub.w	r5, r5, #32
    8b52:	f10e 0e20 	add.w	lr, lr, #32
    8b56:	2a01      	cmp	r2, #1
    8b58:	fa03 fc0e 	lsl.w	ip, r3, lr
    8b5c:	bf28      	it	cs
    8b5e:	f04c 0c02 	orrcs.w	ip, ip, #2
    8b62:	fa43 f305 	asr.w	r3, r3, r5
    8b66:	18c0      	adds	r0, r0, r3
    8b68:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
    8b6c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    8b70:	d507      	bpl.n	8b82 <__adddf3+0xe6>
    8b72:	f04f 0e00 	mov.w	lr, #0
    8b76:	f1dc 0c00 	rsbs	ip, ip, #0
    8b7a:	eb7e 0000 	sbcs.w	r0, lr, r0
    8b7e:	eb6e 0101 	sbc.w	r1, lr, r1
    8b82:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    8b86:	d31b      	bcc.n	8bc0 <__adddf3+0x124>
    8b88:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    8b8c:	d30c      	bcc.n	8ba8 <__adddf3+0x10c>
    8b8e:	0849      	lsrs	r1, r1, #1
    8b90:	ea5f 0030 	movs.w	r0, r0, rrx
    8b94:	ea4f 0c3c 	mov.w	ip, ip, rrx
    8b98:	f104 0401 	add.w	r4, r4, #1
    8b9c:	ea4f 5244 	mov.w	r2, r4, lsl #21
    8ba0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
    8ba4:	f080 809a 	bcs.w	8cdc <__adddf3+0x240>
    8ba8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    8bac:	bf08      	it	eq
    8bae:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    8bb2:	f150 0000 	adcs.w	r0, r0, #0
    8bb6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    8bba:	ea41 0105 	orr.w	r1, r1, r5
    8bbe:	bd30      	pop	{r4, r5, pc}
    8bc0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
    8bc4:	4140      	adcs	r0, r0
    8bc6:	eb41 0101 	adc.w	r1, r1, r1
    8bca:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    8bce:	f1a4 0401 	sub.w	r4, r4, #1
    8bd2:	d1e9      	bne.n	8ba8 <__adddf3+0x10c>
    8bd4:	f091 0f00 	teq	r1, #0
    8bd8:	bf04      	itt	eq
    8bda:	4601      	moveq	r1, r0
    8bdc:	2000      	moveq	r0, #0
    8bde:	fab1 f381 	clz	r3, r1
    8be2:	bf08      	it	eq
    8be4:	3320      	addeq	r3, #32
    8be6:	f1a3 030b 	sub.w	r3, r3, #11
    8bea:	f1b3 0220 	subs.w	r2, r3, #32
    8bee:	da0c      	bge.n	8c0a <__adddf3+0x16e>
    8bf0:	320c      	adds	r2, #12
    8bf2:	dd08      	ble.n	8c06 <__adddf3+0x16a>
    8bf4:	f102 0c14 	add.w	ip, r2, #20
    8bf8:	f1c2 020c 	rsb	r2, r2, #12
    8bfc:	fa01 f00c 	lsl.w	r0, r1, ip
    8c00:	fa21 f102 	lsr.w	r1, r1, r2
    8c04:	e00c      	b.n	8c20 <__adddf3+0x184>
    8c06:	f102 0214 	add.w	r2, r2, #20
    8c0a:	bfd8      	it	le
    8c0c:	f1c2 0c20 	rsble	ip, r2, #32
    8c10:	fa01 f102 	lsl.w	r1, r1, r2
    8c14:	fa20 fc0c 	lsr.w	ip, r0, ip
    8c18:	bfdc      	itt	le
    8c1a:	ea41 010c 	orrle.w	r1, r1, ip
    8c1e:	4090      	lslle	r0, r2
    8c20:	1ae4      	subs	r4, r4, r3
    8c22:	bfa2      	ittt	ge
    8c24:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
    8c28:	4329      	orrge	r1, r5
    8c2a:	bd30      	popge	{r4, r5, pc}
    8c2c:	ea6f 0404 	mvn.w	r4, r4
    8c30:	3c1f      	subs	r4, #31
    8c32:	da1c      	bge.n	8c6e <__adddf3+0x1d2>
    8c34:	340c      	adds	r4, #12
    8c36:	dc0e      	bgt.n	8c56 <__adddf3+0x1ba>
    8c38:	f104 0414 	add.w	r4, r4, #20
    8c3c:	f1c4 0220 	rsb	r2, r4, #32
    8c40:	fa20 f004 	lsr.w	r0, r0, r4
    8c44:	fa01 f302 	lsl.w	r3, r1, r2
    8c48:	ea40 0003 	orr.w	r0, r0, r3
    8c4c:	fa21 f304 	lsr.w	r3, r1, r4
    8c50:	ea45 0103 	orr.w	r1, r5, r3
    8c54:	bd30      	pop	{r4, r5, pc}
    8c56:	f1c4 040c 	rsb	r4, r4, #12
    8c5a:	f1c4 0220 	rsb	r2, r4, #32
    8c5e:	fa20 f002 	lsr.w	r0, r0, r2
    8c62:	fa01 f304 	lsl.w	r3, r1, r4
    8c66:	ea40 0003 	orr.w	r0, r0, r3
    8c6a:	4629      	mov	r1, r5
    8c6c:	bd30      	pop	{r4, r5, pc}
    8c6e:	fa21 f004 	lsr.w	r0, r1, r4
    8c72:	4629      	mov	r1, r5
    8c74:	bd30      	pop	{r4, r5, pc}
    8c76:	f094 0f00 	teq	r4, #0
    8c7a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
    8c7e:	bf06      	itte	eq
    8c80:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
    8c84:	3401      	addeq	r4, #1
    8c86:	3d01      	subne	r5, #1
    8c88:	e74e      	b.n	8b28 <__adddf3+0x8c>
    8c8a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    8c8e:	bf18      	it	ne
    8c90:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    8c94:	d029      	beq.n	8cea <__adddf3+0x24e>
    8c96:	ea94 0f05 	teq	r4, r5
    8c9a:	bf08      	it	eq
    8c9c:	ea90 0f02 	teqeq	r0, r2
    8ca0:	d005      	beq.n	8cae <__adddf3+0x212>
    8ca2:	ea54 0c00 	orrs.w	ip, r4, r0
    8ca6:	bf04      	itt	eq
    8ca8:	4619      	moveq	r1, r3
    8caa:	4610      	moveq	r0, r2
    8cac:	bd30      	pop	{r4, r5, pc}
    8cae:	ea91 0f03 	teq	r1, r3
    8cb2:	bf1e      	ittt	ne
    8cb4:	2100      	movne	r1, #0
    8cb6:	2000      	movne	r0, #0
    8cb8:	bd30      	popne	{r4, r5, pc}
    8cba:	ea5f 5c54 	movs.w	ip, r4, lsr #21
    8cbe:	d105      	bne.n	8ccc <__adddf3+0x230>
    8cc0:	0040      	lsls	r0, r0, #1
    8cc2:	4149      	adcs	r1, r1
    8cc4:	bf28      	it	cs
    8cc6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
    8cca:	bd30      	pop	{r4, r5, pc}
    8ccc:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
    8cd0:	bf3c      	itt	cc
    8cd2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
    8cd6:	bd30      	popcc	{r4, r5, pc}
    8cd8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    8cdc:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
    8ce0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    8ce4:	f04f 0000 	mov.w	r0, #0
    8ce8:	bd30      	pop	{r4, r5, pc}
    8cea:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    8cee:	bf1a      	itte	ne
    8cf0:	4619      	movne	r1, r3
    8cf2:	4610      	movne	r0, r2
    8cf4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
    8cf8:	bf1c      	itt	ne
    8cfa:	460b      	movne	r3, r1
    8cfc:	4602      	movne	r2, r0
    8cfe:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    8d02:	bf06      	itte	eq
    8d04:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
    8d08:	ea91 0f03 	teqeq	r1, r3
    8d0c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
    8d10:	bd30      	pop	{r4, r5, pc}
    8d12:	bf00      	nop

00008d14 <__aeabi_ui2d>:
    8d14:	f090 0f00 	teq	r0, #0
    8d18:	bf04      	itt	eq
    8d1a:	2100      	moveq	r1, #0
    8d1c:	4770      	bxeq	lr
    8d1e:	b530      	push	{r4, r5, lr}
    8d20:	f44f 6480 	mov.w	r4, #1024	; 0x400
    8d24:	f104 0432 	add.w	r4, r4, #50	; 0x32
    8d28:	f04f 0500 	mov.w	r5, #0
    8d2c:	f04f 0100 	mov.w	r1, #0
    8d30:	e750      	b.n	8bd4 <__adddf3+0x138>
    8d32:	bf00      	nop

00008d34 <__aeabi_i2d>:
    8d34:	f090 0f00 	teq	r0, #0
    8d38:	bf04      	itt	eq
    8d3a:	2100      	moveq	r1, #0
    8d3c:	4770      	bxeq	lr
    8d3e:	b530      	push	{r4, r5, lr}
    8d40:	f44f 6480 	mov.w	r4, #1024	; 0x400
    8d44:	f104 0432 	add.w	r4, r4, #50	; 0x32
    8d48:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
    8d4c:	bf48      	it	mi
    8d4e:	4240      	negmi	r0, r0
    8d50:	f04f 0100 	mov.w	r1, #0
    8d54:	e73e      	b.n	8bd4 <__adddf3+0x138>
    8d56:	bf00      	nop

00008d58 <__aeabi_f2d>:
    8d58:	0042      	lsls	r2, r0, #1
    8d5a:	ea4f 01e2 	mov.w	r1, r2, asr #3
    8d5e:	ea4f 0131 	mov.w	r1, r1, rrx
    8d62:	ea4f 7002 	mov.w	r0, r2, lsl #28
    8d66:	bf1f      	itttt	ne
    8d68:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
    8d6c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    8d70:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
    8d74:	4770      	bxne	lr
    8d76:	f092 0f00 	teq	r2, #0
    8d7a:	bf14      	ite	ne
    8d7c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    8d80:	4770      	bxeq	lr
    8d82:	b530      	push	{r4, r5, lr}
    8d84:	f44f 7460 	mov.w	r4, #896	; 0x380
    8d88:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    8d8c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    8d90:	e720      	b.n	8bd4 <__adddf3+0x138>
    8d92:	bf00      	nop

00008d94 <__aeabi_ul2d>:
    8d94:	ea50 0201 	orrs.w	r2, r0, r1
    8d98:	bf08      	it	eq
    8d9a:	4770      	bxeq	lr
    8d9c:	b530      	push	{r4, r5, lr}
    8d9e:	f04f 0500 	mov.w	r5, #0
    8da2:	e00a      	b.n	8dba <__aeabi_l2d+0x16>

00008da4 <__aeabi_l2d>:
    8da4:	ea50 0201 	orrs.w	r2, r0, r1
    8da8:	bf08      	it	eq
    8daa:	4770      	bxeq	lr
    8dac:	b530      	push	{r4, r5, lr}
    8dae:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
    8db2:	d502      	bpl.n	8dba <__aeabi_l2d+0x16>
    8db4:	4240      	negs	r0, r0
    8db6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    8dba:	f44f 6480 	mov.w	r4, #1024	; 0x400
    8dbe:	f104 0432 	add.w	r4, r4, #50	; 0x32
    8dc2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
    8dc6:	f43f aedc 	beq.w	8b82 <__adddf3+0xe6>
    8dca:	f04f 0203 	mov.w	r2, #3
    8dce:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    8dd2:	bf18      	it	ne
    8dd4:	3203      	addne	r2, #3
    8dd6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    8dda:	bf18      	it	ne
    8ddc:	3203      	addne	r2, #3
    8dde:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
    8de2:	f1c2 0320 	rsb	r3, r2, #32
    8de6:	fa00 fc03 	lsl.w	ip, r0, r3
    8dea:	fa20 f002 	lsr.w	r0, r0, r2
    8dee:	fa01 fe03 	lsl.w	lr, r1, r3
    8df2:	ea40 000e 	orr.w	r0, r0, lr
    8df6:	fa21 f102 	lsr.w	r1, r1, r2
    8dfa:	4414      	add	r4, r2
    8dfc:	e6c1      	b.n	8b82 <__adddf3+0xe6>
    8dfe:	bf00      	nop

00008e00 <__aeabi_dmul>:
    8e00:	b570      	push	{r4, r5, r6, lr}
    8e02:	f04f 0cff 	mov.w	ip, #255	; 0xff
    8e06:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    8e0a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    8e0e:	bf1d      	ittte	ne
    8e10:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    8e14:	ea94 0f0c 	teqne	r4, ip
    8e18:	ea95 0f0c 	teqne	r5, ip
    8e1c:	f000 f8de 	bleq	8fdc <__aeabi_dmul+0x1dc>
    8e20:	442c      	add	r4, r5
    8e22:	ea81 0603 	eor.w	r6, r1, r3
    8e26:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
    8e2a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
    8e2e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
    8e32:	bf18      	it	ne
    8e34:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
    8e38:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    8e3c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    8e40:	d038      	beq.n	8eb4 <__aeabi_dmul+0xb4>
    8e42:	fba0 ce02 	umull	ip, lr, r0, r2
    8e46:	f04f 0500 	mov.w	r5, #0
    8e4a:	fbe1 e502 	umlal	lr, r5, r1, r2
    8e4e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
    8e52:	fbe0 e503 	umlal	lr, r5, r0, r3
    8e56:	f04f 0600 	mov.w	r6, #0
    8e5a:	fbe1 5603 	umlal	r5, r6, r1, r3
    8e5e:	f09c 0f00 	teq	ip, #0
    8e62:	bf18      	it	ne
    8e64:	f04e 0e01 	orrne.w	lr, lr, #1
    8e68:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
    8e6c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
    8e70:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
    8e74:	d204      	bcs.n	8e80 <__aeabi_dmul+0x80>
    8e76:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
    8e7a:	416d      	adcs	r5, r5
    8e7c:	eb46 0606 	adc.w	r6, r6, r6
    8e80:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
    8e84:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
    8e88:	ea4f 20c5 	mov.w	r0, r5, lsl #11
    8e8c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
    8e90:	ea4f 2ece 	mov.w	lr, lr, lsl #11
    8e94:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    8e98:	bf88      	it	hi
    8e9a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    8e9e:	d81e      	bhi.n	8ede <__aeabi_dmul+0xde>
    8ea0:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
    8ea4:	bf08      	it	eq
    8ea6:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
    8eaa:	f150 0000 	adcs.w	r0, r0, #0
    8eae:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    8eb2:	bd70      	pop	{r4, r5, r6, pc}
    8eb4:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
    8eb8:	ea46 0101 	orr.w	r1, r6, r1
    8ebc:	ea40 0002 	orr.w	r0, r0, r2
    8ec0:	ea81 0103 	eor.w	r1, r1, r3
    8ec4:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
    8ec8:	bfc2      	ittt	gt
    8eca:	ebd4 050c 	rsbsgt	r5, r4, ip
    8ece:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    8ed2:	bd70      	popgt	{r4, r5, r6, pc}
    8ed4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    8ed8:	f04f 0e00 	mov.w	lr, #0
    8edc:	3c01      	subs	r4, #1
    8ede:	f300 80ab 	bgt.w	9038 <__aeabi_dmul+0x238>
    8ee2:	f114 0f36 	cmn.w	r4, #54	; 0x36
    8ee6:	bfde      	ittt	le
    8ee8:	2000      	movle	r0, #0
    8eea:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
    8eee:	bd70      	pople	{r4, r5, r6, pc}
    8ef0:	f1c4 0400 	rsb	r4, r4, #0
    8ef4:	3c20      	subs	r4, #32
    8ef6:	da35      	bge.n	8f64 <__aeabi_dmul+0x164>
    8ef8:	340c      	adds	r4, #12
    8efa:	dc1b      	bgt.n	8f34 <__aeabi_dmul+0x134>
    8efc:	f104 0414 	add.w	r4, r4, #20
    8f00:	f1c4 0520 	rsb	r5, r4, #32
    8f04:	fa00 f305 	lsl.w	r3, r0, r5
    8f08:	fa20 f004 	lsr.w	r0, r0, r4
    8f0c:	fa01 f205 	lsl.w	r2, r1, r5
    8f10:	ea40 0002 	orr.w	r0, r0, r2
    8f14:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
    8f18:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    8f1c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    8f20:	fa21 f604 	lsr.w	r6, r1, r4
    8f24:	eb42 0106 	adc.w	r1, r2, r6
    8f28:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    8f2c:	bf08      	it	eq
    8f2e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    8f32:	bd70      	pop	{r4, r5, r6, pc}
    8f34:	f1c4 040c 	rsb	r4, r4, #12
    8f38:	f1c4 0520 	rsb	r5, r4, #32
    8f3c:	fa00 f304 	lsl.w	r3, r0, r4
    8f40:	fa20 f005 	lsr.w	r0, r0, r5
    8f44:	fa01 f204 	lsl.w	r2, r1, r4
    8f48:	ea40 0002 	orr.w	r0, r0, r2
    8f4c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    8f50:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    8f54:	f141 0100 	adc.w	r1, r1, #0
    8f58:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    8f5c:	bf08      	it	eq
    8f5e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    8f62:	bd70      	pop	{r4, r5, r6, pc}
    8f64:	f1c4 0520 	rsb	r5, r4, #32
    8f68:	fa00 f205 	lsl.w	r2, r0, r5
    8f6c:	ea4e 0e02 	orr.w	lr, lr, r2
    8f70:	fa20 f304 	lsr.w	r3, r0, r4
    8f74:	fa01 f205 	lsl.w	r2, r1, r5
    8f78:	ea43 0302 	orr.w	r3, r3, r2
    8f7c:	fa21 f004 	lsr.w	r0, r1, r4
    8f80:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    8f84:	fa21 f204 	lsr.w	r2, r1, r4
    8f88:	ea20 0002 	bic.w	r0, r0, r2
    8f8c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
    8f90:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    8f94:	bf08      	it	eq
    8f96:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    8f9a:	bd70      	pop	{r4, r5, r6, pc}
    8f9c:	f094 0f00 	teq	r4, #0
    8fa0:	d10f      	bne.n	8fc2 <__aeabi_dmul+0x1c2>
    8fa2:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
    8fa6:	0040      	lsls	r0, r0, #1
    8fa8:	eb41 0101 	adc.w	r1, r1, r1
    8fac:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    8fb0:	bf08      	it	eq
    8fb2:	3c01      	subeq	r4, #1
    8fb4:	d0f7      	beq.n	8fa6 <__aeabi_dmul+0x1a6>
    8fb6:	ea41 0106 	orr.w	r1, r1, r6
    8fba:	f095 0f00 	teq	r5, #0
    8fbe:	bf18      	it	ne
    8fc0:	4770      	bxne	lr
    8fc2:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
    8fc6:	0052      	lsls	r2, r2, #1
    8fc8:	eb43 0303 	adc.w	r3, r3, r3
    8fcc:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    8fd0:	bf08      	it	eq
    8fd2:	3d01      	subeq	r5, #1
    8fd4:	d0f7      	beq.n	8fc6 <__aeabi_dmul+0x1c6>
    8fd6:	ea43 0306 	orr.w	r3, r3, r6
    8fda:	4770      	bx	lr
    8fdc:	ea94 0f0c 	teq	r4, ip
    8fe0:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    8fe4:	bf18      	it	ne
    8fe6:	ea95 0f0c 	teqne	r5, ip
    8fea:	d00c      	beq.n	9006 <__aeabi_dmul+0x206>
    8fec:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    8ff0:	bf18      	it	ne
    8ff2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    8ff6:	d1d1      	bne.n	8f9c <__aeabi_dmul+0x19c>
    8ff8:	ea81 0103 	eor.w	r1, r1, r3
    8ffc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    9000:	f04f 0000 	mov.w	r0, #0
    9004:	bd70      	pop	{r4, r5, r6, pc}
    9006:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    900a:	bf06      	itte	eq
    900c:	4610      	moveq	r0, r2
    900e:	4619      	moveq	r1, r3
    9010:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    9014:	d019      	beq.n	904a <__aeabi_dmul+0x24a>
    9016:	ea94 0f0c 	teq	r4, ip
    901a:	d102      	bne.n	9022 <__aeabi_dmul+0x222>
    901c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
    9020:	d113      	bne.n	904a <__aeabi_dmul+0x24a>
    9022:	ea95 0f0c 	teq	r5, ip
    9026:	d105      	bne.n	9034 <__aeabi_dmul+0x234>
    9028:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
    902c:	bf1c      	itt	ne
    902e:	4610      	movne	r0, r2
    9030:	4619      	movne	r1, r3
    9032:	d10a      	bne.n	904a <__aeabi_dmul+0x24a>
    9034:	ea81 0103 	eor.w	r1, r1, r3
    9038:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    903c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    9040:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    9044:	f04f 0000 	mov.w	r0, #0
    9048:	bd70      	pop	{r4, r5, r6, pc}
    904a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    904e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
    9052:	bd70      	pop	{r4, r5, r6, pc}

00009054 <__aeabi_ddiv>:
    9054:	b570      	push	{r4, r5, r6, lr}
    9056:	f04f 0cff 	mov.w	ip, #255	; 0xff
    905a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    905e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    9062:	bf1d      	ittte	ne
    9064:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    9068:	ea94 0f0c 	teqne	r4, ip
    906c:	ea95 0f0c 	teqne	r5, ip
    9070:	f000 f8a7 	bleq	91c2 <__aeabi_ddiv+0x16e>
    9074:	eba4 0405 	sub.w	r4, r4, r5
    9078:	ea81 0e03 	eor.w	lr, r1, r3
    907c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    9080:	ea4f 3101 	mov.w	r1, r1, lsl #12
    9084:	f000 8088 	beq.w	9198 <__aeabi_ddiv+0x144>
    9088:	ea4f 3303 	mov.w	r3, r3, lsl #12
    908c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
    9090:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
    9094:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    9098:	ea4f 2202 	mov.w	r2, r2, lsl #8
    909c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
    90a0:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
    90a4:	ea4f 2600 	mov.w	r6, r0, lsl #8
    90a8:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
    90ac:	429d      	cmp	r5, r3
    90ae:	bf08      	it	eq
    90b0:	4296      	cmpeq	r6, r2
    90b2:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
    90b6:	f504 7440 	add.w	r4, r4, #768	; 0x300
    90ba:	d202      	bcs.n	90c2 <__aeabi_ddiv+0x6e>
    90bc:	085b      	lsrs	r3, r3, #1
    90be:	ea4f 0232 	mov.w	r2, r2, rrx
    90c2:	1ab6      	subs	r6, r6, r2
    90c4:	eb65 0503 	sbc.w	r5, r5, r3
    90c8:	085b      	lsrs	r3, r3, #1
    90ca:	ea4f 0232 	mov.w	r2, r2, rrx
    90ce:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
    90d2:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
    90d6:	ebb6 0e02 	subs.w	lr, r6, r2
    90da:	eb75 0e03 	sbcs.w	lr, r5, r3
    90de:	bf22      	ittt	cs
    90e0:	1ab6      	subcs	r6, r6, r2
    90e2:	4675      	movcs	r5, lr
    90e4:	ea40 000c 	orrcs.w	r0, r0, ip
    90e8:	085b      	lsrs	r3, r3, #1
    90ea:	ea4f 0232 	mov.w	r2, r2, rrx
    90ee:	ebb6 0e02 	subs.w	lr, r6, r2
    90f2:	eb75 0e03 	sbcs.w	lr, r5, r3
    90f6:	bf22      	ittt	cs
    90f8:	1ab6      	subcs	r6, r6, r2
    90fa:	4675      	movcs	r5, lr
    90fc:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    9100:	085b      	lsrs	r3, r3, #1
    9102:	ea4f 0232 	mov.w	r2, r2, rrx
    9106:	ebb6 0e02 	subs.w	lr, r6, r2
    910a:	eb75 0e03 	sbcs.w	lr, r5, r3
    910e:	bf22      	ittt	cs
    9110:	1ab6      	subcs	r6, r6, r2
    9112:	4675      	movcs	r5, lr
    9114:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    9118:	085b      	lsrs	r3, r3, #1
    911a:	ea4f 0232 	mov.w	r2, r2, rrx
    911e:	ebb6 0e02 	subs.w	lr, r6, r2
    9122:	eb75 0e03 	sbcs.w	lr, r5, r3
    9126:	bf22      	ittt	cs
    9128:	1ab6      	subcs	r6, r6, r2
    912a:	4675      	movcs	r5, lr
    912c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    9130:	ea55 0e06 	orrs.w	lr, r5, r6
    9134:	d018      	beq.n	9168 <__aeabi_ddiv+0x114>
    9136:	ea4f 1505 	mov.w	r5, r5, lsl #4
    913a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
    913e:	ea4f 1606 	mov.w	r6, r6, lsl #4
    9142:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    9146:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
    914a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    914e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
    9152:	d1c0      	bne.n	90d6 <__aeabi_ddiv+0x82>
    9154:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    9158:	d10b      	bne.n	9172 <__aeabi_ddiv+0x11e>
    915a:	ea41 0100 	orr.w	r1, r1, r0
    915e:	f04f 0000 	mov.w	r0, #0
    9162:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
    9166:	e7b6      	b.n	90d6 <__aeabi_ddiv+0x82>
    9168:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    916c:	bf04      	itt	eq
    916e:	4301      	orreq	r1, r0
    9170:	2000      	moveq	r0, #0
    9172:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    9176:	bf88      	it	hi
    9178:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    917c:	f63f aeaf 	bhi.w	8ede <__aeabi_dmul+0xde>
    9180:	ebb5 0c03 	subs.w	ip, r5, r3
    9184:	bf04      	itt	eq
    9186:	ebb6 0c02 	subseq.w	ip, r6, r2
    918a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    918e:	f150 0000 	adcs.w	r0, r0, #0
    9192:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    9196:	bd70      	pop	{r4, r5, r6, pc}
    9198:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
    919c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
    91a0:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
    91a4:	bfc2      	ittt	gt
    91a6:	ebd4 050c 	rsbsgt	r5, r4, ip
    91aa:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    91ae:	bd70      	popgt	{r4, r5, r6, pc}
    91b0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    91b4:	f04f 0e00 	mov.w	lr, #0
    91b8:	3c01      	subs	r4, #1
    91ba:	e690      	b.n	8ede <__aeabi_dmul+0xde>
    91bc:	ea45 0e06 	orr.w	lr, r5, r6
    91c0:	e68d      	b.n	8ede <__aeabi_dmul+0xde>
    91c2:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    91c6:	ea94 0f0c 	teq	r4, ip
    91ca:	bf08      	it	eq
    91cc:	ea95 0f0c 	teqeq	r5, ip
    91d0:	f43f af3b 	beq.w	904a <__aeabi_dmul+0x24a>
    91d4:	ea94 0f0c 	teq	r4, ip
    91d8:	d10a      	bne.n	91f0 <__aeabi_ddiv+0x19c>
    91da:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    91de:	f47f af34 	bne.w	904a <__aeabi_dmul+0x24a>
    91e2:	ea95 0f0c 	teq	r5, ip
    91e6:	f47f af25 	bne.w	9034 <__aeabi_dmul+0x234>
    91ea:	4610      	mov	r0, r2
    91ec:	4619      	mov	r1, r3
    91ee:	e72c      	b.n	904a <__aeabi_dmul+0x24a>
    91f0:	ea95 0f0c 	teq	r5, ip
    91f4:	d106      	bne.n	9204 <__aeabi_ddiv+0x1b0>
    91f6:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    91fa:	f43f aefd 	beq.w	8ff8 <__aeabi_dmul+0x1f8>
    91fe:	4610      	mov	r0, r2
    9200:	4619      	mov	r1, r3
    9202:	e722      	b.n	904a <__aeabi_dmul+0x24a>
    9204:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    9208:	bf18      	it	ne
    920a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    920e:	f47f aec5 	bne.w	8f9c <__aeabi_dmul+0x19c>
    9212:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
    9216:	f47f af0d 	bne.w	9034 <__aeabi_dmul+0x234>
    921a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
    921e:	f47f aeeb 	bne.w	8ff8 <__aeabi_dmul+0x1f8>
    9222:	e712      	b.n	904a <__aeabi_dmul+0x24a>

00009224 <__gedf2>:
    9224:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
    9228:	e006      	b.n	9238 <__cmpdf2+0x4>
    922a:	bf00      	nop

0000922c <__ledf2>:
    922c:	f04f 0c01 	mov.w	ip, #1
    9230:	e002      	b.n	9238 <__cmpdf2+0x4>
    9232:	bf00      	nop

00009234 <__cmpdf2>:
    9234:	f04f 0c01 	mov.w	ip, #1
    9238:	f84d cd04 	str.w	ip, [sp, #-4]!
    923c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    9240:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    9244:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    9248:	bf18      	it	ne
    924a:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
    924e:	d01b      	beq.n	9288 <__cmpdf2+0x54>
    9250:	b001      	add	sp, #4
    9252:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
    9256:	bf0c      	ite	eq
    9258:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
    925c:	ea91 0f03 	teqne	r1, r3
    9260:	bf02      	ittt	eq
    9262:	ea90 0f02 	teqeq	r0, r2
    9266:	2000      	moveq	r0, #0
    9268:	4770      	bxeq	lr
    926a:	f110 0f00 	cmn.w	r0, #0
    926e:	ea91 0f03 	teq	r1, r3
    9272:	bf58      	it	pl
    9274:	4299      	cmppl	r1, r3
    9276:	bf08      	it	eq
    9278:	4290      	cmpeq	r0, r2
    927a:	bf2c      	ite	cs
    927c:	17d8      	asrcs	r0, r3, #31
    927e:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
    9282:	f040 0001 	orr.w	r0, r0, #1
    9286:	4770      	bx	lr
    9288:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    928c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    9290:	d102      	bne.n	9298 <__cmpdf2+0x64>
    9292:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    9296:	d107      	bne.n	92a8 <__cmpdf2+0x74>
    9298:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    929c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    92a0:	d1d6      	bne.n	9250 <__cmpdf2+0x1c>
    92a2:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    92a6:	d0d3      	beq.n	9250 <__cmpdf2+0x1c>
    92a8:	f85d 0b04 	ldr.w	r0, [sp], #4
    92ac:	4770      	bx	lr
    92ae:	bf00      	nop

000092b0 <__aeabi_cdrcmple>:
    92b0:	4684      	mov	ip, r0
    92b2:	4610      	mov	r0, r2
    92b4:	4662      	mov	r2, ip
    92b6:	468c      	mov	ip, r1
    92b8:	4619      	mov	r1, r3
    92ba:	4663      	mov	r3, ip
    92bc:	e000      	b.n	92c0 <__aeabi_cdcmpeq>
    92be:	bf00      	nop

000092c0 <__aeabi_cdcmpeq>:
    92c0:	b501      	push	{r0, lr}
    92c2:	f7ff ffb7 	bl	9234 <__cmpdf2>
    92c6:	2800      	cmp	r0, #0
    92c8:	bf48      	it	mi
    92ca:	f110 0f00 	cmnmi.w	r0, #0
    92ce:	bd01      	pop	{r0, pc}

000092d0 <__aeabi_dcmpeq>:
    92d0:	f84d ed08 	str.w	lr, [sp, #-8]!
    92d4:	f7ff fff4 	bl	92c0 <__aeabi_cdcmpeq>
    92d8:	bf0c      	ite	eq
    92da:	2001      	moveq	r0, #1
    92dc:	2000      	movne	r0, #0
    92de:	f85d fb08 	ldr.w	pc, [sp], #8
    92e2:	bf00      	nop

000092e4 <__aeabi_dcmplt>:
    92e4:	f84d ed08 	str.w	lr, [sp, #-8]!
    92e8:	f7ff ffea 	bl	92c0 <__aeabi_cdcmpeq>
    92ec:	bf34      	ite	cc
    92ee:	2001      	movcc	r0, #1
    92f0:	2000      	movcs	r0, #0
    92f2:	f85d fb08 	ldr.w	pc, [sp], #8
    92f6:	bf00      	nop

000092f8 <__aeabi_dcmple>:
    92f8:	f84d ed08 	str.w	lr, [sp, #-8]!
    92fc:	f7ff ffe0 	bl	92c0 <__aeabi_cdcmpeq>
    9300:	bf94      	ite	ls
    9302:	2001      	movls	r0, #1
    9304:	2000      	movhi	r0, #0
    9306:	f85d fb08 	ldr.w	pc, [sp], #8
    930a:	bf00      	nop

0000930c <__aeabi_dcmpge>:
    930c:	f84d ed08 	str.w	lr, [sp, #-8]!
    9310:	f7ff ffce 	bl	92b0 <__aeabi_cdrcmple>
    9314:	bf94      	ite	ls
    9316:	2001      	movls	r0, #1
    9318:	2000      	movhi	r0, #0
    931a:	f85d fb08 	ldr.w	pc, [sp], #8
    931e:	bf00      	nop

00009320 <__aeabi_dcmpgt>:
    9320:	f84d ed08 	str.w	lr, [sp, #-8]!
    9324:	f7ff ffc4 	bl	92b0 <__aeabi_cdrcmple>
    9328:	bf34      	ite	cc
    932a:	2001      	movcc	r0, #1
    932c:	2000      	movcs	r0, #0
    932e:	f85d fb08 	ldr.w	pc, [sp], #8
    9332:	bf00      	nop

00009334 <__aeabi_dcmpun>:
    9334:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    9338:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    933c:	d102      	bne.n	9344 <__aeabi_dcmpun+0x10>
    933e:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    9342:	d10a      	bne.n	935a <__aeabi_dcmpun+0x26>
    9344:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    9348:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    934c:	d102      	bne.n	9354 <__aeabi_dcmpun+0x20>
    934e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    9352:	d102      	bne.n	935a <__aeabi_dcmpun+0x26>
    9354:	f04f 0000 	mov.w	r0, #0
    9358:	4770      	bx	lr
    935a:	f04f 0001 	mov.w	r0, #1
    935e:	4770      	bx	lr

00009360 <__aeabi_d2iz>:
    9360:	ea4f 0241 	mov.w	r2, r1, lsl #1
    9364:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
    9368:	d215      	bcs.n	9396 <__aeabi_d2iz+0x36>
    936a:	d511      	bpl.n	9390 <__aeabi_d2iz+0x30>
    936c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
    9370:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
    9374:	d912      	bls.n	939c <__aeabi_d2iz+0x3c>
    9376:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    937a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    937e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
    9382:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    9386:	fa23 f002 	lsr.w	r0, r3, r2
    938a:	bf18      	it	ne
    938c:	4240      	negne	r0, r0
    938e:	4770      	bx	lr
    9390:	f04f 0000 	mov.w	r0, #0
    9394:	4770      	bx	lr
    9396:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
    939a:	d105      	bne.n	93a8 <__aeabi_d2iz+0x48>
    939c:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
    93a0:	bf08      	it	eq
    93a2:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
    93a6:	4770      	bx	lr
    93a8:	f04f 0000 	mov.w	r0, #0
    93ac:	4770      	bx	lr
    93ae:	bf00      	nop

000093b0 <__aeabi_d2f>:
    93b0:	ea4f 0241 	mov.w	r2, r1, lsl #1
    93b4:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
    93b8:	bf24      	itt	cs
    93ba:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
    93be:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
    93c2:	d90d      	bls.n	93e0 <__aeabi_d2f+0x30>
    93c4:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    93c8:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    93cc:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
    93d0:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    93d4:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
    93d8:	bf08      	it	eq
    93da:	f020 0001 	biceq.w	r0, r0, #1
    93de:	4770      	bx	lr
    93e0:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
    93e4:	d121      	bne.n	942a <__aeabi_d2f+0x7a>
    93e6:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
    93ea:	bfbc      	itt	lt
    93ec:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
    93f0:	4770      	bxlt	lr
    93f2:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    93f6:	ea4f 5252 	mov.w	r2, r2, lsr #21
    93fa:	f1c2 0218 	rsb	r2, r2, #24
    93fe:	f1c2 0c20 	rsb	ip, r2, #32
    9402:	fa10 f30c 	lsls.w	r3, r0, ip
    9406:	fa20 f002 	lsr.w	r0, r0, r2
    940a:	bf18      	it	ne
    940c:	f040 0001 	orrne.w	r0, r0, #1
    9410:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    9414:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    9418:	fa03 fc0c 	lsl.w	ip, r3, ip
    941c:	ea40 000c 	orr.w	r0, r0, ip
    9420:	fa23 f302 	lsr.w	r3, r3, r2
    9424:	ea4f 0343 	mov.w	r3, r3, lsl #1
    9428:	e7cc      	b.n	93c4 <__aeabi_d2f+0x14>
    942a:	ea7f 5362 	mvns.w	r3, r2, asr #21
    942e:	d107      	bne.n	9440 <__aeabi_d2f+0x90>
    9430:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
    9434:	bf1e      	ittt	ne
    9436:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
    943a:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
    943e:	4770      	bxne	lr
    9440:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
    9444:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    9448:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    944c:	4770      	bx	lr
    944e:	bf00      	nop

00009450 <__errno>:
    9450:	4b01      	ldr	r3, [pc, #4]	; (9458 <__errno+0x8>)
    9452:	6818      	ldr	r0, [r3, #0]
    9454:	4770      	bx	lr
    9456:	bf00      	nop
    9458:	1fff1010 	.word	0x1fff1010

0000945c <__libc_init_array>:
    945c:	b570      	push	{r4, r5, r6, lr}
    945e:	4e0f      	ldr	r6, [pc, #60]	; (949c <__libc_init_array+0x40>)
    9460:	4d0f      	ldr	r5, [pc, #60]	; (94a0 <__libc_init_array+0x44>)
    9462:	1b76      	subs	r6, r6, r5
    9464:	10b6      	asrs	r6, r6, #2
    9466:	bf18      	it	ne
    9468:	2400      	movne	r4, #0
    946a:	d005      	beq.n	9478 <__libc_init_array+0x1c>
    946c:	3401      	adds	r4, #1
    946e:	f855 3b04 	ldr.w	r3, [r5], #4
    9472:	4798      	blx	r3
    9474:	42a6      	cmp	r6, r4
    9476:	d1f9      	bne.n	946c <__libc_init_array+0x10>
    9478:	4e0a      	ldr	r6, [pc, #40]	; (94a4 <__libc_init_array+0x48>)
    947a:	4d0b      	ldr	r5, [pc, #44]	; (94a8 <__libc_init_array+0x4c>)
    947c:	1b76      	subs	r6, r6, r5
    947e:	f001 fd69 	bl	af54 <_init>
    9482:	10b6      	asrs	r6, r6, #2
    9484:	bf18      	it	ne
    9486:	2400      	movne	r4, #0
    9488:	d006      	beq.n	9498 <__libc_init_array+0x3c>
    948a:	3401      	adds	r4, #1
    948c:	f855 3b04 	ldr.w	r3, [r5], #4
    9490:	4798      	blx	r3
    9492:	42a6      	cmp	r6, r4
    9494:	d1f9      	bne.n	948a <__libc_init_array+0x2e>
    9496:	bd70      	pop	{r4, r5, r6, pc}
    9498:	bd70      	pop	{r4, r5, r6, pc}
    949a:	bf00      	nop
    949c:	0000af60 	.word	0x0000af60
    94a0:	0000af60 	.word	0x0000af60
    94a4:	0000af6c 	.word	0x0000af6c
    94a8:	0000af60 	.word	0x0000af60

000094ac <malloc>:
    94ac:	4b02      	ldr	r3, [pc, #8]	; (94b8 <malloc+0xc>)
    94ae:	4601      	mov	r1, r0
    94b0:	6818      	ldr	r0, [r3, #0]
    94b2:	f000 b80b 	b.w	94cc <_malloc_r>
    94b6:	bf00      	nop
    94b8:	1fff1010 	.word	0x1fff1010

000094bc <free>:
    94bc:	4b02      	ldr	r3, [pc, #8]	; (94c8 <free+0xc>)
    94be:	4601      	mov	r1, r0
    94c0:	6818      	ldr	r0, [r3, #0]
    94c2:	f001 b83d 	b.w	a540 <_free_r>
    94c6:	bf00      	nop
    94c8:	1fff1010 	.word	0x1fff1010

000094cc <_malloc_r>:
    94cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    94d0:	f101 050b 	add.w	r5, r1, #11
    94d4:	2d16      	cmp	r5, #22
    94d6:	b083      	sub	sp, #12
    94d8:	4606      	mov	r6, r0
    94da:	f240 809f 	bls.w	961c <_malloc_r+0x150>
    94de:	f035 0507 	bics.w	r5, r5, #7
    94e2:	f100 80bf 	bmi.w	9664 <_malloc_r+0x198>
    94e6:	42a9      	cmp	r1, r5
    94e8:	f200 80bc 	bhi.w	9664 <_malloc_r+0x198>
    94ec:	f000 fb58 	bl	9ba0 <__malloc_lock>
    94f0:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
    94f4:	f0c0 829c 	bcc.w	9a30 <_malloc_r+0x564>
    94f8:	0a6b      	lsrs	r3, r5, #9
    94fa:	f000 80ba 	beq.w	9672 <_malloc_r+0x1a6>
    94fe:	2b04      	cmp	r3, #4
    9500:	f200 8183 	bhi.w	980a <_malloc_r+0x33e>
    9504:	09a8      	lsrs	r0, r5, #6
    9506:	f100 0e39 	add.w	lr, r0, #57	; 0x39
    950a:	ea4f 034e 	mov.w	r3, lr, lsl #1
    950e:	3038      	adds	r0, #56	; 0x38
    9510:	4fc4      	ldr	r7, [pc, #784]	; (9824 <_malloc_r+0x358>)
    9512:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    9516:	f1a3 0108 	sub.w	r1, r3, #8
    951a:	685c      	ldr	r4, [r3, #4]
    951c:	42a1      	cmp	r1, r4
    951e:	d107      	bne.n	9530 <_malloc_r+0x64>
    9520:	e0ac      	b.n	967c <_malloc_r+0x1b0>
    9522:	2a00      	cmp	r2, #0
    9524:	f280 80ac 	bge.w	9680 <_malloc_r+0x1b4>
    9528:	68e4      	ldr	r4, [r4, #12]
    952a:	42a1      	cmp	r1, r4
    952c:	f000 80a6 	beq.w	967c <_malloc_r+0x1b0>
    9530:	6863      	ldr	r3, [r4, #4]
    9532:	f023 0303 	bic.w	r3, r3, #3
    9536:	1b5a      	subs	r2, r3, r5
    9538:	2a0f      	cmp	r2, #15
    953a:	ddf2      	ble.n	9522 <_malloc_r+0x56>
    953c:	49b9      	ldr	r1, [pc, #740]	; (9824 <_malloc_r+0x358>)
    953e:	693c      	ldr	r4, [r7, #16]
    9540:	f101 0e08 	add.w	lr, r1, #8
    9544:	4574      	cmp	r4, lr
    9546:	f000 81b3 	beq.w	98b0 <_malloc_r+0x3e4>
    954a:	6863      	ldr	r3, [r4, #4]
    954c:	f023 0303 	bic.w	r3, r3, #3
    9550:	1b5a      	subs	r2, r3, r5
    9552:	2a0f      	cmp	r2, #15
    9554:	f300 8199 	bgt.w	988a <_malloc_r+0x3be>
    9558:	2a00      	cmp	r2, #0
    955a:	f8c1 e014 	str.w	lr, [r1, #20]
    955e:	f8c1 e010 	str.w	lr, [r1, #16]
    9562:	f280 809e 	bge.w	96a2 <_malloc_r+0x1d6>
    9566:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    956a:	f080 8167 	bcs.w	983c <_malloc_r+0x370>
    956e:	08db      	lsrs	r3, r3, #3
    9570:	f103 0c01 	add.w	ip, r3, #1
    9574:	2201      	movs	r2, #1
    9576:	109b      	asrs	r3, r3, #2
    9578:	fa02 f303 	lsl.w	r3, r2, r3
    957c:	684a      	ldr	r2, [r1, #4]
    957e:	f851 803c 	ldr.w	r8, [r1, ip, lsl #3]
    9582:	f8c4 8008 	str.w	r8, [r4, #8]
    9586:	eb01 09cc 	add.w	r9, r1, ip, lsl #3
    958a:	431a      	orrs	r2, r3
    958c:	f1a9 0308 	sub.w	r3, r9, #8
    9590:	60e3      	str	r3, [r4, #12]
    9592:	604a      	str	r2, [r1, #4]
    9594:	f841 403c 	str.w	r4, [r1, ip, lsl #3]
    9598:	f8c8 400c 	str.w	r4, [r8, #12]
    959c:	1083      	asrs	r3, r0, #2
    959e:	2401      	movs	r4, #1
    95a0:	409c      	lsls	r4, r3
    95a2:	4294      	cmp	r4, r2
    95a4:	f200 808a 	bhi.w	96bc <_malloc_r+0x1f0>
    95a8:	4214      	tst	r4, r2
    95aa:	d106      	bne.n	95ba <_malloc_r+0xee>
    95ac:	f020 0003 	bic.w	r0, r0, #3
    95b0:	0064      	lsls	r4, r4, #1
    95b2:	4214      	tst	r4, r2
    95b4:	f100 0004 	add.w	r0, r0, #4
    95b8:	d0fa      	beq.n	95b0 <_malloc_r+0xe4>
    95ba:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
    95be:	46cc      	mov	ip, r9
    95c0:	4680      	mov	r8, r0
    95c2:	f8dc 100c 	ldr.w	r1, [ip, #12]
    95c6:	458c      	cmp	ip, r1
    95c8:	d107      	bne.n	95da <_malloc_r+0x10e>
    95ca:	e173      	b.n	98b4 <_malloc_r+0x3e8>
    95cc:	2a00      	cmp	r2, #0
    95ce:	f280 8181 	bge.w	98d4 <_malloc_r+0x408>
    95d2:	68c9      	ldr	r1, [r1, #12]
    95d4:	458c      	cmp	ip, r1
    95d6:	f000 816d 	beq.w	98b4 <_malloc_r+0x3e8>
    95da:	684b      	ldr	r3, [r1, #4]
    95dc:	f023 0303 	bic.w	r3, r3, #3
    95e0:	1b5a      	subs	r2, r3, r5
    95e2:	2a0f      	cmp	r2, #15
    95e4:	ddf2      	ble.n	95cc <_malloc_r+0x100>
    95e6:	460c      	mov	r4, r1
    95e8:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    95ec:	f854 8f08 	ldr.w	r8, [r4, #8]!
    95f0:	194b      	adds	r3, r1, r5
    95f2:	f045 0501 	orr.w	r5, r5, #1
    95f6:	604d      	str	r5, [r1, #4]
    95f8:	f042 0101 	orr.w	r1, r2, #1
    95fc:	f8c8 c00c 	str.w	ip, [r8, #12]
    9600:	4630      	mov	r0, r6
    9602:	f8cc 8008 	str.w	r8, [ip, #8]
    9606:	617b      	str	r3, [r7, #20]
    9608:	613b      	str	r3, [r7, #16]
    960a:	f8c3 e00c 	str.w	lr, [r3, #12]
    960e:	f8c3 e008 	str.w	lr, [r3, #8]
    9612:	6059      	str	r1, [r3, #4]
    9614:	509a      	str	r2, [r3, r2]
    9616:	f000 fac5 	bl	9ba4 <__malloc_unlock>
    961a:	e01f      	b.n	965c <_malloc_r+0x190>
    961c:	2910      	cmp	r1, #16
    961e:	d821      	bhi.n	9664 <_malloc_r+0x198>
    9620:	f000 fabe 	bl	9ba0 <__malloc_lock>
    9624:	2510      	movs	r5, #16
    9626:	2306      	movs	r3, #6
    9628:	2002      	movs	r0, #2
    962a:	4f7e      	ldr	r7, [pc, #504]	; (9824 <_malloc_r+0x358>)
    962c:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    9630:	f1a3 0208 	sub.w	r2, r3, #8
    9634:	685c      	ldr	r4, [r3, #4]
    9636:	4294      	cmp	r4, r2
    9638:	f000 8145 	beq.w	98c6 <_malloc_r+0x3fa>
    963c:	6863      	ldr	r3, [r4, #4]
    963e:	68e1      	ldr	r1, [r4, #12]
    9640:	68a5      	ldr	r5, [r4, #8]
    9642:	f023 0303 	bic.w	r3, r3, #3
    9646:	4423      	add	r3, r4
    9648:	4630      	mov	r0, r6
    964a:	685a      	ldr	r2, [r3, #4]
    964c:	60e9      	str	r1, [r5, #12]
    964e:	f042 0201 	orr.w	r2, r2, #1
    9652:	608d      	str	r5, [r1, #8]
    9654:	605a      	str	r2, [r3, #4]
    9656:	f000 faa5 	bl	9ba4 <__malloc_unlock>
    965a:	3408      	adds	r4, #8
    965c:	4620      	mov	r0, r4
    965e:	b003      	add	sp, #12
    9660:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9664:	2400      	movs	r4, #0
    9666:	230c      	movs	r3, #12
    9668:	4620      	mov	r0, r4
    966a:	6033      	str	r3, [r6, #0]
    966c:	b003      	add	sp, #12
    966e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9672:	2380      	movs	r3, #128	; 0x80
    9674:	f04f 0e40 	mov.w	lr, #64	; 0x40
    9678:	203f      	movs	r0, #63	; 0x3f
    967a:	e749      	b.n	9510 <_malloc_r+0x44>
    967c:	4670      	mov	r0, lr
    967e:	e75d      	b.n	953c <_malloc_r+0x70>
    9680:	4423      	add	r3, r4
    9682:	68e1      	ldr	r1, [r4, #12]
    9684:	685a      	ldr	r2, [r3, #4]
    9686:	68a5      	ldr	r5, [r4, #8]
    9688:	f042 0201 	orr.w	r2, r2, #1
    968c:	60e9      	str	r1, [r5, #12]
    968e:	4630      	mov	r0, r6
    9690:	608d      	str	r5, [r1, #8]
    9692:	605a      	str	r2, [r3, #4]
    9694:	f000 fa86 	bl	9ba4 <__malloc_unlock>
    9698:	3408      	adds	r4, #8
    969a:	4620      	mov	r0, r4
    969c:	b003      	add	sp, #12
    969e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    96a2:	4423      	add	r3, r4
    96a4:	4630      	mov	r0, r6
    96a6:	685a      	ldr	r2, [r3, #4]
    96a8:	f042 0201 	orr.w	r2, r2, #1
    96ac:	605a      	str	r2, [r3, #4]
    96ae:	f000 fa79 	bl	9ba4 <__malloc_unlock>
    96b2:	3408      	adds	r4, #8
    96b4:	4620      	mov	r0, r4
    96b6:	b003      	add	sp, #12
    96b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    96bc:	68bc      	ldr	r4, [r7, #8]
    96be:	6863      	ldr	r3, [r4, #4]
    96c0:	f023 0803 	bic.w	r8, r3, #3
    96c4:	45a8      	cmp	r8, r5
    96c6:	d304      	bcc.n	96d2 <_malloc_r+0x206>
    96c8:	ebc5 0308 	rsb	r3, r5, r8
    96cc:	2b0f      	cmp	r3, #15
    96ce:	f300 808c 	bgt.w	97ea <_malloc_r+0x31e>
    96d2:	4b55      	ldr	r3, [pc, #340]	; (9828 <_malloc_r+0x35c>)
    96d4:	f8df 9160 	ldr.w	r9, [pc, #352]	; 9838 <_malloc_r+0x36c>
    96d8:	681a      	ldr	r2, [r3, #0]
    96da:	f8d9 3000 	ldr.w	r3, [r9]
    96de:	3301      	adds	r3, #1
    96e0:	442a      	add	r2, r5
    96e2:	eb04 0a08 	add.w	sl, r4, r8
    96e6:	f000 8160 	beq.w	99aa <_malloc_r+0x4de>
    96ea:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    96ee:	320f      	adds	r2, #15
    96f0:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
    96f4:	f022 020f 	bic.w	r2, r2, #15
    96f8:	4611      	mov	r1, r2
    96fa:	4630      	mov	r0, r6
    96fc:	9201      	str	r2, [sp, #4]
    96fe:	f000 fc4b 	bl	9f98 <_sbrk_r>
    9702:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    9706:	4683      	mov	fp, r0
    9708:	9a01      	ldr	r2, [sp, #4]
    970a:	f000 8158 	beq.w	99be <_malloc_r+0x4f2>
    970e:	4582      	cmp	sl, r0
    9710:	f200 80fc 	bhi.w	990c <_malloc_r+0x440>
    9714:	4b45      	ldr	r3, [pc, #276]	; (982c <_malloc_r+0x360>)
    9716:	6819      	ldr	r1, [r3, #0]
    9718:	45da      	cmp	sl, fp
    971a:	4411      	add	r1, r2
    971c:	6019      	str	r1, [r3, #0]
    971e:	f000 8153 	beq.w	99c8 <_malloc_r+0x4fc>
    9722:	f8d9 0000 	ldr.w	r0, [r9]
    9726:	f8df e110 	ldr.w	lr, [pc, #272]	; 9838 <_malloc_r+0x36c>
    972a:	3001      	adds	r0, #1
    972c:	bf1b      	ittet	ne
    972e:	ebca 0a0b 	rsbne	sl, sl, fp
    9732:	4451      	addne	r1, sl
    9734:	f8ce b000 	streq.w	fp, [lr]
    9738:	6019      	strne	r1, [r3, #0]
    973a:	f01b 0107 	ands.w	r1, fp, #7
    973e:	f000 8117 	beq.w	9970 <_malloc_r+0x4a4>
    9742:	f1c1 0008 	rsb	r0, r1, #8
    9746:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
    974a:	4483      	add	fp, r0
    974c:	3108      	adds	r1, #8
    974e:	445a      	add	r2, fp
    9750:	f3c2 020b 	ubfx	r2, r2, #0, #12
    9754:	ebc2 0901 	rsb	r9, r2, r1
    9758:	4649      	mov	r1, r9
    975a:	4630      	mov	r0, r6
    975c:	9301      	str	r3, [sp, #4]
    975e:	f000 fc1b 	bl	9f98 <_sbrk_r>
    9762:	1c43      	adds	r3, r0, #1
    9764:	9b01      	ldr	r3, [sp, #4]
    9766:	f000 813f 	beq.w	99e8 <_malloc_r+0x51c>
    976a:	ebcb 0200 	rsb	r2, fp, r0
    976e:	444a      	add	r2, r9
    9770:	f042 0201 	orr.w	r2, r2, #1
    9774:	6819      	ldr	r1, [r3, #0]
    9776:	f8c7 b008 	str.w	fp, [r7, #8]
    977a:	4449      	add	r1, r9
    977c:	42bc      	cmp	r4, r7
    977e:	f8cb 2004 	str.w	r2, [fp, #4]
    9782:	6019      	str	r1, [r3, #0]
    9784:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 982c <_malloc_r+0x360>
    9788:	d016      	beq.n	97b8 <_malloc_r+0x2ec>
    978a:	f1b8 0f0f 	cmp.w	r8, #15
    978e:	f240 80fd 	bls.w	998c <_malloc_r+0x4c0>
    9792:	6862      	ldr	r2, [r4, #4]
    9794:	f1a8 030c 	sub.w	r3, r8, #12
    9798:	f023 0307 	bic.w	r3, r3, #7
    979c:	18e0      	adds	r0, r4, r3
    979e:	f002 0201 	and.w	r2, r2, #1
    97a2:	f04f 0e05 	mov.w	lr, #5
    97a6:	431a      	orrs	r2, r3
    97a8:	2b0f      	cmp	r3, #15
    97aa:	6062      	str	r2, [r4, #4]
    97ac:	f8c0 e004 	str.w	lr, [r0, #4]
    97b0:	f8c0 e008 	str.w	lr, [r0, #8]
    97b4:	f200 811c 	bhi.w	99f0 <_malloc_r+0x524>
    97b8:	4b1d      	ldr	r3, [pc, #116]	; (9830 <_malloc_r+0x364>)
    97ba:	68bc      	ldr	r4, [r7, #8]
    97bc:	681a      	ldr	r2, [r3, #0]
    97be:	4291      	cmp	r1, r2
    97c0:	bf88      	it	hi
    97c2:	6019      	strhi	r1, [r3, #0]
    97c4:	4b1b      	ldr	r3, [pc, #108]	; (9834 <_malloc_r+0x368>)
    97c6:	681a      	ldr	r2, [r3, #0]
    97c8:	4291      	cmp	r1, r2
    97ca:	6862      	ldr	r2, [r4, #4]
    97cc:	bf88      	it	hi
    97ce:	6019      	strhi	r1, [r3, #0]
    97d0:	f022 0203 	bic.w	r2, r2, #3
    97d4:	4295      	cmp	r5, r2
    97d6:	eba2 0305 	sub.w	r3, r2, r5
    97da:	d801      	bhi.n	97e0 <_malloc_r+0x314>
    97dc:	2b0f      	cmp	r3, #15
    97de:	dc04      	bgt.n	97ea <_malloc_r+0x31e>
    97e0:	4630      	mov	r0, r6
    97e2:	f000 f9df 	bl	9ba4 <__malloc_unlock>
    97e6:	2400      	movs	r4, #0
    97e8:	e738      	b.n	965c <_malloc_r+0x190>
    97ea:	1962      	adds	r2, r4, r5
    97ec:	f043 0301 	orr.w	r3, r3, #1
    97f0:	f045 0501 	orr.w	r5, r5, #1
    97f4:	6065      	str	r5, [r4, #4]
    97f6:	4630      	mov	r0, r6
    97f8:	60ba      	str	r2, [r7, #8]
    97fa:	6053      	str	r3, [r2, #4]
    97fc:	f000 f9d2 	bl	9ba4 <__malloc_unlock>
    9800:	3408      	adds	r4, #8
    9802:	4620      	mov	r0, r4
    9804:	b003      	add	sp, #12
    9806:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    980a:	2b14      	cmp	r3, #20
    980c:	d971      	bls.n	98f2 <_malloc_r+0x426>
    980e:	2b54      	cmp	r3, #84	; 0x54
    9810:	f200 80a4 	bhi.w	995c <_malloc_r+0x490>
    9814:	0b28      	lsrs	r0, r5, #12
    9816:	f100 0e6f 	add.w	lr, r0, #111	; 0x6f
    981a:	ea4f 034e 	mov.w	r3, lr, lsl #1
    981e:	306e      	adds	r0, #110	; 0x6e
    9820:	e676      	b.n	9510 <_malloc_r+0x44>
    9822:	bf00      	nop
    9824:	1fff1014 	.word	0x1fff1014
    9828:	1fff2c84 	.word	0x1fff2c84
    982c:	1fff2c88 	.word	0x1fff2c88
    9830:	1fff2c80 	.word	0x1fff2c80
    9834:	1fff2c7c 	.word	0x1fff2c7c
    9838:	1fff1420 	.word	0x1fff1420
    983c:	0a5a      	lsrs	r2, r3, #9
    983e:	2a04      	cmp	r2, #4
    9840:	d95e      	bls.n	9900 <_malloc_r+0x434>
    9842:	2a14      	cmp	r2, #20
    9844:	f200 80b3 	bhi.w	99ae <_malloc_r+0x4e2>
    9848:	f102 015c 	add.w	r1, r2, #92	; 0x5c
    984c:	0049      	lsls	r1, r1, #1
    984e:	325b      	adds	r2, #91	; 0x5b
    9850:	eb07 0c81 	add.w	ip, r7, r1, lsl #2
    9854:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
    9858:	f8df 81dc 	ldr.w	r8, [pc, #476]	; 9a38 <_malloc_r+0x56c>
    985c:	f1ac 0c08 	sub.w	ip, ip, #8
    9860:	458c      	cmp	ip, r1
    9862:	f000 8088 	beq.w	9976 <_malloc_r+0x4aa>
    9866:	684a      	ldr	r2, [r1, #4]
    9868:	f022 0203 	bic.w	r2, r2, #3
    986c:	4293      	cmp	r3, r2
    986e:	d202      	bcs.n	9876 <_malloc_r+0x3aa>
    9870:	6889      	ldr	r1, [r1, #8]
    9872:	458c      	cmp	ip, r1
    9874:	d1f7      	bne.n	9866 <_malloc_r+0x39a>
    9876:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    987a:	687a      	ldr	r2, [r7, #4]
    987c:	f8c4 c00c 	str.w	ip, [r4, #12]
    9880:	60a1      	str	r1, [r4, #8]
    9882:	f8cc 4008 	str.w	r4, [ip, #8]
    9886:	60cc      	str	r4, [r1, #12]
    9888:	e688      	b.n	959c <_malloc_r+0xd0>
    988a:	1963      	adds	r3, r4, r5
    988c:	f042 0701 	orr.w	r7, r2, #1
    9890:	f045 0501 	orr.w	r5, r5, #1
    9894:	6065      	str	r5, [r4, #4]
    9896:	4630      	mov	r0, r6
    9898:	614b      	str	r3, [r1, #20]
    989a:	610b      	str	r3, [r1, #16]
    989c:	f8c3 e00c 	str.w	lr, [r3, #12]
    98a0:	f8c3 e008 	str.w	lr, [r3, #8]
    98a4:	605f      	str	r7, [r3, #4]
    98a6:	509a      	str	r2, [r3, r2]
    98a8:	3408      	adds	r4, #8
    98aa:	f000 f97b 	bl	9ba4 <__malloc_unlock>
    98ae:	e6d5      	b.n	965c <_malloc_r+0x190>
    98b0:	684a      	ldr	r2, [r1, #4]
    98b2:	e673      	b.n	959c <_malloc_r+0xd0>
    98b4:	f108 0801 	add.w	r8, r8, #1
    98b8:	f018 0f03 	tst.w	r8, #3
    98bc:	f10c 0c08 	add.w	ip, ip, #8
    98c0:	f47f ae7f 	bne.w	95c2 <_malloc_r+0xf6>
    98c4:	e030      	b.n	9928 <_malloc_r+0x45c>
    98c6:	68dc      	ldr	r4, [r3, #12]
    98c8:	42a3      	cmp	r3, r4
    98ca:	bf08      	it	eq
    98cc:	3002      	addeq	r0, #2
    98ce:	f43f ae35 	beq.w	953c <_malloc_r+0x70>
    98d2:	e6b3      	b.n	963c <_malloc_r+0x170>
    98d4:	440b      	add	r3, r1
    98d6:	460c      	mov	r4, r1
    98d8:	685a      	ldr	r2, [r3, #4]
    98da:	68c9      	ldr	r1, [r1, #12]
    98dc:	f854 5f08 	ldr.w	r5, [r4, #8]!
    98e0:	f042 0201 	orr.w	r2, r2, #1
    98e4:	605a      	str	r2, [r3, #4]
    98e6:	4630      	mov	r0, r6
    98e8:	60e9      	str	r1, [r5, #12]
    98ea:	608d      	str	r5, [r1, #8]
    98ec:	f000 f95a 	bl	9ba4 <__malloc_unlock>
    98f0:	e6b4      	b.n	965c <_malloc_r+0x190>
    98f2:	f103 0e5c 	add.w	lr, r3, #92	; 0x5c
    98f6:	f103 005b 	add.w	r0, r3, #91	; 0x5b
    98fa:	ea4f 034e 	mov.w	r3, lr, lsl #1
    98fe:	e607      	b.n	9510 <_malloc_r+0x44>
    9900:	099a      	lsrs	r2, r3, #6
    9902:	f102 0139 	add.w	r1, r2, #57	; 0x39
    9906:	0049      	lsls	r1, r1, #1
    9908:	3238      	adds	r2, #56	; 0x38
    990a:	e7a1      	b.n	9850 <_malloc_r+0x384>
    990c:	42bc      	cmp	r4, r7
    990e:	4b4a      	ldr	r3, [pc, #296]	; (9a38 <_malloc_r+0x56c>)
    9910:	f43f af00 	beq.w	9714 <_malloc_r+0x248>
    9914:	689c      	ldr	r4, [r3, #8]
    9916:	6862      	ldr	r2, [r4, #4]
    9918:	f022 0203 	bic.w	r2, r2, #3
    991c:	e75a      	b.n	97d4 <_malloc_r+0x308>
    991e:	f859 3908 	ldr.w	r3, [r9], #-8
    9922:	4599      	cmp	r9, r3
    9924:	f040 8082 	bne.w	9a2c <_malloc_r+0x560>
    9928:	f010 0f03 	tst.w	r0, #3
    992c:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
    9930:	d1f5      	bne.n	991e <_malloc_r+0x452>
    9932:	687b      	ldr	r3, [r7, #4]
    9934:	ea23 0304 	bic.w	r3, r3, r4
    9938:	607b      	str	r3, [r7, #4]
    993a:	0064      	lsls	r4, r4, #1
    993c:	429c      	cmp	r4, r3
    993e:	f63f aebd 	bhi.w	96bc <_malloc_r+0x1f0>
    9942:	2c00      	cmp	r4, #0
    9944:	f43f aeba 	beq.w	96bc <_malloc_r+0x1f0>
    9948:	421c      	tst	r4, r3
    994a:	4640      	mov	r0, r8
    994c:	f47f ae35 	bne.w	95ba <_malloc_r+0xee>
    9950:	0064      	lsls	r4, r4, #1
    9952:	421c      	tst	r4, r3
    9954:	f100 0004 	add.w	r0, r0, #4
    9958:	d0fa      	beq.n	9950 <_malloc_r+0x484>
    995a:	e62e      	b.n	95ba <_malloc_r+0xee>
    995c:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
    9960:	d818      	bhi.n	9994 <_malloc_r+0x4c8>
    9962:	0be8      	lsrs	r0, r5, #15
    9964:	f100 0e78 	add.w	lr, r0, #120	; 0x78
    9968:	ea4f 034e 	mov.w	r3, lr, lsl #1
    996c:	3077      	adds	r0, #119	; 0x77
    996e:	e5cf      	b.n	9510 <_malloc_r+0x44>
    9970:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    9974:	e6eb      	b.n	974e <_malloc_r+0x282>
    9976:	2101      	movs	r1, #1
    9978:	f8d8 3004 	ldr.w	r3, [r8, #4]
    997c:	1092      	asrs	r2, r2, #2
    997e:	fa01 f202 	lsl.w	r2, r1, r2
    9982:	431a      	orrs	r2, r3
    9984:	f8c8 2004 	str.w	r2, [r8, #4]
    9988:	4661      	mov	r1, ip
    998a:	e777      	b.n	987c <_malloc_r+0x3b0>
    998c:	2301      	movs	r3, #1
    998e:	f8cb 3004 	str.w	r3, [fp, #4]
    9992:	e725      	b.n	97e0 <_malloc_r+0x314>
    9994:	f240 5254 	movw	r2, #1364	; 0x554
    9998:	4293      	cmp	r3, r2
    999a:	d820      	bhi.n	99de <_malloc_r+0x512>
    999c:	0ca8      	lsrs	r0, r5, #18
    999e:	f100 0e7d 	add.w	lr, r0, #125	; 0x7d
    99a2:	ea4f 034e 	mov.w	r3, lr, lsl #1
    99a6:	307c      	adds	r0, #124	; 0x7c
    99a8:	e5b2      	b.n	9510 <_malloc_r+0x44>
    99aa:	3210      	adds	r2, #16
    99ac:	e6a4      	b.n	96f8 <_malloc_r+0x22c>
    99ae:	2a54      	cmp	r2, #84	; 0x54
    99b0:	d826      	bhi.n	9a00 <_malloc_r+0x534>
    99b2:	0b1a      	lsrs	r2, r3, #12
    99b4:	f102 016f 	add.w	r1, r2, #111	; 0x6f
    99b8:	0049      	lsls	r1, r1, #1
    99ba:	326e      	adds	r2, #110	; 0x6e
    99bc:	e748      	b.n	9850 <_malloc_r+0x384>
    99be:	68bc      	ldr	r4, [r7, #8]
    99c0:	6862      	ldr	r2, [r4, #4]
    99c2:	f022 0203 	bic.w	r2, r2, #3
    99c6:	e705      	b.n	97d4 <_malloc_r+0x308>
    99c8:	f3ca 000b 	ubfx	r0, sl, #0, #12
    99cc:	2800      	cmp	r0, #0
    99ce:	f47f aea8 	bne.w	9722 <_malloc_r+0x256>
    99d2:	4442      	add	r2, r8
    99d4:	68bb      	ldr	r3, [r7, #8]
    99d6:	f042 0201 	orr.w	r2, r2, #1
    99da:	605a      	str	r2, [r3, #4]
    99dc:	e6ec      	b.n	97b8 <_malloc_r+0x2ec>
    99de:	23fe      	movs	r3, #254	; 0xfe
    99e0:	f04f 0e7f 	mov.w	lr, #127	; 0x7f
    99e4:	207e      	movs	r0, #126	; 0x7e
    99e6:	e593      	b.n	9510 <_malloc_r+0x44>
    99e8:	2201      	movs	r2, #1
    99ea:	f04f 0900 	mov.w	r9, #0
    99ee:	e6c1      	b.n	9774 <_malloc_r+0x2a8>
    99f0:	f104 0108 	add.w	r1, r4, #8
    99f4:	4630      	mov	r0, r6
    99f6:	f000 fda3 	bl	a540 <_free_r>
    99fa:	f8d9 1000 	ldr.w	r1, [r9]
    99fe:	e6db      	b.n	97b8 <_malloc_r+0x2ec>
    9a00:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    9a04:	d805      	bhi.n	9a12 <_malloc_r+0x546>
    9a06:	0bda      	lsrs	r2, r3, #15
    9a08:	f102 0178 	add.w	r1, r2, #120	; 0x78
    9a0c:	0049      	lsls	r1, r1, #1
    9a0e:	3277      	adds	r2, #119	; 0x77
    9a10:	e71e      	b.n	9850 <_malloc_r+0x384>
    9a12:	f240 5154 	movw	r1, #1364	; 0x554
    9a16:	428a      	cmp	r2, r1
    9a18:	d805      	bhi.n	9a26 <_malloc_r+0x55a>
    9a1a:	0c9a      	lsrs	r2, r3, #18
    9a1c:	f102 017d 	add.w	r1, r2, #125	; 0x7d
    9a20:	0049      	lsls	r1, r1, #1
    9a22:	327c      	adds	r2, #124	; 0x7c
    9a24:	e714      	b.n	9850 <_malloc_r+0x384>
    9a26:	21fe      	movs	r1, #254	; 0xfe
    9a28:	227e      	movs	r2, #126	; 0x7e
    9a2a:	e711      	b.n	9850 <_malloc_r+0x384>
    9a2c:	687b      	ldr	r3, [r7, #4]
    9a2e:	e784      	b.n	993a <_malloc_r+0x46e>
    9a30:	08e8      	lsrs	r0, r5, #3
    9a32:	1c43      	adds	r3, r0, #1
    9a34:	005b      	lsls	r3, r3, #1
    9a36:	e5f8      	b.n	962a <_malloc_r+0x15e>
    9a38:	1fff1014 	.word	0x1fff1014

00009a3c <memmove>:
    9a3c:	4288      	cmp	r0, r1
    9a3e:	b5f0      	push	{r4, r5, r6, r7, lr}
    9a40:	d90d      	bls.n	9a5e <memmove+0x22>
    9a42:	188b      	adds	r3, r1, r2
    9a44:	4298      	cmp	r0, r3
    9a46:	d20a      	bcs.n	9a5e <memmove+0x22>
    9a48:	1881      	adds	r1, r0, r2
    9a4a:	2a00      	cmp	r2, #0
    9a4c:	d051      	beq.n	9af2 <memmove+0xb6>
    9a4e:	1a9a      	subs	r2, r3, r2
    9a50:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
    9a54:	f801 4d01 	strb.w	r4, [r1, #-1]!
    9a58:	4293      	cmp	r3, r2
    9a5a:	d1f9      	bne.n	9a50 <memmove+0x14>
    9a5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9a5e:	2a0f      	cmp	r2, #15
    9a60:	d948      	bls.n	9af4 <memmove+0xb8>
    9a62:	ea41 0300 	orr.w	r3, r1, r0
    9a66:	079b      	lsls	r3, r3, #30
    9a68:	d146      	bne.n	9af8 <memmove+0xbc>
    9a6a:	f100 0410 	add.w	r4, r0, #16
    9a6e:	f101 0310 	add.w	r3, r1, #16
    9a72:	4615      	mov	r5, r2
    9a74:	f853 6c10 	ldr.w	r6, [r3, #-16]
    9a78:	f844 6c10 	str.w	r6, [r4, #-16]
    9a7c:	f853 6c0c 	ldr.w	r6, [r3, #-12]
    9a80:	f844 6c0c 	str.w	r6, [r4, #-12]
    9a84:	f853 6c08 	ldr.w	r6, [r3, #-8]
    9a88:	f844 6c08 	str.w	r6, [r4, #-8]
    9a8c:	3d10      	subs	r5, #16
    9a8e:	f853 6c04 	ldr.w	r6, [r3, #-4]
    9a92:	f844 6c04 	str.w	r6, [r4, #-4]
    9a96:	2d0f      	cmp	r5, #15
    9a98:	f103 0310 	add.w	r3, r3, #16
    9a9c:	f104 0410 	add.w	r4, r4, #16
    9aa0:	d8e8      	bhi.n	9a74 <memmove+0x38>
    9aa2:	f1a2 0310 	sub.w	r3, r2, #16
    9aa6:	f023 030f 	bic.w	r3, r3, #15
    9aaa:	f002 0e0f 	and.w	lr, r2, #15
    9aae:	3310      	adds	r3, #16
    9ab0:	f1be 0f03 	cmp.w	lr, #3
    9ab4:	4419      	add	r1, r3
    9ab6:	4403      	add	r3, r0
    9ab8:	d921      	bls.n	9afe <memmove+0xc2>
    9aba:	1f1e      	subs	r6, r3, #4
    9abc:	460d      	mov	r5, r1
    9abe:	4674      	mov	r4, lr
    9ac0:	3c04      	subs	r4, #4
    9ac2:	f855 7b04 	ldr.w	r7, [r5], #4
    9ac6:	f846 7f04 	str.w	r7, [r6, #4]!
    9aca:	2c03      	cmp	r4, #3
    9acc:	d8f8      	bhi.n	9ac0 <memmove+0x84>
    9ace:	f1ae 0404 	sub.w	r4, lr, #4
    9ad2:	f024 0403 	bic.w	r4, r4, #3
    9ad6:	3404      	adds	r4, #4
    9ad8:	4423      	add	r3, r4
    9ada:	4421      	add	r1, r4
    9adc:	f002 0203 	and.w	r2, r2, #3
    9ae0:	b162      	cbz	r2, 9afc <memmove+0xc0>
    9ae2:	3b01      	subs	r3, #1
    9ae4:	440a      	add	r2, r1
    9ae6:	f811 4b01 	ldrb.w	r4, [r1], #1
    9aea:	f803 4f01 	strb.w	r4, [r3, #1]!
    9aee:	428a      	cmp	r2, r1
    9af0:	d1f9      	bne.n	9ae6 <memmove+0xaa>
    9af2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9af4:	4603      	mov	r3, r0
    9af6:	e7f3      	b.n	9ae0 <memmove+0xa4>
    9af8:	4603      	mov	r3, r0
    9afa:	e7f2      	b.n	9ae2 <memmove+0xa6>
    9afc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9afe:	4672      	mov	r2, lr
    9b00:	e7ee      	b.n	9ae0 <memmove+0xa4>
    9b02:	bf00      	nop

00009b04 <memset>:
    9b04:	b470      	push	{r4, r5, r6}
    9b06:	0784      	lsls	r4, r0, #30
    9b08:	d046      	beq.n	9b98 <memset+0x94>
    9b0a:	1e54      	subs	r4, r2, #1
    9b0c:	2a00      	cmp	r2, #0
    9b0e:	d041      	beq.n	9b94 <memset+0x90>
    9b10:	b2cd      	uxtb	r5, r1
    9b12:	4603      	mov	r3, r0
    9b14:	e002      	b.n	9b1c <memset+0x18>
    9b16:	1e62      	subs	r2, r4, #1
    9b18:	b3e4      	cbz	r4, 9b94 <memset+0x90>
    9b1a:	4614      	mov	r4, r2
    9b1c:	f803 5b01 	strb.w	r5, [r3], #1
    9b20:	079a      	lsls	r2, r3, #30
    9b22:	d1f8      	bne.n	9b16 <memset+0x12>
    9b24:	2c03      	cmp	r4, #3
    9b26:	d92e      	bls.n	9b86 <memset+0x82>
    9b28:	b2cd      	uxtb	r5, r1
    9b2a:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    9b2e:	2c0f      	cmp	r4, #15
    9b30:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    9b34:	d919      	bls.n	9b6a <memset+0x66>
    9b36:	f103 0210 	add.w	r2, r3, #16
    9b3a:	4626      	mov	r6, r4
    9b3c:	3e10      	subs	r6, #16
    9b3e:	2e0f      	cmp	r6, #15
    9b40:	f842 5c10 	str.w	r5, [r2, #-16]
    9b44:	f842 5c0c 	str.w	r5, [r2, #-12]
    9b48:	f842 5c08 	str.w	r5, [r2, #-8]
    9b4c:	f842 5c04 	str.w	r5, [r2, #-4]
    9b50:	f102 0210 	add.w	r2, r2, #16
    9b54:	d8f2      	bhi.n	9b3c <memset+0x38>
    9b56:	f1a4 0210 	sub.w	r2, r4, #16
    9b5a:	f022 020f 	bic.w	r2, r2, #15
    9b5e:	f004 040f 	and.w	r4, r4, #15
    9b62:	3210      	adds	r2, #16
    9b64:	2c03      	cmp	r4, #3
    9b66:	4413      	add	r3, r2
    9b68:	d90d      	bls.n	9b86 <memset+0x82>
    9b6a:	461e      	mov	r6, r3
    9b6c:	4622      	mov	r2, r4
    9b6e:	3a04      	subs	r2, #4
    9b70:	2a03      	cmp	r2, #3
    9b72:	f846 5b04 	str.w	r5, [r6], #4
    9b76:	d8fa      	bhi.n	9b6e <memset+0x6a>
    9b78:	1f22      	subs	r2, r4, #4
    9b7a:	f022 0203 	bic.w	r2, r2, #3
    9b7e:	3204      	adds	r2, #4
    9b80:	4413      	add	r3, r2
    9b82:	f004 0403 	and.w	r4, r4, #3
    9b86:	b12c      	cbz	r4, 9b94 <memset+0x90>
    9b88:	b2c9      	uxtb	r1, r1
    9b8a:	441c      	add	r4, r3
    9b8c:	f803 1b01 	strb.w	r1, [r3], #1
    9b90:	42a3      	cmp	r3, r4
    9b92:	d1fb      	bne.n	9b8c <memset+0x88>
    9b94:	bc70      	pop	{r4, r5, r6}
    9b96:	4770      	bx	lr
    9b98:	4614      	mov	r4, r2
    9b9a:	4603      	mov	r3, r0
    9b9c:	e7c2      	b.n	9b24 <memset+0x20>
    9b9e:	bf00      	nop

00009ba0 <__malloc_lock>:
    9ba0:	4770      	bx	lr
    9ba2:	bf00      	nop

00009ba4 <__malloc_unlock>:
    9ba4:	4770      	bx	lr
    9ba6:	bf00      	nop

00009ba8 <realloc>:
    9ba8:	4b02      	ldr	r3, [pc, #8]	; (9bb4 <realloc+0xc>)
    9baa:	460a      	mov	r2, r1
    9bac:	4601      	mov	r1, r0
    9bae:	6818      	ldr	r0, [r3, #0]
    9bb0:	f000 b802 	b.w	9bb8 <_realloc_r>
    9bb4:	1fff1010 	.word	0x1fff1010

00009bb8 <_realloc_r>:
    9bb8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9bbc:	4617      	mov	r7, r2
    9bbe:	b083      	sub	sp, #12
    9bc0:	2900      	cmp	r1, #0
    9bc2:	f000 80c1 	beq.w	9d48 <_realloc_r+0x190>
    9bc6:	460e      	mov	r6, r1
    9bc8:	4681      	mov	r9, r0
    9bca:	f107 050b 	add.w	r5, r7, #11
    9bce:	f7ff ffe7 	bl	9ba0 <__malloc_lock>
    9bd2:	f856 ec04 	ldr.w	lr, [r6, #-4]
    9bd6:	2d16      	cmp	r5, #22
    9bd8:	f02e 0403 	bic.w	r4, lr, #3
    9bdc:	f1a6 0808 	sub.w	r8, r6, #8
    9be0:	d840      	bhi.n	9c64 <_realloc_r+0xac>
    9be2:	2210      	movs	r2, #16
    9be4:	4615      	mov	r5, r2
    9be6:	42af      	cmp	r7, r5
    9be8:	d841      	bhi.n	9c6e <_realloc_r+0xb6>
    9bea:	4294      	cmp	r4, r2
    9bec:	da75      	bge.n	9cda <_realloc_r+0x122>
    9bee:	4bc9      	ldr	r3, [pc, #804]	; (9f14 <_realloc_r+0x35c>)
    9bf0:	6899      	ldr	r1, [r3, #8]
    9bf2:	eb08 0004 	add.w	r0, r8, r4
    9bf6:	4288      	cmp	r0, r1
    9bf8:	6841      	ldr	r1, [r0, #4]
    9bfa:	f000 80d9 	beq.w	9db0 <_realloc_r+0x1f8>
    9bfe:	f021 0301 	bic.w	r3, r1, #1
    9c02:	4403      	add	r3, r0
    9c04:	685b      	ldr	r3, [r3, #4]
    9c06:	07db      	lsls	r3, r3, #31
    9c08:	d57d      	bpl.n	9d06 <_realloc_r+0x14e>
    9c0a:	f01e 0f01 	tst.w	lr, #1
    9c0e:	d035      	beq.n	9c7c <_realloc_r+0xc4>
    9c10:	4639      	mov	r1, r7
    9c12:	4648      	mov	r0, r9
    9c14:	f7ff fc5a 	bl	94cc <_malloc_r>
    9c18:	4607      	mov	r7, r0
    9c1a:	b1e0      	cbz	r0, 9c56 <_realloc_r+0x9e>
    9c1c:	f856 3c04 	ldr.w	r3, [r6, #-4]
    9c20:	f023 0301 	bic.w	r3, r3, #1
    9c24:	4443      	add	r3, r8
    9c26:	f1a0 0208 	sub.w	r2, r0, #8
    9c2a:	429a      	cmp	r2, r3
    9c2c:	f000 8144 	beq.w	9eb8 <_realloc_r+0x300>
    9c30:	1f22      	subs	r2, r4, #4
    9c32:	2a24      	cmp	r2, #36	; 0x24
    9c34:	f200 8131 	bhi.w	9e9a <_realloc_r+0x2e2>
    9c38:	2a13      	cmp	r2, #19
    9c3a:	f200 8104 	bhi.w	9e46 <_realloc_r+0x28e>
    9c3e:	4603      	mov	r3, r0
    9c40:	4632      	mov	r2, r6
    9c42:	6811      	ldr	r1, [r2, #0]
    9c44:	6019      	str	r1, [r3, #0]
    9c46:	6851      	ldr	r1, [r2, #4]
    9c48:	6059      	str	r1, [r3, #4]
    9c4a:	6892      	ldr	r2, [r2, #8]
    9c4c:	609a      	str	r2, [r3, #8]
    9c4e:	4631      	mov	r1, r6
    9c50:	4648      	mov	r0, r9
    9c52:	f000 fc75 	bl	a540 <_free_r>
    9c56:	4648      	mov	r0, r9
    9c58:	f7ff ffa4 	bl	9ba4 <__malloc_unlock>
    9c5c:	4638      	mov	r0, r7
    9c5e:	b003      	add	sp, #12
    9c60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9c64:	f025 0507 	bic.w	r5, r5, #7
    9c68:	2d00      	cmp	r5, #0
    9c6a:	462a      	mov	r2, r5
    9c6c:	dabb      	bge.n	9be6 <_realloc_r+0x2e>
    9c6e:	230c      	movs	r3, #12
    9c70:	2000      	movs	r0, #0
    9c72:	f8c9 3000 	str.w	r3, [r9]
    9c76:	b003      	add	sp, #12
    9c78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9c7c:	f856 3c08 	ldr.w	r3, [r6, #-8]
    9c80:	ebc3 0a08 	rsb	sl, r3, r8
    9c84:	f8da 3004 	ldr.w	r3, [sl, #4]
    9c88:	f023 0c03 	bic.w	ip, r3, #3
    9c8c:	eb04 030c 	add.w	r3, r4, ip
    9c90:	4293      	cmp	r3, r2
    9c92:	dbbd      	blt.n	9c10 <_realloc_r+0x58>
    9c94:	4657      	mov	r7, sl
    9c96:	f8da 100c 	ldr.w	r1, [sl, #12]
    9c9a:	f857 0f08 	ldr.w	r0, [r7, #8]!
    9c9e:	1f22      	subs	r2, r4, #4
    9ca0:	2a24      	cmp	r2, #36	; 0x24
    9ca2:	60c1      	str	r1, [r0, #12]
    9ca4:	6088      	str	r0, [r1, #8]
    9ca6:	f200 8117 	bhi.w	9ed8 <_realloc_r+0x320>
    9caa:	2a13      	cmp	r2, #19
    9cac:	f240 8112 	bls.w	9ed4 <_realloc_r+0x31c>
    9cb0:	6831      	ldr	r1, [r6, #0]
    9cb2:	f8ca 1008 	str.w	r1, [sl, #8]
    9cb6:	6871      	ldr	r1, [r6, #4]
    9cb8:	f8ca 100c 	str.w	r1, [sl, #12]
    9cbc:	2a1b      	cmp	r2, #27
    9cbe:	f200 812b 	bhi.w	9f18 <_realloc_r+0x360>
    9cc2:	3608      	adds	r6, #8
    9cc4:	f10a 0210 	add.w	r2, sl, #16
    9cc8:	6831      	ldr	r1, [r6, #0]
    9cca:	6011      	str	r1, [r2, #0]
    9ccc:	6871      	ldr	r1, [r6, #4]
    9cce:	6051      	str	r1, [r2, #4]
    9cd0:	68b1      	ldr	r1, [r6, #8]
    9cd2:	6091      	str	r1, [r2, #8]
    9cd4:	463e      	mov	r6, r7
    9cd6:	461c      	mov	r4, r3
    9cd8:	46d0      	mov	r8, sl
    9cda:	1b63      	subs	r3, r4, r5
    9cdc:	2b0f      	cmp	r3, #15
    9cde:	d81d      	bhi.n	9d1c <_realloc_r+0x164>
    9ce0:	f8d8 3004 	ldr.w	r3, [r8, #4]
    9ce4:	f003 0301 	and.w	r3, r3, #1
    9ce8:	4323      	orrs	r3, r4
    9cea:	4444      	add	r4, r8
    9cec:	f8c8 3004 	str.w	r3, [r8, #4]
    9cf0:	6863      	ldr	r3, [r4, #4]
    9cf2:	f043 0301 	orr.w	r3, r3, #1
    9cf6:	6063      	str	r3, [r4, #4]
    9cf8:	4648      	mov	r0, r9
    9cfa:	f7ff ff53 	bl	9ba4 <__malloc_unlock>
    9cfe:	4630      	mov	r0, r6
    9d00:	b003      	add	sp, #12
    9d02:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9d06:	f021 0103 	bic.w	r1, r1, #3
    9d0a:	4421      	add	r1, r4
    9d0c:	4291      	cmp	r1, r2
    9d0e:	db21      	blt.n	9d54 <_realloc_r+0x19c>
    9d10:	68c3      	ldr	r3, [r0, #12]
    9d12:	6882      	ldr	r2, [r0, #8]
    9d14:	460c      	mov	r4, r1
    9d16:	60d3      	str	r3, [r2, #12]
    9d18:	609a      	str	r2, [r3, #8]
    9d1a:	e7de      	b.n	9cda <_realloc_r+0x122>
    9d1c:	f8d8 2004 	ldr.w	r2, [r8, #4]
    9d20:	eb08 0105 	add.w	r1, r8, r5
    9d24:	f002 0201 	and.w	r2, r2, #1
    9d28:	4315      	orrs	r5, r2
    9d2a:	f043 0201 	orr.w	r2, r3, #1
    9d2e:	440b      	add	r3, r1
    9d30:	f8c8 5004 	str.w	r5, [r8, #4]
    9d34:	604a      	str	r2, [r1, #4]
    9d36:	685a      	ldr	r2, [r3, #4]
    9d38:	f042 0201 	orr.w	r2, r2, #1
    9d3c:	3108      	adds	r1, #8
    9d3e:	605a      	str	r2, [r3, #4]
    9d40:	4648      	mov	r0, r9
    9d42:	f000 fbfd 	bl	a540 <_free_r>
    9d46:	e7d7      	b.n	9cf8 <_realloc_r+0x140>
    9d48:	4611      	mov	r1, r2
    9d4a:	b003      	add	sp, #12
    9d4c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9d50:	f7ff bbbc 	b.w	94cc <_malloc_r>
    9d54:	f01e 0f01 	tst.w	lr, #1
    9d58:	f47f af5a 	bne.w	9c10 <_realloc_r+0x58>
    9d5c:	f856 3c08 	ldr.w	r3, [r6, #-8]
    9d60:	ebc3 0a08 	rsb	sl, r3, r8
    9d64:	f8da 3004 	ldr.w	r3, [sl, #4]
    9d68:	f023 0c03 	bic.w	ip, r3, #3
    9d6c:	eb01 0e0c 	add.w	lr, r1, ip
    9d70:	4596      	cmp	lr, r2
    9d72:	db8b      	blt.n	9c8c <_realloc_r+0xd4>
    9d74:	68c3      	ldr	r3, [r0, #12]
    9d76:	6882      	ldr	r2, [r0, #8]
    9d78:	4657      	mov	r7, sl
    9d7a:	60d3      	str	r3, [r2, #12]
    9d7c:	609a      	str	r2, [r3, #8]
    9d7e:	f857 1f08 	ldr.w	r1, [r7, #8]!
    9d82:	f8da 300c 	ldr.w	r3, [sl, #12]
    9d86:	60cb      	str	r3, [r1, #12]
    9d88:	1f22      	subs	r2, r4, #4
    9d8a:	2a24      	cmp	r2, #36	; 0x24
    9d8c:	6099      	str	r1, [r3, #8]
    9d8e:	f200 8099 	bhi.w	9ec4 <_realloc_r+0x30c>
    9d92:	2a13      	cmp	r2, #19
    9d94:	d962      	bls.n	9e5c <_realloc_r+0x2a4>
    9d96:	6833      	ldr	r3, [r6, #0]
    9d98:	f8ca 3008 	str.w	r3, [sl, #8]
    9d9c:	6873      	ldr	r3, [r6, #4]
    9d9e:	f8ca 300c 	str.w	r3, [sl, #12]
    9da2:	2a1b      	cmp	r2, #27
    9da4:	f200 80a0 	bhi.w	9ee8 <_realloc_r+0x330>
    9da8:	3608      	adds	r6, #8
    9daa:	f10a 0310 	add.w	r3, sl, #16
    9dae:	e056      	b.n	9e5e <_realloc_r+0x2a6>
    9db0:	f021 0b03 	bic.w	fp, r1, #3
    9db4:	44a3      	add	fp, r4
    9db6:	f105 0010 	add.w	r0, r5, #16
    9dba:	4583      	cmp	fp, r0
    9dbc:	da59      	bge.n	9e72 <_realloc_r+0x2ba>
    9dbe:	f01e 0f01 	tst.w	lr, #1
    9dc2:	f47f af25 	bne.w	9c10 <_realloc_r+0x58>
    9dc6:	f856 1c08 	ldr.w	r1, [r6, #-8]
    9dca:	ebc1 0a08 	rsb	sl, r1, r8
    9dce:	f8da 1004 	ldr.w	r1, [sl, #4]
    9dd2:	f021 0c03 	bic.w	ip, r1, #3
    9dd6:	44e3      	add	fp, ip
    9dd8:	4558      	cmp	r0, fp
    9dda:	f73f af57 	bgt.w	9c8c <_realloc_r+0xd4>
    9dde:	4657      	mov	r7, sl
    9de0:	f8da 100c 	ldr.w	r1, [sl, #12]
    9de4:	f857 0f08 	ldr.w	r0, [r7, #8]!
    9de8:	1f22      	subs	r2, r4, #4
    9dea:	2a24      	cmp	r2, #36	; 0x24
    9dec:	60c1      	str	r1, [r0, #12]
    9dee:	6088      	str	r0, [r1, #8]
    9df0:	f200 80b4 	bhi.w	9f5c <_realloc_r+0x3a4>
    9df4:	2a13      	cmp	r2, #19
    9df6:	f240 80a5 	bls.w	9f44 <_realloc_r+0x38c>
    9dfa:	6831      	ldr	r1, [r6, #0]
    9dfc:	f8ca 1008 	str.w	r1, [sl, #8]
    9e00:	6871      	ldr	r1, [r6, #4]
    9e02:	f8ca 100c 	str.w	r1, [sl, #12]
    9e06:	2a1b      	cmp	r2, #27
    9e08:	f200 80af 	bhi.w	9f6a <_realloc_r+0x3b2>
    9e0c:	3608      	adds	r6, #8
    9e0e:	f10a 0210 	add.w	r2, sl, #16
    9e12:	6831      	ldr	r1, [r6, #0]
    9e14:	6011      	str	r1, [r2, #0]
    9e16:	6871      	ldr	r1, [r6, #4]
    9e18:	6051      	str	r1, [r2, #4]
    9e1a:	68b1      	ldr	r1, [r6, #8]
    9e1c:	6091      	str	r1, [r2, #8]
    9e1e:	eb0a 0105 	add.w	r1, sl, r5
    9e22:	ebc5 020b 	rsb	r2, r5, fp
    9e26:	f042 0201 	orr.w	r2, r2, #1
    9e2a:	6099      	str	r1, [r3, #8]
    9e2c:	604a      	str	r2, [r1, #4]
    9e2e:	f8da 3004 	ldr.w	r3, [sl, #4]
    9e32:	f003 0301 	and.w	r3, r3, #1
    9e36:	431d      	orrs	r5, r3
    9e38:	4648      	mov	r0, r9
    9e3a:	f8ca 5004 	str.w	r5, [sl, #4]
    9e3e:	f7ff feb1 	bl	9ba4 <__malloc_unlock>
    9e42:	4638      	mov	r0, r7
    9e44:	e75c      	b.n	9d00 <_realloc_r+0x148>
    9e46:	6833      	ldr	r3, [r6, #0]
    9e48:	6003      	str	r3, [r0, #0]
    9e4a:	6873      	ldr	r3, [r6, #4]
    9e4c:	6043      	str	r3, [r0, #4]
    9e4e:	2a1b      	cmp	r2, #27
    9e50:	d827      	bhi.n	9ea2 <_realloc_r+0x2ea>
    9e52:	f100 0308 	add.w	r3, r0, #8
    9e56:	f106 0208 	add.w	r2, r6, #8
    9e5a:	e6f2      	b.n	9c42 <_realloc_r+0x8a>
    9e5c:	463b      	mov	r3, r7
    9e5e:	6832      	ldr	r2, [r6, #0]
    9e60:	601a      	str	r2, [r3, #0]
    9e62:	6872      	ldr	r2, [r6, #4]
    9e64:	605a      	str	r2, [r3, #4]
    9e66:	68b2      	ldr	r2, [r6, #8]
    9e68:	609a      	str	r2, [r3, #8]
    9e6a:	463e      	mov	r6, r7
    9e6c:	4674      	mov	r4, lr
    9e6e:	46d0      	mov	r8, sl
    9e70:	e733      	b.n	9cda <_realloc_r+0x122>
    9e72:	eb08 0105 	add.w	r1, r8, r5
    9e76:	ebc5 0b0b 	rsb	fp, r5, fp
    9e7a:	f04b 0201 	orr.w	r2, fp, #1
    9e7e:	6099      	str	r1, [r3, #8]
    9e80:	604a      	str	r2, [r1, #4]
    9e82:	f856 3c04 	ldr.w	r3, [r6, #-4]
    9e86:	f003 0301 	and.w	r3, r3, #1
    9e8a:	431d      	orrs	r5, r3
    9e8c:	4648      	mov	r0, r9
    9e8e:	f846 5c04 	str.w	r5, [r6, #-4]
    9e92:	f7ff fe87 	bl	9ba4 <__malloc_unlock>
    9e96:	4630      	mov	r0, r6
    9e98:	e732      	b.n	9d00 <_realloc_r+0x148>
    9e9a:	4631      	mov	r1, r6
    9e9c:	f7ff fdce 	bl	9a3c <memmove>
    9ea0:	e6d5      	b.n	9c4e <_realloc_r+0x96>
    9ea2:	68b3      	ldr	r3, [r6, #8]
    9ea4:	6083      	str	r3, [r0, #8]
    9ea6:	68f3      	ldr	r3, [r6, #12]
    9ea8:	60c3      	str	r3, [r0, #12]
    9eaa:	2a24      	cmp	r2, #36	; 0x24
    9eac:	d028      	beq.n	9f00 <_realloc_r+0x348>
    9eae:	f100 0310 	add.w	r3, r0, #16
    9eb2:	f106 0210 	add.w	r2, r6, #16
    9eb6:	e6c4      	b.n	9c42 <_realloc_r+0x8a>
    9eb8:	f850 3c04 	ldr.w	r3, [r0, #-4]
    9ebc:	f023 0303 	bic.w	r3, r3, #3
    9ec0:	441c      	add	r4, r3
    9ec2:	e70a      	b.n	9cda <_realloc_r+0x122>
    9ec4:	4631      	mov	r1, r6
    9ec6:	4638      	mov	r0, r7
    9ec8:	4674      	mov	r4, lr
    9eca:	46d0      	mov	r8, sl
    9ecc:	f7ff fdb6 	bl	9a3c <memmove>
    9ed0:	463e      	mov	r6, r7
    9ed2:	e702      	b.n	9cda <_realloc_r+0x122>
    9ed4:	463a      	mov	r2, r7
    9ed6:	e6f7      	b.n	9cc8 <_realloc_r+0x110>
    9ed8:	4631      	mov	r1, r6
    9eda:	4638      	mov	r0, r7
    9edc:	461c      	mov	r4, r3
    9ede:	46d0      	mov	r8, sl
    9ee0:	f7ff fdac 	bl	9a3c <memmove>
    9ee4:	463e      	mov	r6, r7
    9ee6:	e6f8      	b.n	9cda <_realloc_r+0x122>
    9ee8:	68b3      	ldr	r3, [r6, #8]
    9eea:	f8ca 3010 	str.w	r3, [sl, #16]
    9eee:	68f3      	ldr	r3, [r6, #12]
    9ef0:	f8ca 3014 	str.w	r3, [sl, #20]
    9ef4:	2a24      	cmp	r2, #36	; 0x24
    9ef6:	d01b      	beq.n	9f30 <_realloc_r+0x378>
    9ef8:	3610      	adds	r6, #16
    9efa:	f10a 0318 	add.w	r3, sl, #24
    9efe:	e7ae      	b.n	9e5e <_realloc_r+0x2a6>
    9f00:	6933      	ldr	r3, [r6, #16]
    9f02:	6103      	str	r3, [r0, #16]
    9f04:	6973      	ldr	r3, [r6, #20]
    9f06:	6143      	str	r3, [r0, #20]
    9f08:	f106 0218 	add.w	r2, r6, #24
    9f0c:	f100 0318 	add.w	r3, r0, #24
    9f10:	e697      	b.n	9c42 <_realloc_r+0x8a>
    9f12:	bf00      	nop
    9f14:	1fff1014 	.word	0x1fff1014
    9f18:	68b1      	ldr	r1, [r6, #8]
    9f1a:	f8ca 1010 	str.w	r1, [sl, #16]
    9f1e:	68f1      	ldr	r1, [r6, #12]
    9f20:	f8ca 1014 	str.w	r1, [sl, #20]
    9f24:	2a24      	cmp	r2, #36	; 0x24
    9f26:	d00f      	beq.n	9f48 <_realloc_r+0x390>
    9f28:	3610      	adds	r6, #16
    9f2a:	f10a 0218 	add.w	r2, sl, #24
    9f2e:	e6cb      	b.n	9cc8 <_realloc_r+0x110>
    9f30:	6933      	ldr	r3, [r6, #16]
    9f32:	f8ca 3018 	str.w	r3, [sl, #24]
    9f36:	6973      	ldr	r3, [r6, #20]
    9f38:	f8ca 301c 	str.w	r3, [sl, #28]
    9f3c:	3618      	adds	r6, #24
    9f3e:	f10a 0320 	add.w	r3, sl, #32
    9f42:	e78c      	b.n	9e5e <_realloc_r+0x2a6>
    9f44:	463a      	mov	r2, r7
    9f46:	e764      	b.n	9e12 <_realloc_r+0x25a>
    9f48:	6932      	ldr	r2, [r6, #16]
    9f4a:	f8ca 2018 	str.w	r2, [sl, #24]
    9f4e:	6972      	ldr	r2, [r6, #20]
    9f50:	f8ca 201c 	str.w	r2, [sl, #28]
    9f54:	3618      	adds	r6, #24
    9f56:	f10a 0220 	add.w	r2, sl, #32
    9f5a:	e6b5      	b.n	9cc8 <_realloc_r+0x110>
    9f5c:	4631      	mov	r1, r6
    9f5e:	4638      	mov	r0, r7
    9f60:	9301      	str	r3, [sp, #4]
    9f62:	f7ff fd6b 	bl	9a3c <memmove>
    9f66:	9b01      	ldr	r3, [sp, #4]
    9f68:	e759      	b.n	9e1e <_realloc_r+0x266>
    9f6a:	68b1      	ldr	r1, [r6, #8]
    9f6c:	f8ca 1010 	str.w	r1, [sl, #16]
    9f70:	68f1      	ldr	r1, [r6, #12]
    9f72:	f8ca 1014 	str.w	r1, [sl, #20]
    9f76:	2a24      	cmp	r2, #36	; 0x24
    9f78:	d003      	beq.n	9f82 <_realloc_r+0x3ca>
    9f7a:	3610      	adds	r6, #16
    9f7c:	f10a 0218 	add.w	r2, sl, #24
    9f80:	e747      	b.n	9e12 <_realloc_r+0x25a>
    9f82:	6932      	ldr	r2, [r6, #16]
    9f84:	f8ca 2018 	str.w	r2, [sl, #24]
    9f88:	6972      	ldr	r2, [r6, #20]
    9f8a:	f8ca 201c 	str.w	r2, [sl, #28]
    9f8e:	3618      	adds	r6, #24
    9f90:	f10a 0220 	add.w	r2, sl, #32
    9f94:	e73d      	b.n	9e12 <_realloc_r+0x25a>
    9f96:	bf00      	nop

00009f98 <_sbrk_r>:
    9f98:	b538      	push	{r3, r4, r5, lr}
    9f9a:	4c07      	ldr	r4, [pc, #28]	; (9fb8 <_sbrk_r+0x20>)
    9f9c:	2300      	movs	r3, #0
    9f9e:	4605      	mov	r5, r0
    9fa0:	4608      	mov	r0, r1
    9fa2:	6023      	str	r3, [r4, #0]
    9fa4:	f7fb feec 	bl	5d80 <_sbrk>
    9fa8:	1c43      	adds	r3, r0, #1
    9faa:	d000      	beq.n	9fae <_sbrk_r+0x16>
    9fac:	bd38      	pop	{r3, r4, r5, pc}
    9fae:	6823      	ldr	r3, [r4, #0]
    9fb0:	2b00      	cmp	r3, #0
    9fb2:	d0fb      	beq.n	9fac <_sbrk_r+0x14>
    9fb4:	602b      	str	r3, [r5, #0]
    9fb6:	bd38      	pop	{r3, r4, r5, pc}
    9fb8:	1fff2cc4 	.word	0x1fff2cc4
    9fbc:	ffffffff 	.word	0xffffffff
    9fc0:	eba2 0003 	sub.w	r0, r2, r3
    9fc4:	4770      	bx	lr
    9fc6:	bf00      	nop

00009fc8 <strcmp>:
    9fc8:	7802      	ldrb	r2, [r0, #0]
    9fca:	780b      	ldrb	r3, [r1, #0]
    9fcc:	2a01      	cmp	r2, #1
    9fce:	bf28      	it	cs
    9fd0:	429a      	cmpcs	r2, r3
    9fd2:	d1f5      	bne.n	9fc0 <_sbrk_r+0x28>
    9fd4:	e96d 4504 	strd	r4, r5, [sp, #-16]!
    9fd8:	ea40 0401 	orr.w	r4, r0, r1
    9fdc:	e9cd 6702 	strd	r6, r7, [sp, #8]
    9fe0:	f06f 0c00 	mvn.w	ip, #0
    9fe4:	ea4f 7244 	mov.w	r2, r4, lsl #29
    9fe8:	b312      	cbz	r2, a030 <strcmp+0x68>
    9fea:	ea80 0401 	eor.w	r4, r0, r1
    9fee:	f014 0f07 	tst.w	r4, #7
    9ff2:	d16a      	bne.n	a0ca <strcmp+0x102>
    9ff4:	f000 0407 	and.w	r4, r0, #7
    9ff8:	f020 0007 	bic.w	r0, r0, #7
    9ffc:	f004 0503 	and.w	r5, r4, #3
    a000:	f021 0107 	bic.w	r1, r1, #7
    a004:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    a008:	e8f0 2304 	ldrd	r2, r3, [r0], #16
    a00c:	f014 0f04 	tst.w	r4, #4
    a010:	e8f1 6704 	ldrd	r6, r7, [r1], #16
    a014:	fa0c f405 	lsl.w	r4, ip, r5
    a018:	ea62 0204 	orn	r2, r2, r4
    a01c:	ea66 0604 	orn	r6, r6, r4
    a020:	d00a      	beq.n	a038 <strcmp+0x70>
    a022:	ea63 0304 	orn	r3, r3, r4
    a026:	4662      	mov	r2, ip
    a028:	ea67 0704 	orn	r7, r7, r4
    a02c:	4666      	mov	r6, ip
    a02e:	e003      	b.n	a038 <strcmp+0x70>
    a030:	e8f0 2304 	ldrd	r2, r3, [r0], #16
    a034:	e8f1 6704 	ldrd	r6, r7, [r1], #16
    a038:	fa82 f54c 	uadd8	r5, r2, ip
    a03c:	ea82 0406 	eor.w	r4, r2, r6
    a040:	faa4 f48c 	sel	r4, r4, ip
    a044:	bb6c      	cbnz	r4, a0a2 <strcmp+0xda>
    a046:	fa83 f54c 	uadd8	r5, r3, ip
    a04a:	ea83 0507 	eor.w	r5, r3, r7
    a04e:	faa5 f58c 	sel	r5, r5, ip
    a052:	b995      	cbnz	r5, a07a <strcmp+0xb2>
    a054:	e950 2302 	ldrd	r2, r3, [r0, #-8]
    a058:	e951 6702 	ldrd	r6, r7, [r1, #-8]
    a05c:	fa82 f54c 	uadd8	r5, r2, ip
    a060:	ea82 0406 	eor.w	r4, r2, r6
    a064:	faa4 f48c 	sel	r4, r4, ip
    a068:	fa83 f54c 	uadd8	r5, r3, ip
    a06c:	ea83 0507 	eor.w	r5, r3, r7
    a070:	faa5 f58c 	sel	r5, r5, ip
    a074:	4325      	orrs	r5, r4
    a076:	d0db      	beq.n	a030 <strcmp+0x68>
    a078:	b99c      	cbnz	r4, a0a2 <strcmp+0xda>
    a07a:	ba2d      	rev	r5, r5
    a07c:	fab5 f485 	clz	r4, r5
    a080:	f024 0407 	bic.w	r4, r4, #7
    a084:	fa27 f104 	lsr.w	r1, r7, r4
    a088:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    a08c:	fa23 f304 	lsr.w	r3, r3, r4
    a090:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    a094:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    a098:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    a09c:	eba0 0001 	sub.w	r0, r0, r1
    a0a0:	4770      	bx	lr
    a0a2:	ba24      	rev	r4, r4
    a0a4:	fab4 f484 	clz	r4, r4
    a0a8:	f024 0407 	bic.w	r4, r4, #7
    a0ac:	fa26 f104 	lsr.w	r1, r6, r4
    a0b0:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    a0b4:	fa22 f204 	lsr.w	r2, r2, r4
    a0b8:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    a0bc:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    a0c0:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    a0c4:	eba0 0001 	sub.w	r0, r0, r1
    a0c8:	4770      	bx	lr
    a0ca:	f014 0f03 	tst.w	r4, #3
    a0ce:	d13c      	bne.n	a14a <strcmp+0x182>
    a0d0:	f010 0403 	ands.w	r4, r0, #3
    a0d4:	d128      	bne.n	a128 <strcmp+0x160>
    a0d6:	f850 2b08 	ldr.w	r2, [r0], #8
    a0da:	f851 3b08 	ldr.w	r3, [r1], #8
    a0de:	fa82 f54c 	uadd8	r5, r2, ip
    a0e2:	ea82 0503 	eor.w	r5, r2, r3
    a0e6:	faa5 f58c 	sel	r5, r5, ip
    a0ea:	b95d      	cbnz	r5, a104 <strcmp+0x13c>
    a0ec:	f850 2c04 	ldr.w	r2, [r0, #-4]
    a0f0:	f851 3c04 	ldr.w	r3, [r1, #-4]
    a0f4:	fa82 f54c 	uadd8	r5, r2, ip
    a0f8:	ea82 0503 	eor.w	r5, r2, r3
    a0fc:	faa5 f58c 	sel	r5, r5, ip
    a100:	2d00      	cmp	r5, #0
    a102:	d0e8      	beq.n	a0d6 <strcmp+0x10e>
    a104:	ba2d      	rev	r5, r5
    a106:	fab5 f485 	clz	r4, r5
    a10a:	f024 0407 	bic.w	r4, r4, #7
    a10e:	fa23 f104 	lsr.w	r1, r3, r4
    a112:	fa22 f204 	lsr.w	r2, r2, r4
    a116:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    a11a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    a11e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    a122:	eba0 0001 	sub.w	r0, r0, r1
    a126:	4770      	bx	lr
    a128:	ea4f 04c4 	mov.w	r4, r4, lsl #3
    a12c:	f020 0003 	bic.w	r0, r0, #3
    a130:	f850 2b08 	ldr.w	r2, [r0], #8
    a134:	f021 0103 	bic.w	r1, r1, #3
    a138:	f851 3b08 	ldr.w	r3, [r1], #8
    a13c:	fa0c f404 	lsl.w	r4, ip, r4
    a140:	ea62 0204 	orn	r2, r2, r4
    a144:	ea63 0304 	orn	r3, r3, r4
    a148:	e7c9      	b.n	a0de <strcmp+0x116>
    a14a:	f010 0403 	ands.w	r4, r0, #3
    a14e:	d01a      	beq.n	a186 <strcmp+0x1be>
    a150:	eba1 0104 	sub.w	r1, r1, r4
    a154:	f020 0003 	bic.w	r0, r0, #3
    a158:	07e4      	lsls	r4, r4, #31
    a15a:	f850 2b04 	ldr.w	r2, [r0], #4
    a15e:	d006      	beq.n	a16e <strcmp+0x1a6>
    a160:	d20f      	bcs.n	a182 <strcmp+0x1ba>
    a162:	788b      	ldrb	r3, [r1, #2]
    a164:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
    a168:	1ae4      	subs	r4, r4, r3
    a16a:	d106      	bne.n	a17a <strcmp+0x1b2>
    a16c:	b12b      	cbz	r3, a17a <strcmp+0x1b2>
    a16e:	78cb      	ldrb	r3, [r1, #3]
    a170:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
    a174:	1ae4      	subs	r4, r4, r3
    a176:	d100      	bne.n	a17a <strcmp+0x1b2>
    a178:	b91b      	cbnz	r3, a182 <strcmp+0x1ba>
    a17a:	4620      	mov	r0, r4
    a17c:	f85d 4b10 	ldr.w	r4, [sp], #16
    a180:	4770      	bx	lr
    a182:	f101 0104 	add.w	r1, r1, #4
    a186:	f850 2b04 	ldr.w	r2, [r0], #4
    a18a:	07cc      	lsls	r4, r1, #31
    a18c:	f021 0103 	bic.w	r1, r1, #3
    a190:	f851 3b04 	ldr.w	r3, [r1], #4
    a194:	d848      	bhi.n	a228 <strcmp+0x260>
    a196:	d224      	bcs.n	a1e2 <strcmp+0x21a>
    a198:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
    a19c:	fa82 f54c 	uadd8	r5, r2, ip
    a1a0:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
    a1a4:	faa5 f58c 	sel	r5, r5, ip
    a1a8:	d10a      	bne.n	a1c0 <strcmp+0x1f8>
    a1aa:	b965      	cbnz	r5, a1c6 <strcmp+0x1fe>
    a1ac:	f851 3b04 	ldr.w	r3, [r1], #4
    a1b0:	ea84 0402 	eor.w	r4, r4, r2
    a1b4:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
    a1b8:	d10e      	bne.n	a1d8 <strcmp+0x210>
    a1ba:	f850 2b04 	ldr.w	r2, [r0], #4
    a1be:	e7eb      	b.n	a198 <strcmp+0x1d0>
    a1c0:	ea4f 2313 	mov.w	r3, r3, lsr #8
    a1c4:	e055      	b.n	a272 <strcmp+0x2aa>
    a1c6:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
    a1ca:	d14d      	bne.n	a268 <strcmp+0x2a0>
    a1cc:	7808      	ldrb	r0, [r1, #0]
    a1ce:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    a1d2:	f1c0 0000 	rsb	r0, r0, #0
    a1d6:	4770      	bx	lr
    a1d8:	ea4f 6212 	mov.w	r2, r2, lsr #24
    a1dc:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    a1e0:	e047      	b.n	a272 <strcmp+0x2aa>
    a1e2:	ea02 441c 	and.w	r4, r2, ip, lsr #16
    a1e6:	fa82 f54c 	uadd8	r5, r2, ip
    a1ea:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
    a1ee:	faa5 f58c 	sel	r5, r5, ip
    a1f2:	d10a      	bne.n	a20a <strcmp+0x242>
    a1f4:	b965      	cbnz	r5, a210 <strcmp+0x248>
    a1f6:	f851 3b04 	ldr.w	r3, [r1], #4
    a1fa:	ea84 0402 	eor.w	r4, r4, r2
    a1fe:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
    a202:	d10c      	bne.n	a21e <strcmp+0x256>
    a204:	f850 2b04 	ldr.w	r2, [r0], #4
    a208:	e7eb      	b.n	a1e2 <strcmp+0x21a>
    a20a:	ea4f 4313 	mov.w	r3, r3, lsr #16
    a20e:	e030      	b.n	a272 <strcmp+0x2aa>
    a210:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
    a214:	d128      	bne.n	a268 <strcmp+0x2a0>
    a216:	880b      	ldrh	r3, [r1, #0]
    a218:	ea4f 4212 	mov.w	r2, r2, lsr #16
    a21c:	e029      	b.n	a272 <strcmp+0x2aa>
    a21e:	ea4f 4212 	mov.w	r2, r2, lsr #16
    a222:	ea03 431c 	and.w	r3, r3, ip, lsr #16
    a226:	e024      	b.n	a272 <strcmp+0x2aa>
    a228:	f002 04ff 	and.w	r4, r2, #255	; 0xff
    a22c:	fa82 f54c 	uadd8	r5, r2, ip
    a230:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
    a234:	faa5 f58c 	sel	r5, r5, ip
    a238:	d10a      	bne.n	a250 <strcmp+0x288>
    a23a:	b965      	cbnz	r5, a256 <strcmp+0x28e>
    a23c:	f851 3b04 	ldr.w	r3, [r1], #4
    a240:	ea84 0402 	eor.w	r4, r4, r2
    a244:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
    a248:	d109      	bne.n	a25e <strcmp+0x296>
    a24a:	f850 2b04 	ldr.w	r2, [r0], #4
    a24e:	e7eb      	b.n	a228 <strcmp+0x260>
    a250:	ea4f 6313 	mov.w	r3, r3, lsr #24
    a254:	e00d      	b.n	a272 <strcmp+0x2aa>
    a256:	f015 0fff 	tst.w	r5, #255	; 0xff
    a25a:	d105      	bne.n	a268 <strcmp+0x2a0>
    a25c:	680b      	ldr	r3, [r1, #0]
    a25e:	ea4f 2212 	mov.w	r2, r2, lsr #8
    a262:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    a266:	e004      	b.n	a272 <strcmp+0x2aa>
    a268:	f04f 0000 	mov.w	r0, #0
    a26c:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    a270:	4770      	bx	lr
    a272:	ba12      	rev	r2, r2
    a274:	ba1b      	rev	r3, r3
    a276:	fa82 f44c 	uadd8	r4, r2, ip
    a27a:	ea82 0403 	eor.w	r4, r2, r3
    a27e:	faa4 f58c 	sel	r5, r4, ip
    a282:	fab5 f485 	clz	r4, r5
    a286:	fa02 f204 	lsl.w	r2, r2, r4
    a28a:	fa03 f304 	lsl.w	r3, r3, r4
    a28e:	ea4f 6012 	mov.w	r0, r2, lsr #24
    a292:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    a296:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
    a29a:	4770      	bx	lr

0000a29c <strcpy>:
    a29c:	ea80 0201 	eor.w	r2, r0, r1
    a2a0:	4684      	mov	ip, r0
    a2a2:	f012 0f03 	tst.w	r2, #3
    a2a6:	d14f      	bne.n	a348 <strcpy+0xac>
    a2a8:	f011 0f03 	tst.w	r1, #3
    a2ac:	d132      	bne.n	a314 <strcpy+0x78>
    a2ae:	f84d 4d04 	str.w	r4, [sp, #-4]!
    a2b2:	f011 0f04 	tst.w	r1, #4
    a2b6:	f851 3b04 	ldr.w	r3, [r1], #4
    a2ba:	d00b      	beq.n	a2d4 <strcpy+0x38>
    a2bc:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    a2c0:	439a      	bics	r2, r3
    a2c2:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    a2c6:	bf04      	itt	eq
    a2c8:	f84c 3b04 	streq.w	r3, [ip], #4
    a2cc:	f851 3b04 	ldreq.w	r3, [r1], #4
    a2d0:	d116      	bne.n	a300 <strcpy+0x64>
    a2d2:	bf00      	nop
    a2d4:	f851 4b04 	ldr.w	r4, [r1], #4
    a2d8:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    a2dc:	439a      	bics	r2, r3
    a2de:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    a2e2:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
    a2e6:	d10b      	bne.n	a300 <strcpy+0x64>
    a2e8:	f84c 3b04 	str.w	r3, [ip], #4
    a2ec:	43a2      	bics	r2, r4
    a2ee:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    a2f2:	bf04      	itt	eq
    a2f4:	f851 3b04 	ldreq.w	r3, [r1], #4
    a2f8:	f84c 4b04 	streq.w	r4, [ip], #4
    a2fc:	d0ea      	beq.n	a2d4 <strcpy+0x38>
    a2fe:	4623      	mov	r3, r4
    a300:	f80c 3b01 	strb.w	r3, [ip], #1
    a304:	f013 0fff 	tst.w	r3, #255	; 0xff
    a308:	ea4f 2333 	mov.w	r3, r3, ror #8
    a30c:	d1f8      	bne.n	a300 <strcpy+0x64>
    a30e:	f85d 4b04 	ldr.w	r4, [sp], #4
    a312:	4770      	bx	lr
    a314:	f011 0f01 	tst.w	r1, #1
    a318:	d006      	beq.n	a328 <strcpy+0x8c>
    a31a:	f811 2b01 	ldrb.w	r2, [r1], #1
    a31e:	f80c 2b01 	strb.w	r2, [ip], #1
    a322:	2a00      	cmp	r2, #0
    a324:	bf08      	it	eq
    a326:	4770      	bxeq	lr
    a328:	f011 0f02 	tst.w	r1, #2
    a32c:	d0bf      	beq.n	a2ae <strcpy+0x12>
    a32e:	f831 2b02 	ldrh.w	r2, [r1], #2
    a332:	f012 0fff 	tst.w	r2, #255	; 0xff
    a336:	bf16      	itet	ne
    a338:	f82c 2b02 	strhne.w	r2, [ip], #2
    a33c:	f88c 2000 	strbeq.w	r2, [ip]
    a340:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
    a344:	d1b3      	bne.n	a2ae <strcpy+0x12>
    a346:	4770      	bx	lr
    a348:	f811 2b01 	ldrb.w	r2, [r1], #1
    a34c:	f80c 2b01 	strb.w	r2, [ip], #1
    a350:	2a00      	cmp	r2, #0
    a352:	d1f9      	bne.n	a348 <strcpy+0xac>
    a354:	4770      	bx	lr
    a356:	bf00      	nop
    a358:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    a35c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    a360:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    a364:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    a368:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    a36c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    a370:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    a374:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    a378:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    a37c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

0000a380 <strlen>:
    a380:	f890 f000 	pld	[r0]
    a384:	e96d 4502 	strd	r4, r5, [sp, #-8]!
    a388:	f020 0107 	bic.w	r1, r0, #7
    a38c:	f06f 0c00 	mvn.w	ip, #0
    a390:	f010 0407 	ands.w	r4, r0, #7
    a394:	f891 f020 	pld	[r1, #32]
    a398:	f040 8049 	bne.w	a42e <strlen+0xae>
    a39c:	f04f 0400 	mov.w	r4, #0
    a3a0:	f06f 0007 	mvn.w	r0, #7
    a3a4:	e9d1 2300 	ldrd	r2, r3, [r1]
    a3a8:	f891 f040 	pld	[r1, #64]	; 0x40
    a3ac:	f100 0008 	add.w	r0, r0, #8
    a3b0:	fa82 f24c 	uadd8	r2, r2, ip
    a3b4:	faa4 f28c 	sel	r2, r4, ip
    a3b8:	fa83 f34c 	uadd8	r3, r3, ip
    a3bc:	faa2 f38c 	sel	r3, r2, ip
    a3c0:	bb4b      	cbnz	r3, a416 <strlen+0x96>
    a3c2:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
    a3c6:	fa82 f24c 	uadd8	r2, r2, ip
    a3ca:	f100 0008 	add.w	r0, r0, #8
    a3ce:	faa4 f28c 	sel	r2, r4, ip
    a3d2:	fa83 f34c 	uadd8	r3, r3, ip
    a3d6:	faa2 f38c 	sel	r3, r2, ip
    a3da:	b9e3      	cbnz	r3, a416 <strlen+0x96>
    a3dc:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
    a3e0:	fa82 f24c 	uadd8	r2, r2, ip
    a3e4:	f100 0008 	add.w	r0, r0, #8
    a3e8:	faa4 f28c 	sel	r2, r4, ip
    a3ec:	fa83 f34c 	uadd8	r3, r3, ip
    a3f0:	faa2 f38c 	sel	r3, r2, ip
    a3f4:	b97b      	cbnz	r3, a416 <strlen+0x96>
    a3f6:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
    a3fa:	f101 0120 	add.w	r1, r1, #32
    a3fe:	fa82 f24c 	uadd8	r2, r2, ip
    a402:	f100 0008 	add.w	r0, r0, #8
    a406:	faa4 f28c 	sel	r2, r4, ip
    a40a:	fa83 f34c 	uadd8	r3, r3, ip
    a40e:	faa2 f38c 	sel	r3, r2, ip
    a412:	2b00      	cmp	r3, #0
    a414:	d0c6      	beq.n	a3a4 <strlen+0x24>
    a416:	2a00      	cmp	r2, #0
    a418:	bf04      	itt	eq
    a41a:	3004      	addeq	r0, #4
    a41c:	461a      	moveq	r2, r3
    a41e:	ba12      	rev	r2, r2
    a420:	fab2 f282 	clz	r2, r2
    a424:	e8fd 4502 	ldrd	r4, r5, [sp], #8
    a428:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
    a42c:	4770      	bx	lr
    a42e:	e9d1 2300 	ldrd	r2, r3, [r1]
    a432:	f004 0503 	and.w	r5, r4, #3
    a436:	f1c4 0000 	rsb	r0, r4, #0
    a43a:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    a43e:	f014 0f04 	tst.w	r4, #4
    a442:	f891 f040 	pld	[r1, #64]	; 0x40
    a446:	fa0c f505 	lsl.w	r5, ip, r5
    a44a:	ea62 0205 	orn	r2, r2, r5
    a44e:	bf1c      	itt	ne
    a450:	ea63 0305 	ornne	r3, r3, r5
    a454:	4662      	movne	r2, ip
    a456:	f04f 0400 	mov.w	r4, #0
    a45a:	e7a9      	b.n	a3b0 <strlen+0x30>

0000a45c <register_fini>:
    a45c:	4b02      	ldr	r3, [pc, #8]	; (a468 <register_fini+0xc>)
    a45e:	b113      	cbz	r3, a466 <register_fini+0xa>
    a460:	4802      	ldr	r0, [pc, #8]	; (a46c <register_fini+0x10>)
    a462:	f000 b805 	b.w	a470 <atexit>
    a466:	4770      	bx	lr
    a468:	00000000 	.word	0x00000000
    a46c:	0000a47d 	.word	0x0000a47d

0000a470 <atexit>:
    a470:	2300      	movs	r3, #0
    a472:	4601      	mov	r1, r0
    a474:	461a      	mov	r2, r3
    a476:	4618      	mov	r0, r3
    a478:	f000 b94a 	b.w	a710 <__register_exitproc>

0000a47c <__libc_fini_array>:
    a47c:	b538      	push	{r3, r4, r5, lr}
    a47e:	4d07      	ldr	r5, [pc, #28]	; (a49c <__libc_fini_array+0x20>)
    a480:	4c07      	ldr	r4, [pc, #28]	; (a4a0 <__libc_fini_array+0x24>)
    a482:	1b2c      	subs	r4, r5, r4
    a484:	10a4      	asrs	r4, r4, #2
    a486:	d005      	beq.n	a494 <__libc_fini_array+0x18>
    a488:	3c01      	subs	r4, #1
    a48a:	f855 3d04 	ldr.w	r3, [r5, #-4]!
    a48e:	4798      	blx	r3
    a490:	2c00      	cmp	r4, #0
    a492:	d1f9      	bne.n	a488 <__libc_fini_array+0xc>
    a494:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    a498:	f000 bd68 	b.w	af6c <__init_array_end>
	...

0000a4a4 <_malloc_trim_r>:
    a4a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a4a6:	4f23      	ldr	r7, [pc, #140]	; (a534 <_malloc_trim_r+0x90>)
    a4a8:	460c      	mov	r4, r1
    a4aa:	4606      	mov	r6, r0
    a4ac:	f7ff fb78 	bl	9ba0 <__malloc_lock>
    a4b0:	68bb      	ldr	r3, [r7, #8]
    a4b2:	685d      	ldr	r5, [r3, #4]
    a4b4:	f025 0503 	bic.w	r5, r5, #3
    a4b8:	1b29      	subs	r1, r5, r4
    a4ba:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
    a4be:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
    a4c2:	f021 010f 	bic.w	r1, r1, #15
    a4c6:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
    a4ca:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    a4ce:	db07      	blt.n	a4e0 <_malloc_trim_r+0x3c>
    a4d0:	2100      	movs	r1, #0
    a4d2:	4630      	mov	r0, r6
    a4d4:	f7ff fd60 	bl	9f98 <_sbrk_r>
    a4d8:	68bb      	ldr	r3, [r7, #8]
    a4da:	442b      	add	r3, r5
    a4dc:	4298      	cmp	r0, r3
    a4de:	d004      	beq.n	a4ea <_malloc_trim_r+0x46>
    a4e0:	4630      	mov	r0, r6
    a4e2:	f7ff fb5f 	bl	9ba4 <__malloc_unlock>
    a4e6:	2000      	movs	r0, #0
    a4e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a4ea:	4261      	negs	r1, r4
    a4ec:	4630      	mov	r0, r6
    a4ee:	f7ff fd53 	bl	9f98 <_sbrk_r>
    a4f2:	3001      	adds	r0, #1
    a4f4:	d00d      	beq.n	a512 <_malloc_trim_r+0x6e>
    a4f6:	4b10      	ldr	r3, [pc, #64]	; (a538 <_malloc_trim_r+0x94>)
    a4f8:	68ba      	ldr	r2, [r7, #8]
    a4fa:	6819      	ldr	r1, [r3, #0]
    a4fc:	1b2d      	subs	r5, r5, r4
    a4fe:	f045 0501 	orr.w	r5, r5, #1
    a502:	4630      	mov	r0, r6
    a504:	1b09      	subs	r1, r1, r4
    a506:	6055      	str	r5, [r2, #4]
    a508:	6019      	str	r1, [r3, #0]
    a50a:	f7ff fb4b 	bl	9ba4 <__malloc_unlock>
    a50e:	2001      	movs	r0, #1
    a510:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a512:	2100      	movs	r1, #0
    a514:	4630      	mov	r0, r6
    a516:	f7ff fd3f 	bl	9f98 <_sbrk_r>
    a51a:	68ba      	ldr	r2, [r7, #8]
    a51c:	1a83      	subs	r3, r0, r2
    a51e:	2b0f      	cmp	r3, #15
    a520:	ddde      	ble.n	a4e0 <_malloc_trim_r+0x3c>
    a522:	4c06      	ldr	r4, [pc, #24]	; (a53c <_malloc_trim_r+0x98>)
    a524:	4904      	ldr	r1, [pc, #16]	; (a538 <_malloc_trim_r+0x94>)
    a526:	6824      	ldr	r4, [r4, #0]
    a528:	f043 0301 	orr.w	r3, r3, #1
    a52c:	1b00      	subs	r0, r0, r4
    a52e:	6053      	str	r3, [r2, #4]
    a530:	6008      	str	r0, [r1, #0]
    a532:	e7d5      	b.n	a4e0 <_malloc_trim_r+0x3c>
    a534:	1fff1014 	.word	0x1fff1014
    a538:	1fff2c88 	.word	0x1fff2c88
    a53c:	1fff1420 	.word	0x1fff1420

0000a540 <_free_r>:
    a540:	2900      	cmp	r1, #0
    a542:	d045      	beq.n	a5d0 <_free_r+0x90>
    a544:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a548:	460d      	mov	r5, r1
    a54a:	4680      	mov	r8, r0
    a54c:	f7ff fb28 	bl	9ba0 <__malloc_lock>
    a550:	f855 7c04 	ldr.w	r7, [r5, #-4]
    a554:	496a      	ldr	r1, [pc, #424]	; (a700 <_free_r+0x1c0>)
    a556:	f027 0301 	bic.w	r3, r7, #1
    a55a:	f1a5 0408 	sub.w	r4, r5, #8
    a55e:	18e2      	adds	r2, r4, r3
    a560:	688e      	ldr	r6, [r1, #8]
    a562:	6850      	ldr	r0, [r2, #4]
    a564:	42b2      	cmp	r2, r6
    a566:	f020 0003 	bic.w	r0, r0, #3
    a56a:	d062      	beq.n	a632 <_free_r+0xf2>
    a56c:	07fe      	lsls	r6, r7, #31
    a56e:	6050      	str	r0, [r2, #4]
    a570:	d40b      	bmi.n	a58a <_free_r+0x4a>
    a572:	f855 7c08 	ldr.w	r7, [r5, #-8]
    a576:	1be4      	subs	r4, r4, r7
    a578:	f101 0e08 	add.w	lr, r1, #8
    a57c:	68a5      	ldr	r5, [r4, #8]
    a57e:	4575      	cmp	r5, lr
    a580:	443b      	add	r3, r7
    a582:	d06f      	beq.n	a664 <_free_r+0x124>
    a584:	68e7      	ldr	r7, [r4, #12]
    a586:	60ef      	str	r7, [r5, #12]
    a588:	60bd      	str	r5, [r7, #8]
    a58a:	1815      	adds	r5, r2, r0
    a58c:	686d      	ldr	r5, [r5, #4]
    a58e:	07ed      	lsls	r5, r5, #31
    a590:	d542      	bpl.n	a618 <_free_r+0xd8>
    a592:	f043 0201 	orr.w	r2, r3, #1
    a596:	6062      	str	r2, [r4, #4]
    a598:	50e3      	str	r3, [r4, r3]
    a59a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    a59e:	d218      	bcs.n	a5d2 <_free_r+0x92>
    a5a0:	08db      	lsrs	r3, r3, #3
    a5a2:	1c5a      	adds	r2, r3, #1
    a5a4:	684d      	ldr	r5, [r1, #4]
    a5a6:	f851 7032 	ldr.w	r7, [r1, r2, lsl #3]
    a5aa:	60a7      	str	r7, [r4, #8]
    a5ac:	2001      	movs	r0, #1
    a5ae:	109b      	asrs	r3, r3, #2
    a5b0:	fa00 f303 	lsl.w	r3, r0, r3
    a5b4:	eb01 00c2 	add.w	r0, r1, r2, lsl #3
    a5b8:	431d      	orrs	r5, r3
    a5ba:	3808      	subs	r0, #8
    a5bc:	60e0      	str	r0, [r4, #12]
    a5be:	604d      	str	r5, [r1, #4]
    a5c0:	f841 4032 	str.w	r4, [r1, r2, lsl #3]
    a5c4:	60fc      	str	r4, [r7, #12]
    a5c6:	4640      	mov	r0, r8
    a5c8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    a5cc:	f7ff baea 	b.w	9ba4 <__malloc_unlock>
    a5d0:	4770      	bx	lr
    a5d2:	0a5a      	lsrs	r2, r3, #9
    a5d4:	2a04      	cmp	r2, #4
    a5d6:	d853      	bhi.n	a680 <_free_r+0x140>
    a5d8:	099a      	lsrs	r2, r3, #6
    a5da:	f102 0739 	add.w	r7, r2, #57	; 0x39
    a5de:	007f      	lsls	r7, r7, #1
    a5e0:	f102 0538 	add.w	r5, r2, #56	; 0x38
    a5e4:	eb01 0087 	add.w	r0, r1, r7, lsl #2
    a5e8:	f851 2027 	ldr.w	r2, [r1, r7, lsl #2]
    a5ec:	4944      	ldr	r1, [pc, #272]	; (a700 <_free_r+0x1c0>)
    a5ee:	3808      	subs	r0, #8
    a5f0:	4290      	cmp	r0, r2
    a5f2:	d04d      	beq.n	a690 <_free_r+0x150>
    a5f4:	6851      	ldr	r1, [r2, #4]
    a5f6:	f021 0103 	bic.w	r1, r1, #3
    a5fa:	428b      	cmp	r3, r1
    a5fc:	d202      	bcs.n	a604 <_free_r+0xc4>
    a5fe:	6892      	ldr	r2, [r2, #8]
    a600:	4290      	cmp	r0, r2
    a602:	d1f7      	bne.n	a5f4 <_free_r+0xb4>
    a604:	68d0      	ldr	r0, [r2, #12]
    a606:	60e0      	str	r0, [r4, #12]
    a608:	60a2      	str	r2, [r4, #8]
    a60a:	6084      	str	r4, [r0, #8]
    a60c:	60d4      	str	r4, [r2, #12]
    a60e:	4640      	mov	r0, r8
    a610:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    a614:	f7ff bac6 	b.w	9ba4 <__malloc_unlock>
    a618:	6895      	ldr	r5, [r2, #8]
    a61a:	4f3a      	ldr	r7, [pc, #232]	; (a704 <_free_r+0x1c4>)
    a61c:	42bd      	cmp	r5, r7
    a61e:	4403      	add	r3, r0
    a620:	d03f      	beq.n	a6a2 <_free_r+0x162>
    a622:	68d0      	ldr	r0, [r2, #12]
    a624:	60e8      	str	r0, [r5, #12]
    a626:	f043 0201 	orr.w	r2, r3, #1
    a62a:	6085      	str	r5, [r0, #8]
    a62c:	6062      	str	r2, [r4, #4]
    a62e:	50e3      	str	r3, [r4, r3]
    a630:	e7b3      	b.n	a59a <_free_r+0x5a>
    a632:	07ff      	lsls	r7, r7, #31
    a634:	4403      	add	r3, r0
    a636:	d407      	bmi.n	a648 <_free_r+0x108>
    a638:	f855 2c08 	ldr.w	r2, [r5, #-8]
    a63c:	1aa4      	subs	r4, r4, r2
    a63e:	4413      	add	r3, r2
    a640:	68a0      	ldr	r0, [r4, #8]
    a642:	68e2      	ldr	r2, [r4, #12]
    a644:	60c2      	str	r2, [r0, #12]
    a646:	6090      	str	r0, [r2, #8]
    a648:	4a2f      	ldr	r2, [pc, #188]	; (a708 <_free_r+0x1c8>)
    a64a:	6812      	ldr	r2, [r2, #0]
    a64c:	f043 0001 	orr.w	r0, r3, #1
    a650:	4293      	cmp	r3, r2
    a652:	6060      	str	r0, [r4, #4]
    a654:	608c      	str	r4, [r1, #8]
    a656:	d3b6      	bcc.n	a5c6 <_free_r+0x86>
    a658:	4b2c      	ldr	r3, [pc, #176]	; (a70c <_free_r+0x1cc>)
    a65a:	4640      	mov	r0, r8
    a65c:	6819      	ldr	r1, [r3, #0]
    a65e:	f7ff ff21 	bl	a4a4 <_malloc_trim_r>
    a662:	e7b0      	b.n	a5c6 <_free_r+0x86>
    a664:	1811      	adds	r1, r2, r0
    a666:	6849      	ldr	r1, [r1, #4]
    a668:	07c9      	lsls	r1, r1, #31
    a66a:	d444      	bmi.n	a6f6 <_free_r+0x1b6>
    a66c:	6891      	ldr	r1, [r2, #8]
    a66e:	68d2      	ldr	r2, [r2, #12]
    a670:	60ca      	str	r2, [r1, #12]
    a672:	4403      	add	r3, r0
    a674:	f043 0001 	orr.w	r0, r3, #1
    a678:	6091      	str	r1, [r2, #8]
    a67a:	6060      	str	r0, [r4, #4]
    a67c:	50e3      	str	r3, [r4, r3]
    a67e:	e7a2      	b.n	a5c6 <_free_r+0x86>
    a680:	2a14      	cmp	r2, #20
    a682:	d817      	bhi.n	a6b4 <_free_r+0x174>
    a684:	f102 075c 	add.w	r7, r2, #92	; 0x5c
    a688:	007f      	lsls	r7, r7, #1
    a68a:	f102 055b 	add.w	r5, r2, #91	; 0x5b
    a68e:	e7a9      	b.n	a5e4 <_free_r+0xa4>
    a690:	10aa      	asrs	r2, r5, #2
    a692:	684b      	ldr	r3, [r1, #4]
    a694:	2501      	movs	r5, #1
    a696:	fa05 f202 	lsl.w	r2, r5, r2
    a69a:	4313      	orrs	r3, r2
    a69c:	604b      	str	r3, [r1, #4]
    a69e:	4602      	mov	r2, r0
    a6a0:	e7b1      	b.n	a606 <_free_r+0xc6>
    a6a2:	f043 0201 	orr.w	r2, r3, #1
    a6a6:	614c      	str	r4, [r1, #20]
    a6a8:	610c      	str	r4, [r1, #16]
    a6aa:	60e5      	str	r5, [r4, #12]
    a6ac:	60a5      	str	r5, [r4, #8]
    a6ae:	6062      	str	r2, [r4, #4]
    a6b0:	50e3      	str	r3, [r4, r3]
    a6b2:	e788      	b.n	a5c6 <_free_r+0x86>
    a6b4:	2a54      	cmp	r2, #84	; 0x54
    a6b6:	d806      	bhi.n	a6c6 <_free_r+0x186>
    a6b8:	0b1a      	lsrs	r2, r3, #12
    a6ba:	f102 076f 	add.w	r7, r2, #111	; 0x6f
    a6be:	007f      	lsls	r7, r7, #1
    a6c0:	f102 056e 	add.w	r5, r2, #110	; 0x6e
    a6c4:	e78e      	b.n	a5e4 <_free_r+0xa4>
    a6c6:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    a6ca:	d806      	bhi.n	a6da <_free_r+0x19a>
    a6cc:	0bda      	lsrs	r2, r3, #15
    a6ce:	f102 0778 	add.w	r7, r2, #120	; 0x78
    a6d2:	007f      	lsls	r7, r7, #1
    a6d4:	f102 0577 	add.w	r5, r2, #119	; 0x77
    a6d8:	e784      	b.n	a5e4 <_free_r+0xa4>
    a6da:	f240 5054 	movw	r0, #1364	; 0x554
    a6de:	4282      	cmp	r2, r0
    a6e0:	d806      	bhi.n	a6f0 <_free_r+0x1b0>
    a6e2:	0c9a      	lsrs	r2, r3, #18
    a6e4:	f102 077d 	add.w	r7, r2, #125	; 0x7d
    a6e8:	007f      	lsls	r7, r7, #1
    a6ea:	f102 057c 	add.w	r5, r2, #124	; 0x7c
    a6ee:	e779      	b.n	a5e4 <_free_r+0xa4>
    a6f0:	27fe      	movs	r7, #254	; 0xfe
    a6f2:	257e      	movs	r5, #126	; 0x7e
    a6f4:	e776      	b.n	a5e4 <_free_r+0xa4>
    a6f6:	f043 0201 	orr.w	r2, r3, #1
    a6fa:	6062      	str	r2, [r4, #4]
    a6fc:	50e3      	str	r3, [r4, r3]
    a6fe:	e762      	b.n	a5c6 <_free_r+0x86>
    a700:	1fff1014 	.word	0x1fff1014
    a704:	1fff101c 	.word	0x1fff101c
    a708:	1fff141c 	.word	0x1fff141c
    a70c:	1fff2c84 	.word	0x1fff2c84

0000a710 <__register_exitproc>:
    a710:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    a714:	4c25      	ldr	r4, [pc, #148]	; (a7ac <__register_exitproc+0x9c>)
    a716:	6825      	ldr	r5, [r4, #0]
    a718:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
    a71c:	4606      	mov	r6, r0
    a71e:	4688      	mov	r8, r1
    a720:	4692      	mov	sl, r2
    a722:	4699      	mov	r9, r3
    a724:	b3c4      	cbz	r4, a798 <__register_exitproc+0x88>
    a726:	6860      	ldr	r0, [r4, #4]
    a728:	281f      	cmp	r0, #31
    a72a:	dc17      	bgt.n	a75c <__register_exitproc+0x4c>
    a72c:	1c43      	adds	r3, r0, #1
    a72e:	b176      	cbz	r6, a74e <__register_exitproc+0x3e>
    a730:	eb04 0580 	add.w	r5, r4, r0, lsl #2
    a734:	2201      	movs	r2, #1
    a736:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
    a73a:	f8d4 1188 	ldr.w	r1, [r4, #392]	; 0x188
    a73e:	4082      	lsls	r2, r0
    a740:	4311      	orrs	r1, r2
    a742:	2e02      	cmp	r6, #2
    a744:	f8c4 1188 	str.w	r1, [r4, #392]	; 0x188
    a748:	f8c5 9108 	str.w	r9, [r5, #264]	; 0x108
    a74c:	d01e      	beq.n	a78c <__register_exitproc+0x7c>
    a74e:	3002      	adds	r0, #2
    a750:	6063      	str	r3, [r4, #4]
    a752:	f844 8020 	str.w	r8, [r4, r0, lsl #2]
    a756:	2000      	movs	r0, #0
    a758:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a75c:	4b14      	ldr	r3, [pc, #80]	; (a7b0 <__register_exitproc+0xa0>)
    a75e:	b303      	cbz	r3, a7a2 <__register_exitproc+0x92>
    a760:	f44f 70c8 	mov.w	r0, #400	; 0x190
    a764:	f7fe fea2 	bl	94ac <malloc>
    a768:	4604      	mov	r4, r0
    a76a:	b1d0      	cbz	r0, a7a2 <__register_exitproc+0x92>
    a76c:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
    a770:	2700      	movs	r7, #0
    a772:	e880 0088 	stmia.w	r0, {r3, r7}
    a776:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    a77a:	4638      	mov	r0, r7
    a77c:	2301      	movs	r3, #1
    a77e:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
    a782:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
    a786:	2e00      	cmp	r6, #0
    a788:	d0e1      	beq.n	a74e <__register_exitproc+0x3e>
    a78a:	e7d1      	b.n	a730 <__register_exitproc+0x20>
    a78c:	f8d4 118c 	ldr.w	r1, [r4, #396]	; 0x18c
    a790:	430a      	orrs	r2, r1
    a792:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
    a796:	e7da      	b.n	a74e <__register_exitproc+0x3e>
    a798:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
    a79c:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    a7a0:	e7c1      	b.n	a726 <__register_exitproc+0x16>
    a7a2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a7a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a7aa:	bf00      	nop
    a7ac:	0000af50 	.word	0x0000af50
    a7b0:	000094ad 	.word	0x000094ad

0000a7b4 <vtable for std_msgs::Time>:
	...
    a7bc:	0000046d 00000495 000004d1 000004d9     m...............

0000a7cc <vtable for rosserial_msgs::TopicInfo>:
	...
    a7d4:	00000bb1 000004e1 000005c9 000005d1     ................

0000a7e4 <vtable for rosserial_msgs::Log>:
	...
    a7ec:	00000b7d 000005d9 00000621 00000629     }.......!...)...

0000a7fc <vtable for rosserial_msgs::RequestParamResponse>:
	...
    a804:	00000a35 00000c55 00000631 00000639     5...U...1...9...

0000a814 <vtable for std_msgs::Int16>:
	...
    a81c:	00000641 00000651 00000661 00000669     A...Q...a...i...

0000a82c <vtable for std_msgs::Float32>:
	...
    a834:	00000671 0000068d 000006ad 000006b5     q...............

0000a844 <vtable for geometry_msgs::Vector3>:
	...
    a84c:	000012c5 000020d9 000006bd 000006c5     ..... ..........

0000a85c <vtable for geometry_msgs::Quaternion>:
	...
    a864:	000014f1 000022d5 000006cd 000006d5     ....."..........

0000a874 <vtable for geometry_msgs::Twist>:
	...
    a87c:	00000e3d 00001cd1 000006dd 000006e5     =...............

0000a88c <vtable for ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>>:
	...
    a894:	0000257d 00004895 0000072d              }%...H..-...

0000a8a0 <vtable for ros::Subscriber<geometry_msgs::Twist, void>>:
	...
    a8a8:	000018ad 00000719 0000071d 00000725     ............%...

0000a8b8 <vtable for ros::Subscriber<std_msgs::Int16, void>>:
	...
    a8c0:	000006ed 00000705 00000709 00000711     ................

0000a8d0 <rosserial_msgs::REQUESTPARAM>:
    a8d0:	73736f72 61697265 736d5f6c 522f7367     rosserial_msgs/R
    a8e0:	65757165 61507473 006d6172 5f647473     equestParam.std_
    a8f0:	7367736d 6d69542f 00000065 31376463     msgs/Time...cd71
    a900:	37633636 35356334 31336332 63626631     66c74c552c311fbc
    a910:	65663263 62376135 39383263 00000000     c2fe5a7bc289....
    a920:	73736f72 61697265 736d5f6c 542f7367     rosserial_msgs/T
    a930:	6369706f 6f666e49 00000000 35646130     opicInfo....0ad5
    a940:	38386631 34346366 66323938 30316338     1f88fc44892f8c10
    a950:	30343836 34363737 35303036 00000000     684077646005....
    a960:	73736f72 61697265 736d5f6c 4c2f7367     rosserial_msgs/L
    a970:	0000676f 62613131 31333764 39353263     og..11abd731c259
    a980:	36323333 36646331 62333831 64323164     33261cd6183bd12d
    a990:	35393236 00000000 65306639 64623839     6295....9f0e98bd
    a9a0:	39353661 38393138 66646436 66613335     a65981986ddf53af
    a9b0:	34613761 39346530 00000000 5f647473     a7a40e49....std_
    a9c0:	7367736d 746e492f 00003631 34323538     msgs/Int16..8524
    a9d0:	65363835 62663433 62633764 38306331     586e34fbd7cb1c08
    a9e0:	35663563 61633166 37356530 00000000     c5f5f1ca0e57....
    a9f0:	5f647473 7367736d 6f6c462f 32337461     std_msgs/Float32
    aa00:	00000000 63663337 36346662 31393462     ....73fcbf46b491
    aa10:	36653139 30393237 30356538 61323438     91e672908e50842a
    aa20:	34643338 00000000 6d6f6567 79727465     83d4....geometry
    aa30:	67736d5f 65562f73 726f7463 00000033     _msgs/Vector3...
    aa40:	34386134 35366232 33313466 64343830     4a842b65f413084d
    aa50:	31623263 34626630 61653438 37316637     c2b10fb484ea7f17
    aa60:	00000000 6d6f6567 79727465 67736d5f     ....geometry_msg
    aa70:	75512f73 72657461 6e6f696e 00000000     s/Quaternion....
    aa80:	39373761 66393738 30666461 37303631     a779879fadf01607
    aa90:	39663433 38623630 63393163 34303037     34f906b8c19c7004
    aaa0:	00000000 6d6f6567 79727465 67736d5f     ....geometry_msg
    aab0:	77542f73 00747369 39316639 38386635     s/Twist.9f195f88
    aac0:	36343231 61666466 38393732 33643164     1246fdfa2798d1d3
    aad0:	63626565 61343861 00000000 7373654d     eebca84a....Mess
    aae0:	20656761 6d6f7266 76656420 20656369     age from device 
    aaf0:	706f7264 3a646570 73656d20 65676173     dropped: message
    ab00:	72616c20 20726567 6e616874 66756220      larger than buf
    ab10:	2e726566 00000000 00646572 00646552     fer.....red.Red.
    ab20:	00444552 65657267 0000006e 65657247     RED.green...Gree
    ab30:	0000006e 45455247 0000004e 65756c62     n...GREEN...blue
    ab40:	00000000 65756c42 00000000 45554c42     ....Blue....BLUE
    ab50:	00000000 6e617963 00000000 6e617943     ....cyan....Cyan
    ab60:	00000000 4e415943 00000000 70727570     ....CYAN....purp
    ab70:	0000656c 70727550 0000656c 50525550     le..Purple..PURP
    ab80:	0000454c 6e61726f 00006567 6e61724f     LE..orange..Oran
    ab90:	00006567 4e41524f 00004547 74696877     ge..ORANGE..whit
    aba0:	00002065 74696857 00000065 54494857     e ..White...WHIT
    abb0:	00000045 74696877 00000065 68676972     E...white...righ
    abc0:	69745f74 00006b63 7466656c 6369745f     t_tick..left_tic
    abd0:	0000006b 65656877 6e615f6c 00656c67     k...wheel_angle.
    abe0:	65657073 6e615f64 69745f64 00006b63     speed_and_tick..
    abf0:	5f756d69 00636361 5f756d69 6f727967     imu_acc.imu_gyro
    ac00:	00000000 5f756d69 0067616d 7361656d     ....imu_mag.meas
    ac10:	64657275 676e615f 0000656c 5f646d63     ured_angle..cmd_
    ac20:	006c6576 74617473 5f70755f 656e6f64     vel.stat_up_done
    ac30:	ffffff00                                ....

0000ac34 <TwoWire::i2c0_hardware>:
    ac34:	40048034 00000040 08221112 05020230     4..@@.....".0...
    ac44:	10130207 022f0721 02070502 00000018     ....!./.........

0000ac54 <TwoWire::i2c1_hardware>:
    ac54:	40048034 00000080 ffff3a26 000602ff     4..@....&:......
    ac64:	3b250000 02ffffff 00000006 00000019     ..%;............

0000ac74 <TwoWire::i2c2_hardware>:
    ac74:	40048028 00000040 ffffff04 000005ff     (..@@...........
    ac84:	1a030000 05ffffff 00000005 0000004a     ............J...

0000ac94 <vtable for TwoWire>:
	...
    ac9c:	000054c9 0000548d 0000546d 00005489     .T...T..mT...T..
    acac:	000051c9 000051d5 00005471              .Q...Q..qT..

0000acb8 <digital_pin_to_info_PGM>:
    acb8:	43fe0840 4004a040 43fe0844 4004a044     @..C@..@D..CD..@
    acc8:	43fe1800 4004c000 43fe0030 40049030     ...C...@0..C0..@
    acd8:	43fe0034 40049034 43fe181c 4004c01c     4..C4..@...C...@
    ace8:	43fe1810 4004c010 43fe1808 4004c008     ...C...@...C...@
    acf8:	43fe180c 4004c00c 43fe100c 4004b00c     ...C...@...C...@
    ad08:	43fe1010 4004b010 43fe1018 4004b018     ...C...@...C...@
    ad18:	43fe101c 4004b01c 43fe1014 4004b014     ...C...@...C...@
    ad28:	43fe1804 4004c004 43fe1000 4004b000     ...C...@...C...@
    ad38:	43fe0800 4004a000 43fe0804 4004a004     ...C...@...C...@
    ad48:	43fe080c 4004a00c 43fe0808 4004a008     ...C...@...C...@
    ad58:	43fe1814 4004c014 43fe1818 4004c018     ...C...@...C...@
    ad68:	43fe1004 4004b004 43fe1008 4004b008     ...C...@...C...@
    ad78:	43fe2068 4004d068 43fe0014 40049014     h .Ch..@...C...@
    ad88:	43fe0038 40049038 43fe003c 4004903c     8..C8..@<..C<..@
    ad98:	43fe0040 40049040 43fe0848 4004a048     @..C@..@H..CH..@
    ada8:	43fe084c 4004a04c 43fe0828 4004a028     L..CL..@(..C(..@
    adb8:	43fe082c 4004a02c 43fe2060 4004d060     ,..C,..@` .C`..@
    adc8:	43fe2064 4004d064 43fe1020 4004b020     d .Cd..@ ..C ..@
    add8:	43fe1024 4004b024 43fe1028 4004b028     $..C$..@(..C(..@
    ade8:	43fe102c 4004b02c 43fe0044 40049044     ,..C,..@D..CD..@
    adf8:	43fe0070 40049070 43fe0074 40049074     p..Cp..@t..Ct..@
    ae08:	43fe0068 40049068 43fe0850 4004a050     h..Ch..@P..CP..@
    ae18:	43fe0858 4004a058 43fe085c 4004a05c     X..CX..@\..C\..@
    ae28:	43fe0854 4004a054 43fe1820 4004c020     T..CT..@ ..C ..@
    ae38:	43fe1824 4004c024 43fe0810 4004a010     $..C$..@...C...@
    ae48:	43fe0814 4004a014 43fe1838 4004c038     ...C...@8..C8..@
    ae58:	43fe1834 4004c034 43fe1830 4004c030     4..C4..@0..C0..@
    ae68:	43fe183c 4004c03c 43fe182c 4004c02c     <..C<..@,..C,..@
    ae78:	43fe2028 4004d028 43fe202c 4004d02c     ( .C(..@, .C,..@
    ae88:	43fe2000 4004d000 43fe2004 4004d004     . .C...@. .C...@
    ae98:	43fe2008 4004d008 43fe200c 4004d00c     . .C...@. .C...@
    aea8:	43fe2010 4004d010 43fe2014 4004d014     . .C...@. .C...@

0000aeb8 <vtable for usb_serial_class>:
	...
    aec0:	00007501 00000c49 000074fd 000074f9     .u..I....t...t..
    aed0:	000074f5 00000c51 000074f1 000074ed     .t..Q....t...t..

0000aee0 <usb_endpoint_config_table>:
    aee0:	15191500                                ....

0000aee4 <usb_descriptor_list>:
    aee4:	00000100 1fff0b40 00000012 00000200     ....@...........
    aef4:	1fff0b6c 00000043 00000300 1fff0bc8     l...C...........
    af04:	00000000 04090301 1fff0b54 00000000     ........T.......
    af14:	04090302 1fff0bb0 00000000 04090303     ................
    af24:	1fff0bcc 00000000 00000000 00000000     ................
    af34:	00000000 00776f70 ffffffff              ....pow.....

0000af40 <TWO52>:
    af40:	00000000 43300000 00000000 c3300000     ......0C......0.

0000af50 <_global_impure_ptr>:
    af50:	1fff0be8                                ....

0000af54 <_init>:
    af54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    af56:	bf00      	nop
    af58:	bcf8      	pop	{r3, r4, r5, r6, r7}
    af5a:	bc08      	pop	{r3}
    af5c:	469e      	mov	lr, r3
    af5e:	4770      	bx	lr

0000af60 <__init_array_start>:
    af60:	0000a45d 	.word	0x0000a45d

0000af64 <__frame_dummy_init_array_entry>:
    af64:	00000435 00004f71                       5...qO..

Disassembly of section .fini:

0000af6c <_fini>:
    af6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    af6e:	bf00      	nop

Disassembly of section .data:

1fff0730 <port_E_isr>:
#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
PORT_ISR_FUNCTION_CLZ(C)
PORT_ISR_FUNCTION_CLZ(D)
PORT_ISR_FUNCTION_CLZ(E)
1fff0730:	b538      	push	{r3, r4, r5, lr}
1fff0732:	4b08      	ldr	r3, [pc, #32]	; (1fff0754 <port_E_isr+0x24>)
1fff0734:	681c      	ldr	r4, [r3, #0]
1fff0736:	601c      	str	r4, [r3, #0]
1fff0738:	b154      	cbz	r4, 1fff0750 <port_E_isr+0x20>
1fff073a:	4d07      	ldr	r5, [pc, #28]	; (1fff0758 <port_E_isr+0x28>)
1fff073c:	fa94 f3a4 	rbit	r3, r4
1fff0740:	fab3 f383 	clz	r3, r3
1fff0744:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff0748:	4798      	blx	r3
1fff074a:	1e63      	subs	r3, r4, #1
1fff074c:	401c      	ands	r4, r3
1fff074e:	d1f5      	bne.n	1fff073c <port_E_isr+0xc>
1fff0750:	bd38      	pop	{r3, r4, r5, pc}
1fff0752:	bf00      	nop
1fff0754:	4004d0a0 	.word	0x4004d0a0
1fff0758:	1fff0ab8 	.word	0x1fff0ab8

1fff075c <port_D_isr>:

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
PORT_ISR_FUNCTION_CLZ(C)
PORT_ISR_FUNCTION_CLZ(D)
1fff075c:	b538      	push	{r3, r4, r5, lr}
1fff075e:	4b08      	ldr	r3, [pc, #32]	; (1fff0780 <port_D_isr+0x24>)
1fff0760:	681c      	ldr	r4, [r3, #0]
1fff0762:	601c      	str	r4, [r3, #0]
1fff0764:	b154      	cbz	r4, 1fff077c <port_D_isr+0x20>
1fff0766:	4d07      	ldr	r5, [pc, #28]	; (1fff0784 <port_D_isr+0x28>)
1fff0768:	fa94 f3a4 	rbit	r3, r4
1fff076c:	fab3 f383 	clz	r3, r3
1fff0770:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff0774:	4798      	blx	r3
1fff0776:	1e63      	subs	r3, r4, #1
1fff0778:	401c      	ands	r4, r3
1fff077a:	d1f5      	bne.n	1fff0768 <port_D_isr+0xc>
1fff077c:	bd38      	pop	{r3, r4, r5, pc}
1fff077e:	bf00      	nop
1fff0780:	4004c0a0 	.word	0x4004c0a0
1fff0784:	1fff0a78 	.word	0x1fff0a78

1fff0788 <port_C_isr>:
// END PORT_ISR_FUNCTION_CLZ

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
PORT_ISR_FUNCTION_CLZ(C)
1fff0788:	b538      	push	{r3, r4, r5, lr}
1fff078a:	4b08      	ldr	r3, [pc, #32]	; (1fff07ac <port_C_isr+0x24>)
1fff078c:	681c      	ldr	r4, [r3, #0]
1fff078e:	601c      	str	r4, [r3, #0]
1fff0790:	b154      	cbz	r4, 1fff07a8 <port_C_isr+0x20>
1fff0792:	4d07      	ldr	r5, [pc, #28]	; (1fff07b0 <port_C_isr+0x28>)
1fff0794:	fa94 f3a4 	rbit	r3, r4
1fff0798:	fab3 f383 	clz	r3, r3
1fff079c:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff07a0:	4798      	blx	r3
1fff07a2:	1e63      	subs	r3, r4, #1
1fff07a4:	401c      	ands	r4, r3
1fff07a6:	d1f5      	bne.n	1fff0794 <port_C_isr+0xc>
1fff07a8:	bd38      	pop	{r3, r4, r5, pc}
1fff07aa:	bf00      	nop
1fff07ac:	4004b0a0 	.word	0x4004b0a0
1fff07b0:	1fff0a48 	.word	0x1fff0a48

1fff07b4 <port_B_isr>:
	}
// END PORT_ISR_FUNCTION_CLZ

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
1fff07b4:	b538      	push	{r3, r4, r5, lr}
1fff07b6:	4b08      	ldr	r3, [pc, #32]	; (1fff07d8 <port_B_isr+0x24>)
1fff07b8:	681c      	ldr	r4, [r3, #0]
1fff07ba:	601c      	str	r4, [r3, #0]
1fff07bc:	b154      	cbz	r4, 1fff07d4 <port_B_isr+0x20>
1fff07be:	4d07      	ldr	r5, [pc, #28]	; (1fff07dc <port_B_isr+0x28>)
1fff07c0:	fa94 f3a4 	rbit	r3, r4
1fff07c4:	fab3 f383 	clz	r3, r3
1fff07c8:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff07cc:	4798      	blx	r3
1fff07ce:	1e63      	subs	r3, r4, #1
1fff07d0:	401c      	ands	r4, r3
1fff07d2:	d1f5      	bne.n	1fff07c0 <port_B_isr+0xc>
1fff07d4:	bd38      	pop	{r3, r4, r5, pc}
1fff07d6:	bf00      	nop
1fff07d8:	4004a0a0 	.word	0x4004a0a0
1fff07dc:	1fff09e8 	.word	0x1fff09e8

1fff07e0 <port_A_isr>:
		}                                                     \
	}
// END PORT_ISR_FUNCTION_CLZ

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
1fff07e0:	b538      	push	{r3, r4, r5, lr}
1fff07e2:	4b08      	ldr	r3, [pc, #32]	; (1fff0804 <port_A_isr+0x24>)
1fff07e4:	681c      	ldr	r4, [r3, #0]
1fff07e6:	601c      	str	r4, [r3, #0]
1fff07e8:	b154      	cbz	r4, 1fff0800 <port_A_isr+0x20>
1fff07ea:	4d07      	ldr	r5, [pc, #28]	; (1fff0808 <port_A_isr+0x28>)
1fff07ec:	fa94 f3a4 	rbit	r3, r4
1fff07f0:	fab3 f383 	clz	r3, r3
1fff07f4:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff07f8:	4798      	blx	r3
1fff07fa:	1e63      	subs	r3, r4, #1
1fff07fc:	401c      	ands	r4, r3
1fff07fe:	d1f5      	bne.n	1fff07ec <port_A_isr+0xc>
1fff0800:	bd38      	pop	{r3, r4, r5, pc}
1fff0802:	bf00      	nop
1fff0804:	400490a0 	.word	0x400490a0
1fff0808:	1fff0970 	.word	0x1fff0970

1fff080c <period>:
1fff080c:	00000064                                d...

1fff0810 <wheel_radius>:
1fff0810:	3d23d70a                                ..#=

1fff0814 <wheel_base>:
1fff0814:	3e6a7efa                                .~j>

1fff0818 <count_to_rad>:
1fff0818:	20000000 3f6aceea                       ... ..j?

1fff0820 <float_to_long_factor>:
1fff0820:	461c4000                                .@.F

1fff0824 <I2Cdev::readTimeout>:
1fff0824:	000003e8                                ....

1fff0828 <Wire2>:
1fff0828:	0000ac9c 00000000 000003e8 00000000     ................
1fff0838:	400e6000 0000ac74 00000000 00000000     .`.@t...........
	...

1fff0894 <Wire>:
1fff0894:	0000ac9c 00000000 000003e8 00000000     ................
1fff08a4:	40066000 0000ac34 00000000 00000000     .`.@4...........
	...

1fff0900 <Wire1>:
1fff0900:	0000ac9c 00000000 000003e8 00000000     ................
1fff0910:	40067000 0000ac54 00000000 00000000     .p.@T...........
	...

1fff096c <__brkval>:
1fff096c:	1fff2cc8                                .,..

1fff0970 <isr_table_portA>:
1fff0970:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff0980:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff0990:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff09a0:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff09b0:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff09c0:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff09d0:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff09e0:	00005e15 00005e15                       .^...^..

1fff09e8 <isr_table_portB>:
1fff09e8:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff09f8:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff0a08:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff0a18:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff0a28:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff0a38:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..

1fff0a48 <isr_table_portC>:
1fff0a48:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff0a58:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff0a68:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..

1fff0a78 <isr_table_portD>:
1fff0a78:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff0a88:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff0a98:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff0aa8:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..

1fff0ab8 <isr_table_portE>:
1fff0ab8:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff0ac8:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff0ad8:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff0ae8:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff0af8:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff0b08:	00005e15 00005e15 00005e15 00005e15     .^...^...^...^..
1fff0b18:	00005e15 00005e15 00005e15              .^...^...^..

1fff0b24 <analog_write_res>:
1fff0b24:	00000008                                ....

1fff0b28 <usb_buffer_available>:
1fff0b28:	ffffffff                                ....

1fff0b2c <Serial>:
1fff0b2c:	0000aec0 00000000 000003e8 00000000     ................

1fff0b3c <yield_active_check_flags>:
1fff0b3c:	00040a01                                         .

1fff0b3d <analog_config_bits>:
1fff0b3d:	1200040a                                         .

1fff0b3e <analog_num_average>:
1fff0b3e:	01120004                                         ..

1fff0b40 <device_descriptor>:
1fff0b40:	01100112 40000002 048316c0 02010277     .......@....w...
1fff0b50:	00000103                                ....

1fff0b54 <usb_string_manufacturer_name_default>:
1fff0b54:	00540318 00650065 0073006e 00640079     ..T.e.e.n.s.y.d.
1fff0b64:	00690075 006f006e                       u.i.n.o.

1fff0b6c <config_descriptor>:
1fff0b6c:	00430209 c0000102 00040932 02020100     ..C.....2.......
1fff0b7c:	24050001 05011000 01010124 06022404     ...$....$....$..
1fff0b8c:	00062405 82050701 40001003 00010409     .$.........@....
1fff0b9c:	00000a02 03050700 00004002 02840507     .........@......
1fff0bac:	00000040                                @...

1fff0bb0 <usb_string_product_name_default>:
1fff0bb0:	00550316 00420053 00530020 00720065     ..U.S.B. .S.e.r.
1fff0bc0:	00610069 0000006c                       i.a.l...

1fff0bc8 <string0>:
1fff0bc8:	04090304                                ....

1fff0bcc <usb_string_serial_number_default>:
1fff0bcc:	0000030c 00000000 00000000 00000000     ................
1fff0bdc:	00000000 01010000                                ......

1fff0be2 <_serialEvent_default>:
1fff0be2:	00000101                                         .

1fff0be3 <__fdlib_version>:
1fff0be3:	00000001 00000000                                .....

1fff0be8 <impure_data>:
1fff0be8:	00000000 1fff0ed4 1fff0f3c 1fff0fa4     ........<.......
	...
1fff0c90:	00000001 00000000 abcd330e e66d1234     .........3..4.m.
1fff0ca0:	0005deec 0000000b 00000000 00000000     ................
	...

1fff1010 <_impure_ptr>:
1fff1010:	1fff0be8                                ....

1fff1014 <__malloc_av_>:
	...
1fff101c:	1fff1014 1fff1014 1fff101c 1fff101c     ................
1fff102c:	1fff1024 1fff1024 1fff102c 1fff102c     $...$...,...,...
1fff103c:	1fff1034 1fff1034 1fff103c 1fff103c     4...4...<...<...
1fff104c:	1fff1044 1fff1044 1fff104c 1fff104c     D...D...L...L...
1fff105c:	1fff1054 1fff1054 1fff105c 1fff105c     T...T...\...\...
1fff106c:	1fff1064 1fff1064 1fff106c 1fff106c     d...d...l...l...
1fff107c:	1fff1074 1fff1074 1fff107c 1fff107c     t...t...|...|...
1fff108c:	1fff1084 1fff1084 1fff108c 1fff108c     ................
1fff109c:	1fff1094 1fff1094 1fff109c 1fff109c     ................
1fff10ac:	1fff10a4 1fff10a4 1fff10ac 1fff10ac     ................
1fff10bc:	1fff10b4 1fff10b4 1fff10bc 1fff10bc     ................
1fff10cc:	1fff10c4 1fff10c4 1fff10cc 1fff10cc     ................
1fff10dc:	1fff10d4 1fff10d4 1fff10dc 1fff10dc     ................
1fff10ec:	1fff10e4 1fff10e4 1fff10ec 1fff10ec     ................
1fff10fc:	1fff10f4 1fff10f4 1fff10fc 1fff10fc     ................
1fff110c:	1fff1104 1fff1104 1fff110c 1fff110c     ................
1fff111c:	1fff1114 1fff1114 1fff111c 1fff111c     ................
1fff112c:	1fff1124 1fff1124 1fff112c 1fff112c     $...$...,...,...
1fff113c:	1fff1134 1fff1134 1fff113c 1fff113c     4...4...<...<...
1fff114c:	1fff1144 1fff1144 1fff114c 1fff114c     D...D...L...L...
1fff115c:	1fff1154 1fff1154 1fff115c 1fff115c     T...T...\...\...
1fff116c:	1fff1164 1fff1164 1fff116c 1fff116c     d...d...l...l...
1fff117c:	1fff1174 1fff1174 1fff117c 1fff117c     t...t...|...|...
1fff118c:	1fff1184 1fff1184 1fff118c 1fff118c     ................
1fff119c:	1fff1194 1fff1194 1fff119c 1fff119c     ................
1fff11ac:	1fff11a4 1fff11a4 1fff11ac 1fff11ac     ................
1fff11bc:	1fff11b4 1fff11b4 1fff11bc 1fff11bc     ................
1fff11cc:	1fff11c4 1fff11c4 1fff11cc 1fff11cc     ................
1fff11dc:	1fff11d4 1fff11d4 1fff11dc 1fff11dc     ................
1fff11ec:	1fff11e4 1fff11e4 1fff11ec 1fff11ec     ................
1fff11fc:	1fff11f4 1fff11f4 1fff11fc 1fff11fc     ................
1fff120c:	1fff1204 1fff1204 1fff120c 1fff120c     ................
1fff121c:	1fff1214 1fff1214 1fff121c 1fff121c     ................
1fff122c:	1fff1224 1fff1224 1fff122c 1fff122c     $...$...,...,...
1fff123c:	1fff1234 1fff1234 1fff123c 1fff123c     4...4...<...<...
1fff124c:	1fff1244 1fff1244 1fff124c 1fff124c     D...D...L...L...
1fff125c:	1fff1254 1fff1254 1fff125c 1fff125c     T...T...\...\...
1fff126c:	1fff1264 1fff1264 1fff126c 1fff126c     d...d...l...l...
1fff127c:	1fff1274 1fff1274 1fff127c 1fff127c     t...t...|...|...
1fff128c:	1fff1284 1fff1284 1fff128c 1fff128c     ................
1fff129c:	1fff1294 1fff1294 1fff129c 1fff129c     ................
1fff12ac:	1fff12a4 1fff12a4 1fff12ac 1fff12ac     ................
1fff12bc:	1fff12b4 1fff12b4 1fff12bc 1fff12bc     ................
1fff12cc:	1fff12c4 1fff12c4 1fff12cc 1fff12cc     ................
1fff12dc:	1fff12d4 1fff12d4 1fff12dc 1fff12dc     ................
1fff12ec:	1fff12e4 1fff12e4 1fff12ec 1fff12ec     ................
1fff12fc:	1fff12f4 1fff12f4 1fff12fc 1fff12fc     ................
1fff130c:	1fff1304 1fff1304 1fff130c 1fff130c     ................
1fff131c:	1fff1314 1fff1314 1fff131c 1fff131c     ................
1fff132c:	1fff1324 1fff1324 1fff132c 1fff132c     $...$...,...,...
1fff133c:	1fff1334 1fff1334 1fff133c 1fff133c     4...4...<...<...
1fff134c:	1fff1344 1fff1344 1fff134c 1fff134c     D...D...L...L...
1fff135c:	1fff1354 1fff1354 1fff135c 1fff135c     T...T...\...\...
1fff136c:	1fff1364 1fff1364 1fff136c 1fff136c     d...d...l...l...
1fff137c:	1fff1374 1fff1374 1fff137c 1fff137c     t...t...|...|...
1fff138c:	1fff1384 1fff1384 1fff138c 1fff138c     ................
1fff139c:	1fff1394 1fff1394 1fff139c 1fff139c     ................
1fff13ac:	1fff13a4 1fff13a4 1fff13ac 1fff13ac     ................
1fff13bc:	1fff13b4 1fff13b4 1fff13bc 1fff13bc     ................
1fff13cc:	1fff13c4 1fff13c4 1fff13cc 1fff13cc     ................
1fff13dc:	1fff13d4 1fff13d4 1fff13dc 1fff13dc     ................
1fff13ec:	1fff13e4 1fff13e4 1fff13ec 1fff13ec     ................
1fff13fc:	1fff13f4 1fff13f4 1fff13fc 1fff13fc     ................
1fff140c:	1fff1404 1fff1404 1fff140c 1fff140c     ................

1fff141c <__malloc_trim_threshold>:
1fff141c:	00020000                                ....

1fff1420 <__malloc_sbrk_base>:
1fff1420:	ffffffff                                ....
