
/tmp/arduino-sketch-1A5AB903302D1BEDD698E1DA3B58D00C/motor_strait_driving.ino.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <_VectorsFlash>:
  free(ptr);
}

void operator delete[](void * ptr, size_t size)
{
  free(ptr);
       0:	00 00 03 20 d1 01 00 00 2d 66 00 00 e5 65 00 00     ... ....-f...e..

// simple helper function that add us to the list of Serial ports that have
// their own serialEvent code defined that needs to be called at yield.
void HardwareSerial::addToSerialEventsList() {
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
		if (s_serials_with_serial_events[i] == this) return; // already in the list.
      10:	e5 65 00 00 e5 65 00 00 e5 65 00 00 e5 65 00 00     .e...e...e...e..
      20:	e5 65 00 00 e5 65 00 00 e5 65 00 00 2d 66 00 00     .e...e...e..-f..
	}

	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
      30:	2d 66 00 00 e5 65 00 00 b9 7c 00 00 bd 7c 00 00     -f...e...|...|..
uint8_t 		HardwareSerial::s_count_serials_with_serial_events = 0;

// simple helper function that add us to the list of Serial ports that have
// their own serialEvent code defined that needs to be called at yield.
void HardwareSerial::addToSerialEventsList() {
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
      40:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..
      50:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..
      60:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..
      70:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..
      80:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..
      90:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..
      a0:	45 52 00 00 51 52 00 00 2d 66 00 00 2d 66 00 00     ER..QR..-f..-f..
      b0:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..
      c0:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..
      d0:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..
      e0:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..
      f0:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..
     100:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..
     110:	2d 66 00 00 dd 6f 00 00 2d 66 00 00 2d 66 00 00     -f...o..-f..-f..
     120:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..
     130:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..
     140:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..
     150:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..
     160:	2d 66 00 00 2d 66 00 00 5d 52 00 00 2d 66 00 00     -f..-f..]R..-f..
     170:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..
     180:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..
     190:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..
     1a0:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..
     1b0:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..
     1c0:	2d 66 00 00 2d 66 00 00 2d 66 00 00 2d 66 00 00     -f..-f..-f..-f..

000001d0 <ResetHandler>:
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d0:	4b5c      	ldr	r3, [pc, #368]	; (344 <ResetHandler+0x174>)
     1d2:	f24c 5220 	movw	r2, #50464	; 0xc520
#else
// hopefully all others fit into startup section (below 0x400)
__attribute__ ((section(".startup"),optimize("-Os")))
#endif
void ResetHandler(void)
{
     1d6:	b510      	push	{r4, lr}
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d8:	801a      	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
     1da:	f64d 1228 	movw	r2, #55592	; 0xd928
     1de:	801a      	strh	r2, [r3, #0]
	__asm__ volatile ("nop");
     1e0:	bf00      	nop
	__asm__ volatile ("nop");
     1e2:	bf00      	nop
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
     1e4:	f006 fa26 	bl	6634 <startup_early_hook>
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1e8:	4b57      	ldr	r3, [pc, #348]	; (348 <ResetHandler+0x178>)
     1ea:	f04f 6230 	mov.w	r2, #184549376	; 0xb000000
     1ee:	601a      	str	r2, [r3, #0]
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
     1f0:	4a56      	ldr	r2, [pc, #344]	; (34c <ResetHandler+0x17c>)
     1f2:	609a      	str	r2, [r3, #8]
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
     1f4:	4a56      	ldr	r2, [pc, #344]	; (350 <ResetHandler+0x180>)
     1f6:	60da      	str	r2, [r3, #12]
	SIM_SCGC4 = SIM_SCGC4_USBOTG | 0xF0000030;
	SIM_SCGC5 = 0x00003F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_ADC0 | SIM_SCGC6_TPM0 | SIM_SCGC6_TPM1 | SIM_SCGC6_TPM2 | SIM_SCGC6_FTFL;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SCB_CPACR = 0x00F00000;
     1f8:	4b56      	ldr	r3, [pc, #344]	; (354 <ResetHandler+0x184>)
     1fa:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
     1fe:	601a      	str	r2, [r3, #0]
#endif
#if defined(__MK66FX1M0__)
	LMEM_PCCCR = 0x85000003;
     200:	4b55      	ldr	r3, [pc, #340]	; (358 <ResetHandler+0x188>)
     202:	4a56      	ldr	r2, [pc, #344]	; (35c <ResetHandler+0x18c>)
     204:	601a      	str	r2, [r3, #0]
		RTC_SR = 0;
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
     206:	4b56      	ldr	r3, [pc, #344]	; (360 <ResetHandler+0x190>)
     208:	781a      	ldrb	r2, [r3, #0]
     20a:	0711      	lsls	r1, r2, #28
     20c:	d503      	bpl.n	216 <ResetHandler+0x46>
     20e:	781a      	ldrb	r2, [r3, #0]
     210:	f042 0208 	orr.w	r2, r2, #8
     214:	701a      	strb	r2, [r3, #0]

    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     216:	4b53      	ldr	r3, [pc, #332]	; (364 <ResetHandler+0x194>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     218:	4953      	ldr	r1, [pc, #332]	; (368 <ResetHandler+0x198>)
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;

    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     21a:	22aa      	movs	r2, #170	; 0xaa
     21c:	701a      	strb	r2, [r3, #0]
     21e:	4a53      	ldr	r2, [pc, #332]	; (36c <ResetHandler+0x19c>)
     220:	4b53      	ldr	r3, [pc, #332]	; (370 <ResetHandler+0x1a0>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     222:	428b      	cmp	r3, r1
     224:	d204      	bcs.n	230 <ResetHandler+0x60>
     226:	f852 0f04 	ldr.w	r0, [r2, #4]!
     22a:	f843 0b04 	str.w	r0, [r3], #4
     22e:	e7f8      	b.n	222 <ResetHandler+0x52>
     230:	4b50      	ldr	r3, [pc, #320]	; (374 <ResetHandler+0x1a4>)
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
     232:	4951      	ldr	r1, [pc, #324]	; (378 <ResetHandler+0x1a8>)
     234:	2200      	movs	r2, #0
     236:	428b      	cmp	r3, r1
     238:	d202      	bcs.n	240 <ResetHandler+0x70>
     23a:	f843 2b04 	str.w	r2, [r3], #4
     23e:	e7fa      	b.n	236 <ResetHandler+0x66>

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
     240:	494e      	ldr	r1, [pc, #312]	; (37c <ResetHandler+0x1ac>)
     242:	4a4f      	ldr	r2, [pc, #316]	; (380 <ResetHandler+0x1b0>)
     244:	2300      	movs	r3, #0
     246:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
     24a:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
     24e:	3301      	adds	r3, #1
     250:	2b74      	cmp	r3, #116	; 0x74
     252:	d1f8      	bne.n	246 <ResetHandler+0x76>
     254:	4b4b      	ldr	r3, [pc, #300]	; (384 <ResetHandler+0x1b4>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
     256:	4a4c      	ldr	r2, [pc, #304]	; (388 <ResetHandler+0x1b8>)
     258:	2180      	movs	r1, #128	; 0x80
     25a:	f803 1b01 	strb.w	r1, [r3], #1
     25e:	4293      	cmp	r3, r2
     260:	d1fb      	bne.n	25a <ResetHandler+0x8a>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
     262:	4b4a      	ldr	r3, [pc, #296]	; (38c <ResetHandler+0x1bc>)
     264:	4a45      	ldr	r2, [pc, #276]	; (37c <ResetHandler+0x1ac>)
     266:	601a      	str	r2, [r3, #0]
	//  C6[PLLS] bit is written to 0
	//  C2[LP] bit is written to 1
#else
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
     268:	4b49      	ldr	r3, [pc, #292]	; (390 <ResetHandler+0x1c0>)
     26a:	228a      	movs	r2, #138	; 0x8a
     26c:	701a      	strb	r2, [r3, #0]
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
     26e:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
     272:	2224      	movs	r2, #36	; 0x24
     274:	705a      	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
     276:	22a0      	movs	r2, #160	; 0xa0
     278:	701a      	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
     27a:	799a      	ldrb	r2, [r3, #6]
     27c:	0792      	lsls	r2, r2, #30
     27e:	d5fc      	bpl.n	27a <ResetHandler+0xaa>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
     280:	799a      	ldrb	r2, [r3, #6]
     282:	06d4      	lsls	r4, r2, #27
     284:	d4fc      	bmi.n	280 <ResetHandler+0xb0>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     286:	4a43      	ldr	r2, [pc, #268]	; (394 <ResetHandler+0x1c4>)
     288:	7993      	ldrb	r3, [r2, #6]
     28a:	f003 030c 	and.w	r3, r3, #12
     28e:	2b08      	cmp	r3, #8
     290:	d1fa      	bne.n	288 <ResetHandler+0xb8>
	//   C2[LP] bit is written to 1
  #else
	// if we need faster than the crystal, turn on the PLL
   #if defined(__MK66FX1M0__)
    #if F_CPU > 120000000
	SMC_PMCTRL = SMC_PMCTRL_RUNM(3); // enter HSRUN mode
     292:	4b41      	ldr	r3, [pc, #260]	; (398 <ResetHandler+0x1c8>)
     294:	2260      	movs	r2, #96	; 0x60
     296:	701a      	strb	r2, [r3, #0]
	while (SMC_PMSTAT != SMC_PMSTAT_HSRUN) ; // wait for HSRUN
     298:	3302      	adds	r3, #2
     29a:	781a      	ldrb	r2, [r3, #0]
     29c:	2a80      	cmp	r2, #128	; 0x80
     29e:	d1fc      	bne.n	29a <ResetHandler+0xca>
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(11);
    #elif F_CPU == 192000000
	MCG_C5 = MCG_C5_PRDIV0(0);
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(8);
    #elif F_CPU == 180000000
	MCG_C5 = MCG_C5_PRDIV0(1);
     2a0:	4b3c      	ldr	r3, [pc, #240]	; (394 <ResetHandler+0x1c4>)
     2a2:	2201      	movs	r2, #1
     2a4:	711a      	strb	r2, [r3, #4]
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(29);
     2a6:	225d      	movs	r2, #93	; 0x5d
     2a8:	715a      	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     2aa:	799a      	ldrb	r2, [r3, #6]
     2ac:	0690      	lsls	r0, r2, #26
     2ae:	d5fc      	bpl.n	2aa <ResetHandler+0xda>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     2b0:	7999      	ldrb	r1, [r3, #6]
     2b2:	4a38      	ldr	r2, [pc, #224]	; (394 <ResetHandler+0x1c4>)
     2b4:	0649      	lsls	r1, r1, #25
     2b6:	d5fb      	bpl.n	2b0 <ResetHandler+0xe0>
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(3);
#elif F_CPU == 180000000
	// config divisors: 180 MHz core, 60 MHz bus, 25.7 MHz flash, USB = IRC48M
	#if F_BUS == 60000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(2) | SIM_CLKDIV1_OUTDIV4(6);
     2b8:	4b38      	ldr	r3, [pc, #224]	; (39c <ResetHandler+0x1cc>)
     2ba:	4939      	ldr	r1, [pc, #228]	; (3a0 <ResetHandler+0x1d0>)
     2bc:	6019      	str	r1, [r3, #0]
	#elif F_BUS == 90000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(6);
	#else
	#error "This F_CPU & F_BUS combination is not supported"
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(0);
     2be:	2100      	movs	r1, #0
     2c0:	6059      	str	r1, [r3, #4]
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     2c2:	2320      	movs	r3, #32
     2c4:	7013      	strb	r3, [r2, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     2c6:	7993      	ldrb	r3, [r2, #6]
     2c8:	f003 030c 	and.w	r3, r3, #12
     2cc:	2b0c      	cmp	r3, #12
     2ce:	d1fa      	bne.n	2c6 <ResetHandler+0xf6>
	// now we're in PEE mode
	// trace is CPU clock, CLKOUT=OSCERCLK0
	#if defined(KINETISK)
	#if F_CPU == 256000000 || F_CPU == 216000000 || F_CPU == 180000000
	// USB uses IRC48
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
     2d0:	4b34      	ldr	r3, [pc, #208]	; (3a4 <ResetHandler+0x1d4>)
     2d2:	4a35      	ldr	r2, [pc, #212]	; (3a8 <ResetHandler+0x1d8>)
     2d4:	601a      	str	r2, [r3, #0]
#endif

#if defined(__MK66FX1M0__)
	// If the RTC oscillator isn't enabled, get it started.  For Teensy 3.6
	// we don't do this early.  See comment above about slow rising power.
	if (!(RTC_CR & RTC_CR_OSCE)) {
     2d6:	4a35      	ldr	r2, [pc, #212]	; (3ac <ResetHandler+0x1dc>)
     2d8:	4c35      	ldr	r4, [pc, #212]	; (3b0 <ResetHandler+0x1e0>)
     2da:	6813      	ldr	r3, [r2, #0]
     2dc:	f413 7380 	ands.w	r3, r3, #256	; 0x100
     2e0:	d103      	bne.n	2ea <ResetHandler+0x11a>
		RTC_SR = 0;
     2e2:	6023      	str	r3, [r4, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
     2e4:	f44f 53a8 	mov.w	r3, #5376	; 0x1500
     2e8:	6013      	str	r3, [r2, #0]
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     2ea:	4b32      	ldr	r3, [pc, #200]	; (3b4 <ResetHandler+0x1e4>)
     2ec:	4a32      	ldr	r2, [pc, #200]	; (3b8 <ResetHandler+0x1e8>)
     2ee:	601a      	str	r2, [r3, #0]
	SYST_CVR = 0;
     2f0:	2200      	movs	r2, #0
     2f2:	605a      	str	r2, [r3, #4]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     2f4:	2207      	movs	r2, #7
     2f6:	f843 2c04 	str.w	r2, [r3, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     2fa:	4a30      	ldr	r2, [pc, #192]	; (3bc <ResetHandler+0x1ec>)
     2fc:	f8c3 2d0c 	str.w	r2, [r3, #3340]	; 0xd0c

	//init_pins();
	__enable_irq();
     300:	b662      	cpsie	i

	_init_Teensyduino_internal_();
     302:	f006 fcfd 	bl	6d00 <_init_Teensyduino_internal_>

#if defined(KINETISK)
	// RTC initialization
	if (RTC_SR & RTC_SR_TIF) {
     306:	6823      	ldr	r3, [r4, #0]
     308:	07da      	lsls	r2, r3, #31
     30a:	d505      	bpl.n	318 <ResetHandler+0x148>
		// compiled-in time will be stale.  Write a special
		// flag into the VBAT register file indicating the
		// RTC is set with known-stale time and should be
		// updated when fresh time is known.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     30c:	482c      	ldr	r0, [pc, #176]	; (3c0 <ResetHandler+0x1f0>)
     30e:	f006 fac3 	bl	6898 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
     312:	4b2c      	ldr	r3, [pc, #176]	; (3c4 <ResetHandler+0x1f4>)
     314:	4a2c      	ldr	r2, [pc, #176]	; (3c8 <ResetHandler+0x1f8>)
     316:	601a      	str	r2, [r3, #0]
	}
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
     318:	4b2c      	ldr	r3, [pc, #176]	; (3cc <ResetHandler+0x1fc>)
     31a:	781b      	ldrb	r3, [r3, #0]
     31c:	065b      	lsls	r3, r3, #25
     31e:	d509      	bpl.n	334 <ResetHandler+0x164>
     320:	4c28      	ldr	r4, [pc, #160]	; (3c4 <ResetHandler+0x1f4>)
     322:	4b29      	ldr	r3, [pc, #164]	; (3c8 <ResetHandler+0x1f8>)
     324:	6822      	ldr	r2, [r4, #0]
     326:	429a      	cmp	r2, r3
     328:	d104      	bne.n	334 <ResetHandler+0x164>
		// Our compiled-in time will be very fresh, so set
		// the RTC with this, and clear the VBAT resister file
		// data so we don't mess with the time after it's been
		// set well.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     32a:	4825      	ldr	r0, [pc, #148]	; (3c0 <ResetHandler+0x1f0>)
     32c:	f006 fab4 	bl	6898 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0;
     330:	2300      	movs	r3, #0
     332:	6023      	str	r3, [r4, #0]
	}
#endif

	__libc_init_array();
     334:	f00a fa8c 	bl	a850 <__libc_init_array>

	startup_late_hook();
     338:	f006 f982 	bl	6640 <startup_late_hook>
	main();
     33c:	f007 fd30 	bl	7da0 <main>
     340:	e7fe      	b.n	340 <ResetHandler+0x170>
     342:	bf00      	nop
     344:	4005200e 	.word	0x4005200e
     348:	40048030 	.word	0x40048030
     34c:	00043f82 	.word	0x00043f82
     350:	2b000001 	.word	0x2b000001
     354:	e000ed88 	.word	0xe000ed88
     358:	e0082000 	.word	0xe0082000
     35c:	85000003 	.word	0x85000003
     360:	4007d002 	.word	0x4007d002
     364:	4007e000 	.word	0x4007e000
     368:	1fff1414 	.word	0x1fff1414
     36c:	0000c4b4 	.word	0x0000c4b4
     370:	1fff0730 	.word	0x1fff0730
     374:	1fff1418 	.word	0x1fff1418
     378:	1fff2d80 	.word	0x1fff2d80
     37c:	1fff0200 	.word	0x1fff0200
     380:	00000000 	.word	0x00000000
     384:	e000e400 	.word	0xe000e400
     388:	e000e464 	.word	0xe000e464
     38c:	e000ed08 	.word	0xe000ed08
     390:	40065000 	.word	0x40065000
     394:	40064000 	.word	0x40064000
     398:	4007e001 	.word	0x4007e001
     39c:	40048044 	.word	0x40048044
     3a0:	02060000 	.word	0x02060000
     3a4:	40048004 	.word	0x40048004
     3a8:	000710c0 	.word	0x000710c0
     3ac:	4003d010 	.word	0x4003d010
     3b0:	4003d014 	.word	0x4003d014
     3b4:	e000e014 	.word	0xe000e014
     3b8:	0002bf1f 	.word	0x0002bf1f
     3bc:	20200000 	.word	0x20200000
     3c0:	62483d0a 	.word	0x62483d0a
     3c4:	4003e01c 	.word	0x4003e01c
     3c8:	5a94c3a5 	.word	0x5a94c3a5
     3cc:	4007f000 	.word	0x4007f000
     3d0:	ffffffff 	.word	0xffffffff
     3d4:	ffffffff 	.word	0xffffffff
     3d8:	ffffffff 	.word	0xffffffff
     3dc:	ffffffff 	.word	0xffffffff
     3e0:	ffffffff 	.word	0xffffffff
     3e4:	ffffffff 	.word	0xffffffff
     3e8:	ffffffff 	.word	0xffffffff
     3ec:	ffffffff 	.word	0xffffffff
     3f0:	ffffffff 	.word	0xffffffff
     3f4:	ffffffff 	.word	0xffffffff
     3f8:	ffffffff 	.word	0xffffffff
     3fc:	ffffffff 	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	ffffffff ffffffff ffffffff fffff9de     ................

00000410 <__do_global_dtors_aux>:
     410:	b510      	push	{r4, lr}
     412:	4c05      	ldr	r4, [pc, #20]	; (428 <__do_global_dtors_aux+0x18>)
     414:	7823      	ldrb	r3, [r4, #0]
     416:	b933      	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
     418:	4b04      	ldr	r3, [pc, #16]	; (42c <__do_global_dtors_aux+0x1c>)
     41a:	b113      	cbz	r3, 422 <__do_global_dtors_aux+0x12>
     41c:	4804      	ldr	r0, [pc, #16]	; (430 <__do_global_dtors_aux+0x20>)
     41e:	f3af 8000 	nop.w
     422:	2301      	movs	r3, #1
     424:	7023      	strb	r3, [r4, #0]
     426:	bd10      	pop	{r4, pc}
     428:	1fff1418 	.word	0x1fff1418
     42c:	00000000 	.word	0x00000000
     430:	0000c4b0 	.word	0x0000c4b0

00000434 <frame_dummy>:
     434:	4b08      	ldr	r3, [pc, #32]	; (458 <frame_dummy+0x24>)
     436:	b510      	push	{r4, lr}
     438:	b11b      	cbz	r3, 442 <frame_dummy+0xe>
     43a:	4908      	ldr	r1, [pc, #32]	; (45c <frame_dummy+0x28>)
     43c:	4808      	ldr	r0, [pc, #32]	; (460 <frame_dummy+0x2c>)
     43e:	f3af 8000 	nop.w
     442:	4808      	ldr	r0, [pc, #32]	; (464 <frame_dummy+0x30>)
     444:	6803      	ldr	r3, [r0, #0]
     446:	b903      	cbnz	r3, 44a <frame_dummy+0x16>
     448:	bd10      	pop	{r4, pc}
     44a:	4b07      	ldr	r3, [pc, #28]	; (468 <frame_dummy+0x34>)
     44c:	2b00      	cmp	r3, #0
     44e:	d0fb      	beq.n	448 <frame_dummy+0x14>
     450:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     454:	4718      	bx	r3
     456:	bf00      	nop
     458:	00000000 	.word	0x00000000
     45c:	1fff141c 	.word	0x1fff141c
     460:	0000c4b0 	.word	0x0000c4b0
     464:	1fff1414 	.word	0x1fff1414
     468:	00000000 	.word	0x00000000

0000046c <std_msgs::Time::serialize(unsigned char*) const>:
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->data.sec >> (8 * 0)) & 0xFF;
     46c:	6843      	ldr	r3, [r0, #4]
     46e:	700b      	strb	r3, [r1, #0]
      *(outbuffer + offset + 1) = (this->data.sec >> (8 * 1)) & 0xFF;
     470:	6843      	ldr	r3, [r0, #4]
     472:	0a1b      	lsrs	r3, r3, #8
     474:	704b      	strb	r3, [r1, #1]
      *(outbuffer + offset + 2) = (this->data.sec >> (8 * 2)) & 0xFF;
     476:	88c3      	ldrh	r3, [r0, #6]
     478:	708b      	strb	r3, [r1, #2]
      *(outbuffer + offset + 3) = (this->data.sec >> (8 * 3)) & 0xFF;
     47a:	79c3      	ldrb	r3, [r0, #7]
     47c:	70cb      	strb	r3, [r1, #3]
      offset += sizeof(this->data.sec);
      *(outbuffer + offset + 0) = (this->data.nsec >> (8 * 0)) & 0xFF;
     47e:	6883      	ldr	r3, [r0, #8]
     480:	710b      	strb	r3, [r1, #4]
      *(outbuffer + offset + 1) = (this->data.nsec >> (8 * 1)) & 0xFF;
     482:	6883      	ldr	r3, [r0, #8]
     484:	0a1b      	lsrs	r3, r3, #8
     486:	714b      	strb	r3, [r1, #5]
      *(outbuffer + offset + 2) = (this->data.nsec >> (8 * 2)) & 0xFF;
     488:	8943      	ldrh	r3, [r0, #10]
     48a:	718b      	strb	r3, [r1, #6]
      *(outbuffer + offset + 3) = (this->data.nsec >> (8 * 3)) & 0xFF;
     48c:	7ac3      	ldrb	r3, [r0, #11]
     48e:	71cb      	strb	r3, [r1, #7]
      offset += sizeof(this->data.nsec);
      return offset;
    }
     490:	2008      	movs	r0, #8
     492:	4770      	bx	lr

00000494 <std_msgs::Time::deserialize(unsigned char*)>:

    virtual int deserialize(unsigned char *inbuffer) override
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
     494:	780b      	ldrb	r3, [r1, #0]
     496:	6043      	str	r3, [r0, #4]
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
     498:	784a      	ldrb	r2, [r1, #1]
     49a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
     49e:	6043      	str	r3, [r0, #4]
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
     4a0:	788a      	ldrb	r2, [r1, #2]
     4a2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
     4a6:	6043      	str	r3, [r0, #4]
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
     4a8:	78ca      	ldrb	r2, [r1, #3]
     4aa:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
     4ae:	6043      	str	r3, [r0, #4]
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
     4b0:	790b      	ldrb	r3, [r1, #4]
     4b2:	6083      	str	r3, [r0, #8]
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
     4b4:	794a      	ldrb	r2, [r1, #5]
     4b6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
     4ba:	6083      	str	r3, [r0, #8]
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
     4bc:	798a      	ldrb	r2, [r1, #6]
     4be:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
     4c2:	6083      	str	r3, [r0, #8]
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
     4c4:	79ca      	ldrb	r2, [r1, #7]
     4c6:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
     4ca:	6083      	str	r3, [r0, #8]
      offset += sizeof(this->data.nsec);
     return offset;
    }
     4cc:	2008      	movs	r0, #8
     4ce:	4770      	bx	lr

000004d0 <std_msgs::Time::getType()>:

    virtual const char * getType() override { return "std_msgs/Time"; };
     4d0:	4800      	ldr	r0, [pc, #0]	; (4d4 <std_msgs::Time::getType()+0x4>)
     4d2:	4770      	bx	lr
     4d4:	0000bd38 	.word	0x0000bd38

000004d8 <std_msgs::Time::getMD5()>:
    virtual const char * getMD5() override { return "cd7166c74c552c311fbcc2fe5a7bc289"; };
     4d8:	4800      	ldr	r0, [pc, #0]	; (4dc <std_msgs::Time::getMD5()+0x4>)
     4da:	4770      	bx	lr
     4dc:	0000bd48 	.word	0x0000bd48

000004e0 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)>:
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     4e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    {
      int offset = 0;
      this->topic_id =  ((uint16_t) (*(inbuffer + offset)));
      this->topic_id |= ((uint16_t) (*(inbuffer + offset + 1))) << (8 * 1);
     4e2:	460c      	mov	r4, r1
    }

    virtual int deserialize(unsigned char *inbuffer) override
    {
      int offset = 0;
      this->topic_id =  ((uint16_t) (*(inbuffer + offset)));
     4e4:	780a      	ldrb	r2, [r1, #0]
     4e6:	8082      	strh	r2, [r0, #4]
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     4e8:	4606      	mov	r6, r0
    {
      int offset = 0;
      this->topic_id =  ((uint16_t) (*(inbuffer + offset)));
      this->topic_id |= ((uint16_t) (*(inbuffer + offset + 1))) << (8 * 1);
     4ea:	f814 0f01 	ldrb.w	r0, [r4, #1]!
     4ee:	2300      	movs	r3, #0
     4f0:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
     4f4:	80b2      	strh	r2, [r6, #4]

  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
     4f6:	461a      	mov	r2, r3
    for (size_t i = 0; i < sizeof(V); i++)
      var |= (arr[i] << (8 * i));
     4f8:	f814 0f01 	ldrb.w	r0, [r4, #1]!
     4fc:	4098      	lsls	r0, r3
     4fe:	3308      	adds	r3, #8
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
     500:	2b20      	cmp	r3, #32
      var |= (arr[i] << (8 * i));
     502:	ea42 0200 	orr.w	r2, r2, r0
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
     506:	d1f7      	bne.n	4f8 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x18>
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name;
      arrToVar(length_topic_name, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_topic_name; ++k){
     508:	1d97      	adds	r7, r2, #6
     50a:	2f06      	cmp	r7, #6
     50c:	d958      	bls.n	5c0 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0xe0>
     50e:	f101 0e05 	add.w	lr, r1, #5
     512:	1d55      	adds	r5, r2, #5
     514:	4673      	mov	r3, lr
     516:	194c      	adds	r4, r1, r5
          inbuffer[k-1]=inbuffer[k];
     518:	f813 0f01 	ldrb.w	r0, [r3, #1]!
     51c:	f803 0c01 	strb.w	r0, [r3, #-1]
      this->topic_id |= ((uint16_t) (*(inbuffer + offset + 1))) << (8 * 1);
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name;
      arrToVar(length_topic_name, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_topic_name; ++k){
     520:	42a3      	cmp	r3, r4
     522:	d1f9      	bne.n	518 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x38>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_topic_name-1]=0;
     524:	2300      	movs	r3, #0
     526:	554b      	strb	r3, [r1, r5]
      this->topic_name = (char *)(inbuffer + offset-1);
      offset += length_topic_name;
     528:	4618      	mov	r0, r3
     52a:	440d      	add	r5, r1
      offset += 4;
      for(unsigned int k= offset; k< offset+length_topic_name; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_topic_name-1]=0;
      this->topic_name = (char *)(inbuffer + offset-1);
     52c:	f8c6 e008 	str.w	lr, [r6, #8]
      var |= (arr[i] << (8 * i));
     530:	f815 4f01 	ldrb.w	r4, [r5, #1]!
     534:	4084      	lsls	r4, r0
     536:	3008      	adds	r0, #8
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
     538:	2820      	cmp	r0, #32
      var |= (arr[i] << (8 * i));
     53a:	ea43 0304 	orr.w	r3, r3, r4
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
     53e:	d1f7      	bne.n	530 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x50>
      offset += length_topic_name;
      uint32_t length_message_type;
      arrToVar(length_message_type, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_message_type; ++k){
     540:	1d38      	adds	r0, r7, #4
     542:	4403      	add	r3, r0
     544:	4283      	cmp	r3, r0
     546:	d909      	bls.n	55c <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x7c>
     548:	3209      	adds	r2, #9
     54a:	440a      	add	r2, r1
     54c:	4604      	mov	r4, r0
     54e:	3401      	adds	r4, #1
          inbuffer[k-1]=inbuffer[k];
     550:	f812 5f01 	ldrb.w	r5, [r2, #1]!
     554:	f802 5c01 	strb.w	r5, [r2, #-1]
      this->topic_name = (char *)(inbuffer + offset-1);
      offset += length_topic_name;
      uint32_t length_message_type;
      arrToVar(length_message_type, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_message_type; ++k){
     558:	42a3      	cmp	r3, r4
     55a:	d8f8      	bhi.n	54e <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x6e>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_message_type-1]=0;
      this->message_type = (char *)(inbuffer + offset-1);
     55c:	3801      	subs	r0, #1
      arrToVar(length_message_type, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_message_type; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_message_type-1]=0;
     55e:	18cf      	adds	r7, r1, r3
     560:	2400      	movs	r4, #0
      this->message_type = (char *)(inbuffer + offset-1);
     562:	4408      	add	r0, r1
      arrToVar(length_message_type, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_message_type; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_message_type-1]=0;
     564:	f807 4c01 	strb.w	r4, [r7, #-1]
      this->message_type = (char *)(inbuffer + offset-1);
      offset += length_message_type;
     568:	4622      	mov	r2, r4
      offset += 4;
      for(unsigned int k= offset; k< offset+length_message_type; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_message_type-1]=0;
      this->message_type = (char *)(inbuffer + offset-1);
     56a:	60f0      	str	r0, [r6, #12]
      var |= (arr[i] << (8 * i));
     56c:	f817 5b01 	ldrb.w	r5, [r7], #1
     570:	4095      	lsls	r5, r2
     572:	3208      	adds	r2, #8
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
     574:	2a20      	cmp	r2, #32
      var |= (arr[i] << (8 * i));
     576:	ea44 0405 	orr.w	r4, r4, r5
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
     57a:	d1f7      	bne.n	56c <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x8c>
      offset += length_message_type;
      uint32_t length_md5sum;
      arrToVar(length_md5sum, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_md5sum; ++k){
     57c:	1d18      	adds	r0, r3, #4
     57e:	4404      	add	r4, r0
     580:	42a0      	cmp	r0, r4
     582:	d209      	bcs.n	598 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0xb8>
     584:	3303      	adds	r3, #3
     586:	440b      	add	r3, r1
     588:	4602      	mov	r2, r0
     58a:	3201      	adds	r2, #1
          inbuffer[k-1]=inbuffer[k];
     58c:	f813 5f01 	ldrb.w	r5, [r3, #1]!
     590:	f803 5c01 	strb.w	r5, [r3, #-1]
      this->message_type = (char *)(inbuffer + offset-1);
      offset += length_message_type;
      uint32_t length_md5sum;
      arrToVar(length_md5sum, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_md5sum; ++k){
     594:	42a2      	cmp	r2, r4
     596:	d3f8      	bcc.n	58a <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0xaa>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_md5sum-1]=0;
     598:	190d      	adds	r5, r1, r4
      this->md5sum = (char *)(inbuffer + offset-1);
     59a:	3801      	subs	r0, #1
     59c:	4408      	add	r0, r1
      arrToVar(length_md5sum, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_md5sum; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_md5sum-1]=0;
     59e:	2300      	movs	r3, #0
     5a0:	f805 3c01 	strb.w	r3, [r5, #-1]
      this->md5sum = (char *)(inbuffer + offset-1);
     5a4:	6130      	str	r0, [r6, #16]
      u_buffer_size.base = 0;
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->buffer_size = u_buffer_size.real;
     5a6:	78a8      	ldrb	r0, [r5, #2]
     5a8:	786b      	ldrb	r3, [r5, #1]
     5aa:	5d0a      	ldrb	r2, [r1, r4]
     5ac:	78ed      	ldrb	r5, [r5, #3]
     5ae:	0401      	lsls	r1, r0, #16
     5b0:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
     5b4:	4313      	orrs	r3, r2
     5b6:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
      offset += sizeof(this->buffer_size);
     return offset;
     5ba:	1d20      	adds	r0, r4, #4
      u_buffer_size.base = 0;
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->buffer_size = u_buffer_size.real;
     5bc:	6173      	str	r3, [r6, #20]
      offset += sizeof(this->buffer_size);
     return offset;
    }
     5be:	bdf0      	pop	{r4, r5, r6, r7, pc}
     5c0:	1d55      	adds	r5, r2, #5
     5c2:	f101 0e05 	add.w	lr, r1, #5
     5c6:	e7ad      	b.n	524 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x44>

000005c8 <rosserial_msgs::TopicInfo::getType()>:

    virtual const char * getType() override { return "rosserial_msgs/TopicInfo"; };
     5c8:	4800      	ldr	r0, [pc, #0]	; (5cc <rosserial_msgs::TopicInfo::getType()+0x4>)
     5ca:	4770      	bx	lr
     5cc:	0000bd6c 	.word	0x0000bd6c

000005d0 <rosserial_msgs::TopicInfo::getMD5()>:
    virtual const char * getMD5() override { return "0ad51f88fc44892f8c10684077646005"; };
     5d0:	4800      	ldr	r0, [pc, #0]	; (5d4 <rosserial_msgs::TopicInfo::getMD5()+0x4>)
     5d2:	4770      	bx	lr
     5d4:	0000bd88 	.word	0x0000bd88

000005d8 <rosserial_msgs::Log::deserialize(unsigned char*)>:
    }

    virtual int deserialize(unsigned char *inbuffer) override
    {
      int offset = 0;
      this->level =  ((uint8_t) (*(inbuffer + offset)));
     5d8:	780b      	ldrb	r3, [r1, #0]
      memcpy(outbuffer + offset, this->msg, length_msg);
      offset += length_msg;
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     5da:	b4f0      	push	{r4, r5, r6, r7}
    {
      int offset = 0;
      this->level =  ((uint8_t) (*(inbuffer + offset)));
     5dc:	7103      	strb	r3, [r0, #4]
     5de:	2300      	movs	r3, #0
      memcpy(outbuffer + offset, this->msg, length_msg);
      offset += length_msg;
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     5e0:	4606      	mov	r6, r0
     5e2:	460c      	mov	r4, r1

  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
     5e4:	461d      	mov	r5, r3
    for (size_t i = 0; i < sizeof(V); i++)
      var |= (arr[i] << (8 * i));
     5e6:	f814 2f01 	ldrb.w	r2, [r4, #1]!
     5ea:	409a      	lsls	r2, r3
     5ec:	3308      	adds	r3, #8
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
     5ee:	2b20      	cmp	r3, #32
      var |= (arr[i] << (8 * i));
     5f0:	ea45 0502 	orr.w	r5, r5, r2
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
     5f4:	d1f7      	bne.n	5e6 <rosserial_msgs::Log::deserialize(unsigned char*)+0xe>
      this->level =  ((uint8_t) (*(inbuffer + offset)));
      offset += sizeof(this->level);
      uint32_t length_msg;
      arrToVar(length_msg, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_msg; ++k){
     5f6:	1d68      	adds	r0, r5, #5
     5f8:	2805      	cmp	r0, #5
     5fa:	f101 0704 	add.w	r7, r1, #4
     5fe:	d908      	bls.n	612 <rosserial_msgs::Log::deserialize(unsigned char*)+0x3a>
     600:	1d2c      	adds	r4, r5, #4
     602:	463b      	mov	r3, r7
     604:	440c      	add	r4, r1
          inbuffer[k-1]=inbuffer[k];
     606:	f813 2f01 	ldrb.w	r2, [r3, #1]!
     60a:	f803 2c01 	strb.w	r2, [r3, #-1]
      this->level =  ((uint8_t) (*(inbuffer + offset)));
      offset += sizeof(this->level);
      uint32_t length_msg;
      arrToVar(length_msg, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_msg; ++k){
     60e:	429c      	cmp	r4, r3
     610:	d1f9      	bne.n	606 <rosserial_msgs::Log::deserialize(unsigned char*)+0x2e>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_msg-1]=0;
     612:	440d      	add	r5, r1
     614:	2300      	movs	r3, #0
     616:	712b      	strb	r3, [r5, #4]
      this->msg = (char *)(inbuffer + offset-1);
     618:	60b7      	str	r7, [r6, #8]
      offset += length_msg;
     return offset;
    }
     61a:	bcf0      	pop	{r4, r5, r6, r7}
     61c:	4770      	bx	lr
     61e:	bf00      	nop

00000620 <rosserial_msgs::Log::getType()>:

    virtual const char * getType() override { return "rosserial_msgs/Log"; };
     620:	4800      	ldr	r0, [pc, #0]	; (624 <rosserial_msgs::Log::getType()+0x4>)
     622:	4770      	bx	lr
     624:	0000bdac 	.word	0x0000bdac

00000628 <rosserial_msgs::Log::getMD5()>:
    virtual const char * getMD5() override { return "11abd731c25933261cd6183bd12d6295"; };
     628:	4800      	ldr	r0, [pc, #0]	; (62c <rosserial_msgs::Log::getMD5()+0x4>)
     62a:	4770      	bx	lr
     62c:	0000bdc0 	.word	0x0000bdc0

00000630 <rosserial_msgs::RequestParamResponse::getType()>:
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
      }
     return offset;
    }

    virtual const char * getType() override { return REQUESTPARAM; };
     630:	4800      	ldr	r0, [pc, #0]	; (634 <rosserial_msgs::RequestParamResponse::getType()+0x4>)
     632:	4770      	bx	lr
     634:	0000c0dc 	.word	0x0000c0dc

00000638 <rosserial_msgs::RequestParamResponse::getMD5()>:
    virtual const char * getMD5() override { return "9f0e98bda65981986ddf53afa7a40e49"; };
     638:	4800      	ldr	r0, [pc, #0]	; (63c <rosserial_msgs::RequestParamResponse::getMD5()+0x4>)
     63a:	4770      	bx	lr
     63c:	0000bde4 	.word	0x0000bde4

00000640 <std_msgs::Int16::serialize(unsigned char*) const>:
      int offset = 0;
      union {
        int16_t real;
        uint16_t base;
      } u_data;
      u_data.real = this->data;
     640:	f9b0 3004 	ldrsh.w	r3, [r0, #4]
      *(outbuffer + offset + 0) = (u_data.base >> (8 * 0)) & 0xFF;
     644:	700b      	strb	r3, [r1, #0]
      *(outbuffer + offset + 1) = (u_data.base >> (8 * 1)) & 0xFF;
     646:	f3c3 2207 	ubfx	r2, r3, #8, #8
     64a:	704a      	strb	r2, [r1, #1]
      offset += sizeof(this->data);
      return offset;
    }
     64c:	2002      	movs	r0, #2
     64e:	4770      	bx	lr

00000650 <std_msgs::Int16::deserialize(unsigned char*)>:
        uint16_t base;
      } u_data;
      u_data.base = 0;
      u_data.base |= ((uint16_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_data.base |= ((uint16_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data = u_data.real;
     650:	784a      	ldrb	r2, [r1, #1]
     652:	780b      	ldrb	r3, [r1, #0]
     654:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
     658:	8083      	strh	r3, [r0, #4]
      offset += sizeof(this->data);
     return offset;
    }
     65a:	2002      	movs	r0, #2
     65c:	4770      	bx	lr
     65e:	bf00      	nop

00000660 <std_msgs::Int16::getType()>:

    virtual const char * getType() override { return "std_msgs/Int16"; };
     660:	4800      	ldr	r0, [pc, #0]	; (664 <std_msgs::Int16::getType()+0x4>)
     662:	4770      	bx	lr
     664:	0000be08 	.word	0x0000be08

00000668 <std_msgs::Int16::getMD5()>:
    virtual const char * getMD5() override { return "8524586e34fbd7cb1c08c5f5f1ca0e57"; };
     668:	4800      	ldr	r0, [pc, #0]	; (66c <std_msgs::Int16::getMD5()+0x4>)
     66a:	4770      	bx	lr
     66c:	0000be18 	.word	0x0000be18

00000670 <std_msgs::Float32::serialize(unsigned char*) const>:
      union {
        float real;
        uint32_t base;
      } u_data;
      u_data.real = this->data;
      *(outbuffer + offset + 0) = (u_data.base >> (8 * 0)) & 0xFF;
     670:	6843      	ldr	r3, [r0, #4]
     672:	700b      	strb	r3, [r1, #0]
    Float32():
      data(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
     674:	b410      	push	{r4}
        uint32_t base;
      } u_data;
      u_data.real = this->data;
      *(outbuffer + offset + 0) = (u_data.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_data.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_data.base >> (8 * 2)) & 0xFF;
     676:	0c18      	lsrs	r0, r3, #16
        float real;
        uint32_t base;
      } u_data;
      u_data.real = this->data;
      *(outbuffer + offset + 0) = (u_data.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_data.base >> (8 * 1)) & 0xFF;
     678:	0a1c      	lsrs	r4, r3, #8
      *(outbuffer + offset + 2) = (u_data.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_data.base >> (8 * 3)) & 0xFF;
     67a:	0e1a      	lsrs	r2, r3, #24
        float real;
        uint32_t base;
      } u_data;
      u_data.real = this->data;
      *(outbuffer + offset + 0) = (u_data.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_data.base >> (8 * 1)) & 0xFF;
     67c:	704c      	strb	r4, [r1, #1]
      *(outbuffer + offset + 2) = (u_data.base >> (8 * 2)) & 0xFF;
     67e:	7088      	strb	r0, [r1, #2]
      *(outbuffer + offset + 3) = (u_data.base >> (8 * 3)) & 0xFF;
     680:	70ca      	strb	r2, [r1, #3]
      offset += sizeof(this->data);
      return offset;
    }
     682:	2004      	movs	r0, #4
     684:	f85d 4b04 	ldr.w	r4, [sp], #4
     688:	4770      	bx	lr
     68a:	bf00      	nop

0000068c <std_msgs::Float32::deserialize(unsigned char*)>:

    virtual int deserialize(unsigned char *inbuffer) override
     68c:	b410      	push	{r4}
      } u_data;
      u_data.base = 0;
      u_data.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_data.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_data.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_data.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
     68e:	784c      	ldrb	r4, [r1, #1]
     690:	780a      	ldrb	r2, [r1, #0]
     692:	788b      	ldrb	r3, [r1, #2]
     694:	78c9      	ldrb	r1, [r1, #3]
     696:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
     69a:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
      this->data = u_data.real;
     69e:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
     6a2:	6043      	str	r3, [r0, #4]
      offset += sizeof(this->data);
     return offset;
    }
     6a4:	f85d 4b04 	ldr.w	r4, [sp], #4
     6a8:	2004      	movs	r0, #4
     6aa:	4770      	bx	lr

000006ac <std_msgs::Float32::getType()>:

    virtual const char * getType() override { return "std_msgs/Float32"; };
     6ac:	4800      	ldr	r0, [pc, #0]	; (6b0 <std_msgs::Float32::getType()+0x4>)
     6ae:	4770      	bx	lr
     6b0:	0000be3c 	.word	0x0000be3c

000006b4 <std_msgs::Float32::getMD5()>:
    virtual const char * getMD5() override { return "73fcbf46b49191e672908e50842a83d4"; };
     6b4:	4800      	ldr	r0, [pc, #0]	; (6b8 <std_msgs::Float32::getMD5()+0x4>)
     6b6:	4770      	bx	lr
     6b8:	0000be50 	.word	0x0000be50

000006bc <geometry_msgs::Vector3::serialize(unsigned char*) const>:
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
     6bc:	6882      	ldr	r2, [r0, #8]
     6be:	68c3      	ldr	r3, [r0, #12]
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
     6c0:	710b      	strb	r3, [r1, #4]
      y(0),
      z(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
     6c2:	b4f0      	push	{r4, r5, r6, r7}
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
     6c4:	0a14      	lsrs	r4, r2, #8
     6c6:	704c      	strb	r4, [r1, #1]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
     6c8:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
     6ca:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
     6cc:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
     6ce:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
     6d0:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
     6d2:	708f      	strb	r7, [r1, #2]
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
     6d4:	70ce      	strb	r6, [r1, #3]
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
     6d6:	714d      	strb	r5, [r1, #5]
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
     6d8:	718c      	strb	r4, [r1, #6]
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
     6da:	700a      	strb	r2, [r1, #0]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
     6dc:	71cb      	strb	r3, [r1, #7]
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
     6de:	6902      	ldr	r2, [r0, #16]
     6e0:	6943      	ldr	r3, [r0, #20]
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
     6e2:	730b      	strb	r3, [r1, #12]
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
     6e4:	0a14      	lsrs	r4, r2, #8
     6e6:	724c      	strb	r4, [r1, #9]
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
     6e8:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
     6ea:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
     6ec:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
     6ee:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
     6f0:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
     6f2:	728f      	strb	r7, [r1, #10]
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
     6f4:	72ce      	strb	r6, [r1, #11]
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
     6f6:	734d      	strb	r5, [r1, #13]
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
     6f8:	738c      	strb	r4, [r1, #14]
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
     6fa:	720a      	strb	r2, [r1, #8]
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
     6fc:	73cb      	strb	r3, [r1, #15]
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
     6fe:	6982      	ldr	r2, [r0, #24]
     700:	69c3      	ldr	r3, [r0, #28]
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
     702:	750b      	strb	r3, [r1, #20]
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
     704:	0a1c      	lsrs	r4, r3, #8
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
     706:	0c18      	lsrs	r0, r3, #16
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
     708:	0a17      	lsrs	r7, r2, #8
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
     70a:	0c16      	lsrs	r6, r2, #16
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
     70c:	0e15      	lsrs	r5, r2, #24
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
     70e:	0e1b      	lsrs	r3, r3, #24
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
     710:	7588      	strb	r0, [r1, #22]
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
     712:	740a      	strb	r2, [r1, #16]
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
     714:	744f      	strb	r7, [r1, #17]
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
     716:	748e      	strb	r6, [r1, #18]
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
     718:	74cd      	strb	r5, [r1, #19]
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
     71a:	754c      	strb	r4, [r1, #21]
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
     71c:	75cb      	strb	r3, [r1, #23]
      offset += sizeof(this->z);
      return offset;
    }
     71e:	2018      	movs	r0, #24
     720:	bcf0      	pop	{r4, r5, r6, r7}
     722:	4770      	bx	lr

00000724 <geometry_msgs::Vector3::deserialize(unsigned char*)>:

    virtual int deserialize(unsigned char *inbuffer) override
     724:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
     728:	f891 c001 	ldrb.w	ip, [r1, #1]
     72c:	f891 e000 	ldrb.w	lr, [r1]
     730:	790f      	ldrb	r7, [r1, #4]
     732:	f891 b002 	ldrb.w	fp, [r1, #2]
     736:	f891 a003 	ldrb.w	sl, [r1, #3]
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
      offset += sizeof(this->z);
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     73a:	4606      	mov	r6, r0
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
     73c:	7948      	ldrb	r0, [r1, #5]
     73e:	ea4e 2e0c 	orr.w	lr, lr, ip, lsl #8
     742:	f891 c006 	ldrb.w	ip, [r1, #6]
     746:	ea47 2000 	orr.w	r0, r7, r0, lsl #8
     74a:	79cf      	ldrb	r7, [r1, #7]
     74c:	ea4e 4e0b 	orr.w	lr, lr, fp, lsl #16
     750:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
     754:	ea4e 680a 	orr.w	r8, lr, sl, lsl #24
     758:	ea40 6907 	orr.w	r9, r0, r7, lsl #24
      this->x = u_x.real;
     75c:	e9c6 8902 	strd	r8, r9, [r6, #8]
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
     760:	f891 c008 	ldrb.w	ip, [r1, #8]
     764:	f891 e009 	ldrb.w	lr, [r1, #9]
     768:	7b0f      	ldrb	r7, [r1, #12]
     76a:	7b48      	ldrb	r0, [r1, #13]
     76c:	f891 900a 	ldrb.w	r9, [r1, #10]
     770:	f891 800b 	ldrb.w	r8, [r1, #11]
     774:	ea4c 2e0e 	orr.w	lr, ip, lr, lsl #8
     778:	f891 c00e 	ldrb.w	ip, [r1, #14]
     77c:	ea47 2000 	orr.w	r0, r7, r0, lsl #8
     780:	7bcf      	ldrb	r7, [r1, #15]
     782:	ea4e 4e09 	orr.w	lr, lr, r9, lsl #16
     786:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
     78a:	ea4e 6408 	orr.w	r4, lr, r8, lsl #24
     78e:	ea40 6507 	orr.w	r5, r0, r7, lsl #24
      this->y = u_y.real;
     792:	e9c6 4504 	strd	r4, r5, [r6, #16]
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
     796:	7c0d      	ldrb	r5, [r1, #16]
     798:	7c4c      	ldrb	r4, [r1, #17]
     79a:	7d08      	ldrb	r0, [r1, #20]
     79c:	f891 c015 	ldrb.w	ip, [r1, #21]
     7a0:	f891 8012 	ldrb.w	r8, [r1, #18]
     7a4:	7d8f      	ldrb	r7, [r1, #22]
     7a6:	f891 e013 	ldrb.w	lr, [r1, #19]
     7aa:	ea45 2404 	orr.w	r4, r5, r4, lsl #8
     7ae:	7dcd      	ldrb	r5, [r1, #23]
     7b0:	ea40 210c 	orr.w	r1, r0, ip, lsl #8
     7b4:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
     7b8:	ea41 4107 	orr.w	r1, r1, r7, lsl #16
     7bc:	ea44 620e 	orr.w	r2, r4, lr, lsl #24
     7c0:	ea41 6305 	orr.w	r3, r1, r5, lsl #24
      this->z = u_z.real;
      offset += sizeof(this->z);
     return offset;
    }
     7c4:	2018      	movs	r0, #24
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
      this->z = u_z.real;
     7c6:	e9c6 2306 	strd	r2, r3, [r6, #24]
      offset += sizeof(this->z);
     return offset;
    }
     7ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     7ce:	bf00      	nop

000007d0 <geometry_msgs::Vector3::getType()>:

    virtual const char * getType() override { return "geometry_msgs/Vector3"; };
     7d0:	4800      	ldr	r0, [pc, #0]	; (7d4 <geometry_msgs::Vector3::getType()+0x4>)
     7d2:	4770      	bx	lr
     7d4:	0000be74 	.word	0x0000be74

000007d8 <geometry_msgs::Vector3::getMD5()>:
    virtual const char * getMD5() override { return "4a842b65f413084dc2b10fb484ea7f17"; };
     7d8:	4800      	ldr	r0, [pc, #0]	; (7dc <geometry_msgs::Vector3::getMD5()+0x4>)
     7da:	4770      	bx	lr
     7dc:	0000be8c 	.word	0x0000be8c

000007e0 <geometry_msgs::Quaternion::serialize(unsigned char*) const>:
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
     7e0:	6882      	ldr	r2, [r0, #8]
     7e2:	68c3      	ldr	r3, [r0, #12]
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
     7e4:	710b      	strb	r3, [r1, #4]
      z(0),
      w(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
     7e6:	b4f0      	push	{r4, r5, r6, r7}
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
     7e8:	0a14      	lsrs	r4, r2, #8
     7ea:	704c      	strb	r4, [r1, #1]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
     7ec:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
     7ee:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
     7f0:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
     7f2:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
     7f4:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
     7f6:	708f      	strb	r7, [r1, #2]
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
     7f8:	70ce      	strb	r6, [r1, #3]
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
     7fa:	714d      	strb	r5, [r1, #5]
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
     7fc:	718c      	strb	r4, [r1, #6]
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
     7fe:	700a      	strb	r2, [r1, #0]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
     800:	71cb      	strb	r3, [r1, #7]
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
     802:	6902      	ldr	r2, [r0, #16]
     804:	6943      	ldr	r3, [r0, #20]
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
     806:	730b      	strb	r3, [r1, #12]
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
     808:	0a14      	lsrs	r4, r2, #8
     80a:	724c      	strb	r4, [r1, #9]
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
     80c:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
     80e:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
     810:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
     812:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
     814:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
     816:	728f      	strb	r7, [r1, #10]
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
     818:	72ce      	strb	r6, [r1, #11]
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
     81a:	734d      	strb	r5, [r1, #13]
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
     81c:	738c      	strb	r4, [r1, #14]
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
     81e:	720a      	strb	r2, [r1, #8]
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
     820:	73cb      	strb	r3, [r1, #15]
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
     822:	6982      	ldr	r2, [r0, #24]
     824:	69c3      	ldr	r3, [r0, #28]
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
     826:	750b      	strb	r3, [r1, #20]
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
     828:	0a14      	lsrs	r4, r2, #8
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
     82a:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
     82c:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
     82e:	0a1d      	lsrs	r5, r3, #8
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
     830:	744c      	strb	r4, [r1, #17]
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
     832:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
     834:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
     836:	748f      	strb	r7, [r1, #18]
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
     838:	74ce      	strb	r6, [r1, #19]
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
     83a:	754d      	strb	r5, [r1, #21]
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
     83c:	758c      	strb	r4, [r1, #22]
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
     83e:	740a      	strb	r2, [r1, #16]
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
     840:	75cb      	strb	r3, [r1, #23]
      union {
        double real;
        uint64_t base;
      } u_w;
      u_w.real = this->w;
      *(outbuffer + offset + 0) = (u_w.base >> (8 * 0)) & 0xFF;
     842:	6a03      	ldr	r3, [r0, #32]
     844:	6a42      	ldr	r2, [r0, #36]	; 0x24
     846:	760b      	strb	r3, [r1, #24]
      *(outbuffer + offset + 1) = (u_w.base >> (8 * 1)) & 0xFF;
     848:	0a1f      	lsrs	r7, r3, #8
      *(outbuffer + offset + 2) = (u_w.base >> (8 * 2)) & 0xFF;
     84a:	0c1e      	lsrs	r6, r3, #16
      *(outbuffer + offset + 3) = (u_w.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_w.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_w.base >> (8 * 5)) & 0xFF;
     84c:	0a15      	lsrs	r5, r2, #8
      *(outbuffer + offset + 6) = (u_w.base >> (8 * 6)) & 0xFF;
     84e:	0c14      	lsrs	r4, r2, #16
      *(outbuffer + offset + 7) = (u_w.base >> (8 * 7)) & 0xFF;
     850:	0e10      	lsrs	r0, r2, #24
      } u_w;
      u_w.real = this->w;
      *(outbuffer + offset + 0) = (u_w.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_w.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_w.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_w.base >> (8 * 3)) & 0xFF;
     852:	0e1b      	lsrs	r3, r3, #24
        double real;
        uint64_t base;
      } u_w;
      u_w.real = this->w;
      *(outbuffer + offset + 0) = (u_w.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_w.base >> (8 * 1)) & 0xFF;
     854:	764f      	strb	r7, [r1, #25]
      *(outbuffer + offset + 2) = (u_w.base >> (8 * 2)) & 0xFF;
     856:	768e      	strb	r6, [r1, #26]
      *(outbuffer + offset + 3) = (u_w.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_w.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_w.base >> (8 * 5)) & 0xFF;
     858:	774d      	strb	r5, [r1, #29]
      *(outbuffer + offset + 6) = (u_w.base >> (8 * 6)) & 0xFF;
     85a:	778c      	strb	r4, [r1, #30]
      *(outbuffer + offset + 7) = (u_w.base >> (8 * 7)) & 0xFF;
     85c:	77c8      	strb	r0, [r1, #31]
      u_w.real = this->w;
      *(outbuffer + offset + 0) = (u_w.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_w.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_w.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_w.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_w.base >> (8 * 4)) & 0xFF;
     85e:	770a      	strb	r2, [r1, #28]
      *(outbuffer + offset + 5) = (u_w.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_w.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_w.base >> (8 * 7)) & 0xFF;
      offset += sizeof(this->w);
      return offset;
    }
     860:	2020      	movs	r0, #32
      } u_w;
      u_w.real = this->w;
      *(outbuffer + offset + 0) = (u_w.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_w.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_w.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_w.base >> (8 * 3)) & 0xFF;
     862:	76cb      	strb	r3, [r1, #27]
      *(outbuffer + offset + 5) = (u_w.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_w.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_w.base >> (8 * 7)) & 0xFF;
      offset += sizeof(this->w);
      return offset;
    }
     864:	bcf0      	pop	{r4, r5, r6, r7}
     866:	4770      	bx	lr

00000868 <geometry_msgs::Quaternion::deserialize(unsigned char*)>:

    virtual int deserialize(unsigned char *inbuffer) override
     868:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
     86c:	f891 9001 	ldrb.w	r9, [r1, #1]
     870:	f891 c000 	ldrb.w	ip, [r1]
     874:	f891 e004 	ldrb.w	lr, [r1, #4]
     878:	f891 b002 	ldrb.w	fp, [r1, #2]
     87c:	f891 a003 	ldrb.w	sl, [r1, #3]
      *(outbuffer + offset + 7) = (u_w.base >> (8 * 7)) & 0xFF;
      offset += sizeof(this->w);
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     880:	4680      	mov	r8, r0
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
     882:	7948      	ldrb	r0, [r1, #5]
     884:	ea4c 2c09 	orr.w	ip, ip, r9, lsl #8
     888:	f891 9006 	ldrb.w	r9, [r1, #6]
     88c:	ea4e 2000 	orr.w	r0, lr, r0, lsl #8
     890:	f891 e007 	ldrb.w	lr, [r1, #7]
     894:	ea4c 4c0b 	orr.w	ip, ip, fp, lsl #16
     898:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
     89c:	ea4c 660a 	orr.w	r6, ip, sl, lsl #24
     8a0:	ea40 670e 	orr.w	r7, r0, lr, lsl #24
      this->x = u_x.real;
     8a4:	e9c8 6702 	strd	r6, r7, [r8, #8]
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
     8a8:	f891 e009 	ldrb.w	lr, [r1, #9]
     8ac:	7a0f      	ldrb	r7, [r1, #8]
     8ae:	7b0e      	ldrb	r6, [r1, #12]
     8b0:	7b48      	ldrb	r0, [r1, #13]
     8b2:	f891 900a 	ldrb.w	r9, [r1, #10]
     8b6:	f891 c00b 	ldrb.w	ip, [r1, #11]
     8ba:	ea47 270e 	orr.w	r7, r7, lr, lsl #8
     8be:	f891 e00e 	ldrb.w	lr, [r1, #14]
     8c2:	ea46 2000 	orr.w	r0, r6, r0, lsl #8
     8c6:	7bce      	ldrb	r6, [r1, #15]
     8c8:	ea47 4709 	orr.w	r7, r7, r9, lsl #16
     8cc:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     8d0:	ea47 640c 	orr.w	r4, r7, ip, lsl #24
     8d4:	ea40 6506 	orr.w	r5, r0, r6, lsl #24
      this->y = u_y.real;
     8d8:	e9c8 4504 	strd	r4, r5, [r8, #16]
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
     8dc:	7c0e      	ldrb	r6, [r1, #16]
     8de:	7c4d      	ldrb	r5, [r1, #17]
     8e0:	7d0c      	ldrb	r4, [r1, #20]
     8e2:	7d48      	ldrb	r0, [r1, #21]
     8e4:	f891 e012 	ldrb.w	lr, [r1, #18]
     8e8:	7ccf      	ldrb	r7, [r1, #19]
     8ea:	ea46 2505 	orr.w	r5, r6, r5, lsl #8
     8ee:	7d8e      	ldrb	r6, [r1, #22]
     8f0:	ea44 2000 	orr.w	r0, r4, r0, lsl #8
     8f4:	7dcc      	ldrb	r4, [r1, #23]
     8f6:	ea45 450e 	orr.w	r5, r5, lr, lsl #16
     8fa:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
     8fe:	ea45 6207 	orr.w	r2, r5, r7, lsl #24
     902:	ea40 6304 	orr.w	r3, r0, r4, lsl #24
      this->z = u_z.real;
     906:	e9c8 2306 	strd	r2, r3, [r8, #24]
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
     90a:	7e4c      	ldrb	r4, [r1, #25]
     90c:	7e08      	ldrb	r0, [r1, #24]
     90e:	7e8f      	ldrb	r7, [r1, #26]
     910:	7ece      	ldrb	r6, [r1, #27]
     912:	7f0a      	ldrb	r2, [r1, #28]
     914:	7f4b      	ldrb	r3, [r1, #29]
     916:	7f8d      	ldrb	r5, [r1, #30]
     918:	ea40 2004 	orr.w	r0, r0, r4, lsl #8
     91c:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
     920:	7fcc      	ldrb	r4, [r1, #31]
      *(outbuffer + offset + 7) = (u_w.base >> (8 * 7)) & 0xFF;
      offset += sizeof(this->w);
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     922:	b083      	sub	sp, #12
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
     924:	ea40 4107 	orr.w	r1, r0, r7, lsl #16
     928:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
     92c:	ea41 6206 	orr.w	r2, r1, r6, lsl #24
     930:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
     934:	9200      	str	r2, [sp, #0]
     936:	9301      	str	r3, [sp, #4]
      this->w = u_w.real;
     938:	e9dd 2300 	ldrd	r2, r3, [sp]
      offset += sizeof(this->w);
     return offset;
    }
     93c:	2020      	movs	r0, #32
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
      this->w = u_w.real;
     93e:	e9c8 2308 	strd	r2, r3, [r8, #32]
      offset += sizeof(this->w);
     return offset;
    }
     942:	b003      	add	sp, #12
     944:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00000948 <geometry_msgs::Quaternion::getType()>:

    virtual const char * getType() override { return "geometry_msgs/Quaternion"; };
     948:	4800      	ldr	r0, [pc, #0]	; (94c <geometry_msgs::Quaternion::getType()+0x4>)
     94a:	4770      	bx	lr
     94c:	0000beb0 	.word	0x0000beb0

00000950 <geometry_msgs::Quaternion::getMD5()>:
    virtual const char * getMD5() override { return "a779879fadf0160734f906b8c19c7004"; };
     950:	4800      	ldr	r0, [pc, #0]	; (954 <geometry_msgs::Quaternion::getMD5()+0x4>)
     952:	4770      	bx	lr
     954:	0000becc 	.word	0x0000becc

00000958 <geometry_msgs::Twist::getType()>:
      offset += this->linear.deserialize(inbuffer + offset);
      offset += this->angular.deserialize(inbuffer + offset);
     return offset;
    }

    virtual const char * getType() override { return "geometry_msgs/Twist"; };
     958:	4800      	ldr	r0, [pc, #0]	; (95c <geometry_msgs::Twist::getType()+0x4>)
     95a:	4770      	bx	lr
     95c:	0000bef0 	.word	0x0000bef0

00000960 <geometry_msgs::Twist::getMD5()>:
    virtual const char * getMD5() override { return "9f195f881246fdfa2798d1d3eebca84a"; };
     960:	4800      	ldr	r0, [pc, #0]	; (964 <geometry_msgs::Twist::getMD5()+0x4>)
     962:	4770      	bx	lr
     964:	0000bf04 	.word	0x0000bf04

00000968 <custom_msgs::odom_and_imu::getType()>:
      this->temp = u_temp.real;
      offset += sizeof(this->temp);
     return offset;
    }

    virtual const char * getType() override { return "custom_msgs/odom_and_imu"; };
     968:	4800      	ldr	r0, [pc, #0]	; (96c <custom_msgs::odom_and_imu::getType()+0x4>)
     96a:	4770      	bx	lr
     96c:	0000bf28 	.word	0x0000bf28

00000970 <custom_msgs::odom_and_imu::getMD5()>:
    virtual const char * getMD5() override { return "a0f22ba6c51d41d976fa58cb83325cf0"; };
     970:	4800      	ldr	r0, [pc, #0]	; (974 <custom_msgs::odom_and_imu::getMD5()+0x4>)
     972:	4770      	bx	lr
     974:	0000bf44 	.word	0x0000bf44

00000978 <ros::Subscriber<geometry_msgs::Twist, void>::getEndpointType()>:
    return this->msg.getMD5();
  }
  virtual int getEndpointType() override
  {
    return endpoint_;
  }
     978:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
     97a:	4770      	bx	lr

0000097c <ros::Subscriber<geometry_msgs::Twist, void>::getMsgType()>:
  }

  virtual const char * getMsgType() override
  {
    return this->msg.getType();
  }
     97c:	4800      	ldr	r0, [pc, #0]	; (980 <ros::Subscriber<geometry_msgs::Twist, void>::getMsgType()+0x4>)
     97e:	4770      	bx	lr
     980:	0000bef0 	.word	0x0000bef0

00000984 <ros::Subscriber<geometry_msgs::Twist, void>::getMsgMD5()>:
  virtual const char * getMsgMD5() override
  {
    return this->msg.getMD5();
  }
     984:	4800      	ldr	r0, [pc, #0]	; (988 <ros::Subscriber<geometry_msgs::Twist, void>::getMsgMD5()+0x4>)
     986:	4770      	bx	lr
     988:	0000bf04 	.word	0x0000bf04

0000098c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::connected()>:

  /* Are we connected to the PC? */
  virtual bool connected() override
  {
    return configured_;
  };
     98c:	f890 04f8 	ldrb.w	r0, [r0, #1272]	; 0x4f8
     990:	4770      	bx	lr
     992:	bf00      	nop
     994:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

00000998 <encoder_count_chage_right()>:
  result = result / sizeof(the_input_array);
  return result;
}


void encoder_count_chage_right() {
     998:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  delta_time_right =  double(micros()) / 1000000 - old_time_right;
     99a:	f006 f93b 	bl	6c14 <micros>
     99e:	4c54      	ldr	r4, [pc, #336]	; (af0 <encoder_count_chage_right()+0x158>)
     9a0:	4d54      	ldr	r5, [pc, #336]	; (af4 <encoder_count_chage_right()+0x15c>)
     9a2:	f009 f8d9 	bl	9b58 <__aeabi_ui2d>
     9a6:	a34c      	add	r3, pc, #304	; (adr r3, ad8 <encoder_count_chage_right()+0x140>)
     9a8:	e9d3 2300 	ldrd	r2, r3, [r3]
     9ac:	f009 fa74 	bl	9e98 <__aeabi_ddiv>
     9b0:	e9d4 2300 	ldrd	r2, r3, [r4]
     9b4:	f008 ff92 	bl	98dc <__aeabi_dsub>
     9b8:	e9c5 0100 	strd	r0, r1, [r5]
  old_time_right = double(micros()) / 1000000;
     9bc:	f006 f92a 	bl	6c14 <micros>
     9c0:	f009 f8ca 	bl	9b58 <__aeabi_ui2d>
     9c4:	a344      	add	r3, pc, #272	; (adr r3, ad8 <encoder_count_chage_right()+0x140>)
     9c6:	e9d3 2300 	ldrd	r2, r3, [r3]
     9ca:	f009 fa65 	bl	9e98 <__aeabi_ddiv>
  if (encoder_counter_right < counts_per_revolution && encoder_counter_right > -counts_per_revolution) {
     9ce:	4b4a      	ldr	r3, [pc, #296]	; (af8 <encoder_count_chage_right()+0x160>)
     9d0:	e9d3 6700 	ldrd	r6, r7, [r3]
}


void encoder_count_chage_right() {
  delta_time_right =  double(micros()) / 1000000 - old_time_right;
  old_time_right = double(micros()) / 1000000;
     9d4:	e9c4 0100 	strd	r0, r1, [r4]
  if (encoder_counter_right < counts_per_revolution && encoder_counter_right > -counts_per_revolution) {
     9d8:	2200      	movs	r2, #0
     9da:	4b48      	ldr	r3, [pc, #288]	; (afc <encoder_count_chage_right()+0x164>)
     9dc:	4630      	mov	r0, r6
     9de:	4639      	mov	r1, r7
     9e0:	f009 fba2 	bl	a128 <__aeabi_dcmplt>
     9e4:	b138      	cbz	r0, 9f6 <encoder_count_chage_right()+0x5e>
     9e6:	4630      	mov	r0, r6
     9e8:	4639      	mov	r1, r7
     9ea:	2200      	movs	r2, #0
     9ec:	4b44      	ldr	r3, [pc, #272]	; (b00 <encoder_count_chage_right()+0x168>)
     9ee:	f009 fbb9 	bl	a164 <__aeabi_dcmpgt>
     9f2:	2800      	cmp	r0, #0
     9f4:	d14e      	bne.n	a94 <encoder_count_chage_right()+0xfc>
     9f6:	4b43      	ldr	r3, [pc, #268]	; (b04 <encoder_count_chage_right()+0x16c>)
     9f8:	edd3 7a00 	vldr	s15, [r3]
      current_omega_right = -count_to_rad / delta_time_right;
    }
  }


  if (current_omega_right < 20 && current_omega_right > -20) {
     9fc:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
     a00:	eef4 7ac7 	vcmpe.f32	s15, s14
     a04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     a08:	d506      	bpl.n	a18 <encoder_count_chage_right()+0x80>
     a0a:	eebb 7a04 	vmov.f32	s14, #180	; 0xc1a00000 -20.0
     a0e:	eef4 7ac7 	vcmpe.f32	s15, s14
     a12:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     a16:	dc2c      	bgt.n	a72 <encoder_count_chage_right()+0xda>
     a18:	4b3b      	ldr	r3, [pc, #236]	; (b08 <encoder_count_chage_right()+0x170>)
     a1a:	edd3 7a00 	vldr	s15, [r3]
}

float averaging_array(long the_input_array[]) {
  float result = 0;
  for (int x = 0; x < sizeof(the_input_array); x++) {
    result = result + (the_input_array[x] / float_to_long_factor);
     a1e:	eddf 6a3b 	vldr	s13, [pc, #236]	; b0c <encoder_count_chage_right()+0x174>
     a22:	ed93 6a01 	vldr	s12, [r3, #4]
     a26:	ed93 7a02 	vldr	s14, [r3, #8]
     a2a:	edd3 4a03 	vldr	s9, [r3, #12]
     a2e:	ed9f 4a38 	vldr	s8, [pc, #224]	; b10 <encoder_count_chage_right()+0x178>


  if (current_omega_right < 20 && current_omega_right > -20) {
    array_push(speed_array_right, current_omega_right);
  }
  average_omega_right = averaging_array(speed_array_right);
     a32:	4b38      	ldr	r3, [pc, #224]	; (b14 <encoder_count_chage_right()+0x17c>)
}

float averaging_array(long the_input_array[]) {
  float result = 0;
  for (int x = 0; x < sizeof(the_input_array); x++) {
    result = result + (the_input_array[x] / float_to_long_factor);
     a34:	eef8 7ae7 	vcvt.f32.s32	s15, s15
     a38:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
     a3c:	ee87 5aa6 	vdiv.f32	s10, s15, s13
     a40:	eec6 5a26 	vdiv.f32	s11, s12, s13
     a44:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
     a48:	eef8 4ae4 	vcvt.f32.s32	s9, s9
     a4c:	ee87 6a26 	vdiv.f32	s12, s14, s13
     a50:	ee84 7aa6 	vdiv.f32	s14, s9, s13
     a54:	ee75 7a04 	vadd.f32	s15, s10, s8


  if (current_omega_right < 20 && current_omega_right > -20) {
    array_push(speed_array_right, current_omega_right);
  }
  average_omega_right = averaging_array(speed_array_right);
     a58:	eef5 6a00 	vmov.f32	s13, #80	; 0x3e800000  0.250
}

float averaging_array(long the_input_array[]) {
  float result = 0;
  for (int x = 0; x < sizeof(the_input_array); x++) {
    result = result + (the_input_array[x] / float_to_long_factor);
     a5c:	ee75 7aa7 	vadd.f32	s15, s11, s15
     a60:	ee76 7a27 	vadd.f32	s15, s12, s15
     a64:	ee77 7a27 	vadd.f32	s15, s14, s15


  if (current_omega_right < 20 && current_omega_right > -20) {
    array_push(speed_array_right, current_omega_right);
  }
  average_omega_right = averaging_array(speed_array_right);
     a68:	ee67 7aa6 	vmul.f32	s15, s15, s13
     a6c:	edc3 7a00 	vstr	s15, [r3]
     a70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}


//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
     a72:	4b25      	ldr	r3, [pc, #148]	; (b08 <encoder_count_chage_right()+0x170>)
  }
  the_input_array[0] = data * float_to_long_factor;
     a74:	ed9f 7a25 	vldr	s14, [pc, #148]	; b0c <encoder_count_chage_right()+0x174>


//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
     a78:	681c      	ldr	r4, [r3, #0]
     a7a:	1d18      	adds	r0, r3, #4
     a7c:	c807      	ldmia	r0, {r0, r1, r2}
  }
  the_input_array[0] = data * float_to_long_factor;
     a7e:	ee67 7a87 	vmul.f32	s15, s15, s14


//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
     a82:	605c      	str	r4, [r3, #4]
  }
  the_input_array[0] = data * float_to_long_factor;
     a84:	eefd 7ae7 	vcvt.s32.f32	s15, s15


//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
     a88:	6098      	str	r0, [r3, #8]
  }
  the_input_array[0] = data * float_to_long_factor;
     a8a:	edc3 7a00 	vstr	s15, [r3]


//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
     a8e:	60d9      	str	r1, [r3, #12]
     a90:	611a      	str	r2, [r3, #16]
     a92:	e7c4      	b.n	a1e <encoder_count_chage_right()+0x86>

void encoder_count_chage_right() {
  delta_time_right =  double(micros()) / 1000000 - old_time_right;
  old_time_right = double(micros()) / 1000000;
  if (encoder_counter_right < counts_per_revolution && encoder_counter_right > -counts_per_revolution) {
    if (direction_indicator_right == 1) {
     a94:	4b20      	ldr	r3, [pc, #128]	; (b18 <encoder_count_chage_right()+0x180>)
     a96:	681b      	ldr	r3, [r3, #0]
     a98:	2b01      	cmp	r3, #1
     a9a:	d013      	beq.n	ac4 <encoder_count_chage_right()+0x12c>
      right_count_tick += 1;
      current_omega_right = count_to_rad / delta_time_right;
    }
    if (direction_indicator_right == 0) {
     a9c:	2b00      	cmp	r3, #0
     a9e:	d1aa      	bne.n	9f6 <encoder_count_chage_right()+0x5e>
      right_count_tick += -1;
     aa0:	4e1e      	ldr	r6, [pc, #120]	; (b1c <encoder_count_chage_right()+0x184>)
     aa2:	6831      	ldr	r1, [r6, #0]
      current_omega_right = -count_to_rad / delta_time_right;
     aa4:	e9d5 2300 	ldrd	r2, r3, [r5]
    if (direction_indicator_right == 1) {
      right_count_tick += 1;
      current_omega_right = count_to_rad / delta_time_right;
    }
    if (direction_indicator_right == 0) {
      right_count_tick += -1;
     aa8:	1e4c      	subs	r4, r1, #1
      current_omega_right = -count_to_rad / delta_time_right;
     aaa:	a10d      	add	r1, pc, #52	; (adr r1, ae0 <encoder_count_chage_right()+0x148>)
     aac:	e9d1 0100 	ldrd	r0, r1, [r1]
    if (direction_indicator_right == 1) {
      right_count_tick += 1;
      current_omega_right = count_to_rad / delta_time_right;
    }
    if (direction_indicator_right == 0) {
      right_count_tick += -1;
     ab0:	6034      	str	r4, [r6, #0]
      current_omega_right = -count_to_rad / delta_time_right;
     ab2:	f009 f9f1 	bl	9e98 <__aeabi_ddiv>
     ab6:	f009 fb9d 	bl	a1f4 <__aeabi_d2f>
     aba:	4b12      	ldr	r3, [pc, #72]	; (b04 <encoder_count_chage_right()+0x16c>)
     abc:	ee07 0a90 	vmov	s15, r0
     ac0:	6018      	str	r0, [r3, #0]
     ac2:	e79b      	b.n	9fc <encoder_count_chage_right()+0x64>
void encoder_count_chage_right() {
  delta_time_right =  double(micros()) / 1000000 - old_time_right;
  old_time_right = double(micros()) / 1000000;
  if (encoder_counter_right < counts_per_revolution && encoder_counter_right > -counts_per_revolution) {
    if (direction_indicator_right == 1) {
      right_count_tick += 1;
     ac4:	4e15      	ldr	r6, [pc, #84]	; (b1c <encoder_count_chage_right()+0x184>)
     ac6:	6831      	ldr	r1, [r6, #0]
      current_omega_right = count_to_rad / delta_time_right;
     ac8:	e9d5 2300 	ldrd	r2, r3, [r5]
void encoder_count_chage_right() {
  delta_time_right =  double(micros()) / 1000000 - old_time_right;
  old_time_right = double(micros()) / 1000000;
  if (encoder_counter_right < counts_per_revolution && encoder_counter_right > -counts_per_revolution) {
    if (direction_indicator_right == 1) {
      right_count_tick += 1;
     acc:	1c4c      	adds	r4, r1, #1
      current_omega_right = count_to_rad / delta_time_right;
     ace:	a106      	add	r1, pc, #24	; (adr r1, ae8 <encoder_count_chage_right()+0x150>)
     ad0:	e9d1 0100 	ldrd	r0, r1, [r1]
     ad4:	e7ec      	b.n	ab0 <encoder_count_chage_right()+0x118>
     ad6:	bf00      	nop
     ad8:	00000000 	.word	0x00000000
     adc:	412e8480 	.word	0x412e8480
     ae0:	20000000 	.word	0x20000000
     ae4:	bf6aceea 	.word	0xbf6aceea
     ae8:	20000000 	.word	0x20000000
     aec:	3f6aceea 	.word	0x3f6aceea
     af0:	1fff1d40 	.word	0x1fff1d40
     af4:	1fff1460 	.word	0x1fff1460
     af8:	1fff1d30 	.word	0x1fff1d30
     afc:	409e0000 	.word	0x409e0000
     b00:	c09e0000 	.word	0xc09e0000
     b04:	1fff1d3c 	.word	0x1fff1d3c
     b08:	1fff22b0 	.word	0x1fff22b0
     b0c:	461c4000 	.word	0x461c4000
     b10:	00000000 	.word	0x00000000
     b14:	1fff148c 	.word	0x1fff148c
     b18:	1fff2298 	.word	0x1fff2298
     b1c:	1fff1488 	.word	0x1fff1488

00000b20 <encoder_count_chage_left()>:
    array_push(speed_array_right, current_omega_right);
  }
  average_omega_right = averaging_array(speed_array_right);
}

void encoder_count_chage_left() {
     b20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  delta_time_left = double(micros()) / 1000000 - old_time_left;
     b22:	f006 f877 	bl	6c14 <micros>
     b26:	4c54      	ldr	r4, [pc, #336]	; (c78 <encoder_count_chage_left()+0x158>)
     b28:	4d54      	ldr	r5, [pc, #336]	; (c7c <encoder_count_chage_left()+0x15c>)
     b2a:	f009 f815 	bl	9b58 <__aeabi_ui2d>
     b2e:	a34c      	add	r3, pc, #304	; (adr r3, c60 <encoder_count_chage_left()+0x140>)
     b30:	e9d3 2300 	ldrd	r2, r3, [r3]
     b34:	f009 f9b0 	bl	9e98 <__aeabi_ddiv>
     b38:	e9d4 2300 	ldrd	r2, r3, [r4]
     b3c:	f008 fece 	bl	98dc <__aeabi_dsub>
     b40:	e9c5 0100 	strd	r0, r1, [r5]
  old_time_left = double(micros()) / 1000000;
     b44:	f006 f866 	bl	6c14 <micros>
     b48:	f009 f806 	bl	9b58 <__aeabi_ui2d>
     b4c:	a344      	add	r3, pc, #272	; (adr r3, c60 <encoder_count_chage_left()+0x140>)
     b4e:	e9d3 2300 	ldrd	r2, r3, [r3]
     b52:	f009 f9a1 	bl	9e98 <__aeabi_ddiv>
  if (encoder_counter_left < counts_per_revolution && encoder_counter_left > -counts_per_revolution) {
     b56:	4b4a      	ldr	r3, [pc, #296]	; (c80 <encoder_count_chage_left()+0x160>)
     b58:	e9d3 6700 	ldrd	r6, r7, [r3]
  average_omega_right = averaging_array(speed_array_right);
}

void encoder_count_chage_left() {
  delta_time_left = double(micros()) / 1000000 - old_time_left;
  old_time_left = double(micros()) / 1000000;
     b5c:	e9c4 0100 	strd	r0, r1, [r4]
  if (encoder_counter_left < counts_per_revolution && encoder_counter_left > -counts_per_revolution) {
     b60:	2200      	movs	r2, #0
     b62:	4b48      	ldr	r3, [pc, #288]	; (c84 <encoder_count_chage_left()+0x164>)
     b64:	4630      	mov	r0, r6
     b66:	4639      	mov	r1, r7
     b68:	f009 fade 	bl	a128 <__aeabi_dcmplt>
     b6c:	b138      	cbz	r0, b7e <encoder_count_chage_left()+0x5e>
     b6e:	4630      	mov	r0, r6
     b70:	4639      	mov	r1, r7
     b72:	2200      	movs	r2, #0
     b74:	4b44      	ldr	r3, [pc, #272]	; (c88 <encoder_count_chage_left()+0x168>)
     b76:	f009 faf5 	bl	a164 <__aeabi_dcmpgt>
     b7a:	2800      	cmp	r0, #0
     b7c:	d14e      	bne.n	c1c <encoder_count_chage_left()+0xfc>
     b7e:	4b43      	ldr	r3, [pc, #268]	; (c8c <encoder_count_chage_left()+0x16c>)
     b80:	edd3 7a00 	vldr	s15, [r3]
      left_count_tick += -1;
      current_omega_left = -count_to_rad / delta_time_left;
    }
  }

  if (current_omega_left < 20 && current_omega_left > -20) {
     b84:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
     b88:	eef4 7ac7 	vcmpe.f32	s15, s14
     b8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     b90:	d506      	bpl.n	ba0 <encoder_count_chage_left()+0x80>
     b92:	eebb 7a04 	vmov.f32	s14, #180	; 0xc1a00000 -20.0
     b96:	eef4 7ac7 	vcmpe.f32	s15, s14
     b9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     b9e:	dc2c      	bgt.n	bfa <encoder_count_chage_left()+0xda>
     ba0:	4b3b      	ldr	r3, [pc, #236]	; (c90 <encoder_count_chage_left()+0x170>)
     ba2:	edd3 7a00 	vldr	s15, [r3]
}

float averaging_array(long the_input_array[]) {
  float result = 0;
  for (int x = 0; x < sizeof(the_input_array); x++) {
    result = result + (the_input_array[x] / float_to_long_factor);
     ba6:	eddf 6a3b 	vldr	s13, [pc, #236]	; c94 <encoder_count_chage_left()+0x174>
     baa:	ed93 6a01 	vldr	s12, [r3, #4]
     bae:	ed93 7a02 	vldr	s14, [r3, #8]
     bb2:	edd3 4a03 	vldr	s9, [r3, #12]
     bb6:	ed9f 4a38 	vldr	s8, [pc, #224]	; c98 <encoder_count_chage_left()+0x178>
  }

  if (current_omega_left < 20 && current_omega_left > -20) {
    array_push(speed_array_left, current_omega_left);
  }
  average_omega_left = averaging_array(speed_array_left);
     bba:	4b38      	ldr	r3, [pc, #224]	; (c9c <encoder_count_chage_left()+0x17c>)
}

float averaging_array(long the_input_array[]) {
  float result = 0;
  for (int x = 0; x < sizeof(the_input_array); x++) {
    result = result + (the_input_array[x] / float_to_long_factor);
     bbc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
     bc0:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
     bc4:	ee87 5aa6 	vdiv.f32	s10, s15, s13
     bc8:	eec6 5a26 	vdiv.f32	s11, s12, s13
     bcc:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
     bd0:	eef8 4ae4 	vcvt.f32.s32	s9, s9
     bd4:	ee87 6a26 	vdiv.f32	s12, s14, s13
     bd8:	ee84 7aa6 	vdiv.f32	s14, s9, s13
     bdc:	ee75 7a04 	vadd.f32	s15, s10, s8
  }

  if (current_omega_left < 20 && current_omega_left > -20) {
    array_push(speed_array_left, current_omega_left);
  }
  average_omega_left = averaging_array(speed_array_left);
     be0:	eef5 6a00 	vmov.f32	s13, #80	; 0x3e800000  0.250
}

float averaging_array(long the_input_array[]) {
  float result = 0;
  for (int x = 0; x < sizeof(the_input_array); x++) {
    result = result + (the_input_array[x] / float_to_long_factor);
     be4:	ee75 7aa7 	vadd.f32	s15, s11, s15
     be8:	ee76 7a27 	vadd.f32	s15, s12, s15
     bec:	ee77 7a27 	vadd.f32	s15, s14, s15
  }

  if (current_omega_left < 20 && current_omega_left > -20) {
    array_push(speed_array_left, current_omega_left);
  }
  average_omega_left = averaging_array(speed_array_left);
     bf0:	ee67 7aa6 	vmul.f32	s15, s15, s13
     bf4:	edc3 7a00 	vstr	s15, [r3]
     bf8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}


//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
     bfa:	4b25      	ldr	r3, [pc, #148]	; (c90 <encoder_count_chage_left()+0x170>)
  }
  the_input_array[0] = data * float_to_long_factor;
     bfc:	ed9f 7a25 	vldr	s14, [pc, #148]	; c94 <encoder_count_chage_left()+0x174>


//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
     c00:	681c      	ldr	r4, [r3, #0]
     c02:	1d18      	adds	r0, r3, #4
     c04:	c807      	ldmia	r0, {r0, r1, r2}
  }
  the_input_array[0] = data * float_to_long_factor;
     c06:	ee67 7a87 	vmul.f32	s15, s15, s14


//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
     c0a:	605c      	str	r4, [r3, #4]
  }
  the_input_array[0] = data * float_to_long_factor;
     c0c:	eefd 7ae7 	vcvt.s32.f32	s15, s15


//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
     c10:	6098      	str	r0, [r3, #8]
  }
  the_input_array[0] = data * float_to_long_factor;
     c12:	edc3 7a00 	vstr	s15, [r3]


//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
     c16:	60d9      	str	r1, [r3, #12]
     c18:	611a      	str	r2, [r3, #16]
     c1a:	e7c4      	b.n	ba6 <encoder_count_chage_left()+0x86>

void encoder_count_chage_left() {
  delta_time_left = double(micros()) / 1000000 - old_time_left;
  old_time_left = double(micros()) / 1000000;
  if (encoder_counter_left < counts_per_revolution && encoder_counter_left > -counts_per_revolution) {
    if (direction_indicator_left == 1) {
     c1c:	4b20      	ldr	r3, [pc, #128]	; (ca0 <encoder_count_chage_left()+0x180>)
     c1e:	681b      	ldr	r3, [r3, #0]
     c20:	2b01      	cmp	r3, #1
     c22:	d013      	beq.n	c4c <encoder_count_chage_left()+0x12c>
      left_count_tick += 1;
      current_omega_left = count_to_rad / delta_time_left;
    }
    if (direction_indicator_left == 0) {
     c24:	2b00      	cmp	r3, #0
     c26:	d1aa      	bne.n	b7e <encoder_count_chage_left()+0x5e>
      left_count_tick += -1;
     c28:	4e1e      	ldr	r6, [pc, #120]	; (ca4 <encoder_count_chage_left()+0x184>)
     c2a:	6831      	ldr	r1, [r6, #0]
      current_omega_left = -count_to_rad / delta_time_left;
     c2c:	e9d5 2300 	ldrd	r2, r3, [r5]
    if (direction_indicator_left == 1) {
      left_count_tick += 1;
      current_omega_left = count_to_rad / delta_time_left;
    }
    if (direction_indicator_left == 0) {
      left_count_tick += -1;
     c30:	1e4c      	subs	r4, r1, #1
      current_omega_left = -count_to_rad / delta_time_left;
     c32:	a10d      	add	r1, pc, #52	; (adr r1, c68 <encoder_count_chage_left()+0x148>)
     c34:	e9d1 0100 	ldrd	r0, r1, [r1]
    if (direction_indicator_left == 1) {
      left_count_tick += 1;
      current_omega_left = count_to_rad / delta_time_left;
    }
    if (direction_indicator_left == 0) {
      left_count_tick += -1;
     c38:	6034      	str	r4, [r6, #0]
      current_omega_left = -count_to_rad / delta_time_left;
     c3a:	f009 f92d 	bl	9e98 <__aeabi_ddiv>
     c3e:	f009 fad9 	bl	a1f4 <__aeabi_d2f>
     c42:	4b12      	ldr	r3, [pc, #72]	; (c8c <encoder_count_chage_left()+0x16c>)
     c44:	ee07 0a90 	vmov	s15, r0
     c48:	6018      	str	r0, [r3, #0]
     c4a:	e79b      	b.n	b84 <encoder_count_chage_left()+0x64>
void encoder_count_chage_left() {
  delta_time_left = double(micros()) / 1000000 - old_time_left;
  old_time_left = double(micros()) / 1000000;
  if (encoder_counter_left < counts_per_revolution && encoder_counter_left > -counts_per_revolution) {
    if (direction_indicator_left == 1) {
      left_count_tick += 1;
     c4c:	4e15      	ldr	r6, [pc, #84]	; (ca4 <encoder_count_chage_left()+0x184>)
     c4e:	6831      	ldr	r1, [r6, #0]
      current_omega_left = count_to_rad / delta_time_left;
     c50:	e9d5 2300 	ldrd	r2, r3, [r5]
void encoder_count_chage_left() {
  delta_time_left = double(micros()) / 1000000 - old_time_left;
  old_time_left = double(micros()) / 1000000;
  if (encoder_counter_left < counts_per_revolution && encoder_counter_left > -counts_per_revolution) {
    if (direction_indicator_left == 1) {
      left_count_tick += 1;
     c54:	1c4c      	adds	r4, r1, #1
      current_omega_left = count_to_rad / delta_time_left;
     c56:	a106      	add	r1, pc, #24	; (adr r1, c70 <encoder_count_chage_left()+0x150>)
     c58:	e9d1 0100 	ldrd	r0, r1, [r1]
     c5c:	e7ec      	b.n	c38 <encoder_count_chage_left()+0x118>
     c5e:	bf00      	nop
     c60:	00000000 	.word	0x00000000
     c64:	412e8480 	.word	0x412e8480
     c68:	20000000 	.word	0x20000000
     c6c:	bf6aceea 	.word	0xbf6aceea
     c70:	20000000 	.word	0x20000000
     c74:	3f6aceea 	.word	0x3f6aceea
     c78:	1fff2a80 	.word	0x1fff2a80
     c7c:	1fff2b68 	.word	0x1fff2b68
     c80:	1fff1498 	.word	0x1fff1498
     c84:	409e0000 	.word	0x409e0000
     c88:	c09e0000 	.word	0xc09e0000
     c8c:	1fff2bf0 	.word	0x1fff2bf0
     c90:	1fff14a8 	.word	0x1fff14a8
     c94:	461c4000 	.word	0x461c4000
     c98:	00000000 	.word	0x00000000
     c9c:	1fff1c90 	.word	0x1fff1c90
     ca0:	1fff1d60 	.word	0x1fff1d60
     ca4:	1fff2b98 	.word	0x1fff2b98

00000ca8 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const>:
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->ints_length >> (8 * 0)) & 0xFF;
     ca8:	6843      	ldr	r3, [r0, #4]
      floats_length(0), st_floats(), floats(nullptr),
      strings_length(0), st_strings(), strings(nullptr)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
     caa:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->ints_length >> (8 * 0)) & 0xFF;
     cae:	700b      	strb	r3, [r1, #0]
      *(outbuffer + offset + 1) = (this->ints_length >> (8 * 1)) & 0xFF;
     cb0:	6843      	ldr	r3, [r0, #4]
     cb2:	0a1b      	lsrs	r3, r3, #8
     cb4:	704b      	strb	r3, [r1, #1]
      *(outbuffer + offset + 2) = (this->ints_length >> (8 * 2)) & 0xFF;
     cb6:	88c3      	ldrh	r3, [r0, #6]
     cb8:	708b      	strb	r3, [r1, #2]
      *(outbuffer + offset + 3) = (this->ints_length >> (8 * 3)) & 0xFF;
     cba:	79c3      	ldrb	r3, [r0, #7]
     cbc:	70cb      	strb	r3, [r1, #3]
      offset += sizeof(this->ints_length);
      for( uint32_t i = 0; i < ints_length; i++){
     cbe:	6843      	ldr	r3, [r0, #4]
     cc0:	2b00      	cmp	r3, #0
     cc2:	f000 8085 	beq.w	dd0 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0x128>
     cc6:	460a      	mov	r2, r1
     cc8:	2500      	movs	r5, #0
     cca:	2604      	movs	r6, #4
      union {
        int32_t real;
        uint32_t base;
      } u_intsi;
      u_intsi.real = this->ints[i];
     ccc:	68c3      	ldr	r3, [r0, #12]
     cce:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
      *(outbuffer + offset + 0) = (u_intsi.base >> (8 * 0)) & 0xFF;
     cd2:	7113      	strb	r3, [r2, #4]
      *(outbuffer + offset + 1) = (u_intsi.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_intsi.base >> (8 * 2)) & 0xFF;
     cd4:	0c1c      	lsrs	r4, r3, #16
        int32_t real;
        uint32_t base;
      } u_intsi;
      u_intsi.real = this->ints[i];
      *(outbuffer + offset + 0) = (u_intsi.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_intsi.base >> (8 * 1)) & 0xFF;
     cd6:	0a1f      	lsrs	r7, r3, #8
      *(outbuffer + offset + 2) = (u_intsi.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_intsi.base >> (8 * 3)) & 0xFF;
     cd8:	0e1b      	lsrs	r3, r3, #24
        uint32_t base;
      } u_intsi;
      u_intsi.real = this->ints[i];
      *(outbuffer + offset + 0) = (u_intsi.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_intsi.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_intsi.base >> (8 * 2)) & 0xFF;
     cda:	7194      	strb	r4, [r2, #6]
        int32_t real;
        uint32_t base;
      } u_intsi;
      u_intsi.real = this->ints[i];
      *(outbuffer + offset + 0) = (u_intsi.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_intsi.base >> (8 * 1)) & 0xFF;
     cdc:	7157      	strb	r7, [r2, #5]
      *(outbuffer + offset + 2) = (u_intsi.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_intsi.base >> (8 * 3)) & 0xFF;
     cde:	71d3      	strb	r3, [r2, #7]
      *(outbuffer + offset + 0) = (this->ints_length >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->ints_length >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (this->ints_length >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (this->ints_length >> (8 * 3)) & 0xFF;
      offset += sizeof(this->ints_length);
      for( uint32_t i = 0; i < ints_length; i++){
     ce0:	6843      	ldr	r3, [r0, #4]
     ce2:	3501      	adds	r5, #1
     ce4:	42ab      	cmp	r3, r5
     ce6:	4634      	mov	r4, r6
     ce8:	f102 0204 	add.w	r2, r2, #4
     cec:	f106 0604 	add.w	r6, r6, #4
     cf0:	d8ec      	bhi.n	ccc <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0x24>
     cf2:	f104 0208 	add.w	r2, r4, #8
     cf6:	f104 0a05 	add.w	sl, r4, #5
     cfa:	f104 0906 	add.w	r9, r4, #6
     cfe:	f104 0807 	add.w	r8, r4, #7
     d02:	f104 0c09 	add.w	ip, r4, #9
     d06:	f104 0e0a 	add.w	lr, r4, #10
     d0a:	f104 050b 	add.w	r5, r4, #11
     d0e:	4617      	mov	r7, r2
     d10:	340c      	adds	r4, #12
      *(outbuffer + offset + 1) = (u_intsi.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_intsi.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_intsi.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->ints[i]);
      }
      *(outbuffer + offset + 0) = (this->floats_length >> (8 * 0)) & 0xFF;
     d12:	6903      	ldr	r3, [r0, #16]
     d14:	558b      	strb	r3, [r1, r6]
      *(outbuffer + offset + 1) = (this->floats_length >> (8 * 1)) & 0xFF;
     d16:	6903      	ldr	r3, [r0, #16]
     d18:	0a1b      	lsrs	r3, r3, #8
     d1a:	f801 300a 	strb.w	r3, [r1, sl]
      *(outbuffer + offset + 2) = (this->floats_length >> (8 * 2)) & 0xFF;
     d1e:	8a43      	ldrh	r3, [r0, #18]
     d20:	f801 3009 	strb.w	r3, [r1, r9]
      *(outbuffer + offset + 3) = (this->floats_length >> (8 * 3)) & 0xFF;
     d24:	7cc3      	ldrb	r3, [r0, #19]
     d26:	f801 3008 	strb.w	r3, [r1, r8]
      offset += sizeof(this->floats_length);
      for( uint32_t i = 0; i < floats_length; i++){
     d2a:	6903      	ldr	r3, [r0, #16]
     d2c:	b1f3      	cbz	r3, d6c <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0xc4>
     d2e:	eb01 0e07 	add.w	lr, r1, r7
     d32:	4675      	mov	r5, lr
     d34:	2200      	movs	r2, #0
      union {
        float real;
        uint32_t base;
      } u_floatsi;
      u_floatsi.real = this->floats[i];
     d36:	6983      	ldr	r3, [r0, #24]
      *(outbuffer + offset + 0) = (u_floatsi.base >> (8 * 0)) & 0xFF;
     d38:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
     d3c:	f80e 3022 	strb.w	r3, [lr, r2, lsl #2]
      *(outbuffer + offset + 1) = (u_floatsi.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_floatsi.base >> (8 * 2)) & 0xFF;
     d40:	0c1c      	lsrs	r4, r3, #16
        float real;
        uint32_t base;
      } u_floatsi;
      u_floatsi.real = this->floats[i];
      *(outbuffer + offset + 0) = (u_floatsi.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_floatsi.base >> (8 * 1)) & 0xFF;
     d42:	0a1e      	lsrs	r6, r3, #8
      *(outbuffer + offset + 2) = (u_floatsi.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_floatsi.base >> (8 * 3)) & 0xFF;
     d44:	0e1b      	lsrs	r3, r3, #24
        uint32_t base;
      } u_floatsi;
      u_floatsi.real = this->floats[i];
      *(outbuffer + offset + 0) = (u_floatsi.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_floatsi.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_floatsi.base >> (8 * 2)) & 0xFF;
     d46:	70ac      	strb	r4, [r5, #2]
        float real;
        uint32_t base;
      } u_floatsi;
      u_floatsi.real = this->floats[i];
      *(outbuffer + offset + 0) = (u_floatsi.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_floatsi.base >> (8 * 1)) & 0xFF;
     d48:	706e      	strb	r6, [r5, #1]
      *(outbuffer + offset + 2) = (u_floatsi.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_floatsi.base >> (8 * 3)) & 0xFF;
     d4a:	70eb      	strb	r3, [r5, #3]
      *(outbuffer + offset + 0) = (this->floats_length >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->floats_length >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (this->floats_length >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (this->floats_length >> (8 * 3)) & 0xFF;
      offset += sizeof(this->floats_length);
      for( uint32_t i = 0; i < floats_length; i++){
     d4c:	6903      	ldr	r3, [r0, #16]
     d4e:	3201      	adds	r2, #1
     d50:	4293      	cmp	r3, r2
     d52:	463c      	mov	r4, r7
     d54:	f105 0504 	add.w	r5, r5, #4
     d58:	f107 0704 	add.w	r7, r7, #4
     d5c:	d8eb      	bhi.n	d36 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0x8e>
     d5e:	f104 0c05 	add.w	ip, r4, #5
     d62:	f104 0e06 	add.w	lr, r4, #6
     d66:	1de5      	adds	r5, r4, #7
     d68:	463a      	mov	r2, r7
     d6a:	3408      	adds	r4, #8
      *(outbuffer + offset + 1) = (u_floatsi.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_floatsi.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_floatsi.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->floats[i]);
      }
      *(outbuffer + offset + 0) = (this->strings_length >> (8 * 0)) & 0xFF;
     d6c:	69c3      	ldr	r3, [r0, #28]
     d6e:	548b      	strb	r3, [r1, r2]
      *(outbuffer + offset + 1) = (this->strings_length >> (8 * 1)) & 0xFF;
     d70:	69c3      	ldr	r3, [r0, #28]
     d72:	0a1b      	lsrs	r3, r3, #8
     d74:	f801 300c 	strb.w	r3, [r1, ip]
      *(outbuffer + offset + 2) = (this->strings_length >> (8 * 2)) & 0xFF;
     d78:	8bc3      	ldrh	r3, [r0, #30]
     d7a:	f801 300e 	strb.w	r3, [r1, lr]
      *(outbuffer + offset + 3) = (this->strings_length >> (8 * 3)) & 0xFF;
     d7e:	7fc3      	ldrb	r3, [r0, #31]
     d80:	554b      	strb	r3, [r1, r5]
      offset += sizeof(this->strings_length);
      for( uint32_t i = 0; i < strings_length; i++){
     d82:	69c3      	ldr	r3, [r0, #28]
     d84:	b30b      	cbz	r3, dca <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0x122>
     d86:	460f      	mov	r7, r1
     d88:	4680      	mov	r8, r0
     d8a:	2600      	movs	r6, #0
      uint32_t length_stringsi = strlen(this->strings[i]);
     d8c:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
     d90:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
     d94:	f00a fcf4 	bl	b780 <strlen>
     d98:	00b1      	lsls	r1, r6, #2
     d9a:	4605      	mov	r5, r0
     d9c:	193a      	adds	r2, r7, r4
      varToArr(outbuffer + offset, length_stringsi);
     d9e:	2300      	movs	r3, #0
  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
      arr[i] = (var >> (8 * i));
     da0:	fa25 f003 	lsr.w	r0, r5, r3
     da4:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
     da6:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
     da8:	f802 0b01 	strb.w	r0, [r2], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
     dac:	d1f8      	bne.n	da0 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0xf8>
      offset += 4;
      memcpy(outbuffer + offset, this->strings[i], length_stringsi);
     dae:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
     db2:	3404      	adds	r4, #4
     db4:	1938      	adds	r0, r7, r4
     db6:	5859      	ldr	r1, [r3, r1]
     db8:	462a      	mov	r2, r5
     dba:	f005 fb3f 	bl	643c <memcpy>
      *(outbuffer + offset + 0) = (this->strings_length >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->strings_length >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (this->strings_length >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (this->strings_length >> (8 * 3)) & 0xFF;
      offset += sizeof(this->strings_length);
      for( uint32_t i = 0; i < strings_length; i++){
     dbe:	f8d8 301c 	ldr.w	r3, [r8, #28]
     dc2:	3601      	adds	r6, #1
     dc4:	42b3      	cmp	r3, r6
      uint32_t length_stringsi = strlen(this->strings[i]);
      varToArr(outbuffer + offset, length_stringsi);
      offset += 4;
      memcpy(outbuffer + offset, this->strings[i], length_stringsi);
      offset += length_stringsi;
     dc6:	442c      	add	r4, r5
      *(outbuffer + offset + 0) = (this->strings_length >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->strings_length >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (this->strings_length >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (this->strings_length >> (8 * 3)) & 0xFF;
      offset += sizeof(this->strings_length);
      for( uint32_t i = 0; i < strings_length; i++){
     dc8:	d8e0      	bhi.n	d8c <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0xe4>
      offset += 4;
      memcpy(outbuffer + offset, this->strings[i], length_stringsi);
      offset += length_stringsi;
      }
      return offset;
    }
     dca:	4620      	mov	r0, r4
     dcc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      *(outbuffer + offset + 0) = (this->ints_length >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->ints_length >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (this->ints_length >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (this->ints_length >> (8 * 3)) & 0xFF;
      offset += sizeof(this->ints_length);
      for( uint32_t i = 0; i < ints_length; i++){
     dd0:	2208      	movs	r2, #8
     dd2:	4617      	mov	r7, r2
     dd4:	240c      	movs	r4, #12
     dd6:	250b      	movs	r5, #11
     dd8:	f04f 0e0a 	mov.w	lr, #10
     ddc:	f04f 0c09 	mov.w	ip, #9
     de0:	f04f 0807 	mov.w	r8, #7
     de4:	f04f 0906 	mov.w	r9, #6
     de8:	f04f 0a05 	mov.w	sl, #5
     dec:	2604      	movs	r6, #4
     dee:	e790      	b.n	d12 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0x6a>

00000df0 <rosserial_msgs::Log::serialize(unsigned char*) const>:
      level(0),
      msg("")
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
     df0:	b570      	push	{r4, r5, r6, lr}
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
     df2:	7903      	ldrb	r3, [r0, #4]
     df4:	700b      	strb	r3, [r1, #0]
      level(0),
      msg("")
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
     df6:	4606      	mov	r6, r0
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
     df8:	6880      	ldr	r0, [r0, #8]
      level(0),
      msg("")
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
     dfa:	460d      	mov	r5, r1
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
     dfc:	f00a fcc0 	bl	b780 <strlen>
     e00:	462a      	mov	r2, r5
     e02:	4604      	mov	r4, r0
     e04:	2300      	movs	r3, #0
      arr[i] = (var >> (8 * i));
     e06:	fa24 f103 	lsr.w	r1, r4, r3
     e0a:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
     e0c:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
     e0e:	f802 1f01 	strb.w	r1, [r2, #1]!

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
     e12:	d1f8      	bne.n	e06 <rosserial_msgs::Log::serialize(unsigned char*) const+0x16>
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
     e14:	68b1      	ldr	r1, [r6, #8]
     e16:	1d68      	adds	r0, r5, #5
     e18:	4622      	mov	r2, r4
     e1a:	f005 fb0f 	bl	643c <memcpy>
      offset += length_msg;
      return offset;
    }
     e1e:	1d60      	adds	r0, r4, #5
     e20:	bd70      	pop	{r4, r5, r6, pc}
     e22:	bf00      	nop

00000e24 <rosserial_msgs::TopicInfo::serialize(unsigned char*) const>:
      md5sum(""),
      buffer_size(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
     e24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
     e26:	8883      	ldrh	r3, [r0, #4]
     e28:	700b      	strb	r3, [r1, #0]
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
     e2a:	8883      	ldrh	r3, [r0, #4]
     e2c:	0a1b      	lsrs	r3, r3, #8
     e2e:	704b      	strb	r3, [r1, #1]
      md5sum(""),
      buffer_size(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
     e30:	4606      	mov	r6, r0
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
     e32:	6880      	ldr	r0, [r0, #8]
      md5sum(""),
      buffer_size(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
     e34:	460d      	mov	r5, r1
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
     e36:	f00a fca3 	bl	b780 <strlen>
      arr[i] = (var >> (8 * i));
     e3a:	0e03      	lsrs	r3, r0, #24
     e3c:	0a01      	lsrs	r1, r0, #8
     e3e:	0c02      	lsrs	r2, r0, #16
     e40:	716b      	strb	r3, [r5, #5]
     e42:	70a8      	strb	r0, [r5, #2]
     e44:	712a      	strb	r2, [r5, #4]
     e46:	70e9      	strb	r1, [r5, #3]
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
     e48:	4602      	mov	r2, r0
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
     e4a:	4604      	mov	r4, r0
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
     e4c:	68b1      	ldr	r1, [r6, #8]
     e4e:	1da8      	adds	r0, r5, #6
     e50:	f005 faf4 	bl	643c <memcpy>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
     e54:	68f0      	ldr	r0, [r6, #12]
     e56:	f00a fc93 	bl	b780 <strlen>
     e5a:	1d61      	adds	r1, r4, #5
     e5c:	4602      	mov	r2, r0
     e5e:	4429      	add	r1, r5
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
     e60:	3406      	adds	r4, #6
      uint32_t length_message_type = strlen(this->message_type);
     e62:	2300      	movs	r3, #0
     e64:	fa22 f003 	lsr.w	r0, r2, r3
     e68:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
     e6a:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
     e6c:	f801 0f01 	strb.w	r0, [r1, #1]!

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
     e70:	d1f8      	bne.n	e64 <rosserial_msgs::TopicInfo::serialize(unsigned char*) const+0x40>
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
     e72:	3404      	adds	r4, #4
     e74:	1928      	adds	r0, r5, r4
     e76:	68f1      	ldr	r1, [r6, #12]
      offset += length_message_type;
     e78:	4414      	add	r4, r2
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
     e7a:	f005 fadf 	bl	643c <memcpy>
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
     e7e:	6930      	ldr	r0, [r6, #16]
     e80:	f00a fc7e 	bl	b780 <strlen>
     e84:	192a      	adds	r2, r5, r4
     e86:	4607      	mov	r7, r0
     e88:	2300      	movs	r3, #0
      arr[i] = (var >> (8 * i));
     e8a:	fa27 f103 	lsr.w	r1, r7, r3
     e8e:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
     e90:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
     e92:	f802 1b01 	strb.w	r1, [r2], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
     e96:	d1f8      	bne.n	e8a <rosserial_msgs::TopicInfo::serialize(unsigned char*) const+0x66>
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
     e98:	3404      	adds	r4, #4
     e9a:	1928      	adds	r0, r5, r4
     e9c:	463a      	mov	r2, r7
     e9e:	6931      	ldr	r1, [r6, #16]
     ea0:	f005 facc 	bl	643c <memcpy>
      offset += length_md5sum;
     ea4:	1938      	adds	r0, r7, r4
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
     ea6:	6973      	ldr	r3, [r6, #20]
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
     ea8:	542b      	strb	r3, [r5, r0]
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
     eaa:	4405      	add	r5, r0
     eac:	0a19      	lsrs	r1, r3, #8
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
     eae:	0c1a      	lsrs	r2, r3, #16
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
     eb0:	0e1b      	lsrs	r3, r3, #24
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
     eb2:	7069      	strb	r1, [r5, #1]
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
     eb4:	70aa      	strb	r2, [r5, #2]
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
     eb6:	70eb      	strb	r3, [r5, #3]
      offset += sizeof(this->buffer_size);
      return offset;
    }
     eb8:	3004      	adds	r0, #4
     eba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00000ebc <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
     ebc:	4608      	mov	r0, r1
     ebe:	4611      	mov	r1, r2
     ec0:	f006 bdd4 	b.w	7a6c <usb_serial_write>

00000ec4 <usb_serial_class::read()>:
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
     ec4:	f006 bd6c 	b.w	79a0 <usb_serial_getchar>

00000ec8 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)>:
      offset += length_stringsi;
      }
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     ec8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    {
      int offset = 0;
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
     ecc:	780a      	ldrb	r2, [r1, #0]
     ece:	784b      	ldrb	r3, [r1, #1]
     ed0:	788c      	ldrb	r4, [r1, #2]
      offset += length_stringsi;
      }
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     ed2:	4605      	mov	r5, r0
    {
      int offset = 0;
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
     ed4:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
     ed8:	78c8      	ldrb	r0, [r1, #3]
      offset += length_stringsi;
      }
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     eda:	460e      	mov	r6, r1
    {
      int offset = 0;
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
     edc:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
     ee0:	6869      	ldr	r1, [r5, #4]
    {
      int offset = 0;
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
     ee2:	ea43 6400 	orr.w	r4, r3, r0, lsl #24
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
     ee6:	428c      	cmp	r4, r1
      offset += length_stringsi;
      }
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     ee8:	b083      	sub	sp, #12
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
     eea:	f200 80ba 	bhi.w	1062 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x19a>
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
      ints_length = ints_lengthT;
     eee:	606c      	str	r4, [r5, #4]
      for( uint32_t i = 0; i < ints_length; i++){
     ef0:	2c00      	cmp	r4, #0
     ef2:	f000 80bf 	beq.w	1074 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x1ac>
     ef6:	f105 0908 	add.w	r9, r5, #8
     efa:	4634      	mov	r4, r6
     efc:	2700      	movs	r7, #0
     efe:	f04f 0804 	mov.w	r8, #4
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
     f02:	79a1      	ldrb	r1, [r4, #6]
     f04:	7963      	ldrb	r3, [r4, #5]
     f06:	7922      	ldrb	r2, [r4, #4]
     f08:	f894 e007 	ldrb.w	lr, [r4, #7]
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
     f0c:	68e8      	ldr	r0, [r5, #12]
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
     f0e:	0409      	lsls	r1, r1, #16
     f10:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
     f14:	4313      	orrs	r3, r2
     f16:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
     f1a:	60ab      	str	r3, [r5, #8]
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
     f1c:	eb00 0087 	add.w	r0, r0, r7, lsl #2
     f20:	2204      	movs	r2, #4
     f22:	4649      	mov	r1, r9
     f24:	f005 fa8a 	bl	643c <memcpy>
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
      ints_length = ints_lengthT;
      for( uint32_t i = 0; i < ints_length; i++){
     f28:	686b      	ldr	r3, [r5, #4]
     f2a:	3701      	adds	r7, #1
     f2c:	42bb      	cmp	r3, r7
     f2e:	4642      	mov	r2, r8
     f30:	f104 0404 	add.w	r4, r4, #4
     f34:	f108 0804 	add.w	r8, r8, #4
     f38:	d8e3      	bhi.n	f02 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x3a>
     f3a:	f102 0708 	add.w	r7, r2, #8
     f3e:	4641      	mov	r1, r8
     f40:	46b9      	mov	r9, r7
     f42:	f102 0e05 	add.w	lr, r2, #5
     f46:	1d90      	adds	r0, r2, #6
     f48:	1dd3      	adds	r3, r2, #7
     f4a:	f102 0b09 	add.w	fp, r2, #9
     f4e:	f102 080a 	add.w	r8, r2, #10
     f52:	f102 0a0b 	add.w	sl, r2, #11
     f56:	f102 040c 	add.w	r4, r2, #12
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
     f5a:	5c30      	ldrb	r0, [r6, r0]
     f5c:	f816 200e 	ldrb.w	r2, [r6, lr]
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
     f60:	5c71      	ldrb	r1, [r6, r1]
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
     f62:	f816 e003 	ldrb.w	lr, [r6, r3]
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
     f66:	692b      	ldr	r3, [r5, #16]
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
     f68:	0400      	lsls	r0, r0, #16
     f6a:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
     f6e:	430a      	orrs	r2, r1
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
     f70:	ea42 620e 	orr.w	r2, r2, lr, lsl #24
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
     f74:	429a      	cmp	r2, r3
     f76:	f200 8092 	bhi.w	109e <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x1d6>
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
      floats_length = floats_lengthT;
     f7a:	612a      	str	r2, [r5, #16]
      for( uint32_t i = 0; i < floats_length; i++){
     f7c:	b34a      	cbz	r2, fd2 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x10a>
     f7e:	f105 0a14 	add.w	sl, r5, #20
     f82:	eb06 0709 	add.w	r7, r6, r9
     f86:	f04f 0800 	mov.w	r8, #0
      } u_st_floats;
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
     f8a:	78b9      	ldrb	r1, [r7, #2]
     f8c:	787b      	ldrb	r3, [r7, #1]
     f8e:	783a      	ldrb	r2, [r7, #0]
     f90:	78fc      	ldrb	r4, [r7, #3]
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
     f92:	69a8      	ldr	r0, [r5, #24]
      } u_st_floats;
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
     f94:	0409      	lsls	r1, r1, #16
     f96:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
     f9a:	4313      	orrs	r3, r2
      this->st_floats = u_st_floats.real;
     f9c:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
     fa0:	616b      	str	r3, [r5, #20]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
     fa2:	eb00 0088 	add.w	r0, r0, r8, lsl #2
     fa6:	2204      	movs	r2, #4
     fa8:	4651      	mov	r1, sl
     faa:	f005 fa47 	bl	643c <memcpy>
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
      floats_length = floats_lengthT;
      for( uint32_t i = 0; i < floats_length; i++){
     fae:	692b      	ldr	r3, [r5, #16]
     fb0:	f108 0801 	add.w	r8, r8, #1
     fb4:	4543      	cmp	r3, r8
     fb6:	464c      	mov	r4, r9
     fb8:	f107 0704 	add.w	r7, r7, #4
     fbc:	f109 0904 	add.w	r9, r9, #4
     fc0:	d8e3      	bhi.n	f8a <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0xc2>
     fc2:	f104 0b05 	add.w	fp, r4, #5
     fc6:	f104 0806 	add.w	r8, r4, #6
     fca:	f104 0a07 	add.w	sl, r4, #7
     fce:	464f      	mov	r7, r9
     fd0:	3408      	adds	r4, #8
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
     fd2:	f816 2008 	ldrb.w	r2, [r6, r8]
     fd6:	f816 000b 	ldrb.w	r0, [r6, fp]
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
     fda:	5df3      	ldrb	r3, [r6, r7]
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
     fdc:	f816 700a 	ldrb.w	r7, [r6, sl]
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
     fe0:	69e9      	ldr	r1, [r5, #28]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
     fe2:	0412      	lsls	r2, r2, #16
     fe4:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
     fe8:	4313      	orrs	r3, r2
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
     fea:	ea43 6707 	orr.w	r7, r3, r7, lsl #24
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
     fee:	428f      	cmp	r7, r1
     ff0:	d84f      	bhi.n	1092 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x1ca>
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      strings_length = strings_lengthT;
     ff2:	61ef      	str	r7, [r5, #28]
      for( uint32_t i = 0; i < strings_length; i++){
     ff4:	b38f      	cbz	r7, 105a <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x192>
     ff6:	f04f 0900 	mov.w	r9, #0
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
     ffa:	46c8      	mov	r8, r9
     ffc:	f105 0720 	add.w	r7, r5, #32
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
      uint32_t length_st_strings;
      arrToVar(length_st_strings, (inbuffer + offset));
    1000:	2300      	movs	r3, #0

  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    1002:	469e      	mov	lr, r3
    1004:	1931      	adds	r1, r6, r4
    for (size_t i = 0; i < sizeof(V); i++)
      var |= (arr[i] << (8 * i));
    1006:	f811 2b01 	ldrb.w	r2, [r1], #1
    100a:	409a      	lsls	r2, r3
    100c:	3308      	adds	r3, #8
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
    100e:	2b20      	cmp	r3, #32
      var |= (arr[i] << (8 * i));
    1010:	ea4e 0e02 	orr.w	lr, lr, r2
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
    1014:	d1f7      	bne.n	1006 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x13e>
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
    1016:	1d20      	adds	r0, r4, #4
    1018:	4486      	add	lr, r0
    101a:	4570      	cmp	r0, lr
    101c:	d209      	bcs.n	1032 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x16a>
    101e:	1ce3      	adds	r3, r4, #3
    1020:	4433      	add	r3, r6
    1022:	4602      	mov	r2, r0
    1024:	3201      	adds	r2, #1
          inbuffer[k-1]=inbuffer[k];
    1026:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    102a:	f803 1c01 	strb.w	r1, [r3, #-1]
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
      uint32_t length_st_strings;
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
    102e:	4572      	cmp	r2, lr
    1030:	d3f8      	bcc.n	1024 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x15c>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    1032:	eb06 020e 	add.w	r2, r6, lr
      this->st_strings = (char *)(inbuffer + offset-1);
    1036:	1e43      	subs	r3, r0, #1
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    1038:	f802 8c01 	strb.w	r8, [r2, #-1]
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    103c:	6a68      	ldr	r0, [r5, #36]	; 0x24
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
    103e:	4433      	add	r3, r6
    1040:	622b      	str	r3, [r5, #32]
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    1042:	eb00 0089 	add.w	r0, r0, r9, lsl #2
    1046:	2204      	movs	r2, #4
    1048:	4639      	mov	r1, r7
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
    104a:	4674      	mov	r4, lr
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    104c:	f005 f9f6 	bl	643c <memcpy>
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
    1050:	69eb      	ldr	r3, [r5, #28]
    1052:	f109 0901 	add.w	r9, r9, #1
    1056:	454b      	cmp	r3, r9
    1058:	d8d2      	bhi.n	1000 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x138>
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
      }
     return offset;
    }
    105a:	4620      	mov	r0, r4
    105c:	b003      	add	sp, #12
    105e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
    1062:	00a1      	lsls	r1, r4, #2
    1064:	68e8      	ldr	r0, [r5, #12]
    1066:	f009 ff99 	bl	af9c <realloc>
      ints_length = ints_lengthT;
    106a:	606c      	str	r4, [r5, #4]
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
    106c:	60e8      	str	r0, [r5, #12]
      ints_length = ints_lengthT;
      for( uint32_t i = 0; i < ints_length; i++){
    106e:	2c00      	cmp	r4, #0
    1070:	f47f af41 	bne.w	ef6 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x2e>
    1074:	2708      	movs	r7, #8
    1076:	46b9      	mov	r9, r7
    1078:	240c      	movs	r4, #12
    107a:	f04f 0a0b 	mov.w	sl, #11
    107e:	f04f 080a 	mov.w	r8, #10
    1082:	f04f 0b09 	mov.w	fp, #9
    1086:	2307      	movs	r3, #7
    1088:	2006      	movs	r0, #6
    108a:	f04f 0e05 	mov.w	lr, #5
    108e:	2104      	movs	r1, #4
    1090:	e763      	b.n	f5a <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x92>
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
    1092:	00b9      	lsls	r1, r7, #2
    1094:	6a68      	ldr	r0, [r5, #36]	; 0x24
    1096:	f009 ff81 	bl	af9c <realloc>
    109a:	6268      	str	r0, [r5, #36]	; 0x24
    109c:	e7a9      	b.n	ff2 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x12a>
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
    109e:	0091      	lsls	r1, r2, #2
    10a0:	69a8      	ldr	r0, [r5, #24]
    10a2:	9201      	str	r2, [sp, #4]
    10a4:	f009 ff7a 	bl	af9c <realloc>
    10a8:	9a01      	ldr	r2, [sp, #4]
    10aa:	61a8      	str	r0, [r5, #24]
    10ac:	e765      	b.n	f7a <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0xb2>
    10ae:	bf00      	nop

000010b0 <geometry_msgs::Twist::serialize(unsigned char*) const>:
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    10b0:	6902      	ldr	r2, [r0, #16]
    10b2:	6943      	ldr	r3, [r0, #20]
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
    10b4:	710b      	strb	r3, [r1, #4]
      linear(),
      angular()
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
    10b6:	b4f0      	push	{r4, r5, r6, r7}
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
    10b8:	0a14      	lsrs	r4, r2, #8
    10ba:	704c      	strb	r4, [r1, #1]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    10bc:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    10be:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    10c0:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    10c2:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    10c4:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    10c6:	708f      	strb	r7, [r1, #2]
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    10c8:	70ce      	strb	r6, [r1, #3]
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    10ca:	714d      	strb	r5, [r1, #5]
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    10cc:	718c      	strb	r4, [r1, #6]
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    10ce:	700a      	strb	r2, [r1, #0]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    10d0:	71cb      	strb	r3, [r1, #7]
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    10d2:	6982      	ldr	r2, [r0, #24]
    10d4:	69c3      	ldr	r3, [r0, #28]
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
    10d6:	730b      	strb	r3, [r1, #12]
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    10d8:	0a14      	lsrs	r4, r2, #8
    10da:	724c      	strb	r4, [r1, #9]
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    10dc:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    10de:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    10e0:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    10e2:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    10e4:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    10e6:	728f      	strb	r7, [r1, #10]
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    10e8:	72ce      	strb	r6, [r1, #11]
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    10ea:	734d      	strb	r5, [r1, #13]
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    10ec:	738c      	strb	r4, [r1, #14]
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    10ee:	720a      	strb	r2, [r1, #8]
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    10f0:	73cb      	strb	r3, [r1, #15]
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    10f2:	6a02      	ldr	r2, [r0, #32]
    10f4:	6a43      	ldr	r3, [r0, #36]	; 0x24
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
    10f6:	750b      	strb	r3, [r1, #20]
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    10f8:	0a14      	lsrs	r4, r2, #8
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    10fa:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    10fc:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    10fe:	0a1d      	lsrs	r5, r3, #8
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    1100:	744c      	strb	r4, [r1, #17]
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    1102:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    1104:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    1106:	748f      	strb	r7, [r1, #18]
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    1108:	74ce      	strb	r6, [r1, #19]
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    110a:	754d      	strb	r5, [r1, #21]
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    110c:	758c      	strb	r4, [r1, #22]
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    110e:	740a      	strb	r2, [r1, #16]
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    1110:	75cb      	strb	r3, [r1, #23]
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    1112:	6b03      	ldr	r3, [r0, #48]	; 0x30
    1114:	6b42      	ldr	r2, [r0, #52]	; 0x34
    1116:	760b      	strb	r3, [r1, #24]
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
    1118:	0a1c      	lsrs	r4, r3, #8
    111a:	764c      	strb	r4, [r1, #25]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    111c:	0c1f      	lsrs	r7, r3, #16
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    111e:	0a16      	lsrs	r6, r2, #8
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    1120:	0c15      	lsrs	r5, r2, #16
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    1122:	0e14      	lsrs	r4, r2, #24
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    1124:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    1126:	768f      	strb	r7, [r1, #26]
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    1128:	774e      	strb	r6, [r1, #29]
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    112a:	778d      	strb	r5, [r1, #30]
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    112c:	77cc      	strb	r4, [r1, #31]
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
    112e:	770a      	strb	r2, [r1, #28]
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    1130:	76cb      	strb	r3, [r1, #27]
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    1132:	6b82      	ldr	r2, [r0, #56]	; 0x38
    1134:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
    1136:	f881 3024 	strb.w	r3, [r1, #36]	; 0x24
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    113a:	0a14      	lsrs	r4, r2, #8
    113c:	f881 4021 	strb.w	r4, [r1, #33]	; 0x21
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    1140:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    1142:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    1144:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    1146:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    1148:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    114a:	f881 7022 	strb.w	r7, [r1, #34]	; 0x22
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    114e:	f881 6023 	strb.w	r6, [r1, #35]	; 0x23
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    1152:	f881 5025 	strb.w	r5, [r1, #37]	; 0x25
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    1156:	f881 4026 	strb.w	r4, [r1, #38]	; 0x26
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    115a:	f881 2020 	strb.w	r2, [r1, #32]
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    115e:	f881 3027 	strb.w	r3, [r1, #39]	; 0x27
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    1162:	6c02      	ldr	r2, [r0, #64]	; 0x40
    1164:	6c43      	ldr	r3, [r0, #68]	; 0x44
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
    1166:	f881 302c 	strb.w	r3, [r1, #44]	; 0x2c
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    116a:	0a1c      	lsrs	r4, r3, #8
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    116c:	0c18      	lsrs	r0, r3, #16
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    116e:	0a17      	lsrs	r7, r2, #8
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    1170:	0c16      	lsrs	r6, r2, #16
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    1172:	0e15      	lsrs	r5, r2, #24
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    1174:	0e1b      	lsrs	r3, r3, #24
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    1176:	f881 002e 	strb.w	r0, [r1, #46]	; 0x2e
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    117a:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    117e:	f881 7029 	strb.w	r7, [r1, #41]	; 0x29
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    1182:	f881 602a 	strb.w	r6, [r1, #42]	; 0x2a
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    1186:	f881 502b 	strb.w	r5, [r1, #43]	; 0x2b
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    118a:	f881 402d 	strb.w	r4, [r1, #45]	; 0x2d
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    118e:	f881 302f 	strb.w	r3, [r1, #47]	; 0x2f
    {
      int offset = 0;
      offset += this->linear.serialize(outbuffer + offset);
      offset += this->angular.serialize(outbuffer + offset);
      return offset;
    }
    1192:	2030      	movs	r0, #48	; 0x30
    1194:	bcf0      	pop	{r4, r5, r6, r7}
    1196:	4770      	bx	lr

00001198 <custom_msgs::odom_and_imu::serialize(unsigned char*) const>:
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    1198:	6902      	ldr	r2, [r0, #16]
    119a:	6943      	ldr	r3, [r0, #20]
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
    119c:	710b      	strb	r3, [r1, #4]
      omega_left(0),
      temp(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
    119e:	b4f0      	push	{r4, r5, r6, r7}
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
    11a0:	0a14      	lsrs	r4, r2, #8
    11a2:	704c      	strb	r4, [r1, #1]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    11a4:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    11a6:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    11a8:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    11aa:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    11ac:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    11ae:	708f      	strb	r7, [r1, #2]
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    11b0:	70ce      	strb	r6, [r1, #3]
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    11b2:	714d      	strb	r5, [r1, #5]
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    11b4:	718c      	strb	r4, [r1, #6]
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    11b6:	700a      	strb	r2, [r1, #0]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    11b8:	71cb      	strb	r3, [r1, #7]
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    11ba:	6982      	ldr	r2, [r0, #24]
    11bc:	69c3      	ldr	r3, [r0, #28]
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
    11be:	730b      	strb	r3, [r1, #12]
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    11c0:	0a14      	lsrs	r4, r2, #8
    11c2:	724c      	strb	r4, [r1, #9]
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    11c4:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    11c6:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    11c8:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    11ca:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    11cc:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    11ce:	728f      	strb	r7, [r1, #10]
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    11d0:	72ce      	strb	r6, [r1, #11]
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    11d2:	734d      	strb	r5, [r1, #13]
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    11d4:	738c      	strb	r4, [r1, #14]
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    11d6:	720a      	strb	r2, [r1, #8]
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    11d8:	73cb      	strb	r3, [r1, #15]
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    11da:	6a02      	ldr	r2, [r0, #32]
    11dc:	6a43      	ldr	r3, [r0, #36]	; 0x24
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
    11de:	750b      	strb	r3, [r1, #20]
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    11e0:	0a14      	lsrs	r4, r2, #8
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    11e2:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    11e4:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    11e6:	0a1d      	lsrs	r5, r3, #8
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    11e8:	744c      	strb	r4, [r1, #17]
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    11ea:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    11ec:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    11ee:	748f      	strb	r7, [r1, #18]
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    11f0:	74ce      	strb	r6, [r1, #19]
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    11f2:	754d      	strb	r5, [r1, #21]
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    11f4:	758c      	strb	r4, [r1, #22]
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    11f6:	740a      	strb	r2, [r1, #16]
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    11f8:	75cb      	strb	r3, [r1, #23]
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    11fa:	6b03      	ldr	r3, [r0, #48]	; 0x30
    11fc:	6b42      	ldr	r2, [r0, #52]	; 0x34
    11fe:	760b      	strb	r3, [r1, #24]
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
    1200:	0a1c      	lsrs	r4, r3, #8
    1202:	764c      	strb	r4, [r1, #25]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    1204:	0c1f      	lsrs	r7, r3, #16
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    1206:	0a16      	lsrs	r6, r2, #8
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    1208:	0c15      	lsrs	r5, r2, #16
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    120a:	0e14      	lsrs	r4, r2, #24
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    120c:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    120e:	768f      	strb	r7, [r1, #26]
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    1210:	774e      	strb	r6, [r1, #29]
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    1212:	778d      	strb	r5, [r1, #30]
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    1214:	77cc      	strb	r4, [r1, #31]
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
    1216:	770a      	strb	r2, [r1, #28]
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    1218:	76cb      	strb	r3, [r1, #27]
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    121a:	6b82      	ldr	r2, [r0, #56]	; 0x38
    121c:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
    121e:	f881 3024 	strb.w	r3, [r1, #36]	; 0x24
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    1222:	0a14      	lsrs	r4, r2, #8
    1224:	f881 4021 	strb.w	r4, [r1, #33]	; 0x21
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    1228:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    122a:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    122c:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    122e:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    1230:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    1232:	f881 7022 	strb.w	r7, [r1, #34]	; 0x22
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    1236:	f881 6023 	strb.w	r6, [r1, #35]	; 0x23
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    123a:	f881 5025 	strb.w	r5, [r1, #37]	; 0x25
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    123e:	f881 4026 	strb.w	r4, [r1, #38]	; 0x26
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    1242:	f881 2020 	strb.w	r2, [r1, #32]
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    1246:	f881 3027 	strb.w	r3, [r1, #39]	; 0x27
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    124a:	6c02      	ldr	r2, [r0, #64]	; 0x40
    124c:	6c43      	ldr	r3, [r0, #68]	; 0x44
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
    124e:	f881 302c 	strb.w	r3, [r1, #44]	; 0x2c
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    1252:	0a14      	lsrs	r4, r2, #8
    1254:	f881 4029 	strb.w	r4, [r1, #41]	; 0x29
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    1258:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    125a:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    125c:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    125e:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    1260:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    1262:	f881 702a 	strb.w	r7, [r1, #42]	; 0x2a
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    1266:	f881 602b 	strb.w	r6, [r1, #43]	; 0x2b
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    126a:	f881 502d 	strb.w	r5, [r1, #45]	; 0x2d
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    126e:	f881 402e 	strb.w	r4, [r1, #46]	; 0x2e
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    1272:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    1276:	f881 302f 	strb.w	r3, [r1, #47]	; 0x2f
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    127a:	6d03      	ldr	r3, [r0, #80]	; 0x50
    127c:	6d42      	ldr	r2, [r0, #84]	; 0x54
    127e:	f881 3030 	strb.w	r3, [r1, #48]	; 0x30
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
    1282:	0a1c      	lsrs	r4, r3, #8
    1284:	f881 4031 	strb.w	r4, [r1, #49]	; 0x31
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    1288:	0c1f      	lsrs	r7, r3, #16
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    128a:	0a16      	lsrs	r6, r2, #8
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    128c:	0c15      	lsrs	r5, r2, #16
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    128e:	0e14      	lsrs	r4, r2, #24
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    1290:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    1292:	f881 7032 	strb.w	r7, [r1, #50]	; 0x32
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    1296:	f881 6035 	strb.w	r6, [r1, #53]	; 0x35
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    129a:	f881 5036 	strb.w	r5, [r1, #54]	; 0x36
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    129e:	f881 4037 	strb.w	r4, [r1, #55]	; 0x37
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    12a2:	f881 3033 	strb.w	r3, [r1, #51]	; 0x33
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
    12a6:	f881 2034 	strb.w	r2, [r1, #52]	; 0x34
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    12aa:	6d82      	ldr	r2, [r0, #88]	; 0x58
    12ac:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
    12ae:	f881 303c 	strb.w	r3, [r1, #60]	; 0x3c
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    12b2:	0a14      	lsrs	r4, r2, #8
    12b4:	f881 4039 	strb.w	r4, [r1, #57]	; 0x39
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    12b8:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    12ba:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    12bc:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    12be:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    12c0:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    12c2:	f881 703a 	strb.w	r7, [r1, #58]	; 0x3a
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    12c6:	f881 603b 	strb.w	r6, [r1, #59]	; 0x3b
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    12ca:	f881 503d 	strb.w	r5, [r1, #61]	; 0x3d
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    12ce:	f881 403e 	strb.w	r4, [r1, #62]	; 0x3e
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    12d2:	f881 2038 	strb.w	r2, [r1, #56]	; 0x38
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    12d6:	f881 303f 	strb.w	r3, [r1, #63]	; 0x3f
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    12da:	6e02      	ldr	r2, [r0, #96]	; 0x60
    12dc:	6e43      	ldr	r3, [r0, #100]	; 0x64
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
    12de:	f881 3044 	strb.w	r3, [r1, #68]	; 0x44
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    12e2:	0a14      	lsrs	r4, r2, #8
    12e4:	f881 4041 	strb.w	r4, [r1, #65]	; 0x41
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    12e8:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    12ea:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    12ec:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    12ee:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    12f0:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    12f2:	f881 7042 	strb.w	r7, [r1, #66]	; 0x42
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    12f6:	f881 6043 	strb.w	r6, [r1, #67]	; 0x43
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    12fa:	f881 5045 	strb.w	r5, [r1, #69]	; 0x45
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    12fe:	f881 4046 	strb.w	r4, [r1, #70]	; 0x46
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    1302:	f881 2040 	strb.w	r2, [r1, #64]	; 0x40
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    1306:	f881 3047 	strb.w	r3, [r1, #71]	; 0x47
      union {
        double real;
        uint64_t base;
      } u_omega_right;
      u_omega_right.real = this->omega_right;
      *(outbuffer + offset + 0) = (u_omega_right.base >> (8 * 0)) & 0xFF;
    130a:	6e82      	ldr	r2, [r0, #104]	; 0x68
    130c:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
      *(outbuffer + offset + 1) = (u_omega_right.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_omega_right.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_omega_right.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_omega_right.base >> (8 * 4)) & 0xFF;
    130e:	f881 304c 	strb.w	r3, [r1, #76]	; 0x4c
        double real;
        uint64_t base;
      } u_omega_right;
      u_omega_right.real = this->omega_right;
      *(outbuffer + offset + 0) = (u_omega_right.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_right.base >> (8 * 1)) & 0xFF;
    1312:	0a14      	lsrs	r4, r2, #8
      *(outbuffer + offset + 2) = (u_omega_right.base >> (8 * 2)) & 0xFF;
    1314:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_omega_right.base >> (8 * 3)) & 0xFF;
    1316:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_omega_right.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_right.base >> (8 * 5)) & 0xFF;
    1318:	0a1d      	lsrs	r5, r3, #8
        double real;
        uint64_t base;
      } u_omega_right;
      u_omega_right.real = this->omega_right;
      *(outbuffer + offset + 0) = (u_omega_right.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_right.base >> (8 * 1)) & 0xFF;
    131a:	f881 4049 	strb.w	r4, [r1, #73]	; 0x49
      *(outbuffer + offset + 2) = (u_omega_right.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_omega_right.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_omega_right.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_right.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_omega_right.base >> (8 * 6)) & 0xFF;
    131e:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_omega_right.base >> (8 * 7)) & 0xFF;
    1320:	0e1b      	lsrs	r3, r3, #24
      union {
        double real;
        uint64_t base;
      } u_omega_right;
      u_omega_right.real = this->omega_right;
      *(outbuffer + offset + 0) = (u_omega_right.base >> (8 * 0)) & 0xFF;
    1322:	f881 2048 	strb.w	r2, [r1, #72]	; 0x48
      *(outbuffer + offset + 1) = (u_omega_right.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_omega_right.base >> (8 * 2)) & 0xFF;
    1326:	f881 704a 	strb.w	r7, [r1, #74]	; 0x4a
      *(outbuffer + offset + 3) = (u_omega_right.base >> (8 * 3)) & 0xFF;
    132a:	f881 604b 	strb.w	r6, [r1, #75]	; 0x4b
      *(outbuffer + offset + 4) = (u_omega_right.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_right.base >> (8 * 5)) & 0xFF;
    132e:	f881 504d 	strb.w	r5, [r1, #77]	; 0x4d
      *(outbuffer + offset + 6) = (u_omega_right.base >> (8 * 6)) & 0xFF;
    1332:	f881 404e 	strb.w	r4, [r1, #78]	; 0x4e
      *(outbuffer + offset + 7) = (u_omega_right.base >> (8 * 7)) & 0xFF;
    1336:	f881 304f 	strb.w	r3, [r1, #79]	; 0x4f
      union {
        double real;
        uint64_t base;
      } u_omega_left;
      u_omega_left.real = this->omega_left;
      *(outbuffer + offset + 0) = (u_omega_left.base >> (8 * 0)) & 0xFF;
    133a:	6f02      	ldr	r2, [r0, #112]	; 0x70
    133c:	6f43      	ldr	r3, [r0, #116]	; 0x74
      *(outbuffer + offset + 1) = (u_omega_left.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_omega_left.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_omega_left.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_omega_left.base >> (8 * 4)) & 0xFF;
    133e:	f881 3054 	strb.w	r3, [r1, #84]	; 0x54
        double real;
        uint64_t base;
      } u_omega_left;
      u_omega_left.real = this->omega_left;
      *(outbuffer + offset + 0) = (u_omega_left.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_left.base >> (8 * 1)) & 0xFF;
    1342:	0a14      	lsrs	r4, r2, #8
      *(outbuffer + offset + 2) = (u_omega_left.base >> (8 * 2)) & 0xFF;
    1344:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_omega_left.base >> (8 * 3)) & 0xFF;
    1346:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_omega_left.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_left.base >> (8 * 5)) & 0xFF;
    1348:	0a1d      	lsrs	r5, r3, #8
        double real;
        uint64_t base;
      } u_omega_left;
      u_omega_left.real = this->omega_left;
      *(outbuffer + offset + 0) = (u_omega_left.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_left.base >> (8 * 1)) & 0xFF;
    134a:	f881 4051 	strb.w	r4, [r1, #81]	; 0x51
      *(outbuffer + offset + 2) = (u_omega_left.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_omega_left.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_omega_left.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_left.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_omega_left.base >> (8 * 6)) & 0xFF;
    134e:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_omega_left.base >> (8 * 7)) & 0xFF;
    1350:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_omega_left;
      u_omega_left.real = this->omega_left;
      *(outbuffer + offset + 0) = (u_omega_left.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_left.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_omega_left.base >> (8 * 2)) & 0xFF;
    1352:	f881 7052 	strb.w	r7, [r1, #82]	; 0x52
      *(outbuffer + offset + 3) = (u_omega_left.base >> (8 * 3)) & 0xFF;
    1356:	f881 6053 	strb.w	r6, [r1, #83]	; 0x53
      *(outbuffer + offset + 4) = (u_omega_left.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_left.base >> (8 * 5)) & 0xFF;
    135a:	f881 5055 	strb.w	r5, [r1, #85]	; 0x55
      *(outbuffer + offset + 6) = (u_omega_left.base >> (8 * 6)) & 0xFF;
    135e:	f881 4056 	strb.w	r4, [r1, #86]	; 0x56
      union {
        double real;
        uint64_t base;
      } u_omega_left;
      u_omega_left.real = this->omega_left;
      *(outbuffer + offset + 0) = (u_omega_left.base >> (8 * 0)) & 0xFF;
    1362:	f881 2050 	strb.w	r2, [r1, #80]	; 0x50
      *(outbuffer + offset + 2) = (u_omega_left.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_omega_left.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_omega_left.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_left.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_omega_left.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_omega_left.base >> (8 * 7)) & 0xFF;
    1366:	f881 3057 	strb.w	r3, [r1, #87]	; 0x57
      union {
        double real;
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
    136a:	6f82      	ldr	r2, [r0, #120]	; 0x78
    136c:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
      *(outbuffer + offset + 1) = (u_temp.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_temp.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_temp.base >> (8 * 4)) & 0xFF;
    136e:	f881 305c 	strb.w	r3, [r1, #92]	; 0x5c
      *(outbuffer + offset + 5) = (u_temp.base >> (8 * 5)) & 0xFF;
    1372:	0a1c      	lsrs	r4, r3, #8
      *(outbuffer + offset + 6) = (u_temp.base >> (8 * 6)) & 0xFF;
    1374:	0c18      	lsrs	r0, r3, #16
        double real;
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_temp.base >> (8 * 1)) & 0xFF;
    1376:	0a17      	lsrs	r7, r2, #8
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
    1378:	0c16      	lsrs	r6, r2, #16
      *(outbuffer + offset + 3) = (u_temp.base >> (8 * 3)) & 0xFF;
    137a:	0e15      	lsrs	r5, r2, #24
      *(outbuffer + offset + 4) = (u_temp.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_temp.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_temp.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_temp.base >> (8 * 7)) & 0xFF;
    137c:	0e1b      	lsrs	r3, r3, #24
        double real;
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_temp.base >> (8 * 1)) & 0xFF;
    137e:	f881 7059 	strb.w	r7, [r1, #89]	; 0x59
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
    1382:	f881 605a 	strb.w	r6, [r1, #90]	; 0x5a
      *(outbuffer + offset + 3) = (u_temp.base >> (8 * 3)) & 0xFF;
    1386:	f881 505b 	strb.w	r5, [r1, #91]	; 0x5b
      *(outbuffer + offset + 4) = (u_temp.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_temp.base >> (8 * 5)) & 0xFF;
    138a:	f881 405d 	strb.w	r4, [r1, #93]	; 0x5d
      *(outbuffer + offset + 6) = (u_temp.base >> (8 * 6)) & 0xFF;
    138e:	f881 005e 	strb.w	r0, [r1, #94]	; 0x5e
      union {
        double real;
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
    1392:	f881 2058 	strb.w	r2, [r1, #88]	; 0x58
      *(outbuffer + offset + 5) = (u_temp.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_temp.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_temp.base >> (8 * 7)) & 0xFF;
      offset += sizeof(this->temp);
      return offset;
    }
    1396:	2060      	movs	r0, #96	; 0x60
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_temp.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_temp.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_temp.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_temp.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_temp.base >> (8 * 7)) & 0xFF;
    1398:	f881 305f 	strb.w	r3, [r1, #95]	; 0x5f
      offset += sizeof(this->temp);
      return offset;
    }
    139c:	bcf0      	pop	{r4, r5, r6, r7}
    139e:	4770      	bx	lr

000013a0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.8] [clone .constprop.10]>:
      }
    }
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
    13a0:	b5f0      	push	{r4, r5, r6, r7, lr}
    13a2:	b085      	sub	sp, #20
      enum { ERROR = 3 };
      enum { FATAL = 4 };

    Log():
      level(0),
      msg("")
    13a4:	4b2d      	ldr	r3, [pc, #180]	; (145c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.8] [clone .constprop.10]+0xbc>)
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    13a6:	6802      	ldr	r2, [r0, #0]
    13a8:	9301      	str	r3, [sp, #4]
protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    13aa:	492d      	ldr	r1, [pc, #180]	; (1460 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.8] [clone .constprop.10]+0xc0>)
    13ac:	9103      	str	r1, [sp, #12]

protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    13ae:	2303      	movs	r3, #3
    13b0:	f88d 3008 	strb.w	r3, [sp, #8]
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    13b4:	6814      	ldr	r4, [r2, #0]
    13b6:	4a2b      	ldr	r2, [pc, #172]	; (1464 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.8] [clone .constprop.10]+0xc4>)
    13b8:	4294      	cmp	r4, r2
    13ba:	d140      	bne.n	143e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.8] [clone .constprop.10]+0x9e>
  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
      arr[i] = (var >> (8 * i));
    13bc:	2400      	movs	r4, #0
    13be:	2238      	movs	r2, #56	; 0x38
    13c0:	4605      	mov	r5, r0
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    13c2:	f880 3223 	strb.w	r3, [r0, #547]	; 0x223
    13c6:	f880 2224 	strb.w	r2, [r0, #548]	; 0x224
    13ca:	f880 4225 	strb.w	r4, [r0, #549]	; 0x225
    13ce:	f880 4226 	strb.w	r4, [r0, #550]	; 0x226
    13d2:	f880 4227 	strb.w	r4, [r0, #551]	; 0x227
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    13d6:	f500 700a 	add.w	r0, r0, #552	; 0x228
    13da:	f005 f82f 	bl	643c <memcpy>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    13de:	27ff      	movs	r7, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    13e0:	203d      	movs	r0, #61	; 0x3d
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    13e2:	23c2      	movs	r3, #194	; 0xc2
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    13e4:	26fe      	movs	r6, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    13e6:	2107      	movs	r1, #7
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    13e8:	f885 021e 	strb.w	r0, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    13ec:	f885 3220 	strb.w	r3, [r5, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    13f0:	f885 421f 	strb.w	r4, [r5, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    13f4:	f885 4222 	strb.w	r4, [r5, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    13f8:	4622      	mov	r2, r4

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    13fa:	f885 721c 	strb.w	r7, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    13fe:	f885 621d 	strb.w	r6, [r5, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    1402:	f885 1221 	strb.w	r1, [r5, #545]	; 0x221
    1406:	f205 2321 	addw	r3, r5, #545	; 0x221
    140a:	f205 205f 	addw	r0, r5, #607	; 0x25f
    140e:	e001      	b.n	1414 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.8] [clone .constprop.10]+0x74>
    1410:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    1414:	4283      	cmp	r3, r0
      chk += message_out[i];
    1416:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    1418:	d1fa      	bne.n	1410 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.8] [clone .constprop.10]+0x70>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    141a:	43d2      	mvns	r2, r2
    141c:	686c      	ldr	r4, [r5, #4]
    141e:	f885 2260 	strb.w	r2, [r5, #608]	; 0x260
      iostream->begin(baud_);
    }

    int read(){return iostream->read();};
    void write(uint8_t* data, int length){
      iostream->write(data, length);
    1422:	6823      	ldr	r3, [r4, #0]
    1424:	4a10      	ldr	r2, [pc, #64]	; (1468 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.8] [clone .constprop.10]+0xc8>)
    1426:	685b      	ldr	r3, [r3, #4]
    1428:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    142a:	f505 7007 	add.w	r0, r5, #540	; 0x21c
    142e:	d10d      	bne.n	144c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.8] [clone .constprop.10]+0xac>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    1430:	2145      	movs	r1, #69	; 0x45
    1432:	f006 fb1b 	bl	7a6c <usb_serial_write>
    else
    {
      logerror("Message from device dropped: message larger than buffer.");
      return -1;
    }
  }
    1436:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    143a:	b005      	add	sp, #20
    143c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    143e:	aa01      	add	r2, sp, #4
    1440:	2107      	movs	r1, #7
    1442:	47a0      	blx	r4
    else
    {
      logerror("Message from device dropped: message larger than buffer.");
      return -1;
    }
  }
    1444:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1448:	b005      	add	sp, #20
    144a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    144c:	4601      	mov	r1, r0
    144e:	2245      	movs	r2, #69	; 0x45
    1450:	4620      	mov	r0, r4
    1452:	4798      	blx	r3
    1454:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1458:	b005      	add	sp, #20
    145a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    145c:	0000bc54 	.word	0x0000bc54
    1460:	0000bf68 	.word	0x0000bf68
    1464:	00001a4d 	.word	0x00001a4d
    1468:	00000ebd 	.word	0x00000ebd

0000146c <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)>:
    endpoint_(endpoint)
  {
    topic_ = topic_name;
  };

  virtual void callback(unsigned char* data) override
    146c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1470:	f891 c001 	ldrb.w	ip, [r1, #1]
    1474:	f891 e000 	ldrb.w	lr, [r1]
    1478:	794a      	ldrb	r2, [r1, #5]
    147a:	f891 b002 	ldrb.w	fp, [r1, #2]
    147e:	f891 a003 	ldrb.w	sl, [r1, #3]
    1482:	4603      	mov	r3, r0
    1484:	7908      	ldrb	r0, [r1, #4]
    1486:	ea4e 2e0c 	orr.w	lr, lr, ip, lsl #8
    148a:	f891 c006 	ldrb.w	ip, [r1, #6]
    148e:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    1492:	79c8      	ldrb	r0, [r1, #7]
    1494:	ea4e 4e0b 	orr.w	lr, lr, fp, lsl #16
    1498:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
    149c:	ea4e 680a 	orr.w	r8, lr, sl, lsl #24
    14a0:	ea42 6900 	orr.w	r9, r2, r0, lsl #24
      this->x = u_x.real;
    14a4:	e9c3 8908 	strd	r8, r9, [r3, #32]
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    14a8:	f891 c009 	ldrb.w	ip, [r1, #9]
    14ac:	f891 e008 	ldrb.w	lr, [r1, #8]
    14b0:	7b08      	ldrb	r0, [r1, #12]
    14b2:	7b4a      	ldrb	r2, [r1, #13]
    14b4:	f891 900a 	ldrb.w	r9, [r1, #10]
    14b8:	f891 800b 	ldrb.w	r8, [r1, #11]
    14bc:	ea4e 2e0c 	orr.w	lr, lr, ip, lsl #8
    14c0:	f891 c00e 	ldrb.w	ip, [r1, #14]
    14c4:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    14c8:	7bc8      	ldrb	r0, [r1, #15]
    14ca:	ea4e 4e09 	orr.w	lr, lr, r9, lsl #16
    14ce:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
    14d2:	ea4e 6608 	orr.w	r6, lr, r8, lsl #24
    14d6:	ea42 6700 	orr.w	r7, r2, r0, lsl #24
      this->y = u_y.real;
    14da:	e9c3 670a 	strd	r6, r7, [r3, #40]	; 0x28
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    14de:	7c4f      	ldrb	r7, [r1, #17]
    14e0:	7c0e      	ldrb	r6, [r1, #16]
    14e2:	7d08      	ldrb	r0, [r1, #20]
    14e4:	7d4a      	ldrb	r2, [r1, #21]
    14e6:	f891 c012 	ldrb.w	ip, [r1, #18]
    14ea:	f891 e013 	ldrb.w	lr, [r1, #19]
    14ee:	ea46 2607 	orr.w	r6, r6, r7, lsl #8
    14f2:	7d8f      	ldrb	r7, [r1, #22]
    14f4:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    14f8:	7dc8      	ldrb	r0, [r1, #23]
    14fa:	b087      	sub	sp, #28
    14fc:	ea46 460c 	orr.w	r6, r6, ip, lsl #16
    1500:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
    1504:	ea46 660e 	orr.w	r6, r6, lr, lsl #24
    1508:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    150c:	9201      	str	r2, [sp, #4]
    150e:	9600      	str	r6, [sp, #0]
      this->z = u_z.real;
    1510:	e9dd 6700 	ldrd	r6, r7, [sp]
    1514:	e9c3 670c 	strd	r6, r7, [r3, #48]	; 0x30
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1518:	f891 e019 	ldrb.w	lr, [r1, #25]
    151c:	7e0e      	ldrb	r6, [r1, #24]
    151e:	7e8f      	ldrb	r7, [r1, #26]
    1520:	7f0a      	ldrb	r2, [r1, #28]
    1522:	7f48      	ldrb	r0, [r1, #29]
    1524:	f891 c01b 	ldrb.w	ip, [r1, #27]
    1528:	ea46 260e 	orr.w	r6, r6, lr, lsl #8
    152c:	f891 e01e 	ldrb.w	lr, [r1, #30]
    1530:	ea46 4607 	orr.w	r6, r6, r7, lsl #16
    1534:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
    1538:	7fcf      	ldrb	r7, [r1, #31]
  {
    msg.deserialize(data);
    this->cb_(msg);
    153a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    153c:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
    1540:	ea46 660c 	orr.w	r6, r6, ip, lsl #24
    1544:	ea40 6007 	orr.w	r0, r0, r7, lsl #24
    1548:	9003      	str	r0, [sp, #12]
    154a:	9602      	str	r6, [sp, #8]
      this->x = u_x.real;
    154c:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    1550:	e9c3 6710 	strd	r6, r7, [r3, #64]	; 0x40
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1554:	f891 e020 	ldrb.w	lr, [r1, #32]
    1558:	f891 7021 	ldrb.w	r7, [r1, #33]	; 0x21
    155c:	f891 6024 	ldrb.w	r6, [r1, #36]	; 0x24
    1560:	f891 0025 	ldrb.w	r0, [r1, #37]	; 0x25
    1564:	f891 8022 	ldrb.w	r8, [r1, #34]	; 0x22
    1568:	f891 c023 	ldrb.w	ip, [r1, #35]	; 0x23
    156c:	ea4e 2707 	orr.w	r7, lr, r7, lsl #8
    1570:	f891 e026 	ldrb.w	lr, [r1, #38]	; 0x26
    1574:	ea46 2000 	orr.w	r0, r6, r0, lsl #8
    1578:	f891 6027 	ldrb.w	r6, [r1, #39]	; 0x27
    157c:	ea47 4708 	orr.w	r7, r7, r8, lsl #16
    1580:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
    1584:	ea47 670c 	orr.w	r7, r7, ip, lsl #24
    1588:	ea40 6006 	orr.w	r0, r0, r6, lsl #24
    158c:	9005      	str	r0, [sp, #20]
    158e:	9704      	str	r7, [sp, #16]
      this->y = u_y.real;
    1590:	e9dd 6704 	ldrd	r6, r7, [sp, #16]
    1594:	e9c3 6712 	strd	r6, r7, [r3, #72]	; 0x48
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1598:	f891 7028 	ldrb.w	r7, [r1, #40]	; 0x28
    159c:	f891 6029 	ldrb.w	r6, [r1, #41]	; 0x29
    15a0:	f891 002c 	ldrb.w	r0, [r1, #44]	; 0x2c
    15a4:	f891 802d 	ldrb.w	r8, [r1, #45]	; 0x2d
    15a8:	f891 902a 	ldrb.w	r9, [r1, #42]	; 0x2a
    15ac:	f891 c02b 	ldrb.w	ip, [r1, #43]	; 0x2b
    15b0:	f891 e02e 	ldrb.w	lr, [r1, #46]	; 0x2e
    15b4:	ea47 2606 	orr.w	r6, r7, r6, lsl #8
    15b8:	f891 702f 	ldrb.w	r7, [r1, #47]	; 0x2f
    15bc:	ea40 2108 	orr.w	r1, r0, r8, lsl #8
    15c0:	ea46 4609 	orr.w	r6, r6, r9, lsl #16
    15c4:	ea41 410e 	orr.w	r1, r1, lr, lsl #16
    15c8:	ea46 640c 	orr.w	r4, r6, ip, lsl #24
    15cc:	ea41 6507 	orr.w	r5, r1, r7, lsl #24
    15d0:	f103 0010 	add.w	r0, r3, #16
      this->z = u_z.real;
    15d4:	e9c3 4514 	strd	r4, r5, [r3, #80]	; 0x50
  }
    15d8:	b007      	add	sp, #28
    15da:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  };

  virtual void callback(unsigned char* data) override
  {
    msg.deserialize(data);
    this->cb_(msg);
    15de:	4710      	bx	r2

000015e0 <geometry_msgs::Twist::deserialize(unsigned char*)>:

    virtual int deserialize(unsigned char *inbuffer) override
    15e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    15e4:	f891 c001 	ldrb.w	ip, [r1, #1]
    15e8:	f891 e000 	ldrb.w	lr, [r1]
    15ec:	794a      	ldrb	r2, [r1, #5]
    15ee:	f891 b002 	ldrb.w	fp, [r1, #2]
    15f2:	f891 a003 	ldrb.w	sl, [r1, #3]
    15f6:	4603      	mov	r3, r0
    15f8:	7908      	ldrb	r0, [r1, #4]
    15fa:	ea4e 2e0c 	orr.w	lr, lr, ip, lsl #8
    15fe:	f891 c006 	ldrb.w	ip, [r1, #6]
    1602:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    1606:	79c8      	ldrb	r0, [r1, #7]
    1608:	ea4e 4e0b 	orr.w	lr, lr, fp, lsl #16
    160c:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
    1610:	ea4e 680a 	orr.w	r8, lr, sl, lsl #24
    1614:	ea42 6900 	orr.w	r9, r2, r0, lsl #24
      this->x = u_x.real;
    1618:	e9c3 8904 	strd	r8, r9, [r3, #16]
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    161c:	f891 c009 	ldrb.w	ip, [r1, #9]
    1620:	f891 e008 	ldrb.w	lr, [r1, #8]
    1624:	7b08      	ldrb	r0, [r1, #12]
    1626:	7b4a      	ldrb	r2, [r1, #13]
    1628:	f891 900a 	ldrb.w	r9, [r1, #10]
    162c:	f891 800b 	ldrb.w	r8, [r1, #11]
    1630:	ea4e 2e0c 	orr.w	lr, lr, ip, lsl #8
    1634:	f891 c00e 	ldrb.w	ip, [r1, #14]
    1638:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    163c:	7bc8      	ldrb	r0, [r1, #15]
    163e:	ea4e 4e09 	orr.w	lr, lr, r9, lsl #16
    1642:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
    1646:	ea4e 6608 	orr.w	r6, lr, r8, lsl #24
    164a:	ea42 6700 	orr.w	r7, r2, r0, lsl #24
      this->y = u_y.real;
    164e:	e9c3 6706 	strd	r6, r7, [r3, #24]
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1652:	7c4f      	ldrb	r7, [r1, #17]
    1654:	7c0e      	ldrb	r6, [r1, #16]
    1656:	7d08      	ldrb	r0, [r1, #20]
    1658:	7d4a      	ldrb	r2, [r1, #21]
    165a:	f891 c012 	ldrb.w	ip, [r1, #18]
    165e:	f891 e013 	ldrb.w	lr, [r1, #19]
    1662:	ea46 2607 	orr.w	r6, r6, r7, lsl #8
    1666:	7d8f      	ldrb	r7, [r1, #22]
    1668:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    166c:	7dc8      	ldrb	r0, [r1, #23]
    166e:	b087      	sub	sp, #28
    1670:	ea46 460c 	orr.w	r6, r6, ip, lsl #16
    1674:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
    1678:	ea46 660e 	orr.w	r6, r6, lr, lsl #24
    167c:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    1680:	9201      	str	r2, [sp, #4]
    1682:	9600      	str	r6, [sp, #0]
      this->z = u_z.real;
    1684:	e9dd 6700 	ldrd	r6, r7, [sp]
    1688:	e9c3 6708 	strd	r6, r7, [r3, #32]
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    168c:	7e4f      	ldrb	r7, [r1, #25]
    168e:	7e0e      	ldrb	r6, [r1, #24]
    1690:	7f08      	ldrb	r0, [r1, #28]
    1692:	7f4a      	ldrb	r2, [r1, #29]
    1694:	f891 c01a 	ldrb.w	ip, [r1, #26]
    1698:	f891 e01b 	ldrb.w	lr, [r1, #27]
    169c:	ea46 2607 	orr.w	r6, r6, r7, lsl #8
    16a0:	7f8f      	ldrb	r7, [r1, #30]
    16a2:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    16a6:	7fc8      	ldrb	r0, [r1, #31]
    16a8:	ea46 460c 	orr.w	r6, r6, ip, lsl #16
    16ac:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
    16b0:	ea46 660e 	orr.w	r6, r6, lr, lsl #24
    16b4:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    16b8:	9203      	str	r2, [sp, #12]
    16ba:	9602      	str	r6, [sp, #8]
      this->x = u_x.real;
    16bc:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    16c0:	e9c3 670c 	strd	r6, r7, [r3, #48]	; 0x30
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    16c4:	f891 7020 	ldrb.w	r7, [r1, #32]
    16c8:	f891 6021 	ldrb.w	r6, [r1, #33]	; 0x21
    16cc:	f891 0024 	ldrb.w	r0, [r1, #36]	; 0x24
    16d0:	f891 2025 	ldrb.w	r2, [r1, #37]	; 0x25
    16d4:	f891 c022 	ldrb.w	ip, [r1, #34]	; 0x22
    16d8:	f891 e023 	ldrb.w	lr, [r1, #35]	; 0x23
    16dc:	ea47 2606 	orr.w	r6, r7, r6, lsl #8
    16e0:	f891 7026 	ldrb.w	r7, [r1, #38]	; 0x26
    16e4:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    16e8:	f891 0027 	ldrb.w	r0, [r1, #39]	; 0x27
    16ec:	ea46 460c 	orr.w	r6, r6, ip, lsl #16
    16f0:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
    16f4:	ea46 660e 	orr.w	r6, r6, lr, lsl #24
    16f8:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    16fc:	9205      	str	r2, [sp, #20]
    16fe:	9604      	str	r6, [sp, #16]
      this->y = u_y.real;
    1700:	e9dd 6704 	ldrd	r6, r7, [sp, #16]
    1704:	e9c3 670e 	strd	r6, r7, [r3, #56]	; 0x38
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1708:	f891 7029 	ldrb.w	r7, [r1, #41]	; 0x29
    170c:	f891 002c 	ldrb.w	r0, [r1, #44]	; 0x2c
    1710:	f891 6028 	ldrb.w	r6, [r1, #40]	; 0x28
    1714:	f891 202d 	ldrb.w	r2, [r1, #45]	; 0x2d
    1718:	f891 c02b 	ldrb.w	ip, [r1, #43]	; 0x2b
    171c:	f891 802a 	ldrb.w	r8, [r1, #42]	; 0x2a
    1720:	f891 e02e 	ldrb.w	lr, [r1, #46]	; 0x2e
    1724:	ea46 2607 	orr.w	r6, r6, r7, lsl #8
    1728:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    172c:	f891 702f 	ldrb.w	r7, [r1, #47]	; 0x2f
    1730:	ea42 420e 	orr.w	r2, r2, lr, lsl #16
    1734:	ea46 4108 	orr.w	r1, r6, r8, lsl #16
    1738:	ea41 640c 	orr.w	r4, r1, ip, lsl #24
    173c:	ea42 6507 	orr.w	r5, r2, r7, lsl #24
    {
      int offset = 0;
      offset += this->linear.deserialize(inbuffer + offset);
      offset += this->angular.deserialize(inbuffer + offset);
     return offset;
    }
    1740:	2030      	movs	r0, #48	; 0x30
      this->z = u_z.real;
    1742:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
    1746:	b007      	add	sp, #28
    1748:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000174c <custom_msgs::odom_and_imu::deserialize(unsigned char*)>:

    virtual int deserialize(unsigned char *inbuffer) override
    174c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1750:	f891 c001 	ldrb.w	ip, [r1, #1]
    1754:	f891 e000 	ldrb.w	lr, [r1]
    1758:	794a      	ldrb	r2, [r1, #5]
    175a:	f891 b002 	ldrb.w	fp, [r1, #2]
    175e:	f891 a003 	ldrb.w	sl, [r1, #3]
    1762:	4603      	mov	r3, r0
    1764:	7908      	ldrb	r0, [r1, #4]
    1766:	ea4e 2e0c 	orr.w	lr, lr, ip, lsl #8
    176a:	f891 c006 	ldrb.w	ip, [r1, #6]
    176e:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    1772:	79c8      	ldrb	r0, [r1, #7]
    1774:	ea4e 4e0b 	orr.w	lr, lr, fp, lsl #16
    1778:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
    177c:	ea4e 680a 	orr.w	r8, lr, sl, lsl #24
    1780:	ea42 6900 	orr.w	r9, r2, r0, lsl #24
      this->x = u_x.real;
    1784:	e9c3 8904 	strd	r8, r9, [r3, #16]
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1788:	f891 c009 	ldrb.w	ip, [r1, #9]
    178c:	f891 e008 	ldrb.w	lr, [r1, #8]
    1790:	7b08      	ldrb	r0, [r1, #12]
    1792:	7b4a      	ldrb	r2, [r1, #13]
    1794:	f891 900a 	ldrb.w	r9, [r1, #10]
    1798:	f891 800b 	ldrb.w	r8, [r1, #11]
    179c:	ea4e 2e0c 	orr.w	lr, lr, ip, lsl #8
    17a0:	f891 c00e 	ldrb.w	ip, [r1, #14]
    17a4:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    17a8:	7bc8      	ldrb	r0, [r1, #15]
    17aa:	ea4e 4e09 	orr.w	lr, lr, r9, lsl #16
    17ae:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
    17b2:	ea4e 6608 	orr.w	r6, lr, r8, lsl #24
    17b6:	ea42 6700 	orr.w	r7, r2, r0, lsl #24
      this->y = u_y.real;
    17ba:	e9c3 6706 	strd	r6, r7, [r3, #24]
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    17be:	7c4f      	ldrb	r7, [r1, #17]
    17c0:	7c0e      	ldrb	r6, [r1, #16]
    17c2:	f891 c012 	ldrb.w	ip, [r1, #18]
    17c6:	7d08      	ldrb	r0, [r1, #20]
    17c8:	7d4a      	ldrb	r2, [r1, #21]
    17ca:	f891 e013 	ldrb.w	lr, [r1, #19]
    17ce:	ea46 2607 	orr.w	r6, r6, r7, lsl #8
    17d2:	7d8f      	ldrb	r7, [r1, #22]
    17d4:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    17d8:	7dc8      	ldrb	r0, [r1, #23]
    17da:	ea46 460c 	orr.w	r6, r6, ip, lsl #16
    17de:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
    17e2:	ea46 640e 	orr.w	r4, r6, lr, lsl #24
    17e6:	ea42 6500 	orr.w	r5, r2, r0, lsl #24
      this->z = u_z.real;
    17ea:	e9c3 4508 	strd	r4, r5, [r3, #32]
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    17ee:	7e4d      	ldrb	r5, [r1, #25]
    17f0:	7e0c      	ldrb	r4, [r1, #24]
    17f2:	7f08      	ldrb	r0, [r1, #28]
    17f4:	7f4a      	ldrb	r2, [r1, #29]
    17f6:	7e8f      	ldrb	r7, [r1, #26]
    17f8:	7ece      	ldrb	r6, [r1, #27]
    17fa:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
    17fe:	7f8d      	ldrb	r5, [r1, #30]
    1800:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    1804:	7fc8      	ldrb	r0, [r1, #31]
    1806:	b093      	sub	sp, #76	; 0x4c
    1808:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
    180c:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
    1810:	ea44 6406 	orr.w	r4, r4, r6, lsl #24
    1814:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    1818:	9201      	str	r2, [sp, #4]
    181a:	9400      	str	r4, [sp, #0]
      this->x = u_x.real;
    181c:	e9dd 4500 	ldrd	r4, r5, [sp]
    1820:	e9c3 450c 	strd	r4, r5, [r3, #48]	; 0x30
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1824:	f891 5021 	ldrb.w	r5, [r1, #33]	; 0x21
    1828:	f891 4020 	ldrb.w	r4, [r1, #32]
    182c:	f891 0024 	ldrb.w	r0, [r1, #36]	; 0x24
    1830:	f891 2025 	ldrb.w	r2, [r1, #37]	; 0x25
    1834:	f891 7022 	ldrb.w	r7, [r1, #34]	; 0x22
    1838:	f891 6023 	ldrb.w	r6, [r1, #35]	; 0x23
    183c:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
    1840:	f891 5026 	ldrb.w	r5, [r1, #38]	; 0x26
    1844:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    1848:	f891 0027 	ldrb.w	r0, [r1, #39]	; 0x27
    184c:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
    1850:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
    1854:	ea44 6406 	orr.w	r4, r4, r6, lsl #24
    1858:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    185c:	9203      	str	r2, [sp, #12]
    185e:	9402      	str	r4, [sp, #8]
      this->y = u_y.real;
    1860:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
    1864:	e9c3 450e 	strd	r4, r5, [r3, #56]	; 0x38
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1868:	f891 5029 	ldrb.w	r5, [r1, #41]	; 0x29
    186c:	f891 4028 	ldrb.w	r4, [r1, #40]	; 0x28
    1870:	f891 702a 	ldrb.w	r7, [r1, #42]	; 0x2a
    1874:	f891 002c 	ldrb.w	r0, [r1, #44]	; 0x2c
    1878:	f891 202d 	ldrb.w	r2, [r1, #45]	; 0x2d
    187c:	f891 602b 	ldrb.w	r6, [r1, #43]	; 0x2b
    1880:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
    1884:	f891 502e 	ldrb.w	r5, [r1, #46]	; 0x2e
    1888:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    188c:	f891 002f 	ldrb.w	r0, [r1, #47]	; 0x2f
    1890:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
    1894:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
    1898:	ea44 6406 	orr.w	r4, r4, r6, lsl #24
    189c:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    18a0:	9205      	str	r2, [sp, #20]
    18a2:	9404      	str	r4, [sp, #16]
      this->z = u_z.real;
    18a4:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
    18a8:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    18ac:	f891 5031 	ldrb.w	r5, [r1, #49]	; 0x31
    18b0:	f891 4030 	ldrb.w	r4, [r1, #48]	; 0x30
    18b4:	f891 0034 	ldrb.w	r0, [r1, #52]	; 0x34
    18b8:	f891 2035 	ldrb.w	r2, [r1, #53]	; 0x35
    18bc:	f891 7032 	ldrb.w	r7, [r1, #50]	; 0x32
    18c0:	f891 6033 	ldrb.w	r6, [r1, #51]	; 0x33
    18c4:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
    18c8:	f891 5036 	ldrb.w	r5, [r1, #54]	; 0x36
    18cc:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    18d0:	f891 0037 	ldrb.w	r0, [r1, #55]	; 0x37
    18d4:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
    18d8:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
    18dc:	ea44 6406 	orr.w	r4, r4, r6, lsl #24
    18e0:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    18e4:	9207      	str	r2, [sp, #28]
    18e6:	9406      	str	r4, [sp, #24]
      this->x = u_x.real;
    18e8:	e9dd 4506 	ldrd	r4, r5, [sp, #24]
    18ec:	e9c3 4514 	strd	r4, r5, [r3, #80]	; 0x50
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    18f0:	f891 5039 	ldrb.w	r5, [r1, #57]	; 0x39
    18f4:	f891 4038 	ldrb.w	r4, [r1, #56]	; 0x38
    18f8:	f891 003c 	ldrb.w	r0, [r1, #60]	; 0x3c
    18fc:	f891 203d 	ldrb.w	r2, [r1, #61]	; 0x3d
    1900:	f891 703a 	ldrb.w	r7, [r1, #58]	; 0x3a
    1904:	f891 603b 	ldrb.w	r6, [r1, #59]	; 0x3b
    1908:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
    190c:	f891 503e 	ldrb.w	r5, [r1, #62]	; 0x3e
    1910:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    1914:	f891 003f 	ldrb.w	r0, [r1, #63]	; 0x3f
    1918:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
    191c:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
    1920:	ea44 6406 	orr.w	r4, r4, r6, lsl #24
    1924:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    1928:	9209      	str	r2, [sp, #36]	; 0x24
    192a:	9408      	str	r4, [sp, #32]
      this->y = u_y.real;
    192c:	e9dd 4508 	ldrd	r4, r5, [sp, #32]
    1930:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1934:	f891 5041 	ldrb.w	r5, [r1, #65]	; 0x41
    1938:	f891 4040 	ldrb.w	r4, [r1, #64]	; 0x40
    193c:	f891 0044 	ldrb.w	r0, [r1, #68]	; 0x44
    1940:	f891 2045 	ldrb.w	r2, [r1, #69]	; 0x45
    1944:	f891 7042 	ldrb.w	r7, [r1, #66]	; 0x42
    1948:	f891 6043 	ldrb.w	r6, [r1, #67]	; 0x43
    194c:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
    1950:	f891 5046 	ldrb.w	r5, [r1, #70]	; 0x46
    1954:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    1958:	f891 0047 	ldrb.w	r0, [r1, #71]	; 0x47
    195c:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
    1960:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
    1964:	ea44 6406 	orr.w	r4, r4, r6, lsl #24
    1968:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    196c:	920b      	str	r2, [sp, #44]	; 0x2c
    196e:	940a      	str	r4, [sp, #40]	; 0x28
      this->z = u_z.real;
    1970:	e9dd 450a 	ldrd	r4, r5, [sp, #40]	; 0x28
    1974:	e9c3 4518 	strd	r4, r5, [r3, #96]	; 0x60
      u_omega_right.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_omega_right.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_omega_right.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_omega_right.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_omega_right.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_omega_right.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1978:	f891 5049 	ldrb.w	r5, [r1, #73]	; 0x49
    197c:	f891 4048 	ldrb.w	r4, [r1, #72]	; 0x48
    1980:	f891 004c 	ldrb.w	r0, [r1, #76]	; 0x4c
    1984:	f891 204d 	ldrb.w	r2, [r1, #77]	; 0x4d
    1988:	f891 704a 	ldrb.w	r7, [r1, #74]	; 0x4a
    198c:	f891 604b 	ldrb.w	r6, [r1, #75]	; 0x4b
    1990:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
    1994:	f891 504e 	ldrb.w	r5, [r1, #78]	; 0x4e
    1998:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    199c:	f891 004f 	ldrb.w	r0, [r1, #79]	; 0x4f
    19a0:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
    19a4:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
    19a8:	ea44 6406 	orr.w	r4, r4, r6, lsl #24
    19ac:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    19b0:	920d      	str	r2, [sp, #52]	; 0x34
    19b2:	940c      	str	r4, [sp, #48]	; 0x30
      this->omega_right = u_omega_right.real;
    19b4:	e9dd 450c 	ldrd	r4, r5, [sp, #48]	; 0x30
    19b8:	e9c3 451a 	strd	r4, r5, [r3, #104]	; 0x68
      u_omega_left.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_omega_left.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_omega_left.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_omega_left.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_omega_left.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_omega_left.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    19bc:	f891 5050 	ldrb.w	r5, [r1, #80]	; 0x50
    19c0:	f891 4051 	ldrb.w	r4, [r1, #81]	; 0x51
    19c4:	f891 0054 	ldrb.w	r0, [r1, #84]	; 0x54
    19c8:	f891 2055 	ldrb.w	r2, [r1, #85]	; 0x55
    19cc:	f891 7052 	ldrb.w	r7, [r1, #82]	; 0x52
    19d0:	f891 6053 	ldrb.w	r6, [r1, #83]	; 0x53
    19d4:	ea45 2404 	orr.w	r4, r5, r4, lsl #8
    19d8:	f891 5056 	ldrb.w	r5, [r1, #86]	; 0x56
    19dc:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    19e0:	f891 0057 	ldrb.w	r0, [r1, #87]	; 0x57
    19e4:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
    19e8:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
    19ec:	ea44 6406 	orr.w	r4, r4, r6, lsl #24
    19f0:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    19f4:	940e      	str	r4, [sp, #56]	; 0x38
    19f6:	920f      	str	r2, [sp, #60]	; 0x3c
      this->omega_left = u_omega_left.real;
    19f8:	e9dd 450e 	ldrd	r4, r5, [sp, #56]	; 0x38
    19fc:	e9c3 451c 	strd	r4, r5, [r3, #112]	; 0x70
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1a00:	f891 5059 	ldrb.w	r5, [r1, #89]	; 0x59
    1a04:	f891 005c 	ldrb.w	r0, [r1, #92]	; 0x5c
    1a08:	f891 4058 	ldrb.w	r4, [r1, #88]	; 0x58
    1a0c:	f891 205d 	ldrb.w	r2, [r1, #93]	; 0x5d
    1a10:	f891 605e 	ldrb.w	r6, [r1, #94]	; 0x5e
    1a14:	f891 e05a 	ldrb.w	lr, [r1, #90]	; 0x5a
    1a18:	f891 705b 	ldrb.w	r7, [r1, #91]	; 0x5b
    1a1c:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
    1a20:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    1a24:	f891 505f 	ldrb.w	r5, [r1, #95]	; 0x5f
    1a28:	ea42 4206 	orr.w	r2, r2, r6, lsl #16
    1a2c:	ea44 410e 	orr.w	r1, r4, lr, lsl #16
    1a30:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
    1a34:	ea41 6107 	orr.w	r1, r1, r7, lsl #24
    1a38:	9110      	str	r1, [sp, #64]	; 0x40
    1a3a:	9211      	str	r2, [sp, #68]	; 0x44
      this->temp = u_temp.real;
    1a3c:	e9dd 4510 	ldrd	r4, r5, [sp, #64]	; 0x40
      offset += sizeof(this->temp);
     return offset;
    }
    1a40:	2060      	movs	r0, #96	; 0x60
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
      this->temp = u_temp.real;
    1a42:	e9c3 451e 	strd	r4, r5, [r3, #120]	; 0x78
      offset += sizeof(this->temp);
     return offset;
    }
    1a46:	b013      	add	sp, #76	; 0x4c
    1a48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00001a4c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)>:
      }
    }
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
    1a4c:	b5f0      	push	{r4, r5, r6, r7, lr}
  {
    if (id >= 100 && !configured_)
    1a4e:	2963      	cmp	r1, #99	; 0x63
      }
    }
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
    1a50:	b085      	sub	sp, #20
  {
    if (id >= 100 && !configured_)
    1a52:	dd03      	ble.n	1a5c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x10>
    1a54:	f890 44f8 	ldrb.w	r4, [r0, #1272]	; 0x4f8
    1a58:	2c00      	cmp	r4, #0
    1a5a:	d046      	beq.n	1aea <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x9e>
      return 0;

    /* serialize message */
    int l = msg->serialize(message_out + 7);
    1a5c:	6813      	ldr	r3, [r2, #0]
    1a5e:	4605      	mov	r5, r0
    1a60:	460f      	mov	r7, r1
    1a62:	4610      	mov	r0, r2
    1a64:	681b      	ldr	r3, [r3, #0]
    1a66:	f205 2123 	addw	r1, r5, #547	; 0x223
    1a6a:	4798      	blx	r3

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    1a6c:	b2c2      	uxtb	r2, r0
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    1a6e:	f3c0 2107 	ubfx	r1, r0, #8, #8
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    1a72:	1856      	adds	r6, r2, r1
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    1a74:	f885 221e 	strb.w	r2, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    1a78:	f347 2207 	sbfx	r2, r7, #8, #8
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    1a7c:	43f6      	mvns	r6, r6

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    1a7e:	23ff      	movs	r3, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    1a80:	f04f 0efe 	mov.w	lr, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    1a84:	b2fc      	uxtb	r4, r7
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    1a86:	f885 2222 	strb.w	r2, [r5, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    1a8a:	1c42      	adds	r2, r0, #1
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    1a8c:	f885 6220 	strb.w	r6, [r5, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    1a90:	f885 121f 	strb.w	r1, [r5, #543]	; 0x21f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    1a94:	f885 321c 	strb.w	r3, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    1a98:	f885 e21d 	strb.w	lr, [r5, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    1a9c:	f885 4221 	strb.w	r4, [r5, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    1aa0:	db0d      	blt.n	1abe <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x72>
    1aa2:	f200 2122 	addw	r1, r0, #546	; 0x222
    1aa6:	4429      	add	r1, r5
    1aa8:	f205 2321 	addw	r3, r5, #545	; 0x221
    1aac:	2200      	movs	r2, #0
    1aae:	e001      	b.n	1ab4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x68>
    1ab0:	f813 4f01 	ldrb.w	r4, [r3, #1]!
    1ab4:	428b      	cmp	r3, r1
      chk += message_out[i];
    1ab6:	4422      	add	r2, r4
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    1ab8:	d1fa      	bne.n	1ab0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x64>
    1aba:	43d3      	mvns	r3, r2
    1abc:	b2db      	uxtb	r3, r3
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    1abe:	182a      	adds	r2, r5, r0
    1ac0:	f100 0408 	add.w	r4, r0, #8

    if (l <= OUTPUT_SIZE)
    1ac4:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    1ac8:	f882 3223 	strb.w	r3, [r2, #547]	; 0x223

    if (l <= OUTPUT_SIZE)
    1acc:	dc17      	bgt.n	1afe <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0xb2>
    1ace:	686a      	ldr	r2, [r5, #4]
    1ad0:	4e35      	ldr	r6, [pc, #212]	; (1ba8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x15c>)
    1ad2:	6813      	ldr	r3, [r2, #0]
    1ad4:	685b      	ldr	r3, [r3, #4]
    1ad6:	42b3      	cmp	r3, r6
    {
      hardware_.write(message_out, l);
    1ad8:	f505 7007 	add.w	r0, r5, #540	; 0x21c
    1adc:	d108      	bne.n	1af0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0xa4>
    1ade:	4621      	mov	r1, r4
    1ae0:	f005 ffc4 	bl	7a6c <usb_serial_write>
    1ae4:	4620      	mov	r0, r4
    else
    {
      logerror("Message from device dropped: message larger than buffer.");
      return -1;
    }
  }
    1ae6:	b005      	add	sp, #20
    1ae8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
      return 0;
    1aea:	4620      	mov	r0, r4
    else
    {
      logerror("Message from device dropped: message larger than buffer.");
      return -1;
    }
  }
    1aec:	b005      	add	sp, #20
    1aee:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1af0:	4601      	mov	r1, r0
    1af2:	4610      	mov	r0, r2
    1af4:	4622      	mov	r2, r4
    1af6:	4798      	blx	r3
    1af8:	4620      	mov	r0, r4
    1afa:	b005      	add	sp, #20
    1afc:	bdf0      	pop	{r4, r5, r6, r7, pc}
      enum { ERROR = 3 };
      enum { FATAL = 4 };

    Log():
      level(0),
      msg("")
    1afe:	4a2b      	ldr	r2, [pc, #172]	; (1bac <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x160>)
protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    1b00:	492b      	ldr	r1, [pc, #172]	; (1bb0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x164>)
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    1b02:	682b      	ldr	r3, [r5, #0]
    1b04:	9201      	str	r2, [sp, #4]

protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    1b06:	2003      	movs	r0, #3
    1b08:	f88d 0008 	strb.w	r0, [sp, #8]
    l.msg = (char*)msg;
    1b0c:	9103      	str	r1, [sp, #12]
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    1b0e:	681b      	ldr	r3, [r3, #0]
    1b10:	4a28      	ldr	r2, [pc, #160]	; (1bb4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x168>)
    1b12:	4293      	cmp	r3, r2
    1b14:	d13f      	bne.n	1b96 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x14a>
    1b16:	2400      	movs	r4, #0
    1b18:	2238      	movs	r2, #56	; 0x38
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    1b1a:	f885 0223 	strb.w	r0, [r5, #547]	; 0x223
    1b1e:	f885 2224 	strb.w	r2, [r5, #548]	; 0x224
    1b22:	f885 4225 	strb.w	r4, [r5, #549]	; 0x225
    1b26:	f885 4226 	strb.w	r4, [r5, #550]	; 0x226
    1b2a:	f885 4227 	strb.w	r4, [r5, #551]	; 0x227
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    1b2e:	f505 700a 	add.w	r0, r5, #552	; 0x228
    1b32:	f004 fc83 	bl	643c <memcpy>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    1b36:	27ff      	movs	r7, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    1b38:	203d      	movs	r0, #61	; 0x3d
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    1b3a:	23c2      	movs	r3, #194	; 0xc2
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    1b3c:	26fe      	movs	r6, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    1b3e:	2107      	movs	r1, #7
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    1b40:	f885 021e 	strb.w	r0, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    1b44:	f885 3220 	strb.w	r3, [r5, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    1b48:	f885 421f 	strb.w	r4, [r5, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    1b4c:	f885 4222 	strb.w	r4, [r5, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    1b50:	4622      	mov	r2, r4

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    1b52:	f885 721c 	strb.w	r7, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    1b56:	f885 621d 	strb.w	r6, [r5, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    1b5a:	f885 1221 	strb.w	r1, [r5, #545]	; 0x221
    1b5e:	f205 2321 	addw	r3, r5, #545	; 0x221
    1b62:	f205 205f 	addw	r0, r5, #607	; 0x25f
    1b66:	e001      	b.n	1b6c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x120>
    1b68:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    1b6c:	4298      	cmp	r0, r3
      chk += message_out[i];
    1b6e:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    1b70:	d1fa      	bne.n	1b68 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x11c>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    1b72:	43d2      	mvns	r2, r2
    1b74:	6868      	ldr	r0, [r5, #4]
    1b76:	f885 2260 	strb.w	r2, [r5, #608]	; 0x260
    1b7a:	6803      	ldr	r3, [r0, #0]
    1b7c:	4a0a      	ldr	r2, [pc, #40]	; (1ba8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x15c>)
    1b7e:	685b      	ldr	r3, [r3, #4]
    1b80:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    1b82:	f505 7107 	add.w	r1, r5, #540	; 0x21c
    1b86:	d10b      	bne.n	1ba0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x154>
    1b88:	4608      	mov	r0, r1
    1b8a:	2145      	movs	r1, #69	; 0x45
    1b8c:	f005 ff6e 	bl	7a6c <usb_serial_write>
    1b90:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1b94:	e7a7      	b.n	1ae6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x9a>
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    1b96:	4628      	mov	r0, r5
    1b98:	aa01      	add	r2, sp, #4
    1b9a:	2107      	movs	r1, #7
    1b9c:	4798      	blx	r3
    1b9e:	e7f7      	b.n	1b90 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x144>
    1ba0:	2245      	movs	r2, #69	; 0x45
    1ba2:	4798      	blx	r3
    1ba4:	e7f4      	b.n	1b90 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x144>
    1ba6:	bf00      	nop
    1ba8:	00000ebd 	.word	0x00000ebd
    1bac:	0000bc54 	.word	0x0000bc54
    1bb0:	0000bf68 	.word	0x0000bf68
    1bb4:	00001a4d 	.word	0x00001a4d

00001bb8 <omega_to_pwm(double)>:
    array_push(speed_array_left, current_omega_left);
  }
  average_omega_left = averaging_array(speed_array_left);
}

int omega_to_pwm(double x){
    1bb8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    1bbc:	ec55 4b10 	vmov	r4, r5, d0
    1bc0:	b082      	sub	sp, #8
  double pwm_cal;
  int sign;
  if(x < 0){
    1bc2:	2200      	movs	r2, #0
    1bc4:	2300      	movs	r3, #0
    1bc6:	ee10 0a10 	vmov	r0, s0
    1bca:	4629      	mov	r1, r5
    1bcc:	f008 faac 	bl	a128 <__aeabi_dcmplt>
    sign = -1;
  }
  else{
    sign = 1;
  }
  if (abs(x) > change_over_point){
    1bd0:	2200      	movs	r2, #0
  int sign;
  if(x < 0){
    sign = -1;
  }
  else{
    sign = 1;
    1bd2:	2800      	cmp	r0, #0
  }
  if (abs(x) > change_over_point){
    1bd4:	f04f 0300 	mov.w	r3, #0
    1bd8:	4620      	mov	r0, r4
    1bda:	4629      	mov	r1, r5
  int sign;
  if(x < 0){
    sign = -1;
  }
  else{
    sign = 1;
    1bdc:	bf14      	ite	ne
    1bde:	f04f 3aff 	movne.w	sl, #4294967295	; 0xffffffff
    1be2:	f04f 0a01 	moveq.w	sl, #1
  }
  if (abs(x) > change_over_point){
    1be6:	f008 fabd 	bl	a164 <__aeabi_dcmpgt>
    1bea:	2200      	movs	r2, #0
    1bec:	2800      	cmp	r0, #0
    1bee:	f000 80a2 	beq.w	1d36 <omega_to_pwm(double)+0x17e>
    1bf2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    1bf6:	4620      	mov	r0, r4
    1bf8:	4629      	mov	r1, r5
    1bfa:	f008 fab3 	bl	a164 <__aeabi_dcmpgt>
    1bfe:	b3b8      	cbz	r0, 1c70 <omega_to_pwm(double)+0xb8>
    pwm_cal = a*pow(abs(x),3)+b*pow(abs(x),2)+c*abs(x)+d;
    1c00:	ed9f 1b79 	vldr	d1, [pc, #484]	; 1de8 <omega_to_pwm(double)+0x230>
    1c04:	ec45 4b10 	vmov	d0, r4, r5
    1c08:	f006 fa72 	bl	80f0 <pow>
    1c0c:	4622      	mov	r2, r4
    1c0e:	462b      	mov	r3, r5
    1c10:	4620      	mov	r0, r4
    1c12:	4629      	mov	r1, r5
    1c14:	ed8d 0b00 	vstr	d0, [sp]
    1c18:	f008 f814 	bl	9c44 <__aeabi_dmul>
    1c1c:	a374      	add	r3, pc, #464	; (adr r3, 1df0 <omega_to_pwm(double)+0x238>)
    1c1e:	e9d3 2300 	ldrd	r2, r3, [r3]
    1c22:	f008 f80f 	bl	9c44 <__aeabi_dmul>
    1c26:	ed9d 0b00 	vldr	d0, [sp]
    1c2a:	a373      	add	r3, pc, #460	; (adr r3, 1df8 <omega_to_pwm(double)+0x240>)
    1c2c:	e9d3 2300 	ldrd	r2, r3, [r3]
    1c30:	4606      	mov	r6, r0
    1c32:	460f      	mov	r7, r1
    1c34:	ec51 0b10 	vmov	r0, r1, d0
    1c38:	f008 f804 	bl	9c44 <__aeabi_dmul>
    1c3c:	4602      	mov	r2, r0
    1c3e:	460b      	mov	r3, r1
    1c40:	4630      	mov	r0, r6
    1c42:	4639      	mov	r1, r7
    1c44:	f007 fe4c 	bl	98e0 <__adddf3>
    1c48:	4606      	mov	r6, r0
    1c4a:	460f      	mov	r7, r1
    1c4c:	4620      	mov	r0, r4
    1c4e:	4629      	mov	r1, r5
    1c50:	a36b      	add	r3, pc, #428	; (adr r3, 1e00 <omega_to_pwm(double)+0x248>)
    1c52:	e9d3 2300 	ldrd	r2, r3, [r3]
    1c56:	f007 fff5 	bl	9c44 <__aeabi_dmul>
    1c5a:	4632      	mov	r2, r6
    1c5c:	463b      	mov	r3, r7
    1c5e:	f007 fe3f 	bl	98e0 <__adddf3>
    1c62:	a369      	add	r3, pc, #420	; (adr r3, 1e08 <omega_to_pwm(double)+0x250>)
    1c64:	e9d3 2300 	ldrd	r2, r3, [r3]
    1c68:	f007 fe38 	bl	98dc <__aeabi_dsub>
    1c6c:	4606      	mov	r6, r0
    1c6e:	460f      	mov	r7, r1
  }
  if (abs(x) <= change_over_point && abs(x) > 0.01){
    1c70:	2200      	movs	r2, #0
    1c72:	2300      	movs	r3, #0
    1c74:	4620      	mov	r0, r4
    1c76:	4629      	mov	r1, r5
    1c78:	f008 fa74 	bl	a164 <__aeabi_dcmpgt>
    1c7c:	2200      	movs	r2, #0
    1c7e:	b3a8      	cbz	r0, 1cec <omega_to_pwm(double)+0x134>
    1c80:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    1c84:	4620      	mov	r0, r4
    1c86:	4629      	mov	r1, r5
    1c88:	f008 fa58 	bl	a13c <__aeabi_dcmple>
    1c8c:	b9b0      	cbnz	r0, 1cbc <omega_to_pwm(double)+0x104>
    pwm_cal = a_2*abs(x) + b_2;
  }
  if (pwm_cal>opper_lim){
    1c8e:	a360      	add	r3, pc, #384	; (adr r3, 1e10 <omega_to_pwm(double)+0x258>)
    1c90:	e9d3 2300 	ldrd	r2, r3, [r3]
    1c94:	4630      	mov	r0, r6
    1c96:	4639      	mov	r1, r7
    1c98:	f008 fa64 	bl	a164 <__aeabi_dcmpgt>
    1c9c:	b110      	cbz	r0, 1ca4 <omega_to_pwm(double)+0xec>
    pwm_cal = opper_lim;
    1c9e:	a75c      	add	r7, pc, #368	; (adr r7, 1e10 <omega_to_pwm(double)+0x258>)
    1ca0:	e9d7 6700 	ldrd	r6, r7, [r7]
  }
  int pwm_int = sign * pwm_cal;

  return pwm_int;
    1ca4:	4650      	mov	r0, sl
    1ca6:	f007 ff67 	bl	9b78 <__aeabi_i2d>
    1caa:	4632      	mov	r2, r6
    1cac:	463b      	mov	r3, r7
    1cae:	f007 ffc9 	bl	9c44 <__aeabi_dmul>
    1cb2:	f008 fa77 	bl	a1a4 <__aeabi_d2iz>
}
    1cb6:	b002      	add	sp, #8
    1cb8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    sign = 1;
  }
  if (abs(x) > change_over_point){
    pwm_cal = a*pow(abs(x),3)+b*pow(abs(x),2)+c*abs(x)+d;
  }
  if (abs(x) <= change_over_point && abs(x) > 0.01){
    1cbc:	a356      	add	r3, pc, #344	; (adr r3, 1e18 <omega_to_pwm(double)+0x260>)
    1cbe:	e9d3 2300 	ldrd	r2, r3, [r3]
    1cc2:	4620      	mov	r0, r4
    1cc4:	4629      	mov	r1, r5
    1cc6:	f008 fa4d 	bl	a164 <__aeabi_dcmpgt>
    1cca:	2800      	cmp	r0, #0
    1ccc:	d0df      	beq.n	1c8e <omega_to_pwm(double)+0xd6>
    pwm_cal = a_2*abs(x) + b_2;
    1cce:	4620      	mov	r0, r4
    1cd0:	4629      	mov	r1, r5
    1cd2:	a353      	add	r3, pc, #332	; (adr r3, 1e20 <omega_to_pwm(double)+0x268>)
    1cd4:	e9d3 2300 	ldrd	r2, r3, [r3]
    1cd8:	f007 ffb4 	bl	9c44 <__aeabi_dmul>
    1cdc:	a352      	add	r3, pc, #328	; (adr r3, 1e28 <omega_to_pwm(double)+0x270>)
    1cde:	e9d3 2300 	ldrd	r2, r3, [r3]
    1ce2:	f007 fdfd 	bl	98e0 <__adddf3>
    1ce6:	4606      	mov	r6, r0
    1ce8:	460f      	mov	r7, r1
    1cea:	e7d0      	b.n	1c8e <omega_to_pwm(double)+0xd6>
    sign = 1;
  }
  if (abs(x) > change_over_point){
    pwm_cal = a*pow(abs(x),3)+b*pow(abs(x),2)+c*abs(x)+d;
  }
  if (abs(x) <= change_over_point && abs(x) > 0.01){
    1cec:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
    1cf0:	4620      	mov	r0, r4
    1cf2:	4629      	mov	r1, r5
    1cf4:	f008 fa2c 	bl	a150 <__aeabi_dcmpge>
    1cf8:	2800      	cmp	r0, #0
    1cfa:	d0c8      	beq.n	1c8e <omega_to_pwm(double)+0xd6>
    1cfc:	2200      	movs	r2, #0
    1cfe:	2300      	movs	r3, #0
    1d00:	4620      	mov	r0, r4
    1d02:	4629      	mov	r1, r5
    1d04:	f008 fa2e 	bl	a164 <__aeabi_dcmpgt>
    1d08:	2800      	cmp	r0, #0
    1d0a:	d1d7      	bne.n	1cbc <omega_to_pwm(double)+0x104>
    1d0c:	a348      	add	r3, pc, #288	; (adr r3, 1e30 <omega_to_pwm(double)+0x278>)
    1d0e:	e9d3 2300 	ldrd	r2, r3, [r3]
    1d12:	4620      	mov	r0, r4
    1d14:	4629      	mov	r1, r5
    1d16:	f008 fa07 	bl	a128 <__aeabi_dcmplt>
    1d1a:	2800      	cmp	r0, #0
    1d1c:	d0b7      	beq.n	1c8e <omega_to_pwm(double)+0xd6>
    pwm_cal = a_2*abs(x) + b_2;
    1d1e:	2200      	movs	r2, #0
    1d20:	2300      	movs	r3, #0
    1d22:	4620      	mov	r0, r4
    1d24:	4629      	mov	r1, r5
    1d26:	f008 fa1d 	bl	a164 <__aeabi_dcmpgt>
    1d2a:	2800      	cmp	r0, #0
    1d2c:	d1cf      	bne.n	1cce <omega_to_pwm(double)+0x116>
    1d2e:	4620      	mov	r0, r4
    1d30:	f105 4100 	add.w	r1, r5, #2147483648	; 0x80000000
    1d34:	e7cd      	b.n	1cd2 <omega_to_pwm(double)+0x11a>
    sign = -1;
  }
  else{
    sign = 1;
  }
  if (abs(x) > change_over_point){
    1d36:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
    1d3a:	4620      	mov	r0, r4
    1d3c:	4629      	mov	r1, r5
    1d3e:	f008 f9f3 	bl	a128 <__aeabi_dcmplt>
    1d42:	2800      	cmp	r0, #0
    1d44:	d094      	beq.n	1c70 <omega_to_pwm(double)+0xb8>
    pwm_cal = a*pow(abs(x),3)+b*pow(abs(x),2)+c*abs(x)+d;
    1d46:	2200      	movs	r2, #0
    1d48:	2300      	movs	r3, #0
    1d4a:	4620      	mov	r0, r4
    1d4c:	4629      	mov	r1, r5
    1d4e:	f008 fa09 	bl	a164 <__aeabi_dcmpgt>
    1d52:	2800      	cmp	r0, #0
    1d54:	f47f af54 	bne.w	1c00 <omega_to_pwm(double)+0x48>
    1d58:	46a0      	mov	r8, r4
    1d5a:	f105 4900 	add.w	r9, r5, #2147483648	; 0x80000000
    1d5e:	ed9f 1b22 	vldr	d1, [pc, #136]	; 1de8 <omega_to_pwm(double)+0x230>
    1d62:	ec49 8b10 	vmov	d0, r8, r9
    1d66:	f006 f9c3 	bl	80f0 <pow>
    1d6a:	a323      	add	r3, pc, #140	; (adr r3, 1df8 <omega_to_pwm(double)+0x240>)
    1d6c:	e9d3 2300 	ldrd	r2, r3, [r3]
    1d70:	ec51 0b10 	vmov	r0, r1, d0
    1d74:	f007 ff66 	bl	9c44 <__aeabi_dmul>
    1d78:	2200      	movs	r2, #0
    1d7a:	4606      	mov	r6, r0
    1d7c:	460f      	mov	r7, r1
    1d7e:	2300      	movs	r3, #0
    1d80:	4620      	mov	r0, r4
    1d82:	4629      	mov	r1, r5
    1d84:	f008 f9ee 	bl	a164 <__aeabi_dcmpgt>
    1d88:	b9d0      	cbnz	r0, 1dc0 <omega_to_pwm(double)+0x208>
    1d8a:	4622      	mov	r2, r4
    1d8c:	464b      	mov	r3, r9
    1d8e:	4620      	mov	r0, r4
    1d90:	4649      	mov	r1, r9
    1d92:	f007 ff57 	bl	9c44 <__aeabi_dmul>
    1d96:	a316      	add	r3, pc, #88	; (adr r3, 1df0 <omega_to_pwm(double)+0x238>)
    1d98:	e9d3 2300 	ldrd	r2, r3, [r3]
    1d9c:	f007 ff52 	bl	9c44 <__aeabi_dmul>
    1da0:	4632      	mov	r2, r6
    1da2:	463b      	mov	r3, r7
    1da4:	f007 fd9c 	bl	98e0 <__adddf3>
    1da8:	2200      	movs	r2, #0
    1daa:	4606      	mov	r6, r0
    1dac:	460f      	mov	r7, r1
    1dae:	2300      	movs	r3, #0
    1db0:	4620      	mov	r0, r4
    1db2:	4629      	mov	r1, r5
    1db4:	f008 f9d6 	bl	a164 <__aeabi_dcmpgt>
    1db8:	b980      	cbnz	r0, 1ddc <omega_to_pwm(double)+0x224>
    1dba:	4620      	mov	r0, r4
    1dbc:	4649      	mov	r1, r9
    1dbe:	e747      	b.n	1c50 <omega_to_pwm(double)+0x98>
    1dc0:	4622      	mov	r2, r4
    1dc2:	462b      	mov	r3, r5
    1dc4:	4620      	mov	r0, r4
    1dc6:	4629      	mov	r1, r5
    1dc8:	f007 ff3c 	bl	9c44 <__aeabi_dmul>
    1dcc:	a308      	add	r3, pc, #32	; (adr r3, 1df0 <omega_to_pwm(double)+0x238>)
    1dce:	e9d3 2300 	ldrd	r2, r3, [r3]
    1dd2:	f007 ff37 	bl	9c44 <__aeabi_dmul>
    1dd6:	4632      	mov	r2, r6
    1dd8:	463b      	mov	r3, r7
    1dda:	e733      	b.n	1c44 <omega_to_pwm(double)+0x8c>
    1ddc:	4620      	mov	r0, r4
    1dde:	4629      	mov	r1, r5
    1de0:	e736      	b.n	1c50 <omega_to_pwm(double)+0x98>
    1de2:	bf00      	nop
    1de4:	f3af 8000 	nop.w
    1de8:	00000000 	.word	0x00000000
    1dec:	40080000 	.word	0x40080000
    1df0:	00000000 	.word	0x00000000
    1df4:	c00bb22d 	.word	0xc00bb22d
    1df8:	a0000000 	.word	0xa0000000
    1dfc:	3fc84ea4 	.word	0x3fc84ea4
    1e00:	20000000 	.word	0x20000000
    1e04:	4037c7ae 	.word	0x4037c7ae
    1e08:	20000000 	.word	0x20000000
    1e0c:	40229d2f 	.word	0x40229d2f
    1e10:	00000000 	.word	0x00000000
    1e14:	406fe000 	.word	0x406fe000
    1e18:	40000000 	.word	0x40000000
    1e1c:	3f847ae1 	.word	0x3f847ae1
    1e20:	c0000000 	.word	0xc0000000
    1e24:	3ffb851e 	.word	0x3ffb851e
    1e28:	a0000000 	.word	0xa0000000
    1e2c:	4036e147 	.word	0x4036e147
    1e30:	40000000 	.word	0x40000000
    1e34:	bf847ae1 	.word	0xbf847ae1

00001e38 <setPWM(int, int)>:

  return pwm_int;
}


void setPWM(int pwm_right, int pwm_left) {
    1e38:	b570      	push	{r4, r5, r6, lr}
  //setting the correct direction of the motor
  direction_indicator_right = 0;
  direction_indicator_left = 0;
    1e3a:	4a1e      	ldr	r2, [pc, #120]	; (1eb4 <setPWM(int, int)+0x7c>)
}


void setPWM(int pwm_right, int pwm_left) {
  //setting the correct direction of the motor
  direction_indicator_right = 0;
    1e3c:	4e1e      	ldr	r6, [pc, #120]	; (1eb8 <setPWM(int, int)+0x80>)
    1e3e:	2300      	movs	r3, #0
  direction_indicator_left = 0;
  if(pwm_right >= 0){
    1e40:	1e05      	subs	r5, r0, #0
}


void setPWM(int pwm_right, int pwm_left) {
  //setting the correct direction of the motor
  direction_indicator_right = 0;
    1e42:	6033      	str	r3, [r6, #0]
  direction_indicator_left = 0;
    1e44:	6013      	str	r3, [r2, #0]
  if(pwm_right >= 0){
    direction_indicator_right = 1;
    1e46:	bfa8      	it	ge
    1e48:	2301      	movge	r3, #1

  return pwm_int;
}


void setPWM(int pwm_right, int pwm_left) {
    1e4a:	460c      	mov	r4, r1
  //setting the correct direction of the motor
  direction_indicator_right = 0;
  direction_indicator_left = 0;
  if(pwm_right >= 0){
    direction_indicator_right = 1;
    1e4c:	bfa8      	it	ge
    1e4e:	6033      	strge	r3, [r6, #0]
  }
  if(pwm_left >= 0){
    1e50:	2900      	cmp	r1, #0
    direction_indicator_left = 1;
  }
  digitalWrite(right_motor_ina, pwm_right >= 0);
    1e52:	ea6f 0105 	mvn.w	r1, r5
  direction_indicator_left = 0;
  if(pwm_right >= 0){
    direction_indicator_right = 1;
  }
  if(pwm_left >= 0){
    direction_indicator_left = 1;
    1e56:	bfa8      	it	ge
    1e58:	2301      	movge	r3, #1
  }
  digitalWrite(right_motor_ina, pwm_right >= 0);
    1e5a:	ea4f 71d1 	mov.w	r1, r1, lsr #31
    1e5e:	f04f 001e 	mov.w	r0, #30
  direction_indicator_left = 0;
  if(pwm_right >= 0){
    direction_indicator_right = 1;
  }
  if(pwm_left >= 0){
    direction_indicator_left = 1;
    1e62:	bfa8      	it	ge
    1e64:	6013      	strge	r3, [r2, #0]
  }
  digitalWrite(right_motor_ina, pwm_right >= 0);
    1e66:	f004 fec9 	bl	6bfc <digitalWrite>
  digitalWrite(right_motor_inb, pwm_right < 0);
    1e6a:	0fe9      	lsrs	r1, r5, #31
    1e6c:	201c      	movs	r0, #28
    1e6e:	f004 fec5 	bl	6bfc <digitalWrite>
  digitalWrite(left_motor_ina, pwm_left >= 0);
    1e72:	43e1      	mvns	r1, r4
    1e74:	0fc9      	lsrs	r1, r1, #31
    1e76:	2027      	movs	r0, #39	; 0x27
    1e78:	f004 fec0 	bl	6bfc <digitalWrite>
  digitalWrite(left_motor_inb, pwm_left < 0);
    1e7c:	0fe1      	lsrs	r1, r4, #31
    1e7e:	2025      	movs	r0, #37	; 0x25
    1e80:	f004 febc 	bl	6bfc <digitalWrite>
  //setting the value of the motor
  pwm_right = abs(pwm_right);
    1e84:	ea85 71e5 	eor.w	r1, r5, r5, asr #31
    1e88:	eba1 71e5 	sub.w	r1, r1, r5, asr #31
  pwm_left = abs(pwm_left);
    1e8c:	2c00      	cmp	r4, #0
    1e8e:	bfb8      	it	lt
    1e90:	4264      	neglt	r4, r4
    pwm_left = 255;
  }
  if (pwm_right > 255) {
    pwm_right = 255;
  }
  analogWrite(right_motor_pwm, pwm_right);
    1e92:	29ff      	cmp	r1, #255	; 0xff
    1e94:	bfa8      	it	ge
    1e96:	21ff      	movge	r1, #255	; 0xff
    1e98:	201d      	movs	r0, #29
    1e9a:	f004 fd0f 	bl	68bc <analogWrite>
  analogWrite(left_motor_pwm, pwm_left);
    1e9e:	2cff      	cmp	r4, #255	; 0xff
    1ea0:	4621      	mov	r1, r4
    1ea2:	f04f 0026 	mov.w	r0, #38	; 0x26
    1ea6:	bfa8      	it	ge
    1ea8:	21ff      	movge	r1, #255	; 0xff
}
    1eaa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  }
  if (pwm_right > 255) {
    pwm_right = 255;
  }
  analogWrite(right_motor_pwm, pwm_right);
  analogWrite(left_motor_pwm, pwm_left);
    1eae:	f004 bd05 	b.w	68bc <analogWrite>
    1eb2:	bf00      	nop
    1eb4:	1fff1d60 	.word	0x1fff1d60
    1eb8:	1fff2298 	.word	0x1fff2298

00001ebc <speed_PID_controller(double, double, double, double, double, double, double)>:
}

void speed_PID_controller(double goal_wheel_speed_r, double current_wheel_speed_r, double last_error_r, double goal_wheel_speed_l, double current_wheel_speed_l, double last_error_l, double elapsed_time){
    1ebc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1ec0:	b08d      	sub	sp, #52	; 0x34
    1ec2:	ec59 8b16 	vmov	r8, r9, d6
    1ec6:	ed8d 2b06 	vstr	d2, [sp, #24]
    1eca:	ed8d 5b04 	vstr	d5, [sp, #16]
    1ece:	ed8d 3b02 	vstr	d3, [sp, #8]
    1ed2:	ed8d 4b00 	vstr	d4, [sp]
    1ed6:	ed8d 0b0a 	vstr	d0, [sp, #40]	; 0x28
    1eda:	ed8d 1b08 	vstr	d1, [sp, #32]
  //double error_r = goal_wheel_speed_r - current_wheel_speed_r;
  previous_time = micros();
    1ede:	f004 fe99 	bl	6c14 <micros>
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
    1ee2:	ed9d 1b08 	vldr	d1, [sp, #32]
    1ee6:	ed9d 0b0a 	vldr	d0, [sp, #40]	; 0x28
  analogWrite(left_motor_pwm, pwm_left);
}

void speed_PID_controller(double goal_wheel_speed_r, double current_wheel_speed_r, double last_error_r, double goal_wheel_speed_l, double current_wheel_speed_l, double last_error_l, double elapsed_time){
  //double error_r = goal_wheel_speed_r - current_wheel_speed_r;
  previous_time = micros();
    1eea:	4b57      	ldr	r3, [pc, #348]	; (2048 <speed_PID_controller(double, double, double, double, double, double, double)+0x18c>)
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
    1eec:	4c57      	ldr	r4, [pc, #348]	; (204c <speed_PID_controller(double, double, double, double, double, double, double)+0x190>)
  analogWrite(left_motor_pwm, pwm_left);
}

void speed_PID_controller(double goal_wheel_speed_r, double current_wheel_speed_r, double last_error_r, double goal_wheel_speed_l, double current_wheel_speed_l, double last_error_l, double elapsed_time){
  //double error_r = goal_wheel_speed_r - current_wheel_speed_r;
  previous_time = micros();
    1eee:	6018      	str	r0, [r3, #0]
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
    1ef0:	ec53 2b11 	vmov	r2, r3, d1
    1ef4:	ec51 0b10 	vmov	r0, r1, d0
    1ef8:	f007 fcf0 	bl	98dc <__aeabi_dsub>
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
    1efc:	ed9d 4b00 	vldr	d4, [sp]
    1f00:	ed9d 3b02 	vldr	d3, [sp, #8]

void speed_PID_controller(double goal_wheel_speed_r, double current_wheel_speed_r, double last_error_r, double goal_wheel_speed_l, double current_wheel_speed_l, double last_error_l, double elapsed_time){
  //double error_r = goal_wheel_speed_r - current_wheel_speed_r;
  previous_time = micros();
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
    1f04:	4682      	mov	sl, r0
    1f06:	468b      	mov	fp, r1
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
    1f08:	ec53 2b14 	vmov	r2, r3, d4
    1f0c:	ec51 0b13 	vmov	r0, r1, d3

void speed_PID_controller(double goal_wheel_speed_r, double current_wheel_speed_r, double last_error_r, double goal_wheel_speed_l, double current_wheel_speed_l, double last_error_l, double elapsed_time){
  //double error_r = goal_wheel_speed_r - current_wheel_speed_r;
  previous_time = micros();
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
    1f10:	e9c4 ab00 	strd	sl, fp, [r4]
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
    1f14:	f007 fce2 	bl	98dc <__aeabi_dsub>
    1f18:	4604      	mov	r4, r0
    1f1a:	460d      	mov	r5, r1
    1f1c:	ec45 4b17 	vmov	d7, r4, r5
    1f20:	4f4b      	ldr	r7, [pc, #300]	; (2050 <speed_PID_controller(double, double, double, double, double, double, double)+0x194>)
  cum_error_r += error_r * elapsed_time;
    1f22:	4e4c      	ldr	r6, [pc, #304]	; (2054 <speed_PID_controller(double, double, double, double, double, double, double)+0x198>)
  //double error_r = goal_wheel_speed_r - current_wheel_speed_r;
  previous_time = micros();
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
    1f24:	ed87 7b00 	vstr	d7, [r7]
  cum_error_r += error_r * elapsed_time;
    1f28:	4642      	mov	r2, r8
    1f2a:	464b      	mov	r3, r9
    1f2c:	4650      	mov	r0, sl
    1f2e:	4659      	mov	r1, fp
  //double error_r = goal_wheel_speed_r - current_wheel_speed_r;
  previous_time = micros();
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
    1f30:	e9cd 4500 	strd	r4, r5, [sp]
  cum_error_r += error_r * elapsed_time;
    1f34:	f007 fe86 	bl	9c44 <__aeabi_dmul>
    1f38:	e9d6 2300 	ldrd	r2, r3, [r6]
    1f3c:	f007 fcd0 	bl	98e0 <__adddf3>
    1f40:	4604      	mov	r4, r0
    1f42:	460d      	mov	r5, r1
    1f44:	ec45 4b17 	vmov	d7, r4, r5
  cum_error_l += error_l * elapsed_time;
    1f48:	4642      	mov	r2, r8
  previous_time = micros();
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
  cum_error_r += error_r * elapsed_time;
    1f4a:	ed86 7b00 	vstr	d7, [r6]
  cum_error_l += error_l * elapsed_time;
    1f4e:	464b      	mov	r3, r9
    1f50:	e9dd 0100 	ldrd	r0, r1, [sp]
  previous_time = micros();
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
  cum_error_r += error_r * elapsed_time;
    1f54:	e9cd 4502 	strd	r4, r5, [sp, #8]
  cum_error_l += error_l * elapsed_time;
    1f58:	f007 fe74 	bl	9c44 <__aeabi_dmul>
    1f5c:	4b3e      	ldr	r3, [pc, #248]	; (2058 <speed_PID_controller(double, double, double, double, double, double, double)+0x19c>)
    1f5e:	e9d3 2300 	ldrd	r2, r3, [r3]
    1f62:	f007 fcbd 	bl	98e0 <__adddf3>
  double rate_error_r = (error_r - last_error_r) / elapsed_time;
  double rate_error_l = (error_l - last_error_l) / elapsed_time;
  double controller_output_r = error_r * p_gain + cum_error_r * i_gain + rate_error_r * d_gain;
  double controller_output_l = error_l * p_gain + cum_error_l * i_gain + rate_error_l * d_gain;
    1f66:	e9dd 4500 	ldrd	r4, r5, [sp]
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
  cum_error_r += error_r * elapsed_time;
  cum_error_l += error_l * elapsed_time;
    1f6a:	4606      	mov	r6, r0
  double rate_error_r = (error_r - last_error_r) / elapsed_time;
  double rate_error_l = (error_l - last_error_l) / elapsed_time;
  double controller_output_r = error_r * p_gain + cum_error_r * i_gain + rate_error_r * d_gain;
  double controller_output_l = error_l * p_gain + cum_error_l * i_gain + rate_error_l * d_gain;
    1f6c:	4622      	mov	r2, r4
    1f6e:	4620      	mov	r0, r4
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
  cum_error_r += error_r * elapsed_time;
  cum_error_l += error_l * elapsed_time;
    1f70:	4c39      	ldr	r4, [pc, #228]	; (2058 <speed_PID_controller(double, double, double, double, double, double, double)+0x19c>)
    1f72:	460f      	mov	r7, r1
    1f74:	e9c4 6700 	strd	r6, r7, [r4]
  double rate_error_r = (error_r - last_error_r) / elapsed_time;
  double rate_error_l = (error_l - last_error_l) / elapsed_time;
  double controller_output_r = error_r * p_gain + cum_error_r * i_gain + rate_error_r * d_gain;
  double controller_output_l = error_l * p_gain + cum_error_l * i_gain + rate_error_l * d_gain;
    1f78:	462b      	mov	r3, r5
    1f7a:	4629      	mov	r1, r5
    1f7c:	f007 fcb0 	bl	98e0 <__adddf3>
    1f80:	2200      	movs	r2, #0
    1f82:	4604      	mov	r4, r0
    1f84:	460d      	mov	r5, r1
    1f86:	4b35      	ldr	r3, [pc, #212]	; (205c <speed_PID_controller(double, double, double, double, double, double, double)+0x1a0>)
    1f88:	4630      	mov	r0, r6
    1f8a:	4639      	mov	r1, r7
    1f8c:	f007 fe5a 	bl	9c44 <__aeabi_dmul>
    1f90:	4602      	mov	r2, r0
    1f92:	460b      	mov	r3, r1
    1f94:	4620      	mov	r0, r4
    1f96:	4629      	mov	r1, r5
    1f98:	f007 fca2 	bl	98e0 <__adddf3>
    1f9c:	ed9d 5b04 	vldr	d5, [sp, #16]
    1fa0:	4606      	mov	r6, r0
    1fa2:	ec53 2b15 	vmov	r2, r3, d5
    1fa6:	460f      	mov	r7, r1
    1fa8:	e9dd 0100 	ldrd	r0, r1, [sp]
    1fac:	f007 fc96 	bl	98dc <__aeabi_dsub>
    1fb0:	4642      	mov	r2, r8
    1fb2:	464b      	mov	r3, r9
    1fb4:	f007 ff70 	bl	9e98 <__aeabi_ddiv>
    1fb8:	2200      	movs	r2, #0
    1fba:	2300      	movs	r3, #0
    1fbc:	f007 fe42 	bl	9c44 <__aeabi_dmul>
    1fc0:	4602      	mov	r2, r0
    1fc2:	460b      	mov	r3, r1
    1fc4:	4630      	mov	r0, r6
    1fc6:	4639      	mov	r1, r7
    1fc8:	f007 fc8a 	bl	98e0 <__adddf3>
  double pwm_signal_r = omega_to_pwm(controller_output_r);
    1fcc:	4652      	mov	r2, sl
  cum_error_r += error_r * elapsed_time;
  cum_error_l += error_l * elapsed_time;
  double rate_error_r = (error_r - last_error_r) / elapsed_time;
  double rate_error_l = (error_l - last_error_l) / elapsed_time;
  double controller_output_r = error_r * p_gain + cum_error_r * i_gain + rate_error_r * d_gain;
  double controller_output_l = error_l * p_gain + cum_error_l * i_gain + rate_error_l * d_gain;
    1fce:	4606      	mov	r6, r0
    1fd0:	460f      	mov	r7, r1
  double pwm_signal_r = omega_to_pwm(controller_output_r);
    1fd2:	465b      	mov	r3, fp
    1fd4:	4650      	mov	r0, sl
    1fd6:	4659      	mov	r1, fp
    1fd8:	f007 fc82 	bl	98e0 <__adddf3>
    1fdc:	2200      	movs	r2, #0
    1fde:	4604      	mov	r4, r0
    1fe0:	460d      	mov	r5, r1
    1fe2:	4b1e      	ldr	r3, [pc, #120]	; (205c <speed_PID_controller(double, double, double, double, double, double, double)+0x1a0>)
    1fe4:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    1fe8:	f007 fe2c 	bl	9c44 <__aeabi_dmul>
    1fec:	4602      	mov	r2, r0
    1fee:	460b      	mov	r3, r1
    1ff0:	4620      	mov	r0, r4
    1ff2:	4629      	mov	r1, r5
    1ff4:	f007 fc74 	bl	98e0 <__adddf3>
    1ff8:	ed9d 2b06 	vldr	d2, [sp, #24]
    1ffc:	4604      	mov	r4, r0
    1ffe:	ec53 2b12 	vmov	r2, r3, d2
    2002:	460d      	mov	r5, r1
    2004:	4650      	mov	r0, sl
    2006:	4659      	mov	r1, fp
    2008:	f007 fc68 	bl	98dc <__aeabi_dsub>
    200c:	4642      	mov	r2, r8
    200e:	464b      	mov	r3, r9
    2010:	f007 ff42 	bl	9e98 <__aeabi_ddiv>
    2014:	2200      	movs	r2, #0
    2016:	2300      	movs	r3, #0
    2018:	f007 fe14 	bl	9c44 <__aeabi_dmul>
    201c:	4602      	mov	r2, r0
    201e:	460b      	mov	r3, r1
    2020:	4620      	mov	r0, r4
    2022:	4629      	mov	r1, r5
    2024:	f007 fc5c 	bl	98e0 <__adddf3>
    2028:	ec41 0b10 	vmov	d0, r0, r1
    202c:	f7ff fdc4 	bl	1bb8 <omega_to_pwm(double)>
  double pwm_signal_l = omega_to_pwm(controller_output_l);
    2030:	ec47 6b10 	vmov	d0, r6, r7
  cum_error_l += error_l * elapsed_time;
  double rate_error_r = (error_r - last_error_r) / elapsed_time;
  double rate_error_l = (error_l - last_error_l) / elapsed_time;
  double controller_output_r = error_r * p_gain + cum_error_r * i_gain + rate_error_r * d_gain;
  double controller_output_l = error_l * p_gain + cum_error_l * i_gain + rate_error_l * d_gain;
  double pwm_signal_r = omega_to_pwm(controller_output_r);
    2034:	4604      	mov	r4, r0
  double pwm_signal_l = omega_to_pwm(controller_output_l);
    2036:	f7ff fdbf 	bl	1bb8 <omega_to_pwm(double)>
  setPWM(pwm_signal_r,pwm_signal_l);
    203a:	4601      	mov	r1, r0
    203c:	4620      	mov	r0, r4
}
    203e:	b00d      	add	sp, #52	; 0x34
    2040:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  double rate_error_l = (error_l - last_error_l) / elapsed_time;
  double controller_output_r = error_r * p_gain + cum_error_r * i_gain + rate_error_r * d_gain;
  double controller_output_l = error_l * p_gain + cum_error_l * i_gain + rate_error_l * d_gain;
  double pwm_signal_r = omega_to_pwm(controller_output_r);
  double pwm_signal_l = omega_to_pwm(controller_output_l);
  setPWM(pwm_signal_r,pwm_signal_l);
    2044:	f7ff bef8 	b.w	1e38 <setPWM(int, int)>
    2048:	1fff2b94 	.word	0x1fff2b94
    204c:	1fff1458 	.word	0x1fff1458
    2050:	1fff2bf8 	.word	0x1fff2bf8
    2054:	1fff2b28 	.word	0x1fff2b28
    2058:	1fff2a88 	.word	0x1fff2a88
    205c:	3fe00000 	.word	0x3fe00000

00002060 <imu_collection()>:




//-----IMU data colection function-----//
void imu_collection() {
    2060:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  accelgyro.getMotion9(&accel_X, &accel_Y, &accel_Z, &gyro_X, &gyro_Y, &gyro_Z, &mx, &my, &mz);
    2064:	f8df a17c 	ldr.w	sl, [pc, #380]	; 21e4 <imu_collection()+0x184>
    2068:	f8df b17c 	ldr.w	fp, [pc, #380]	; 21e8 <imu_collection()+0x188>
    206c:	4d4e      	ldr	r5, [pc, #312]	; (21a8 <imu_collection()+0x148>)
    206e:	4e4f      	ldr	r6, [pc, #316]	; (21ac <imu_collection()+0x14c>)
    2070:	4f4f      	ldr	r7, [pc, #316]	; (21b0 <imu_collection()+0x150>)
    2072:	f8df 8178 	ldr.w	r8, [pc, #376]	; 21ec <imu_collection()+0x18c>
    2076:	f8df 9178 	ldr.w	r9, [pc, #376]	; 21f0 <imu_collection()+0x190>
    207a:	4b4e      	ldr	r3, [pc, #312]	; (21b4 <imu_collection()+0x154>)
    207c:	484e      	ldr	r0, [pc, #312]	; (21b8 <imu_collection()+0x158>)
  data_measured_odom_and_imu.imu_acc.x = accel_X;
    207e:	4c4f      	ldr	r4, [pc, #316]	; (21bc <imu_collection()+0x15c>)




//-----IMU data colection function-----//
void imu_collection() {
    2080:	b093      	sub	sp, #76	; 0x4c
  accelgyro.getMotion9(&accel_X, &accel_Y, &accel_Z, &gyro_X, &gyro_Y, &gyro_Z, &mx, &my, &mz);
    2082:	465a      	mov	r2, fp
    2084:	9305      	str	r3, [sp, #20]
    2086:	4629      	mov	r1, r5
    2088:	4653      	mov	r3, sl
    208a:	9004      	str	r0, [sp, #16]
    208c:	9702      	str	r7, [sp, #8]
    208e:	f8cd 8004 	str.w	r8, [sp, #4]
    2092:	9603      	str	r6, [sp, #12]
    2094:	f8cd 9000 	str.w	r9, [sp]
    2098:	4849      	ldr	r0, [pc, #292]	; (21c0 <imu_collection()+0x160>)
    209a:	f003 f94b 	bl	5334 <MPU9250::getMotion9(short*, short*, short*, short*, short*, short*, short*, short*, short*)>
  data_measured_odom_and_imu.imu_acc.x = accel_X;
    209e:	f9b5 0000 	ldrsh.w	r0, [r5]
  data_measured_odom_and_imu.imu_mag.x = mx;
  data_measured_odom_and_imu.imu_mag.y = my;
  data_measured_odom_and_imu.imu_mag.z = mz;
  //IMU_data_mag.publish(&imu_mag);
  measured_angle = atan2(my - mag_y_cal, mx - mag_x_cal) * 180 / pi;
  data_measured_angle.x = mx;
    20a2:	4d48      	ldr	r5, [pc, #288]	; (21c4 <imu_collection()+0x164>)


//-----IMU data colection function-----//
void imu_collection() {
  accelgyro.getMotion9(&accel_X, &accel_Y, &accel_Z, &gyro_X, &gyro_Y, &gyro_Z, &mx, &my, &mz);
  data_measured_odom_and_imu.imu_acc.x = accel_X;
    20a4:	f007 fd68 	bl	9b78 <__aeabi_i2d>
    20a8:	e9c4 0104 	strd	r0, r1, [r4, #16]
  data_measured_odom_and_imu.imu_acc.y = accel_Y;
    20ac:	f9bb 0000 	ldrsh.w	r0, [fp]
    20b0:	f007 fd62 	bl	9b78 <__aeabi_i2d>
    20b4:	e9c4 0106 	strd	r0, r1, [r4, #24]
  data_measured_odom_and_imu.imu_acc.z = accel_Z;
    20b8:	f9ba 0000 	ldrsh.w	r0, [sl]
    20bc:	f007 fd5c 	bl	9b78 <__aeabi_i2d>
  //IMU_data_acc.publish(&imu_acc);
  sensors_event_t temp_event;
  bmp_temp->getEvent(&temp_event);
    20c0:	4b41      	ldr	r3, [pc, #260]	; (21c8 <imu_collection()+0x168>)
    20c2:	681b      	ldr	r3, [r3, #0]
    20c4:	681a      	ldr	r2, [r3, #0]
//-----IMU data colection function-----//
void imu_collection() {
  accelgyro.getMotion9(&accel_X, &accel_Y, &accel_Z, &gyro_X, &gyro_Y, &gyro_Z, &mx, &my, &mz);
  data_measured_odom_and_imu.imu_acc.x = accel_X;
  data_measured_odom_and_imu.imu_acc.y = accel_Y;
  data_measured_odom_and_imu.imu_acc.z = accel_Z;
    20c6:	e9c4 0108 	strd	r0, r1, [r4, #32]
  //IMU_data_acc.publish(&imu_acc);
  sensors_event_t temp_event;
  bmp_temp->getEvent(&temp_event);
    20ca:	68d2      	ldr	r2, [r2, #12]
    20cc:	a909      	add	r1, sp, #36	; 0x24
    20ce:	4618      	mov	r0, r3
    20d0:	4790      	blx	r2
  temperature = temp_event.temperature;
    20d2:	4a3e      	ldr	r2, [pc, #248]	; (21cc <imu_collection()+0x16c>)
    20d4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    20d6:	6013      	str	r3, [r2, #0]
  data_measured_odom_and_imu.temp = temperature;
    20d8:	4618      	mov	r0, r3
    20da:	f007 fd5f 	bl	9b9c <__aeabi_f2d>
    20de:	e9c4 011e 	strd	r0, r1, [r4, #120]	; 0x78
  data_measured_odom_and_imu.imu_gyro.x = gyro_X;
    20e2:	f9b9 0000 	ldrsh.w	r0, [r9]
    20e6:	f007 fd47 	bl	9b78 <__aeabi_i2d>
    20ea:	e9c4 010c 	strd	r0, r1, [r4, #48]	; 0x30
  data_measured_odom_and_imu.imu_gyro.y = gyro_Y;
    20ee:	f9b8 0000 	ldrsh.w	r0, [r8]
    20f2:	f007 fd41 	bl	9b78 <__aeabi_i2d>
    20f6:	e9c4 010e 	strd	r0, r1, [r4, #56]	; 0x38
  data_measured_odom_and_imu.imu_gyro.z = gyro_Z;
    20fa:	f9b7 0000 	ldrsh.w	r0, [r7]
    20fe:	f007 fd3b 	bl	9b78 <__aeabi_i2d>
  //IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  data_measured_odom_and_imu.imu_mag.x = mx;
    2102:	f9b6 8000 	ldrsh.w	r8, [r6]
  bmp_temp->getEvent(&temp_event);
  temperature = temp_event.temperature;
  data_measured_odom_and_imu.temp = temperature;
  data_measured_odom_and_imu.imu_gyro.x = gyro_X;
  data_measured_odom_and_imu.imu_gyro.y = gyro_Y;
  data_measured_odom_and_imu.imu_gyro.z = gyro_Z;
    2106:	e9c4 0110 	strd	r0, r1, [r4, #64]	; 0x40
  //IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  data_measured_odom_and_imu.imu_mag.x = mx;
    210a:	4640      	mov	r0, r8
    210c:	f007 fd34 	bl	9b78 <__aeabi_i2d>
  data_measured_odom_and_imu.imu_mag.y = my;
    2110:	4b29      	ldr	r3, [pc, #164]	; (21b8 <imu_collection()+0x158>)
    2112:	f9b3 7000 	ldrsh.w	r7, [r3]
  data_measured_odom_and_imu.imu_gyro.x = gyro_X;
  data_measured_odom_and_imu.imu_gyro.y = gyro_Y;
  data_measured_odom_and_imu.imu_gyro.z = gyro_Z;
  //IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  data_measured_odom_and_imu.imu_mag.x = mx;
    2116:	e9c4 0114 	strd	r0, r1, [r4, #80]	; 0x50
  data_measured_odom_and_imu.imu_mag.y = my;
    211a:	4638      	mov	r0, r7
    211c:	f007 fd2c 	bl	9b78 <__aeabi_i2d>
  data_measured_odom_and_imu.imu_mag.z = mz;
    2120:	4b24      	ldr	r3, [pc, #144]	; (21b4 <imu_collection()+0x154>)
  data_measured_odom_and_imu.imu_gyro.y = gyro_Y;
  data_measured_odom_and_imu.imu_gyro.z = gyro_Z;
  //IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  data_measured_odom_and_imu.imu_mag.x = mx;
  data_measured_odom_and_imu.imu_mag.y = my;
    2122:	e9c4 0116 	strd	r0, r1, [r4, #88]	; 0x58
  data_measured_odom_and_imu.imu_mag.z = mz;
    2126:	f9b3 0000 	ldrsh.w	r0, [r3]
    212a:	f007 fd25 	bl	9b78 <__aeabi_i2d>
  //IMU_data_mag.publish(&imu_mag);
  measured_angle = atan2(my - mag_y_cal, mx - mag_x_cal) * 180 / pi;
    212e:	4b28      	ldr	r3, [pc, #160]	; (21d0 <imu_collection()+0x170>)
    2130:	681b      	ldr	r3, [r3, #0]
  data_measured_odom_and_imu.imu_gyro.z = gyro_Z;
  //IMU_data_gyro.publish(&imu_gyro);
  // data from the magnetometer that is calibrated and turned into a heading
  data_measured_odom_and_imu.imu_mag.x = mx;
  data_measured_odom_and_imu.imu_mag.y = my;
  data_measured_odom_and_imu.imu_mag.z = mz;
    2132:	e9c4 0118 	strd	r0, r1, [r4, #96]	; 0x60
  //IMU_data_mag.publish(&imu_mag);
  measured_angle = atan2(my - mag_y_cal, mx - mag_x_cal) * 180 / pi;
    2136:	ebc3 0008 	rsb	r0, r3, r8
    213a:	f007 fd1d 	bl	9b78 <__aeabi_i2d>
    213e:	4b25      	ldr	r3, [pc, #148]	; (21d4 <imu_collection()+0x174>)
    2140:	e9cd 0106 	strd	r0, r1, [sp, #24]
    2144:	6818      	ldr	r0, [r3, #0]
    2146:	1a38      	subs	r0, r7, r0
    2148:	f007 fd16 	bl	9b78 <__aeabi_i2d>
    214c:	ed9d 1b06 	vldr	d1, [sp, #24]
    2150:	ec41 0b10 	vmov	d0, r0, r1
    2154:	f005 ffca 	bl	80ec <atan2>
    2158:	2200      	movs	r2, #0
    215a:	ec51 0b10 	vmov	r0, r1, d0
    215e:	4b1e      	ldr	r3, [pc, #120]	; (21d8 <imu_collection()+0x178>)
    2160:	f007 fd70 	bl	9c44 <__aeabi_dmul>
    2164:	a30e      	add	r3, pc, #56	; (adr r3, 21a0 <imu_collection()+0x140>)
    2166:	e9d3 2300 	ldrd	r2, r3, [r3]
    216a:	f007 fe95 	bl	9e98 <__aeabi_ddiv>
    216e:	f008 f841 	bl	a1f4 <__aeabi_d2f>
    2172:	4b1a      	ldr	r3, [pc, #104]	; (21dc <imu_collection()+0x17c>)
    2174:	4604      	mov	r4, r0
    2176:	601c      	str	r4, [r3, #0]
  data_measured_angle.x = mx;
    2178:	f9b6 0000 	ldrsh.w	r0, [r6]
    217c:	f007 fcfc 	bl	9b78 <__aeabi_i2d>
  data_measured_angle.y = reference_angle;
    2180:	4b17      	ldr	r3, [pc, #92]	; (21e0 <imu_collection()+0x180>)
  data_measured_odom_and_imu.imu_mag.x = mx;
  data_measured_odom_and_imu.imu_mag.y = my;
  data_measured_odom_and_imu.imu_mag.z = mz;
  //IMU_data_mag.publish(&imu_mag);
  measured_angle = atan2(my - mag_y_cal, mx - mag_x_cal) * 180 / pi;
  data_measured_angle.x = mx;
    2182:	e9c5 0102 	strd	r0, r1, [r5, #8]
  data_measured_angle.y = reference_angle;
    2186:	6818      	ldr	r0, [r3, #0]
    2188:	f007 fd08 	bl	9b9c <__aeabi_f2d>
    218c:	e9c5 0104 	strd	r0, r1, [r5, #16]
  data_measured_angle.z = measured_angle;
    2190:	4620      	mov	r0, r4
    2192:	f007 fd03 	bl	9b9c <__aeabi_f2d>
    2196:	e9c5 0106 	strd	r0, r1, [r5, #24]
  //measured_angle_pub.publish(&data_measured_angle);
}
    219a:	b013      	add	sp, #76	; 0x4c
    219c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    21a0:	80000000 	.word	0x80000000
    21a4:	400921fb 	.word	0x400921fb
    21a8:	1fff2ba0 	.word	0x1fff2ba0
    21ac:	1fff1490 	.word	0x1fff1490
    21b0:	1fff2ba8 	.word	0x1fff2ba8
    21b4:	1fff2b70 	.word	0x1fff2b70
    21b8:	1fff1492 	.word	0x1fff1492
    21bc:	1fff2a90 	.word	0x1fff2a90
    21c0:	1fff1c80 	.word	0x1fff1c80
    21c4:	1fff1438 	.word	0x1fff1438
    21c8:	1fff1c78 	.word	0x1fff1c78
    21cc:	1fff1c94 	.word	0x1fff1c94
    21d0:	1fff0814 	.word	0x1fff0814
    21d4:	1fff0810 	.word	0x1fff0810
    21d8:	40668000 	.word	0x40668000
    21dc:	1fff2bac 	.word	0x1fff2bac
    21e0:	1fff2bf4 	.word	0x1fff2bf4
    21e4:	1fff1c7c 	.word	0x1fff1c7c
    21e8:	1fff2ba2 	.word	0x1fff2ba2
    21ec:	1fff2ba6 	.word	0x1fff2ba6
    21f0:	1fff2ba4 	.word	0x1fff2ba4

000021f4 <RGB_led_set(String const&)>:
    //output_number = map(encoder_count,-counts_per_revolution, counts_per_revolution, -2*pi, 2*pi);
  }
  return output_number;
}

void RGB_led_set(const String& color) {
    21f4:	b510      	push	{r4, lr}
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	//unsigned char equals(const __FlashStringHelper *pgmstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
    21f6:	4971      	ldr	r1, [pc, #452]	; (23bc <RGB_led_set(String const&)+0x1c8>)
    21f8:	4604      	mov	r4, r0
    21fa:	f005 fdbb 	bl	7d74 <String::equals(char const*) const>
  if (color == "red" || color == "Red" || color == "RED") {
    21fe:	2800      	cmp	r0, #0
    2200:	d07a      	beq.n	22f8 <RGB_led_set(String const&)+0x104>
    digitalWrite(RGB_led_green, HIGH);
    2202:	2101      	movs	r1, #1
    2204:	2002      	movs	r0, #2
    2206:	f004 fcf9 	bl	6bfc <digitalWrite>
    digitalWrite(RGB_led_blue, HIGH);
    220a:	2101      	movs	r1, #1
    220c:	2003      	movs	r0, #3
    220e:	f004 fcf5 	bl	6bfc <digitalWrite>
    digitalWrite(RGB_led_red, LOW);
    2212:	2100      	movs	r1, #0
    2214:	2004      	movs	r0, #4
    2216:	f004 fcf1 	bl	6bfc <digitalWrite>
    221a:	4969      	ldr	r1, [pc, #420]	; (23c0 <RGB_led_set(String const&)+0x1cc>)
    221c:	4620      	mov	r0, r4
    221e:	f005 fda9 	bl	7d74 <String::equals(char const*) const>
  }
  if (color == "green" || color == "Green" || color == "GREEN") {
    2222:	2800      	cmp	r0, #0
    2224:	f000 80bb 	beq.w	239e <RGB_led_set(String const&)+0x1aa>
    digitalWrite(RGB_led_green, LOW);
    2228:	2100      	movs	r1, #0
    222a:	2002      	movs	r0, #2
    222c:	f004 fce6 	bl	6bfc <digitalWrite>
    digitalWrite(RGB_led_blue, HIGH);
    2230:	2101      	movs	r1, #1
    2232:	2003      	movs	r0, #3
    2234:	f004 fce2 	bl	6bfc <digitalWrite>
    digitalWrite(RGB_led_red, HIGH);
    2238:	2101      	movs	r1, #1
    223a:	2004      	movs	r0, #4
    223c:	f004 fcde 	bl	6bfc <digitalWrite>
    2240:	4960      	ldr	r1, [pc, #384]	; (23c4 <RGB_led_set(String const&)+0x1d0>)
    2242:	4620      	mov	r0, r4
    2244:	f005 fd96 	bl	7d74 <String::equals(char const*) const>
  }
  if (color == "blue" || color == "Blue" || color == "BLUE") {
    2248:	2800      	cmp	r0, #0
    224a:	f000 8099 	beq.w	2380 <RGB_led_set(String const&)+0x18c>
    digitalWrite(RGB_led_green, HIGH);
    224e:	2101      	movs	r1, #1
    2250:	2002      	movs	r0, #2
    2252:	f004 fcd3 	bl	6bfc <digitalWrite>
    digitalWrite(RGB_led_blue, LOW);
    2256:	2100      	movs	r1, #0
    2258:	2003      	movs	r0, #3
    225a:	f004 fccf 	bl	6bfc <digitalWrite>
    digitalWrite(RGB_led_red, HIGH);
    225e:	2101      	movs	r1, #1
    2260:	2004      	movs	r0, #4
    2262:	f004 fccb 	bl	6bfc <digitalWrite>
    2266:	4958      	ldr	r1, [pc, #352]	; (23c8 <RGB_led_set(String const&)+0x1d4>)
    2268:	4620      	mov	r0, r4
    226a:	f005 fd83 	bl	7d74 <String::equals(char const*) const>
  }
  if (color == "cyan" || color == "Cyan" || color == "CYAN") {
    226e:	2800      	cmp	r0, #0
    2270:	d078      	beq.n	2364 <RGB_led_set(String const&)+0x170>
    digitalWrite(RGB_led_green, LOW);
    2272:	2100      	movs	r1, #0
    2274:	2002      	movs	r0, #2
    2276:	f004 fcc1 	bl	6bfc <digitalWrite>
    digitalWrite(RGB_led_blue, LOW);
    227a:	2100      	movs	r1, #0
    227c:	2003      	movs	r0, #3
    227e:	f004 fcbd 	bl	6bfc <digitalWrite>
    digitalWrite(RGB_led_red, HIGH);
    2282:	2101      	movs	r1, #1
    2284:	2004      	movs	r0, #4
    2286:	f004 fcb9 	bl	6bfc <digitalWrite>
    228a:	4950      	ldr	r1, [pc, #320]	; (23cc <RGB_led_set(String const&)+0x1d8>)
    228c:	4620      	mov	r0, r4
    228e:	f005 fd71 	bl	7d74 <String::equals(char const*) const>
  }
  if (color == "purple" || color == "Purple" || color == "PURPLE") {
    2292:	2800      	cmp	r0, #0
    2294:	d059      	beq.n	234a <RGB_led_set(String const&)+0x156>
    digitalWrite(RGB_led_green, HIGH);
    2296:	2101      	movs	r1, #1
    2298:	2002      	movs	r0, #2
    229a:	f004 fcaf 	bl	6bfc <digitalWrite>
    digitalWrite(RGB_led_blue, LOW);
    229e:	2100      	movs	r1, #0
    22a0:	2003      	movs	r0, #3
    22a2:	f004 fcab 	bl	6bfc <digitalWrite>
    digitalWrite(RGB_led_red, LOW);
    22a6:	2100      	movs	r1, #0
    22a8:	2004      	movs	r0, #4
    22aa:	f004 fca7 	bl	6bfc <digitalWrite>
    22ae:	4948      	ldr	r1, [pc, #288]	; (23d0 <RGB_led_set(String const&)+0x1dc>)
    22b0:	4620      	mov	r0, r4
    22b2:	f005 fd5f 	bl	7d74 <String::equals(char const*) const>
  }
  if (color == "orange" || color == "Orange" || color == "ORANGE") {
    22b6:	2800      	cmp	r0, #0
    22b8:	d03a      	beq.n	2330 <RGB_led_set(String const&)+0x13c>
    digitalWrite(RGB_led_green, LOW);
    22ba:	2100      	movs	r1, #0
    22bc:	2002      	movs	r0, #2
    22be:	f004 fc9d 	bl	6bfc <digitalWrite>
    digitalWrite(RGB_led_blue, HIGH);
    22c2:	2101      	movs	r1, #1
    22c4:	2003      	movs	r0, #3
    22c6:	f004 fc99 	bl	6bfc <digitalWrite>
    digitalWrite(RGB_led_red, LOW);
    22ca:	2100      	movs	r1, #0
    22cc:	2004      	movs	r0, #4
    22ce:	f004 fc95 	bl	6bfc <digitalWrite>
    22d2:	4940      	ldr	r1, [pc, #256]	; (23d4 <RGB_led_set(String const&)+0x1e0>)
    22d4:	4620      	mov	r0, r4
    22d6:	f005 fd4d 	bl	7d74 <String::equals(char const*) const>
  }
  if (color == "white " || color == "White" || color == "WHITE") {
    22da:	b1e0      	cbz	r0, 2316 <RGB_led_set(String const&)+0x122>
    digitalWrite(RGB_led_green, LOW);
    22dc:	2100      	movs	r1, #0
    22de:	2002      	movs	r0, #2
    22e0:	f004 fc8c 	bl	6bfc <digitalWrite>
    digitalWrite(RGB_led_blue, LOW);
    22e4:	2100      	movs	r1, #0
    22e6:	2003      	movs	r0, #3
    22e8:	f004 fc88 	bl	6bfc <digitalWrite>
    digitalWrite(RGB_led_red, LOW);
    22ec:	2100      	movs	r1, #0
    22ee:	2004      	movs	r0, #4
  }
}
    22f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    digitalWrite(RGB_led_red, LOW);
  }
  if (color == "white " || color == "White" || color == "WHITE") {
    digitalWrite(RGB_led_green, LOW);
    digitalWrite(RGB_led_blue, LOW);
    digitalWrite(RGB_led_red, LOW);
    22f4:	f004 bc82 	b.w	6bfc <digitalWrite>
    22f8:	4937      	ldr	r1, [pc, #220]	; (23d8 <RGB_led_set(String const&)+0x1e4>)
    22fa:	4620      	mov	r0, r4
    22fc:	f005 fd3a 	bl	7d74 <String::equals(char const*) const>
  }
  return output_number;
}

void RGB_led_set(const String& color) {
  if (color == "red" || color == "Red" || color == "RED") {
    2300:	2800      	cmp	r0, #0
    2302:	f47f af7e 	bne.w	2202 <RGB_led_set(String const&)+0xe>
    2306:	4935      	ldr	r1, [pc, #212]	; (23dc <RGB_led_set(String const&)+0x1e8>)
    2308:	4620      	mov	r0, r4
    230a:	f005 fd33 	bl	7d74 <String::equals(char const*) const>
    230e:	2800      	cmp	r0, #0
    2310:	f47f af77 	bne.w	2202 <RGB_led_set(String const&)+0xe>
    2314:	e781      	b.n	221a <RGB_led_set(String const&)+0x26>
    2316:	4932      	ldr	r1, [pc, #200]	; (23e0 <RGB_led_set(String const&)+0x1ec>)
    2318:	4620      	mov	r0, r4
    231a:	f005 fd2b 	bl	7d74 <String::equals(char const*) const>
  if (color == "orange" || color == "Orange" || color == "ORANGE") {
    digitalWrite(RGB_led_green, LOW);
    digitalWrite(RGB_led_blue, HIGH);
    digitalWrite(RGB_led_red, LOW);
  }
  if (color == "white " || color == "White" || color == "WHITE") {
    231e:	2800      	cmp	r0, #0
    2320:	d1dc      	bne.n	22dc <RGB_led_set(String const&)+0xe8>
    2322:	4620      	mov	r0, r4
    2324:	492f      	ldr	r1, [pc, #188]	; (23e4 <RGB_led_set(String const&)+0x1f0>)
    2326:	f005 fd25 	bl	7d74 <String::equals(char const*) const>
    232a:	2800      	cmp	r0, #0
    232c:	d1d6      	bne.n	22dc <RGB_led_set(String const&)+0xe8>
    232e:	bd10      	pop	{r4, pc}
    2330:	492d      	ldr	r1, [pc, #180]	; (23e8 <RGB_led_set(String const&)+0x1f4>)
    2332:	4620      	mov	r0, r4
    2334:	f005 fd1e 	bl	7d74 <String::equals(char const*) const>
  if (color == "purple" || color == "Purple" || color == "PURPLE") {
    digitalWrite(RGB_led_green, HIGH);
    digitalWrite(RGB_led_blue, LOW);
    digitalWrite(RGB_led_red, LOW);
  }
  if (color == "orange" || color == "Orange" || color == "ORANGE") {
    2338:	2800      	cmp	r0, #0
    233a:	d1be      	bne.n	22ba <RGB_led_set(String const&)+0xc6>
    233c:	492b      	ldr	r1, [pc, #172]	; (23ec <RGB_led_set(String const&)+0x1f8>)
    233e:	4620      	mov	r0, r4
    2340:	f005 fd18 	bl	7d74 <String::equals(char const*) const>
    2344:	2800      	cmp	r0, #0
    2346:	d1b8      	bne.n	22ba <RGB_led_set(String const&)+0xc6>
    2348:	e7c3      	b.n	22d2 <RGB_led_set(String const&)+0xde>
    234a:	4929      	ldr	r1, [pc, #164]	; (23f0 <RGB_led_set(String const&)+0x1fc>)
    234c:	4620      	mov	r0, r4
    234e:	f005 fd11 	bl	7d74 <String::equals(char const*) const>
  if (color == "cyan" || color == "Cyan" || color == "CYAN") {
    digitalWrite(RGB_led_green, LOW);
    digitalWrite(RGB_led_blue, LOW);
    digitalWrite(RGB_led_red, HIGH);
  }
  if (color == "purple" || color == "Purple" || color == "PURPLE") {
    2352:	2800      	cmp	r0, #0
    2354:	d19f      	bne.n	2296 <RGB_led_set(String const&)+0xa2>
    2356:	4927      	ldr	r1, [pc, #156]	; (23f4 <RGB_led_set(String const&)+0x200>)
    2358:	4620      	mov	r0, r4
    235a:	f005 fd0b 	bl	7d74 <String::equals(char const*) const>
    235e:	2800      	cmp	r0, #0
    2360:	d199      	bne.n	2296 <RGB_led_set(String const&)+0xa2>
    2362:	e7a4      	b.n	22ae <RGB_led_set(String const&)+0xba>
    2364:	4924      	ldr	r1, [pc, #144]	; (23f8 <RGB_led_set(String const&)+0x204>)
    2366:	4620      	mov	r0, r4
    2368:	f005 fd04 	bl	7d74 <String::equals(char const*) const>
  if (color == "blue" || color == "Blue" || color == "BLUE") {
    digitalWrite(RGB_led_green, HIGH);
    digitalWrite(RGB_led_blue, LOW);
    digitalWrite(RGB_led_red, HIGH);
  }
  if (color == "cyan" || color == "Cyan" || color == "CYAN") {
    236c:	2800      	cmp	r0, #0
    236e:	d180      	bne.n	2272 <RGB_led_set(String const&)+0x7e>
    2370:	4922      	ldr	r1, [pc, #136]	; (23fc <RGB_led_set(String const&)+0x208>)
    2372:	4620      	mov	r0, r4
    2374:	f005 fcfe 	bl	7d74 <String::equals(char const*) const>
    2378:	2800      	cmp	r0, #0
    237a:	f47f af7a 	bne.w	2272 <RGB_led_set(String const&)+0x7e>
    237e:	e784      	b.n	228a <RGB_led_set(String const&)+0x96>
    2380:	491f      	ldr	r1, [pc, #124]	; (2400 <RGB_led_set(String const&)+0x20c>)
    2382:	4620      	mov	r0, r4
    2384:	f005 fcf6 	bl	7d74 <String::equals(char const*) const>
  if (color == "green" || color == "Green" || color == "GREEN") {
    digitalWrite(RGB_led_green, LOW);
    digitalWrite(RGB_led_blue, HIGH);
    digitalWrite(RGB_led_red, HIGH);
  }
  if (color == "blue" || color == "Blue" || color == "BLUE") {
    2388:	2800      	cmp	r0, #0
    238a:	f47f af60 	bne.w	224e <RGB_led_set(String const&)+0x5a>
    238e:	491d      	ldr	r1, [pc, #116]	; (2404 <RGB_led_set(String const&)+0x210>)
    2390:	4620      	mov	r0, r4
    2392:	f005 fcef 	bl	7d74 <String::equals(char const*) const>
    2396:	2800      	cmp	r0, #0
    2398:	f47f af59 	bne.w	224e <RGB_led_set(String const&)+0x5a>
    239c:	e763      	b.n	2266 <RGB_led_set(String const&)+0x72>
    239e:	491a      	ldr	r1, [pc, #104]	; (2408 <RGB_led_set(String const&)+0x214>)
    23a0:	4620      	mov	r0, r4
    23a2:	f005 fce7 	bl	7d74 <String::equals(char const*) const>
  if (color == "red" || color == "Red" || color == "RED") {
    digitalWrite(RGB_led_green, HIGH);
    digitalWrite(RGB_led_blue, HIGH);
    digitalWrite(RGB_led_red, LOW);
  }
  if (color == "green" || color == "Green" || color == "GREEN") {
    23a6:	2800      	cmp	r0, #0
    23a8:	f47f af3e 	bne.w	2228 <RGB_led_set(String const&)+0x34>
    23ac:	4917      	ldr	r1, [pc, #92]	; (240c <RGB_led_set(String const&)+0x218>)
    23ae:	4620      	mov	r0, r4
    23b0:	f005 fce0 	bl	7d74 <String::equals(char const*) const>
    23b4:	2800      	cmp	r0, #0
    23b6:	f47f af37 	bne.w	2228 <RGB_led_set(String const&)+0x34>
    23ba:	e741      	b.n	2240 <RGB_led_set(String const&)+0x4c>
    23bc:	0000bfa4 	.word	0x0000bfa4
    23c0:	0000bfb0 	.word	0x0000bfb0
    23c4:	0000bfc8 	.word	0x0000bfc8
    23c8:	0000bfe0 	.word	0x0000bfe0
    23cc:	0000bff8 	.word	0x0000bff8
    23d0:	0000c010 	.word	0x0000c010
    23d4:	0000c028 	.word	0x0000c028
    23d8:	0000bfa8 	.word	0x0000bfa8
    23dc:	0000bfac 	.word	0x0000bfac
    23e0:	0000c030 	.word	0x0000c030
    23e4:	0000c038 	.word	0x0000c038
    23e8:	0000c018 	.word	0x0000c018
    23ec:	0000c020 	.word	0x0000c020
    23f0:	0000c000 	.word	0x0000c000
    23f4:	0000c008 	.word	0x0000c008
    23f8:	0000bfe8 	.word	0x0000bfe8
    23fc:	0000bff0 	.word	0x0000bff0
    2400:	0000bfd0 	.word	0x0000bfd0
    2404:	0000bfd8 	.word	0x0000bfd8
    2408:	0000bfb8 	.word	0x0000bfb8
    240c:	0000bfc0 	.word	0x0000bfc0

00002410 <wheel_speed_set(double, double, int)>:
  double pwm_signal_r = omega_to_pwm(controller_output_r);
  double pwm_signal_l = omega_to_pwm(controller_output_l);
  setPWM(pwm_signal_r,pwm_signal_l);
}

void wheel_speed_set(double input_vel_x, double input_omega, int tele_op){
    2410:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2414:	ed2d 8b06 	vpush	{d8-d10}
  double vel_x_goal;
  double goal_omega;

  if (tele_op == 100){
    2418:	2864      	cmp	r0, #100	; 0x64
  double pwm_signal_r = omega_to_pwm(controller_output_r);
  double pwm_signal_l = omega_to_pwm(controller_output_l);
  setPWM(pwm_signal_r,pwm_signal_l);
}

void wheel_speed_set(double input_vel_x, double input_omega, int tele_op){
    241a:	b087      	sub	sp, #28
  double vel_x_goal;
  double goal_omega;

  if (tele_op == 100){
    241c:	f000 8107 	beq.w	262e <wheel_speed_set(double, double, int)+0x21e>
    2420:	eeb0 8a40 	vmov.f32	s16, s0
    2424:	eef0 8a60 	vmov.f32	s17, s1
    2428:	eeb0 9a41 	vmov.f32	s18, s2
    242c:	eef0 9a61 	vmov.f32	s19, s3
    RGB_led_set("red");
  }
  if (tele_op == 0 || tele_op == 1){//keyboard tele-op or PS4 controller tele-op
    2430:	2801      	cmp	r0, #1
    2432:	d906      	bls.n	2442 <wheel_speed_set(double, double, int)+0x32>
    pwm_procent_right = int(map(goal_omega_right, 0, 100, 0, 255));
    pwm_procent_left = int(map(goal_omega_left, 0, 100, 0, 255));
    setPWM(pwm_procent_right, pwm_procent_left);
  }

  else if(tele_op == 2){//speed control with speed (PID) controller
    2434:	2802      	cmp	r0, #2
    2436:	d06b      	beq.n	2510 <wheel_speed_set(double, double, int)+0x100>
  //wheel_speed.y = goal_omega;
  //wheel_speed.z = goal_omega_right;
  //wheel_speed.w = goal_omega_left;

  //speed_pub.publish(&wheel_speed);
}
    2438:	b007      	add	sp, #28
    243a:	ecbd 8b06 	vpop	{d8-d10}
    243e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

  if (tele_op == 100){
    RGB_led_set("red");
  }
  if (tele_op == 0 || tele_op == 1){//keyboard tele-op or PS4 controller tele-op
    if (tele_op == 0){ //keyboard tele-op setting indicator color
    2442:	2800      	cmp	r0, #0
    2444:	f000 80f0 	beq.w	2628 <wheel_speed_set(double, double, int)+0x218>
      RGB_led_set("purple");
    }
    if (tele_op == 1){ //PS4 controller tele-op setting indicator color
      RGB_led_set("blue");
    2448:	4989      	ldr	r1, [pc, #548]	; (2670 <wheel_speed_set(double, double, int)+0x260>)
    244a:	a802      	add	r0, sp, #8
  if (tele_op == 100){
    RGB_led_set("red");
  }
  if (tele_op == 0 || tele_op == 1){//keyboard tele-op or PS4 controller tele-op
    if (tele_op == 0){ //keyboard tele-op setting indicator color
      RGB_led_set("purple");
    244c:	f005 fc7e 	bl	7d4c <String::String(char const*)>
    2450:	a802      	add	r0, sp, #8
    2452:	f7ff fecf 	bl	21f4 <RGB_led_set(String const&)>
    2456:	a802      	add	r0, sp, #8
    2458:	f005 fc38 	bl	7ccc <String::~String()>
    if (tele_op == 1){ //PS4 controller tele-op setting indicator color
      RGB_led_set("blue");
    }
    // here we assume that the imput is for input_vel_x is between 0 - 1 and
    // input_omega is between 0 - 0.5
    vel_x_goal = input_vel_x * 75;
    245c:	a37c      	add	r3, pc, #496	; (adr r3, 2650 <wheel_speed_set(double, double, int)+0x240>)
    245e:	e9d3 2300 	ldrd	r2, r3, [r3]
    2462:	ec51 0b18 	vmov	r0, r1, d8
    2466:	f007 fbed 	bl	9c44 <__aeabi_dmul>
    goal_omega = input_omega * 50;
    246a:	2200      	movs	r2, #0
    if (tele_op == 1){ //PS4 controller tele-op setting indicator color
      RGB_led_set("blue");
    }
    // here we assume that the imput is for input_vel_x is between 0 - 1 and
    // input_omega is between 0 - 0.5
    vel_x_goal = input_vel_x * 75;
    246c:	4606      	mov	r6, r0
    246e:	460f      	mov	r7, r1
    goal_omega = input_omega * 50;
    2470:	4b80      	ldr	r3, [pc, #512]	; (2674 <wheel_speed_set(double, double, int)+0x264>)
    2472:	ec51 0b19 	vmov	r0, r1, d9
    2476:	f007 fbe5 	bl	9c44 <__aeabi_dmul>
    247a:	4680      	mov	r8, r0
    247c:	4689      	mov	r9, r1
    goal_omega_right = vel_x_goal + goal_omega;
    247e:	4602      	mov	r2, r0
    2480:	460b      	mov	r3, r1
    2482:	4630      	mov	r0, r6
    2484:	4639      	mov	r1, r7
    2486:	f007 fa2b 	bl	98e0 <__adddf3>
    248a:	f8df e220 	ldr.w	lr, [pc, #544]	; 26ac <wheel_speed_set(double, double, int)+0x29c>
    248e:	4604      	mov	r4, r0
    2490:	460d      	mov	r5, r1
    2492:	e9ce 4500 	strd	r4, r5, [lr]
    goal_omega_left = vel_x_goal - goal_omega;
    2496:	4642      	mov	r2, r8
    2498:	464b      	mov	r3, r9
    249a:	4630      	mov	r0, r6
    249c:	4639      	mov	r1, r7
    249e:	f007 fa1d 	bl	98dc <__aeabi_dsub>
    24a2:	f8df e20c 	ldr.w	lr, [pc, #524]	; 26b0 <wheel_speed_set(double, double, int)+0x2a0>
    24a6:	4606      	mov	r6, r0
    24a8:	460f      	mov	r7, r1
    24aa:	e9ce 6700 	strd	r6, r7, [lr]
    pwm_procent_right = int(map(goal_omega_right, 0, 100, 0, 255));
    24ae:	a36a      	add	r3, pc, #424	; (adr r3, 2658 <wheel_speed_set(double, double, int)+0x248>)
    24b0:	e9d3 2300 	ldrd	r2, r3, [r3]
    24b4:	4620      	mov	r0, r4
    24b6:	4629      	mov	r1, r5
    24b8:	f007 fbc4 	bl	9c44 <__aeabi_dmul>
    24bc:	2200      	movs	r2, #0
    24be:	4b6e      	ldr	r3, [pc, #440]	; (2678 <wheel_speed_set(double, double, int)+0x268>)
    24c0:	4d6e      	ldr	r5, [pc, #440]	; (267c <wheel_speed_set(double, double, int)+0x26c>)
    24c2:	f007 fce9 	bl	9e98 <__aeabi_ddiv>
    24c6:	2200      	movs	r2, #0
    24c8:	2300      	movs	r3, #0
    24ca:	f007 fa09 	bl	98e0 <__adddf3>
    24ce:	f007 fe69 	bl	a1a4 <__aeabi_d2iz>
    24d2:	4604      	mov	r4, r0
    pwm_procent_left = int(map(goal_omega_left, 0, 100, 0, 255));
    24d4:	a360      	add	r3, pc, #384	; (adr r3, 2658 <wheel_speed_set(double, double, int)+0x248>)
    24d6:	e9d3 2300 	ldrd	r2, r3, [r3]
    24da:	4630      	mov	r0, r6
    24dc:	4639      	mov	r1, r7
    // input_omega is between 0 - 0.5
    vel_x_goal = input_vel_x * 75;
    goal_omega = input_omega * 50;
    goal_omega_right = vel_x_goal + goal_omega;
    goal_omega_left = vel_x_goal - goal_omega;
    pwm_procent_right = int(map(goal_omega_right, 0, 100, 0, 255));
    24de:	602c      	str	r4, [r5, #0]
    pwm_procent_left = int(map(goal_omega_left, 0, 100, 0, 255));
    24e0:	f007 fbb0 	bl	9c44 <__aeabi_dmul>
    24e4:	2200      	movs	r2, #0
    24e6:	4b64      	ldr	r3, [pc, #400]	; (2678 <wheel_speed_set(double, double, int)+0x268>)
    24e8:	f007 fcd6 	bl	9e98 <__aeabi_ddiv>
    24ec:	2200      	movs	r2, #0
    24ee:	2300      	movs	r3, #0
    24f0:	f007 f9f6 	bl	98e0 <__adddf3>
    24f4:	f007 fe56 	bl	a1a4 <__aeabi_d2iz>
    24f8:	4a61      	ldr	r2, [pc, #388]	; (2680 <wheel_speed_set(double, double, int)+0x270>)
    24fa:	4603      	mov	r3, r0
    setPWM(pwm_procent_right, pwm_procent_left);
    24fc:	4619      	mov	r1, r3
    24fe:	4620      	mov	r0, r4
    vel_x_goal = input_vel_x * 75;
    goal_omega = input_omega * 50;
    goal_omega_right = vel_x_goal + goal_omega;
    goal_omega_left = vel_x_goal - goal_omega;
    pwm_procent_right = int(map(goal_omega_right, 0, 100, 0, 255));
    pwm_procent_left = int(map(goal_omega_left, 0, 100, 0, 255));
    2500:	6013      	str	r3, [r2, #0]
    setPWM(pwm_procent_right, pwm_procent_left);
    2502:	f7ff fc99 	bl	1e38 <setPWM(int, int)>
  //wheel_speed.y = goal_omega;
  //wheel_speed.z = goal_omega_right;
  //wheel_speed.w = goal_omega_left;

  //speed_pub.publish(&wheel_speed);
}
    2506:	b007      	add	sp, #28
    2508:	ecbd 8b06 	vpop	{d8-d10}
    250c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    pwm_procent_left = int(map(goal_omega_left, 0, 100, 0, 255));
    setPWM(pwm_procent_right, pwm_procent_left);
  }

  else if(tele_op == 2){//speed control with speed (PID) controller
    RGB_led_set("green");
    2510:	495c      	ldr	r1, [pc, #368]	; (2684 <wheel_speed_set(double, double, int)+0x274>)
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    2512:	f8df 9198 	ldr.w	r9, [pc, #408]	; 26ac <wheel_speed_set(double, double, int)+0x29c>
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    2516:	f8df 8198 	ldr.w	r8, [pc, #408]	; 26b0 <wheel_speed_set(double, double, int)+0x2a0>
    pwm_procent_left = int(map(goal_omega_left, 0, 100, 0, 255));
    setPWM(pwm_procent_right, pwm_procent_left);
  }

  else if(tele_op == 2){//speed control with speed (PID) controller
    RGB_led_set("green");
    251a:	a802      	add	r0, sp, #8
    251c:	f005 fc16 	bl	7d4c <String::String(char const*)>
    2520:	a802      	add	r0, sp, #8
    2522:	f7ff fe67 	bl	21f4 <RGB_led_set(String const&)>
    2526:	a802      	add	r0, sp, #8
    2528:	f005 fbd0 	bl	7ccc <String::~String()>
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    252c:	ec53 2b18 	vmov	r2, r3, d8
    2530:	ee18 0a10 	vmov	r0, s16
    2534:	4619      	mov	r1, r3
    2536:	f007 f9d3 	bl	98e0 <__adddf3>
    253a:	a349      	add	r3, pc, #292	; (adr r3, 2660 <wheel_speed_set(double, double, int)+0x250>)
    253c:	e9d3 2300 	ldrd	r2, r3, [r3]
    2540:	4604      	mov	r4, r0
    2542:	460d      	mov	r5, r1
    2544:	ec51 0b19 	vmov	r0, r1, d9
    2548:	f007 fb7c 	bl	9c44 <__aeabi_dmul>
    254c:	4606      	mov	r6, r0
    254e:	460f      	mov	r7, r1
    2550:	4602      	mov	r2, r0
    2552:	460b      	mov	r3, r1
    2554:	4620      	mov	r0, r4
    2556:	4629      	mov	r1, r5
    2558:	f007 f9c2 	bl	98e0 <__adddf3>
    255c:	a342      	add	r3, pc, #264	; (adr r3, 2668 <wheel_speed_set(double, double, int)+0x258>)
    255e:	e9d3 2300 	ldrd	r2, r3, [r3]
    2562:	f007 fc99 	bl	9e98 <__aeabi_ddiv>
    2566:	4682      	mov	sl, r0
    2568:	468b      	mov	fp, r1
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    256a:	4632      	mov	r2, r6
    256c:	463b      	mov	r3, r7
    256e:	4620      	mov	r0, r4
    2570:	4629      	mov	r1, r5
  else if(tele_op == 2){//speed control with speed (PID) controller
    RGB_led_set("green");
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    2572:	e9c9 ab00 	strd	sl, fp, [r9]
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    2576:	f007 f9b1 	bl	98dc <__aeabi_dsub>
    257a:	a33b      	add	r3, pc, #236	; (adr r3, 2668 <wheel_speed_set(double, double, int)+0x258>)
    257c:	e9d3 2300 	ldrd	r2, r3, [r3]
    2580:	f007 fc8a 	bl	9e98 <__aeabi_ddiv>
    double time_elapsed = double(current_time - previous_time);
    2584:	4a40      	ldr	r2, [pc, #256]	; (2688 <wheel_speed_set(double, double, int)+0x278>)
    2586:	4b41      	ldr	r3, [pc, #260]	; (268c <wheel_speed_set(double, double, int)+0x27c>)
    if(goal_omega_right > 15){
    2588:	4d41      	ldr	r5, [pc, #260]	; (2690 <wheel_speed_set(double, double, int)+0x280>)
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    double time_elapsed = double(current_time - previous_time);
    258a:	681b      	ldr	r3, [r3, #0]
    RGB_led_set("green");
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    258c:	4606      	mov	r6, r0
    double time_elapsed = double(current_time - previous_time);
    258e:	6810      	ldr	r0, [r2, #0]
    RGB_led_set("green");
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    2590:	460f      	mov	r7, r1
    double time_elapsed = double(current_time - previous_time);
    2592:	1ac0      	subs	r0, r0, r3
    RGB_led_set("green");
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    2594:	e9c8 6700 	strd	r6, r7, [r8]
    double time_elapsed = double(current_time - previous_time);
    2598:	f007 faee 	bl	9b78 <__aeabi_i2d>
    if(goal_omega_right > 15){
    259c:	2400      	movs	r4, #0
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    double time_elapsed = double(current_time - previous_time);
    259e:	ec41 0b1a 	vmov	d10, r0, r1
    if(goal_omega_right > 15){
    25a2:	4622      	mov	r2, r4
    25a4:	462b      	mov	r3, r5
    25a6:	4650      	mov	r0, sl
    25a8:	4659      	mov	r1, fp
    25aa:	f007 fddb 	bl	a164 <__aeabi_dcmpgt>
    25ae:	b118      	cbz	r0, 25b8 <wheel_speed_set(double, double, int)+0x1a8>
      goal_omega_right = 15;
    25b0:	e9c9 4500 	strd	r4, r5, [r9]
    25b4:	46a2      	mov	sl, r4
    25b6:	46ab      	mov	fp, r5
    }
    if(goal_omega_left > 15){
    25b8:	4d35      	ldr	r5, [pc, #212]	; (2690 <wheel_speed_set(double, double, int)+0x280>)
    25ba:	2400      	movs	r4, #0
    25bc:	4630      	mov	r0, r6
    25be:	4639      	mov	r1, r7
    25c0:	4622      	mov	r2, r4
    25c2:	462b      	mov	r3, r5
    25c4:	f007 fdce 	bl	a164 <__aeabi_dcmpgt>
    25c8:	b118      	cbz	r0, 25d2 <wheel_speed_set(double, double, int)+0x1c2>
      goal_omega_left = 15;
    25ca:	e9c8 4500 	strd	r4, r5, [r8]
    25ce:	4626      	mov	r6, r4
    25d0:	462f      	mov	r7, r5
    }
    //temp_input_vel = goal_omega_right;
    speed_PID_controller(goal_omega_right, average_omega_right, last_error_right, goal_omega_left, average_omega_left, last_error_left, time_elapsed);
    25d2:	4a30      	ldr	r2, [pc, #192]	; (2694 <wheel_speed_set(double, double, int)+0x284>)
    25d4:	4b30      	ldr	r3, [pc, #192]	; (2698 <wheel_speed_set(double, double, int)+0x288>)
    25d6:	6810      	ldr	r0, [r2, #0]
    25d8:	ed93 9b00 	vldr	d9, [r3]
    25dc:	f007 fade 	bl	9b9c <__aeabi_f2d>
    25e0:	4b2e      	ldr	r3, [pc, #184]	; (269c <wheel_speed_set(double, double, int)+0x28c>)
    25e2:	4a2f      	ldr	r2, [pc, #188]	; (26a0 <wheel_speed_set(double, double, int)+0x290>)
    25e4:	e9cd 0100 	strd	r0, r1, [sp]
    25e8:	6818      	ldr	r0, [r3, #0]
    25ea:	ed92 8b00 	vldr	d8, [r2]
    25ee:	f007 fad5 	bl	9b9c <__aeabi_f2d>
    25f2:	eeb0 6a4a 	vmov.f32	s12, s20
    25f6:	eef0 6a6a 	vmov.f32	s13, s21
    25fa:	eeb0 5a49 	vmov.f32	s10, s18
    25fe:	eef0 5a69 	vmov.f32	s11, s19
    2602:	ed9d 4b00 	vldr	d4, [sp]
    2606:	eeb0 2a48 	vmov.f32	s4, s16
    260a:	eef0 2a68 	vmov.f32	s5, s17
    260e:	ec47 6b13 	vmov	d3, r6, r7
    2612:	ec41 0b11 	vmov	d1, r0, r1
    2616:	ec4b ab10 	vmov	d0, sl, fp
    261a:	f7ff fc4f 	bl	1ebc <speed_PID_controller(double, double, double, double, double, double, double)>
  //wheel_speed.y = goal_omega;
  //wheel_speed.z = goal_omega_right;
  //wheel_speed.w = goal_omega_left;

  //speed_pub.publish(&wheel_speed);
}
    261e:	b007      	add	sp, #28
    2620:	ecbd 8b06 	vpop	{d8-d10}
    2624:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (tele_op == 100){
    RGB_led_set("red");
  }
  if (tele_op == 0 || tele_op == 1){//keyboard tele-op or PS4 controller tele-op
    if (tele_op == 0){ //keyboard tele-op setting indicator color
      RGB_led_set("purple");
    2628:	a802      	add	r0, sp, #8
    262a:	491e      	ldr	r1, [pc, #120]	; (26a4 <wheel_speed_set(double, double, int)+0x294>)
    262c:	e70e      	b.n	244c <wheel_speed_set(double, double, int)+0x3c>
void wheel_speed_set(double input_vel_x, double input_omega, int tele_op){
  double vel_x_goal;
  double goal_omega;

  if (tele_op == 100){
    RGB_led_set("red");
    262e:	491e      	ldr	r1, [pc, #120]	; (26a8 <wheel_speed_set(double, double, int)+0x298>)
    2630:	a802      	add	r0, sp, #8
    2632:	f005 fb8b 	bl	7d4c <String::String(char const*)>
    2636:	a802      	add	r0, sp, #8
    2638:	f7ff fddc 	bl	21f4 <RGB_led_set(String const&)>
    263c:	a802      	add	r0, sp, #8
    263e:	f005 fb45 	bl	7ccc <String::~String()>
  //wheel_speed.y = goal_omega;
  //wheel_speed.z = goal_omega_right;
  //wheel_speed.w = goal_omega_left;

  //speed_pub.publish(&wheel_speed);
}
    2642:	b007      	add	sp, #28
    2644:	ecbd 8b06 	vpop	{d8-d10}
    2648:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    264c:	f3af 8000 	nop.w
    2650:	00000000 	.word	0x00000000
    2654:	4052c000 	.word	0x4052c000
    2658:	00000000 	.word	0x00000000
    265c:	406fe000 	.word	0x406fe000
    2660:	40000000 	.word	0x40000000
    2664:	3fcd4fdf 	.word	0x3fcd4fdf
    2668:	40000000 	.word	0x40000000
    266c:	3fc47ae1 	.word	0x3fc47ae1
    2670:	0000bfc8 	.word	0x0000bfc8
    2674:	40490000 	.word	0x40490000
    2678:	40590000 	.word	0x40590000
    267c:	1fff1d5c 	.word	0x1fff1d5c
    2680:	1fff1d38 	.word	0x1fff1d38
    2684:	0000bfb0 	.word	0x0000bfb0
    2688:	1fff2b9c 	.word	0x1fff2b9c
    268c:	1fff2b94 	.word	0x1fff2b94
    2690:	402e0000 	.word	0x402e0000
    2694:	1fff1c90 	.word	0x1fff1c90
    2698:	1fff1480 	.word	0x1fff1480
    269c:	1fff148c 	.word	0x1fff148c
    26a0:	1fff1d10 	.word	0x1fff1d10
    26a4:	0000bff8 	.word	0x0000bff8
    26a8:	0000bfa4 	.word	0x0000bfa4
    26ac:	1fff2b78 	.word	0x1fff2b78
    26b0:	1fff14a0 	.word	0x1fff14a0

000026b4 <cmd_velocity(geometry_msgs::Twist&)>:
  if (hi == 0){
    RGB_led_set("red");
  }
}

void cmd_velocity(geometry_msgs::Twist& cmd_goal) {
    26b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  double goal_vel_x = cmd_goal.linear.x;
  double goal_omega = cmd_goal.angular.z;
  if (cmd_goal.angular.x == 0){ // here if this is true that means that the robot is being teleoperated
    26b6:	e9d0 670c 	ldrd	r6, r7, [r0, #48]	; 0x30
  if (hi == 0){
    RGB_led_set("red");
  }
}

void cmd_velocity(geometry_msgs::Twist& cmd_goal) {
    26ba:	ed2d 8b04 	vpush	{d8-d9}
    26be:	4604      	mov	r4, r0
  double goal_vel_x = cmd_goal.linear.x;
  double goal_omega = cmd_goal.angular.z;
  if (cmd_goal.angular.x == 0){ // here if this is true that means that the robot is being teleoperated
    26c0:	2200      	movs	r2, #0
    26c2:	2300      	movs	r3, #0
    26c4:	4630      	mov	r0, r6
    26c6:	4639      	mov	r1, r7
    26c8:	f007 fd24 	bl	a114 <__aeabi_dcmpeq>
    RGB_led_set("red");
  }
}

void cmd_velocity(geometry_msgs::Twist& cmd_goal) {
  double goal_vel_x = cmd_goal.linear.x;
    26cc:	ed94 9b04 	vldr	d9, [r4, #16]
  double goal_omega = cmd_goal.angular.z;
    26d0:	ed94 8b10 	vldr	d8, [r4, #64]	; 0x40
  if (cmd_goal.angular.x == 0){ // here if this is true that means that the robot is being teleoperated
    bool_tele_op_toggel = 0;
    26d4:	4d1d      	ldr	r5, [pc, #116]	; (274c <cmd_velocity(geometry_msgs::Twist&)+0x98>)
}

void cmd_velocity(geometry_msgs::Twist& cmd_goal) {
  double goal_vel_x = cmd_goal.linear.x;
  double goal_omega = cmd_goal.angular.z;
  if (cmd_goal.angular.x == 0){ // here if this is true that means that the robot is being teleoperated
    26d6:	b108      	cbz	r0, 26dc <cmd_velocity(geometry_msgs::Twist&)+0x28>
    bool_tele_op_toggel = 0;
    26d8:	2300      	movs	r3, #0
    26da:	602b      	str	r3, [r5, #0]
  }
  if (cmd_goal.angular.x == 5){
    26dc:	2200      	movs	r2, #0
    26de:	4b1c      	ldr	r3, [pc, #112]	; (2750 <cmd_velocity(geometry_msgs::Twist&)+0x9c>)
    26e0:	4630      	mov	r0, r6
    26e2:	4639      	mov	r1, r7
    26e4:	f007 fd16 	bl	a114 <__aeabi_dcmpeq>
    26e8:	b188      	cbz	r0, 270e <cmd_velocity(geometry_msgs::Twist&)+0x5a>
    bool_tele_op_toggel = 1;
    goal_omega = cmd_goal.linear.y;
    26ea:	ed94 8b06 	vldr	d8, [r4, #24]
  double goal_omega = cmd_goal.angular.z;
  if (cmd_goal.angular.x == 0){ // here if this is true that means that the robot is being teleoperated
    bool_tele_op_toggel = 0;
  }
  if (cmd_goal.angular.x == 5){
    bool_tele_op_toggel = 1;
    26ee:	2001      	movs	r0, #1
    26f0:	6028      	str	r0, [r5, #0]
    bool_tele_op_toggel = 100;
  }
  //if(tele_op_toggel == 0.5 || tele_op_toggel == -0.5){
  //  bool_tele_op_toggel = !bool_tele_op_toggel;
  //}
  wheel_speed_set(goal_vel_x, goal_omega, bool_tele_op_toggel);
    26f2:	eeb0 1a48 	vmov.f32	s2, s16
    26f6:	eef0 1a68 	vmov.f32	s3, s17
    26fa:	eeb0 0a49 	vmov.f32	s0, s18
    26fe:	eef0 0a69 	vmov.f32	s1, s19
}
    2702:	ecbd 8b04 	vpop	{d8-d9}
    2706:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    bool_tele_op_toggel = 100;
  }
  //if(tele_op_toggel == 0.5 || tele_op_toggel == -0.5){
  //  bool_tele_op_toggel = !bool_tele_op_toggel;
  //}
  wheel_speed_set(goal_vel_x, goal_omega, bool_tele_op_toggel);
    270a:	f7ff be81 	b.w	2410 <wheel_speed_set(double, double, int)>
  }
  if (cmd_goal.angular.x == 5){
    bool_tele_op_toggel = 1;
    goal_omega = cmd_goal.linear.y;
  }
  if (cmd_goal.angular.x == 90){
    270e:	2200      	movs	r2, #0
    2710:	4b10      	ldr	r3, [pc, #64]	; (2754 <cmd_velocity(geometry_msgs::Twist&)+0xa0>)
    2712:	4630      	mov	r0, r6
    2714:	4639      	mov	r1, r7
    2716:	f007 fcfd 	bl	a114 <__aeabi_dcmpeq>
    271a:	b940      	cbnz	r0, 272e <cmd_velocity(geometry_msgs::Twist&)+0x7a>
    bool_tele_op_toggel = 2;
    cum_error_r = 0;
    cum_error_l = 0;
  }
  else if (cmd_goal.angular.x != 0 && cmd_goal.angular.x != 5 && cmd_goal.angular.x != 90){
    271c:	4630      	mov	r0, r6
    271e:	4639      	mov	r1, r7
    2720:	2200      	movs	r2, #0
    2722:	2300      	movs	r3, #0
    2724:	f007 fcf6 	bl	a114 <__aeabi_dcmpeq>
    2728:	b160      	cbz	r0, 2744 <cmd_velocity(geometry_msgs::Twist&)+0x90>
    272a:	6828      	ldr	r0, [r5, #0]
    272c:	e7e1      	b.n	26f2 <cmd_velocity(geometry_msgs::Twist&)+0x3e>
    bool_tele_op_toggel = 1;
    goal_omega = cmd_goal.linear.y;
  }
  if (cmd_goal.angular.x == 90){
    bool_tele_op_toggel = 2;
    cum_error_r = 0;
    272e:	4c0a      	ldr	r4, [pc, #40]	; (2758 <cmd_velocity(geometry_msgs::Twist&)+0xa4>)
    cum_error_l = 0;
    2730:	490a      	ldr	r1, [pc, #40]	; (275c <cmd_velocity(geometry_msgs::Twist&)+0xa8>)
    bool_tele_op_toggel = 1;
    goal_omega = cmd_goal.linear.y;
  }
  if (cmd_goal.angular.x == 90){
    bool_tele_op_toggel = 2;
    cum_error_r = 0;
    2732:	2200      	movs	r2, #0
    2734:	2300      	movs	r3, #0
  if (cmd_goal.angular.x == 5){
    bool_tele_op_toggel = 1;
    goal_omega = cmd_goal.linear.y;
  }
  if (cmd_goal.angular.x == 90){
    bool_tele_op_toggel = 2;
    2736:	2002      	movs	r0, #2
    cum_error_r = 0;
    2738:	e9c4 2300 	strd	r2, r3, [r4]
    cum_error_l = 0;
    273c:	e9c1 2300 	strd	r2, r3, [r1]
  if (cmd_goal.angular.x == 5){
    bool_tele_op_toggel = 1;
    goal_omega = cmd_goal.linear.y;
  }
  if (cmd_goal.angular.x == 90){
    bool_tele_op_toggel = 2;
    2740:	6028      	str	r0, [r5, #0]
    2742:	e7d6      	b.n	26f2 <cmd_velocity(geometry_msgs::Twist&)+0x3e>
    cum_error_r = 0;
    cum_error_l = 0;
  }
  else if (cmd_goal.angular.x != 0 && cmd_goal.angular.x != 5 && cmd_goal.angular.x != 90){
    bool_tele_op_toggel = 100;
    2744:	2064      	movs	r0, #100	; 0x64
    2746:	6028      	str	r0, [r5, #0]
    2748:	e7d3      	b.n	26f2 <cmd_velocity(geometry_msgs::Twist&)+0x3e>
    274a:	bf00      	nop
    274c:	1fff1c98 	.word	0x1fff1c98
    2750:	40140000 	.word	0x40140000
    2754:	40568000 	.word	0x40568000
    2758:	1fff2b28 	.word	0x1fff2b28
    275c:	1fff2a88 	.word	0x1fff2a88

00002760 <setup>:

// Subscribers //
ros::Subscriber<geometry_msgs::Twist> sub_cmd_vel("cmd_vel", &cmd_velocity);
//ros::Subscriber<std_msgs::Int16> start_up("stat_up_done", &start_up_hi);

void setup() {
    2760:	b5f0      	push	{r4, r5, r6, r7, lr}

  /* Start serial, initialize buffers */
  void initNode()
  {
    hardware_.init();
    mode_ = 0;
    2762:	4d6c      	ldr	r5, [pc, #432]	; (2914 <setup+0x1b4>)
    2764:	b085      	sub	sp, #20
    2766:	2400      	movs	r4, #0
  nh.initNode();
  Serial.begin(9600);
  pinMode(RGB_led_green, OUTPUT);
    2768:	2101      	movs	r1, #1
    276a:	2002      	movs	r0, #2
    276c:	f8c5 44e4 	str.w	r4, [r5, #1252]	; 0x4e4
    bytes_ = 0;
    2770:	f8c5 44e8 	str.w	r4, [r5, #1256]	; 0x4e8
    index_ = 0;
    2774:	f8c5 44f0 	str.w	r4, [r5, #1264]	; 0x4f0
    topic_ = 0;
    2778:	f8c5 44ec 	str.w	r4, [r5, #1260]	; 0x4ec
    277c:	f004 fa44 	bl	6c08 <pinMode>
  pinMode(RGB_led_blue, OUTPUT);
    2780:	2101      	movs	r1, #1
    2782:	2003      	movs	r0, #3
    2784:	f004 fa40 	bl	6c08 <pinMode>
  pinMode(RGB_led_red, OUTPUT);
    2788:	2101      	movs	r1, #1
    278a:	2004      	movs	r0, #4
    278c:	f004 fa3c 	bl	6c08 <pinMode>
  RGB_led_set("white");
    2790:	4961      	ldr	r1, [pc, #388]	; (2918 <setup+0x1b8>)
    2792:	4668      	mov	r0, sp
    2794:	f005 fada 	bl	7d4c <String::String(char const*)>
    2798:	4668      	mov	r0, sp
    279a:	f7ff fd2b 	bl	21f4 <RGB_led_set(String const&)>
    279e:	4668      	mov	r0, sp
    27a0:	f005 fa94 	bl	7ccc <String::~String()>
  pinMode(right_motor_pwm, OUTPUT);
    27a4:	2101      	movs	r1, #1
    27a6:	201d      	movs	r0, #29
    27a8:	f004 fa2e 	bl	6c08 <pinMode>
  pinMode(right_motor_ina, OUTPUT);
    27ac:	2101      	movs	r1, #1
    27ae:	201e      	movs	r0, #30
    27b0:	f004 fa2a 	bl	6c08 <pinMode>
  pinMode(right_motor_inb, OUTPUT);
    27b4:	2101      	movs	r1, #1
    27b6:	201c      	movs	r0, #28
    27b8:	f004 fa26 	bl	6c08 <pinMode>
  pinMode(right_encoder_a, INPUT_PULLUP);
    27bc:	2102      	movs	r1, #2
    27be:	2018      	movs	r0, #24
    27c0:	f004 fa22 	bl	6c08 <pinMode>
  pinMode(right_encoder_b, INPUT_PULLUP);
    27c4:	2102      	movs	r1, #2
    27c6:	2019      	movs	r0, #25
    27c8:	f004 fa1e 	bl	6c08 <pinMode>
  pinMode(left_motor_pwm, OUTPUT);
    27cc:	2101      	movs	r1, #1
    27ce:	2026      	movs	r0, #38	; 0x26
    27d0:	f004 fa1a 	bl	6c08 <pinMode>
  pinMode(left_motor_ina, OUTPUT);
    27d4:	2101      	movs	r1, #1
    27d6:	2027      	movs	r0, #39	; 0x27
    27d8:	f004 fa16 	bl	6c08 <pinMode>
  pinMode(left_motor_inb, OUTPUT);
    27dc:	2101      	movs	r1, #1
    27de:	2025      	movs	r0, #37	; 0x25
    27e0:	f004 fa12 	bl	6c08 <pinMode>
  pinMode(left_encoder_a, INPUT_PULLUP);
    27e4:	2102      	movs	r1, #2
    27e6:	2021      	movs	r0, #33	; 0x21
    27e8:	f004 fa0e 	bl	6c08 <pinMode>
  pinMode(left_encoder_b, INPUT_PULLUP);
    27ec:	2102      	movs	r1, #2
    27ee:	2022      	movs	r0, #34	; 0x22
    27f0:	f004 fa0a 	bl	6c08 <pinMode>
  attachInterrupt(digitalPinToInterrupt(right_encoder_a), encoder_count_chage_right, CHANGE);
    27f4:	2204      	movs	r2, #4
    27f6:	4949      	ldr	r1, [pc, #292]	; (291c <setup+0x1bc>)
    27f8:	2018      	movs	r0, #24
    27fa:	f003 ffd1 	bl	67a0 <attachInterrupt>
  attachInterrupt(digitalPinToInterrupt(right_encoder_b), encoder_count_chage_right, CHANGE);
    27fe:	2204      	movs	r2, #4
    2800:	4946      	ldr	r1, [pc, #280]	; (291c <setup+0x1bc>)
    2802:	2019      	movs	r0, #25
    2804:	f003 ffcc 	bl	67a0 <attachInterrupt>
  attachInterrupt(digitalPinToInterrupt(left_encoder_a), encoder_count_chage_left, CHANGE);
    2808:	2204      	movs	r2, #4
    280a:	4945      	ldr	r1, [pc, #276]	; (2920 <setup+0x1c0>)
    280c:	2021      	movs	r0, #33	; 0x21
    280e:	f003 ffc7 	bl	67a0 <attachInterrupt>
  attachInterrupt(digitalPinToInterrupt(left_encoder_b), encoder_count_chage_left, CHANGE);
    2812:	2204      	movs	r2, #4
    2814:	4942      	ldr	r1, [pc, #264]	; (2920 <setup+0x1c0>)
    2816:	2022      	movs	r0, #34	; 0x22
    2818:	f003 ffc2 	bl	67a0 <attachInterrupt>
  }

  /* Register a new subscriber */
  bool subscribe(Subscriber_& s)
  {
    for (int i = 0; i < MAX_SUBSCRIBERS; i++)
    281c:	4623      	mov	r3, r4
    281e:	f205 427c 	addw	r2, r5, #1148	; 0x47c
    2822:	e002      	b.n	282a <setup+0xca>
    2824:	3301      	adds	r3, #1
    2826:	2b19      	cmp	r3, #25
    2828:	d00a      	beq.n	2840 <setup+0xe0>
    {
      if (subscribers[i] == 0) // empty slot
    282a:	f852 1f04 	ldr.w	r1, [r2, #4]!
    282e:	2900      	cmp	r1, #0
    2830:	d1f8      	bne.n	2824 <setup+0xc4>
      {
        subscribers[i] = &s;
    2832:	f503 7190 	add.w	r1, r3, #288	; 0x120
    2836:	4a3b      	ldr	r2, [pc, #236]	; (2924 <setup+0x1c4>)
    2838:	f845 2021 	str.w	r2, [r5, r1, lsl #2]
        s.id_ = i + 100;
    283c:	3364      	adds	r3, #100	; 0x64
    283e:	6053      	str	r3, [r2, #4]
    2840:	4a39      	ldr	r2, [pc, #228]	; (2928 <setup+0x1c8>)
   */

  /* Register a new publisher */
  bool advertise(Publisher & p)
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    2842:	2300      	movs	r3, #0
    2844:	e002      	b.n	284c <setup+0xec>
    2846:	3301      	adds	r3, #1
    2848:	2b19      	cmp	r3, #25
    284a:	d00b      	beq.n	2864 <setup+0x104>
    {
      if (publishers[i] == 0) // empty slot
    284c:	f852 1f04 	ldr.w	r1, [r2, #4]!
    2850:	2900      	cmp	r1, #0
    2852:	d1f8      	bne.n	2846 <setup+0xe6>
      {
        publishers[i] = &p;
    2854:	4a35      	ldr	r2, [pc, #212]	; (292c <setup+0x1cc>)
    2856:	eb05 0183 	add.w	r1, r5, r3, lsl #2
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    285a:	337d      	adds	r3, #125	; 0x7d
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] == 0) // empty slot
      {
        publishers[i] = &p;
    285c:	f8c1 241c 	str.w	r2, [r1, #1052]	; 0x41c
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    2860:	6093      	str	r3, [r2, #8]
        p.nh_ = this;
    2862:	60d5      	str	r5, [r2, #12]
//  nh.advertise(IMU_data_acc);
//  nh.advertise(IMU_data_gyro);
//  nh.advertise(IMU_data_mag);
 nh.advertise(odom_and_IMU_pub);
 unsigned status;
 status = bmp.begin(BMP280_ADDRESS_ALT, BMP280_CHIPID);
    2864:	2258      	movs	r2, #88	; 0x58
    2866:	2176      	movs	r1, #118	; 0x76
    2868:	4831      	ldr	r0, [pc, #196]	; (2930 <setup+0x1d0>)
    286a:	f002 ff8f 	bl	578c <Adafruit_BMP280::begin(unsigned char, unsigned char)>
 if (!status) {
    286e:	4607      	mov	r7, r0
    2870:	b120      	cbz	r0, 287c <setup+0x11c>
   nh.loginfo("Could not find a valid BMP280 sensor, check wiring");
 }

  accelgyro.initialize();
    2872:	4830      	ldr	r0, [pc, #192]	; (2934 <setup+0x1d4>)
    2874:	f002 fcfc 	bl	5270 <MPU9250::initialize()>
  //                Adafruit_BMP280::SAMPLING_X2,     /* Temp. oversampling */
  //                Adafruit_BMP280::SAMPLING_X16,    /* Pressure oversampling */
  //                Adafruit_BMP280::FILTER_X16,      /* Filtering. */
  //                Adafruit_BMP280::STANDBY_MS_500); /* Standby time. */
  //bmp_temp->printSensorDetails();
}
    2878:	b005      	add	sp, #20
    287a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    287c:	4e2e      	ldr	r6, [pc, #184]	; (2938 <setup+0x1d8>)
    287e:	f885 0225 	strb.w	r0, [r5, #549]	; 0x225
    2882:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    2884:	4c2d      	ldr	r4, [pc, #180]	; (293c <setup+0x1dc>)
    2886:	f885 7226 	strb.w	r7, [r5, #550]	; 0x226
    288a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    288c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    288e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    2890:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    2892:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    2894:	4623      	mov	r3, r4
    2896:	6830      	ldr	r0, [r6, #0]
    2898:	f823 0937 	strh.w	r0, [r3], #-55
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    289c:	f04f 0c01 	mov.w	ip, #1
    28a0:	2132      	movs	r1, #50	; 0x32
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    28a2:	22fe      	movs	r2, #254	; 0xfe
    28a4:	f885 1224 	strb.w	r1, [r5, #548]	; 0x224

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    28a8:	f04f 0eff 	mov.w	lr, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    28ac:	2637      	movs	r6, #55	; 0x37
    28ae:	eb04 000c 	add.w	r0, r4, ip
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    28b2:	2107      	movs	r1, #7
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    28b4:	24c8      	movs	r4, #200	; 0xc8
    28b6:	f885 7227 	strb.w	r7, [r5, #551]	; 0x227
    28ba:	f885 c223 	strb.w	ip, [r5, #547]	; 0x223

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    28be:	f885 e21c 	strb.w	lr, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    28c2:	f885 221d 	strb.w	r2, [r5, #541]	; 0x21d
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    28c6:	463a      	mov	r2, r7

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    28c8:	f885 721f 	strb.w	r7, [r5, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    28cc:	f885 7222 	strb.w	r7, [r5, #546]	; 0x222
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    28d0:	f885 621e 	strb.w	r6, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    28d4:	f885 4220 	strb.w	r4, [r5, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    28d8:	f885 1221 	strb.w	r1, [r5, #545]	; 0x221
    28dc:	e001      	b.n	28e2 <setup+0x182>
    28de:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    28e2:	4283      	cmp	r3, r0
      chk += message_out[i];
    28e4:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    28e6:	d1fa      	bne.n	28de <setup+0x17e>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    28e8:	43d2      	mvns	r2, r2
    28ea:	6868      	ldr	r0, [r5, #4]
    28ec:	f885 225a 	strb.w	r2, [r5, #602]	; 0x25a
    28f0:	6803      	ldr	r3, [r0, #0]
    28f2:	4a13      	ldr	r2, [pc, #76]	; (2940 <setup+0x1e0>)
    28f4:	685b      	ldr	r3, [r3, #4]
    28f6:	4293      	cmp	r3, r2
    28f8:	d108      	bne.n	290c <setup+0x1ac>
    28fa:	213f      	movs	r1, #63	; 0x3f
    28fc:	4811      	ldr	r0, [pc, #68]	; (2944 <setup+0x1e4>)
    28fe:	f005 f8b5 	bl	7a6c <usb_serial_write>
 status = bmp.begin(BMP280_ADDRESS_ALT, BMP280_CHIPID);
 if (!status) {
   nh.loginfo("Could not find a valid BMP280 sensor, check wiring");
 }

  accelgyro.initialize();
    2902:	480c      	ldr	r0, [pc, #48]	; (2934 <setup+0x1d4>)
    2904:	f002 fcb4 	bl	5270 <MPU9250::initialize()>
  //                Adafruit_BMP280::SAMPLING_X2,     /* Temp. oversampling */
  //                Adafruit_BMP280::SAMPLING_X16,    /* Pressure oversampling */
  //                Adafruit_BMP280::FILTER_X16,      /* Filtering. */
  //                Adafruit_BMP280::STANDBY_MS_500); /* Standby time. */
  //bmp_temp->printSensorDetails();
}
    2908:	b005      	add	sp, #20
    290a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    290c:	223f      	movs	r2, #63	; 0x3f
    290e:	490d      	ldr	r1, [pc, #52]	; (2944 <setup+0x1e4>)
    2910:	4798      	blx	r3
    2912:	e7ae      	b.n	2872 <setup+0x112>
    2914:	1fff1d64 	.word	0x1fff1d64
    2918:	0000c040 	.word	0x0000c040
    291c:	00000999 	.word	0x00000999
    2920:	00000b21 	.word	0x00000b21
    2924:	1fff1ca8 	.word	0x1fff1ca8
    2928:	1fff217c 	.word	0x1fff217c
    292c:	1fff229c 	.word	0x1fff229c
    2930:	1fff2bb0 	.word	0x1fff2bb0
    2934:	1fff1c80 	.word	0x1fff1c80
    2938:	0000c048 	.word	0x0000c048
    293c:	1fff1f8c 	.word	0x1fff1f8c
    2940:	00000ebd 	.word	0x00000ebd
    2944:	1fff1f80 	.word	0x1fff1f80

00002948 <loop>:




void loop() {
    2948:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int i = 0;
  if(bool_tele_op_toggel == 2){
    294c:	4bc1      	ldr	r3, [pc, #772]	; (2c54 <loop+0x30c>)
    294e:	681b      	ldr	r3, [r3, #0]
    2950:	2b02      	cmp	r3, #2
}




void loop() {
    2952:	b095      	sub	sp, #84	; 0x54
  int i = 0;
  if(bool_tele_op_toggel == 2){
    2954:	f000 835c 	beq.w	3010 <loop+0x6c8>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2958:	4ebf      	ldr	r6, [pc, #764]	; (2c58 <loop+0x310>)
    previous_time = current_time;
    last_error_right = goal_omega_right - average_omega_right;
    last_error_left = goal_omega_left - average_omega_left;
  }

  if(millis() > time_now + period){
    295a:	4ac0      	ldr	r2, [pc, #768]	; (2c5c <loop+0x314>)
    295c:	6833      	ldr	r3, [r6, #0]
    295e:	9307      	str	r3, [sp, #28]
    2960:	6813      	ldr	r3, [r2, #0]
	return ret;
    2962:	9907      	ldr	r1, [sp, #28]
    2964:	330a      	adds	r3, #10
    2966:	428b      	cmp	r3, r1
    2968:	f0c0 81ad 	bcc.w	2cc6 <loop+0x37e>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    296c:	6833      	ldr	r3, [r6, #0]

  virtual int spinOnce() override
  {
    /* restart if timed out */
    uint32_t c_time = hardware_.time();
    if ((c_time - last_sync_receive_time) > (SYNC_SECONDS * 2200))
    296e:	4cbc      	ldr	r4, [pc, #752]	; (2c60 <loop+0x318>)
    2970:	9309      	str	r3, [sp, #36]	; 0x24
	return ret;
    2972:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
    2976:	f8d4 3500 	ldr.w	r3, [r4, #1280]	; 0x500
    297a:	f642 22f8 	movw	r2, #11000	; 0x2af8
    297e:	ebc3 030b 	rsb	r3, r3, fp
    2982:	4293      	cmp	r3, r2
    {
      configured_ = false;
    2984:	bf84      	itt	hi
    2986:	2300      	movhi	r3, #0
    2988:	f884 34f8 	strbhi.w	r3, [r4, #1272]	; 0x4f8
    }

    /* reset if message has timed out */
    if (mode_ != MODE_FIRST_FF)
    298c:	f8d4 34e4 	ldr.w	r3, [r4, #1252]	; 0x4e4
    2990:	4ab3      	ldr	r2, [pc, #716]	; (2c60 <loop+0x318>)
    2992:	b133      	cbz	r3, 29a2 <loop+0x5a>
    {
      if (c_time > last_msg_timeout_time)
    2994:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
    2998:	459b      	cmp	fp, r3
      {
        mode_ = MODE_FIRST_FF;
    299a:	bf84      	itt	hi
    299c:	2300      	movhi	r3, #0
    299e:	f8c2 34e4 	strhi.w	r3, [r2, #1252]	; 0x4e4
        }
      }
      int data = hardware_.read();
      if (data < 0)
        break;
      checksum_ += data;
    29a2:	4daf      	ldr	r5, [pc, #700]	; (2c60 <loop+0x318>)

    /* while available buffer, read data */
    while (true)
    {
      // If a timeout has been specified, check how long spinOnce has been running.
      if (spin_timeout_ > 0)
    29a4:	69a2      	ldr	r2, [r4, #24]
    29a6:	b132      	cbz	r2, 29b6 <loop+0x6e>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    29a8:	6833      	ldr	r3, [r6, #0]
    29aa:	930d      	str	r3, [sp, #52]	; 0x34
	return ret;
    29ac:	9b0d      	ldr	r3, [sp, #52]	; 0x34
      {
        // If the maximum processing timeout has been exceeded, exit with error.
        // The next spinOnce can continue where it left off, or optionally
        // based on the application in use, the hardware buffer could be flushed
        // and start fresh.
        if ((hardware_.time() - c_time) > spin_timeout_)
    29ae:	ebcb 0303 	rsb	r3, fp, r3
    29b2:	429a      	cmp	r2, r3
    29b4:	d325      	bcc.n	2a02 <loop+0xba>
    29b6:	6860      	ldr	r0, [r4, #4]
    29b8:	4aaa      	ldr	r2, [pc, #680]	; (2c64 <loop+0x31c>)
      delay(3000); 
#endif
      iostream->begin(baud_);
    }

    int read(){return iostream->read();};
    29ba:	6803      	ldr	r3, [r0, #0]
    29bc:	695b      	ldr	r3, [r3, #20]
    29be:	4293      	cmp	r3, r2
    29c0:	f040 808a 	bne.w	2ad8 <loop+0x190>
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    29c4:	f004 ffec 	bl	79a0 <usb_serial_getchar>
          // Exit the spin, processing timeout exceeded.
          return SPIN_TIMEOUT;
        }
      }
      int data = hardware_.read();
      if (data < 0)
    29c8:	2800      	cmp	r0, #0
    29ca:	f2c0 8089 	blt.w	2ae0 <loop+0x198>
        break;
      checksum_ += data;
    29ce:	f8d4 34f4 	ldr.w	r3, [r4, #1268]	; 0x4f4
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    29d2:	f8d4 24e4 	ldr.w	r2, [r4, #1252]	; 0x4e4
        }
      }
      int data = hardware_.read();
      if (data < 0)
        break;
      checksum_ += data;
    29d6:	f8df e288 	ldr.w	lr, [pc, #648]	; 2c60 <loop+0x318>
    29da:	4403      	add	r3, r0
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    29dc:	2a07      	cmp	r2, #7
        }
      }
      int data = hardware_.read();
      if (data < 0)
        break;
      checksum_ += data;
    29de:	f8c4 34f4 	str.w	r3, [r4, #1268]	; 0x4f4
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    29e2:	d066      	beq.n	2ab2 <loop+0x16a>
        message_in[index_++] = data;
        bytes_--;
        if (bytes_ == 0)                 /* is message complete? if so, checksum */
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_FIRST_FF)
    29e4:	b982      	cbnz	r2, 2a08 <loop+0xc0>
      {
        if (data == 0xff)
    29e6:	28ff      	cmp	r0, #255	; 0xff
    29e8:	f000 80cc 	beq.w	2b84 <loop+0x23c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    29ec:	6833      	ldr	r3, [r6, #0]
    29ee:	930c      	str	r3, [sp, #48]	; 0x30
	return ret;
    29f0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
        {
          mode_++;
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
        }
        else if (hardware_.time() - c_time > (SYNC_SECONDS * 1000))
    29f2:	f241 3188 	movw	r1, #5000	; 0x1388
    29f6:	ebcb 0303 	rsb	r3, fp, r3
    29fa:	428b      	cmp	r3, r1
    29fc:	d9d2      	bls.n	29a4 <loop+0x5c>
        {
          /* We have been stuck in spinOnce too long, return error */
          configured_ = false;
    29fe:	f88e 24f8 	strb.w	r2, [lr, #1272]	; 0x4f8
    //speed_pub.publish(&wheel_speed);
  }
  nh.spinOnce();
  //}
  //delay(100);
  }
    2a02:	b015      	add	sp, #84	; 0x54
    2a04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          return SPIN_TIMEOUT;
        }
      }
      else if (mode_ == MODE_PROTOCOL_VER)
    2a08:	2a01      	cmp	r2, #1
    2a0a:	f000 80c3 	beq.w	2b94 <loop+0x24c>
          mode_ = MODE_FIRST_FF;
          if (configured_ == false)
            requestSyncTime();  /* send a msg back showing our protocol version */
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
    2a0e:	2a02      	cmp	r2, #2
    2a10:	f000 810a 	beq.w	2c28 <loop+0x2e0>
        bytes_ = data;
        index_ = 0;
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
    2a14:	2a03      	cmp	r2, #3
    2a16:	f000 8112 	beq.w	2c3e <loop+0x2f6>
      {
        bytes_ += data << 8;
        mode_++;
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
    2a1a:	2a04      	cmp	r2, #4
    2a1c:	f000 812c 	beq.w	2c78 <loop+0x330>
        if ((checksum_ % 256) == 255)
          mode_++;
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
    2a20:	2a05      	cmp	r2, #5
    2a22:	f000 8139 	beq.w	2c98 <loop+0x350>
      {
        topic_ = data;
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
    2a26:	2a06      	cmp	r2, #6
    2a28:	f000 813e 	beq.w	2ca8 <loop+0x360>
        topic_ += data << 8;
        mode_ = MODE_MESSAGE;
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
    2a2c:	2a08      	cmp	r2, #8
    2a2e:	d1b9      	bne.n	29a4 <loop+0x5c>
      {
        mode_ = MODE_FIRST_FF;
        if ((checksum_ % 256) == 255)
    2a30:	4a8d      	ldr	r2, [pc, #564]	; (2c68 <loop+0x320>)
    2a32:	401a      	ands	r2, r3
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
    2a34:	2300      	movs	r3, #0
        if ((checksum_ % 256) == 255)
    2a36:	429a      	cmp	r2, r3
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
    2a38:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
        if ((checksum_ % 256) == 255)
    2a3c:	f2c0 833c 	blt.w	30b8 <loop+0x770>
    2a40:	2aff      	cmp	r2, #255	; 0xff
    2a42:	d1af      	bne.n	29a4 <loop+0x5c>
        {
          if (topic_ == TopicInfo::ID_PUBLISHER)
    2a44:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
    2a48:	f8df 9214 	ldr.w	r9, [pc, #532]	; 2c60 <loop+0x318>
    2a4c:	2b00      	cmp	r3, #0
    2a4e:	f000 84b5 	beq.w	33bc <loop+0xa74>
            negotiateTopics();
            last_sync_time = c_time;
            last_sync_receive_time = c_time;
            return SPIN_ERR;
          }
          else if (topic_ == TopicInfo::ID_TIME)
    2a52:	2b0a      	cmp	r3, #10
    2a54:	f000 833d 	beq.w	30d2 <loop+0x78a>
          {
            syncTime(message_in);
          }
          else if (topic_ == TopicInfo::ID_PARAMETER_REQUEST)
    2a58:	2b06      	cmp	r3, #6
    2a5a:	f000 836f 	beq.w	313c <loop+0x7f4>
          {
            req_param_resp.deserialize(message_in);
            param_received = true;
          }
          else if (topic_ == TopicInfo::ID_TX_STOP)
    2a5e:	2b0b      	cmp	r3, #11
    2a60:	f000 8333 	beq.w	30ca <loop+0x782>
          {
            configured_ = false;
          }
          else
          {
            if (subscribers[topic_ - 100])
    2a64:	33bc      	adds	r3, #188	; 0xbc
    2a66:	f855 0023 	ldr.w	r0, [r5, r3, lsl #2]
    2a6a:	2800      	cmp	r0, #0
    2a6c:	d09a      	beq.n	29a4 <loop+0x5c>
              subscribers[topic_ - 100]->callback(message_in);
    2a6e:	6803      	ldr	r3, [r0, #0]
    2a70:	4a7e      	ldr	r2, [pc, #504]	; (2c6c <loop+0x324>)
    2a72:	681b      	ldr	r3, [r3, #0]
    2a74:	4293      	cmp	r3, r2
    2a76:	f040 868f 	bne.w	3798 <loop+0xe50>
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    2a7a:	69ea      	ldr	r2, [r5, #28]
    2a7c:	6a2b      	ldr	r3, [r5, #32]
    2a7e:	6d81      	ldr	r1, [r0, #88]	; 0x58
      this->x = u_x.real;
    2a80:	e9c0 2308 	strd	r2, r3, [r0, #32]
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    2a84:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    2a86:	6aab      	ldr	r3, [r5, #40]	; 0x28
      this->y = u_y.real;
    2a88:	e9c0 230a 	strd	r2, r3, [r0, #40]	; 0x28
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    2a8c:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    2a8e:	6b2b      	ldr	r3, [r5, #48]	; 0x30
      this->z = u_z.real;
    2a90:	e9c0 230c 	strd	r2, r3, [r0, #48]	; 0x30
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    2a94:	6b6a      	ldr	r2, [r5, #52]	; 0x34
    2a96:	6bab      	ldr	r3, [r5, #56]	; 0x38
      this->x = u_x.real;
    2a98:	e9c0 2310 	strd	r2, r3, [r0, #64]	; 0x40
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    2a9c:	6bea      	ldr	r2, [r5, #60]	; 0x3c
    2a9e:	6c2b      	ldr	r3, [r5, #64]	; 0x40
      this->y = u_y.real;
    2aa0:	e9c0 2312 	strd	r2, r3, [r0, #72]	; 0x48
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    2aa4:	6c6a      	ldr	r2, [r5, #68]	; 0x44
    2aa6:	6cab      	ldr	r3, [r5, #72]	; 0x48
    2aa8:	3010      	adds	r0, #16
      this->z = u_z.real;
    2aaa:	e9c0 2310 	strd	r2, r3, [r0, #64]	; 0x40
    2aae:	4788      	blx	r1
    2ab0:	e778      	b.n	29a4 <loop+0x5c>
      if (data < 0)
        break;
      checksum_ += data;
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
      {
        message_in[index_++] = data;
    2ab2:	f8d5 24f0 	ldr.w	r2, [r5, #1264]	; 0x4f0
        bytes_--;
    2ab6:	f8d5 34e8 	ldr.w	r3, [r5, #1256]	; 0x4e8
      if (data < 0)
        break;
      checksum_ += data;
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
      {
        message_in[index_++] = data;
    2aba:	18a9      	adds	r1, r5, r2
        bytes_--;
    2abc:	3b01      	subs	r3, #1
      if (data < 0)
        break;
      checksum_ += data;
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
      {
        message_in[index_++] = data;
    2abe:	3201      	adds	r2, #1
    2ac0:	7708      	strb	r0, [r1, #28]
    2ac2:	f8c5 24f0 	str.w	r2, [r5, #1264]	; 0x4f0
        bytes_--;
    2ac6:	f8c5 34e8 	str.w	r3, [r5, #1256]	; 0x4e8
        if (bytes_ == 0)                 /* is message complete? if so, checksum */
    2aca:	2b00      	cmp	r3, #0
    2acc:	f47f af6a 	bne.w	29a4 <loop+0x5c>
          mode_ = MODE_MSG_CHECKSUM;
    2ad0:	2308      	movs	r3, #8
    2ad2:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    2ad6:	e765      	b.n	29a4 <loop+0x5c>
    2ad8:	4798      	blx	r3
          // Exit the spin, processing timeout exceeded.
          return SPIN_TIMEOUT;
        }
      }
      int data = hardware_.read();
      if (data < 0)
    2ada:	2800      	cmp	r0, #0
    2adc:	f6bf af77 	bge.w	29ce <loop+0x86>
        }
      }
    }

    /* occasionally sync time */
    if (configured_ && ((c_time - last_sync_time) > (SYNC_SECONDS * 500)))
    2ae0:	f894 34f8 	ldrb.w	r3, [r4, #1272]	; 0x4f8
    2ae4:	485e      	ldr	r0, [pc, #376]	; (2c60 <loop+0x318>)
    2ae6:	2b00      	cmp	r3, #0
    2ae8:	d08b      	beq.n	2a02 <loop+0xba>
    2aea:	f8d0 34fc 	ldr.w	r3, [r0, #1276]	; 0x4fc
    2aee:	f640 12c4 	movw	r2, #2500	; 0x9c4
    2af2:	ebc3 030b 	rsb	r3, r3, fp
    2af6:	4293      	cmp	r3, r2
    2af8:	d983      	bls.n	2a02 <loop+0xba>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    2afa:	23ff      	movs	r3, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    2afc:	21fe      	movs	r1, #254	; 0xfe
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->data.sec >> (8 * 0)) & 0xFF;
    2afe:	2200      	movs	r2, #0

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    2b00:	f880 321c 	strb.w	r3, [r0, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    2b04:	f880 121d 	strb.w	r1, [r0, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    2b08:	23f7      	movs	r3, #247	; 0xf7
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    2b0a:	2508      	movs	r5, #8
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    2b0c:	210a      	movs	r1, #10
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    2b0e:	f880 3220 	strb.w	r3, [r0, #544]	; 0x220
    2b12:	f880 2223 	strb.w	r2, [r0, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->data.sec >> (8 * 1)) & 0xFF;
    2b16:	f880 2224 	strb.w	r2, [r0, #548]	; 0x224
      *(outbuffer + offset + 2) = (this->data.sec >> (8 * 2)) & 0xFF;
    2b1a:	f880 2225 	strb.w	r2, [r0, #549]	; 0x225
      *(outbuffer + offset + 3) = (this->data.sec >> (8 * 3)) & 0xFF;
    2b1e:	f880 2226 	strb.w	r2, [r0, #550]	; 0x226
      offset += sizeof(this->data.sec);
      *(outbuffer + offset + 0) = (this->data.nsec >> (8 * 0)) & 0xFF;
    2b22:	f880 2227 	strb.w	r2, [r0, #551]	; 0x227
      *(outbuffer + offset + 1) = (this->data.nsec >> (8 * 1)) & 0xFF;
    2b26:	f880 2228 	strb.w	r2, [r0, #552]	; 0x228
      *(outbuffer + offset + 2) = (this->data.nsec >> (8 * 2)) & 0xFF;
    2b2a:	f880 2229 	strb.w	r2, [r0, #553]	; 0x229
      *(outbuffer + offset + 3) = (this->data.nsec >> (8 * 3)) & 0xFF;
    2b2e:	f880 222a 	strb.w	r2, [r0, #554]	; 0x22a

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    2b32:	f880 221f 	strb.w	r2, [r0, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    2b36:	f880 2222 	strb.w	r2, [r0, #546]	; 0x222
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    2b3a:	f880 521e 	strb.w	r5, [r0, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    2b3e:	f880 1221 	strb.w	r1, [r0, #545]	; 0x221
    2b42:	f200 2321 	addw	r3, r0, #545	; 0x221
    2b46:	f200 202a 	addw	r0, r0, #554	; 0x22a
    2b4a:	e001      	b.n	2b50 <loop+0x208>
    2b4c:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    2b50:	4283      	cmp	r3, r0
      chk += message_out[i];
    2b52:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    2b54:	d1fa      	bne.n	2b4c <loop+0x204>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    2b56:	43d2      	mvns	r2, r2
    2b58:	6860      	ldr	r0, [r4, #4]
    2b5a:	f884 222b 	strb.w	r2, [r4, #555]	; 0x22b
    void write(uint8_t* data, int length){
      iostream->write(data, length);
    2b5e:	6803      	ldr	r3, [r0, #0]
    2b60:	4a43      	ldr	r2, [pc, #268]	; (2c70 <loop+0x328>)
    2b62:	685b      	ldr	r3, [r3, #4]
    2b64:	4293      	cmp	r3, r2
    2b66:	f040 82ac 	bne.w	30c2 <loop+0x77a>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    2b6a:	2110      	movs	r1, #16
    2b6c:	4841      	ldr	r0, [pc, #260]	; (2c74 <loop+0x32c>)
    2b6e:	f004 ff7d 	bl	7a6c <usb_serial_write>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2b72:	6833      	ldr	r3, [r6, #0]
    2b74:	9311      	str	r3, [sp, #68]	; 0x44
	return ret;
    2b76:	9b11      	ldr	r3, [sp, #68]	; 0x44

    /* occasionally sync time */
    if (configured_ && ((c_time - last_sync_time) > (SYNC_SECONDS * 500)))
    {
      requestSyncTime();
      last_sync_time = c_time;
    2b78:	f8c4 b4fc 	str.w	fp, [r4, #1276]	; 0x4fc

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    rt_time = hardware_.time();
    2b7c:	60e3      	str	r3, [r4, #12]
    2b7e:	b015      	add	sp, #84	; 0x54
    2b80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      }
      else if (mode_ == MODE_FIRST_FF)
      {
        if (data == 0xff)
        {
          mode_++;
    2b84:	2201      	movs	r2, #1
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
    2b86:	f10b 0314 	add.w	r3, fp, #20
      }
      else if (mode_ == MODE_FIRST_FF)
      {
        if (data == 0xff)
        {
          mode_++;
    2b8a:	f8c5 24e4 	str.w	r2, [r5, #1252]	; 0x4e4
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
    2b8e:	f8c5 3504 	str.w	r3, [r5, #1284]	; 0x504
    2b92:	e707      	b.n	29a4 <loop+0x5c>
          return SPIN_TIMEOUT;
        }
      }
      else if (mode_ == MODE_PROTOCOL_VER)
      {
        if (data == PROTOCOL_VER)
    2b94:	28fe      	cmp	r0, #254	; 0xfe
    2b96:	d07b      	beq.n	2c90 <loop+0x348>
          mode_++;
        }
        else
        {
          mode_ = MODE_FIRST_FF;
          if (configured_ == false)
    2b98:	f895 24f8 	ldrb.w	r2, [r5, #1272]	; 0x4f8
        {
          mode_++;
        }
        else
        {
          mode_ = MODE_FIRST_FF;
    2b9c:	2300      	movs	r3, #0
    2b9e:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
          if (configured_ == false)
    2ba2:	2a00      	cmp	r2, #0
    2ba4:	f47f aefe 	bne.w	29a4 <loop+0x5c>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    2ba8:	23ff      	movs	r3, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    2baa:	21fe      	movs	r1, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    2bac:	2008      	movs	r0, #8

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    2bae:	f885 321c 	strb.w	r3, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    2bb2:	f885 121d 	strb.w	r1, [r5, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    2bb6:	23f7      	movs	r3, #247	; 0xf7
    message_out[5] = (uint8_t)((int16_t)id & 255);
    2bb8:	210a      	movs	r1, #10
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    2bba:	f885 3220 	strb.w	r3, [r5, #544]	; 0x220
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->data.sec >> (8 * 0)) & 0xFF;
    2bbe:	f885 2223 	strb.w	r2, [r5, #547]	; 0x223
    2bc2:	f20e 2321 	addw	r3, lr, #545	; 0x221
      *(outbuffer + offset + 1) = (this->data.sec >> (8 * 1)) & 0xFF;
    2bc6:	f885 2224 	strb.w	r2, [r5, #548]	; 0x224
      *(outbuffer + offset + 2) = (this->data.sec >> (8 * 2)) & 0xFF;
    2bca:	f885 2225 	strb.w	r2, [r5, #549]	; 0x225
      *(outbuffer + offset + 3) = (this->data.sec >> (8 * 3)) & 0xFF;
    2bce:	f885 2226 	strb.w	r2, [r5, #550]	; 0x226
      offset += sizeof(this->data.sec);
      *(outbuffer + offset + 0) = (this->data.nsec >> (8 * 0)) & 0xFF;
    2bd2:	f885 2227 	strb.w	r2, [r5, #551]	; 0x227
      *(outbuffer + offset + 1) = (this->data.nsec >> (8 * 1)) & 0xFF;
    2bd6:	f885 2228 	strb.w	r2, [r5, #552]	; 0x228
      *(outbuffer + offset + 2) = (this->data.nsec >> (8 * 2)) & 0xFF;
    2bda:	f885 2229 	strb.w	r2, [r5, #553]	; 0x229
      *(outbuffer + offset + 3) = (this->data.nsec >> (8 * 3)) & 0xFF;
    2bde:	f885 222a 	strb.w	r2, [r5, #554]	; 0x22a

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    2be2:	f885 221f 	strb.w	r2, [r5, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    2be6:	f885 2222 	strb.w	r2, [r5, #546]	; 0x222
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    2bea:	f885 021e 	strb.w	r0, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    2bee:	f885 1221 	strb.w	r1, [r5, #545]	; 0x221
    2bf2:	f20e 2e2a 	addw	lr, lr, #554	; 0x22a
    2bf6:	e001      	b.n	2bfc <loop+0x2b4>
    2bf8:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    2bfc:	4573      	cmp	r3, lr
      chk += message_out[i];
    2bfe:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    2c00:	d1fa      	bne.n	2bf8 <loop+0x2b0>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    2c02:	43d2      	mvns	r2, r2
    2c04:	6860      	ldr	r0, [r4, #4]
    2c06:	f884 222b 	strb.w	r2, [r4, #555]	; 0x22b
    2c0a:	6803      	ldr	r3, [r0, #0]
    2c0c:	4a18      	ldr	r2, [pc, #96]	; (2c70 <loop+0x328>)
    2c0e:	685b      	ldr	r3, [r3, #4]
    2c10:	4293      	cmp	r3, r2
    2c12:	f040 81e3 	bne.w	2fdc <loop+0x694>
    2c16:	2110      	movs	r1, #16
    2c18:	4816      	ldr	r0, [pc, #88]	; (2c74 <loop+0x32c>)
    2c1a:	f004 ff27 	bl	7a6c <usb_serial_write>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2c1e:	6833      	ldr	r3, [r6, #0]
    2c20:	930b      	str	r3, [sp, #44]	; 0x2c
	return ret;
    2c22:	9b0b      	ldr	r3, [sp, #44]	; 0x2c

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    rt_time = hardware_.time();
    2c24:	60e3      	str	r3, [r4, #12]
    2c26:	e6bd      	b.n	29a4 <loop+0x5c>
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
        index_ = 0;
    2c28:	2200      	movs	r2, #0
        mode_++;
    2c2a:	2303      	movs	r3, #3
            requestSyncTime();  /* send a msg back showing our protocol version */
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
    2c2c:	f8c5 04e8 	str.w	r0, [r5, #1256]	; 0x4e8
        index_ = 0;
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
    2c30:	f8c5 04f4 	str.w	r0, [r5, #1268]	; 0x4f4
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
        index_ = 0;
    2c34:	f8c5 24f0 	str.w	r2, [r5, #1264]	; 0x4f0
        mode_++;
    2c38:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
    2c3c:	e6b2      	b.n	29a4 <loop+0x5c>
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
      {
        bytes_ += data << 8;
    2c3e:	f8d5 34e8 	ldr.w	r3, [r5, #1256]	; 0x4e8
    2c42:	eb03 2000 	add.w	r0, r3, r0, lsl #8
        mode_++;
    2c46:	2304      	movs	r3, #4
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
      {
        bytes_ += data << 8;
    2c48:	f8c5 04e8 	str.w	r0, [r5, #1256]	; 0x4e8
        mode_++;
    2c4c:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
    2c50:	e6a8      	b.n	29a4 <loop+0x5c>
    2c52:	bf00      	nop
    2c54:	1fff1c98 	.word	0x1fff1c98
    2c58:	1fff2c04 	.word	0x1fff2c04
    2c5c:	1fff2b74 	.word	0x1fff2b74
    2c60:	1fff1d64 	.word	0x1fff1d64
    2c64:	00000ec5 	.word	0x00000ec5
    2c68:	800000ff 	.word	0x800000ff
    2c6c:	0000146d 	.word	0x0000146d
    2c70:	00000ebd 	.word	0x00000ebd
    2c74:	1fff1f80 	.word	0x1fff1f80
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
      {
        if ((checksum_ % 256) == 255)
    2c78:	4adf      	ldr	r2, [pc, #892]	; (2ff8 <loop+0x6b0>)
    2c7a:	401a      	ands	r2, r3
    2c7c:	2a00      	cmp	r2, #0
    2c7e:	f2c0 81b6 	blt.w	2fee <loop+0x6a6>
    2c82:	2aff      	cmp	r2, #255	; 0xff
          mode_++;
    2c84:	bf0c      	ite	eq
    2c86:	2305      	moveq	r3, #5
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
    2c88:	2300      	movne	r3, #0
    2c8a:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    2c8e:	e689      	b.n	29a4 <loop+0x5c>
      }
      else if (mode_ == MODE_PROTOCOL_VER)
      {
        if (data == PROTOCOL_VER)
        {
          mode_++;
    2c90:	2302      	movs	r3, #2
    2c92:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
    2c96:	e685      	b.n	29a4 <loop+0x5c>
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
        mode_++;
    2c98:	2306      	movs	r3, #6
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
    2c9a:	f8c5 04ec 	str.w	r0, [r5, #1260]	; 0x4ec
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
    2c9e:	f8c5 04f4 	str.w	r0, [r5, #1268]	; 0x4f4
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
        mode_++;
    2ca2:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
    2ca6:	e67d      	b.n	29a4 <loop+0x5c>
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    2ca8:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
        mode_ = MODE_MESSAGE;
        if (bytes_ == 0)
    2cac:	f8d5 24e8 	ldr.w	r2, [r5, #1256]	; 0x4e8
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    2cb0:	eb03 2300 	add.w	r3, r3, r0, lsl #8
        mode_ = MODE_MESSAGE;
    2cb4:	2107      	movs	r1, #7
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    2cb6:	f8c5 34ec 	str.w	r3, [r5, #1260]	; 0x4ec
        mode_ = MODE_MESSAGE;
    2cba:	f8c5 14e4 	str.w	r1, [r5, #1252]	; 0x4e4
        if (bytes_ == 0)
    2cbe:	2a00      	cmp	r2, #0
    2cc0:	f43f af06 	beq.w	2ad0 <loop+0x188>
    2cc4:	e66e      	b.n	29a4 <loop+0x5c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2cc6:	6833      	ldr	r3, [r6, #0]
    2cc8:	9308      	str	r3, [sp, #32]
	return ret;
    2cca:	9b08      	ldr	r3, [sp, #32]
    last_error_right = goal_omega_right - average_omega_right;
    last_error_left = goal_omega_left - average_omega_left;
  }

  if(millis() > time_now + period){
    time_now = millis();
    2ccc:	6013      	str	r3, [r2, #0]
    //wheel_speed.x = average_omega_right;
    //wheel_speed.y = average_omega_left;
    //wheel_speed.z = error_r;
    //wheel_speed.w = cum_error_r;

    imu_collection();
    2cce:	f7ff f9c7 	bl	2060 <imu_collection()>
    2cd2:	4bca      	ldr	r3, [pc, #808]	; (2ffc <loop+0x6b4>)
    2cd4:	4aca      	ldr	r2, [pc, #808]	; (3000 <loop+0x6b8>)
    2cd6:	68d8      	ldr	r0, [r3, #12]
    2cd8:	6899      	ldr	r1, [r3, #8]
    msg_(msg),
    endpoint_(endpoint) {};

  int publish(const Msg * msg)
  {
    return nh_->publish(id_, msg);
    2cda:	6803      	ldr	r3, [r0, #0]
    2cdc:	681b      	ldr	r3, [r3, #0]
    2cde:	4293      	cmp	r3, r2
    2ce0:	f040 81e7 	bne.w	30b2 <loop+0x76a>
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    2ce4:	2963      	cmp	r1, #99	; 0x63
    2ce6:	dd04      	ble.n	2cf2 <loop+0x3aa>
    2ce8:	f890 34f8 	ldrb.w	r3, [r0, #1272]	; 0x4f8
    2cec:	2b00      	cmp	r3, #0
    2cee:	f43f ae3d 	beq.w	296c <loop+0x24>
      int offset = 0;
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
    2cf2:	4bc4      	ldr	r3, [pc, #784]	; (3004 <loop+0x6bc>)
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    2cf4:	f8d3 e010 	ldr.w	lr, [r3, #16]
    2cf8:	695f      	ldr	r7, [r3, #20]
    2cfa:	f880 e223 	strb.w	lr, [r0, #547]	; 0x223
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
    2cfe:	ea4f 2c1e 	mov.w	ip, lr, lsr #8
    2d02:	f880 c224 	strb.w	ip, [r0, #548]	; 0x224
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    2d06:	ea4f 4c1e 	mov.w	ip, lr, lsr #16
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    2d0a:	ea4f 6e1e 	mov.w	lr, lr, lsr #24
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    2d0e:	699d      	ldr	r5, [r3, #24]
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    2d10:	f880 e226 	strb.w	lr, [r0, #550]	; 0x226
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    2d14:	ea4f 2e17 	mov.w	lr, r7, lsr #8
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
    2d18:	f880 7227 	strb.w	r7, [r0, #551]	; 0x227
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    2d1c:	f880 e228 	strb.w	lr, [r0, #552]	; 0x228
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    2d20:	ea4f 4e17 	mov.w	lr, r7, lsr #16
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    2d24:	0e3f      	lsrs	r7, r7, #24
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    2d26:	69dc      	ldr	r4, [r3, #28]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    2d28:	f880 722a 	strb.w	r7, [r0, #554]	; 0x22a
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    2d2c:	0a2f      	lsrs	r7, r5, #8
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    2d2e:	f880 522b 	strb.w	r5, [r0, #555]	; 0x22b
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    2d32:	f880 722c 	strb.w	r7, [r0, #556]	; 0x22c
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    2d36:	0c2f      	lsrs	r7, r5, #16
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    2d38:	0e2d      	lsrs	r5, r5, #24
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    2d3a:	6a1a      	ldr	r2, [r3, #32]
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    2d3c:	f880 522e 	strb.w	r5, [r0, #558]	; 0x22e
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    2d40:	0a25      	lsrs	r5, r4, #8
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    2d42:	f880 e229 	strb.w	lr, [r0, #553]	; 0x229
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
    2d46:	f880 422f 	strb.w	r4, [r0, #559]	; 0x22f
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    2d4a:	f8d3 e024 	ldr.w	lr, [r3, #36]	; 0x24
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    2d4e:	f880 5230 	strb.w	r5, [r0, #560]	; 0x230
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    2d52:	0c25      	lsrs	r5, r4, #16
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    2d54:	0e24      	lsrs	r4, r4, #24
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    2d56:	f880 5231 	strb.w	r5, [r0, #561]	; 0x231
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    2d5a:	f880 4232 	strb.w	r4, [r0, #562]	; 0x232
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    2d5e:	0a15      	lsrs	r5, r2, #8
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    2d60:	0c14      	lsrs	r4, r2, #16
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    2d62:	f880 2233 	strb.w	r2, [r0, #563]	; 0x233
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    2d66:	0e12      	lsrs	r2, r2, #24
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    2d68:	f880 5234 	strb.w	r5, [r0, #564]	; 0x234
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    2d6c:	f880 4235 	strb.w	r4, [r0, #565]	; 0x235
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    2d70:	ea4f 251e 	mov.w	r5, lr, lsr #8
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    2d74:	ea4f 441e 	mov.w	r4, lr, lsr #16
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    2d78:	f880 2236 	strb.w	r2, [r0, #566]	; 0x236
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
    2d7c:	f880 e237 	strb.w	lr, [r0, #567]	; 0x237
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    2d80:	ea4f 621e 	mov.w	r2, lr, lsr #24
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    2d84:	f8d3 e030 	ldr.w	lr, [r3, #48]	; 0x30
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    2d88:	f880 c225 	strb.w	ip, [r0, #549]	; 0x225
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    2d8c:	f880 223a 	strb.w	r2, [r0, #570]	; 0x23a
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
    2d90:	ea4f 2c1e 	mov.w	ip, lr, lsr #8
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    2d94:	6b5a      	ldr	r2, [r3, #52]	; 0x34
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    2d96:	f880 722d 	strb.w	r7, [r0, #557]	; 0x22d
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    2d9a:	f880 5238 	strb.w	r5, [r0, #568]	; 0x238
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    2d9e:	f880 4239 	strb.w	r4, [r0, #569]	; 0x239
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    2da2:	f880 e23b 	strb.w	lr, [r0, #571]	; 0x23b
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
    2da6:	f880 c23c 	strb.w	ip, [r0, #572]	; 0x23c
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    2daa:	ea4f 4c1e 	mov.w	ip, lr, lsr #16
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    2dae:	ea4f 6e1e 	mov.w	lr, lr, lsr #24
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    2db2:	6b9f      	ldr	r7, [r3, #56]	; 0x38
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    2db4:	f880 e23e 	strb.w	lr, [r0, #574]	; 0x23e
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    2db8:	ea4f 2e12 	mov.w	lr, r2, lsr #8
    2dbc:	f880 e240 	strb.w	lr, [r0, #576]	; 0x240
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    2dc0:	ea4f 6e12 	mov.w	lr, r2, lsr #24
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    2dc4:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    2dc6:	f880 e242 	strb.w	lr, [r0, #578]	; 0x242
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    2dca:	ea4f 2e17 	mov.w	lr, r7, lsr #8
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    2dce:	f880 7243 	strb.w	r7, [r0, #579]	; 0x243
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    2dd2:	f880 e244 	strb.w	lr, [r0, #580]	; 0x244
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    2dd6:	ea4f 4e17 	mov.w	lr, r7, lsr #16
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    2dda:	0e3f      	lsrs	r7, r7, #24
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    2ddc:	6c1c      	ldr	r4, [r3, #64]	; 0x40
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    2dde:	f880 7246 	strb.w	r7, [r0, #582]	; 0x246
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    2de2:	0a2f      	lsrs	r7, r5, #8
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
    2de4:	f880 5247 	strb.w	r5, [r0, #583]	; 0x247
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    2de8:	f880 7248 	strb.w	r7, [r0, #584]	; 0x248
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    2dec:	0c2f      	lsrs	r7, r5, #16
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    2dee:	0e2d      	lsrs	r5, r5, #24
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
    2df0:	f880 223f 	strb.w	r2, [r0, #575]	; 0x23f
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    2df4:	f880 c23d 	strb.w	ip, [r0, #573]	; 0x23d
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    2df8:	f880 524a 	strb.w	r5, [r0, #586]	; 0x24a
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    2dfc:	ea4f 4c12 	mov.w	ip, r2, lsr #16
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    2e00:	0a25      	lsrs	r5, r4, #8
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    2e02:	6c5a      	ldr	r2, [r3, #68]	; 0x44
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    2e04:	f880 e245 	strb.w	lr, [r0, #581]	; 0x245
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    2e08:	f880 424b 	strb.w	r4, [r0, #587]	; 0x24b
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    2e0c:	f8d3 e050 	ldr.w	lr, [r3, #80]	; 0x50
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    2e10:	f880 524c 	strb.w	r5, [r0, #588]	; 0x24c
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    2e14:	0c25      	lsrs	r5, r4, #16
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    2e16:	0e24      	lsrs	r4, r4, #24
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    2e18:	f880 524d 	strb.w	r5, [r0, #589]	; 0x24d
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    2e1c:	f880 424e 	strb.w	r4, [r0, #590]	; 0x24e
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    2e20:	0a15      	lsrs	r5, r2, #8
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    2e22:	0c14      	lsrs	r4, r2, #16
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
    2e24:	f880 224f 	strb.w	r2, [r0, #591]	; 0x24f
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    2e28:	0e12      	lsrs	r2, r2, #24
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    2e2a:	f880 5250 	strb.w	r5, [r0, #592]	; 0x250
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    2e2e:	f880 4251 	strb.w	r4, [r0, #593]	; 0x251
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
    2e32:	ea4f 251e 	mov.w	r5, lr, lsr #8
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    2e36:	ea4f 441e 	mov.w	r4, lr, lsr #16
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    2e3a:	f880 2252 	strb.w	r2, [r0, #594]	; 0x252
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    2e3e:	ea4f 621e 	mov.w	r2, lr, lsr #24
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    2e42:	f880 c241 	strb.w	ip, [r0, #577]	; 0x241
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    2e46:	f880 7249 	strb.w	r7, [r0, #585]	; 0x249
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    2e4a:	f880 e253 	strb.w	lr, [r0, #595]	; 0x253
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
    2e4e:	f880 5254 	strb.w	r5, [r0, #596]	; 0x254
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    2e52:	f8d3 e054 	ldr.w	lr, [r3, #84]	; 0x54
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    2e56:	f880 4255 	strb.w	r4, [r0, #597]	; 0x255
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    2e5a:	f880 2256 	strb.w	r2, [r0, #598]	; 0x256
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    2e5e:	f103 0258 	add.w	r2, r3, #88	; 0x58
    2e62:	caa4      	ldmia	r2, {r2, r5, r7}
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    2e64:	ea4f 2c1e 	mov.w	ip, lr, lsr #8
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
    2e68:	f880 e257 	strb.w	lr, [r0, #599]	; 0x257
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    2e6c:	f880 c258 	strb.w	ip, [r0, #600]	; 0x258
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    2e70:	ea4f 4c1e 	mov.w	ip, lr, lsr #16
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    2e74:	ea4f 6e1e 	mov.w	lr, lr, lsr #24
    2e78:	f880 e25a 	strb.w	lr, [r0, #602]	; 0x25a
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    2e7c:	ea4f 2e12 	mov.w	lr, r2, lsr #8
    2e80:	f880 e25c 	strb.w	lr, [r0, #604]	; 0x25c
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    2e84:	ea4f 6e12 	mov.w	lr, r2, lsr #24
    2e88:	f880 e25e 	strb.w	lr, [r0, #606]	; 0x25e
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    2e8c:	ea4f 2e15 	mov.w	lr, r5, lsr #8
    2e90:	f880 e260 	strb.w	lr, [r0, #608]	; 0x260
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    2e94:	ea4f 6e15 	mov.w	lr, r5, lsr #24
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    2e98:	6e5c      	ldr	r4, [r3, #100]	; 0x64
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    2e9a:	f880 e262 	strb.w	lr, [r0, #610]	; 0x262
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    2e9e:	ea4f 2e17 	mov.w	lr, r7, lsr #8
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    2ea2:	f880 7263 	strb.w	r7, [r0, #611]	; 0x263
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    2ea6:	f880 e264 	strb.w	lr, [r0, #612]	; 0x264
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    2eaa:	ea4f 4e17 	mov.w	lr, r7, lsr #16
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    2eae:	0e3f      	lsrs	r7, r7, #24
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    2eb0:	f880 c259 	strb.w	ip, [r0, #601]	; 0x259
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    2eb4:	f880 225b 	strb.w	r2, [r0, #603]	; 0x25b
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    2eb8:	ea4f 4c12 	mov.w	ip, r2, lsr #16
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    2ebc:	f880 7266 	strb.w	r7, [r0, #614]	; 0x266
      union {
        double real;
        uint64_t base;
      } u_omega_right;
      u_omega_right.real = this->omega_right;
      *(outbuffer + offset + 0) = (u_omega_right.base >> (8 * 0)) & 0xFF;
    2ec0:	6e9a      	ldr	r2, [r3, #104]	; 0x68
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    2ec2:	f880 c25d 	strb.w	ip, [r0, #605]	; 0x25d
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    2ec6:	0a27      	lsrs	r7, r4, #8
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    2ec8:	ea4f 4c15 	mov.w	ip, r5, lsr #16
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
    2ecc:	f880 525f 	strb.w	r5, [r0, #607]	; 0x25f
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
    2ed0:	f880 4267 	strb.w	r4, [r0, #615]	; 0x267
    2ed4:	6edd      	ldr	r5, [r3, #108]	; 0x6c
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    2ed6:	f880 7268 	strb.w	r7, [r0, #616]	; 0x268
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    2eda:	0c27      	lsrs	r7, r4, #16
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    2edc:	0e24      	lsrs	r4, r4, #24
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    2ede:	f880 7269 	strb.w	r7, [r0, #617]	; 0x269
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    2ee2:	f880 426a 	strb.w	r4, [r0, #618]	; 0x26a
      *(outbuffer + offset + 1) = (u_omega_right.base >> (8 * 1)) & 0xFF;
    2ee6:	0a17      	lsrs	r7, r2, #8
      *(outbuffer + offset + 2) = (u_omega_right.base >> (8 * 2)) & 0xFF;
    2ee8:	0c14      	lsrs	r4, r2, #16
      union {
        double real;
        uint64_t base;
      } u_omega_right;
      u_omega_right.real = this->omega_right;
      *(outbuffer + offset + 0) = (u_omega_right.base >> (8 * 0)) & 0xFF;
    2eea:	f880 226b 	strb.w	r2, [r0, #619]	; 0x26b
      *(outbuffer + offset + 1) = (u_omega_right.base >> (8 * 1)) & 0xFF;
    2eee:	f880 726c 	strb.w	r7, [r0, #620]	; 0x26c
      *(outbuffer + offset + 2) = (u_omega_right.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_omega_right.base >> (8 * 3)) & 0xFF;
    2ef2:	0e12      	lsrs	r2, r2, #24
      *(outbuffer + offset + 4) = (u_omega_right.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_right.base >> (8 * 5)) & 0xFF;
    2ef4:	0a2f      	lsrs	r7, r5, #8
        uint64_t base;
      } u_omega_right;
      u_omega_right.real = this->omega_right;
      *(outbuffer + offset + 0) = (u_omega_right.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_right.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_omega_right.base >> (8 * 2)) & 0xFF;
    2ef6:	f880 426d 	strb.w	r4, [r0, #621]	; 0x26d
      *(outbuffer + offset + 3) = (u_omega_right.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_omega_right.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_right.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_omega_right.base >> (8 * 6)) & 0xFF;
    2efa:	0c2c      	lsrs	r4, r5, #16
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    2efc:	f880 c261 	strb.w	ip, [r0, #609]	; 0x261
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    2f00:	f880 e265 	strb.w	lr, [r0, #613]	; 0x265
      } u_omega_right;
      u_omega_right.real = this->omega_right;
      *(outbuffer + offset + 0) = (u_omega_right.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_right.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_omega_right.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_omega_right.base >> (8 * 3)) & 0xFF;
    2f04:	f880 226e 	strb.w	r2, [r0, #622]	; 0x26e
      *(outbuffer + offset + 4) = (u_omega_right.base >> (8 * 4)) & 0xFF;
    2f08:	f880 526f 	strb.w	r5, [r0, #623]	; 0x26f
      *(outbuffer + offset + 5) = (u_omega_right.base >> (8 * 5)) & 0xFF;
    2f0c:	f880 7270 	strb.w	r7, [r0, #624]	; 0x270
      *(outbuffer + offset + 6) = (u_omega_right.base >> (8 * 6)) & 0xFF;
    2f10:	f880 4271 	strb.w	r4, [r0, #625]	; 0x271
      union {
        double real;
        uint64_t base;
      } u_omega_left;
      u_omega_left.real = this->omega_left;
      *(outbuffer + offset + 0) = (u_omega_left.base >> (8 * 0)) & 0xFF;
    2f14:	6f1c      	ldr	r4, [r3, #112]	; 0x70
    2f16:	6f5a      	ldr	r2, [r3, #116]	; 0x74
      union {
        double real;
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
    2f18:	6f9f      	ldr	r7, [r3, #120]	; 0x78
      union {
        double real;
        uint64_t base;
      } u_omega_left;
      u_omega_left.real = this->omega_left;
      *(outbuffer + offset + 0) = (u_omega_left.base >> (8 * 0)) & 0xFF;
    2f1a:	f880 4273 	strb.w	r4, [r0, #627]	; 0x273
      *(outbuffer + offset + 2) = (u_omega_right.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_omega_right.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_omega_right.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_right.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_omega_right.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_omega_right.base >> (8 * 7)) & 0xFF;
    2f1e:	0e2d      	lsrs	r5, r5, #24
    2f20:	f880 5272 	strb.w	r5, [r0, #626]	; 0x272
        double real;
        uint64_t base;
      } u_omega_left;
      u_omega_left.real = this->omega_left;
      *(outbuffer + offset + 0) = (u_omega_left.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_left.base >> (8 * 1)) & 0xFF;
    2f24:	0a25      	lsrs	r5, r4, #8
    2f26:	f880 5274 	strb.w	r5, [r0, #628]	; 0x274
      *(outbuffer + offset + 2) = (u_omega_left.base >> (8 * 2)) & 0xFF;
    2f2a:	0c25      	lsrs	r5, r4, #16
      *(outbuffer + offset + 3) = (u_omega_left.base >> (8 * 3)) & 0xFF;
    2f2c:	0e24      	lsrs	r4, r4, #24
      union {
        double real;
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
    2f2e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
      } u_omega_left;
      u_omega_left.real = this->omega_left;
      *(outbuffer + offset + 0) = (u_omega_left.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_left.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_omega_left.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_omega_left.base >> (8 * 3)) & 0xFF;
    2f30:	f880 4276 	strb.w	r4, [r0, #630]	; 0x276
      *(outbuffer + offset + 4) = (u_omega_left.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_left.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_omega_left.base >> (8 * 6)) & 0xFF;
    2f34:	0c14      	lsrs	r4, r2, #16
        uint64_t base;
      } u_omega_left;
      u_omega_left.real = this->omega_left;
      *(outbuffer + offset + 0) = (u_omega_left.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_left.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_omega_left.base >> (8 * 2)) & 0xFF;
    2f36:	f880 5275 	strb.w	r5, [r0, #629]	; 0x275
      *(outbuffer + offset + 3) = (u_omega_left.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_omega_left.base >> (8 * 4)) & 0xFF;
    2f3a:	f880 2277 	strb.w	r2, [r0, #631]	; 0x277
      *(outbuffer + offset + 5) = (u_omega_left.base >> (8 * 5)) & 0xFF;
    2f3e:	0a15      	lsrs	r5, r2, #8
      *(outbuffer + offset + 6) = (u_omega_left.base >> (8 * 6)) & 0xFF;
    2f40:	f880 4279 	strb.w	r4, [r0, #633]	; 0x279
      *(outbuffer + offset + 7) = (u_omega_left.base >> (8 * 7)) & 0xFF;
    2f44:	0e12      	lsrs	r2, r2, #24
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_temp.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
    2f46:	0c3c      	lsrs	r4, r7, #16
      *(outbuffer + offset + 0) = (u_omega_left.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_left.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_omega_left.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_omega_left.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_omega_left.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_left.base >> (8 * 5)) & 0xFF;
    2f48:	f880 5278 	strb.w	r5, [r0, #632]	; 0x278
      *(outbuffer + offset + 6) = (u_omega_left.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_omega_left.base >> (8 * 7)) & 0xFF;
    2f4c:	f880 227a 	strb.w	r2, [r0, #634]	; 0x27a
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_temp.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_temp.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_temp.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_temp.base >> (8 * 5)) & 0xFF;
    2f50:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_temp.base >> (8 * 6)) & 0xFF;
    2f52:	0c1a      	lsrs	r2, r3, #16
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_temp.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_temp.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_temp.base >> (8 * 4)) & 0xFF;
    2f54:	f880 327f 	strb.w	r3, [r0, #639]	; 0x27f
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_temp.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
    2f58:	f880 427d 	strb.w	r4, [r0, #637]	; 0x27d
      *(outbuffer + offset + 3) = (u_temp.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_temp.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_temp.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_temp.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_temp.base >> (8 * 7)) & 0xFF;
    2f5c:	0e1b      	lsrs	r3, r3, #24

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    2f5e:	24ff      	movs	r4, #255	; 0xff
        double real;
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_temp.base >> (8 * 1)) & 0xFF;
    2f60:	ea4f 2c17 	mov.w	ip, r7, lsr #8
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_temp.base >> (8 * 3)) & 0xFF;
    2f64:	ea4f 6e17 	mov.w	lr, r7, lsr #24
      union {
        double real;
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
    2f68:	f880 727b 	strb.w	r7, [r0, #635]	; 0x27b
      *(outbuffer + offset + 1) = (u_temp.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_temp.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_temp.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_temp.base >> (8 * 5)) & 0xFF;
    2f6c:	f880 5280 	strb.w	r5, [r0, #640]	; 0x280
    message_out[1] = PROTOCOL_VER;
    2f70:	27fe      	movs	r7, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    2f72:	2560      	movs	r5, #96	; 0x60
      *(outbuffer + offset + 6) = (u_temp.base >> (8 * 6)) & 0xFF;
    2f74:	f880 2281 	strb.w	r2, [r0, #641]	; 0x281
      *(outbuffer + offset + 7) = (u_temp.base >> (8 * 7)) & 0xFF;
    2f78:	f880 3282 	strb.w	r3, [r0, #642]	; 0x282
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    2f7c:	2200      	movs	r2, #0
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    2f7e:	239f      	movs	r3, #159	; 0x9f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    2f80:	f880 421c 	strb.w	r4, [r0, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    2f84:	b2cc      	uxtb	r4, r1
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    2f86:	f341 2107 	sbfx	r1, r1, #8, #8
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    2f8a:	f880 3220 	strb.w	r3, [r0, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    2f8e:	f880 1222 	strb.w	r1, [r0, #546]	; 0x222
        double real;
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_temp.base >> (8 * 1)) & 0xFF;
    2f92:	f880 c27c 	strb.w	ip, [r0, #636]	; 0x27c
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_temp.base >> (8 * 3)) & 0xFF;
    2f96:	f880 e27e 	strb.w	lr, [r0, #638]	; 0x27e
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    2f9a:	f880 721d 	strb.w	r7, [r0, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    2f9e:	f880 521e 	strb.w	r5, [r0, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    2fa2:	f880 221f 	strb.w	r2, [r0, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    2fa6:	f880 4221 	strb.w	r4, [r0, #545]	; 0x221
    2faa:	f200 2321 	addw	r3, r0, #545	; 0x221
    2fae:	f200 2182 	addw	r1, r0, #642	; 0x282
    2fb2:	e001      	b.n	2fb8 <loop+0x670>
    2fb4:	f813 4f01 	ldrb.w	r4, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    2fb8:	428b      	cmp	r3, r1
      chk += message_out[i];
    2fba:	4422      	add	r2, r4
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    2fbc:	d1fa      	bne.n	2fb4 <loop+0x66c>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    2fbe:	43d2      	mvns	r2, r2
    2fc0:	6844      	ldr	r4, [r0, #4]
    2fc2:	f880 2283 	strb.w	r2, [r0, #643]	; 0x283
    2fc6:	6823      	ldr	r3, [r4, #0]
    2fc8:	4a0f      	ldr	r2, [pc, #60]	; (3008 <loop+0x6c0>)
    2fca:	685b      	ldr	r3, [r3, #4]
    2fcc:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    2fce:	f500 7007 	add.w	r0, r0, #540	; 0x21c
    2fd2:	d107      	bne.n	2fe4 <loop+0x69c>
    2fd4:	2168      	movs	r1, #104	; 0x68
    2fd6:	f004 fd49 	bl	7a6c <usb_serial_write>
    2fda:	e4c7      	b.n	296c <loop+0x24>
    2fdc:	2210      	movs	r2, #16
    2fde:	490b      	ldr	r1, [pc, #44]	; (300c <loop+0x6c4>)
    2fe0:	4798      	blx	r3
    2fe2:	e61c      	b.n	2c1e <loop+0x2d6>
    2fe4:	4601      	mov	r1, r0
    2fe6:	2268      	movs	r2, #104	; 0x68
    2fe8:	4620      	mov	r0, r4
    2fea:	4798      	blx	r3
    2fec:	e4be      	b.n	296c <loop+0x24>
        bytes_ += data << 8;
        mode_++;
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
      {
        if ((checksum_ % 256) == 255)
    2fee:	3a01      	subs	r2, #1
    2ff0:	f062 02ff 	orn	r2, r2, #255	; 0xff
    2ff4:	3201      	adds	r2, #1
    2ff6:	e644      	b.n	2c82 <loop+0x33a>
    2ff8:	800000ff 	.word	0x800000ff
    2ffc:	1fff229c 	.word	0x1fff229c
    3000:	00001a4d 	.word	0x00001a4d
    3004:	1fff2a90 	.word	0x1fff2a90
    3008:	00000ebd 	.word	0x00000ebd
    300c:	1fff1f80 	.word	0x1fff1f80

void loop() {
  int i = 0;
  if(bool_tele_op_toggel == 2){
    current_time = micros();
    double time_elapsed = double(current_time - previous_time)*pow(10,-6);
    3010:	f8df 9390 	ldr.w	r9, [pc, #912]	; 33a4 <loop+0xa5c>


void loop() {
  int i = 0;
  if(bool_tele_op_toggel == 2){
    current_time = micros();
    3014:	f8df b390 	ldr.w	fp, [pc, #912]	; 33a8 <loop+0xa60>
    double time_elapsed = double(current_time - previous_time)*pow(10,-6);
    speed_PID_controller(goal_omega_right, average_omega_right, last_error_right, goal_omega_left, average_omega_left, last_error_left, time_elapsed);
    3018:	4ed7      	ldr	r6, [pc, #860]	; (3378 <loop+0xa30>)
    301a:	f8df a390 	ldr.w	sl, [pc, #912]	; 33ac <loop+0xa64>
    301e:	4cd7      	ldr	r4, [pc, #860]	; (337c <loop+0xa34>)
    3020:	4dd7      	ldr	r5, [pc, #860]	; (3380 <loop+0xa38>)
    3022:	4fd8      	ldr	r7, [pc, #864]	; (3384 <loop+0xa3c>)
    3024:	f8df 8388 	ldr.w	r8, [pc, #904]	; 33b0 <loop+0xa68>


void loop() {
  int i = 0;
  if(bool_tele_op_toggel == 2){
    current_time = micros();
    3028:	f003 fdf4 	bl	6c14 <micros>
    double time_elapsed = double(current_time - previous_time)*pow(10,-6);
    speed_PID_controller(goal_omega_right, average_omega_right, last_error_right, goal_omega_left, average_omega_left, last_error_left, time_elapsed);
    302c:	f8d9 3000 	ldr.w	r3, [r9]


void loop() {
  int i = 0;
  if(bool_tele_op_toggel == 2){
    current_time = micros();
    3030:	f8cb 0000 	str.w	r0, [fp]
    double time_elapsed = double(current_time - previous_time)*pow(10,-6);
    speed_PID_controller(goal_omega_right, average_omega_right, last_error_right, goal_omega_left, average_omega_left, last_error_left, time_elapsed);
    3034:	1ac0      	subs	r0, r0, r3
    3036:	f006 fd9f 	bl	9b78 <__aeabi_i2d>
    303a:	a3cd      	add	r3, pc, #820	; (adr r3, 3370 <loop+0xa28>)
    303c:	e9d3 2300 	ldrd	r2, r3, [r3]
    3040:	f006 fe00 	bl	9c44 <__aeabi_dmul>
    3044:	e9cd 0102 	strd	r0, r1, [sp, #8]
    3048:	6830      	ldr	r0, [r6, #0]
    304a:	f006 fda7 	bl	9b9c <__aeabi_f2d>
    304e:	e9cd 0100 	strd	r0, r1, [sp]
    3052:	f8da 0000 	ldr.w	r0, [sl]
    3056:	f006 fda1 	bl	9b9c <__aeabi_f2d>
    305a:	ed94 5b00 	vldr	d5, [r4]
    305e:	ec41 0b11 	vmov	d1, r0, r1
    3062:	ed95 3b00 	vldr	d3, [r5]
    3066:	ed97 2b00 	vldr	d2, [r7]
    306a:	ed9d 6b02 	vldr	d6, [sp, #8]
    306e:	ed9d 4b00 	vldr	d4, [sp]
    3072:	ed98 0b00 	vldr	d0, [r8]
    3076:	f7fe ff21 	bl	1ebc <speed_PID_controller(double, double, double, double, double, double, double)>

    previous_time = current_time;
    307a:	f8db 3000 	ldr.w	r3, [fp]
    307e:	f8c9 3000 	str.w	r3, [r9]
    last_error_right = goal_omega_right - average_omega_right;
    3082:	f8da 0000 	ldr.w	r0, [sl]
    3086:	f006 fd89 	bl	9b9c <__aeabi_f2d>
    308a:	4602      	mov	r2, r0
    308c:	460b      	mov	r3, r1
    308e:	e9d8 0100 	ldrd	r0, r1, [r8]
    3092:	f006 fc23 	bl	98dc <__aeabi_dsub>
    3096:	e9c7 0100 	strd	r0, r1, [r7]
    last_error_left = goal_omega_left - average_omega_left;
    309a:	6830      	ldr	r0, [r6, #0]
    309c:	f006 fd7e 	bl	9b9c <__aeabi_f2d>
    30a0:	4602      	mov	r2, r0
    30a2:	460b      	mov	r3, r1
    30a4:	e9d5 0100 	ldrd	r0, r1, [r5]
    30a8:	f006 fc18 	bl	98dc <__aeabi_dsub>
    30ac:	e9c4 0100 	strd	r0, r1, [r4]
    30b0:	e452      	b.n	2958 <loop+0x10>
    30b2:	4ab5      	ldr	r2, [pc, #724]	; (3388 <loop+0xa40>)
    30b4:	4798      	blx	r3
    30b6:	e459      	b.n	296c <loop+0x24>
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
        if ((checksum_ % 256) == 255)
    30b8:	3a01      	subs	r2, #1
    30ba:	f062 02ff 	orn	r2, r2, #255	; 0xff
    30be:	3201      	adds	r2, #1
    30c0:	e4be      	b.n	2a40 <loop+0xf8>
    30c2:	2210      	movs	r2, #16
    30c4:	49b1      	ldr	r1, [pc, #708]	; (338c <loop+0xa44>)
    30c6:	4798      	blx	r3
    30c8:	e553      	b.n	2b72 <loop+0x22a>
            req_param_resp.deserialize(message_in);
            param_received = true;
          }
          else if (topic_ == TopicInfo::ID_TX_STOP)
          {
            configured_ = false;
    30ca:	2300      	movs	r3, #0
    30cc:	f885 34f8 	strb.w	r3, [r5, #1272]	; 0x4f8
    30d0:	e468      	b.n	29a4 <loop+0x5c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    30d2:	6833      	ldr	r3, [r6, #0]
    30d4:	930e      	str	r3, [sp, #56]	; 0x38
	return ret;
    30d6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  }

  void syncTime(uint8_t * data)
  {
    std_msgs::Time t;
    uint32_t offset = hardware_.time() - rt_time;
    30d8:	68ea      	ldr	r2, [r5, #12]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    30da:	6831      	ldr	r1, [r6, #0]
    30dc:	9110      	str	r1, [sp, #64]	; 0x40
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    30de:	48ac      	ldr	r0, [pc, #688]	; (3390 <loop+0xa48>)
	return ret;
    30e0:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    30e4:	6a29      	ldr	r1, [r5, #32]
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    30e6:	f8df c2cc 	ldr.w	ip, [pc, #716]	; 33b4 <loop+0xa6c>
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    30ea:	4fa9      	ldr	r7, [pc, #676]	; (3390 <loop+0xa48>)
  }

  void syncTime(uint8_t * data)
  {
    std_msgs::Time t;
    uint32_t offset = hardware_.time() - rt_time;
    30ec:	1a9b      	subs	r3, r3, r2
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    30ee:	fba0 0e03 	umull	r0, lr, r0, r3
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    30f2:	69ea      	ldr	r2, [r5, #28]
    30f4:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    30f8:	448c      	add	ip, r1
    30fa:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    30fe:	49a5      	ldr	r1, [pc, #660]	; (3394 <loop+0xa4c>)
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    3100:	fba7 7a08 	umull	r7, sl, r7, r8
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    3104:	fb00 331e 	mls	r3, r0, lr, r3
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    3108:	ea4f 1a9a 	mov.w	sl, sl, lsr #6
    310c:	3a01      	subs	r2, #1
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    310e:	fb01 c303 	mla	r3, r1, r3, ip
    3112:	fb00 801a 	mls	r0, r0, sl, r8
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    3116:	4472      	add	r2, lr
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    3118:	fb01 3310 	mls	r3, r1, r0, r3
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    311c:	ebca 0202 	rsb	r2, sl, r2
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    normalizeSecNSec(sec_offset, nsec_offset);
    3120:	f109 0114 	add.w	r1, r9, #20
    3124:	f109 0010 	add.w	r0, r9, #16

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    3128:	616b      	str	r3, [r5, #20]
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    312a:	612a      	str	r2, [r5, #16]
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    normalizeSecNSec(sec_offset, nsec_offset);
    312c:	f003 f972 	bl	6414 <ros::normalizeSecNSec(unsigned long&, unsigned long&)>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3130:	6833      	ldr	r3, [r6, #0]
    3132:	930f      	str	r3, [sp, #60]	; 0x3c
	return ret;
    3134:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    t.deserialize(data);
    t.data.sec += offset / 1000;
    t.data.nsec += (offset % 1000) * 1000000UL;

    this->setNow(t.data);
    last_sync_receive_time = hardware_.time();
    3136:	f8c5 3500 	str.w	r3, [r5, #1280]	; 0x500
    313a:	e433      	b.n	29a4 <loop+0x5c>
    {
      int offset = 0;
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    313c:	f8d5 801c 	ldr.w	r8, [r5, #28]
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
    3140:	f8d5 3510 	ldr.w	r3, [r5, #1296]	; 0x510
    3144:	4598      	cmp	r8, r3
    3146:	d907      	bls.n	3158 <loop+0x810>
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
    3148:	ea4f 0188 	mov.w	r1, r8, lsl #2
    314c:	f8d5 0518 	ldr.w	r0, [r5, #1304]	; 0x518
    3150:	f007 ff24 	bl	af9c <realloc>
    3154:	f8c5 0518 	str.w	r0, [r5, #1304]	; 0x518
      ints_length = ints_lengthT;
    3158:	f8c4 8510 	str.w	r8, [r4, #1296]	; 0x510
      for( uint32_t i = 0; i < ints_length; i++){
    315c:	f1b8 0f00 	cmp.w	r8, #0
    3160:	f000 80f4 	beq.w	334c <loop+0xa04>
    3164:	f8df 8250 	ldr.w	r8, [pc, #592]	; 33b8 <loop+0xa70>
    3168:	f04f 0904 	mov.w	r9, #4
    316c:	f04f 0a00 	mov.w	sl, #0
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
    3170:	f898 1022 	ldrb.w	r1, [r8, #34]	; 0x22
    3174:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
    3178:	f898 2020 	ldrb.w	r2, [r8, #32]
    317c:	f898 e023 	ldrb.w	lr, [r8, #35]	; 0x23
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
    3180:	f8d4 0518 	ldr.w	r0, [r4, #1304]	; 0x518
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
    3184:	0409      	lsls	r1, r1, #16
    3186:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
    318a:	4313      	orrs	r3, r2
    318c:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
    3190:	eb00 008a 	add.w	r0, r0, sl, lsl #2
    3194:	4980      	ldr	r1, [pc, #512]	; (3398 <loop+0xa50>)
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
    3196:	f8c4 3514 	str.w	r3, [r4, #1300]	; 0x514
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
    319a:	2204      	movs	r2, #4
    319c:	f003 f94e 	bl	643c <memcpy>
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
      ints_length = ints_lengthT;
      for( uint32_t i = 0; i < ints_length; i++){
    31a0:	f8d4 3510 	ldr.w	r3, [r4, #1296]	; 0x510
    31a4:	f10a 0a01 	add.w	sl, sl, #1
    31a8:	4553      	cmp	r3, sl
    31aa:	4649      	mov	r1, r9
    31ac:	f108 0804 	add.w	r8, r8, #4
    31b0:	f109 0904 	add.w	r9, r9, #4
    31b4:	d8dc      	bhi.n	3170 <loop+0x828>
    31b6:	f101 0a08 	add.w	sl, r1, #8
    31ba:	f101 0e05 	add.w	lr, r1, #5
    31be:	f101 0c06 	add.w	ip, r1, #6
    31c2:	f101 0807 	add.w	r8, r1, #7
    31c6:	f101 0309 	add.w	r3, r1, #9
    31ca:	f101 020a 	add.w	r2, r1, #10
    31ce:	f101 070b 	add.w	r7, r1, #11
    31d2:	310c      	adds	r1, #12
    31d4:	4648      	mov	r0, r9
    31d6:	9100      	str	r1, [sp, #0]
    31d8:	46d1      	mov	r9, sl
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    31da:	44a4      	add	ip, r4
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
    31dc:	44a6      	add	lr, r4
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    31de:	f89c c01c 	ldrb.w	ip, [ip, #28]
    31e2:	f89e 101c 	ldrb.w	r1, [lr, #28]
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    31e6:	4420      	add	r0, r4
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    31e8:	44a0      	add	r8, r4
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    31ea:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    31ee:	7f00      	ldrb	r0, [r0, #28]
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    31f0:	f898 e01c 	ldrb.w	lr, [r8, #28]
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    31f4:	ea4c 2c01 	orr.w	ip, ip, r1, lsl #8
    31f8:	ea4c 0c00 	orr.w	ip, ip, r0
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
    31fc:	f8d4 151c 	ldr.w	r1, [r4, #1308]	; 0x51c
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    3200:	ea4c 680e 	orr.w	r8, ip, lr, lsl #24
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
    3204:	4588      	cmp	r8, r1
    3206:	d90b      	bls.n	3220 <loop+0x8d8>
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
    3208:	ea4f 0188 	mov.w	r1, r8, lsl #2
    320c:	f8d5 0524 	ldr.w	r0, [r5, #1316]	; 0x524
    3210:	9205      	str	r2, [sp, #20]
    3212:	9302      	str	r3, [sp, #8]
    3214:	f007 fec2 	bl	af9c <realloc>
    3218:	9a05      	ldr	r2, [sp, #20]
    321a:	9b02      	ldr	r3, [sp, #8]
    321c:	f8c5 0524 	str.w	r0, [r5, #1316]	; 0x524
      floats_length = floats_lengthT;
    3220:	f8c4 851c 	str.w	r8, [r4, #1308]	; 0x51c
      for( uint32_t i = 0; i < floats_length; i++){
    3224:	f1b8 0f00 	cmp.w	r8, #0
    3228:	f000 808d 	beq.w	3346 <loop+0x9fe>
    322c:	eb05 0a09 	add.w	sl, r5, r9
    3230:	f04f 0800 	mov.w	r8, #0
      } u_st_floats;
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    3234:	f89a 101e 	ldrb.w	r1, [sl, #30]
    3238:	f89a 301d 	ldrb.w	r3, [sl, #29]
    323c:	f89a 201c 	ldrb.w	r2, [sl, #28]
    3240:	f89a e01f 	ldrb.w	lr, [sl, #31]
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    3244:	f8d4 0524 	ldr.w	r0, [r4, #1316]	; 0x524
      } u_st_floats;
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    3248:	0409      	lsls	r1, r1, #16
    324a:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
    324e:	4313      	orrs	r3, r2
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    3250:	4952      	ldr	r1, [pc, #328]	; (339c <loop+0xa54>)
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
    3252:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
    3256:	600b      	str	r3, [r1, #0]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    3258:	eb00 0088 	add.w	r0, r0, r8, lsl #2
    325c:	2204      	movs	r2, #4
    325e:	f003 f8ed 	bl	643c <memcpy>
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
      floats_length = floats_lengthT;
      for( uint32_t i = 0; i < floats_length; i++){
    3262:	f8d4 351c 	ldr.w	r3, [r4, #1308]	; 0x51c
    3266:	f108 0801 	add.w	r8, r8, #1
    326a:	4543      	cmp	r3, r8
    326c:	4649      	mov	r1, r9
    326e:	f10a 0a04 	add.w	sl, sl, #4
    3272:	f109 0904 	add.w	r9, r9, #4
    3276:	d8dd      	bhi.n	3234 <loop+0x8ec>
    3278:	1dc8      	adds	r0, r1, #7
    327a:	46ca      	mov	sl, r9
    327c:	1d4b      	adds	r3, r1, #5
    327e:	1d8a      	adds	r2, r1, #6
    3280:	4607      	mov	r7, r0
    3282:	f101 0808 	add.w	r8, r1, #8
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    3286:	4422      	add	r2, r4
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
    3288:	4423      	add	r3, r4
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    328a:	7f11      	ldrb	r1, [r2, #28]
    328c:	7f18      	ldrb	r0, [r3, #28]
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
    328e:	f8d4 3528 	ldr.w	r3, [r4, #1320]	; 0x528
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    3292:	463a      	mov	r2, r7
    3294:	4422      	add	r2, r4
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    3296:	44a2      	add	sl, r4
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    3298:	4696      	mov	lr, r2
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    329a:	0409      	lsls	r1, r1, #16
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    329c:	f89a 201c 	ldrb.w	r2, [sl, #28]
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    32a0:	f89e 901c 	ldrb.w	r9, [lr, #28]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    32a4:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
    32a8:	430a      	orrs	r2, r1
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    32aa:	ea42 6909 	orr.w	r9, r2, r9, lsl #24
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
    32ae:	4599      	cmp	r9, r3
    32b0:	d907      	bls.n	32c2 <loop+0x97a>
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
    32b2:	ea4f 0189 	mov.w	r1, r9, lsl #2
    32b6:	f8d5 0530 	ldr.w	r0, [r5, #1328]	; 0x530
    32ba:	f007 fe6f 	bl	af9c <realloc>
    32be:	f8c5 0530 	str.w	r0, [r5, #1328]	; 0x530
      strings_length = strings_lengthT;
    32c2:	f8c4 9528 	str.w	r9, [r4, #1320]	; 0x528
      for( uint32_t i = 0; i < strings_length; i++){
    32c6:	f1b9 0f00 	cmp.w	r9, #0
    32ca:	d037      	beq.n	333c <loop+0x9f4>
    32cc:	f04f 0a00 	mov.w	sl, #0
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    32d0:	46d1      	mov	r9, sl
    32d2:	f108 011c 	add.w	r1, r8, #28
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
      uint32_t length_st_strings;
      arrToVar(length_st_strings, (inbuffer + offset));
    32d6:	2300      	movs	r3, #0
    32d8:	4421      	add	r1, r4

  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    32da:	469e      	mov	lr, r3
    for (size_t i = 0; i < sizeof(V); i++)
      var |= (arr[i] << (8 * i));
    32dc:	f811 2b01 	ldrb.w	r2, [r1], #1
    32e0:	409a      	lsls	r2, r3
    32e2:	3308      	adds	r3, #8
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
    32e4:	2b20      	cmp	r3, #32
      var |= (arr[i] << (8 * i));
    32e6:	ea4e 0e02 	orr.w	lr, lr, r2
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
    32ea:	d1f7      	bne.n	32dc <loop+0x994>
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
    32ec:	f108 0004 	add.w	r0, r8, #4
    32f0:	4486      	add	lr, r0
    32f2:	4586      	cmp	lr, r0
    32f4:	d909      	bls.n	330a <loop+0x9c2>
    32f6:	f108 031f 	add.w	r3, r8, #31
    32fa:	4423      	add	r3, r4
    32fc:	4602      	mov	r2, r0
    32fe:	3201      	adds	r2, #1
          inbuffer[k-1]=inbuffer[k];
    3300:	7859      	ldrb	r1, [r3, #1]
    3302:	f803 1b01 	strb.w	r1, [r3], #1
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
      uint32_t length_st_strings;
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
    3306:	4596      	cmp	lr, r2
    3308:	d8f9      	bhi.n	32fe <loop+0x9b6>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    330a:	eb04 020e 	add.w	r2, r4, lr
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    330e:	4924      	ldr	r1, [pc, #144]	; (33a0 <loop+0xa58>)
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    3310:	f882 901b 	strb.w	r9, [r2, #27]
      this->st_strings = (char *)(inbuffer + offset-1);
    3314:	1e43      	subs	r3, r0, #1
    3316:	f5a1 62a2 	sub.w	r2, r1, #1296	; 0x510
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    331a:	f8d4 0530 	ldr.w	r0, [r4, #1328]	; 0x530
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
    331e:	4413      	add	r3, r2
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    3320:	eb00 008a 	add.w	r0, r0, sl, lsl #2
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
    3324:	f8c4 352c 	str.w	r3, [r4, #1324]	; 0x52c
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    3328:	2204      	movs	r2, #4
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
    332a:	46f0      	mov	r8, lr
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    332c:	f003 f886 	bl	643c <memcpy>
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
    3330:	f8d4 3528 	ldr.w	r3, [r4, #1320]	; 0x528
    3334:	f10a 0a01 	add.w	sl, sl, #1
    3338:	4553      	cmp	r3, sl
    333a:	d8ca      	bhi.n	32d2 <loop+0x98a>
            syncTime(message_in);
          }
          else if (topic_ == TopicInfo::ID_PARAMETER_REQUEST)
          {
            req_param_resp.deserialize(message_in);
            param_received = true;
    333c:	2301      	movs	r3, #1
    333e:	f884 3508 	strb.w	r3, [r4, #1288]	; 0x508
    3342:	f7ff bb2f 	b.w	29a4 <loop+0x5c>
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
      floats_length = floats_lengthT;
      for( uint32_t i = 0; i < floats_length; i++){
    3346:	f8dd 8000 	ldr.w	r8, [sp]
    334a:	e79c      	b.n	3286 <loop+0x93e>
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
      ints_length = ints_lengthT;
      for( uint32_t i = 0; i < ints_length; i++){
    334c:	230c      	movs	r3, #12
    334e:	f04f 0a08 	mov.w	sl, #8
    3352:	9300      	str	r3, [sp, #0]
    3354:	230b      	movs	r3, #11
    3356:	461f      	mov	r7, r3
    3358:	46d1      	mov	r9, sl
    335a:	220a      	movs	r2, #10
    335c:	2309      	movs	r3, #9
    335e:	f04f 0807 	mov.w	r8, #7
    3362:	f04f 0c06 	mov.w	ip, #6
    3366:	f04f 0e05 	mov.w	lr, #5
    336a:	2004      	movs	r0, #4
    336c:	e735      	b.n	31da <loop+0x892>
    336e:	bf00      	nop
    3370:	a0b5ed8d 	.word	0xa0b5ed8d
    3374:	3eb0c6f7 	.word	0x3eb0c6f7
    3378:	1fff1c90 	.word	0x1fff1c90
    337c:	1fff1480 	.word	0x1fff1480
    3380:	1fff14a0 	.word	0x1fff14a0
    3384:	1fff1d10 	.word	0x1fff1d10
    3388:	1fff2a90 	.word	0x1fff2a90
    338c:	1fff1f80 	.word	0x1fff1f80
    3390:	10624dd3 	.word	0x10624dd3
    3394:	000f4240 	.word	0x000f4240
    3398:	1fff2278 	.word	0x1fff2278
    339c:	1fff2284 	.word	0x1fff2284
    33a0:	1fff2290 	.word	0x1fff2290
    33a4:	1fff2b94 	.word	0x1fff2b94
    33a8:	1fff2b9c 	.word	0x1fff2b9c
    33ac:	1fff148c 	.word	0x1fff148c
    33b0:	1fff2b78 	.word	0x1fff2b78
    33b4:	3b9aca00 	.word	0x3b9aca00
    33b8:	1fff1d64 	.word	0x1fff1d64
    33bc:	469a      	mov	sl, r3
  {
    if (id >= 100 && !configured_)
      return 0;

    /* serialize message */
    int l = msg->serialize(message_out + 7);
    33be:	f209 2123 	addw	r1, r9, #547	; 0x223
    public:
      typedef ros::Time _data_type;
      _data_type data;

    Time():
      data()
    33c2:	4b74      	ldr	r3, [pc, #464]	; (3594 <loop+0xc4c>)
    33c4:	9311      	str	r3, [sp, #68]	; 0x44
    33c6:	a811      	add	r0, sp, #68	; 0x44
    33c8:	4690      	mov	r8, r2
class Time
{
public:
  uint32_t sec, nsec;

  Time() : sec(0), nsec(0) {}
    33ca:	f8cd a048 	str.w	sl, [sp, #72]	; 0x48
    33ce:	f8cd a04c 	str.w	sl, [sp, #76]	; 0x4c
    33d2:	f7fd f84b 	bl	46c <std_msgs::Time::serialize(unsigned char*) const>

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    33d6:	b2c2      	uxtb	r2, r0
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    33d8:	f3c0 2107 	ubfx	r1, r0, #8, #8
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    33dc:	1853      	adds	r3, r2, r1
    33de:	43db      	mvns	r3, r3
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    33e0:	f889 221e 	strb.w	r2, [r9, #542]	; 0x21e
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    33e4:	25fe      	movs	r5, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    33e6:	220a      	movs	r2, #10
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    33e8:	1c47      	adds	r7, r0, #1

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    33ea:	f889 821c 	strb.w	r8, [r9, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    33ee:	f889 a222 	strb.w	sl, [r9, #546]	; 0x222
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    33f2:	f889 3220 	strb.w	r3, [r9, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    33f6:	f889 121f 	strb.w	r1, [r9, #543]	; 0x21f
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    33fa:	f889 521d 	strb.w	r5, [r9, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    33fe:	f889 2221 	strb.w	r2, [r9, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3402:	db0f      	blt.n	3424 <loop+0xadc>
    3404:	f200 2122 	addw	r1, r0, #546	; 0x222
    3408:	4449      	add	r1, r9
    340a:	4653      	mov	r3, sl
    340c:	f209 2921 	addw	r9, r9, #545	; 0x221
    3410:	e001      	b.n	3416 <loop+0xace>
    3412:	f819 2f01 	ldrb.w	r2, [r9, #1]!
    3416:	4589      	cmp	r9, r1
      chk += message_out[i];
    3418:	4413      	add	r3, r2
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    341a:	d1fa      	bne.n	3412 <loop+0xaca>
    341c:	ea6f 0803 	mvn.w	r8, r3
    3420:	fa5f f888 	uxtb.w	r8, r8
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3424:	1823      	adds	r3, r4, r0
    3426:	f100 0208 	add.w	r2, r0, #8

    if (l <= OUTPUT_SIZE)
    342a:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    342e:	f883 8223 	strb.w	r8, [r3, #547]	; 0x223
    3432:	4959      	ldr	r1, [pc, #356]	; (3598 <loop+0xc50>)

    if (l <= OUTPUT_SIZE)
    3434:	f300 824d 	bgt.w	38d2 <loop+0xf8a>
    3438:	6848      	ldr	r0, [r1, #4]
    343a:	6803      	ldr	r3, [r0, #0]
    343c:	f501 7107 	add.w	r1, r1, #540	; 0x21c
    3440:	685b      	ldr	r3, [r3, #4]
    3442:	4798      	blx	r3
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3444:	6833      	ldr	r3, [r6, #0]
    3446:	930a      	str	r3, [sp, #40]	; 0x28
    3448:	4e54      	ldr	r6, [pc, #336]	; (359c <loop+0xc54>)
	return ret;
    344a:	9b0a      	ldr	r3, [sp, #40]	; 0x28

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    rt_time = hardware_.time();
    344c:	60e3      	str	r3, [r4, #12]
    344e:	f106 0364 	add.w	r3, r6, #100	; 0x64
    3452:	9300      	str	r3, [sp, #0]
      memcpy(outbuffer + offset, this->message_type, length_message_type);
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    3454:	f5a6 6583 	sub.w	r5, r6, #1048	; 0x418
  {
    rosserial_msgs::TopicInfo ti;
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
    3458:	f856 3f04 	ldr.w	r3, [r6, #4]!
    345c:	2b00      	cmp	r3, #0
    345e:	f000 80c1 	beq.w	35e4 <loop+0xc9c>
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    3462:	6858      	ldr	r0, [r3, #4]
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
    3464:	689a      	ldr	r2, [r3, #8]
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    3466:	6801      	ldr	r1, [r0, #0]
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
    3468:	9202      	str	r2, [sp, #8]
        ti.topic_name = (char *) publishers[i]->topic_;
    346a:	f8d3 a000 	ldr.w	sl, [r3]
        ti.message_type = (char *) publishers[i]->msg_->getType();
    346e:	688b      	ldr	r3, [r1, #8]
    3470:	4798      	blx	r3
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    3472:	6833      	ldr	r3, [r6, #0]
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    3474:	4681      	mov	r9, r0
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    3476:	6858      	ldr	r0, [r3, #4]
    3478:	6803      	ldr	r3, [r0, #0]
    347a:	68db      	ldr	r3, [r3, #12]
    347c:	4798      	blx	r3
    347e:	6833      	ldr	r3, [r6, #0]
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    3480:	9a02      	ldr	r2, [sp, #8]
    3482:	691f      	ldr	r7, [r3, #16]
    3484:	2f63      	cmp	r7, #99	; 0x63
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    3486:	4680      	mov	r8, r0
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    3488:	dd04      	ble.n	3494 <loop+0xb4c>
    348a:	f894 34f8 	ldrb.w	r3, [r4, #1272]	; 0x4f8
    348e:	2b00      	cmp	r3, #0
    3490:	f000 80a8 	beq.w	35e4 <loop+0xc9c>

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    3494:	f3c2 2307 	ubfx	r3, r2, #8, #8
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    3498:	f884 2223 	strb.w	r2, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    349c:	f884 3224 	strb.w	r3, [r4, #548]	; 0x224
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    34a0:	4650      	mov	r0, sl
    34a2:	f008 f96d 	bl	b780 <strlen>
    34a6:	4603      	mov	r3, r0
  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
      arr[i] = (var >> (8 * i));
    34a8:	ea4f 6e13 	mov.w	lr, r3, lsr #24
    34ac:	0a02      	lsrs	r2, r0, #8
    34ae:	0c00      	lsrs	r0, r0, #16
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
    34b0:	4651      	mov	r1, sl
    34b2:	f884 3225 	strb.w	r3, [r4, #549]	; 0x225
    34b6:	f884 2226 	strb.w	r2, [r4, #550]	; 0x226
    34ba:	f884 0227 	strb.w	r0, [r4, #551]	; 0x227
    34be:	461a      	mov	r2, r3
    34c0:	f884 e228 	strb.w	lr, [r4, #552]	; 0x228
    34c4:	4836      	ldr	r0, [pc, #216]	; (35a0 <loop+0xc58>)
    34c6:	9302      	str	r3, [sp, #8]
    34c8:	f002 ffb8 	bl	643c <memcpy>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
    34cc:	4648      	mov	r0, r9
    34ce:	f008 f957 	bl	b780 <strlen>
    34d2:	9b02      	ldr	r3, [sp, #8]
    34d4:	4602      	mov	r2, r0
    34d6:	f203 2029 	addw	r0, r3, #553	; 0x229
    34da:	4420      	add	r0, r4
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
    34dc:	3306      	adds	r3, #6
      uint32_t length_message_type = strlen(this->message_type);
    34de:	2100      	movs	r1, #0
    34e0:	fa22 fe01 	lsr.w	lr, r2, r1
    34e4:	3108      	adds	r1, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    34e6:	2920      	cmp	r1, #32
      arr[i] = (var >> (8 * i));
    34e8:	f800 eb01 	strb.w	lr, [r0], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    34ec:	d1f8      	bne.n	34e0 <loop+0xb98>
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    34ee:	482d      	ldr	r0, [pc, #180]	; (35a4 <loop+0xc5c>)
    34f0:	3304      	adds	r3, #4
    34f2:	4649      	mov	r1, r9
    34f4:	4418      	add	r0, r3
      offset += length_message_type;
    34f6:	eb02 0903 	add.w	r9, r2, r3
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    34fa:	f002 ff9f 	bl	643c <memcpy>
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
    34fe:	4640      	mov	r0, r8
    3500:	f008 f93e 	bl	b780 <strlen>
    3504:	f209 2223 	addw	r2, r9, #547	; 0x223
    3508:	4682      	mov	sl, r0
    350a:	4422      	add	r2, r4
    350c:	2300      	movs	r3, #0
      arr[i] = (var >> (8 * i));
    350e:	fa2a f103 	lsr.w	r1, sl, r3
    3512:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3514:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
    3516:	f802 1b01 	strb.w	r1, [r2], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    351a:	d1f8      	bne.n	350e <loop+0xbc6>
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    351c:	4b21      	ldr	r3, [pc, #132]	; (35a4 <loop+0xc5c>)
    351e:	f109 0904 	add.w	r9, r9, #4
    3522:	4641      	mov	r1, r8
    3524:	eb03 0009 	add.w	r0, r3, r9
    3528:	4652      	mov	r2, sl
    352a:	f002 ff87 	bl	643c <memcpy>
      offset += length_md5sum;
    352e:	eb0a 0009 	add.w	r0, sl, r9
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
    3532:	f100 0e04 	add.w	lr, r0, #4
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    3536:	1821      	adds	r1, r4, r0
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3538:	fa5f f88e 	uxtb.w	r8, lr
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    353c:	f3ce 2c07 	ubfx	ip, lr, #8, #8
    3540:	2200      	movs	r2, #0
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    3542:	2302      	movs	r3, #2
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3544:	eb08 0a0c 	add.w	sl, r8, ip
    3548:	f881 3224 	strb.w	r3, [r1, #548]	; 0x224
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    354c:	f881 2223 	strb.w	r2, [r1, #547]	; 0x223
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
    3550:	f881 2225 	strb.w	r2, [r1, #549]	; 0x225
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
    3554:	f881 2226 	strb.w	r2, [r1, #550]	; 0x226
    3558:	ea6f 0a0a 	mvn.w	sl, sl
    message_out[5] = (uint8_t)((int16_t)id & 255);
    355c:	b2f9      	uxtb	r1, r7

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    355e:	23ff      	movs	r3, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    3560:	f04f 09fe 	mov.w	r9, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3564:	f347 2707 	sbfx	r7, r7, #8, #8

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3568:	f1be 3fff 	cmp.w	lr, #4294967295	; 0xffffffff
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    356c:	f884 a220 	strb.w	sl, [r4, #544]	; 0x220
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3570:	f884 821e 	strb.w	r8, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3574:	f884 c21f 	strb.w	ip, [r4, #543]	; 0x21f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3578:	f884 321c 	strb.w	r3, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    357c:	f884 921d 	strb.w	r9, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3580:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3584:	f884 7222 	strb.w	r7, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3588:	db17      	blt.n	35ba <loop+0xc72>
    358a:	f200 2026 	addw	r0, r0, #550	; 0x226
    358e:	4b06      	ldr	r3, [pc, #24]	; (35a8 <loop+0xc60>)
    3590:	4428      	add	r0, r5
    3592:	e00d      	b.n	35b0 <loop+0xc68>
    3594:	0000bc24 	.word	0x0000bc24
    3598:	1fff1d64 	.word	0x1fff1d64
    359c:	1fff217c 	.word	0x1fff217c
    35a0:	1fff1f8d 	.word	0x1fff1f8d
    35a4:	1fff1f87 	.word	0x1fff1f87
    35a8:	1fff1f85 	.word	0x1fff1f85
    35ac:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    35b0:	4283      	cmp	r3, r0
      chk += message_out[i];
    35b2:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    35b4:	d1fa      	bne.n	35ac <loop+0xc64>
    35b6:	43d3      	mvns	r3, r2
    35b8:	b2db      	uxtb	r3, r3
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    35ba:	eb04 010e 	add.w	r1, r4, lr
    35be:	f10e 0208 	add.w	r2, lr, #8

    if (l <= OUTPUT_SIZE)
    35c2:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    35c6:	f881 3223 	strb.w	r3, [r1, #547]	; 0x223

    if (l <= OUTPUT_SIZE)
    35ca:	f300 80f8 	bgt.w	37be <loop+0xe76>
    35ce:	6868      	ldr	r0, [r5, #4]
    35d0:	49c3      	ldr	r1, [pc, #780]	; (38e0 <loop+0xf98>)
    35d2:	6803      	ldr	r3, [r0, #0]
    35d4:	685b      	ldr	r3, [r3, #4]
    35d6:	428b      	cmp	r3, r1
    35d8:	f040 80ea 	bne.w	37b0 <loop+0xe68>
    35dc:	4611      	mov	r1, r2
    35de:	48c1      	ldr	r0, [pc, #772]	; (38e4 <loop+0xf9c>)
    35e0:	f004 fa44 	bl	7a6c <usb_serial_write>

  void negotiateTopics()
  {
    rosserial_msgs::TopicInfo ti;
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    35e4:	9b00      	ldr	r3, [sp, #0]
    35e6:	429e      	cmp	r6, r3
    35e8:	f47f af36 	bne.w	3458 <loop+0xb10>
    35ec:	f8df a320 	ldr.w	sl, [pc, #800]	; 3910 <loop+0xfc8>
    35f0:	f8cd b008 	str.w	fp, [sp, #8]
    35f4:	469b      	mov	fp, r3
        publish(publishers[i]->getEndpointType(), &ti);
      }
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
    35f6:	f85b 0f04 	ldr.w	r0, [fp, #4]!
    35fa:	2800      	cmp	r0, #0
    35fc:	f000 80be 	beq.w	377c <loop+0xe34>
      {
        ti.topic_id = subscribers[i]->id_;
    3600:	e890 0208 	ldmia.w	r0, {r3, r9}
    3604:	49b8      	ldr	r1, [pc, #736]	; (38e8 <loop+0xfa0>)
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
    3606:	689a      	ldr	r2, [r3, #8]
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
    3608:	f8d0 8008 	ldr.w	r8, [r0, #8]
    360c:	428a      	cmp	r2, r1
    360e:	f000 80cd 	beq.w	37ac <loop+0xe64>
        ti.message_type = (char *) subscribers[i]->getMsgType();
    3612:	4790      	blx	r2
    3614:	4607      	mov	r7, r0
    3616:	f8db 0000 	ldr.w	r0, [fp]
    361a:	6803      	ldr	r3, [r0, #0]
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
    361c:	68da      	ldr	r2, [r3, #12]
    361e:	49b3      	ldr	r1, [pc, #716]	; (38ec <loop+0xfa4>)
    3620:	428a      	cmp	r2, r1
    3622:	f000 80c1 	beq.w	37a8 <loop+0xe60>
    3626:	4790      	blx	r2
    3628:	4606      	mov	r6, r0
    362a:	f8db 0000 	ldr.w	r0, [fp]
    362e:	6803      	ldr	r3, [r0, #0]
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
    3630:	685b      	ldr	r3, [r3, #4]
    3632:	4aaf      	ldr	r2, [pc, #700]	; (38f0 <loop+0xfa8>)
    3634:	4293      	cmp	r3, r2
    3636:	f040 80b4 	bne.w	37a2 <loop+0xe5a>
  {
    return this->msg.getMD5();
  }
  virtual int getEndpointType() override
  {
    return endpoint_;
    363a:	6dc5      	ldr	r5, [r0, #92]	; 0x5c
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    363c:	2d63      	cmp	r5, #99	; 0x63
    363e:	dd04      	ble.n	364a <loop+0xd02>
    3640:	f894 34f8 	ldrb.w	r3, [r4, #1272]	; 0x4f8
    3644:	2b00      	cmp	r3, #0
    3646:	f000 8099 	beq.w	377c <loop+0xe34>

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    364a:	f3c9 2307 	ubfx	r3, r9, #8, #8
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    364e:	4640      	mov	r0, r8
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    3650:	f884 9223 	strb.w	r9, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    3654:	f884 3224 	strb.w	r3, [r4, #548]	; 0x224
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    3658:	f008 f892 	bl	b780 <strlen>
    365c:	4681      	mov	r9, r0
      arr[i] = (var >> (8 * i));
    365e:	ea4f 6319 	mov.w	r3, r9, lsr #24
    3662:	0a02      	lsrs	r2, r0, #8
    3664:	0c00      	lsrs	r0, r0, #16
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
    3666:	4641      	mov	r1, r8
    3668:	f884 3228 	strb.w	r3, [r4, #552]	; 0x228
    366c:	f884 2226 	strb.w	r2, [r4, #550]	; 0x226
    3670:	f884 0227 	strb.w	r0, [r4, #551]	; 0x227
    3674:	464a      	mov	r2, r9
    3676:	f884 9225 	strb.w	r9, [r4, #549]	; 0x225
    367a:	489e      	ldr	r0, [pc, #632]	; (38f4 <loop+0xfac>)
    367c:	f002 fede 	bl	643c <memcpy>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
    3680:	4638      	mov	r0, r7
    3682:	f008 f87d 	bl	b780 <strlen>
    3686:	f209 2129 	addw	r1, r9, #553	; 0x229
    368a:	4602      	mov	r2, r0
    368c:	4421      	add	r1, r4
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
    368e:	f109 0806 	add.w	r8, r9, #6
      uint32_t length_message_type = strlen(this->message_type);
    3692:	2300      	movs	r3, #0
    3694:	fa22 f003 	lsr.w	r0, r2, r3
    3698:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    369a:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
    369c:	f801 0b01 	strb.w	r0, [r1], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    36a0:	d1f8      	bne.n	3694 <loop+0xd4c>
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    36a2:	4b95      	ldr	r3, [pc, #596]	; (38f8 <loop+0xfb0>)
    36a4:	f108 0804 	add.w	r8, r8, #4
    36a8:	eb03 0008 	add.w	r0, r3, r8
    36ac:	4639      	mov	r1, r7
      offset += length_message_type;
    36ae:	4490      	add	r8, r2
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    36b0:	f002 fec4 	bl	643c <memcpy>
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
    36b4:	4630      	mov	r0, r6
    36b6:	f008 f863 	bl	b780 <strlen>
    36ba:	f208 2223 	addw	r2, r8, #547	; 0x223
    36be:	4607      	mov	r7, r0
    36c0:	4422      	add	r2, r4
    36c2:	2300      	movs	r3, #0
      arr[i] = (var >> (8 * i));
    36c4:	fa27 f103 	lsr.w	r1, r7, r3
    36c8:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    36ca:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
    36cc:	f802 1b01 	strb.w	r1, [r2], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    36d0:	d1f8      	bne.n	36c4 <loop+0xd7c>
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    36d2:	4b89      	ldr	r3, [pc, #548]	; (38f8 <loop+0xfb0>)
    36d4:	f108 0804 	add.w	r8, r8, #4
    36d8:	463a      	mov	r2, r7
      offset += length_md5sum;
    36da:	4447      	add	r7, r8
      memcpy(outbuffer + offset, this->message_type, length_message_type);
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    36dc:	4631      	mov	r1, r6
    36de:	eb03 0008 	add.w	r0, r3, r8
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
    36e2:	1d3e      	adds	r6, r7, #4
      memcpy(outbuffer + offset, this->message_type, length_message_type);
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    36e4:	f002 feaa 	bl	643c <memcpy>
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    36e8:	fa5f fc86 	uxtb.w	ip, r6
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    36ec:	f3c6 2e07 	ubfx	lr, r6, #8, #8
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    36f0:	19e3      	adds	r3, r4, r7
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    36f2:	eb0c 000e 	add.w	r0, ip, lr
    36f6:	2200      	movs	r2, #0
    36f8:	43c0      	mvns	r0, r0
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    36fa:	2102      	movs	r1, #2
    36fc:	f883 1224 	strb.w	r1, [r3, #548]	; 0x224
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    3700:	f883 2223 	strb.w	r2, [r3, #547]	; 0x223
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
    3704:	f883 2225 	strb.w	r2, [r3, #549]	; 0x225
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
    3708:	f883 2226 	strb.w	r2, [r3, #550]	; 0x226
    370c:	f884 0220 	strb.w	r0, [r4, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3710:	b2e8      	uxtb	r0, r5
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3712:	f345 2507 	sbfx	r5, r5, #8, #8
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    3716:	23fe      	movs	r3, #254	; 0xfe

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3718:	21ff      	movs	r1, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    371a:	f884 5222 	strb.w	r5, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    371e:	1c75      	adds	r5, r6, #1
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    3720:	f884 321d 	strb.w	r3, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3724:	f884 c21e 	strb.w	ip, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3728:	f884 e21f 	strb.w	lr, [r4, #543]	; 0x21f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    372c:	f884 121c 	strb.w	r1, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3730:	f884 0221 	strb.w	r0, [r4, #545]	; 0x221
      memcpy(outbuffer + offset, this->message_type, length_message_type);
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    3734:	4b71      	ldr	r3, [pc, #452]	; (38fc <loop+0xfb4>)
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3736:	f2c0 80d0 	blt.w	38da <loop+0xf92>
    373a:	f207 2126 	addw	r1, r7, #550	; 0x226
    373e:	4419      	add	r1, r3
    3740:	f203 2321 	addw	r3, r3, #545	; 0x221
    3744:	e001      	b.n	374a <loop+0xe02>
    3746:	f813 0f01 	ldrb.w	r0, [r3, #1]!
    374a:	4299      	cmp	r1, r3
      chk += message_out[i];
    374c:	4402      	add	r2, r0
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    374e:	d1fa      	bne.n	3746 <loop+0xdfe>
    3750:	43d3      	mvns	r3, r2
    3752:	b2db      	uxtb	r3, r3
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3754:	19a1      	adds	r1, r4, r6
    3756:	f106 0208 	add.w	r2, r6, #8

    if (l <= OUTPUT_SIZE)
    375a:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    375e:	f881 3223 	strb.w	r3, [r1, #547]	; 0x223
    3762:	4f66      	ldr	r7, [pc, #408]	; (38fc <loop+0xfb4>)

    if (l <= OUTPUT_SIZE)
    3764:	dc72      	bgt.n	384c <loop+0xf04>
    3766:	6878      	ldr	r0, [r7, #4]
    3768:	495d      	ldr	r1, [pc, #372]	; (38e0 <loop+0xf98>)
    376a:	6803      	ldr	r3, [r0, #0]
    376c:	685b      	ldr	r3, [r3, #4]
    376e:	428b      	cmp	r3, r1
    3770:	d121      	bne.n	37b6 <loop+0xe6e>
    3772:	4611      	mov	r1, r2
    3774:	f507 7007 	add.w	r0, r7, #540	; 0x21c
    3778:	f004 f978 	bl	7a6c <usb_serial_write>
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
        ti.buffer_size = OUTPUT_SIZE;
        publish(publishers[i]->getEndpointType(), &ti);
      }
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    377c:	45d3      	cmp	fp, sl
    377e:	f47f af3a 	bne.w	35f6 <loop+0xcae>
    3782:	f8dd b008 	ldr.w	fp, [sp, #8]
        {
          if (topic_ == TopicInfo::ID_PUBLISHER)
          {
            requestSyncTime();
            negotiateTopics();
            last_sync_time = c_time;
    3786:	f8c4 b4fc 	str.w	fp, [r4, #1276]	; 0x4fc
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
      }
    }
    configured_ = true;
    378a:	2301      	movs	r3, #1
          if (topic_ == TopicInfo::ID_PUBLISHER)
          {
            requestSyncTime();
            negotiateTopics();
            last_sync_time = c_time;
            last_sync_receive_time = c_time;
    378c:	f8c4 b500 	str.w	fp, [r4, #1280]	; 0x500
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
      }
    }
    configured_ = true;
    3790:	f884 34f8 	strb.w	r3, [r4, #1272]	; 0x4f8
    3794:	f7ff b935 	b.w	2a02 <loop+0xba>
            configured_ = false;
          }
          else
          {
            if (subscribers[topic_ - 100])
              subscribers[topic_ - 100]->callback(message_in);
    3798:	f109 011c 	add.w	r1, r9, #28
    379c:	4798      	blx	r3
    379e:	f7ff b901 	b.w	29a4 <loop+0x5c>
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
    37a2:	4798      	blx	r3
    37a4:	4605      	mov	r5, r0
    37a6:	e749      	b.n	363c <loop+0xcf4>
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
    37a8:	4e55      	ldr	r6, [pc, #340]	; (3900 <loop+0xfb8>)
    37aa:	e741      	b.n	3630 <loop+0xce8>
    {
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
    37ac:	4f55      	ldr	r7, [pc, #340]	; (3904 <loop+0xfbc>)
    37ae:	e735      	b.n	361c <loop+0xcd4>
    37b0:	494c      	ldr	r1, [pc, #304]	; (38e4 <loop+0xf9c>)
    37b2:	4798      	blx	r3
    37b4:	e716      	b.n	35e4 <loop+0xc9c>
    37b6:	f507 7107 	add.w	r1, r7, #540	; 0x21c
    37ba:	4798      	blx	r3
    37bc:	e7de      	b.n	377c <loop+0xe34>
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    37be:	f8df e14c 	ldr.w	lr, [pc, #332]	; 390c <loop+0xfc4>
    37c2:	4f51      	ldr	r7, [pc, #324]	; (3908 <loop+0xfc0>)
    37c4:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    37c8:	c70f      	stmia	r7!, {r0, r1, r2, r3}
    37ca:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    37ce:	c70f      	stmia	r7!, {r0, r1, r2, r3}
    37d0:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    37d4:	c70f      	stmia	r7!, {r0, r1, r2, r3}
    37d6:	e89e 0003 	ldmia.w	lr, {r0, r1}
      arr[i] = (var >> (8 * i));
    37da:	2300      	movs	r3, #0
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    37dc:	f04f 0c03 	mov.w	ip, #3
    37e0:	f04f 0e38 	mov.w	lr, #56	; 0x38

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    37e4:	22ff      	movs	r2, #255	; 0xff
    37e6:	f885 c223 	strb.w	ip, [r5, #547]	; 0x223
    37ea:	f885 e224 	strb.w	lr, [r5, #548]	; 0x224
    message_out[1] = PROTOCOL_VER;
    37ee:	f04f 0cfe 	mov.w	ip, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    37f2:	f04f 0e3d 	mov.w	lr, #61	; 0x3d
    37f6:	f885 3225 	strb.w	r3, [r5, #549]	; 0x225
    37fa:	f885 3226 	strb.w	r3, [r5, #550]	; 0x226
    37fe:	f885 3227 	strb.w	r3, [r5, #551]	; 0x227
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    3802:	e887 0003 	stmia.w	r7, {r0, r1}
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3806:	20c2      	movs	r0, #194	; 0xc2

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3808:	f885 221c 	strb.w	r2, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    380c:	2207      	movs	r2, #7
    380e:	f1a7 0137 	sub.w	r1, r7, #55	; 0x37

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3812:	f885 321f 	strb.w	r3, [r5, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3816:	f885 3222 	strb.w	r3, [r5, #546]	; 0x222
    381a:	3707      	adds	r7, #7
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    381c:	f885 c21d 	strb.w	ip, [r5, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3820:	f885 e21e 	strb.w	lr, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3824:	f885 0220 	strb.w	r0, [r5, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3828:	f885 2221 	strb.w	r2, [r5, #545]	; 0x221
    382c:	e001      	b.n	3832 <loop+0xeea>
    382e:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3832:	42b9      	cmp	r1, r7
      chk += message_out[i];
    3834:	4413      	add	r3, r2
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3836:	d1fa      	bne.n	382e <loop+0xee6>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3838:	43db      	mvns	r3, r3
    383a:	6860      	ldr	r0, [r4, #4]
    383c:	f884 3260 	strb.w	r3, [r4, #608]	; 0x260
    3840:	6803      	ldr	r3, [r0, #0]
    3842:	4928      	ldr	r1, [pc, #160]	; (38e4 <loop+0xf9c>)
    3844:	685b      	ldr	r3, [r3, #4]
    3846:	2245      	movs	r2, #69	; 0x45
    3848:	4798      	blx	r3
    384a:	e6cb      	b.n	35e4 <loop+0xc9c>
    384c:	4d2f      	ldr	r5, [pc, #188]	; (390c <loop+0xfc4>)
    384e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    3850:	f507 760a 	add.w	r6, r7, #552	; 0x228
    3854:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    3856:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    3858:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    385a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    385c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    385e:	e895 0003 	ldmia.w	r5, {r0, r1}
    3862:	2200      	movs	r2, #0
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    3864:	2503      	movs	r5, #3
    3866:	2338      	movs	r3, #56	; 0x38
    3868:	f887 5223 	strb.w	r5, [r7, #547]	; 0x223
    386c:	f887 3224 	strb.w	r3, [r7, #548]	; 0x224

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3870:	f04f 0cff 	mov.w	ip, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    3874:	f04f 0efe 	mov.w	lr, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3878:	253d      	movs	r5, #61	; 0x3d
    387a:	f887 2225 	strb.w	r2, [r7, #549]	; 0x225
    387e:	f887 2226 	strb.w	r2, [r7, #550]	; 0x226
    3882:	f887 2227 	strb.w	r2, [r7, #551]	; 0x227
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3886:	f04f 08c2 	mov.w	r8, #194	; 0xc2
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    388a:	e886 0003 	stmia.w	r6, {r0, r1}
    message_out[5] = (uint8_t)((int16_t)id & 255);
    388e:	2107      	movs	r1, #7

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3890:	f887 221f 	strb.w	r2, [r7, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3894:	f887 2222 	strb.w	r2, [r7, #546]	; 0x222
    3898:	f1a6 0037 	sub.w	r0, r6, #55	; 0x37
    389c:	1df3      	adds	r3, r6, #7

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    389e:	f887 c21c 	strb.w	ip, [r7, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    38a2:	f887 e21d 	strb.w	lr, [r7, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    38a6:	f887 521e 	strb.w	r5, [r7, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    38aa:	f887 8220 	strb.w	r8, [r7, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    38ae:	f887 1221 	strb.w	r1, [r7, #545]	; 0x221
    38b2:	e001      	b.n	38b8 <loop+0xf70>
    38b4:	f810 1f01 	ldrb.w	r1, [r0, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    38b8:	4283      	cmp	r3, r0
      chk += message_out[i];
    38ba:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    38bc:	d1fa      	bne.n	38b4 <loop+0xf6c>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    38be:	43d2      	mvns	r2, r2
    38c0:	6860      	ldr	r0, [r4, #4]
    38c2:	f884 2260 	strb.w	r2, [r4, #608]	; 0x260
    38c6:	6803      	ldr	r3, [r0, #0]
    38c8:	4906      	ldr	r1, [pc, #24]	; (38e4 <loop+0xf9c>)
    38ca:	685b      	ldr	r3, [r3, #4]
    38cc:	2245      	movs	r2, #69	; 0x45
    38ce:	4798      	blx	r3
    38d0:	e754      	b.n	377c <loop+0xe34>
    38d2:	4608      	mov	r0, r1
    38d4:	f7fd fd64 	bl	13a0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*) [clone .part.8] [clone .constprop.10]>
    38d8:	e5b4      	b.n	3444 <loop+0xafc>
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    38da:	460b      	mov	r3, r1
    38dc:	e73a      	b.n	3754 <loop+0xe0c>
    38de:	bf00      	nop
    38e0:	00000ebd 	.word	0x00000ebd
    38e4:	1fff1f80 	.word	0x1fff1f80
    38e8:	0000097d 	.word	0x0000097d
    38ec:	00000985 	.word	0x00000985
    38f0:	00000979 	.word	0x00000979
    38f4:	1fff1f8d 	.word	0x1fff1f8d
    38f8:	1fff1f87 	.word	0x1fff1f87
    38fc:	1fff1d64 	.word	0x1fff1d64
    3900:	0000bf04 	.word	0x0000bf04
    3904:	0000bef0 	.word	0x0000bef0
    3908:	1fff1f8c 	.word	0x1fff1f8c
    390c:	0000bf68 	.word	0x0000bf68
    3910:	1fff2244 	.word	0x1fff2244

00003914 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()>:
    bool v = advertise(srv.pub);
    bool w = subscribe(srv);
    return v && w;
  }

  void negotiateTopics()
    3914:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3918:	b08d      	sub	sp, #52	; 0x34
    TopicInfo():
      topic_id(0),
      topic_name(""),
      message_type(""),
      md5sum(""),
      buffer_size(0)
    391a:	4acb      	ldr	r2, [pc, #812]	; (3c48 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x334>)
    391c:	4bcb      	ldr	r3, [pc, #812]	; (3c4c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x338>)
    391e:	9206      	str	r2, [sp, #24]
    3920:	2200      	movs	r2, #0
    3922:	4604      	mov	r4, r0
    3924:	f500 6583 	add.w	r5, r0, #1048	; 0x418
    3928:	f200 467c 	addw	r6, r0, #1148	; 0x47c
    392c:	f8ad 201c 	strh.w	r2, [sp, #28]
    3930:	920b      	str	r2, [sp, #44]	; 0x2c
    3932:	9308      	str	r3, [sp, #32]
    3934:	9309      	str	r3, [sp, #36]	; 0x24
    3936:	930a      	str	r3, [sp, #40]	; 0x28
  {
    rosserial_msgs::TopicInfo ti;
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
    3938:	f855 3f04 	ldr.w	r3, [r5, #4]!
    393c:	2b00      	cmp	r3, #0
    393e:	f000 80c2 	beq.w	3ac6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    3942:	6858      	ldr	r0, [r3, #4]
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
    3944:	681f      	ldr	r7, [r3, #0]
        ti.message_type = (char *) publishers[i]->msg_->getType();
    3946:	6801      	ldr	r1, [r0, #0]
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
    3948:	689a      	ldr	r2, [r3, #8]
        ti.topic_name = (char *) publishers[i]->topic_;
    394a:	9708      	str	r7, [sp, #32]
        ti.message_type = (char *) publishers[i]->msg_->getType();
    394c:	688b      	ldr	r3, [r1, #8]
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
    394e:	f8ad 201c 	strh.w	r2, [sp, #28]
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    3952:	4798      	blx	r3
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    3954:	682b      	ldr	r3, [r5, #0]
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    3956:	9009      	str	r0, [sp, #36]	; 0x24
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    3958:	6858      	ldr	r0, [r3, #4]
    395a:	6803      	ldr	r3, [r0, #0]
    395c:	68db      	ldr	r3, [r3, #12]
    395e:	4798      	blx	r3
        ti.buffer_size = OUTPUT_SIZE;
        publish(publishers[i]->getEndpointType(), &ti);
    3960:	6823      	ldr	r3, [r4, #0]
    3962:	6829      	ldr	r1, [r5, #0]
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    3964:	900a      	str	r0, [sp, #40]	; 0x28
        ti.buffer_size = OUTPUT_SIZE;
    3966:	f44f 7200 	mov.w	r2, #512	; 0x200
        publish(publishers[i]->getEndpointType(), &ti);
    396a:	681b      	ldr	r3, [r3, #0]
    396c:	f8d1 8010 	ldr.w	r8, [r1, #16]
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
        ti.buffer_size = OUTPUT_SIZE;
    3970:	920b      	str	r2, [sp, #44]	; 0x2c
    3972:	4ab7      	ldr	r2, [pc, #732]	; (3c50 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x33c>)
    3974:	4293      	cmp	r3, r2
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    3976:	4682      	mov	sl, r0
    3978:	f040 81a9 	bne.w	3cce <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x3ba>
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    397c:	f1b8 0f63 	cmp.w	r8, #99	; 0x63
    3980:	dd04      	ble.n	398c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x78>
    3982:	f894 34f8 	ldrb.w	r3, [r4, #1272]	; 0x4f8
    3986:	2b00      	cmp	r3, #0
    3988:	f000 809d 	beq.w	3ac6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    398c:	f8bd 301c 	ldrh.w	r3, [sp, #28]
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    3990:	f8dd 9020 	ldr.w	r9, [sp, #32]
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    3994:	f884 3223 	strb.w	r3, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    3998:	0a1b      	lsrs	r3, r3, #8
    399a:	f884 3224 	strb.w	r3, [r4, #548]	; 0x224
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    399e:	4648      	mov	r0, r9
    39a0:	f007 feee 	bl	b780 <strlen>
    39a4:	4607      	mov	r7, r0
    39a6:	0e3b      	lsrs	r3, r7, #24
    39a8:	0c3a      	lsrs	r2, r7, #16
    39aa:	0a00      	lsrs	r0, r0, #8
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
    39ac:	4649      	mov	r1, r9
    39ae:	f884 3228 	strb.w	r3, [r4, #552]	; 0x228
    39b2:	f884 7225 	strb.w	r7, [r4, #549]	; 0x225
    39b6:	f884 0226 	strb.w	r0, [r4, #550]	; 0x226
    39ba:	f884 2227 	strb.w	r2, [r4, #551]	; 0x227
    39be:	f204 2029 	addw	r0, r4, #553	; 0x229
    39c2:	463a      	mov	r2, r7
    39c4:	f002 fd3a 	bl	643c <memcpy>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
    39c8:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
    39cc:	4658      	mov	r0, fp
    39ce:	f007 fed7 	bl	b780 <strlen>
      return 0;

    /* serialize message */
    int l = msg->serialize(message_out + 7);
    39d2:	f204 2923 	addw	r9, r4, #547	; 0x223
    39d6:	1d79      	adds	r1, r7, #5
    39d8:	4602      	mov	r2, r0
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
    39da:	3706      	adds	r7, #6
    39dc:	4449      	add	r1, r9
      uint32_t length_message_type = strlen(this->message_type);
    39de:	2300      	movs	r3, #0
    39e0:	fa22 f003 	lsr.w	r0, r2, r3
    39e4:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    39e6:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
    39e8:	f801 0f01 	strb.w	r0, [r1, #1]!

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    39ec:	d1f8      	bne.n	39e0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0xcc>
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    39ee:	3704      	adds	r7, #4
    39f0:	4659      	mov	r1, fp
    39f2:	eb09 0007 	add.w	r0, r9, r7
      offset += length_message_type;
    39f6:	4417      	add	r7, r2
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    39f8:	f002 fd20 	bl	643c <memcpy>
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
    39fc:	4650      	mov	r0, sl
    39fe:	f007 febf 	bl	b780 <strlen>
    3a02:	eb09 0307 	add.w	r3, r9, r7
    3a06:	4683      	mov	fp, r0
    3a08:	2200      	movs	r2, #0
      arr[i] = (var >> (8 * i));
    3a0a:	fa2b f102 	lsr.w	r1, fp, r2
    3a0e:	3208      	adds	r2, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3a10:	2a20      	cmp	r2, #32
      arr[i] = (var >> (8 * i));
    3a12:	f803 1b01 	strb.w	r1, [r3], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3a16:	d1f8      	bne.n	3a0a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0xf6>
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    3a18:	3704      	adds	r7, #4
    3a1a:	4651      	mov	r1, sl
    3a1c:	eb09 0007 	add.w	r0, r9, r7
    3a20:	465a      	mov	r2, fp
    3a22:	f002 fd0b 	bl	643c <memcpy>
      offset += length_md5sum;
    3a26:	eb0b 0307 	add.w	r3, fp, r7
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
    3a2a:	1d1f      	adds	r7, r3, #4
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    3a2c:	eb09 0103 	add.w	r1, r9, r3

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3a30:	fa5f fa87 	uxtb.w	sl, r7
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3a34:	f3c7 2c07 	ubfx	ip, r7, #8, #8
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    3a38:	2200      	movs	r2, #0
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3a3a:	eb0a 0e0c 	add.w	lr, sl, ip
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    3a3e:	f04f 0b02 	mov.w	fp, #2
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    3a42:	f809 2003 	strb.w	r2, [r9, r3]
    3a46:	ea6f 0e0e 	mvn.w	lr, lr
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
    3a4a:	708a      	strb	r2, [r1, #2]
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
    3a4c:	70ca      	strb	r2, [r1, #3]
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    3a4e:	f881 b001 	strb.w	fp, [r1, #1]

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3a52:	20ff      	movs	r0, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3a54:	fa5f f188 	uxtb.w	r1, r8
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    3a58:	f04f 09fe 	mov.w	r9, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3a5c:	f348 2807 	sbfx	r8, r8, #8, #8

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3a60:	f1b7 3fff 	cmp.w	r7, #4294967295	; 0xffffffff
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3a64:	f884 e220 	strb.w	lr, [r4, #544]	; 0x220
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3a68:	f884 a21e 	strb.w	sl, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3a6c:	f884 c21f 	strb.w	ip, [r4, #543]	; 0x21f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3a70:	f884 021c 	strb.w	r0, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    3a74:	f884 921d 	strb.w	r9, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3a78:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3a7c:	f884 8222 	strb.w	r8, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3a80:	f2c0 81d0 	blt.w	3e24 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x510>
    3a84:	f203 2326 	addw	r3, r3, #550	; 0x226
    3a88:	18e0      	adds	r0, r4, r3
    3a8a:	f204 2321 	addw	r3, r4, #545	; 0x221
    3a8e:	e001      	b.n	3a94 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x180>
    3a90:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    3a94:	4298      	cmp	r0, r3
      chk += message_out[i];
    3a96:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3a98:	d1fa      	bne.n	3a90 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x17c>
    3a9a:	43d2      	mvns	r2, r2
    3a9c:	b2d2      	uxtb	r2, r2
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3a9e:	19e3      	adds	r3, r4, r7
    3aa0:	f107 0108 	add.w	r1, r7, #8

    if (l <= OUTPUT_SIZE)
    3aa4:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3aa8:	f883 2223 	strb.w	r2, [r3, #547]	; 0x223

    if (l <= OUTPUT_SIZE)
    3aac:	f300 8123 	bgt.w	3cf6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x3e2>
    3ab0:	6867      	ldr	r7, [r4, #4]
    3ab2:	4a68      	ldr	r2, [pc, #416]	; (3c54 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x340>)
    3ab4:	683b      	ldr	r3, [r7, #0]
    3ab6:	685b      	ldr	r3, [r3, #4]
    3ab8:	4293      	cmp	r3, r2
    {
      hardware_.write(message_out, l);
    3aba:	f504 7007 	add.w	r0, r4, #540	; 0x21c
    3abe:	f040 8110 	bne.w	3ce2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x3ce>
    3ac2:	f003 ffd3 	bl	7a6c <usb_serial_write>

  void negotiateTopics()
  {
    rosserial_msgs::TopicInfo ti;
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    3ac6:	42ae      	cmp	r6, r5
    3ac8:	f47f af36 	bne.w	3938 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x24>
    3acc:	f504 699c 	add.w	r9, r4, #1248	; 0x4e0
        publish(publishers[i]->getEndpointType(), &ti);
      }
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
    3ad0:	f856 0f04 	ldr.w	r0, [r6, #4]!
    3ad4:	2800      	cmp	r0, #0
    3ad6:	f000 80e4 	beq.w	3ca2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x38e>
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
    3ada:	6803      	ldr	r3, [r0, #0]
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
    3adc:	6882      	ldr	r2, [r0, #8]
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
    3ade:	6841      	ldr	r1, [r0, #4]
        ti.topic_name = (char *) subscribers[i]->topic_;
    3ae0:	9208      	str	r2, [sp, #32]
        ti.message_type = (char *) subscribers[i]->getMsgType();
    3ae2:	689a      	ldr	r2, [r3, #8]
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
    3ae4:	f8ad 101c 	strh.w	r1, [sp, #28]
    3ae8:	495b      	ldr	r1, [pc, #364]	; (3c58 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x344>)
    3aea:	428a      	cmp	r2, r1
    3aec:	f040 80f4 	bne.w	3cd8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x3c4>
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
    3af0:	4a5a      	ldr	r2, [pc, #360]	; (3c5c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x348>)
    3af2:	9209      	str	r2, [sp, #36]	; 0x24
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
    3af4:	68da      	ldr	r2, [r3, #12]
    3af6:	495a      	ldr	r1, [pc, #360]	; (3c60 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x34c>)
    3af8:	428a      	cmp	r2, r1
    3afa:	f040 80e3 	bne.w	3cc4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x3b0>
    3afe:	4a59      	ldr	r2, [pc, #356]	; (3c64 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x350>)
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
    3b00:	6821      	ldr	r1, [r4, #0]
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
    3b02:	920a      	str	r2, [sp, #40]	; 0x28
        ti.buffer_size = INPUT_SIZE;
    3b04:	f44f 7200 	mov.w	r2, #512	; 0x200
        publish(subscribers[i]->getEndpointType(), &ti);
    3b08:	685b      	ldr	r3, [r3, #4]
    3b0a:	680d      	ldr	r5, [r1, #0]
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
    3b0c:	920b      	str	r2, [sp, #44]	; 0x2c
    3b0e:	4a56      	ldr	r2, [pc, #344]	; (3c68 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x354>)
    3b10:	4293      	cmp	r3, r2
    3b12:	f040 80d4 	bne.w	3cbe <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x3aa>
    3b16:	f8d0 805c 	ldr.w	r8, [r0, #92]	; 0x5c
    3b1a:	4f4d      	ldr	r7, [pc, #308]	; (3c50 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x33c>)
    3b1c:	42bd      	cmp	r5, r7
    3b1e:	f040 80c9 	bne.w	3cb4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x3a0>
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    3b22:	f1b8 0f63 	cmp.w	r8, #99	; 0x63
    3b26:	dd04      	ble.n	3b32 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x21e>
    3b28:	f894 34f8 	ldrb.w	r3, [r4, #1272]	; 0x4f8
    3b2c:	2b00      	cmp	r3, #0
    3b2e:	f000 80b8 	beq.w	3ca2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x38e>
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    3b32:	f8bd 301c 	ldrh.w	r3, [sp, #28]
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    3b36:	9d08      	ldr	r5, [sp, #32]
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    3b38:	f884 3223 	strb.w	r3, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    3b3c:	0a1b      	lsrs	r3, r3, #8
    3b3e:	f884 3224 	strb.w	r3, [r4, #548]	; 0x224
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    3b42:	4628      	mov	r0, r5
    3b44:	f007 fe1c 	bl	b780 <strlen>
    3b48:	4682      	mov	sl, r0
      arr[i] = (var >> (8 * i));
    3b4a:	ea4f 631a 	mov.w	r3, sl, lsr #24
    3b4e:	ea4f 421a 	mov.w	r2, sl, lsr #16
    3b52:	0a00      	lsrs	r0, r0, #8
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
    3b54:	4629      	mov	r1, r5
    3b56:	f884 3228 	strb.w	r3, [r4, #552]	; 0x228
    3b5a:	f884 a225 	strb.w	sl, [r4, #549]	; 0x225
    3b5e:	f884 0226 	strb.w	r0, [r4, #550]	; 0x226
    3b62:	f884 2227 	strb.w	r2, [r4, #551]	; 0x227
    3b66:	f204 2029 	addw	r0, r4, #553	; 0x229
    3b6a:	4652      	mov	r2, sl
    3b6c:	f002 fc66 	bl	643c <memcpy>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
    3b70:	9909      	ldr	r1, [sp, #36]	; 0x24
    3b72:	9101      	str	r1, [sp, #4]
    3b74:	4608      	mov	r0, r1
    3b76:	f007 fe03 	bl	b780 <strlen>
      return 0;

    /* serialize message */
    int l = msg->serialize(message_out + 7);
    3b7a:	f204 2523 	addw	r5, r4, #547	; 0x223
    3b7e:	f10a 0205 	add.w	r2, sl, #5
    3b82:	9901      	ldr	r1, [sp, #4]
    3b84:	4683      	mov	fp, r0
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
    3b86:	f10a 0a06 	add.w	sl, sl, #6
    3b8a:	442a      	add	r2, r5
      uint32_t length_message_type = strlen(this->message_type);
    3b8c:	2300      	movs	r3, #0
    3b8e:	fa2b f003 	lsr.w	r0, fp, r3
    3b92:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3b94:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
    3b96:	f802 0f01 	strb.w	r0, [r2, #1]!

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3b9a:	d1f8      	bne.n	3b8e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x27a>
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    3b9c:	f10a 0a04 	add.w	sl, sl, #4
    3ba0:	465a      	mov	r2, fp
    3ba2:	eb05 000a 	add.w	r0, r5, sl
    3ba6:	f002 fc49 	bl	643c <memcpy>
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
    3baa:	990a      	ldr	r1, [sp, #40]	; 0x28
    3bac:	9101      	str	r1, [sp, #4]
    3bae:	4608      	mov	r0, r1
    3bb0:	f007 fde6 	bl	b780 <strlen>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
      offset += length_message_type;
    3bb4:	44d3      	add	fp, sl
      uint32_t length_md5sum = strlen(this->md5sum);
    3bb6:	9901      	ldr	r1, [sp, #4]
    3bb8:	4682      	mov	sl, r0
    3bba:	eb05 030b 	add.w	r3, r5, fp
    3bbe:	2200      	movs	r2, #0
      arr[i] = (var >> (8 * i));
    3bc0:	fa2a f002 	lsr.w	r0, sl, r2
    3bc4:	3208      	adds	r2, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3bc6:	2a20      	cmp	r2, #32
      arr[i] = (var >> (8 * i));
    3bc8:	f803 0b01 	strb.w	r0, [r3], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3bcc:	d1f8      	bne.n	3bc0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x2ac>
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    3bce:	f10b 0b04 	add.w	fp, fp, #4
    3bd2:	eb05 000b 	add.w	r0, r5, fp
    3bd6:	4652      	mov	r2, sl
    3bd8:	f002 fc30 	bl	643c <memcpy>
      offset += length_md5sum;
    3bdc:	eb0a 030b 	add.w	r3, sl, fp
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
    3be0:	1d1a      	adds	r2, r3, #4
      offset += length_md5sum;
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
    3be2:	990b      	ldr	r1, [sp, #44]	; 0x2c
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    3be4:	54e9      	strb	r1, [r5, r3]

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3be6:	fa5f fc82 	uxtb.w	ip, r2
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3bea:	f3c2 2e07 	ubfx	lr, r2, #8, #8
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    3bee:	441d      	add	r5, r3
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3bf0:	eb0c 000e 	add.w	r0, ip, lr
    3bf4:	ea4f 2b11 	mov.w	fp, r1, lsr #8
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
    3bf8:	ea4f 4a11 	mov.w	sl, r1, lsr #16
    3bfc:	43c0      	mvns	r0, r0
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
    3bfe:	0e09      	lsrs	r1, r1, #24
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    3c00:	f885 b001 	strb.w	fp, [r5, #1]
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
    3c04:	f885 a002 	strb.w	sl, [r5, #2]
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
    3c08:	70e9      	strb	r1, [r5, #3]

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3c0a:	f04f 0bff 	mov.w	fp, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3c0e:	fa5f f188 	uxtb.w	r1, r8
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    3c12:	f04f 0afe 	mov.w	sl, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3c16:	f348 2807 	sbfx	r8, r8, #8, #8
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3c1a:	f884 0220 	strb.w	r0, [r4, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3c1e:	1c50      	adds	r0, r2, #1
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3c20:	f884 c21e 	strb.w	ip, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3c24:	f884 e21f 	strb.w	lr, [r4, #543]	; 0x21f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3c28:	f884 b21c 	strb.w	fp, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    3c2c:	f884 a21d 	strb.w	sl, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3c30:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3c34:	f884 8222 	strb.w	r8, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3c38:	db21      	blt.n	3c7e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x36a>
    3c3a:	f203 2326 	addw	r3, r3, #550	; 0x226
    3c3e:	18e5      	adds	r5, r4, r3
    3c40:	2000      	movs	r0, #0
    3c42:	f204 2321 	addw	r3, r4, #545	; 0x221
    3c46:	e013      	b.n	3c70 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x35c>
    3c48:	0000bc3c 	.word	0x0000bc3c
    3c4c:	0000bfa0 	.word	0x0000bfa0
    3c50:	00001a4d 	.word	0x00001a4d
    3c54:	00000ebd 	.word	0x00000ebd
    3c58:	0000097d 	.word	0x0000097d
    3c5c:	0000bef0 	.word	0x0000bef0
    3c60:	00000985 	.word	0x00000985
    3c64:	0000bf04 	.word	0x0000bf04
    3c68:	00000979 	.word	0x00000979
    3c6c:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    3c70:	42ab      	cmp	r3, r5
      chk += message_out[i];
    3c72:	4408      	add	r0, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3c74:	d1fa      	bne.n	3c6c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x358>
    3c76:	ea6f 0b00 	mvn.w	fp, r0
    3c7a:	fa5f fb8b 	uxtb.w	fp, fp
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3c7e:	18a3      	adds	r3, r4, r2
    3c80:	f102 0108 	add.w	r1, r2, #8

    if (l <= OUTPUT_SIZE)
    3c84:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3c88:	f883 b223 	strb.w	fp, [r3, #547]	; 0x223

    if (l <= OUTPUT_SIZE)
    3c8c:	dc7e      	bgt.n	3d8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x478>
    3c8e:	6865      	ldr	r5, [r4, #4]
    3c90:	4a6b      	ldr	r2, [pc, #428]	; (3e40 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x52c>)
    3c92:	682b      	ldr	r3, [r5, #0]
    3c94:	685b      	ldr	r3, [r3, #4]
    3c96:	4293      	cmp	r3, r2
    {
      hardware_.write(message_out, l);
    3c98:	f504 7007 	add.w	r0, r4, #540	; 0x21c
    3c9c:	d126      	bne.n	3cec <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x3d8>
    3c9e:	f003 fee5 	bl	7a6c <usb_serial_write>
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
        ti.buffer_size = OUTPUT_SIZE;
        publish(publishers[i]->getEndpointType(), &ti);
      }
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    3ca2:	45b1      	cmp	r9, r6
    3ca4:	f47f af14 	bne.w	3ad0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1bc>
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
      }
    }
    configured_ = true;
    3ca8:	2301      	movs	r3, #1
    3caa:	f884 34f8 	strb.w	r3, [r4, #1272]	; 0x4f8
  }
    3cae:	b00d      	add	sp, #52	; 0x34
    3cb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
    3cb4:	4641      	mov	r1, r8
    3cb6:	aa06      	add	r2, sp, #24
    3cb8:	4620      	mov	r0, r4
    3cba:	47a8      	blx	r5
    3cbc:	e7f1      	b.n	3ca2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x38e>
    3cbe:	4798      	blx	r3
    3cc0:	4680      	mov	r8, r0
    3cc2:	e72a      	b.n	3b1a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x206>
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
    3cc4:	4790      	blx	r2
    3cc6:	4602      	mov	r2, r0
    3cc8:	6830      	ldr	r0, [r6, #0]
    3cca:	6803      	ldr	r3, [r0, #0]
    3ccc:	e718      	b.n	3b00 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1ec>
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
        ti.buffer_size = OUTPUT_SIZE;
        publish(publishers[i]->getEndpointType(), &ti);
    3cce:	4641      	mov	r1, r8
    3cd0:	aa06      	add	r2, sp, #24
    3cd2:	4620      	mov	r0, r4
    3cd4:	4798      	blx	r3
    3cd6:	e6f6      	b.n	3ac6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
    {
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
    3cd8:	4790      	blx	r2
    3cda:	4602      	mov	r2, r0
    3cdc:	6830      	ldr	r0, [r6, #0]
    3cde:	6803      	ldr	r3, [r0, #0]
    3ce0:	e707      	b.n	3af2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1de>
    3ce2:	460a      	mov	r2, r1
    3ce4:	4601      	mov	r1, r0
    3ce6:	4638      	mov	r0, r7
    3ce8:	4798      	blx	r3
    3cea:	e6ec      	b.n	3ac6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
    3cec:	460a      	mov	r2, r1
    3cee:	4601      	mov	r1, r0
    3cf0:	4628      	mov	r0, r5
    3cf2:	4798      	blx	r3
    3cf4:	e7d5      	b.n	3ca2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x38e>
      enum { ERROR = 3 };
      enum { FATAL = 4 };

    Log():
      level(0),
      msg("")
    3cf6:	4a53      	ldr	r2, [pc, #332]	; (3e44 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x530>)
    3cf8:	9203      	str	r2, [sp, #12]

protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    3cfa:	2103      	movs	r1, #3
    l.msg = (char*)msg;
    3cfc:	4a52      	ldr	r2, [pc, #328]	; (3e48 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x534>)
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    3cfe:	6823      	ldr	r3, [r4, #0]
protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    3d00:	9205      	str	r2, [sp, #20]

protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    3d02:	f88d 1010 	strb.w	r1, [sp, #16]
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    3d06:	681b      	ldr	r3, [r3, #0]
    3d08:	4a50      	ldr	r2, [pc, #320]	; (3e4c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x538>)
    3d0a:	4293      	cmp	r3, r2
    3d0c:	f040 8085 	bne.w	3e1a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x506>
      arr[i] = (var >> (8 * i));
    3d10:	2700      	movs	r7, #0
    3d12:	2238      	movs	r2, #56	; 0x38
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    3d14:	f884 1223 	strb.w	r1, [r4, #547]	; 0x223
    3d18:	f884 2224 	strb.w	r2, [r4, #548]	; 0x224
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    3d1c:	494a      	ldr	r1, [pc, #296]	; (3e48 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x534>)
    3d1e:	f884 7225 	strb.w	r7, [r4, #549]	; 0x225
    3d22:	f884 7226 	strb.w	r7, [r4, #550]	; 0x226
    3d26:	f884 7227 	strb.w	r7, [r4, #551]	; 0x227
    3d2a:	f504 700a 	add.w	r0, r4, #552	; 0x228
    3d2e:	f002 fb85 	bl	643c <memcpy>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3d32:	21ff      	movs	r1, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3d34:	203d      	movs	r0, #61	; 0x3d
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3d36:	23c2      	movs	r3, #194	; 0xc2
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    3d38:	f04f 0efe 	mov.w	lr, #254	; 0xfe

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3d3c:	f884 121c 	strb.w	r1, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3d40:	2107      	movs	r1, #7
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3d42:	f884 021e 	strb.w	r0, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3d46:	f884 3220 	strb.w	r3, [r4, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3d4a:	f884 721f 	strb.w	r7, [r4, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3d4e:	f884 7222 	strb.w	r7, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    3d52:	463a      	mov	r2, r7
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    3d54:	f884 e21d 	strb.w	lr, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3d58:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    3d5c:	f204 2321 	addw	r3, r4, #545	; 0x221
    3d60:	f204 205f 	addw	r0, r4, #607	; 0x25f
    3d64:	e001      	b.n	3d6a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x456>
    3d66:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3d6a:	4298      	cmp	r0, r3
      chk += message_out[i];
    3d6c:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3d6e:	d1fa      	bne.n	3d66 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x452>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3d70:	43d2      	mvns	r2, r2
    3d72:	6860      	ldr	r0, [r4, #4]
    3d74:	f884 2260 	strb.w	r2, [r4, #608]	; 0x260
    3d78:	6803      	ldr	r3, [r0, #0]
    3d7a:	4a31      	ldr	r2, [pc, #196]	; (3e40 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x52c>)
    3d7c:	685b      	ldr	r3, [r3, #4]
    3d7e:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    3d80:	f504 7107 	add.w	r1, r4, #540	; 0x21c
    3d84:	d158      	bne.n	3e38 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x524>
    3d86:	4608      	mov	r0, r1
    3d88:	2145      	movs	r1, #69	; 0x45
    3d8a:	e69a      	b.n	3ac2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1ae>
      enum { ERROR = 3 };
      enum { FATAL = 4 };

    Log():
      level(0),
      msg("")
    3d8c:	4a2d      	ldr	r2, [pc, #180]	; (3e44 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x530>)
protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    3d8e:	492e      	ldr	r1, [pc, #184]	; (3e48 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x534>)
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    3d90:	6823      	ldr	r3, [r4, #0]
    3d92:	9203      	str	r2, [sp, #12]

protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    3d94:	2003      	movs	r0, #3
    3d96:	f88d 0010 	strb.w	r0, [sp, #16]
    l.msg = (char*)msg;
    3d9a:	9105      	str	r1, [sp, #20]
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    3d9c:	681b      	ldr	r3, [r3, #0]
    3d9e:	42bb      	cmp	r3, r7
    3da0:	d145      	bne.n	3e2e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x51a>
    3da2:	2500      	movs	r5, #0
    3da4:	2238      	movs	r2, #56	; 0x38
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    3da6:	f884 0223 	strb.w	r0, [r4, #547]	; 0x223
    3daa:	f884 2224 	strb.w	r2, [r4, #548]	; 0x224
    3dae:	f884 5225 	strb.w	r5, [r4, #549]	; 0x225
    3db2:	f884 5226 	strb.w	r5, [r4, #550]	; 0x226
    3db6:	f884 5227 	strb.w	r5, [r4, #551]	; 0x227
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    3dba:	f504 700a 	add.w	r0, r4, #552	; 0x228
    3dbe:	f002 fb3d 	bl	643c <memcpy>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3dc2:	21ff      	movs	r1, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3dc4:	203d      	movs	r0, #61	; 0x3d
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3dc6:	23c2      	movs	r3, #194	; 0xc2
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    3dc8:	27fe      	movs	r7, #254	; 0xfe

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3dca:	f884 121c 	strb.w	r1, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3dce:	2107      	movs	r1, #7
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3dd0:	f884 021e 	strb.w	r0, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3dd4:	f884 3220 	strb.w	r3, [r4, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3dd8:	f884 521f 	strb.w	r5, [r4, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3ddc:	f884 5222 	strb.w	r5, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    3de0:	462a      	mov	r2, r5
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    3de2:	f884 721d 	strb.w	r7, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3de6:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    3dea:	f204 2321 	addw	r3, r4, #545	; 0x221
    3dee:	f204 205f 	addw	r0, r4, #607	; 0x25f
    3df2:	e001      	b.n	3df8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4e4>
    3df4:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3df8:	4283      	cmp	r3, r0
      chk += message_out[i];
    3dfa:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3dfc:	d1fa      	bne.n	3df4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4e0>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3dfe:	43d2      	mvns	r2, r2
    3e00:	6860      	ldr	r0, [r4, #4]
    3e02:	f884 2260 	strb.w	r2, [r4, #608]	; 0x260
    3e06:	6803      	ldr	r3, [r0, #0]
    3e08:	4a0d      	ldr	r2, [pc, #52]	; (3e40 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x52c>)
    3e0a:	685b      	ldr	r3, [r3, #4]
    3e0c:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    3e0e:	f504 7107 	add.w	r1, r4, #540	; 0x21c
    3e12:	d109      	bne.n	3e28 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x514>
    3e14:	4608      	mov	r0, r1
    3e16:	2145      	movs	r1, #69	; 0x45
    3e18:	e741      	b.n	3c9e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x38a>
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    3e1a:	aa03      	add	r2, sp, #12
    3e1c:	2107      	movs	r1, #7
    3e1e:	4620      	mov	r0, r4
    3e20:	4798      	blx	r3
    3e22:	e650      	b.n	3ac6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3e24:	4602      	mov	r2, r0
    3e26:	e63a      	b.n	3a9e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x18a>
    3e28:	2245      	movs	r2, #69	; 0x45
    3e2a:	4798      	blx	r3
    3e2c:	e739      	b.n	3ca2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x38e>
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    3e2e:	aa03      	add	r2, sp, #12
    3e30:	2107      	movs	r1, #7
    3e32:	4620      	mov	r0, r4
    3e34:	4798      	blx	r3
    3e36:	e734      	b.n	3ca2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x38e>
    3e38:	2245      	movs	r2, #69	; 0x45
    3e3a:	4798      	blx	r3
    3e3c:	e643      	b.n	3ac6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
    3e3e:	bf00      	nop
    3e40:	00000ebd 	.word	0x00000ebd
    3e44:	0000bc54 	.word	0x0000bc54
    3e48:	0000bf68 	.word	0x0000bf68
    3e4c:	00001a4d 	.word	0x00001a4d

00003e50 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()>:
  /* This function goes in your loop() function, it handles
   *  serial input and callbacks for subscribers.
   */


  virtual int spinOnce() override
    3e50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3e54:	4ec0      	ldr	r6, [pc, #768]	; (4158 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x308>)
    3e56:	b097      	sub	sp, #92	; 0x5c
    3e58:	6833      	ldr	r3, [r6, #0]
    3e5a:	930a      	str	r3, [sp, #40]	; 0x28
	return ret;
    3e5c:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  {
    /* restart if timed out */
    uint32_t c_time = hardware_.time();
    if ((c_time - last_sync_receive_time) > (SYNC_SECONDS * 2200))
    3e5e:	f8d0 3500 	ldr.w	r3, [r0, #1280]	; 0x500
    3e62:	f642 22f8 	movw	r2, #11000	; 0x2af8
    3e66:	1aeb      	subs	r3, r5, r3
    3e68:	4293      	cmp	r3, r2
    {
      configured_ = false;
    3e6a:	bf84      	itt	hi
    3e6c:	2300      	movhi	r3, #0
    3e6e:	f880 34f8 	strbhi.w	r3, [r0, #1272]	; 0x4f8
    }

    /* reset if message has timed out */
    if (mode_ != MODE_FIRST_FF)
    3e72:	f8d0 34e4 	ldr.w	r3, [r0, #1252]	; 0x4e4
  /* This function goes in your loop() function, it handles
   *  serial input and callbacks for subscribers.
   */


  virtual int spinOnce() override
    3e76:	4604      	mov	r4, r0
    {
      configured_ = false;
    }

    /* reset if message has timed out */
    if (mode_ != MODE_FIRST_FF)
    3e78:	b133      	cbz	r3, 3e88 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x38>
    {
      if (c_time > last_msg_timeout_time)
    3e7a:	f8d0 3504 	ldr.w	r3, [r0, #1284]	; 0x504
    3e7e:	42ab      	cmp	r3, r5
      {
        mode_ = MODE_FIRST_FF;
    3e80:	bf3c      	itt	cc
    3e82:	2300      	movcc	r3, #0
    3e84:	f8c0 34e4 	strcc.w	r3, [r0, #1252]	; 0x4e4
    3e88:	f8df a2d8 	ldr.w	sl, [pc, #728]	; 4164 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x314>

    /* while available buffer, read data */
    while (true)
    {
      // If a timeout has been specified, check how long spinOnce has been running.
      if (spin_timeout_ > 0)
    3e8c:	69a2      	ldr	r2, [r4, #24]
    3e8e:	b132      	cbz	r2, 3e9e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x4e>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3e90:	6833      	ldr	r3, [r6, #0]
    3e92:	930b      	str	r3, [sp, #44]	; 0x2c
	return ret;
    3e94:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
      {
        // If the maximum processing timeout has been exceeded, exit with error.
        // The next spinOnce can continue where it left off, or optionally
        // based on the application in use, the hardware buffer could be flushed
        // and start fresh.
        if ((hardware_.time() - c_time) > spin_timeout_)
    3e96:	1b5b      	subs	r3, r3, r5
    3e98:	429a      	cmp	r2, r3
    3e9a:	f0c0 81f5 	bcc.w	4288 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x438>
    3e9e:	6860      	ldr	r0, [r4, #4]
      delay(3000); 
#endif
      iostream->begin(baud_);
    }

    int read(){return iostream->read();};
    3ea0:	6803      	ldr	r3, [r0, #0]
    3ea2:	695b      	ldr	r3, [r3, #20]
    3ea4:	4553      	cmp	r3, sl
    3ea6:	f040 8139 	bne.w	411c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x2cc>
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    3eaa:	f003 fd79 	bl	79a0 <usb_serial_getchar>
          // Exit the spin, processing timeout exceeded.
          return SPIN_TIMEOUT;
        }
      }
      int data = hardware_.read();
      if (data < 0)
    3eae:	2800      	cmp	r0, #0
    3eb0:	f2c0 8138 	blt.w	4124 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x2d4>
        break;
      checksum_ += data;
    3eb4:	f8d4 34f4 	ldr.w	r3, [r4, #1268]	; 0x4f4
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    3eb8:	f8d4 24e4 	ldr.w	r2, [r4, #1252]	; 0x4e4
        }
      }
      int data = hardware_.read();
      if (data < 0)
        break;
      checksum_ += data;
    3ebc:	4403      	add	r3, r0
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    3ebe:	2a07      	cmp	r2, #7
        }
      }
      int data = hardware_.read();
      if (data < 0)
        break;
      checksum_ += data;
    3ec0:	f8c4 34f4 	str.w	r3, [r4, #1268]	; 0x4f4
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    3ec4:	f000 8117 	beq.w	40f6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x2a6>
        message_in[index_++] = data;
        bytes_--;
        if (bytes_ == 0)                 /* is message complete? if so, checksum */
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_FIRST_FF)
    3ec8:	b98a      	cbnz	r2, 3eee <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x9e>
      {
        if (data == 0xff)
    3eca:	28ff      	cmp	r0, #255	; 0xff
    3ecc:	f000 813b 	beq.w	4146 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x2f6>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3ed0:	6833      	ldr	r3, [r6, #0]
    3ed2:	930c      	str	r3, [sp, #48]	; 0x30
	return ret;
    3ed4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
        {
          mode_++;
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
        }
        else if (hardware_.time() - c_time > (SYNC_SECONDS * 1000))
    3ed6:	f241 3188 	movw	r1, #5000	; 0x1388
    3eda:	1b5b      	subs	r3, r3, r5
    3edc:	428b      	cmp	r3, r1
    3ede:	d9d5      	bls.n	3e8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
        {
          /* We have been stuck in spinOnce too long, return error */
          configured_ = false;
    3ee0:	f884 24f8 	strb.w	r2, [r4, #1272]	; 0x4f8
          return SPIN_TIMEOUT;
    3ee4:	f06f 0001 	mvn.w	r0, #1
      requestSyncTime();
      last_sync_time = c_time;
    }

    return SPIN_OK;
  }
    3ee8:	b017      	add	sp, #92	; 0x5c
    3eea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          /* We have been stuck in spinOnce too long, return error */
          configured_ = false;
          return SPIN_TIMEOUT;
        }
      }
      else if (mode_ == MODE_PROTOCOL_VER)
    3eee:	2a01      	cmp	r2, #1
    3ef0:	f000 813a 	beq.w	4168 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x318>
          mode_ = MODE_FIRST_FF;
          if (configured_ == false)
            requestSyncTime();  /* send a msg back showing our protocol version */
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
    3ef4:	2a02      	cmp	r2, #2
    3ef6:	f000 818c 	beq.w	4212 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c2>
        bytes_ = data;
        index_ = 0;
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
    3efa:	2a03      	cmp	r2, #3
    3efc:	f000 8194 	beq.w	4228 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3d8>
      {
        bytes_ += data << 8;
        mode_++;
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
    3f00:	2a04      	cmp	r2, #4
    3f02:	f000 819b 	beq.w	423c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3ec>
        if ((checksum_ % 256) == 255)
          mode_++;
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
    3f06:	2a05      	cmp	r2, #5
    3f08:	f000 81a7 	beq.w	425a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x40a>
      {
        topic_ = data;
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
    3f0c:	2a06      	cmp	r2, #6
    3f0e:	f000 81ac 	beq.w	426a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x41a>
        topic_ += data << 8;
        mode_ = MODE_MESSAGE;
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
    3f12:	2a08      	cmp	r2, #8
    3f14:	d1ba      	bne.n	3e8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
      {
        mode_ = MODE_FIRST_FF;
        if ((checksum_ % 256) == 255)
    3f16:	4a91      	ldr	r2, [pc, #580]	; (415c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x30c>)
    3f18:	401a      	ands	r2, r3
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
    3f1a:	2300      	movs	r3, #0
        if ((checksum_ % 256) == 255)
    3f1c:	429a      	cmp	r2, r3
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
    3f1e:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
        if ((checksum_ % 256) == 255)
    3f22:	f2c0 8214 	blt.w	434e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x4fe>
    3f26:	2aff      	cmp	r2, #255	; 0xff
    3f28:	d1b0      	bne.n	3e8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
        {
          if (topic_ == TopicInfo::ID_PUBLISHER)
    3f2a:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
    3f2e:	2b00      	cmp	r3, #0
    3f30:	f000 8385 	beq.w	463e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x7ee>
            negotiateTopics();
            last_sync_time = c_time;
            last_sync_receive_time = c_time;
            return SPIN_ERR;
          }
          else if (topic_ == TopicInfo::ID_TIME)
    3f34:	2b0a      	cmp	r3, #10
    3f36:	f000 8335 	beq.w	45a4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x754>
          {
            syncTime(message_in);
          }
          else if (topic_ == TopicInfo::ID_PARAMETER_REQUEST)
    3f3a:	2b06      	cmp	r3, #6
    3f3c:	f000 8222 	beq.w	4384 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x534>
          {
            req_param_resp.deserialize(message_in);
            param_received = true;
          }
          else if (topic_ == TopicInfo::ID_TX_STOP)
    3f40:	2b0b      	cmp	r3, #11
    3f42:	f000 8209 	beq.w	4358 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x508>
          {
            configured_ = false;
          }
          else
          {
            if (subscribers[topic_ - 100])
    3f46:	33bc      	adds	r3, #188	; 0xbc
    3f48:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
    3f4c:	2800      	cmp	r0, #0
    3f4e:	d09d      	beq.n	3e8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
              subscribers[topic_ - 100]->callback(message_in);
    3f50:	6803      	ldr	r3, [r0, #0]
    3f52:	4a83      	ldr	r2, [pc, #524]	; (4160 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x310>)
    3f54:	681b      	ldr	r3, [r3, #0]
    3f56:	4293      	cmp	r3, r2
    3f58:	f104 011c 	add.w	r1, r4, #28
    3f5c:	f040 836d 	bne.w	463a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x7ea>
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    3f60:	f894 e01d 	ldrb.w	lr, [r4, #29]
    3f64:	7f27      	ldrb	r7, [r4, #28]
    3f66:	f894 901e 	ldrb.w	r9, [r4, #30]
    3f6a:	f894 8021 	ldrb.w	r8, [r4, #33]	; 0x21
    3f6e:	f894 1020 	ldrb.w	r1, [r4, #32]
    3f72:	f894 c01f 	ldrb.w	ip, [r4, #31]
    3f76:	ea47 270e 	orr.w	r7, r7, lr, lsl #8
    3f7a:	f894 e022 	ldrb.w	lr, [r4, #34]	; 0x22
    3f7e:	ea47 4709 	orr.w	r7, r7, r9, lsl #16
    3f82:	ea41 2108 	orr.w	r1, r1, r8, lsl #8
    3f86:	f894 9023 	ldrb.w	r9, [r4, #35]	; 0x23
    3f8a:	ea41 410e 	orr.w	r1, r1, lr, lsl #16
    3f8e:	ea47 620c 	orr.w	r2, r7, ip, lsl #24
    3f92:	ea41 6309 	orr.w	r3, r1, r9, lsl #24
      this->x = u_x.real;
    3f96:	e9c0 2308 	strd	r2, r3, [r0, #32]
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    3f9a:	f894 1025 	ldrb.w	r1, [r4, #37]	; 0x25
    3f9e:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
    3fa2:	f894 c026 	ldrb.w	ip, [r4, #38]	; 0x26
    3fa6:	f894 e029 	ldrb.w	lr, [r4, #41]	; 0x29
    3faa:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
    3fae:	f894 7027 	ldrb.w	r7, [r4, #39]	; 0x27
    3fb2:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    3fb6:	f894 102a 	ldrb.w	r1, [r4, #42]	; 0x2a
    3fba:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
    3fbe:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
    3fc2:	f894 c02b 	ldrb.w	ip, [r4, #43]	; 0x2b
    3fc6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    3fca:	ea42 6207 	orr.w	r2, r2, r7, lsl #24
    3fce:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
    3fd2:	9200      	str	r2, [sp, #0]
    3fd4:	9301      	str	r3, [sp, #4]
      this->y = u_y.real;
    3fd6:	e9dd 2300 	ldrd	r2, r3, [sp]
    3fda:	e9c0 230a 	strd	r2, r3, [r0, #40]	; 0x28
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    3fde:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    3fe2:	f894 102d 	ldrb.w	r1, [r4, #45]	; 0x2d
    3fe6:	f894 c02e 	ldrb.w	ip, [r4, #46]	; 0x2e
    3fea:	f894 e031 	ldrb.w	lr, [r4, #49]	; 0x31
    3fee:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
    3ff2:	f894 702f 	ldrb.w	r7, [r4, #47]	; 0x2f
    3ff6:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    3ffa:	f894 1032 	ldrb.w	r1, [r4, #50]	; 0x32
    3ffe:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
    4002:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
    4006:	f894 c033 	ldrb.w	ip, [r4, #51]	; 0x33
    400a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    400e:	ea42 6207 	orr.w	r2, r2, r7, lsl #24
    4012:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
    4016:	9202      	str	r2, [sp, #8]
    4018:	9303      	str	r3, [sp, #12]
      this->z = u_z.real;
    401a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    401e:	e9c0 230c 	strd	r2, r3, [r0, #48]	; 0x30
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    4022:	f894 c035 	ldrb.w	ip, [r4, #53]	; 0x35
    4026:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
    402a:	f894 e036 	ldrb.w	lr, [r4, #54]	; 0x36
    402e:	f894 7039 	ldrb.w	r7, [r4, #57]	; 0x39
    4032:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
    4036:	f894 1037 	ldrb.w	r1, [r4, #55]	; 0x37
    403a:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
    403e:	ea42 4e0e 	orr.w	lr, r2, lr, lsl #16
    4042:	f894 203a 	ldrb.w	r2, [r4, #58]	; 0x3a
    4046:	f894 c03b 	ldrb.w	ip, [r4, #59]	; 0x3b
    404a:	ea43 2307 	orr.w	r3, r3, r7, lsl #8
    404e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    4052:	ea4e 6101 	orr.w	r1, lr, r1, lsl #24
    4056:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
    405a:	9104      	str	r1, [sp, #16]
    405c:	9305      	str	r3, [sp, #20]
      this->x = u_x.real;
    405e:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    4062:	e9c0 2310 	strd	r2, r3, [r0, #64]	; 0x40
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    4066:	f894 103d 	ldrb.w	r1, [r4, #61]	; 0x3d
    406a:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
    406e:	f894 c03e 	ldrb.w	ip, [r4, #62]	; 0x3e
    4072:	f894 e041 	ldrb.w	lr, [r4, #65]	; 0x41
    4076:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
    407a:	f894 703f 	ldrb.w	r7, [r4, #63]	; 0x3f
    407e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    4082:	f894 1042 	ldrb.w	r1, [r4, #66]	; 0x42
    4086:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
    408a:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
    408e:	f894 c043 	ldrb.w	ip, [r4, #67]	; 0x43
    4092:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
    4096:	ea41 630c 	orr.w	r3, r1, ip, lsl #24
    409a:	ea42 6207 	orr.w	r2, r2, r7, lsl #24
    409e:	9206      	str	r2, [sp, #24]
    40a0:	9307      	str	r3, [sp, #28]
      this->y = u_y.real;
    40a2:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    40a6:	e9c0 2312 	strd	r2, r3, [r0, #72]	; 0x48
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    40aa:	f894 1044 	ldrb.w	r1, [r4, #68]	; 0x44
    40ae:	f894 2045 	ldrb.w	r2, [r4, #69]	; 0x45
    40b2:	f894 8046 	ldrb.w	r8, [r4, #70]	; 0x46
    40b6:	f894 7048 	ldrb.w	r7, [r4, #72]	; 0x48
    40ba:	f894 3049 	ldrb.w	r3, [r4, #73]	; 0x49
    40be:	f894 e04a 	ldrb.w	lr, [r4, #74]	; 0x4a
    40c2:	f894 c047 	ldrb.w	ip, [r4, #71]	; 0x47
    40c6:	ea41 2202 	orr.w	r2, r1, r2, lsl #8
    40ca:	ea47 2303 	orr.w	r3, r7, r3, lsl #8
    40ce:	f894 104b 	ldrb.w	r1, [r4, #75]	; 0x4b
    40d2:	ea42 4208 	orr.w	r2, r2, r8, lsl #16
    40d6:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
    40da:	ea42 620c 	orr.w	r2, r2, ip, lsl #24
    40de:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    40e2:	9208      	str	r2, [sp, #32]
    40e4:	9309      	str	r3, [sp, #36]	; 0x24
      this->z = u_z.real;
    40e6:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
  };

  virtual void callback(unsigned char* data) override
  {
    msg.deserialize(data);
    this->cb_(msg);
    40ea:	6d81      	ldr	r1, [r0, #88]	; 0x58
    40ec:	e9c0 2314 	strd	r2, r3, [r0, #80]	; 0x50
    40f0:	3010      	adds	r0, #16
    40f2:	4788      	blx	r1
    40f4:	e6ca      	b.n	3e8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
      if (data < 0)
        break;
      checksum_ += data;
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
      {
        message_in[index_++] = data;
    40f6:	f8d4 34f0 	ldr.w	r3, [r4, #1264]	; 0x4f0
    40fa:	18e2      	adds	r2, r4, r3
    40fc:	3301      	adds	r3, #1
    40fe:	f8c4 34f0 	str.w	r3, [r4, #1264]	; 0x4f0
    4102:	7710      	strb	r0, [r2, #28]
        bytes_--;
    4104:	f8d4 34e8 	ldr.w	r3, [r4, #1256]	; 0x4e8
    4108:	3b01      	subs	r3, #1
    410a:	f8c4 34e8 	str.w	r3, [r4, #1256]	; 0x4e8
        if (bytes_ == 0)                 /* is message complete? if so, checksum */
    410e:	2b00      	cmp	r3, #0
    4110:	f47f aebc 	bne.w	3e8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
          mode_ = MODE_MSG_CHECKSUM;
    4114:	2308      	movs	r3, #8
    4116:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    411a:	e6b7      	b.n	3e8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
    411c:	4798      	blx	r3
          // Exit the spin, processing timeout exceeded.
          return SPIN_TIMEOUT;
        }
      }
      int data = hardware_.read();
      if (data < 0)
    411e:	2800      	cmp	r0, #0
    4120:	f6bf aec8 	bge.w	3eb4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x64>
        }
      }
    }

    /* occasionally sync time */
    if (configured_ && ((c_time - last_sync_time) > (SYNC_SECONDS * 500)))
    4124:	f894 04f8 	ldrb.w	r0, [r4, #1272]	; 0x4f8
    4128:	2800      	cmp	r0, #0
    412a:	f43f aedd 	beq.w	3ee8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x98>
    412e:	f8d4 34fc 	ldr.w	r3, [r4, #1276]	; 0x4fc
    4132:	f640 12c4 	movw	r2, #2500	; 0x9c4
    4136:	1aeb      	subs	r3, r5, r3
    4138:	4293      	cmp	r3, r2
    413a:	f200 80aa 	bhi.w	4292 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x442>
    {
      requestSyncTime();
      last_sync_time = c_time;
    }

    return SPIN_OK;
    413e:	2000      	movs	r0, #0
  }
    4140:	b017      	add	sp, #92	; 0x5c
    4142:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      }
      else if (mode_ == MODE_FIRST_FF)
      {
        if (data == 0xff)
        {
          mode_++;
    4146:	2201      	movs	r2, #1
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
    4148:	f105 0314 	add.w	r3, r5, #20
      }
      else if (mode_ == MODE_FIRST_FF)
      {
        if (data == 0xff)
        {
          mode_++;
    414c:	f8c4 24e4 	str.w	r2, [r4, #1252]	; 0x4e4
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
    4150:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
    4154:	e69a      	b.n	3e8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
    4156:	bf00      	nop
    4158:	1fff2c04 	.word	0x1fff2c04
    415c:	800000ff 	.word	0x800000ff
    4160:	0000146d 	.word	0x0000146d
    4164:	00000ec5 	.word	0x00000ec5
          return SPIN_TIMEOUT;
        }
      }
      else if (mode_ == MODE_PROTOCOL_VER)
      {
        if (data == PROTOCOL_VER)
    4168:	28fe      	cmp	r0, #254	; 0xfe
    416a:	d072      	beq.n	4252 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x402>
          mode_++;
        }
        else
        {
          mode_ = MODE_FIRST_FF;
          if (configured_ == false)
    416c:	f894 24f8 	ldrb.w	r2, [r4, #1272]	; 0x4f8
        {
          mode_++;
        }
        else
        {
          mode_ = MODE_FIRST_FF;
    4170:	2300      	movs	r3, #0
    4172:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
          if (configured_ == false)
    4176:	2a00      	cmp	r2, #0
    4178:	f47f ae88 	bne.w	3e8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
    417c:	497d      	ldr	r1, [pc, #500]	; (4374 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x524>)
   */

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    417e:	6823      	ldr	r3, [r4, #0]
    4180:	9113      	str	r1, [sp, #76]	; 0x4c
    4182:	681b      	ldr	r3, [r3, #0]
    4184:	497c      	ldr	r1, [pc, #496]	; (4378 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x528>)
    4186:	9214      	str	r2, [sp, #80]	; 0x50
    4188:	428b      	cmp	r3, r1
    418a:	9215      	str	r2, [sp, #84]	; 0x54
    418c:	f040 80d5 	bne.w	433a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x4ea>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    4190:	21ff      	movs	r1, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    4192:	2008      	movs	r0, #8
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    4194:	23f7      	movs	r3, #247	; 0xf7
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    4196:	27fe      	movs	r7, #254	; 0xfe

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    4198:	f884 121c 	strb.w	r1, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    419c:	210a      	movs	r1, #10
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    419e:	f884 021e 	strb.w	r0, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    41a2:	f884 3220 	strb.w	r3, [r4, #544]	; 0x220
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->data.sec >> (8 * 0)) & 0xFF;
    41a6:	f884 2223 	strb.w	r2, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->data.sec >> (8 * 1)) & 0xFF;
    41aa:	f884 2224 	strb.w	r2, [r4, #548]	; 0x224
      *(outbuffer + offset + 2) = (this->data.sec >> (8 * 2)) & 0xFF;
    41ae:	f884 2225 	strb.w	r2, [r4, #549]	; 0x225
      *(outbuffer + offset + 3) = (this->data.sec >> (8 * 3)) & 0xFF;
    41b2:	f884 2226 	strb.w	r2, [r4, #550]	; 0x226
      offset += sizeof(this->data.sec);
      *(outbuffer + offset + 0) = (this->data.nsec >> (8 * 0)) & 0xFF;
    41b6:	f884 2227 	strb.w	r2, [r4, #551]	; 0x227
      *(outbuffer + offset + 1) = (this->data.nsec >> (8 * 1)) & 0xFF;
    41ba:	f884 2228 	strb.w	r2, [r4, #552]	; 0x228
      *(outbuffer + offset + 2) = (this->data.nsec >> (8 * 2)) & 0xFF;
    41be:	f884 2229 	strb.w	r2, [r4, #553]	; 0x229
      *(outbuffer + offset + 3) = (this->data.nsec >> (8 * 3)) & 0xFF;
    41c2:	f884 222a 	strb.w	r2, [r4, #554]	; 0x22a

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    41c6:	f884 221f 	strb.w	r2, [r4, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    41ca:	f884 2222 	strb.w	r2, [r4, #546]	; 0x222
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    41ce:	f884 721d 	strb.w	r7, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    41d2:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    41d6:	f204 2321 	addw	r3, r4, #545	; 0x221
    41da:	f204 202a 	addw	r0, r4, #554	; 0x22a
    41de:	e001      	b.n	41e4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x394>
    41e0:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    41e4:	4298      	cmp	r0, r3
      chk += message_out[i];
    41e6:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    41e8:	d1fa      	bne.n	41e0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x390>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    41ea:	43d2      	mvns	r2, r2
    41ec:	6867      	ldr	r7, [r4, #4]
    41ee:	f884 222b 	strb.w	r2, [r4, #555]	; 0x22b
    void write(uint8_t* data, int length){
      iostream->write(data, length);
    41f2:	683b      	ldr	r3, [r7, #0]
    41f4:	4a61      	ldr	r2, [pc, #388]	; (437c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x52c>)
    41f6:	685b      	ldr	r3, [r3, #4]
    41f8:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    41fa:	f504 7007 	add.w	r0, r4, #540	; 0x21c
    41fe:	f040 80a1 	bne.w	4344 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x4f4>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    4202:	2110      	movs	r1, #16
    4204:	f003 fc32 	bl	7a6c <usb_serial_write>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4208:	6833      	ldr	r3, [r6, #0]
    420a:	930d      	str	r3, [sp, #52]	; 0x34
	return ret;
    420c:	9b0d      	ldr	r3, [sp, #52]	; 0x34

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    rt_time = hardware_.time();
    420e:	60e3      	str	r3, [r4, #12]
    4210:	e63c      	b.n	3e8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
        index_ = 0;
    4212:	2200      	movs	r2, #0
        mode_++;
    4214:	2303      	movs	r3, #3
            requestSyncTime();  /* send a msg back showing our protocol version */
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
    4216:	f8c4 04e8 	str.w	r0, [r4, #1256]	; 0x4e8
        index_ = 0;
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
    421a:	f8c4 04f4 	str.w	r0, [r4, #1268]	; 0x4f4
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
        index_ = 0;
    421e:	f8c4 24f0 	str.w	r2, [r4, #1264]	; 0x4f0
        mode_++;
    4222:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    4226:	e631      	b.n	3e8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
      {
        bytes_ += data << 8;
    4228:	f8d4 34e8 	ldr.w	r3, [r4, #1256]	; 0x4e8
    422c:	eb03 2000 	add.w	r0, r3, r0, lsl #8
        mode_++;
    4230:	2304      	movs	r3, #4
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
      {
        bytes_ += data << 8;
    4232:	f8c4 04e8 	str.w	r0, [r4, #1256]	; 0x4e8
        mode_++;
    4236:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    423a:	e627      	b.n	3e8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
      {
        if ((checksum_ % 256) == 255)
    423c:	4a50      	ldr	r2, [pc, #320]	; (4380 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x530>)
    423e:	401a      	ands	r2, r3
    4240:	2a00      	cmp	r2, #0
    4242:	db75      	blt.n	4330 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x4e0>
    4244:	2aff      	cmp	r2, #255	; 0xff
          mode_++;
    4246:	bf0c      	ite	eq
    4248:	2305      	moveq	r3, #5
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
    424a:	2300      	movne	r3, #0
    424c:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    4250:	e61c      	b.n	3e8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
      }
      else if (mode_ == MODE_PROTOCOL_VER)
      {
        if (data == PROTOCOL_VER)
        {
          mode_++;
    4252:	2302      	movs	r3, #2
    4254:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    4258:	e618      	b.n	3e8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
        mode_++;
    425a:	2306      	movs	r3, #6
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
    425c:	f8c4 04ec 	str.w	r0, [r4, #1260]	; 0x4ec
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
    4260:	f8c4 04f4 	str.w	r0, [r4, #1268]	; 0x4f4
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
        mode_++;
    4264:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    4268:	e610      	b.n	3e8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    426a:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
        mode_ = MODE_MESSAGE;
        if (bytes_ == 0)
    426e:	f8d4 24e8 	ldr.w	r2, [r4, #1256]	; 0x4e8
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    4272:	eb03 2300 	add.w	r3, r3, r0, lsl #8
        mode_ = MODE_MESSAGE;
    4276:	2107      	movs	r1, #7
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    4278:	f8c4 34ec 	str.w	r3, [r4, #1260]	; 0x4ec
        mode_ = MODE_MESSAGE;
    427c:	f8c4 14e4 	str.w	r1, [r4, #1252]	; 0x4e4
        if (bytes_ == 0)
    4280:	2a00      	cmp	r2, #0
    4282:	f43f af47 	beq.w	4114 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x2c4>
    4286:	e601      	b.n	3e8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
        // based on the application in use, the hardware buffer could be flushed
        // and start fresh.
        if ((hardware_.time() - c_time) > spin_timeout_)
        {
          // Exit the spin, processing timeout exceeded.
          return SPIN_TIMEOUT;
    4288:	f06f 0001 	mvn.w	r0, #1
      requestSyncTime();
      last_sync_time = c_time;
    }

    return SPIN_OK;
  }
    428c:	b017      	add	sp, #92	; 0x5c
    428e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    public:
      typedef ros::Time _data_type;
      _data_type data;

    Time():
      data()
    4292:	4a38      	ldr	r2, [pc, #224]	; (4374 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x524>)
   */

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    4294:	6823      	ldr	r3, [r4, #0]
    4296:	9213      	str	r2, [sp, #76]	; 0x4c
    4298:	681b      	ldr	r3, [r3, #0]
    429a:	4937      	ldr	r1, [pc, #220]	; (4378 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x528>)
    429c:	2200      	movs	r2, #0
    429e:	428b      	cmp	r3, r1
    42a0:	9214      	str	r2, [sp, #80]	; 0x50
    42a2:	9215      	str	r2, [sp, #84]	; 0x54
    42a4:	d15c      	bne.n	4360 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x510>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    42a6:	21ff      	movs	r1, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    42a8:	2008      	movs	r0, #8
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    42aa:	23f7      	movs	r3, #247	; 0xf7
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    42ac:	27fe      	movs	r7, #254	; 0xfe

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    42ae:	f884 121c 	strb.w	r1, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    42b2:	210a      	movs	r1, #10
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    42b4:	f884 021e 	strb.w	r0, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    42b8:	f884 3220 	strb.w	r3, [r4, #544]	; 0x220
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->data.sec >> (8 * 0)) & 0xFF;
    42bc:	f884 2223 	strb.w	r2, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->data.sec >> (8 * 1)) & 0xFF;
    42c0:	f884 2224 	strb.w	r2, [r4, #548]	; 0x224
      *(outbuffer + offset + 2) = (this->data.sec >> (8 * 2)) & 0xFF;
    42c4:	f884 2225 	strb.w	r2, [r4, #549]	; 0x225
      *(outbuffer + offset + 3) = (this->data.sec >> (8 * 3)) & 0xFF;
    42c8:	f884 2226 	strb.w	r2, [r4, #550]	; 0x226
      offset += sizeof(this->data.sec);
      *(outbuffer + offset + 0) = (this->data.nsec >> (8 * 0)) & 0xFF;
    42cc:	f884 2227 	strb.w	r2, [r4, #551]	; 0x227
      *(outbuffer + offset + 1) = (this->data.nsec >> (8 * 1)) & 0xFF;
    42d0:	f884 2228 	strb.w	r2, [r4, #552]	; 0x228
      *(outbuffer + offset + 2) = (this->data.nsec >> (8 * 2)) & 0xFF;
    42d4:	f884 2229 	strb.w	r2, [r4, #553]	; 0x229
      *(outbuffer + offset + 3) = (this->data.nsec >> (8 * 3)) & 0xFF;
    42d8:	f884 222a 	strb.w	r2, [r4, #554]	; 0x22a

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    42dc:	f884 221f 	strb.w	r2, [r4, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    42e0:	f884 2222 	strb.w	r2, [r4, #546]	; 0x222
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    42e4:	f884 721d 	strb.w	r7, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    42e8:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    42ec:	f204 2321 	addw	r3, r4, #545	; 0x221
    42f0:	f204 202a 	addw	r0, r4, #554	; 0x22a
    42f4:	e001      	b.n	42fa <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x4aa>
    42f6:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    42fa:	4283      	cmp	r3, r0
      chk += message_out[i];
    42fc:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    42fe:	d1fa      	bne.n	42f6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x4a6>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    4300:	43d2      	mvns	r2, r2
    4302:	6867      	ldr	r7, [r4, #4]
    4304:	f884 222b 	strb.w	r2, [r4, #555]	; 0x22b
    4308:	683b      	ldr	r3, [r7, #0]
    430a:	4a1c      	ldr	r2, [pc, #112]	; (437c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x52c>)
    430c:	685b      	ldr	r3, [r3, #4]
    430e:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    4310:	f504 7007 	add.w	r0, r4, #540	; 0x21c
    4314:	d129      	bne.n	436a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x51a>
    4316:	2110      	movs	r1, #16
    4318:	f003 fba8 	bl	7a6c <usb_serial_write>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    431c:	6833      	ldr	r3, [r6, #0]
    431e:	930f      	str	r3, [sp, #60]	; 0x3c
	return ret;
    4320:	9b0f      	ldr	r3, [sp, #60]	; 0x3c

    /* occasionally sync time */
    if (configured_ && ((c_time - last_sync_time) > (SYNC_SECONDS * 500)))
    {
      requestSyncTime();
      last_sync_time = c_time;
    4322:	f8c4 54fc 	str.w	r5, [r4, #1276]	; 0x4fc
    }

    return SPIN_OK;
    4326:	2000      	movs	r0, #0

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    rt_time = hardware_.time();
    4328:	60e3      	str	r3, [r4, #12]
      requestSyncTime();
      last_sync_time = c_time;
    }

    return SPIN_OK;
  }
    432a:	b017      	add	sp, #92	; 0x5c
    432c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        bytes_ += data << 8;
        mode_++;
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
      {
        if ((checksum_ % 256) == 255)
    4330:	3a01      	subs	r2, #1
    4332:	f062 02ff 	orn	r2, r2, #255	; 0xff
    4336:	3201      	adds	r2, #1
    4338:	e784      	b.n	4244 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3f4>
   */

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    433a:	aa13      	add	r2, sp, #76	; 0x4c
    433c:	210a      	movs	r1, #10
    433e:	4620      	mov	r0, r4
    4340:	4798      	blx	r3
    4342:	e761      	b.n	4208 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3b8>
    4344:	4601      	mov	r1, r0
    4346:	2210      	movs	r2, #16
    4348:	4638      	mov	r0, r7
    434a:	4798      	blx	r3
    434c:	e75c      	b.n	4208 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3b8>
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
        if ((checksum_ % 256) == 255)
    434e:	3a01      	subs	r2, #1
    4350:	f062 02ff 	orn	r2, r2, #255	; 0xff
    4354:	3201      	adds	r2, #1
    4356:	e5e6      	b.n	3f26 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0xd6>
            req_param_resp.deserialize(message_in);
            param_received = true;
          }
          else if (topic_ == TopicInfo::ID_TX_STOP)
          {
            configured_ = false;
    4358:	2300      	movs	r3, #0
    435a:	f884 34f8 	strb.w	r3, [r4, #1272]	; 0x4f8
    435e:	e595      	b.n	3e8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
   */

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    4360:	aa13      	add	r2, sp, #76	; 0x4c
    4362:	210a      	movs	r1, #10
    4364:	4620      	mov	r0, r4
    4366:	4798      	blx	r3
    4368:	e7d8      	b.n	431c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x4cc>
    436a:	4601      	mov	r1, r0
    436c:	2210      	movs	r2, #16
    436e:	4638      	mov	r0, r7
    4370:	4798      	blx	r3
    4372:	e7d3      	b.n	431c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x4cc>
    4374:	0000bc24 	.word	0x0000bc24
    4378:	00001a4d 	.word	0x00001a4d
    437c:	00000ebd 	.word	0x00000ebd
    4380:	800000ff 	.word	0x800000ff
    {
      int offset = 0;
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    4384:	7f22      	ldrb	r2, [r4, #28]
    4386:	7f63      	ldrb	r3, [r4, #29]
    4388:	f894 801e 	ldrb.w	r8, [r4, #30]
    438c:	7fe1      	ldrb	r1, [r4, #31]
    438e:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    4392:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
    4396:	f8d4 2510 	ldr.w	r2, [r4, #1296]	; 0x510
    {
      int offset = 0;
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    439a:	ea43 6801 	orr.w	r8, r3, r1, lsl #24
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
    439e:	4590      	cmp	r8, r2
          {
            syncTime(message_in);
          }
          else if (topic_ == TopicInfo::ID_PARAMETER_REQUEST)
          {
            req_param_resp.deserialize(message_in);
    43a0:	f104 071c 	add.w	r7, r4, #28
    43a4:	d907      	bls.n	43b6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x566>
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
    43a6:	ea4f 0188 	mov.w	r1, r8, lsl #2
    43aa:	f8d4 0518 	ldr.w	r0, [r4, #1304]	; 0x518
    43ae:	f006 fdf5 	bl	af9c <realloc>
    43b2:	f8c4 0518 	str.w	r0, [r4, #1304]	; 0x518
      ints_length = ints_lengthT;
    43b6:	f8c4 8510 	str.w	r8, [r4, #1296]	; 0x510
      for( uint32_t i = 0; i < ints_length; i++){
    43ba:	f1b8 0f00 	cmp.w	r8, #0
    43be:	f000 8156 	beq.w	466e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x81e>
    43c2:	f204 5314 	addw	r3, r4, #1300	; 0x514
    43c6:	9300      	str	r3, [sp, #0]
    43c8:	46b8      	mov	r8, r7
    43ca:	f04f 0904 	mov.w	r9, #4
    43ce:	f04f 0b00 	mov.w	fp, #0
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
    43d2:	f898 3006 	ldrb.w	r3, [r8, #6]
    43d6:	f898 0005 	ldrb.w	r0, [r8, #5]
    43da:	f898 2004 	ldrb.w	r2, [r8, #4]
    43de:	f898 1007 	ldrb.w	r1, [r8, #7]
    43e2:	041b      	lsls	r3, r3, #16
    43e4:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
    43e8:	4313      	orrs	r3, r2
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
    43ea:	f8d4 0518 	ldr.w	r0, [r4, #1304]	; 0x518
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
    43ee:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    43f2:	f8c4 3514 	str.w	r3, [r4, #1300]	; 0x514
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
    43f6:	eb00 008b 	add.w	r0, r0, fp, lsl #2
    43fa:	2204      	movs	r2, #4
    43fc:	9900      	ldr	r1, [sp, #0]
    43fe:	f002 f81d 	bl	643c <memcpy>
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
      ints_length = ints_lengthT;
      for( uint32_t i = 0; i < ints_length; i++){
    4402:	f8d4 3510 	ldr.w	r3, [r4, #1296]	; 0x510
    4406:	f10b 0b01 	add.w	fp, fp, #1
    440a:	455b      	cmp	r3, fp
    440c:	464a      	mov	r2, r9
    440e:	f108 0804 	add.w	r8, r8, #4
    4412:	f109 0904 	add.w	r9, r9, #4
    4416:	d8dc      	bhi.n	43d2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x582>
    4418:	f102 0309 	add.w	r3, r2, #9
    441c:	f102 0b08 	add.w	fp, r2, #8
    4420:	f102 010b 	add.w	r1, r2, #11
    4424:	f102 0e05 	add.w	lr, r2, #5
    4428:	f102 0c06 	add.w	ip, r2, #6
    442c:	f102 0807 	add.w	r8, r2, #7
    4430:	9300      	str	r3, [sp, #0]
    4432:	f102 030a 	add.w	r3, r2, #10
    4436:	320c      	adds	r2, #12
    4438:	4648      	mov	r0, r9
    443a:	9102      	str	r1, [sp, #8]
    443c:	46d9      	mov	r9, fp
    443e:	9204      	str	r2, [sp, #16]
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    4440:	f817 200c 	ldrb.w	r2, [r7, ip]
    4444:	f817 c00e 	ldrb.w	ip, [r7, lr]
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    4448:	5c38      	ldrb	r0, [r7, r0]
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    444a:	f817 e008 	ldrb.w	lr, [r7, r8]
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
    444e:	f8d4 151c 	ldr.w	r1, [r4, #1308]	; 0x51c
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    4452:	0412      	lsls	r2, r2, #16
    4454:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
    4458:	4310      	orrs	r0, r2
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    445a:	ea40 680e 	orr.w	r8, r0, lr, lsl #24
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
    445e:	4588      	cmp	r8, r1
    4460:	d909      	bls.n	4476 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x626>
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
    4462:	ea4f 0188 	mov.w	r1, r8, lsl #2
    4466:	f8d4 0524 	ldr.w	r0, [r4, #1316]	; 0x524
    446a:	9306      	str	r3, [sp, #24]
    446c:	f006 fd96 	bl	af9c <realloc>
    4470:	9b06      	ldr	r3, [sp, #24]
    4472:	f8c4 0524 	str.w	r0, [r4, #1316]	; 0x524
      floats_length = floats_lengthT;
    4476:	f8c4 851c 	str.w	r8, [r4, #1308]	; 0x51c
      for( uint32_t i = 0; i < floats_length; i++){
    447a:	f1b8 0f00 	cmp.w	r8, #0
    447e:	f000 8108 	beq.w	4692 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x842>
    4482:	f504 63a4 	add.w	r3, r4, #1312	; 0x520
    4486:	9300      	str	r3, [sp, #0]
    4488:	f204 530c 	addw	r3, r4, #1292	; 0x50c
    448c:	eb07 0809 	add.w	r8, r7, r9
    4490:	f04f 0b00 	mov.w	fp, #0
    4494:	9302      	str	r3, [sp, #8]
      } u_st_floats;
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    4496:	f898 1002 	ldrb.w	r1, [r8, #2]
    449a:	f898 3001 	ldrb.w	r3, [r8, #1]
    449e:	f898 2000 	ldrb.w	r2, [r8]
    44a2:	f898 e003 	ldrb.w	lr, [r8, #3]
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    44a6:	f8d4 0524 	ldr.w	r0, [r4, #1316]	; 0x524
      } u_st_floats;
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    44aa:	0409      	lsls	r1, r1, #16
    44ac:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
    44b0:	4313      	orrs	r3, r2
      this->st_floats = u_st_floats.real;
    44b2:	9a02      	ldr	r2, [sp, #8]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    44b4:	9900      	ldr	r1, [sp, #0]
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
    44b6:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
    44ba:	6153      	str	r3, [r2, #20]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    44bc:	eb00 008b 	add.w	r0, r0, fp, lsl #2
    44c0:	2204      	movs	r2, #4
    44c2:	f001 ffbb 	bl	643c <memcpy>
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
      floats_length = floats_lengthT;
      for( uint32_t i = 0; i < floats_length; i++){
    44c6:	f8d4 351c 	ldr.w	r3, [r4, #1308]	; 0x51c
    44ca:	f10b 0b01 	add.w	fp, fp, #1
    44ce:	455b      	cmp	r3, fp
    44d0:	464a      	mov	r2, r9
    44d2:	f108 0804 	add.w	r8, r8, #4
    44d6:	f109 0904 	add.w	r9, r9, #4
    44da:	d8dc      	bhi.n	4496 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x646>
    44dc:	1d53      	adds	r3, r2, #5
    44de:	1dd1      	adds	r1, r2, #7
    44e0:	9300      	str	r3, [sp, #0]
    44e2:	46cb      	mov	fp, r9
    44e4:	1d93      	adds	r3, r2, #6
    44e6:	9102      	str	r1, [sp, #8]
    44e8:	f102 0808 	add.w	r8, r2, #8
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    44ec:	5cf9      	ldrb	r1, [r7, r3]
    44ee:	9b00      	ldr	r3, [sp, #0]
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    44f0:	9a02      	ldr	r2, [sp, #8]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    44f2:	5cf8      	ldrb	r0, [r7, r3]
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    44f4:	f817 300b 	ldrb.w	r3, [r7, fp]
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    44f8:	f817 9002 	ldrb.w	r9, [r7, r2]
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
    44fc:	f8d4 2528 	ldr.w	r2, [r4, #1320]	; 0x528
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    4500:	0409      	lsls	r1, r1, #16
    4502:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
    4506:	430b      	orrs	r3, r1
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    4508:	ea43 6909 	orr.w	r9, r3, r9, lsl #24
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
    450c:	4591      	cmp	r9, r2
    450e:	d907      	bls.n	4520 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x6d0>
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
    4510:	ea4f 0189 	mov.w	r1, r9, lsl #2
    4514:	f8d4 0530 	ldr.w	r0, [r4, #1328]	; 0x530
    4518:	f006 fd40 	bl	af9c <realloc>
    451c:	f8c4 0530 	str.w	r0, [r4, #1328]	; 0x530
      strings_length = strings_lengthT;
    4520:	f8c4 9528 	str.w	r9, [r4, #1320]	; 0x528
      for( uint32_t i = 0; i < strings_length; i++){
    4524:	f1b9 0f00 	cmp.w	r9, #0
    4528:	d038      	beq.n	459c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x74c>
    452a:	f04f 0900 	mov.w	r9, #0
    452e:	f204 532c 	addw	r3, r4, #1324	; 0x52c
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    4532:	46cb      	mov	fp, r9
    4534:	9300      	str	r3, [sp, #0]
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
      uint32_t length_st_strings;
      arrToVar(length_st_strings, (inbuffer + offset));
    4536:	2300      	movs	r3, #0

  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    4538:	469e      	mov	lr, r3
    453a:	eb07 0108 	add.w	r1, r7, r8
    for (size_t i = 0; i < sizeof(V); i++)
      var |= (arr[i] << (8 * i));
    453e:	f811 2b01 	ldrb.w	r2, [r1], #1
    4542:	409a      	lsls	r2, r3
    4544:	3308      	adds	r3, #8
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
    4546:	2b20      	cmp	r3, #32
      var |= (arr[i] << (8 * i));
    4548:	ea4e 0e02 	orr.w	lr, lr, r2
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
    454c:	d1f7      	bne.n	453e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x6ee>
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
    454e:	f108 0104 	add.w	r1, r8, #4
    4552:	448e      	add	lr, r1
    4554:	4571      	cmp	r1, lr
    4556:	d20a      	bcs.n	456e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x71e>
    4558:	f108 0303 	add.w	r3, r8, #3
    455c:	443b      	add	r3, r7
    455e:	460a      	mov	r2, r1
    4560:	3201      	adds	r2, #1
          inbuffer[k-1]=inbuffer[k];
    4562:	f813 0f01 	ldrb.w	r0, [r3, #1]!
    4566:	f803 0c01 	strb.w	r0, [r3, #-1]
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
      uint32_t length_st_strings;
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
    456a:	4572      	cmp	r2, lr
    456c:	d3f8      	bcc.n	4560 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x710>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    456e:	eb07 020e 	add.w	r2, r7, lr
      this->st_strings = (char *)(inbuffer + offset-1);
    4572:	1e4b      	subs	r3, r1, #1
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    4574:	f802 bc01 	strb.w	fp, [r2, #-1]
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    4578:	f8d4 0530 	ldr.w	r0, [r4, #1328]	; 0x530
    457c:	9900      	ldr	r1, [sp, #0]
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
    457e:	443b      	add	r3, r7
    4580:	f8c4 352c 	str.w	r3, [r4, #1324]	; 0x52c
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    4584:	eb00 0089 	add.w	r0, r0, r9, lsl #2
    4588:	2204      	movs	r2, #4
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
    458a:	46f0      	mov	r8, lr
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    458c:	f001 ff56 	bl	643c <memcpy>
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
    4590:	f8d4 3528 	ldr.w	r3, [r4, #1320]	; 0x528
    4594:	f109 0901 	add.w	r9, r9, #1
    4598:	454b      	cmp	r3, r9
    459a:	d8cc      	bhi.n	4536 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x6e6>
            param_received = true;
    459c:	2301      	movs	r3, #1
    459e:	f884 3508 	strb.w	r3, [r4, #1288]	; 0x508
    45a2:	e473      	b.n	3e8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    45a4:	6833      	ldr	r3, [r6, #0]
    45a6:	9310      	str	r3, [sp, #64]	; 0x40
	return ret;
    45a8:	9f10      	ldr	r7, [sp, #64]	; 0x40
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    45aa:	6831      	ldr	r1, [r6, #0]
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    45ac:	7f23      	ldrb	r3, [r4, #28]
    45ae:	9112      	str	r1, [sp, #72]	; 0x48
    45b0:	7f61      	ldrb	r1, [r4, #29]
  }

  void syncTime(uint8_t * data)
  {
    std_msgs::Time t;
    uint32_t offset = hardware_.time() - rt_time;
    45b2:	68e0      	ldr	r0, [r4, #12]
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    45b4:	f894 c021 	ldrb.w	ip, [r4, #33]	; 0x21
    45b8:	f894 2020 	ldrb.w	r2, [r4, #32]
    45bc:	f894 e022 	ldrb.w	lr, [r4, #34]	; 0x22
    45c0:	f894 8023 	ldrb.w	r8, [r4, #35]	; 0x23

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    45c4:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 46a0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x850>
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    45c8:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    45cc:	4b32      	ldr	r3, [pc, #200]	; (4698 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x848>)
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    45ce:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
  }

  void syncTime(uint8_t * data)
  {
    std_msgs::Time t;
    uint32_t offset = hardware_.time() - rt_time;
    45d2:	1a3f      	subs	r7, r7, r0
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    45d4:	f894 c01e 	ldrb.w	ip, [r4, #30]
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    45d8:	fba3 3007 	umull	r3, r0, r3, r7
    45dc:	7fe3      	ldrb	r3, [r4, #31]
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    45de:	ea42 4e0e 	orr.w	lr, r2, lr, lsl #16
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    45e2:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
	return ret;
    45e6:	9a12      	ldr	r2, [sp, #72]	; 0x48
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    45e8:	ea4e 6e08 	orr.w	lr, lr, r8, lsl #24
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    45ec:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    45f0:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 46a4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x854>
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    45f4:	4b28      	ldr	r3, [pc, #160]	; (4698 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x848>)
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    45f6:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    45fa:	0980      	lsrs	r0, r0, #6
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    45fc:	44f0      	add	r8, lr
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    45fe:	fba3 3e02 	umull	r3, lr, r3, r2
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    4602:	fb0c 7710 	mls	r7, ip, r0, r7
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    4606:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
    460a:	3901      	subs	r1, #1
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    460c:	fb0c 221e 	mls	r2, ip, lr, r2
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    4610:	4408      	add	r0, r1
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    4612:	fb09 8707 	mla	r7, r9, r7, r8
    4616:	4621      	mov	r1, r4
    4618:	fb09 7312 	mls	r3, r9, r2, r7
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    461c:	ebce 0200 	rsb	r2, lr, r0
    4620:	6122      	str	r2, [r4, #16]
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    normalizeSecNSec(sec_offset, nsec_offset);
    4622:	f104 0010 	add.w	r0, r4, #16

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    4626:	f841 3f14 	str.w	r3, [r1, #20]!
    normalizeSecNSec(sec_offset, nsec_offset);
    462a:	f001 fef3 	bl	6414 <ros::normalizeSecNSec(unsigned long&, unsigned long&)>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    462e:	6833      	ldr	r3, [r6, #0]
    4630:	9311      	str	r3, [sp, #68]	; 0x44
	return ret;
    4632:	9b11      	ldr	r3, [sp, #68]	; 0x44
    t.deserialize(data);
    t.data.sec += offset / 1000;
    t.data.nsec += (offset % 1000) * 1000000UL;

    this->setNow(t.data);
    last_sync_receive_time = hardware_.time();
    4634:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
    4638:	e428      	b.n	3e8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
            configured_ = false;
          }
          else
          {
            if (subscribers[topic_ - 100])
              subscribers[topic_ - 100]->callback(message_in);
    463a:	4798      	blx	r3
    463c:	e426      	b.n	3e8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
   */

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    463e:	6822      	ldr	r2, [r4, #0]
    public:
      typedef ros::Time _data_type;
      _data_type data;

    Time():
      data()
    4640:	4916      	ldr	r1, [pc, #88]	; (469c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x84c>)
    4642:	9113      	str	r1, [sp, #76]	; 0x4c
    4644:	9314      	str	r3, [sp, #80]	; 0x50
    4646:	9315      	str	r3, [sp, #84]	; 0x54
    4648:	210a      	movs	r1, #10
    464a:	6813      	ldr	r3, [r2, #0]
    464c:	4620      	mov	r0, r4
    464e:	aa13      	add	r2, sp, #76	; 0x4c
    4650:	4798      	blx	r3
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4652:	6833      	ldr	r3, [r6, #0]
    4654:	930e      	str	r3, [sp, #56]	; 0x38
	return ret;
    4656:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    rt_time = hardware_.time();
    4658:	60e3      	str	r3, [r4, #12]
        if ((checksum_ % 256) == 255)
        {
          if (topic_ == TopicInfo::ID_PUBLISHER)
          {
            requestSyncTime();
            negotiateTopics();
    465a:	4620      	mov	r0, r4
    465c:	f7ff f95a 	bl	3914 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()>
            last_sync_time = c_time;
    4660:	f8c4 54fc 	str.w	r5, [r4, #1276]	; 0x4fc
            last_sync_receive_time = c_time;
    4664:	f8c4 5500 	str.w	r5, [r4, #1280]	; 0x500
            return SPIN_ERR;
    4668:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    466c:	e43c      	b.n	3ee8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x98>
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
      ints_length = ints_lengthT;
      for( uint32_t i = 0; i < ints_length; i++){
    466e:	230c      	movs	r3, #12
    4670:	f04f 0b08 	mov.w	fp, #8
    4674:	9304      	str	r3, [sp, #16]
    4676:	2209      	movs	r2, #9
    4678:	230b      	movs	r3, #11
    467a:	9302      	str	r3, [sp, #8]
    467c:	46d9      	mov	r9, fp
    467e:	230a      	movs	r3, #10
    4680:	9200      	str	r2, [sp, #0]
    4682:	f04f 0807 	mov.w	r8, #7
    4686:	f04f 0c06 	mov.w	ip, #6
    468a:	f04f 0e05 	mov.w	lr, #5
    468e:	2004      	movs	r0, #4
    4690:	e6d6      	b.n	4440 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x5f0>
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
      floats_length = floats_lengthT;
      for( uint32_t i = 0; i < floats_length; i++){
    4692:	f8dd 8010 	ldr.w	r8, [sp, #16]
    4696:	e729      	b.n	44ec <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x69c>
    4698:	10624dd3 	.word	0x10624dd3
    469c:	0000bc24 	.word	0x0000bc24
    46a0:	000f4240 	.word	0x000f4240
    46a4:	3b9aca00 	.word	0x3b9aca00

000046a8 <_GLOBAL__sub_I_bmp>:
    //speed_pub.publish(&wheel_speed);
  }
  nh.spinOnce();
  //}
  //delay(100);
  }
    46a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#include <geometry_msgs/Vector3.h>
#include <geometry_msgs/Quaternion.h>
#include <geometry_msgs/Twist.h>
#include <custom_msgs/odom_and_imu.h>

Adafruit_BMP280 bmp; // use I2C interface
    46aa:	4c75      	ldr	r4, [pc, #468]	; (4880 <_GLOBAL__sub_I_bmp+0x1d8>)
    46ac:	4975      	ldr	r1, [pc, #468]	; (4884 <_GLOBAL__sub_I_bmp+0x1dc>)
template<class Hardware,
         int MAX_SUBSCRIBERS = 25,
         int MAX_PUBLISHERS = 25,
         int INPUT_SIZE = 512,
         int OUTPUT_SIZE = 512>
class NodeHandle_ : public NodeHandleBase_
    46ae:	4d76      	ldr	r5, [pc, #472]	; (4888 <_GLOBAL__sub_I_bmp+0x1e0>)
      /* Leonardo support */
      iostream = &Serial1;
#elif defined(USE_TEENSY_HW_SERIAL) or defined(USE_STM32_HW_SERIAL)
      iostream = &Serial1;
#else
      iostream = &Serial;
    46b0:	4e76      	ldr	r6, [pc, #472]	; (488c <_GLOBAL__sub_I_bmp+0x1e4>)
    46b2:	4620      	mov	r0, r4
    46b4:	f000 fee2 	bl	547c <Adafruit_BMP280::Adafruit_BMP280(TwoWire*)>
    46b8:	4a75      	ldr	r2, [pc, #468]	; (4890 <_GLOBAL__sub_I_bmp+0x1e8>)
    46ba:	4976      	ldr	r1, [pc, #472]	; (4894 <_GLOBAL__sub_I_bmp+0x1ec>)
    46bc:	4620      	mov	r0, r4
    46be:	f005 f903 	bl	98c8 <__aeabi_atexit>
Adafruit_Sensor *bmp_temp = bmp.getTemperatureSensor();
    46c2:	4620      	mov	r0, r4
    46c4:	f001 f9ee 	bl	5aa4 <Adafruit_BMP280::getTemperatureSensor()>
    46c8:	4b73      	ldr	r3, [pc, #460]	; (4898 <_GLOBAL__sub_I_bmp+0x1f0>)
    46ca:	6018      	str	r0, [r3, #0]
Adafruit_Sensor *bmp_pressure = bmp.getPressureSensor();
    46cc:	4620      	mov	r0, r4
    46ce:	f001 f9eb 	bl	5aa8 <Adafruit_BMP280::getPressureSensor()>
    46d2:	4b72      	ldr	r3, [pc, #456]	; (489c <_GLOBAL__sub_I_bmp+0x1f4>)
    46d4:	6018      	str	r0, [r3, #0]
int left_count_tick;
const float wheel_base = 0.229;            // needs to be updated and use the right unit (proberbly meters)
const float wheel_radius = 0.04;           // needs to be updated and use the right unit (proberbly meters)
int16_t accel_X, accel_Y, accel_Z, tmp, gyro_X, gyro_Y, gyro_Z, mx, my, mz;
long publisher_timer;
MPU9250 accelgyro;
    46d6:	4872      	ldr	r0, [pc, #456]	; (48a0 <_GLOBAL__sub_I_bmp+0x1f8>)
    46d8:	f000 fdc6 	bl	5268 <MPU9250::MPU9250()>
    46dc:	4b71      	ldr	r3, [pc, #452]	; (48a4 <_GLOBAL__sub_I_bmp+0x1fc>)
    46de:	602b      	str	r3, [r5, #0]
    46e0:	2400      	movs	r4, #0
#endif
      baud_ = 57600;
    46e2:	f44f 4361 	mov.w	r3, #57600	; 0xe100
    46e6:	f44f 7700 	mov.w	r7, #512	; 0x200
    46ea:	60ab      	str	r3, [r5, #8]
    46ec:	4621      	mov	r1, r4
    46ee:	463a      	mov	r2, r7
      /* Leonardo support */
      iostream = &Serial1;
#elif defined(USE_TEENSY_HW_SERIAL) or defined(USE_STM32_HW_SERIAL)
      iostream = &Serial1;
#else
      iostream = &Serial;
    46f0:	606e      	str	r6, [r5, #4]
    46f2:	f105 001c 	add.w	r0, r5, #28
    46f6:	60ec      	str	r4, [r5, #12]
    46f8:	612c      	str	r4, [r5, #16]
    46fa:	616c      	str	r4, [r5, #20]
    46fc:	61ac      	str	r4, [r5, #24]
    46fe:	2664      	movs	r6, #100	; 0x64
    4700:	f006 fbfa 	bl	aef8 <memset>
    4704:	463a      	mov	r2, r7
    4706:	4621      	mov	r1, r4
    4708:	f505 7007 	add.w	r0, r5, #540	; 0x21c
    470c:	f006 fbf4 	bl	aef8 <memset>
    4710:	4621      	mov	r1, r4
    4712:	4632      	mov	r2, r6
    4714:	f205 401c 	addw	r0, r5, #1052	; 0x41c
    4718:	f006 fbee 	bl	aef8 <memset>
    471c:	4632      	mov	r2, r6
    471e:	4621      	mov	r1, r4
    4720:	f505 6090 	add.w	r0, r5, #1152	; 0x480
    4724:	f006 fbe8 	bl	aef8 <memset>
      _strings_type * strings;

    RequestParamResponse():
      ints_length(0), st_ints(), ints(nullptr),
      floats_length(0), st_floats(), floats(nullptr),
      strings_length(0), st_strings(), strings(nullptr)
    4728:	495f      	ldr	r1, [pc, #380]	; (48a8 <_GLOBAL__sub_I_bmp+0x200>)
    472a:	f8c5 44e4 	str.w	r4, [r5, #1252]	; 0x4e4
    472e:	f8c5 44e8 	str.w	r4, [r5, #1256]	; 0x4e8
    4732:	f8c5 44ec 	str.w	r4, [r5, #1260]	; 0x4ec
    4736:	f8c5 44f0 	str.w	r4, [r5, #1264]	; 0x4f0
    473a:	f8c5 44f4 	str.w	r4, [r5, #1268]	; 0x4f4
    473e:	f885 44f8 	strb.w	r4, [r5, #1272]	; 0x4f8
    4742:	f8c5 44fc 	str.w	r4, [r5, #1276]	; 0x4fc
    4746:	f8c5 4500 	str.w	r4, [r5, #1280]	; 0x500
    474a:	f8c5 4504 	str.w	r4, [r5, #1284]	; 0x504
    474e:	f885 4508 	strb.w	r4, [r5, #1288]	; 0x508
    4752:	f8c5 4510 	str.w	r4, [r5, #1296]	; 0x510
    4756:	f8c5 4514 	str.w	r4, [r5, #1300]	; 0x514
    475a:	f8c5 4518 	str.w	r4, [r5, #1304]	; 0x518
    475e:	f8c5 451c 	str.w	r4, [r5, #1308]	; 0x51c
    4762:	f8c5 4524 	str.w	r4, [r5, #1316]	; 0x524
    4766:	f8c5 4528 	str.w	r4, [r5, #1320]	; 0x528
    476a:	f8c5 452c 	str.w	r4, [r5, #1324]	; 0x52c
    476e:	f8c5 4530 	str.w	r4, [r5, #1328]	; 0x530
    4772:	f8c5 150c 	str.w	r1, [r5, #1292]	; 0x50c
    4776:	f505 65a4 	add.w	r5, r5, #1312	; 0x520
    public:
      typedef float _data_type;
      _data_type data;

    Float32():
      data(0)
    477a:	4f4c      	ldr	r7, [pc, #304]	; (48ac <_GLOBAL__sub_I_bmp+0x204>)
    public:
      typedef int16_t _data_type;
      _data_type data;

    Int16():
      data(0)
    477c:	484c      	ldr	r0, [pc, #304]	; (48b0 <_GLOBAL__sub_I_bmp+0x208>)
{
public:
  Publisher(const char * topic_name, Msg * msg, int endpoint = rosserial_msgs::TopicInfo::ID_PUBLISHER) :
    topic_(topic_name),
    msg_(msg),
    endpoint_(endpoint) {};
    477e:	494d      	ldr	r1, [pc, #308]	; (48b4 <_GLOBAL__sub_I_bmp+0x20c>)
    4780:	f8df e188 	ldr.w	lr, [pc, #392]	; 490c <_GLOBAL__sub_I_bmp+0x264>
    4784:	8084      	strh	r4, [r0, #4]
    4786:	2600      	movs	r6, #0
    4788:	602e      	str	r6, [r5, #0]
    478a:	4d4b      	ldr	r5, [pc, #300]	; (48b8 <_GLOBAL__sub_I_bmp+0x210>)
    478c:	607e      	str	r6, [r7, #4]
    478e:	603d      	str	r5, [r7, #0]
    4790:	4e4a      	ldr	r6, [pc, #296]	; (48bc <_GLOBAL__sub_I_bmp+0x214>)
    4792:	4d4b      	ldr	r5, [pc, #300]	; (48c0 <_GLOBAL__sub_I_bmp+0x218>)
    4794:	6005      	str	r5, [r0, #0]
    4796:	6048      	str	r0, [r1, #4]
    4798:	484a      	ldr	r0, [pc, #296]	; (48c4 <_GLOBAL__sub_I_bmp+0x21c>)
    479a:	610c      	str	r4, [r1, #16]
    479c:	6008      	str	r0, [r1, #0]
    479e:	f8ce 5000 	str.w	r5, [lr]
    47a2:	4949      	ldr	r1, [pc, #292]	; (48c8 <_GLOBAL__sub_I_bmp+0x220>)
    47a4:	f8ae 4004 	strh.w	r4, [lr, #4]
    47a8:	f8c6 e004 	str.w	lr, [r6, #4]
    47ac:	f8df e160 	ldr.w	lr, [pc, #352]	; 4910 <_GLOBAL__sub_I_bmp+0x268>
    47b0:	4846      	ldr	r0, [pc, #280]	; (48cc <_GLOBAL__sub_I_bmp+0x224>)
    47b2:	6134      	str	r4, [r6, #16]
    47b4:	f8c6 e000 	str.w	lr, [r6]
    47b8:	4e45      	ldr	r6, [pc, #276]	; (48d0 <_GLOBAL__sub_I_bmp+0x228>)
    47ba:	600e      	str	r6, [r1, #0]

    Quaternion():
      x(0),
      y(0),
      z(0),
      w(0)
    47bc:	4d45      	ldr	r5, [pc, #276]	; (48d4 <_GLOBAL__sub_I_bmp+0x22c>)
    47be:	610c      	str	r4, [r1, #16]
    47c0:	604f      	str	r7, [r1, #4]
    47c2:	4945      	ldr	r1, [pc, #276]	; (48d8 <_GLOBAL__sub_I_bmp+0x230>)
      _z_type z;

    Vector3():
      x(0),
      y(0),
      z(0)
    47c4:	4e45      	ldr	r6, [pc, #276]	; (48dc <_GLOBAL__sub_I_bmp+0x234>)
    47c6:	4f46      	ldr	r7, [pc, #280]	; (48e0 <_GLOBAL__sub_I_bmp+0x238>)
    47c8:	6104      	str	r4, [r0, #16]
    47ca:	2200      	movs	r2, #0
    47cc:	2300      	movs	r3, #0
    47ce:	6001      	str	r1, [r0, #0]
    47d0:	6045      	str	r5, [r0, #4]
    47d2:	4844      	ldr	r0, [pc, #272]	; (48e4 <_GLOBAL__sub_I_bmp+0x23c>)
    47d4:	6028      	str	r0, [r5, #0]
    47d6:	e9c5 2302 	strd	r2, r3, [r5, #8]
    47da:	e9c5 2304 	strd	r2, r3, [r5, #16]
    47de:	e9c5 2306 	strd	r2, r3, [r5, #24]
    47e2:	e9c5 2308 	strd	r2, r3, [r5, #32]
    47e6:	4d40      	ldr	r5, [pc, #256]	; (48e8 <_GLOBAL__sub_I_bmp+0x240>)
      imu_acc(),
      imu_gyro(),
      imu_mag(),
      omega_right(0),
      omega_left(0),
      temp(0)
    47e8:	4940      	ldr	r1, [pc, #256]	; (48ec <_GLOBAL__sub_I_bmp+0x244>)
    47ea:	607e      	str	r6, [r7, #4]
    47ec:	e9c6 2302 	strd	r2, r3, [r6, #8]
    47f0:	e9c6 2304 	strd	r2, r3, [r6, #16]
    47f4:	e9c6 2306 	strd	r2, r3, [r6, #24]
    47f8:	6035      	str	r5, [r6, #0]
    47fa:	4e3d      	ldr	r6, [pc, #244]	; (48f0 <_GLOBAL__sub_I_bmp+0x248>)
    47fc:	603e      	str	r6, [r7, #0]
    47fe:	4e3d      	ldr	r6, [pc, #244]	; (48f4 <_GLOBAL__sub_I_bmp+0x24c>)
  typedef void(*CallbackT)(const MsgT&);
  MsgT msg;

  Subscriber(const char * topic_name, CallbackT cb, int endpoint = rosserial_msgs::TopicInfo::ID_SUBSCRIBER) :
    cb_(cb),
    endpoint_(endpoint)
    4800:	483d      	ldr	r0, [pc, #244]	; (48f8 <_GLOBAL__sub_I_bmp+0x250>)
    4802:	600e      	str	r6, [r1, #0]
    4804:	4e3d      	ldr	r6, [pc, #244]	; (48fc <_GLOBAL__sub_I_bmp+0x254>)
    4806:	613c      	str	r4, [r7, #16]
    4808:	e9c1 2304 	strd	r2, r3, [r1, #16]
    480c:	e9c1 2306 	strd	r2, r3, [r1, #24]
    4810:	e9c1 2308 	strd	r2, r3, [r1, #32]
    4814:	e9c1 230c 	strd	r2, r3, [r1, #48]	; 0x30
    4818:	e9c1 230e 	strd	r2, r3, [r1, #56]	; 0x38
    481c:	e9c1 2310 	strd	r2, r3, [r1, #64]	; 0x40
    4820:	e9c1 2314 	strd	r2, r3, [r1, #80]	; 0x50
    4824:	e9c1 2316 	strd	r2, r3, [r1, #88]	; 0x58
    4828:	e9c1 2318 	strd	r2, r3, [r1, #96]	; 0x60
    482c:	e9c1 231a 	strd	r2, r3, [r1, #104]	; 0x68
    4830:	e9c1 231c 	strd	r2, r3, [r1, #112]	; 0x70
    4834:	608d      	str	r5, [r1, #8]
    4836:	628d      	str	r5, [r1, #40]	; 0x28
    4838:	648d      	str	r5, [r1, #72]	; 0x48
    483a:	f8df c0d8 	ldr.w	ip, [pc, #216]	; 4914 <_GLOBAL__sub_I_bmp+0x26c>
    483e:	f8df e0d8 	ldr.w	lr, [pc, #216]	; 4918 <_GLOBAL__sub_I_bmp+0x270>
      typedef geometry_msgs::Vector3 _angular_type;
      _angular_type angular;

    Twist():
      linear(),
      angular()
    4842:	4f2f      	ldr	r7, [pc, #188]	; (4900 <_GLOBAL__sub_I_bmp+0x258>)
    4844:	e9c1 231e 	strd	r2, r3, [r1, #120]	; 0x78
    4848:	e9c0 2308 	strd	r2, r3, [r0, #32]
    484c:	e9c0 230a 	strd	r2, r3, [r0, #40]	; 0x28
    4850:	e9c0 230c 	strd	r2, r3, [r0, #48]	; 0x30
    4854:	e9c0 2310 	strd	r2, r3, [r0, #64]	; 0x40
    4858:	e9c0 2312 	strd	r2, r3, [r0, #72]	; 0x48
    485c:	e9c0 2314 	strd	r2, r3, [r0, #80]	; 0x50
    4860:	6134      	str	r4, [r6, #16]
    4862:	2201      	movs	r2, #1
    4864:	4c27      	ldr	r4, [pc, #156]	; (4904 <_GLOBAL__sub_I_bmp+0x25c>)
  {
    topic_ = topic_name;
    4866:	4b28      	ldr	r3, [pc, #160]	; (4908 <_GLOBAL__sub_I_bmp+0x260>)
    4868:	6071      	str	r1, [r6, #4]
    486a:	f8c6 c000 	str.w	ip, [r6]
    486e:	6185      	str	r5, [r0, #24]
    4870:	6385      	str	r5, [r0, #56]	; 0x38
  typedef void(*CallbackT)(const MsgT&);
  MsgT msg;

  Subscriber(const char * topic_name, CallbackT cb, int endpoint = rosserial_msgs::TopicInfo::ID_SUBSCRIBER) :
    cb_(cb),
    endpoint_(endpoint)
    4872:	f8c0 e000 	str.w	lr, [r0]
    4876:	6107      	str	r7, [r0, #16]
    4878:	6584      	str	r4, [r0, #88]	; 0x58
    487a:	65c2      	str	r2, [r0, #92]	; 0x5c
  {
    topic_ = topic_name;
    487c:	6083      	str	r3, [r0, #8]
    487e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    4880:	1fff2bb0 	.word	0x1fff2bb0
    4884:	1fff0888 	.word	0x1fff0888
    4888:	1fff1d64 	.word	0x1fff1d64
    488c:	1fff0b20 	.word	0x1fff0b20
    4890:	1fff080c 	.word	0x1fff080c
    4894:	000054e5 	.word	0x000054e5
    4898:	1fff1c78 	.word	0x1fff1c78
    489c:	1fff2b58 	.word	0x1fff2b58
    48a0:	1fff1c80 	.word	0x1fff1c80
    48a4:	0000bd14 	.word	0x0000bd14
    48a8:	0000bc6c 	.word	0x0000bc6c
    48ac:	1fff1c9c 	.word	0x1fff1c9c
    48b0:	1fff1d08 	.word	0x1fff1d08
    48b4:	1fff1468 	.word	0x1fff1468
    48b8:	0000bc9c 	.word	0x0000bc9c
    48bc:	1fff1d48 	.word	0x1fff1d48
    48c0:	0000bc84 	.word	0x0000bc84
    48c4:	0000c07c 	.word	0x0000c07c
    48c8:	1fff2b10 	.word	0x1fff2b10
    48cc:	1fff1d18 	.word	0x1fff1d18
    48d0:	0000c094 	.word	0x0000c094
    48d4:	1fff2b30 	.word	0x1fff2b30
    48d8:	0000c0a0 	.word	0x0000c0a0
    48dc:	1fff1438 	.word	0x1fff1438
    48e0:	1fff2b80 	.word	0x1fff2b80
    48e4:	0000bccc 	.word	0x0000bccc
    48e8:	0000bcb4 	.word	0x0000bcb4
    48ec:	1fff2a90 	.word	0x1fff2a90
    48f0:	0000c0b0 	.word	0x0000c0b0
    48f4:	0000bcfc 	.word	0x0000bcfc
    48f8:	1fff1ca8 	.word	0x1fff1ca8
    48fc:	1fff229c 	.word	0x1fff229c
    4900:	0000bce4 	.word	0x0000bce4
    4904:	000026b5 	.word	0x000026b5
    4908:	0000c0d4 	.word	0x0000c0d4
    490c:	1fff2b5c 	.word	0x1fff2b5c
    4910:	0000c088 	.word	0x0000c088
    4914:	0000c0c0 	.word	0x0000c0c0
    4918:	0000bd28 	.word	0x0000bd28

0000491c <TwoWire::available()>:
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    491c:	f890 2039 	ldrb.w	r2, [r0, #57]	; 0x39
    4920:	f890 0038 	ldrb.w	r0, [r0, #56]	; 0x38
	}
    4924:	1a10      	subs	r0, r2, r0
    4926:	4770      	bx	lr

00004928 <TwoWire::read()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    4928:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
    492c:	f890 2039 	ldrb.w	r2, [r0, #57]	; 0x39
    4930:	429a      	cmp	r2, r3
    4932:	d905      	bls.n	4940 <TwoWire::read()+0x18>
		return rxBuffer[rxBufferIndex++];
    4934:	1c5a      	adds	r2, r3, #1
    4936:	4403      	add	r3, r0
    4938:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    493c:	7e18      	ldrb	r0, [r3, #24]
    493e:	4770      	bx	lr
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    4940:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		return rxBuffer[rxBufferIndex++];
	}
    4944:	4770      	bx	lr
    4946:	bf00      	nop

00004948 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)>:
 * @param length Number of bytes to read
 * @param data Buffer to store read data in
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Number of bytes read (-1 indicates failure)
 */
int8_t I2Cdev::readBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t *data, uint16_t timeout, void *wireObj) {
    4948:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    494c:	f8df a144 	ldr.w	sl, [pc, #324]	; 4a94 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x14c>

    int8_t count = 0;
    uint32_t t1 = millis();

    #if (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
        TwoWire *useWire = &Wire;
    4950:	4d4e      	ldr	r5, [pc, #312]	; (4a8c <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x144>)
    4952:	f8da 6000 	ldr.w	r6, [sl]
 * @param length Number of bytes to read
 * @param data Buffer to store read data in
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Number of bytes read (-1 indicates failure)
 */
int8_t I2Cdev::readBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t *data, uint16_t timeout, void *wireObj) {
    4956:	b08d      	sub	sp, #52	; 0x34
    4958:	4699      	mov	r9, r3
    495a:	9c17      	ldr	r4, [sp, #92]	; 0x5c
    495c:	9609      	str	r6, [sp, #36]	; 0x24
    495e:	9006      	str	r0, [sp, #24]
    4960:	9107      	str	r1, [sp, #28]
	return ret;
    4962:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
    4966:	f8bd 6058 	ldrh.w	r6, [sp, #88]	; 0x58
            // Adds official support for repeated start condition, yay!

            // I2C/TWI subsystem uses internal buffer that breaks with large data requests
            // so if user requests more than I2CDEVLIB_WIRE_BUFFER_LENGTH bytes, we have to do it in
            // smaller chunks instead of all at once
            for (int k = 0; k < length; k += min((int)length, I2CDEVLIB_WIRE_BUFFER_LENGTH)) {
    496a:	9204      	str	r2, [sp, #16]

    int8_t count = 0;
    uint32_t t1 = millis();

    #if (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
        TwoWire *useWire = &Wire;
    496c:	2c00      	cmp	r4, #0
    496e:	bf08      	it	eq
    4970:	462c      	moveq	r4, r5
            // Adds official support for repeated start condition, yay!

            // I2C/TWI subsystem uses internal buffer that breaks with large data requests
            // so if user requests more than I2CDEVLIB_WIRE_BUFFER_LENGTH bytes, we have to do it in
            // smaller chunks instead of all at once
            for (int k = 0; k < length; k += min((int)length, I2CDEVLIB_WIRE_BUFFER_LENGTH)) {
    4972:	2a00      	cmp	r2, #0
    4974:	d076      	beq.n	4a64 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x11c>
    4976:	0043      	lsls	r3, r0, #1
    4978:	2a20      	cmp	r2, #32
    497a:	4610      	mov	r0, r2
    497c:	b2db      	uxtb	r3, r3
    497e:	bfa8      	it	ge
    4980:	2220      	movge	r2, #32
    4982:	4f43      	ldr	r7, [pc, #268]	; (4a90 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x148>)
    4984:	f8df 8110 	ldr.w	r8, [pc, #272]	; 4a98 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x150>
    4988:	9205      	str	r2, [sp, #20]
    498a:	9303      	str	r3, [sp, #12]
    498c:	9202      	str	r2, [sp, #8]
    498e:	9001      	str	r0, [sp, #4]
    4990:	2500      	movs	r5, #0
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    4992:	f89d 200c 	ldrb.w	r2, [sp, #12]
    4996:	f884 203b 	strb.w	r2, [r4, #59]	; 0x3b
                useWire->beginTransmission(devAddr);
                useWire->write(regAddr);
    499a:	6823      	ldr	r3, [r4, #0]
    499c:	9907      	ldr	r1, [sp, #28]
		transmitting = 1;
    499e:	f04f 0201 	mov.w	r2, #1
    49a2:	f884 205e 	strb.w	r2, [r4, #94]	; 0x5e
		txBufferLength = 1;
    49a6:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
    49aa:	681b      	ldr	r3, [r3, #0]
    49ac:	4620      	mov	r0, r4
    49ae:	4798      	blx	r3
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    49b0:	2101      	movs	r1, #1
    49b2:	4620      	mov	r0, r4
    49b4:	f000 faaa 	bl	4f0c <TwoWire::endTransmission(unsigned char)>
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    49b8:	f89d 300c 	ldrb.w	r3, [sp, #12]
    49bc:	f884 303b 	strb.w	r3, [r4, #59]	; 0x3b
		transmitting = 1;
    49c0:	f04f 0301 	mov.w	r3, #1
    49c4:	f884 305e 	strb.w	r3, [r4, #94]	; 0x5e
		txBufferLength = 1;
    49c8:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
//#include <algorithm> // this isn't really needed, is it?  (slows down compiling)
#include <utility>
// https://forum.pjrc.com/threads/44596-Teensyduino-1-37-Beta-2-(Arduino-1-8-3-support)?p=145150&viewfull=1#post145150
template<class A, class B>
constexpr auto min(A&& a, B&& b) -> decltype(a < b ? std::forward<A>(a) : std::forward<B>(b)) {
  return a < b ? std::forward<A>(a) : std::forward<B>(b);
    49cc:	9b01      	ldr	r3, [sp, #4]
	uint8_t endTransmission(void) {
		return endTransmission(1);
	}
	uint8_t requestFrom(uint8_t address, uint8_t quantity, uint8_t sendStop);
	uint8_t requestFrom(uint8_t address, uint8_t quantity) {
		return requestFrom(address, quantity, (uint8_t)1);
    49ce:	9906      	ldr	r1, [sp, #24]
    49d0:	2b1f      	cmp	r3, #31
    49d2:	bfd4      	ite	le
    49d4:	b2da      	uxtble	r2, r3
    49d6:	2220      	movgt	r2, #32
    49d8:	2301      	movs	r3, #1
    49da:	4620      	mov	r0, r4
    49dc:	f000 fb20 	bl	5020 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>
                useWire->endTransmission();
                useWire->beginTransmission(devAddr);
                useWire->requestFrom((uint8_t)devAddr, (uint8_t)min((int)length - k, I2CDEVLIB_WIRE_BUFFER_LENGTH));
        
                for (; useWire->available() && (timeout == 0 || millis() - t1 < timeout); count++) {
    49e0:	6823      	ldr	r3, [r4, #0]
    49e2:	691b      	ldr	r3, [r3, #16]
    49e4:	42bb      	cmp	r3, r7
    49e6:	d126      	bne.n	4a36 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xee>
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    49e8:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
    49ec:	f894 0038 	ldrb.w	r0, [r4, #56]	; 0x38
    49f0:	1a18      	subs	r0, r3, r0
    49f2:	b320      	cbz	r0, 4a3e <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xf6>
    49f4:	b13e      	cbz	r6, 4a06 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xbe>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    49f6:	f8da 3000 	ldr.w	r3, [sl]
    49fa:	930a      	str	r3, [sp, #40]	; 0x28
	return ret;
    49fc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    49fe:	ebcb 0303 	rsb	r3, fp, r3
    4a02:	42b3      	cmp	r3, r6
    4a04:	d21b      	bcs.n	4a3e <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xf6>
                    data[count] = useWire->read();
    4a06:	6823      	ldr	r3, [r4, #0]
    4a08:	695b      	ldr	r3, [r3, #20]
    4a0a:	4543      	cmp	r3, r8
    4a0c:	eb09 0205 	add.w	r2, r9, r5
    4a10:	d120      	bne.n	4a54 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x10c>
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    4a12:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
    4a16:	f894 1039 	ldrb.w	r1, [r4, #57]	; 0x39
    4a1a:	4299      	cmp	r1, r3
    4a1c:	d920      	bls.n	4a60 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x118>
		return rxBuffer[rxBufferIndex++];
    4a1e:	1c59      	adds	r1, r3, #1
    4a20:	4423      	add	r3, r4
    4a22:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
    4a26:	7e18      	ldrb	r0, [r3, #24]
    4a28:	7010      	strb	r0, [r2, #0]
                useWire->write(regAddr);
                useWire->endTransmission();
                useWire->beginTransmission(devAddr);
                useWire->requestFrom((uint8_t)devAddr, (uint8_t)min((int)length - k, I2CDEVLIB_WIRE_BUFFER_LENGTH));
        
                for (; useWire->available() && (timeout == 0 || millis() - t1 < timeout); count++) {
    4a2a:	6823      	ldr	r3, [r4, #0]
    4a2c:	691b      	ldr	r3, [r3, #16]
    4a2e:	3501      	adds	r5, #1
    4a30:	42bb      	cmp	r3, r7
    4a32:	b26d      	sxtb	r5, r5
    4a34:	d0d8      	beq.n	49e8 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xa0>
    4a36:	4620      	mov	r0, r4
    4a38:	4798      	blx	r3
    4a3a:	2800      	cmp	r0, #0
    4a3c:	d1da      	bne.n	49f4 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xac>
    4a3e:	9a01      	ldr	r2, [sp, #4]
    4a40:	9b05      	ldr	r3, [sp, #20]
            // Adds official support for repeated start condition, yay!

            // I2C/TWI subsystem uses internal buffer that breaks with large data requests
            // so if user requests more than I2CDEVLIB_WIRE_BUFFER_LENGTH bytes, we have to do it in
            // smaller chunks instead of all at once
            for (int k = 0; k < length; k += min((int)length, I2CDEVLIB_WIRE_BUFFER_LENGTH)) {
    4a42:	9904      	ldr	r1, [sp, #16]
    4a44:	1ad2      	subs	r2, r2, r3
    4a46:	9201      	str	r2, [sp, #4]
    4a48:	9a02      	ldr	r2, [sp, #8]
    4a4a:	428a      	cmp	r2, r1
    4a4c:	4413      	add	r3, r2
    4a4e:	da0a      	bge.n	4a66 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x11e>
    4a50:	9302      	str	r3, [sp, #8]
    4a52:	e79e      	b.n	4992 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x4a>
    4a54:	9200      	str	r2, [sp, #0]
                useWire->endTransmission();
                useWire->beginTransmission(devAddr);
                useWire->requestFrom((uint8_t)devAddr, (uint8_t)min((int)length - k, I2CDEVLIB_WIRE_BUFFER_LENGTH));
        
                for (; useWire->available() && (timeout == 0 || millis() - t1 < timeout); count++) {
                    data[count] = useWire->read();
    4a56:	4620      	mov	r0, r4
    4a58:	4798      	blx	r3
    4a5a:	9a00      	ldr	r2, [sp, #0]
    4a5c:	b2c0      	uxtb	r0, r0
    4a5e:	e7e3      	b.n	4a28 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xe0>
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    4a60:	20ff      	movs	r0, #255	; 0xff
    4a62:	e7e1      	b.n	4a28 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0xe0>
        Serial.print(" bytes from 0x");
        Serial.print(regAddr, HEX);
        Serial.print("...");
    #endif

    int8_t count = 0;
    4a64:	9d04      	ldr	r5, [sp, #16]
        }

    #endif

    // check for timeout
    if (timeout > 0 && millis() - t1 >= timeout && count < length) count = -1; // timeout
    4a66:	b166      	cbz	r6, 4a82 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x13a>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4a68:	f8da 3000 	ldr.w	r3, [sl]
    4a6c:	930b      	str	r3, [sp, #44]	; 0x2c
	return ret;
    4a6e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    4a70:	ebcb 0b03 	rsb	fp, fp, r3
    4a74:	45b3      	cmp	fp, r6
    4a76:	d304      	bcc.n	4a82 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)+0x13a>
    4a78:	9b04      	ldr	r3, [sp, #16]
    4a7a:	429d      	cmp	r5, r3
    4a7c:	bfb8      	it	lt
    4a7e:	f04f 35ff 	movlt.w	r5, #4294967295	; 0xffffffff
        Serial.print(count, DEC);
        Serial.println(" read).");
    #endif

    return count;
}
    4a82:	4628      	mov	r0, r5
    4a84:	b00d      	add	sp, #52	; 0x34
    4a86:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4a8a:	bf00      	nop
    4a8c:	1fff0888 	.word	0x1fff0888
    4a90:	0000491d 	.word	0x0000491d
    4a94:	1fff2c04 	.word	0x1fff2c04
    4a98:	00004929 	.word	0x00004929

00004a9c <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*, void*)>:
 * @param regAddr First register address to write to
 * @param length Number of bytes to write
 * @param data Buffer to copy new data from
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t* data, void *wireObj) {
    4a9c:	b570      	push	{r4, r5, r6, lr}
    4a9e:	9d04      	ldr	r5, [sp, #16]
        Serial.print("...");
    #endif
    uint8_t status = 0;

#if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE
    TwoWire *useWire = &Wire;
    4aa0:	4c13      	ldr	r4, [pc, #76]	; (4af0 <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*, void*)+0x54>)
    4aa2:	2d00      	cmp	r5, #0
    4aa4:	bf08      	it	eq
    4aa6:	4625      	moveq	r5, r4
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    4aa8:	0040      	lsls	r0, r0, #1
        useWire->send((uint8_t) regAddr); // send address
    #elif ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100) \
            || (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE && ARDUINO >= 100) \
            || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
        useWire->beginTransmission(devAddr);
        useWire->write((uint8_t) regAddr); // send address
    4aaa:	682c      	ldr	r4, [r5, #0]
    4aac:	f885 003b 	strb.w	r0, [r5, #59]	; 0x3b
		transmitting = 1;
    4ab0:	2001      	movs	r0, #1
    4ab2:	f885 005e 	strb.w	r0, [r5, #94]	; 0x5e
		txBufferLength = 1;
    4ab6:	f885 005d 	strb.w	r0, [r5, #93]	; 0x5d
 * @param regAddr First register address to write to
 * @param length Number of bytes to write
 * @param data Buffer to copy new data from
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t* data, void *wireObj) {
    4aba:	4616      	mov	r6, r2
        useWire->send((uint8_t) regAddr); // send address
    #elif ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100) \
            || (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE && ARDUINO >= 100) \
            || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
        useWire->beginTransmission(devAddr);
        useWire->write((uint8_t) regAddr); // send address
    4abc:	4628      	mov	r0, r5
    4abe:	6822      	ldr	r2, [r4, #0]
 * @param regAddr First register address to write to
 * @param length Number of bytes to write
 * @param data Buffer to copy new data from
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t* data, void *wireObj) {
    4ac0:	461c      	mov	r4, r3
        useWire->send((uint8_t) regAddr); // send address
    #elif ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100) \
            || (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE && ARDUINO >= 100) \
            || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
        useWire->beginTransmission(devAddr);
        useWire->write((uint8_t) regAddr); // send address
    4ac2:	4790      	blx	r2
    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE)
        Fastwire::beginTransmission(devAddr);
        Fastwire::write(regAddr);
    #endif
    for (uint8_t i = 0; i < length; i++) {
    4ac4:	b15e      	cbz	r6, 4ade <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*, void*)+0x42>
    4ac6:	3e01      	subs	r6, #1
    4ac8:	fa54 f686 	uxtab	r6, r4, r6
    4acc:	3c01      	subs	r4, #1
        #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)
            useWire->send((uint8_t) data[i]);
        #elif ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100) \
                || (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE && ARDUINO >= 100) \
                || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
            useWire->write((uint8_t) data[i]);
    4ace:	682b      	ldr	r3, [r5, #0]
    4ad0:	f814 1f01 	ldrb.w	r1, [r4, #1]!
    4ad4:	681b      	ldr	r3, [r3, #0]
    4ad6:	4628      	mov	r0, r5
    4ad8:	4798      	blx	r3
        useWire->write((uint8_t) regAddr); // send address
    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE)
        Fastwire::beginTransmission(devAddr);
        Fastwire::write(regAddr);
    #endif
    for (uint8_t i = 0; i < length; i++) {
    4ada:	42b4      	cmp	r4, r6
    4adc:	d1f7      	bne.n	4ace <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*, void*)+0x32>
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    4ade:	4628      	mov	r0, r5
    4ae0:	2101      	movs	r1, #1
    4ae2:	f000 fa13 	bl	4f0c <TwoWire::endTransmission(unsigned char)>
        //status = Fastwire::endTransmission();
    #endif
    #ifdef I2CDEV_SERIAL_DEBUG
        Serial.println(". Done.");
    #endif
    return status == 0;
    4ae6:	fab0 f080 	clz	r0, r0
    4aea:	0940      	lsrs	r0, r0, #5
}
    4aec:	bd70      	pop	{r4, r5, r6, pc}
    4aee:	bf00      	nop
    4af0:	1fff0888 	.word	0x1fff0888

00004af4 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char, void*)>:
 * @param devAddr I2C slave device address
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data, void *wireObj) {
    4af4:	b510      	push	{r4, lr}
    4af6:	b084      	sub	sp, #16
    4af8:	ac04      	add	r4, sp, #16
    return writeBytes(devAddr, regAddr, 1, &data, wireObj);
    4afa:	9300      	str	r3, [sp, #0]
 * @param devAddr I2C slave device address
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data, void *wireObj) {
    4afc:	f804 2d01 	strb.w	r2, [r4, #-1]!
    return writeBytes(devAddr, regAddr, 1, &data, wireObj);
    4b00:	2201      	movs	r2, #1
    4b02:	4623      	mov	r3, r4
    4b04:	f7ff ffca 	bl	4a9c <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*, void*)>
}
    4b08:	b004      	add	sp, #16
    4b0a:	bd10      	pop	{r4, pc}

00004b0c <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char, void*)>:
 * @param regAddr Register regAddr to write to
 * @param bitNum Bit position to write (0-7)
 * @param value New bit value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    4b0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint8_t b;
    readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj);
    4b10:	4c14      	ldr	r4, [pc, #80]	; (4b64 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char, void*)+0x58>)
 * @param regAddr Register regAddr to write to
 * @param bitNum Bit position to write (0-7)
 * @param value New bit value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    4b12:	b084      	sub	sp, #16
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    4b14:	8824      	ldrh	r4, [r4, #0]
 * @param regAddr Register regAddr to write to
 * @param bitNum Bit position to write (0-7)
 * @param value New bit value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    4b16:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    4b18:	9400      	str	r4, [sp, #0]
 * @param regAddr Register regAddr to write to
 * @param bitNum Bit position to write (0-7)
 * @param value New bit value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    4b1a:	4698      	mov	r8, r3
    4b1c:	4614      	mov	r4, r2
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    4b1e:	f10d 030e 	add.w	r3, sp, #14
    4b22:	2201      	movs	r2, #1
    4b24:	9501      	str	r5, [sp, #4]
 * @param regAddr Register regAddr to write to
 * @param bitNum Bit position to write (0-7)
 * @param value New bit value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    4b26:	4606      	mov	r6, r0
    4b28:	460f      	mov	r7, r1
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    4b2a:	f7ff ff0d 	bl	4948 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)>
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    uint8_t b;
    readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj);
    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
    4b2e:	2201      	movs	r2, #1
    4b30:	f89d 300e 	ldrb.w	r3, [sp, #14]
    4b34:	fa02 f404 	lsl.w	r4, r2, r4
    4b38:	f1b8 0f00 	cmp.w	r8, #0
    4b3c:	d10f      	bne.n	4b5e <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char, void*)+0x52>
    4b3e:	ea23 0404 	bic.w	r4, r3, r4
    4b42:	ab04      	add	r3, sp, #16
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data, void *wireObj) {
    return writeBytes(devAddr, regAddr, 1, &data, wireObj);
    4b44:	9500      	str	r5, [sp, #0]
    4b46:	4639      	mov	r1, r7
    4b48:	f803 4d01 	strb.w	r4, [r3, #-1]!
    4b4c:	4630      	mov	r0, r6
    4b4e:	2201      	movs	r2, #1
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    uint8_t b;
    readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj);
    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
    4b50:	f88d 400e 	strb.w	r4, [sp, #14]
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data, void *wireObj) {
    return writeBytes(devAddr, regAddr, 1, &data, wireObj);
    4b54:	f7ff ffa2 	bl	4a9c <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*, void*)>
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    uint8_t b;
    readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj);
    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
    return writeByte(devAddr, regAddr, b, wireObj);
}
    4b58:	b004      	add	sp, #16
    4b5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data, void *wireObj) {
    uint8_t b;
    readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj);
    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
    4b5e:	431c      	orrs	r4, r3
    4b60:	b2e4      	uxtb	r4, r4
    4b62:	e7ee      	b.n	4b42 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char, void*)+0x36>
    4b64:	1fff0818 	.word	0x1fff0818

00004b68 <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, void*)>:
 * @param bitStart First bit position to write (0-7)
 * @param length Number of bits to write (not more than 8)
 * @param data Right-aligned value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data, void *wireObj) {
    4b68:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    // 00011100 mask byte
    // 10101111 original value (sample)
    // 10100011 original & ~mask
    // 10101011 masked | value
    uint8_t b;
    if (readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj) != 0) {
    4b6c:	4c19      	ldr	r4, [pc, #100]	; (4bd4 <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, void*)+0x6c>)
 * @param bitStart First bit position to write (0-7)
 * @param length Number of bits to write (not more than 8)
 * @param data Right-aligned value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data, void *wireObj) {
    4b6e:	b085      	sub	sp, #20
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    4b70:	8824      	ldrh	r4, [r4, #0]
 * @param bitStart First bit position to write (0-7)
 * @param length Number of bits to write (not more than 8)
 * @param data Right-aligned value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data, void *wireObj) {
    4b72:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    4b74:	9400      	str	r4, [sp, #0]
 * @param bitStart First bit position to write (0-7)
 * @param length Number of bits to write (not more than 8)
 * @param data Right-aligned value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data, void *wireObj) {
    4b76:	4691      	mov	r9, r2
    4b78:	4698      	mov	r8, r3
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    4b7a:	9501      	str	r5, [sp, #4]
    4b7c:	f10d 030e 	add.w	r3, sp, #14
    4b80:	2201      	movs	r2, #1
 * @param bitStart First bit position to write (0-7)
 * @param length Number of bits to write (not more than 8)
 * @param data Right-aligned value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data, void *wireObj) {
    4b82:	4606      	mov	r6, r0
    4b84:	460f      	mov	r7, r1
    4b86:	f89d 4030 	ldrb.w	r4, [sp, #48]	; 0x30
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout, void *wireObj) {
    return readBytes(devAddr, regAddr, 1, data, timeout, wireObj);
    4b8a:	f7ff fedd 	bl	4948 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)>
    // 00011100 mask byte
    // 10101111 original value (sample)
    // 10100011 original & ~mask
    // 10101011 masked | value
    uint8_t b;
    if (readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj) != 0) {
    4b8e:	b1e8      	cbz	r0, 4bcc <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, void*)+0x64>
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
    4b90:	ebc8 0909 	rsb	r9, r8, r9
    4b94:	2201      	movs	r2, #1
    4b96:	4491      	add	r9, r2
    4b98:	fa02 f808 	lsl.w	r8, r2, r8
        data <<= (bitStart - length + 1); // shift data into correct position
    4b9c:	fa04 f109 	lsl.w	r1, r4, r9
    // 10101111 original value (sample)
    // 10100011 original & ~mask
    // 10101011 masked | value
    uint8_t b;
    if (readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj) != 0) {
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
    4ba0:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
        data <<= (bitStart - length + 1); // shift data into correct position
        data &= mask; // zero all non-important bits in data
        b &= ~(mask); // zero all important bits in existing byte
        b |= data; // combine data with existing byte
    4ba4:	f89d 400e 	ldrb.w	r4, [sp, #14]
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data, void *wireObj) {
    return writeBytes(devAddr, regAddr, 1, &data, wireObj);
    4ba8:	9500      	str	r5, [sp, #0]
    // 10101111 original value (sample)
    // 10100011 original & ~mask
    // 10101011 masked | value
    uint8_t b;
    if (readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj) != 0) {
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
    4baa:	fa03 f809 	lsl.w	r8, r3, r9
        data <<= (bitStart - length + 1); // shift data into correct position
    4bae:	b2c9      	uxtb	r1, r1
        data &= mask; // zero all non-important bits in data
        b &= ~(mask); // zero all important bits in existing byte
        b |= data; // combine data with existing byte
    4bb0:	ea01 0108 	and.w	r1, r1, r8
    4bb4:	ea24 0408 	bic.w	r4, r4, r8
    4bb8:	ab04      	add	r3, sp, #16
    4bba:	430c      	orrs	r4, r1
    4bbc:	f803 4d01 	strb.w	r4, [r3, #-1]!
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data, void *wireObj) {
    return writeBytes(devAddr, regAddr, 1, &data, wireObj);
    4bc0:	4639      	mov	r1, r7
    4bc2:	4630      	mov	r0, r6
    if (readByte(devAddr, regAddr, &b, I2Cdev::readTimeout, wireObj) != 0) {
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
        data <<= (bitStart - length + 1); // shift data into correct position
        data &= mask; // zero all non-important bits in data
        b &= ~(mask); // zero all important bits in existing byte
        b |= data; // combine data with existing byte
    4bc4:	f88d 400e 	strb.w	r4, [sp, #14]
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data, void *wireObj) {
    return writeBytes(devAddr, regAddr, 1, &data, wireObj);
    4bc8:	f7ff ff68 	bl	4a9c <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*, void*)>
        b |= data; // combine data with existing byte
        return writeByte(devAddr, regAddr, b, wireObj);
    } else {
        return false;
    }
}
    4bcc:	b005      	add	sp, #20
    4bce:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    4bd2:	bf00      	nop
    4bd4:	1fff0818 	.word	0x1fff0818

00004bd8 <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
    4bd8:	2000      	movs	r0, #0
    4bda:	4770      	bx	lr

00004bdc <TwoWire::peek()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    4bdc:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
    4be0:	f890 2039 	ldrb.w	r2, [r0, #57]	; 0x39
    4be4:	429a      	cmp	r2, r3
		return rxBuffer[rxBufferIndex];
    4be6:	bf86      	itte	hi
    4be8:	181b      	addhi	r3, r3, r0
    4bea:	7e18      	ldrbhi	r0, [r3, #24]
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    4bec:	f04f 30ff 	movls.w	r0, #4294967295	; 0xffffffff
		return rxBuffer[rxBufferIndex];
	}
    4bf0:	4770      	bx	lr
    4bf2:	bf00      	nop

00004bf4 <TwoWire::flush()>:
	virtual void flush(void) {
    4bf4:	4770      	bx	lr
    4bf6:	bf00      	nop

00004bf8 <TwoWire::write(unsigned char const*, unsigned int)>:
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    4bf8:	b538      	push	{r3, r4, r5, lr}
    4bfa:	4605      	mov	r5, r0
	if (transmitting || slave_mode) {
    4bfc:	f8b0 005e 	ldrh.w	r0, [r0, #94]	; 0x5e
    4c00:	b190      	cbz	r0, 4c28 <TwoWire::write(unsigned char const*, unsigned int)+0x30>
		size_t avail = BUFFER_LENGTH+1 - txBufferLength;
    4c02:	f895 305d 	ldrb.w	r3, [r5, #93]	; 0x5d
    4c06:	4614      	mov	r4, r2
    4c08:	f1c3 0221 	rsb	r2, r3, #33	; 0x21
		if (quantity > avail) {
    4c0c:	4294      	cmp	r4, r2
    4c0e:	d80c      	bhi.n	4c2a <TwoWire::write(unsigned char const*, unsigned int)+0x32>
			quantity = avail;
			setWriteError();
		}
		memcpy(txBuffer + txBufferLength, data, quantity);
    4c10:	f105 003b 	add.w	r0, r5, #59	; 0x3b
    4c14:	4418      	add	r0, r3
    4c16:	4622      	mov	r2, r4
    4c18:	f001 fc10 	bl	643c <memcpy>
		txBufferLength += quantity;
    4c1c:	f895 305d 	ldrb.w	r3, [r5, #93]	; 0x5d
    4c20:	4423      	add	r3, r4
    4c22:	f885 305d 	strb.w	r3, [r5, #93]	; 0x5d
    4c26:	4620      	mov	r0, r4
		return quantity;
	}
	return 0;
}
    4c28:	bd38      	pop	{r3, r4, r5, pc}
	// format warnings are too pedantic - disable until newer toolchain offers better...
	// https://forum.pjrc.com/threads/62473?p=256873&viewfull=1#post256873
	int printf(const char *format, ...) /*__attribute__ ((format (printf, 2, 3)))*/;
	int printf(const __FlashStringHelper *format, ...);
  protected:
	void setWriteError(int err = 1) { write_error = err; }
    4c2a:	2001      	movs	r0, #1
    4c2c:	4614      	mov	r4, r2
    4c2e:	7128      	strb	r0, [r5, #4]
    4c30:	e7ee      	b.n	4c10 <TwoWire::write(unsigned char const*, unsigned int)+0x18>
    4c32:	bf00      	nop

00004c34 <TwoWire::write(unsigned char)>:
//  I2C0_C2      // I2C Control Register 2
//  I2C0_FLT     // I2C Programmable Input Glitch Filter register

size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
    4c34:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
    4c38:	b16b      	cbz	r3, 4c56 <TwoWire::write(unsigned char)+0x22>
		if (txBufferLength >= BUFFER_LENGTH+1) {
    4c3a:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
    4c3e:	2b20      	cmp	r3, #32
    4c40:	d807      	bhi.n	4c52 <TwoWire::write(unsigned char)+0x1e>
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    4c42:	18c2      	adds	r2, r0, r3
    4c44:	3301      	adds	r3, #1
    4c46:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d
		return 1;
    4c4a:	2001      	movs	r0, #1
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    4c4c:	f882 103b 	strb.w	r1, [r2, #59]	; 0x3b
    4c50:	4770      	bx	lr
    4c52:	2301      	movs	r3, #1
    4c54:	7103      	strb	r3, [r0, #4]
size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
    4c56:	2000      	movs	r0, #0
    4c58:	4770      	bx	lr
    4c5a:	bf00      	nop

00004c5c <TwoWire::begin()>:
void TwoWire::begin(void)
{
	//serial_begin(BAUD2DIV(115200));
	//serial_print("\nWire Begin\n");

	rxBufferIndex = 0;
    4c5c:	2300      	movs	r3, #0
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    4c5e:	6942      	ldr	r2, [r0, #20]
void TwoWire::begin(void)
{
	//serial_begin(BAUD2DIV(115200));
	//serial_print("\nWire Begin\n");

	rxBufferIndex = 0;
    4c60:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
	rxBufferLength = 0;
    4c64:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
	txBufferIndex = 0;
    4c68:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c
	txBufferLength = 0;
    4c6c:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d
	transmitting = 0;
    4c70:	f880 305e 	strb.w	r3, [r0, #94]	; 0x5e
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
    4c74:	f880 305f 	strb.w	r3, [r0, #95]	; 0x5f
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    4c78:	ca06      	ldmia	r2, {r1, r2}

void sda_rising_isr0(void);
void sda_rising_isr1(void);

void TwoWire::begin(void)
{
    4c7a:	b430      	push	{r4, r5}
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    4c7c:	680d      	ldr	r5, [r1, #0]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    4c7e:	6904      	ldr	r4, [r0, #16]
	rxBufferIndex = 0;
	rxBufferLength = 0;
	txBufferIndex = 0;
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
    4c80:	6643      	str	r3, [r0, #100]	; 0x64
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    4c82:	432a      	orrs	r2, r5
	rxBufferLength = 0;
	txBufferIndex = 0;
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
    4c84:	6683      	str	r3, [r0, #104]	; 0x68
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    4c86:	600a      	str	r2, [r1, #0]
	port().C1 = 0;
    4c88:	70a3      	strb	r3, [r4, #2]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    4c8a:	6942      	ldr	r2, [r0, #20]
    4c8c:	f890 3061 	ldrb.w	r3, [r0, #97]	; 0x61
    4c90:	4916      	ldr	r1, [pc, #88]	; (4cec <TwoWire::begin()+0x90>)
	//pinMode(4, OUTPUT);
}

void TwoWire::setClock(uint32_t frequency)
{
	if (!(hardware.clock_gate_register & hardware.clock_gate_mask)) return;
    4c92:	6814      	ldr	r4, [r2, #0]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    4c94:	4413      	add	r3, r2
    4c96:	7a1d      	ldrb	r5, [r3, #8]
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    4c98:	7b5b      	ldrb	r3, [r3, #13]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    4c9a:	eb01 05c5 	add.w	r5, r1, r5, lsl #3
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    4c9e:	021b      	lsls	r3, r3, #8
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    4ca0:	686d      	ldr	r5, [r5, #4]
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    4ca2:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4ca6:	f043 0364 	orr.w	r3, r3, #100	; 0x64
    4caa:	602b      	str	r3, [r5, #0]
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    4cac:	f890 3062 	ldrb.w	r3, [r0, #98]	; 0x62
    4cb0:	4413      	add	r3, r2
    4cb2:	7c9d      	ldrb	r5, [r3, #18]
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    4cb4:	7ddb      	ldrb	r3, [r3, #23]
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    4cb6:	eb01 01c5 	add.w	r1, r1, r5, lsl #3
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    4cba:	021b      	lsls	r3, r3, #8
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    4cbc:	6849      	ldr	r1, [r1, #4]
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    4cbe:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4cc2:	f043 0364 	orr.w	r3, r3, #100	; 0x64
    4cc6:	600b      	str	r3, [r1, #0]
	//pinMode(4, OUTPUT);
}

void TwoWire::setClock(uint32_t frequency)
{
	if (!(hardware.clock_gate_register & hardware.clock_gate_mask)) return;
    4cc8:	6821      	ldr	r1, [r4, #0]
    4cca:	6853      	ldr	r3, [r2, #4]
    4ccc:	4219      	tst	r1, r3
    4cce:	d005      	beq.n	4cdc <TwoWire::begin()+0x80>
    4cd0:	6903      	ldr	r3, [r0, #16]
		port().F = I2C_F_DIV64; // 1.0 MHz
	}
	port().FLT = 4;
#elif F_BUS == 60000000
	if (frequency < 400000) {
		port().F = 0x2C;	// 104 kHz
    4cd2:	222c      	movs	r2, #44	; 0x2c
    4cd4:	705a      	strb	r2, [r3, #1]
    4cd6:	6903      	ldr	r3, [r0, #16]
	} else if (frequency < 1000000) {
		port().F = 0x1C; // 416 kHz
	} else {
		port().F = 0x12; // 938 kHz
	}
	port().FLT = 4;
    4cd8:	2204      	movs	r2, #4
    4cda:	719a      	strb	r2, [r3, #6]
    4cdc:	6903      	ldr	r3, [r0, #16]
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	setClock(100000);
	port().C2 = I2C_C2_HDRS;
    4cde:	2220      	movs	r2, #32
    4ce0:	715a      	strb	r2, [r3, #5]
    4ce2:	6903      	ldr	r3, [r0, #16]
	port().C1 = I2C_C1_IICEN;
    4ce4:	2280      	movs	r2, #128	; 0x80
    4ce6:	709a      	strb	r2, [r3, #2]
	//pinMode(3, OUTPUT);
	//pinMode(4, OUTPUT);
}
    4ce8:	bc30      	pop	{r4, r5}
    4cea:	4770      	bx	lr
    4cec:	0000c1bc 	.word	0x0000c1bc

00004cf0 <TwoWire::isr()>:
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    4cf0:	b538      	push	{r3, r4, r5, lr}
    4cf2:	6902      	ldr	r2, [r0, #16]
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
    4cf4:	78d4      	ldrb	r4, [r2, #3]
    4cf6:	b2e4      	uxtb	r4, r4
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    4cf8:	06e1      	lsls	r1, r4, #27
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    4cfa:	4605      	mov	r5, r0
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    4cfc:	d524      	bpl.n	4d48 <TwoWire::isr()+0x58>
		// Arbitration Lost
		port().S = I2C_S_ARBL;
    4cfe:	2310      	movs	r3, #16
    4d00:	70d3      	strb	r3, [r2, #3]
		if (receiving && rxBufferLength > 0) {
			// TODO: does this detect the STOP condition in slave receive mode?


		}
		if (!(status & I2C_S_IAAS)) return;
    4d02:	0663      	lsls	r3, r4, #25
    4d04:	d51f      	bpl.n	4d46 <TwoWire::isr()+0x56>
	}
	if (status & I2C_S_IAAS) {
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
    4d06:	f004 0404 	and.w	r4, r4, #4
    4d0a:	f004 03ff 	and.w	r3, r4, #255	; 0xff
    4d0e:	2c00      	cmp	r4, #0
    4d10:	d05a      	beq.n	4dc8 <TwoWire::isr()+0xd8>
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
    4d12:	4942      	ldr	r1, [pc, #264]	; (4e1c <TwoWire::isr()+0x12c>)
			txBufferLength = 0;
			if (user_onRequest != NULL) {
    4d14:	6e6a      	ldr	r2, [r5, #100]	; 0x64
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
    4d16:	2300      	movs	r3, #0
    4d18:	700b      	strb	r3, [r1, #0]
			txBufferLength = 0;
    4d1a:	f885 305d 	strb.w	r3, [r5, #93]	; 0x5d
			if (user_onRequest != NULL) {
    4d1e:	2a00      	cmp	r2, #0
    4d20:	d066      	beq.n	4df0 <TwoWire::isr()+0x100>
				user_onRequest();
    4d22:	4790      	blx	r2
			}
			if (txBufferLength == 0) {
    4d24:	f895 305d 	ldrb.w	r3, [r5, #93]	; 0x5d
    4d28:	2b00      	cmp	r3, #0
    4d2a:	d061      	beq.n	4df0 <TwoWire::isr()+0x100>
    4d2c:	692b      	ldr	r3, [r5, #16]
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
				txBuffer[0] = 0;
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    4d2e:	22d0      	movs	r2, #208	; 0xd0
    4d30:	709a      	strb	r2, [r3, #2]
    4d32:	692b      	ldr	r3, [r5, #16]
			port().D = txBuffer[0];
    4d34:	f895 203b 	ldrb.w	r2, [r5, #59]	; 0x3b
    4d38:	711a      	strb	r2, [r3, #4]
    4d3a:	692b      	ldr	r3, [r5, #16]
			txBufferIndex = 1;
    4d3c:	2201      	movs	r2, #1
    4d3e:	f885 205c 	strb.w	r2, [r5, #92]	; 0x5c
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    4d42:	2202      	movs	r2, #2
    4d44:	70da      	strb	r2, [r3, #3]
    4d46:	bd38      	pop	{r3, r4, r5, pc}


		}
		if (!(status & I2C_S_IAAS)) return;
	}
	if (status & I2C_S_IAAS) {
    4d48:	f004 0340 	and.w	r3, r4, #64	; 0x40
    4d4c:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    4d50:	2b00      	cmp	r3, #0
    4d52:	d1d8      	bne.n	4d06 <TwoWire::isr()+0x16>
		}
		port().S = I2C_S_IICIF;
		return;
	}
	#if defined(WIRE_HAS_STOP_INTERRUPT)
	c1 = port().FLT;
    4d54:	7993      	ldrb	r3, [r2, #6]
    4d56:	b2db      	uxtb	r3, r3
	if ((c1 & I2C_FLT_STOPF) && (c1 & I2C_FLT_STOPIE)) {
    4d58:	f003 0160 	and.w	r1, r3, #96	; 0x60
    4d5c:	2960      	cmp	r1, #96	; 0x60
    4d5e:	d04e      	beq.n	4dfe <TwoWire::isr()+0x10e>
			rxBufferIndex = 0;
			user_onReceive(rxBufferLength);
		}
	}
	#endif
	c1 = port().C1;
    4d60:	7893      	ldrb	r3, [r2, #2]
	if (c1 & I2C_C1_TX) {
    4d62:	f003 0310 	and.w	r3, r3, #16
    4d66:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    4d6a:	b1b3      	cbz	r3, 4d9a <TwoWire::isr()+0xaa>
		// Continue Slave Transmit
		//serial_print("t");
		if ((status & I2C_S_RXAK) == 0) {
    4d6c:	f014 0401 	ands.w	r4, r4, #1
    4d70:	d137      	bne.n	4de2 <TwoWire::isr()+0xf2>
			//serial_print(".");
			// Master ACK'd previous byte
			if (txBufferIndex < txBufferLength) {
    4d72:	f895 305c 	ldrb.w	r3, [r5, #92]	; 0x5c
    4d76:	f895 105d 	ldrb.w	r1, [r5, #93]	; 0x5d
    4d7a:	4299      	cmp	r1, r3
    4d7c:	d94b      	bls.n	4e16 <TwoWire::isr()+0x126>
				port().D = txBuffer[txBufferIndex++];
    4d7e:	1c59      	adds	r1, r3, #1
    4d80:	442b      	add	r3, r5
    4d82:	f885 105c 	strb.w	r1, [r5, #92]	; 0x5c
    4d86:	f893 303b 	ldrb.w	r3, [r3, #59]	; 0x3b
    4d8a:	7113      	strb	r3, [r2, #4]
    4d8c:	692b      	ldr	r3, [r5, #16]
			} else {
				port().D = 0;
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    4d8e:	22d0      	movs	r2, #208	; 0xd0
    4d90:	709a      	strb	r2, [r3, #2]
    4d92:	692b      	ldr	r3, [r5, #16]
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    4d94:	2202      	movs	r2, #2
    4d96:	70da      	strb	r2, [r3, #3]
    4d98:	e7d5      	b.n	4d46 <TwoWire::isr()+0x56>
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
			data = port().D;
		}
	} else {
		// Continue Slave Receive
		irqcount = 0;
    4d9a:	f885 1060 	strb.w	r1, [r5, #96]	; 0x60
		#ifdef WIRE_HAS_STOP_INTERRUPT
		port().FLT |= I2C_FLT_STOPIE;
    4d9e:	7993      	ldrb	r3, [r2, #6]
    4da0:	f043 0320 	orr.w	r3, r3, #32
    4da4:	7193      	strb	r3, [r2, #6]
    4da6:	692b      	ldr	r3, [r5, #16]
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    4da8:	f895 1039 	ldrb.w	r1, [r5, #57]	; 0x39
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    4dac:	791a      	ldrb	r2, [r3, #4]
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    4dae:	291f      	cmp	r1, #31
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    4db0:	b2d2      	uxtb	r2, r2
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    4db2:	d8c6      	bhi.n	4d42 <TwoWire::isr()+0x52>
    4db4:	4819      	ldr	r0, [pc, #100]	; (4e1c <TwoWire::isr()+0x12c>)
    4db6:	7800      	ldrb	r0, [r0, #0]
    4db8:	2800      	cmp	r0, #0
    4dba:	d0c2      	beq.n	4d42 <TwoWire::isr()+0x52>
			rxBuffer[rxBufferLength++] = data;
    4dbc:	1868      	adds	r0, r5, r1
    4dbe:	3101      	adds	r1, #1
    4dc0:	f885 1039 	strb.w	r1, [r5, #57]	; 0x39
    4dc4:	7602      	strb	r2, [r0, #24]
    4dc6:	e7bc      	b.n	4d42 <TwoWire::isr()+0x52>
    4dc8:	692a      	ldr	r2, [r5, #16]
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
			rxBufferLength = 0;
    4dca:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
    4dce:	23c0      	movs	r3, #192	; 0xc0
    4dd0:	7093      	strb	r3, [r2, #2]
    4dd2:	692b      	ldr	r3, [r5, #16]
			port().D = txBuffer[0];
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
    4dd4:	4a11      	ldr	r2, [pc, #68]	; (4e1c <TwoWire::isr()+0x12c>)
			rxBufferLength = 0;
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
			data = port().D;
    4dd6:	7919      	ldrb	r1, [r3, #4]
			port().D = txBuffer[0];
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
    4dd8:	2101      	movs	r1, #1
    4dda:	7011      	strb	r1, [r2, #0]
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    4ddc:	2202      	movs	r2, #2
    4dde:	70da      	strb	r2, [r3, #3]
    4de0:	e7b1      	b.n	4d46 <TwoWire::isr()+0x56>
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
		} else {
			//serial_print("*");
			// Master did not ACK previous byte
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
    4de2:	23c0      	movs	r3, #192	; 0xc0
    4de4:	7093      	strb	r3, [r2, #2]
    4de6:	692b      	ldr	r3, [r5, #16]
			data = port().D;
    4de8:	791a      	ldrb	r2, [r3, #4]
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    4dea:	2202      	movs	r2, #2
    4dec:	70da      	strb	r2, [r3, #3]
    4dee:	e7aa      	b.n	4d46 <TwoWire::isr()+0x56>
			}
			if (txBufferLength == 0) {
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
    4df0:	2201      	movs	r2, #1
				txBuffer[0] = 0;
    4df2:	2300      	movs	r3, #0
			}
			if (txBufferLength == 0) {
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
    4df4:	f885 205d 	strb.w	r2, [r5, #93]	; 0x5d
				txBuffer[0] = 0;
    4df8:	f885 303b 	strb.w	r3, [r5, #59]	; 0x3b
    4dfc:	e796      	b.n	4d2c <TwoWire::isr()+0x3c>
		return;
	}
	#if defined(WIRE_HAS_STOP_INTERRUPT)
	c1 = port().FLT;
	if ((c1 & I2C_FLT_STOPF) && (c1 & I2C_FLT_STOPIE)) {
		port().FLT = c1 & ~I2C_FLT_STOPIE;
    4dfe:	f003 03df 	and.w	r3, r3, #223	; 0xdf
    4e02:	7193      	strb	r3, [r2, #6]
		if (user_onReceive != NULL) {
    4e04:	6eab      	ldr	r3, [r5, #104]	; 0x68
    4e06:	b123      	cbz	r3, 4e12 <TwoWire::isr()+0x122>
			rxBufferIndex = 0;
    4e08:	f885 0038 	strb.w	r0, [r5, #56]	; 0x38
			user_onReceive(rxBufferLength);
    4e0c:	f895 0039 	ldrb.w	r0, [r5, #57]	; 0x39
    4e10:	4798      	blx	r3
    4e12:	692a      	ldr	r2, [r5, #16]
    4e14:	e7a4      	b.n	4d60 <TwoWire::isr()+0x70>
			//serial_print(".");
			// Master ACK'd previous byte
			if (txBufferIndex < txBufferLength) {
				port().D = txBuffer[txBufferIndex++];
			} else {
				port().D = 0;
    4e16:	7114      	strb	r4, [r2, #4]
    4e18:	e7b8      	b.n	4d8c <TwoWire::isr()+0x9c>
    4e1a:	bf00      	nop
    4e1c:	1fff2c00 	.word	0x1fff2c00

00004e20 <TwoWire::wait_idle()>:
	}
	return 0;
}

bool TwoWire::wait_idle(void)
{
    4e20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4e24:	4f37      	ldr	r7, [pc, #220]	; (4f04 <L_1438_delayMicroseconds+0x18>)
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    4e26:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 4f08 <L_1438_delayMicroseconds+0x1c>
    4e2a:	683b      	ldr	r3, [r7, #0]
    4e2c:	6902      	ldr	r2, [r0, #16]
	}
	return 0;
}

bool TwoWire::wait_idle(void)
{
    4e2e:	b082      	sub	sp, #8
    4e30:	4606      	mov	r6, r0
    4e32:	9300      	str	r3, [sp, #0]
	return ret;
    4e34:	f8dd 8000 	ldr.w	r8, [sp]
	bool reset=false;
    4e38:	2100      	movs	r1, #0
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    4e3a:	f44f 7596 	mov.w	r5, #300	; 0x12c
	uint8_t i2c_status(void) {
		return port().S;
    4e3e:	78d3      	ldrb	r3, [r2, #3]
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    4e40:	069b      	lsls	r3, r3, #26
    4e42:	d55b      	bpl.n	4efc <L_1438_delayMicroseconds+0x10>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4e44:	683b      	ldr	r3, [r7, #0]
    4e46:	9301      	str	r3, [sp, #4]
	return ret;
    4e48:	9b01      	ldr	r3, [sp, #4]
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
    4e4a:	ebc8 0303 	rsb	r3, r8, r3
#if 1
		if (waited > 15 && !reset) {
    4e4e:	2b0f      	cmp	r3, #15
    4e50:	d9f5      	bls.n	4e3e <TwoWire::wait_idle()+0x1e>
    4e52:	b149      	cbz	r1, 4e68 <TwoWire::wait_idle()+0x48>
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			delayMicroseconds(10);
			continue;
		}
#endif
		if (waited > 16) {
    4e54:	2b10      	cmp	r3, #16
    4e56:	d0f2      	beq.n	4e3e <TwoWire::wait_idle()+0x1e>
			// bus stuck busy too long
			port().C1 = 0;
    4e58:	2000      	movs	r0, #0
    4e5a:	7090      	strb	r0, [r2, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    4e5c:	6933      	ldr	r3, [r6, #16]
			port().C1 = I2C_C1_IICEN;
    4e5e:	2280      	movs	r2, #128	; 0x80
    4e60:	709a      	strb	r2, [r3, #2]
			//return 4; // timeout waiting for bus
			return false;
		}
	}
	return true;
}
    4e62:	b002      	add	sp, #8
    4e64:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uint32_t waited = millis() - wait_begin;
#if 1
		if (waited > 15 && !reset) {
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
    4e68:	6972      	ldr	r2, [r6, #20]
    4e6a:	f896 3061 	ldrb.w	r3, [r6, #97]	; 0x61
    4e6e:	4413      	add	r3, r2
			pinMode(sda_pin, INPUT_DISABLE);
    4e70:	2105      	movs	r1, #5
    4e72:	7a18      	ldrb	r0, [r3, #8]
    4e74:	f001 fec8 	bl	6c08 <pinMode>
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
    4e78:	6972      	ldr	r2, [r6, #20]
    4e7a:	f896 3061 	ldrb.w	r3, [r6, #97]	; 0x61
    4e7e:	4413      	add	r3, r2
			pinMode(scl_pin, OUTPUT);
    4e80:	2101      	movs	r1, #1
		if (waited > 15 && !reset) {
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
    4e82:	f893 a012 	ldrb.w	sl, [r3, #18]
			pinMode(scl_pin, OUTPUT);
    4e86:	4650      	mov	r0, sl
    4e88:	f001 febe 	bl	6c08 <pinMode>
    4e8c:	2409      	movs	r4, #9
			for (int i=0; i < 9; i++) {
				digitalWrite(scl_pin, LOW);
    4e8e:	2100      	movs	r1, #0
    4e90:	4650      	mov	r0, sl
    4e92:	f001 feb3 	bl	6bfc <digitalWrite>
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    4e96:	462b      	mov	r3, r5

00004e98 <L_1373_delayMicroseconds>:
    4e98:	3b01      	subs	r3, #1
    4e9a:	d1fd      	bne.n	4e98 <L_1373_delayMicroseconds>
				delayMicroseconds(5);
				digitalWrite(scl_pin, HIGH);
    4e9c:	2101      	movs	r1, #1
    4e9e:	4650      	mov	r0, sl
    4ea0:	f001 feac 	bl	6bfc <digitalWrite>
    4ea4:	462b      	mov	r3, r5

00004ea6 <L_1387_delayMicroseconds>:
    4ea6:	3b01      	subs	r3, #1
    4ea8:	d1fd      	bne.n	4ea6 <L_1387_delayMicroseconds>
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
			pinMode(scl_pin, OUTPUT);
			for (int i=0; i < 9; i++) {
    4eaa:	3c01      	subs	r4, #1
    4eac:	d1ef      	bne.n	4e8e <TwoWire::wait_idle()+0x6e>
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    4eae:	6970      	ldr	r0, [r6, #20]
    4eb0:	f896 1061 	ldrb.w	r1, [r6, #97]	; 0x61
    4eb4:	4401      	add	r1, r0
    4eb6:	f44f 7216 	mov.w	r2, #600	; 0x258
    4eba:	7a0c      	ldrb	r4, [r1, #8]
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    4ebc:	7b4b      	ldrb	r3, [r1, #13]
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    4ebe:	eb09 01c4 	add.w	r1, r9, r4, lsl #3
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    4ec2:	021b      	lsls	r3, r3, #8
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    4ec4:	6849      	ldr	r1, [r1, #4]
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    4ec6:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4eca:	f043 0364 	orr.w	r3, r3, #100	; 0x64
    4ece:	600b      	str	r3, [r1, #0]
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    4ed0:	f896 3062 	ldrb.w	r3, [r6, #98]	; 0x62
    4ed4:	4403      	add	r3, r0
    4ed6:	7c99      	ldrb	r1, [r3, #18]
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    4ed8:	7ddb      	ldrb	r3, [r3, #23]
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    4eda:	eb09 01c1 	add.w	r1, r9, r1, lsl #3
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    4ede:	021b      	lsls	r3, r3, #8
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    4ee0:	6849      	ldr	r1, [r1, #4]
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    4ee2:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4ee6:	f043 0364 	orr.w	r3, r3, #100	; 0x64
    4eea:	600b      	str	r3, [r1, #0]

00004eec <L_1438_delayMicroseconds>:
    4eec:	3a01      	subs	r2, #1
    4eee:	d1fd      	bne.n	4eec <L_1438_delayMicroseconds>
    4ef0:	6932      	ldr	r2, [r6, #16]
	uint8_t i2c_status(void) {
		return port().S;
    4ef2:	78d3      	ldrb	r3, [r2, #3]
{
	bool reset=false;
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    4ef4:	069b      	lsls	r3, r3, #26
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
#if 1
		if (waited > 15 && !reset) {
			reset = true;
    4ef6:	f04f 0101 	mov.w	r1, #1
{
	bool reset=false;
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    4efa:	d4a3      	bmi.n	4e44 <TwoWire::wait_idle()+0x24>
			//Serial.println("abort");
			//return 4; // timeout waiting for bus
			return false;
		}
	}
	return true;
    4efc:	2001      	movs	r0, #1
}
    4efe:	b002      	add	sp, #8
    4f00:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4f04:	1fff2c04 	.word	0x1fff2c04
    4f08:	0000c1bc 	.word	0x0000c1bc

00004f0c <TwoWire::endTransmission(unsigned char)>:

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    4f0c:	b5f0      	push	{r4, r5, r6, r7, lr}
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    4f0e:	6903      	ldr	r3, [r0, #16]
	uint8_t i, status, ret=0;
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    4f10:	2212      	movs	r2, #18
    4f12:	70da      	strb	r2, [r3, #3]
    4f14:	6902      	ldr	r2, [r0, #16]
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    4f16:	7893      	ldrb	r3, [r2, #2]
    4f18:	f003 0320 	and.w	r3, r3, #32
	}
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    4f1c:	b085      	sub	sp, #20
    4f1e:	4604      	mov	r4, r0
    4f20:	460d      	mov	r5, r1
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    4f22:	2b00      	cmp	r3, #0
    4f24:	d05e      	beq.n	4fe4 <TwoWire::endTransmission(unsigned char)+0xd8>
		// we are already the bus master, so send a repeated start
		//Serial.print("rstart:");
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
    4f26:	23b4      	movs	r3, #180	; 0xb4
    4f28:	7093      	strb	r3, [r2, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4f2a:	493c      	ldr	r1, [pc, #240]	; (501c <TwoWire::endTransmission(unsigned char)+0x110>)
    4f2c:	6922      	ldr	r2, [r4, #16]
    4f2e:	680b      	ldr	r3, [r1, #0]
    4f30:	9300      	str	r3, [sp, #0]
	return ret;
    4f32:	9e00      	ldr	r6, [sp, #0]
    4f34:	e005      	b.n	4f42 <TwoWire::endTransmission(unsigned char)+0x36>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4f36:	680b      	ldr	r3, [r1, #0]
    4f38:	9301      	str	r3, [sp, #4]
	return ret;
    4f3a:	9b01      	ldr	r3, [sp, #4]
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		//Serial.write('*') ;
		if (millis() - wait_begin > 4) {
    4f3c:	1b9b      	subs	r3, r3, r6
    4f3e:	2b04      	cmp	r3, #4
    4f40:	d842      	bhi.n	4fc8 <TwoWire::endTransmission(unsigned char)+0xbc>
	uint8_t i2c_status(void) {
		return port().S;
    4f42:	78d3      	ldrb	r3, [r2, #3]
	}
	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
    4f44:	f003 0320 	and.w	r3, r3, #32
    4f48:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    4f4c:	2b00      	cmp	r3, #0
    4f4e:	d0f2      	beq.n	4f36 <TwoWire::endTransmission(unsigned char)+0x2a>
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
    4f50:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
    4f54:	2b00      	cmp	r3, #0
    4f56:	d031      	beq.n	4fbc <TwoWire::endTransmission(unsigned char)+0xb0>
    4f58:	f04f 0e00 	mov.w	lr, #0
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
			}
		}
		port().S = I2C_S_IICIF;
    4f5c:	f04f 0c02 	mov.w	ip, #2
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
		port().D = txBuffer[i];
    4f60:	eb04 030e 	add.w	r3, r4, lr
    4f64:	f893 303b 	ldrb.w	r3, [r3, #59]	; 0x3b
    4f68:	7113      	strb	r3, [r2, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4f6a:	680b      	ldr	r3, [r1, #0]
    4f6c:	9303      	str	r3, [sp, #12]
	return ret;
    4f6e:	9f03      	ldr	r7, [sp, #12]
    4f70:	6920      	ldr	r0, [r4, #16]
    4f72:	e007      	b.n	4f84 <TwoWire::endTransmission(unsigned char)+0x78>
		//Serial.write('^');
		wait_begin = millis();
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
    4f74:	069b      	lsls	r3, r3, #26
    4f76:	d50d      	bpl.n	4f94 <TwoWire::endTransmission(unsigned char)+0x88>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4f78:	680b      	ldr	r3, [r1, #0]
    4f7a:	9302      	str	r3, [sp, #8]
	return ret;
    4f7c:	9b02      	ldr	r3, [sp, #8]
			if (millis() - wait_begin > 5) {
    4f7e:	1bdb      	subs	r3, r3, r7
    4f80:	2b05      	cmp	r3, #5
    4f82:	d828      	bhi.n	4fd6 <TwoWire::endTransmission(unsigned char)+0xca>
    4f84:	78c3      	ldrb	r3, [r0, #3]
    4f86:	b2db      	uxtb	r3, r3
		port().D = txBuffer[i];
		//Serial.write('^');
		wait_begin = millis();
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
    4f88:	f003 0202 	and.w	r2, r3, #2
    4f8c:	f002 06ff 	and.w	r6, r2, #255	; 0xff
    4f90:	2a00      	cmp	r2, #0
    4f92:	d0ef      	beq.n	4f74 <TwoWire::endTransmission(unsigned char)+0x68>
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
			}
		}
		port().S = I2C_S_IICIF;
    4f94:	f880 c003 	strb.w	ip, [r0, #3]
    4f98:	6926      	ldr	r6, [r4, #16]
    4f9a:	78f3      	ldrb	r3, [r6, #3]
    4f9c:	b2db      	uxtb	r3, r3
		//Serial.write('$');
		status = i2c_status();
		if ((status & I2C_S_ARBL)) {
    4f9e:	06df      	lsls	r7, r3, #27
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    4fa0:	4632      	mov	r2, r6
    4fa2:	d42d      	bmi.n	5000 <TwoWire::endTransmission(unsigned char)+0xf4>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("endTransmission err4\n");
			ret = 4; // 4:other error
			break;
		}
		if (!(status & I2C_S_BUSY)) {
    4fa4:	069f      	lsls	r7, r3, #26
    4fa6:	d52b      	bpl.n	5000 <TwoWire::endTransmission(unsigned char)+0xf4>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("endTransmission err5\n");
			ret = 4; // 4:other error
			break;
		}
		if (status & I2C_S_RXAK) {
    4fa8:	07db      	lsls	r3, r3, #31
    4faa:	d431      	bmi.n	5010 <TwoWire::endTransmission(unsigned char)+0x104>
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
    4fac:	f10e 0e01 	add.w	lr, lr, #1
    4fb0:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
    4fb4:	fa5f fe8e 	uxtb.w	lr, lr
    4fb8:	4573      	cmp	r3, lr
    4fba:	d8d1      	bhi.n	4f60 <TwoWire::endTransmission(unsigned char)+0x54>
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
	uint8_t i, status, ret=0;
    4fbc:	2000      	movs	r0, #0
			}
			sendStop = 1;
			break;
		}
	}
	if (sendStop) {
    4fbe:	bb1d      	cbnz	r5, 5008 <TwoWire::endTransmission(unsigned char)+0xfc>
		// send the stop condition
		port().C1 = I2C_C1_IICEN;
		// TODO: do we wait for this somehow?
	}
	transmitting = 0;
    4fc0:	2300      	movs	r3, #0
    4fc2:	f884 305e 	strb.w	r3, [r4, #94]	; 0x5e
    4fc6:	e004      	b.n	4fd2 <TwoWire::endTransmission(unsigned char)+0xc6>
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		//Serial.write('*') ;
		if (millis() - wait_begin > 4) {
			port().C1 = 0;
    4fc8:	7090      	strb	r0, [r2, #2]
    4fca:	6923      	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    4fcc:	2280      	movs	r2, #128	; 0x80
    4fce:	709a      	strb	r2, [r3, #2]
			//Serial.println("abort2");
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
    4fd0:	2004      	movs	r0, #4
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    4fd2:	b005      	add	sp, #20
    4fd4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
    4fd6:	7086      	strb	r6, [r0, #2]
    4fd8:	6923      	ldr	r3, [r4, #16]
				port().C1 = I2C_C1_IICEN;
    4fda:	2280      	movs	r2, #128	; 0x80
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
    4fdc:	2004      	movs	r0, #4
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
				port().C1 = I2C_C1_IICEN;
    4fde:	709a      	strb	r2, [r3, #2]
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    4fe0:	b005      	add	sp, #20
    4fe2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4fe4:	f003 06ff 	and.w	r6, r3, #255	; 0xff
		// we are already the bus master, so send a repeated start
		//Serial.print("rstart:");
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
    4fe8:	f7ff ff1a 	bl	4e20 <TwoWire::wait_idle()>
    4fec:	b910      	cbnz	r0, 4ff4 <TwoWire::endTransmission(unsigned char)+0xe8>
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
    4fee:	2004      	movs	r0, #4
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    4ff0:	b005      	add	sp, #20
    4ff2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4ff4:	6923      	ldr	r3, [r4, #16]
		if (!wait_idle()) {
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
    4ff6:	f884 605f 	strb.w	r6, [r4, #95]	; 0x5f
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    4ffa:	22b0      	movs	r2, #176	; 0xb0
    4ffc:	709a      	strb	r2, [r3, #2]
    4ffe:	e794      	b.n	4f2a <TwoWire::endTransmission(unsigned char)+0x1e>
			ret = 4; // 4:other error
			break;
		}
		if (!(status & I2C_S_BUSY)) {
			// suddenly lost control of the bus!
			port().C1 = I2C_C1_IICEN;
    5000:	2380      	movs	r3, #128	; 0x80
    5002:	70b3      	strb	r3, [r6, #2]
			//Serial.printf("endTransmission err5\n");
			ret = 4; // 4:other error
    5004:	2004      	movs	r0, #4
    5006:	e7da      	b.n	4fbe <TwoWire::endTransmission(unsigned char)+0xb2>
    5008:	6926      	ldr	r6, [r4, #16]
			break;
		}
	}
	if (sendStop) {
		// send the stop condition
		port().C1 = I2C_C1_IICEN;
    500a:	2380      	movs	r3, #128	; 0x80
    500c:	70b3      	strb	r3, [r6, #2]
    500e:	e7d7      	b.n	4fc0 <TwoWire::endTransmission(unsigned char)+0xb4>
			if (i == 0) {
				//Serial.printf("endTransmission err6\n");
				ret = 2; // 2:received NACK on transmit of address
			} else {
				//Serial.printf("endTransmission err7\n");
				ret = 3; // 3:received NACK on transmit of data 
    5010:	f1be 0f00 	cmp.w	lr, #0
    5014:	bf0c      	ite	eq
    5016:	2002      	moveq	r0, #2
    5018:	2003      	movne	r0, #3
    501a:	e7f6      	b.n	500a <TwoWire::endTransmission(unsigned char)+0xfe>
    501c:	1fff2c04 	.word	0x1fff2c04

00005020 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>:
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    5020:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5024:	6906      	ldr	r6, [r0, #16]
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
	uint32_t wait_begin;

	rxBufferIndex = 0;
    5026:	2500      	movs	r5, #0
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    5028:	2712      	movs	r7, #18
{
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
	uint32_t wait_begin;

	rxBufferIndex = 0;
    502a:	f880 5038 	strb.w	r5, [r0, #56]	; 0x38
	rxBufferLength = 0;
    502e:	f880 5039 	strb.w	r5, [r0, #57]	; 0x39
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    5032:	70f7      	strb	r7, [r6, #3]
    5034:	f8d0 c010 	ldr.w	ip, [r0, #16]
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    5038:	f89c e002 	ldrb.w	lr, [ip, #2]
    503c:	f00e 0e20 	and.w	lr, lr, #32
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    5040:	b088      	sub	sp, #32
    5042:	4604      	mov	r4, r0
    5044:	4688      	mov	r8, r1
    5046:	4615      	mov	r5, r2
    5048:	461e      	mov	r6, r3
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    504a:	f1be 0f00 	cmp.w	lr, #0
    504e:	d049      	beq.n	50e4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xc4>
		// we are already the bus master, so send a repeated start
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
    5050:	23b4      	movs	r3, #180	; 0xb4
    5052:	f88c 3002 	strb.w	r3, [ip, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5056:	4b7a      	ldr	r3, [pc, #488]	; (5240 <L_2952_delayMicroseconds+0x1e>)
    5058:	6921      	ldr	r1, [r4, #16]
    505a:	681a      	ldr	r2, [r3, #0]
    505c:	9200      	str	r2, [sp, #0]
	return ret;
    505e:	f8dd e000 	ldr.w	lr, [sp]
    5062:	e006      	b.n	5072 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x52>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5064:	681a      	ldr	r2, [r3, #0]
    5066:	9201      	str	r2, [sp, #4]
	return ret;
    5068:	9801      	ldr	r0, [sp, #4]
	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		if (millis() - wait_begin > 4) {
    506a:	ebce 0000 	rsb	r0, lr, r0
    506e:	2804      	cmp	r0, #4
    5070:	d830      	bhi.n	50d4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xb4>
	uint8_t i2c_status(void) {
		return port().S;
    5072:	78c8      	ldrb	r0, [r1, #3]
    5074:	f000 0020 	and.w	r0, r0, #32

	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
    5078:	f000 07ff 	and.w	r7, r0, #255	; 0xff
    507c:	2800      	cmp	r0, #0
    507e:	d0f1      	beq.n	5064 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x44>
			//Serial.printf("requestFrom err2\n");
			return 0; // error generating start condition
		}
	}
	// send the address
	port().D = (address << 1) | 1;
    5080:	ea4f 0248 	mov.w	r2, r8, lsl #1
    5084:	f042 0201 	orr.w	r2, r2, #1
    5088:	b2d2      	uxtb	r2, r2
    508a:	710a      	strb	r2, [r1, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    508c:	681a      	ldr	r2, [r3, #0]
    508e:	9202      	str	r2, [sp, #8]
	return ret;
    5090:	f8dd e008 	ldr.w	lr, [sp, #8]
    5094:	6920      	ldr	r0, [r4, #16]
    5096:	e006      	b.n	50a6 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x86>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5098:	681a      	ldr	r2, [r3, #0]
    509a:	9203      	str	r2, [sp, #12]
	return ret;
    509c:	9903      	ldr	r1, [sp, #12]
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
    509e:	ebce 0101 	rsb	r1, lr, r1
    50a2:	2905      	cmp	r1, #5
    50a4:	d82a      	bhi.n	50fc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xdc>
		}
	}
	// send the address
	port().D = (address << 1) | 1;
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
    50a6:	78c1      	ldrb	r1, [r0, #3]
    50a8:	f001 0102 	and.w	r1, r1, #2
    50ac:	f001 07ff 	and.w	r7, r1, #255	; 0xff
    50b0:	2900      	cmp	r1, #0
    50b2:	d0f1      	beq.n	5098 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x78>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("requestFrom err3\n");
			return 0; // clock stretch too long (during address)
		}
	}
	port().S = I2C_S_IICIF;
    50b4:	f04f 0c02 	mov.w	ip, #2
    50b8:	f880 c003 	strb.w	ip, [r0, #3]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    50bc:	6922      	ldr	r2, [r4, #16]
	uint8_t i2c_status(void) {
		return port().S;
    50be:	78d1      	ldrb	r1, [r2, #3]
	status = i2c_status();
	if ((status & I2C_S_RXAK) || (status & I2C_S_ARBL)) {
    50c0:	f011 0711 	ands.w	r7, r1, #17
    50c4:	d122      	bne.n	510c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xec>
		// or we lost bus arbitration to another master
		port().C1 = I2C_C1_IICEN;
		//Serial.printf("requestFrom err4\n");
		return 0;
	}
	if (length == 0) {
    50c6:	bb2d      	cbnz	r5, 5114 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf4>
		// TODO: does anybody really do zero length reads?
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
    50c8:	2e00      	cmp	r6, #0
    50ca:	bf0c      	ite	eq
    50cc:	23a0      	moveq	r3, #160	; 0xa0
    50ce:	2380      	movne	r3, #128	; 0x80
    50d0:	7093      	strb	r3, [r2, #2]
		//Serial.printf("requestFrom err5\n");
		return 0;
    50d2:	e003      	b.n	50dc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		if (millis() - wait_begin > 4) {
			port().C1 = 0;
    50d4:	708f      	strb	r7, [r1, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    50d6:	6923      	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    50d8:	2280      	movs	r2, #128	; 0x80
    50da:	709a      	strb	r2, [r3, #2]
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
	rxBufferLength = count;
	return count;
}
    50dc:	4638      	mov	r0, r7
    50de:	b008      	add	sp, #32
    50e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    50e4:	f00e 07ff 	and.w	r7, lr, #255	; 0xff
	if (port().C1 & I2C_C1_MST) {
		// we are already the bus master, so send a repeated start
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
    50e8:	f7ff fe9a 	bl	4e20 <TwoWire::wait_idle()>
    50ec:	2800      	cmp	r0, #0
    50ee:	d0f5      	beq.n	50dc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
    50f0:	6923      	ldr	r3, [r4, #16]
			//Serial.printf("requestFrom err1\n");
			return 0; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
    50f2:	f884 705f 	strb.w	r7, [r4, #95]	; 0x5f
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    50f6:	22b0      	movs	r2, #176	; 0xb0
    50f8:	709a      	strb	r2, [r3, #2]
    50fa:	e7ac      	b.n	5056 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x36>
	// send the address
	port().D = (address << 1) | 1;
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
    50fc:	7087      	strb	r7, [r0, #2]
    50fe:	6923      	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    5100:	2280      	movs	r2, #128	; 0x80
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
	rxBufferLength = count;
	return count;
}
    5102:	4638      	mov	r0, r7
	port().D = (address << 1) | 1;
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
    5104:	709a      	strb	r2, [r3, #2]
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
	rxBufferLength = count;
	return count;
}
    5106:	b008      	add	sp, #32
    5108:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	port().S = I2C_S_IICIF;
	status = i2c_status();
	if ((status & I2C_S_RXAK) || (status & I2C_S_ARBL)) {
		// the slave device did not acknowledge
		// or we lost bus arbitration to another master
		port().C1 = I2C_C1_IICEN;
    510c:	2380      	movs	r3, #128	; 0x80
    510e:	7093      	strb	r3, [r2, #2]
		//Serial.printf("requestFrom err4\n");
		return 0;
    5110:	2700      	movs	r7, #0
    5112:	e7e3      	b.n	50dc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
		// TODO: does anybody really do zero length reads?
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
		//Serial.printf("requestFrom err5\n");
		return 0;
	} else if (length == 1) {
    5114:	2d01      	cmp	r5, #1
    5116:	d078      	beq.n	520a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1ea>
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
    5118:	21a0      	movs	r1, #160	; 0xa0
    511a:	7091      	strb	r1, [r2, #2]
    511c:	6921      	ldr	r1, [r4, #16]
	}
	tmp = port().D; // initiate the first receive
    511e:	790a      	ldrb	r2, [r1, #4]
    5120:	46be      	mov	lr, r7
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
    5122:	4667      	mov	r7, ip
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    5124:	f04f 0ca8 	mov.w	ip, #168	; 0xa8
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5128:	681a      	ldr	r2, [r3, #0]
    512a:	9204      	str	r2, [sp, #16]
	return ret;
    512c:	9804      	ldr	r0, [sp, #16]
    512e:	e005      	b.n	513c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x11c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5130:	681a      	ldr	r2, [r3, #0]
    5132:	9205      	str	r2, [sp, #20]
	return ret;
    5134:	9a05      	ldr	r2, [sp, #20]
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
			if (millis() - wait_begin > 5) {
    5136:	1a12      	subs	r2, r2, r0
    5138:	2a05      	cmp	r2, #5
    513a:	d84d      	bhi.n	51d8 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1b8>
	}
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
    513c:	78ca      	ldrb	r2, [r1, #3]
    513e:	f002 0202 	and.w	r2, r2, #2
    5142:	f002 08ff 	and.w	r8, r2, #255	; 0xff
    5146:	2a00      	cmp	r2, #0
    5148:	d0f2      	beq.n	5130 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x110>
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
    514a:	70cf      	strb	r7, [r1, #3]
    514c:	6921      	ldr	r1, [r4, #16]
		status = port().S;
    514e:	78ca      	ldrb	r2, [r1, #3]
    5150:	b2d2      	uxtb	r2, r2
		if ((status & I2C_S_ARBL)) {
    5152:	f012 0f10 	tst.w	r2, #16
    5156:	4608      	mov	r0, r1
    5158:	d15d      	bne.n	5216 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f6>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7a\n");
			return count;
		}
		if (!(status & I2C_S_BUSY)) {
    515a:	0692      	lsls	r2, r2, #26
    515c:	d55b      	bpl.n	5216 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f6>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
    515e:	3d01      	subs	r5, #1
    5160:	b2ed      	uxtb	r5, r5
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    5162:	2d01      	cmp	r5, #1
    5164:	d04c      	beq.n	5200 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1e0>
		if (count < BUFFER_LENGTH) {
    5166:	f1be 0f1f 	cmp.w	lr, #31
    516a:	d93e      	bls.n	51ea <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1ca>
			rxBuffer[count++] = port().D;
		} else {
			tmp = port().D;
    516c:	790a      	ldrb	r2, [r1, #4]
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
	}
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
    516e:	2d01      	cmp	r5, #1
    5170:	d1da      	bne.n	5128 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x108>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5172:	681a      	ldr	r2, [r3, #0]
    5174:	9206      	str	r2, [sp, #24]
	return ret;
    5176:	9d06      	ldr	r5, [sp, #24]
    5178:	e005      	b.n	5186 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x166>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    517a:	681a      	ldr	r2, [r3, #0]
    517c:	9207      	str	r2, [sp, #28]
	return ret;
    517e:	9a07      	ldr	r2, [sp, #28]
			tmp = port().D;
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
    5180:	1b52      	subs	r2, r2, r5
    5182:	2a05      	cmp	r2, #5
    5184:	d856      	bhi.n	5234 <L_2952_delayMicroseconds+0x12>
		} else {
			tmp = port().D;
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
    5186:	78c2      	ldrb	r2, [r0, #3]
    5188:	f002 0202 	and.w	r2, r2, #2
    518c:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    5190:	2a00      	cmp	r2, #0
    5192:	d0f2      	beq.n	517a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x15a>
			rxBufferLength = count;
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
		}
	}
	port().S = I2C_S_IICIF;
    5194:	2302      	movs	r3, #2
    5196:	70c3      	strb	r3, [r0, #3]
    5198:	6922      	ldr	r2, [r4, #16]
	status = port().S;
    519a:	78d3      	ldrb	r3, [r2, #3]
    519c:	b2db      	uxtb	r3, r3
	if ((status & I2C_S_ARBL)) {
    519e:	06d9      	lsls	r1, r3, #27
    51a0:	d43b      	bmi.n	521a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1fa>
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
		//Serial.printf("requestFrom err9a\n");
		return count;
	}
	if (!(status & I2C_S_BUSY)) {
    51a2:	069b      	lsls	r3, r3, #26
    51a4:	d537      	bpl.n	5216 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f6>
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//Serial.printf("requestFrom err9b\n");
		return count;
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    51a6:	23b0      	movs	r3, #176	; 0xb0
	if (count < BUFFER_LENGTH) {
    51a8:	f1be 0f1f 	cmp.w	lr, #31
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//Serial.printf("requestFrom err9b\n");
		return count;
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    51ac:	7093      	strb	r3, [r2, #2]
	if (count < BUFFER_LENGTH) {
    51ae:	d843      	bhi.n	5238 <L_2952_delayMicroseconds+0x16>
    51b0:	6922      	ldr	r2, [r4, #16]
		rxBuffer[count++] = port().D;
    51b2:	eb04 030e 	add.w	r3, r4, lr
    51b6:	7912      	ldrb	r2, [r2, #4]
    51b8:	761a      	strb	r2, [r3, #24]
    51ba:	f10e 0e01 	add.w	lr, lr, #1
    51be:	fa5f fe8e 	uxtb.w	lr, lr
	} else {
		tmp = port().D;
	}
#if F_CPU > 120000000
	__asm__("nop");
    51c2:	bf00      	nop
	__asm__("nop");
    51c4:	bf00      	nop
	__asm__("nop");
    51c6:	bf00      	nop
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
    51c8:	b116      	cbz	r6, 51d0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1b0>
    51ca:	6923      	ldr	r3, [r4, #16]
    51cc:	2280      	movs	r2, #128	; 0x80
    51ce:	709a      	strb	r2, [r3, #2]
	rxBufferLength = count;
    51d0:	f884 e039 	strb.w	lr, [r4, #57]	; 0x39
	return count;
    51d4:	4677      	mov	r7, lr
    51d6:	e781      	b.n	50dc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
    51d8:	f881 8002 	strb.w	r8, [r1, #2]
    51dc:	6923      	ldr	r3, [r4, #16]
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
    51de:	2280      	movs	r2, #128	; 0x80
    51e0:	709a      	strb	r2, [r3, #2]
			rxBufferLength = count;
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
    51e2:	4677      	mov	r7, lr
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
			rxBufferLength = count;
    51e4:	f884 e039 	strb.w	lr, [r4, #57]	; 0x39
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
    51e8:	e778      	b.n	50dc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
		if (count < BUFFER_LENGTH) {
			rxBuffer[count++] = port().D;
    51ea:	eb04 020e 	add.w	r2, r4, lr
    51ee:	f891 8004 	ldrb.w	r8, [r1, #4]
    51f2:	f882 8018 	strb.w	r8, [r2, #24]
    51f6:	f10e 0e01 	add.w	lr, lr, #1
    51fa:	fa5f fe8e 	uxtb.w	lr, lr
    51fe:	e7b6      	b.n	516e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x14e>
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    5200:	f881 c002 	strb.w	ip, [r1, #2]
    5204:	6921      	ldr	r1, [r4, #16]
    5206:	4608      	mov	r0, r1
    5208:	e7ad      	b.n	5166 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x146>
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
		//Serial.printf("requestFrom err5\n");
		return 0;
	} else if (length == 1) {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    520a:	21a8      	movs	r1, #168	; 0xa8
    520c:	7091      	strb	r1, [r2, #2]
    520e:	6920      	ldr	r0, [r4, #16]


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
    5210:	46be      	mov	lr, r7
	} else if (length == 1) {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
	}
	tmp = port().D; // initiate the first receive
    5212:	7902      	ldrb	r2, [r0, #4]
    5214:	e7ad      	b.n	5172 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x152>
    5216:	4677      	mov	r7, lr
    5218:	e760      	b.n	50dc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
	if ((status & I2C_S_ARBL)) {
		// we lost bus arbitration to another master
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//digitalWriteFast(13, HIGH);
		port().S = I2C_S_ARBL;
    521a:	2110      	movs	r1, #16
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    521c:	f44f 7396 	mov.w	r3, #300	; 0x12c
    5220:	70d1      	strb	r1, [r2, #3]

00005222 <L_2952_delayMicroseconds>:
    5222:	3b01      	subs	r3, #1
    5224:	d1fd      	bne.n	5222 <L_2952_delayMicroseconds>
    5226:	6922      	ldr	r2, [r4, #16]
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
    5228:	7893      	ldrb	r3, [r2, #2]
    522a:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		//Serial.printf("requestFrom err9a\n");
		return count;
    522e:	4677      	mov	r7, lr
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//digitalWriteFast(13, HIGH);
		port().S = I2C_S_ARBL;
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
    5230:	7093      	strb	r3, [r2, #2]
		//Serial.printf("requestFrom err9a\n");
		return count;
    5232:	e753      	b.n	50dc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
    5234:	7081      	strb	r1, [r0, #2]
    5236:	e7d1      	b.n	51dc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1bc>
    5238:	6923      	ldr	r3, [r4, #16]
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
	if (count < BUFFER_LENGTH) {
		rxBuffer[count++] = port().D;
	} else {
		tmp = port().D;
    523a:	791b      	ldrb	r3, [r3, #4]
    523c:	e7c1      	b.n	51c2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1a2>
    523e:	bf00      	nop
    5240:	1fff2c04 	.word	0x1fff2c04

00005244 <i2c0_isr>:
#define MAKE_CONST(x) (__builtin_constant_p(x) ? (x) : (x))

#ifdef WIRE_IMPLEMENT_WIRE
constexpr uintptr_t i2c0_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C0));
TwoWire Wire(i2c0_addr, TwoWire::i2c0_hardware);
void i2c0_isr(void) { Wire.isr(); }
    5244:	4801      	ldr	r0, [pc, #4]	; (524c <i2c0_isr+0x8>)
    5246:	f7ff bd53 	b.w	4cf0 <TwoWire::isr()>
    524a:	bf00      	nop
    524c:	1fff0888 	.word	0x1fff0888

00005250 <i2c1_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE1
constexpr uintptr_t i2c1_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C1));
TwoWire Wire1(i2c1_addr, TwoWire::i2c1_hardware);
void i2c1_isr(void) { Wire1.isr(); }
    5250:	4801      	ldr	r0, [pc, #4]	; (5258 <i2c1_isr+0x8>)
    5252:	f7ff bd4d 	b.w	4cf0 <TwoWire::isr()>
    5256:	bf00      	nop
    5258:	1fff08f4 	.word	0x1fff08f4

0000525c <i2c2_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE2
constexpr uintptr_t i2c2_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C2));
TwoWire Wire2(i2c2_addr, TwoWire::i2c2_hardware);
void i2c2_isr(void) { Wire2.isr(); }
    525c:	4801      	ldr	r0, [pc, #4]	; (5264 <i2c2_isr+0x8>)
    525e:	f7ff bd47 	b.w	4cf0 <TwoWire::isr()>
    5262:	bf00      	nop
    5264:	1fff081c 	.word	0x1fff081c

00005268 <MPU9250::MPU9250()>:

/** Default constructor, uses default I2C address.
 * @see MPU9250_DEFAULT_ADDRESS
 */
MPU9250::MPU9250() {
    devAddr = MPU9250_DEFAULT_ADDRESS;
    5268:	2368      	movs	r3, #104	; 0x68
    526a:	7003      	strb	r3, [r0, #0]
}
    526c:	4770      	bx	lr
    526e:	bf00      	nop

00005270 <MPU9250::initialize()>:
 * after start-up). This function also sets both the accelerometer and the gyroscope
 * to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets
 * the clock source to use the X Gyro for reference, which is slightly better than
 * the default internal clock source.
 */
void MPU9250::initialize() {
    5270:	b530      	push	{r4, r5, lr}
    5272:	b083      	sub	sp, #12
 * @see getSleepEnabled()
 * @see MPU9250_RA_PWR_MGMT_1
 * @see MPU9250_PWR1_SLEEP_BIT
 */
void MPU9250::setSleepEnabled(bool enabled) {
    I2Cdev::writeBit(devAddr, MPU9250_RA_PWR_MGMT_1, MPU9250_PWR1_SLEEP_BIT, enabled);
    5274:	2400      	movs	r4, #0
 * after start-up). This function also sets both the accelerometer and the gyroscope
 * to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets
 * the clock source to use the X Gyro for reference, which is slightly better than
 * the default internal clock source.
 */
void MPU9250::initialize() {
    5276:	4605      	mov	r5, r0
 * @see getSleepEnabled()
 * @see MPU9250_RA_PWR_MGMT_1
 * @see MPU9250_PWR1_SLEEP_BIT
 */
void MPU9250::setSleepEnabled(bool enabled) {
    I2Cdev::writeBit(devAddr, MPU9250_RA_PWR_MGMT_1, MPU9250_PWR1_SLEEP_BIT, enabled);
    5278:	4623      	mov	r3, r4
    527a:	7800      	ldrb	r0, [r0, #0]
    527c:	9400      	str	r4, [sp, #0]
    527e:	2206      	movs	r2, #6
    5280:	216b      	movs	r1, #107	; 0x6b
    5282:	f7ff fc43 	bl	4b0c <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char, void*)>
 * @see MPU9250_RA_PWR_MGMT_1
 * @see MPU9250_PWR1_CLKSEL_BIT
 * @see MPU9250_PWR1_CLKSEL_LENGTH
 */
void MPU9250::setClockSource(uint8_t source) {
    I2Cdev::writeBits(devAddr, MPU9250_RA_PWR_MGMT_1, MPU9250_PWR1_CLKSEL_BIT, MPU9250_PWR1_CLKSEL_LENGTH, source);
    5286:	2301      	movs	r3, #1
    5288:	7828      	ldrb	r0, [r5, #0]
    528a:	9300      	str	r3, [sp, #0]
    528c:	9401      	str	r4, [sp, #4]
    528e:	2303      	movs	r3, #3
    5290:	2202      	movs	r2, #2
    5292:	216b      	movs	r1, #107	; 0x6b
    5294:	f7ff fc68 	bl	4b68 <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, void*)>
 * @see MPU9250_RA_GYRO_CONFIG
 * @see MPU9250_GCONFIG_FS_SEL_BIT
 * @see MPU9250_GCONFIG_FS_SEL_LENGTH
 */
void MPU9250::setFullScaleGyroRange(uint8_t range) {
    I2Cdev::writeBits(devAddr, MPU9250_RA_GYRO_CONFIG, MPU9250_GCONFIG_FS_SEL_BIT, MPU9250_GCONFIG_FS_SEL_LENGTH, range);
    5298:	7828      	ldrb	r0, [r5, #0]
    529a:	9401      	str	r4, [sp, #4]
    529c:	9400      	str	r4, [sp, #0]
    529e:	2302      	movs	r3, #2
    52a0:	2204      	movs	r2, #4
    52a2:	211b      	movs	r1, #27
    52a4:	f7ff fc60 	bl	4b68 <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, void*)>
/** Set full-scale accelerometer range.
 * @param range New full-scale accelerometer range setting
 * @see getFullScaleAccelRange()
 */
void MPU9250::setFullScaleAccelRange(uint8_t range) {
    I2Cdev::writeBits(devAddr, MPU9250_RA_ACCEL_CONFIG, MPU9250_ACONFIG_AFS_SEL_BIT, MPU9250_ACONFIG_AFS_SEL_LENGTH, range);
    52a8:	7828      	ldrb	r0, [r5, #0]
    52aa:	9401      	str	r4, [sp, #4]
    52ac:	9400      	str	r4, [sp, #0]
    52ae:	2302      	movs	r3, #2
    52b0:	2204      	movs	r2, #4
    52b2:	211c      	movs	r1, #28
    52b4:	f7ff fc58 	bl	4b68 <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char, void*)>
void MPU9250::initialize() {
    setSleepEnabled(false); // thanks to Jack Elston for pointing this one out!
    setClockSource(MPU9250_CLOCK_PLL_XGYRO);
    setFullScaleGyroRange(MPU9250_GYRO_FS_250);
    setFullScaleAccelRange(MPU9250_ACCEL_FS_2);
}
    52b8:	b003      	add	sp, #12
    52ba:	bd30      	pop	{r4, r5, pc}

000052bc <MPU9250::getMotion6(short*, short*, short*, short*, short*, short*)>:
 * @param gz 16-bit signed integer container for gyroscope Z-axis value
 * @see getAcceleration()
 * @see getRotation()
 * @see MPU9250_RA_ACCEL_XOUT_H
 */
void MPU9250::getMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {
    52bc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    I2Cdev::readBytes(devAddr, MPU9250_RA_ACCEL_XOUT_H, 14, buffer);
    52c0:	4d1b      	ldr	r5, [pc, #108]	; (5330 <MPU9250::getMotion6(short*, short*, short*, short*, short*, short*)+0x74>)
 * @param gz 16-bit signed integer container for gyroscope Z-axis value
 * @see getAcceleration()
 * @see getRotation()
 * @see MPU9250_RA_ACCEL_XOUT_H
 */
void MPU9250::getMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {
    52c2:	b082      	sub	sp, #8
    I2Cdev::readBytes(devAddr, MPU9250_RA_ACCEL_XOUT_H, 14, buffer);
    52c4:	882d      	ldrh	r5, [r5, #0]
 * @param gz 16-bit signed integer container for gyroscope Z-axis value
 * @see getAcceleration()
 * @see getRotation()
 * @see MPU9250_RA_ACCEL_XOUT_H
 */
void MPU9250::getMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {
    52c6:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    52c8:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    52ca:	4604      	mov	r4, r0
    I2Cdev::readBytes(devAddr, MPU9250_RA_ACCEL_XOUT_H, 14, buffer);
    52cc:	7800      	ldrb	r0, [r0, #0]
    52ce:	9500      	str	r5, [sp, #0]
    52d0:	2500      	movs	r5, #0
 * @param gz 16-bit signed integer container for gyroscope Z-axis value
 * @see getAcceleration()
 * @see getRotation()
 * @see MPU9250_RA_ACCEL_XOUT_H
 */
void MPU9250::getMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {
    52d2:	468a      	mov	sl, r1
    52d4:	4691      	mov	r9, r2
    52d6:	4698      	mov	r8, r3
    I2Cdev::readBytes(devAddr, MPU9250_RA_ACCEL_XOUT_H, 14, buffer);
    52d8:	9501      	str	r5, [sp, #4]
    52da:	1c63      	adds	r3, r4, #1
    52dc:	220e      	movs	r2, #14
    52de:	213b      	movs	r1, #59	; 0x3b
 * @param gz 16-bit signed integer container for gyroscope Z-axis value
 * @see getAcceleration()
 * @see getRotation()
 * @see MPU9250_RA_ACCEL_XOUT_H
 */
void MPU9250::getMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {
    52e0:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    I2Cdev::readBytes(devAddr, MPU9250_RA_ACCEL_XOUT_H, 14, buffer);
    52e2:	f7ff fb31 	bl	4948 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)>
    *ax = (((int16_t)buffer[0]) << 8) | buffer[1];
    52e6:	7862      	ldrb	r2, [r4, #1]
    52e8:	78a3      	ldrb	r3, [r4, #2]
    52ea:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    52ee:	f8aa 3000 	strh.w	r3, [sl]
    *ay = (((int16_t)buffer[2]) << 8) | buffer[3];
    52f2:	78e2      	ldrb	r2, [r4, #3]
    52f4:	7923      	ldrb	r3, [r4, #4]
    52f6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    52fa:	f8a9 3000 	strh.w	r3, [r9]
    *az = (((int16_t)buffer[4]) << 8) | buffer[5];
    52fe:	7962      	ldrb	r2, [r4, #5]
    5300:	79a3      	ldrb	r3, [r4, #6]
    5302:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    5306:	f8a8 3000 	strh.w	r3, [r8]
    *gx = (((int16_t)buffer[8]) << 8) | buffer[9];
    530a:	7a62      	ldrb	r2, [r4, #9]
    530c:	7aa3      	ldrb	r3, [r4, #10]
    530e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    5312:	803b      	strh	r3, [r7, #0]
    *gy = (((int16_t)buffer[10]) << 8) | buffer[11];
    5314:	7ae2      	ldrb	r2, [r4, #11]
    5316:	7b23      	ldrb	r3, [r4, #12]
    5318:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    531c:	8033      	strh	r3, [r6, #0]
    *gz = (((int16_t)buffer[12]) << 8) | buffer[13];
    531e:	7b62      	ldrb	r2, [r4, #13]
    5320:	7ba3      	ldrb	r3, [r4, #14]
    5322:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    5326:	802b      	strh	r3, [r5, #0]
}
    5328:	b002      	add	sp, #8
    532a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    532e:	bf00      	nop
    5330:	1fff0818 	.word	0x1fff0818

00005334 <MPU9250::getMotion9(short*, short*, short*, short*, short*, short*, short*, short*, short*)>:
 * @see getMotion6()
 * @see getAcceleration()
 * @see getRotation()
 * @see MPU9250_RA_ACCEL_XOUT_H
 */
void MPU9250::getMotion9(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz, int16_t* mx, int16_t* my, int16_t* mz) {
    5334:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5338:	b084      	sub	sp, #16
    
	//get accel and gyro
	getMotion6(ax, ay, az, gx, gy, gz);
	
	//read mag
	I2Cdev::writeByte(devAddr, MPU9250_RA_INT_PIN_CFG, 0x02); //set i2c bypass enable pin to true to access magnetometer
    533a:	4680      	mov	r8, r0
 * @see getMotion6()
 * @see getAcceleration()
 * @see getRotation()
 * @see MPU9250_RA_ACCEL_XOUT_H
 */
void MPU9250::getMotion9(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz, int16_t* mx, int16_t* my, int16_t* mz) {
    533c:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    533e:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    5340:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    
	//get accel and gyro
	getMotion6(ax, ay, az, gx, gy, gz);
    5342:	9700      	str	r7, [sp, #0]
    5344:	9601      	str	r6, [sp, #4]
    5346:	9502      	str	r5, [sp, #8]
 * @see getMotion6()
 * @see getAcceleration()
 * @see getRotation()
 * @see MPU9250_RA_ACCEL_XOUT_H
 */
void MPU9250::getMotion9(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz, int16_t* mx, int16_t* my, int16_t* mz) {
    5348:	4604      	mov	r4, r0
    534a:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    534c:	9e0e      	ldr	r6, [sp, #56]	; 0x38
    534e:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
    
	//get accel and gyro
	getMotion6(ax, ay, az, gx, gy, gz);
    5350:	f7ff ffb4 	bl	52bc <MPU9250::getMotion6(short*, short*, short*, short*, short*, short*)>
	
	//read mag
	I2Cdev::writeByte(devAddr, MPU9250_RA_INT_PIN_CFG, 0x02); //set i2c bypass enable pin to true to access magnetometer
    5354:	f818 0b01 	ldrb.w	r0, [r8], #1
    5358:	2300      	movs	r3, #0
    535a:	2202      	movs	r2, #2
    535c:	2137      	movs	r1, #55	; 0x37
    535e:	f7ff fbc9 	bl	4af4 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char, void*)>
	delay(10);
    5362:	200a      	movs	r0, #10
    5364:	f001 fc7a 	bl	6c5c <delay>
	I2Cdev::writeByte(MPU9150_RA_MAG_ADDRESS, 0x0A, 0x01); //enable the magnetometer
    5368:	2300      	movs	r3, #0
    536a:	2201      	movs	r2, #1
    536c:	210a      	movs	r1, #10
    536e:	200c      	movs	r0, #12
    5370:	f7ff fbc0 	bl	4af4 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char, void*)>
	delay(10);
    5374:	200a      	movs	r0, #10
    5376:	f001 fc71 	bl	6c5c <delay>
	I2Cdev::readBytes(MPU9150_RA_MAG_ADDRESS, MPU9150_RA_MAG_XOUT_L, 6, buffer);
    537a:	4b0e      	ldr	r3, [pc, #56]	; (53b4 <MPU9250::getMotion9(short*, short*, short*, short*, short*, short*, short*, short*, short*)+0x80>)
    537c:	2200      	movs	r2, #0
    537e:	881b      	ldrh	r3, [r3, #0]
    5380:	9300      	str	r3, [sp, #0]
    5382:	9201      	str	r2, [sp, #4]
    5384:	4643      	mov	r3, r8
    5386:	2206      	movs	r2, #6
    5388:	2103      	movs	r1, #3
    538a:	200c      	movs	r0, #12
    538c:	f7ff fadc 	bl	4948 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned short, void*)>
	*mx = (((int16_t)buffer[1]) << 8) | buffer[0];
    5390:	78a2      	ldrb	r2, [r4, #2]
    5392:	7863      	ldrb	r3, [r4, #1]
    5394:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    5398:	803b      	strh	r3, [r7, #0]
    *my = (((int16_t)buffer[3]) << 8) | buffer[2];
    539a:	7922      	ldrb	r2, [r4, #4]
    539c:	78e3      	ldrb	r3, [r4, #3]
    539e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    53a2:	8033      	strh	r3, [r6, #0]
    *mz = (((int16_t)buffer[5]) << 8) | buffer[4];		
    53a4:	79a2      	ldrb	r2, [r4, #6]
    53a6:	7963      	ldrb	r3, [r4, #5]
    53a8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    53ac:	802b      	strh	r3, [r5, #0]
}
    53ae:	b004      	add	sp, #16
    53b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    53b4:	1fff0818 	.word	0x1fff0818

000053b8 <Adafruit_Sensor::enableAutoRange(bool)>:
  // These must be defined by the subclass

  /*! @brief Whether we should automatically change the range (if possible) for
     higher precision
      @param enabled True if we will try to autorange */
  virtual void enableAutoRange(bool enabled) {
    53b8:	4770      	bx	lr
    53ba:	bf00      	nop

000053bc <Adafruit_BMP280_Pressure::~Adafruit_BMP280_Pressure()>:
  int _sensorID = 280;
  Adafruit_BMP280 *_theBMP280 = NULL;
};

/** Adafruit Unified Sensor interface for pressure component of BMP280 */
class Adafruit_BMP280_Pressure : public Adafruit_Sensor {
    53bc:	4770      	bx	lr
    53be:	bf00      	nop

000053c0 <Adafruit_BMP280_Temp::~Adafruit_BMP280_Temp()>:
} bmp280_calib_data;

class Adafruit_BMP280;

/** Adafruit Unified Sensor interface for temperature component of BMP280 */
class Adafruit_BMP280_Temp : public Adafruit_Sensor {
    53c0:	4770      	bx	lr
    53c2:	bf00      	nop

000053c4 <Adafruit_BMP280_Temp::~Adafruit_BMP280_Temp()>:
    53c4:	b510      	push	{r4, lr}
    53c6:	2110      	movs	r1, #16
    53c8:	4604      	mov	r4, r0
    53ca:	f002 fcf3 	bl	7db4 <operator delete(void*, unsigned int)>
    53ce:	4620      	mov	r0, r4
    53d0:	bd10      	pop	{r4, pc}
    53d2:	bf00      	nop

000053d4 <Adafruit_BMP280_Pressure::~Adafruit_BMP280_Pressure()>:
  int _sensorID = 280;
  Adafruit_BMP280 *_theBMP280 = NULL;
};

/** Adafruit Unified Sensor interface for pressure component of BMP280 */
class Adafruit_BMP280_Pressure : public Adafruit_Sensor {
    53d4:	b510      	push	{r4, lr}
    53d6:	2110      	movs	r1, #16
    53d8:	4604      	mov	r4, r0
    53da:	f002 fceb 	bl	7db4 <operator delete(void*, unsigned int)>
    53de:	4620      	mov	r0, r4
    53e0:	bd10      	pop	{r4, pc}
    53e2:	bf00      	nop

000053e4 <Adafruit_BMP280_Temp::getSensor(sensor_t*)>:
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data for the BMP280's temperature sensor
*/
/**************************************************************************/
void Adafruit_BMP280_Temp::getSensor(sensor_t *sensor) {
    53e4:	b570      	push	{r4, r5, r6, lr}
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    53e6:	2228      	movs	r2, #40	; 0x28
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data for the BMP280's temperature sensor
*/
/**************************************************************************/
void Adafruit_BMP280_Temp::getSensor(sensor_t *sensor) {
    53e8:	460c      	mov	r4, r1
    53ea:	4605      	mov	r5, r0
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    53ec:	4608      	mov	r0, r1
    53ee:	2100      	movs	r1, #0
    53f0:	f005 fd82 	bl	aef8 <memset>

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "BMP280", sizeof(sensor->name) - 1);
    53f4:	220b      	movs	r2, #11
    53f6:	490a      	ldr	r1, [pc, #40]	; (5420 <Adafruit_BMP280_Temp::getSensor(sensor_t*)+0x3c>)
    53f8:	4620      	mov	r0, r4
    53fa:	f006 fa2f 	bl	b85c <strncpy>
  sensor->name[sizeof(sensor->name) - 1] = 0;
    53fe:	2300      	movs	r3, #0
    5400:	72e3      	strb	r3, [r4, #11]
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    5402:	68ad      	ldr	r5, [r5, #8]
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  sensor->min_delay = 0;
  sensor->min_value = -40.0; /* Temperature range -40 ~ +85 C  */
    5404:	4807      	ldr	r0, [pc, #28]	; (5424 <Adafruit_BMP280_Temp::getSensor(sensor_t*)+0x40>)
  sensor->max_value = +85.0;
    5406:	4908      	ldr	r1, [pc, #32]	; (5428 <Adafruit_BMP280_Temp::getSensor(sensor_t*)+0x44>)
  sensor->resolution = 0.01; /*  0.01 C */
    5408:	4a08      	ldr	r2, [pc, #32]	; (542c <Adafruit_BMP280_Temp::getSensor(sensor_t*)+0x48>)

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "BMP280", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    540a:	6125      	str	r5, [r4, #16]
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "BMP280", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    540c:	2601      	movs	r6, #1
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    540e:	250d      	movs	r5, #13
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "BMP280", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    5410:	60e6      	str	r6, [r4, #12]
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  sensor->min_delay = 0;
    5412:	6263      	str	r3, [r4, #36]	; 0x24
  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "BMP280", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    5414:	6165      	str	r5, [r4, #20]
  sensor->min_delay = 0;
  sensor->min_value = -40.0; /* Temperature range -40 ~ +85 C  */
    5416:	61e0      	str	r0, [r4, #28]
  sensor->max_value = +85.0;
    5418:	61a1      	str	r1, [r4, #24]
  sensor->resolution = 0.01; /*  0.01 C */
    541a:	6222      	str	r2, [r4, #32]
    541c:	bd70      	pop	{r4, r5, r6, pc}
    541e:	bf00      	nop
    5420:	0000c198 	.word	0x0000c198
    5424:	c2200000 	.word	0xc2200000
    5428:	42aa0000 	.word	0x42aa0000
    542c:	3c23d70a 	.word	0x3c23d70a

00005430 <Adafruit_BMP280_Pressure::getSensor(sensor_t*)>:
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data for the BMP280's pressure sensor
*/
/**************************************************************************/
void Adafruit_BMP280_Pressure::getSensor(sensor_t *sensor) {
    5430:	b570      	push	{r4, r5, r6, lr}
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    5432:	2228      	movs	r2, #40	; 0x28
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data for the BMP280's pressure sensor
*/
/**************************************************************************/
void Adafruit_BMP280_Pressure::getSensor(sensor_t *sensor) {
    5434:	460c      	mov	r4, r1
    5436:	4605      	mov	r5, r0
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    5438:	4608      	mov	r0, r1
    543a:	2100      	movs	r1, #0
    543c:	f005 fd5c 	bl	aef8 <memset>

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "BMP280", sizeof(sensor->name) - 1);
    5440:	220b      	movs	r2, #11
    5442:	490a      	ldr	r1, [pc, #40]	; (546c <Adafruit_BMP280_Pressure::getSensor(sensor_t*)+0x3c>)
    5444:	4620      	mov	r0, r4
    5446:	f006 fa09 	bl	b85c <strncpy>
  sensor->name[sizeof(sensor->name) - 1] = 0;
    544a:	2300      	movs	r3, #0
    544c:	72e3      	strb	r3, [r4, #11]
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    544e:	68ad      	ldr	r5, [r5, #8]
  sensor->type = SENSOR_TYPE_PRESSURE;
  sensor->min_delay = 0;
  sensor->min_value = 300.0; /* 300 ~ 1100 hPa  */
    5450:	4807      	ldr	r0, [pc, #28]	; (5470 <Adafruit_BMP280_Pressure::getSensor(sensor_t*)+0x40>)
  sensor->max_value = 1100.0;
    5452:	4908      	ldr	r1, [pc, #32]	; (5474 <Adafruit_BMP280_Pressure::getSensor(sensor_t*)+0x44>)
  sensor->resolution = 0.012; /* 0.12 hPa relative */
    5454:	4a08      	ldr	r2, [pc, #32]	; (5478 <Adafruit_BMP280_Pressure::getSensor(sensor_t*)+0x48>)

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "BMP280", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    5456:	6125      	str	r5, [r4, #16]
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "BMP280", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    5458:	2601      	movs	r6, #1
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_PRESSURE;
    545a:	2506      	movs	r5, #6
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "BMP280", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    545c:	60e6      	str	r6, [r4, #12]
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_PRESSURE;
  sensor->min_delay = 0;
    545e:	6263      	str	r3, [r4, #36]	; 0x24
  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "BMP280", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_PRESSURE;
    5460:	6165      	str	r5, [r4, #20]
  sensor->min_delay = 0;
  sensor->min_value = 300.0; /* 300 ~ 1100 hPa  */
    5462:	61e0      	str	r0, [r4, #28]
  sensor->max_value = 1100.0;
    5464:	61a1      	str	r1, [r4, #24]
  sensor->resolution = 0.012; /* 0.12 hPa relative */
    5466:	6222      	str	r2, [r4, #32]
    5468:	bd70      	pop	{r4, r5, r6, pc}
    546a:	bf00      	nop
    546c:	0000c198 	.word	0x0000c198
    5470:	43960000 	.word	0x43960000
    5474:	44898000 	.word	0x44898000
    5478:	3c449ba6 	.word	0x3c449ba6

0000547c <Adafruit_BMP280::Adafruit_BMP280(TwoWire*)>:
/*!
 * @brief  BMP280 constructor using i2c
 * @param  *theWire
 *         optional wire
 */
Adafruit_BMP280::Adafruit_BMP280(TwoWire *theWire) {
    547c:	b538      	push	{r3, r4, r5, lr}
  Adafruit_BMP280_Pressure *pressure_sensor = NULL;

  /** Encapsulates the config register */
  struct config {
    /** Initialize to power-on-reset state */
    config() : t_sb(STANDBY_MS_1), filter(FILTER_OFF), none(0), spi3w_en(0) {}
    547e:	f890 2038 	ldrb.w	r2, [r0, #56]	; 0x38

  /** Encapsulates trhe ctrl_meas register */
  struct ctrl_meas {
    /** Initialize to power-on-reset state */
    ctrl_meas()
        : osrs_t(SAMPLING_NONE), osrs_p(SAMPLING_NONE), mode(MODE_SLEEP) {}
    5482:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
  _wire = theWire;
    5486:	6001      	str	r1, [r0, #0]
/*!
 * @brief  BMP280 constructor using i2c
 * @param  *theWire
 *         optional wire
 */
Adafruit_BMP280::Adafruit_BMP280(TwoWire *theWire) {
    5488:	2500      	movs	r5, #0
  Adafruit_BMP280_Pressure *pressure_sensor = NULL;

  /** Encapsulates the config register */
  struct config {
    /** Initialize to power-on-reset state */
    config() : t_sb(STANDBY_MS_1), filter(FILTER_OFF), none(0), spi3w_en(0) {}
    548a:	f002 0280 	and.w	r2, r2, #128	; 0x80

  /** Encapsulates trhe ctrl_meas register */
  struct ctrl_meas {
    /** Initialize to power-on-reset state */
    ctrl_meas()
        : osrs_t(SAMPLING_NONE), osrs_p(SAMPLING_NONE), mode(MODE_SLEEP) {}
    548e:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  Adafruit_BMP280_Pressure *pressure_sensor = NULL;

  /** Encapsulates the config register */
  struct config {
    /** Initialize to power-on-reset state */
    config() : t_sb(STANDBY_MS_1), filter(FILTER_OFF), none(0), spi3w_en(0) {}
    5492:	f365 12c7 	bfi	r2, r5, #7, #1

  /** Encapsulates trhe ctrl_meas register */
  struct ctrl_meas {
    /** Initialize to power-on-reset state */
    ctrl_meas()
        : osrs_t(SAMPLING_NONE), osrs_p(SAMPLING_NONE), mode(MODE_SLEEP) {}
    5496:	f365 1387 	bfi	r3, r5, #6, #2
    549a:	4604      	mov	r4, r0
  Adafruit_BMP280_Pressure *pressure_sensor = NULL;

  /** Encapsulates the config register */
  struct config {
    /** Initialize to power-on-reset state */
    config() : t_sb(STANDBY_MS_1), filter(FILTER_OFF), none(0), spi3w_en(0) {}
    549c:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    54a0:	6045      	str	r5, [r0, #4]
    54a2:	6085      	str	r5, [r0, #8]
    54a4:	60c5      	str	r5, [r0, #12]
    54a6:	6105      	str	r5, [r0, #16]
    54a8:	6185      	str	r5, [r0, #24]

  /** Encapsulates trhe ctrl_meas register */
  struct ctrl_meas {
    /** Initialize to power-on-reset state */
    ctrl_meas()
        : osrs_t(SAMPLING_NONE), osrs_p(SAMPLING_NONE), mode(MODE_SLEEP) {}
    54aa:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  _wire = theWire;
  temp_sensor = new Adafruit_BMP280_Temp(this);
    54ae:	2010      	movs	r0, #16
    54b0:	f002 fc7e 	bl	7db0 <operator new(unsigned int)>
    54b4:	4603      	mov	r3, r0
/** Adafruit Unified Sensor interface for temperature component of BMP280 */
class Adafruit_BMP280_Temp : public Adafruit_Sensor {
public:
  /** @brief Create an Adafruit_Sensor compatible object for the temp sensor
      @param parent A pointer to the BMP280 class */
  Adafruit_BMP280_Temp(Adafruit_BMP280 *parent) { _theBMP280 = parent; }
    54b6:	4909      	ldr	r1, [pc, #36]	; (54dc <Adafruit_BMP280::Adafruit_BMP280(TwoWire*)+0x60>)
    54b8:	60c4      	str	r4, [r0, #12]
    54ba:	f44f 728c 	mov.w	r2, #280	; 0x118
    54be:	60e0      	str	r0, [r4, #12]
    54c0:	6019      	str	r1, [r3, #0]
    54c2:	609a      	str	r2, [r3, #8]
  pressure_sensor = new Adafruit_BMP280_Pressure(this);
    54c4:	2010      	movs	r0, #16
    54c6:	f002 fc73 	bl	7db0 <operator new(unsigned int)>
    54ca:	4603      	mov	r3, r0
/** Adafruit Unified Sensor interface for pressure component of BMP280 */
class Adafruit_BMP280_Pressure : public Adafruit_Sensor {
public:
  /** @brief Create an Adafruit_Sensor compatible object for the pressure sensor
      @param parent A pointer to the BMP280 class */
  Adafruit_BMP280_Pressure(Adafruit_BMP280 *parent) { _theBMP280 = parent; }
    54cc:	4a04      	ldr	r2, [pc, #16]	; (54e0 <Adafruit_BMP280::Adafruit_BMP280(TwoWire*)+0x64>)
    54ce:	6085      	str	r5, [r0, #8]
    54d0:	60c4      	str	r4, [r0, #12]
    54d2:	6120      	str	r0, [r4, #16]
    54d4:	601a      	str	r2, [r3, #0]
}
    54d6:	4620      	mov	r0, r4
    54d8:	bd38      	pop	{r3, r4, r5, pc}
    54da:	bf00      	nop
    54dc:	0000c184 	.word	0x0000c184
    54e0:	0000c1a8 	.word	0x0000c1a8

000054e4 <Adafruit_BMP280::~Adafruit_BMP280()>:
  spi_dev = new Adafruit_SPIDevice(cspin, sckpin, misopin, mosipin);
  temp_sensor = new Adafruit_BMP280_Temp(this);
  pressure_sensor = new Adafruit_BMP280_Pressure(this);
}

Adafruit_BMP280::~Adafruit_BMP280(void) {
    54e4:	b538      	push	{r3, r4, r5, lr}
  if (spi_dev)
    54e6:	6885      	ldr	r5, [r0, #8]
  spi_dev = new Adafruit_SPIDevice(cspin, sckpin, misopin, mosipin);
  temp_sensor = new Adafruit_BMP280_Temp(this);
  pressure_sensor = new Adafruit_BMP280_Pressure(this);
}

Adafruit_BMP280::~Adafruit_BMP280(void) {
    54e8:	4604      	mov	r4, r0
  if (spi_dev)
    54ea:	b135      	cbz	r5, 54fa <Adafruit_BMP280::~Adafruit_BMP280()+0x16>
    delete spi_dev;
    54ec:	4628      	mov	r0, r5
    54ee:	f000 fbe1 	bl	5cb4 <Adafruit_SPIDevice::~Adafruit_SPIDevice()>
    54f2:	4628      	mov	r0, r5
    54f4:	212c      	movs	r1, #44	; 0x2c
    54f6:	f002 fc5d 	bl	7db4 <operator delete(void*, unsigned int)>
  if (i2c_dev)
    54fa:	6860      	ldr	r0, [r4, #4]
    54fc:	b110      	cbz	r0, 5504 <Adafruit_BMP280::~Adafruit_BMP280()+0x20>
    delete i2c_dev;
    54fe:	2110      	movs	r1, #16
    5500:	f002 fc58 	bl	7db4 <operator delete(void*, unsigned int)>
  if (temp_sensor)
    5504:	68e0      	ldr	r0, [r4, #12]
    5506:	b148      	cbz	r0, 551c <Adafruit_BMP280::~Adafruit_BMP280()+0x38>
    delete temp_sensor;
    5508:	6803      	ldr	r3, [r0, #0]
    550a:	685b      	ldr	r3, [r3, #4]
    550c:	4798      	blx	r3
  if (pressure_sensor)
    550e:	6920      	ldr	r0, [r4, #16]
    5510:	b110      	cbz	r0, 5518 <Adafruit_BMP280::~Adafruit_BMP280()+0x34>
    delete pressure_sensor;
    5512:	6803      	ldr	r3, [r0, #0]
    5514:	685b      	ldr	r3, [r3, #4]
    5516:	4798      	blx	r3
}
    5518:	4620      	mov	r0, r4
    551a:	bd38      	pop	{r3, r4, r5, pc}
    delete spi_dev;
  if (i2c_dev)
    delete i2c_dev;
  if (temp_sensor)
    delete temp_sensor;
  if (pressure_sensor)
    551c:	6920      	ldr	r0, [r4, #16]
    551e:	2800      	cmp	r0, #0
    5520:	d1f7      	bne.n	5512 <Adafruit_BMP280::~Adafruit_BMP280()+0x2e>
    5522:	e7f9      	b.n	5518 <Adafruit_BMP280::~Adafruit_BMP280()+0x34>

00005524 <Adafruit_BMP280::write8(unsigned char, unsigned char)>:
/**************************************************************************/
/*!
    @brief  Writes an 8 bit value over I2C/SPI
*/
/**************************************************************************/
void Adafruit_BMP280::write8(byte reg, byte value) {
    5524:	b510      	push	{r4, lr}
  byte buffer[2];
  buffer[1] = value;
  if (i2c_dev) {
    5526:	6843      	ldr	r3, [r0, #4]
/**************************************************************************/
/*!
    @brief  Writes an 8 bit value over I2C/SPI
*/
/**************************************************************************/
void Adafruit_BMP280::write8(byte reg, byte value) {
    5528:	b084      	sub	sp, #16
  byte buffer[2];
  buffer[1] = value;
    552a:	f88d 200d 	strb.w	r2, [sp, #13]
  if (i2c_dev) {
    552e:	b16b      	cbz	r3, 554c <Adafruit_BMP280::write8(unsigned char, unsigned char)+0x28>
    buffer[0] = reg;
    5530:	aa04      	add	r2, sp, #16
    i2c_dev->write(buffer, 2);
    5532:	2400      	movs	r4, #0
/**************************************************************************/
void Adafruit_BMP280::write8(byte reg, byte value) {
  byte buffer[2];
  buffer[1] = value;
  if (i2c_dev) {
    buffer[0] = reg;
    5534:	f802 1d04 	strb.w	r1, [r2, #-4]!
    i2c_dev->write(buffer, 2);
    5538:	4618      	mov	r0, r3
    553a:	4611      	mov	r1, r2
    553c:	9401      	str	r4, [sp, #4]
    553e:	9400      	str	r4, [sp, #0]
    5540:	2301      	movs	r3, #1
    5542:	2202      	movs	r2, #2
    5544:	f000 fafc 	bl	5b40 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)>
  } else {
    buffer[0] = reg & ~0x80;
    spi_dev->write(buffer, 2);
  }
}
    5548:	b004      	add	sp, #16
    554a:	bd10      	pop	{r4, pc}
  buffer[1] = value;
  if (i2c_dev) {
    buffer[0] = reg;
    i2c_dev->write(buffer, 2);
  } else {
    buffer[0] = reg & ~0x80;
    554c:	ac04      	add	r4, sp, #16
    554e:	f001 027f 	and.w	r2, r1, #127	; 0x7f
    5552:	f804 2d04 	strb.w	r2, [r4, #-4]!
    spi_dev->write(buffer, 2);
    5556:	6880      	ldr	r0, [r0, #8]
    5558:	9300      	str	r3, [sp, #0]
    555a:	4621      	mov	r1, r4
    555c:	2202      	movs	r2, #2
    555e:	f000 fcbf 	bl	5ee0 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)>
  }
}
    5562:	b004      	add	sp, #16
    5564:	bd10      	pop	{r4, pc}
    5566:	bf00      	nop

00005568 <Adafruit_BMP280::read8(unsigned char)>:
 *  @brief  Reads an 8 bit value over I2C/SPI
 *  @param  reg
 *          selected register
 *  @return value from selected register
 */
uint8_t Adafruit_BMP280::read8(byte reg) {
    5568:	b530      	push	{r4, r5, lr}
  uint8_t buffer[1];
  if (i2c_dev) {
    556a:	6844      	ldr	r4, [r0, #4]
 *  @brief  Reads an 8 bit value over I2C/SPI
 *  @param  reg
 *          selected register
 *  @return value from selected register
 */
uint8_t Adafruit_BMP280::read8(byte reg) {
    556c:	b085      	sub	sp, #20
  uint8_t buffer[1];
  if (i2c_dev) {
    buffer[0] = uint8_t(reg);
    556e:	ab04      	add	r3, sp, #16
 *          selected register
 *  @return value from selected register
 */
uint8_t Adafruit_BMP280::read8(byte reg) {
  uint8_t buffer[1];
  if (i2c_dev) {
    5570:	b16c      	cbz	r4, 558e <Adafruit_BMP280::read8(unsigned char)+0x26>
    buffer[0] = uint8_t(reg);
    5572:	f803 1d04 	strb.w	r1, [r3, #-4]!
    i2c_dev->write_then_read(buffer, 1, buffer, 1);
    5576:	2201      	movs	r2, #1
    5578:	2500      	movs	r5, #0
    557a:	4620      	mov	r0, r4
    557c:	4619      	mov	r1, r3
    557e:	e88d 0024 	stmia.w	sp, {r2, r5}
    5582:	f000 fb6f 	bl	5c64 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool)>
  } else {
    buffer[0] = uint8_t(reg | 0x80);
    spi_dev->write_then_read(buffer, 1, buffer, 1);
  }
  return buffer[0];
}
    5586:	f89d 000c 	ldrb.w	r0, [sp, #12]
    558a:	b005      	add	sp, #20
    558c:	bd30      	pop	{r4, r5, pc}
  uint8_t buffer[1];
  if (i2c_dev) {
    buffer[0] = uint8_t(reg);
    i2c_dev->write_then_read(buffer, 1, buffer, 1);
  } else {
    buffer[0] = uint8_t(reg | 0x80);
    558e:	f061 017f 	orn	r1, r1, #127	; 0x7f
    5592:	f803 1d04 	strb.w	r1, [r3, #-4]!
    spi_dev->write_then_read(buffer, 1, buffer, 1);
    5596:	2201      	movs	r2, #1
    5598:	24ff      	movs	r4, #255	; 0xff
    559a:	6880      	ldr	r0, [r0, #8]
    559c:	4619      	mov	r1, r3
    559e:	e88d 0014 	stmia.w	sp, {r2, r4}
    55a2:	f000 fd49 	bl	6038 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)>
  }
  return buffer[0];
}
    55a6:	f89d 000c 	ldrb.w	r0, [sp, #12]
    55aa:	b005      	add	sp, #20
    55ac:	bd30      	pop	{r4, r5, pc}
    55ae:	bf00      	nop

000055b0 <Adafruit_BMP280::read16(unsigned char)>:

/*!
 *  @brief  Reads a 16 bit value over I2C/SPI
 */
uint16_t Adafruit_BMP280::read16(byte reg) {
    55b0:	b530      	push	{r4, r5, lr}
  uint8_t buffer[2];

  if (i2c_dev) {
    55b2:	6842      	ldr	r2, [r0, #4]
}

/*!
 *  @brief  Reads a 16 bit value over I2C/SPI
 */
uint16_t Adafruit_BMP280::read16(byte reg) {
    55b4:	b085      	sub	sp, #20
  uint8_t buffer[2];

  if (i2c_dev) {
    buffer[0] = uint8_t(reg);
    55b6:	ab04      	add	r3, sp, #16
 *  @brief  Reads a 16 bit value over I2C/SPI
 */
uint16_t Adafruit_BMP280::read16(byte reg) {
  uint8_t buffer[2];

  if (i2c_dev) {
    55b8:	b192      	cbz	r2, 55e0 <Adafruit_BMP280::read16(unsigned char)+0x30>
    buffer[0] = uint8_t(reg);
    55ba:	f803 1d04 	strb.w	r1, [r3, #-4]!
    i2c_dev->write_then_read(buffer, 1, buffer, 2);
    55be:	2500      	movs	r5, #0
    55c0:	2402      	movs	r4, #2
    55c2:	4610      	mov	r0, r2
    55c4:	4619      	mov	r1, r3
    55c6:	e88d 0030 	stmia.w	sp, {r4, r5}
    55ca:	2201      	movs	r2, #1
    55cc:	f000 fb4a 	bl	5c64 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool)>
  } else {
    buffer[0] = uint8_t(reg | 0x80);
    spi_dev->write_then_read(buffer, 1, buffer, 2);
  }
  return uint16_t(buffer[0]) << 8 | uint16_t(buffer[1]);
    55d0:	f89d 000c 	ldrb.w	r0, [sp, #12]
    55d4:	f89d 300d 	ldrb.w	r3, [sp, #13]
}
    55d8:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
    55dc:	b005      	add	sp, #20
    55de:	bd30      	pop	{r4, r5, pc}

  if (i2c_dev) {
    buffer[0] = uint8_t(reg);
    i2c_dev->write_then_read(buffer, 1, buffer, 2);
  } else {
    buffer[0] = uint8_t(reg | 0x80);
    55e0:	f061 017f 	orn	r1, r1, #127	; 0x7f
    55e4:	f803 1d04 	strb.w	r1, [r3, #-4]!
    spi_dev->write_then_read(buffer, 1, buffer, 2);
    55e8:	24ff      	movs	r4, #255	; 0xff
    55ea:	2202      	movs	r2, #2
    55ec:	6880      	ldr	r0, [r0, #8]
    55ee:	4619      	mov	r1, r3
    55f0:	e88d 0014 	stmia.w	sp, {r2, r4}
    55f4:	2201      	movs	r2, #1
    55f6:	f000 fd1f 	bl	6038 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)>
    55fa:	e7e9      	b.n	55d0 <Adafruit_BMP280::read16(unsigned char)+0x20>

000055fc <Adafruit_BMP280::read24(unsigned char)>:
}

/*!
 *  @brief  Reads a 24 bit value over I2C/SPI
 */
uint32_t Adafruit_BMP280::read24(byte reg) {
    55fc:	b530      	push	{r4, r5, lr}
  uint8_t buffer[3];

  if (i2c_dev) {
    55fe:	6842      	ldr	r2, [r0, #4]
}

/*!
 *  @brief  Reads a 24 bit value over I2C/SPI
 */
uint32_t Adafruit_BMP280::read24(byte reg) {
    5600:	b085      	sub	sp, #20
  uint8_t buffer[3];

  if (i2c_dev) {
    buffer[0] = uint8_t(reg);
    5602:	ab04      	add	r3, sp, #16
 *  @brief  Reads a 24 bit value over I2C/SPI
 */
uint32_t Adafruit_BMP280::read24(byte reg) {
  uint8_t buffer[3];

  if (i2c_dev) {
    5604:	b1b2      	cbz	r2, 5634 <Adafruit_BMP280::read24(unsigned char)+0x38>
    buffer[0] = uint8_t(reg);
    5606:	f803 1d04 	strb.w	r1, [r3, #-4]!
    i2c_dev->write_then_read(buffer, 1, buffer, 3);
    560a:	2500      	movs	r5, #0
    560c:	2403      	movs	r4, #3
    560e:	4610      	mov	r0, r2
    5610:	4619      	mov	r1, r3
    5612:	e88d 0030 	stmia.w	sp, {r4, r5}
    5616:	2201      	movs	r2, #1
    5618:	f000 fb24 	bl	5c64 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool)>
  } else {
    buffer[0] = uint8_t(reg | 0x80);
    spi_dev->write_then_read(buffer, 1, buffer, 3);
  }
  return uint32_t(buffer[0]) << 16 | uint32_t(buffer[1]) << 8 |
         uint32_t(buffer[2]);
    561c:	f89d 300d 	ldrb.w	r3, [sp, #13]
    5620:	f89d 200c 	ldrb.w	r2, [sp, #12]
    5624:	f89d 000e 	ldrb.w	r0, [sp, #14]
    5628:	021b      	lsls	r3, r3, #8
    562a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
}
    562e:	4318      	orrs	r0, r3
    5630:	b005      	add	sp, #20
    5632:	bd30      	pop	{r4, r5, pc}

  if (i2c_dev) {
    buffer[0] = uint8_t(reg);
    i2c_dev->write_then_read(buffer, 1, buffer, 3);
  } else {
    buffer[0] = uint8_t(reg | 0x80);
    5634:	f061 017f 	orn	r1, r1, #127	; 0x7f
    5638:	f803 1d04 	strb.w	r1, [r3, #-4]!
    spi_dev->write_then_read(buffer, 1, buffer, 3);
    563c:	24ff      	movs	r4, #255	; 0xff
    563e:	2203      	movs	r2, #3
    5640:	6880      	ldr	r0, [r0, #8]
    5642:	4619      	mov	r1, r3
    5644:	e88d 0014 	stmia.w	sp, {r2, r4}
    5648:	2201      	movs	r2, #1
    564a:	f000 fcf5 	bl	6038 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)>
    564e:	e7e5      	b.n	561c <Adafruit_BMP280::read24(unsigned char)+0x20>

00005650 <Adafruit_BMP280::readTemperature() [clone .part.1]>:

/*!
 * Reads the temperature from the device.
 * @return The temperature in degress celcius.
 */
float Adafruit_BMP280::readTemperature() {
    5650:	b538      	push	{r3, r4, r5, lr}
  int32_t var1, var2;
  if (!_sensorID)
    return NAN; // begin() not called yet

  int32_t adc_T = read24(BMP280_REGISTER_TEMPDATA);
    5652:	21fa      	movs	r1, #250	; 0xfa

/*!
 * Reads the temperature from the device.
 * @return The temperature in degress celcius.
 */
float Adafruit_BMP280::readTemperature() {
    5654:	4604      	mov	r4, r0
  int32_t var1, var2;
  if (!_sensorID)
    return NAN; // begin() not called yet

  int32_t adc_T = read24(BMP280_REGISTER_TEMPDATA);
    5656:	f7ff ffd1 	bl	55fc <Adafruit_BMP280::read24(unsigned char)>
  adc_T >>= 4;

  var1 = ((((adc_T >> 3) - ((int32_t)_bmp280_calib.dig_T1 << 1))) *
    565a:	8c21      	ldrh	r1, [r4, #32]
            ((adc_T >> 4) - ((int32_t)_bmp280_calib.dig_T1))) >>
           12) *
          ((int32_t)_bmp280_calib.dig_T3)) >>
         14;

  t_fine = var1 + var2;
    565c:	f9b4 2024 	ldrsh.w	r2, [r4, #36]	; 0x24
    5660:	f9b4 5022 	ldrsh.w	r5, [r4, #34]	; 0x22
    5664:	eddf 7a0e 	vldr	s15, [pc, #56]	; 56a0 <Adafruit_BMP280::readTemperature() [clone .part.1]+0x50>
  var1 = ((((adc_T >> 3) - ((int32_t)_bmp280_calib.dig_T1 << 1))) *
          ((int32_t)_bmp280_calib.dig_T2)) >>
         11;

  var2 = (((((adc_T >> 4) - ((int32_t)_bmp280_calib.dig_T1)) *
            ((adc_T >> 4) - ((int32_t)_bmp280_calib.dig_T1))) >>
    5668:	ebc1 2320 	rsb	r3, r1, r0, asr #8
           12) *
          ((int32_t)_bmp280_calib.dig_T3)) >>
         14;

  t_fine = var1 + var2;
    566c:	fb03 f303 	mul.w	r3, r3, r3
    5670:	131b      	asrs	r3, r3, #12
    5672:	0049      	lsls	r1, r1, #1
    5674:	ebc1 11e0 	rsb	r1, r1, r0, asr #7
    5678:	fb02 f303 	mul.w	r3, r2, r3
    567c:	139b      	asrs	r3, r3, #14
    567e:	fb05 f001 	mul.w	r0, r5, r1
    5682:	eb03 20e0 	add.w	r0, r3, r0, asr #11
    5686:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    568a:	3380      	adds	r3, #128	; 0x80
    568c:	121b      	asrs	r3, r3, #8
    568e:	ee00 3a10 	vmov	s0, r3
    5692:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
    5696:	61e0      	str	r0, [r4, #28]

  float T = (t_fine * 5 + 128) >> 8;
  return T / 100;
}
    5698:	ee80 0a27 	vdiv.f32	s0, s0, s15
    569c:	bd38      	pop	{r3, r4, r5, pc}
    569e:	bf00      	nop
    56a0:	42c80000 	.word	0x42c80000

000056a4 <Adafruit_BMP280_Temp::getEvent(sensors_event_t*)>:
    @brief  Gets the temperature as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_BMP280_Temp::getEvent(sensors_event_t *event) {
    56a4:	b570      	push	{r4, r5, r6, lr}
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));
    56a6:	2524      	movs	r5, #36	; 0x24
    @brief  Gets the temperature as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_BMP280_Temp::getEvent(sensors_event_t *event) {
    56a8:	460c      	mov	r4, r1
    56aa:	b082      	sub	sp, #8
    56ac:	4606      	mov	r6, r0
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));
    56ae:	462a      	mov	r2, r5
    56b0:	4608      	mov	r0, r1
    56b2:	2100      	movs	r1, #0
    56b4:	f005 fc20 	bl	aef8 <memset>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    56b8:	4b0d      	ldr	r3, [pc, #52]	; (56f0 <Adafruit_BMP280_Temp::getEvent(sensors_event_t*)+0x4c>)

  event->version = sizeof(sensors_event_t);
  event->sensor_id = _sensorID;
  event->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  event->timestamp = millis();
  event->temperature = _theBMP280->readTemperature();
    56ba:	68f0      	ldr	r0, [r6, #12]
    56bc:	681b      	ldr	r3, [r3, #0]
    56be:	9301      	str	r3, [sp, #4]
 * Reads the temperature from the device.
 * @return The temperature in degress celcius.
 */
float Adafruit_BMP280::readTemperature() {
  int32_t var1, var2;
  if (!_sensorID)
    56c0:	6983      	ldr	r3, [r0, #24]
bool Adafruit_BMP280_Temp::getEvent(sensors_event_t *event) {
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));

  event->version = sizeof(sensors_event_t);
  event->sensor_id = _sensorID;
    56c2:	68b6      	ldr	r6, [r6, #8]
	return ret;
    56c4:	9a01      	ldr	r2, [sp, #4]
/**************************************************************************/
bool Adafruit_BMP280_Temp::getEvent(sensors_event_t *event) {
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));

  event->version = sizeof(sensors_event_t);
    56c6:	6025      	str	r5, [r4, #0]
  event->sensor_id = _sensorID;
  event->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    56c8:	210d      	movs	r1, #13
bool Adafruit_BMP280_Temp::getEvent(sensors_event_t *event) {
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));

  event->version = sizeof(sensors_event_t);
  event->sensor_id = _sensorID;
    56ca:	6066      	str	r6, [r4, #4]
  event->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    56cc:	60a1      	str	r1, [r4, #8]
  event->timestamp = millis();
    56ce:	6122      	str	r2, [r4, #16]
 * Reads the temperature from the device.
 * @return The temperature in degress celcius.
 */
float Adafruit_BMP280::readTemperature() {
  int32_t var1, var2;
  if (!_sensorID)
    56d0:	b933      	cbnz	r3, 56e0 <Adafruit_BMP280_Temp::getEvent(sensors_event_t*)+0x3c>
    return NAN; // begin() not called yet
    56d2:	ed9f 0a08 	vldr	s0, [pc, #32]	; 56f4 <Adafruit_BMP280_Temp::getEvent(sensors_event_t*)+0x50>
  event->sensor_id = _sensorID;
  event->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  event->timestamp = millis();
  event->temperature = _theBMP280->readTemperature();
  return true;
}
    56d6:	2001      	movs	r0, #1

  event->version = sizeof(sensors_event_t);
  event->sensor_id = _sensorID;
  event->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  event->timestamp = millis();
  event->temperature = _theBMP280->readTemperature();
    56d8:	ed84 0a05 	vstr	s0, [r4, #20]
  return true;
}
    56dc:	b002      	add	sp, #8
    56de:	bd70      	pop	{r4, r5, r6, pc}
    56e0:	f7ff ffb6 	bl	5650 <Adafruit_BMP280::readTemperature() [clone .part.1]>
    56e4:	2001      	movs	r0, #1

  event->version = sizeof(sensors_event_t);
  event->sensor_id = _sensorID;
  event->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  event->timestamp = millis();
  event->temperature = _theBMP280->readTemperature();
    56e6:	ed84 0a05 	vstr	s0, [r4, #20]
  return true;
}
    56ea:	b002      	add	sp, #8
    56ec:	bd70      	pop	{r4, r5, r6, pc}
    56ee:	bf00      	nop
    56f0:	1fff2c04 	.word	0x1fff2c04
    56f4:	7fc00000 	.word	0x7fc00000

000056f8 <Adafruit_BMP280::readCoefficients()>:
}

/*!
 *  @brief  Reads the factory-set coefficients
 */
void Adafruit_BMP280::readCoefficients() {
    56f8:	b510      	push	{r4, lr}
  }
  return uint16_t(buffer[0]) << 8 | uint16_t(buffer[1]);
}

uint16_t Adafruit_BMP280::read16_LE(byte reg) {
  uint16_t temp = read16(reg);
    56fa:	2188      	movs	r1, #136	; 0x88
}

/*!
 *  @brief  Reads the factory-set coefficients
 */
void Adafruit_BMP280::readCoefficients() {
    56fc:	4604      	mov	r4, r0
  }
  return uint16_t(buffer[0]) << 8 | uint16_t(buffer[1]);
}

uint16_t Adafruit_BMP280::read16_LE(byte reg) {
  uint16_t temp = read16(reg);
    56fe:	f7ff ff57 	bl	55b0 <Adafruit_BMP280::read16(unsigned char)>

/*!
 *  @brief  Reads the factory-set coefficients
 */
void Adafruit_BMP280::readCoefficients() {
  _bmp280_calib.dig_T1 = read16_LE(BMP280_REGISTER_DIG_T1);
    5702:	ba40      	rev16	r0, r0
    5704:	8420      	strh	r0, [r4, #32]
  }
  return uint16_t(buffer[0]) << 8 | uint16_t(buffer[1]);
}

uint16_t Adafruit_BMP280::read16_LE(byte reg) {
  uint16_t temp = read16(reg);
    5706:	218a      	movs	r1, #138	; 0x8a
    5708:	4620      	mov	r0, r4
    570a:	f7ff ff51 	bl	55b0 <Adafruit_BMP280::read16(unsigned char)>
/*!
 *  @brief  Reads the factory-set coefficients
 */
void Adafruit_BMP280::readCoefficients() {
  _bmp280_calib.dig_T1 = read16_LE(BMP280_REGISTER_DIG_T1);
  _bmp280_calib.dig_T2 = readS16_LE(BMP280_REGISTER_DIG_T2);
    570e:	ba40      	rev16	r0, r0
    5710:	8460      	strh	r0, [r4, #34]	; 0x22
  }
  return uint16_t(buffer[0]) << 8 | uint16_t(buffer[1]);
}

uint16_t Adafruit_BMP280::read16_LE(byte reg) {
  uint16_t temp = read16(reg);
    5712:	218c      	movs	r1, #140	; 0x8c
    5714:	4620      	mov	r0, r4
    5716:	f7ff ff4b 	bl	55b0 <Adafruit_BMP280::read16(unsigned char)>
 *  @brief  Reads the factory-set coefficients
 */
void Adafruit_BMP280::readCoefficients() {
  _bmp280_calib.dig_T1 = read16_LE(BMP280_REGISTER_DIG_T1);
  _bmp280_calib.dig_T2 = readS16_LE(BMP280_REGISTER_DIG_T2);
  _bmp280_calib.dig_T3 = readS16_LE(BMP280_REGISTER_DIG_T3);
    571a:	ba40      	rev16	r0, r0
    571c:	84a0      	strh	r0, [r4, #36]	; 0x24
  }
  return uint16_t(buffer[0]) << 8 | uint16_t(buffer[1]);
}

uint16_t Adafruit_BMP280::read16_LE(byte reg) {
  uint16_t temp = read16(reg);
    571e:	218e      	movs	r1, #142	; 0x8e
    5720:	4620      	mov	r0, r4
    5722:	f7ff ff45 	bl	55b0 <Adafruit_BMP280::read16(unsigned char)>
void Adafruit_BMP280::readCoefficients() {
  _bmp280_calib.dig_T1 = read16_LE(BMP280_REGISTER_DIG_T1);
  _bmp280_calib.dig_T2 = readS16_LE(BMP280_REGISTER_DIG_T2);
  _bmp280_calib.dig_T3 = readS16_LE(BMP280_REGISTER_DIG_T3);

  _bmp280_calib.dig_P1 = read16_LE(BMP280_REGISTER_DIG_P1);
    5726:	ba40      	rev16	r0, r0
    5728:	84e0      	strh	r0, [r4, #38]	; 0x26
  }
  return uint16_t(buffer[0]) << 8 | uint16_t(buffer[1]);
}

uint16_t Adafruit_BMP280::read16_LE(byte reg) {
  uint16_t temp = read16(reg);
    572a:	2190      	movs	r1, #144	; 0x90
    572c:	4620      	mov	r0, r4
    572e:	f7ff ff3f 	bl	55b0 <Adafruit_BMP280::read16(unsigned char)>
  _bmp280_calib.dig_T1 = read16_LE(BMP280_REGISTER_DIG_T1);
  _bmp280_calib.dig_T2 = readS16_LE(BMP280_REGISTER_DIG_T2);
  _bmp280_calib.dig_T3 = readS16_LE(BMP280_REGISTER_DIG_T3);

  _bmp280_calib.dig_P1 = read16_LE(BMP280_REGISTER_DIG_P1);
  _bmp280_calib.dig_P2 = readS16_LE(BMP280_REGISTER_DIG_P2);
    5732:	ba40      	rev16	r0, r0
    5734:	8520      	strh	r0, [r4, #40]	; 0x28
  }
  return uint16_t(buffer[0]) << 8 | uint16_t(buffer[1]);
}

uint16_t Adafruit_BMP280::read16_LE(byte reg) {
  uint16_t temp = read16(reg);
    5736:	2192      	movs	r1, #146	; 0x92
    5738:	4620      	mov	r0, r4
    573a:	f7ff ff39 	bl	55b0 <Adafruit_BMP280::read16(unsigned char)>
  _bmp280_calib.dig_T2 = readS16_LE(BMP280_REGISTER_DIG_T2);
  _bmp280_calib.dig_T3 = readS16_LE(BMP280_REGISTER_DIG_T3);

  _bmp280_calib.dig_P1 = read16_LE(BMP280_REGISTER_DIG_P1);
  _bmp280_calib.dig_P2 = readS16_LE(BMP280_REGISTER_DIG_P2);
  _bmp280_calib.dig_P3 = readS16_LE(BMP280_REGISTER_DIG_P3);
    573e:	ba40      	rev16	r0, r0
    5740:	8560      	strh	r0, [r4, #42]	; 0x2a
  }
  return uint16_t(buffer[0]) << 8 | uint16_t(buffer[1]);
}

uint16_t Adafruit_BMP280::read16_LE(byte reg) {
  uint16_t temp = read16(reg);
    5742:	2194      	movs	r1, #148	; 0x94
    5744:	4620      	mov	r0, r4
    5746:	f7ff ff33 	bl	55b0 <Adafruit_BMP280::read16(unsigned char)>
  _bmp280_calib.dig_T3 = readS16_LE(BMP280_REGISTER_DIG_T3);

  _bmp280_calib.dig_P1 = read16_LE(BMP280_REGISTER_DIG_P1);
  _bmp280_calib.dig_P2 = readS16_LE(BMP280_REGISTER_DIG_P2);
  _bmp280_calib.dig_P3 = readS16_LE(BMP280_REGISTER_DIG_P3);
  _bmp280_calib.dig_P4 = readS16_LE(BMP280_REGISTER_DIG_P4);
    574a:	ba40      	rev16	r0, r0
    574c:	85a0      	strh	r0, [r4, #44]	; 0x2c
  }
  return uint16_t(buffer[0]) << 8 | uint16_t(buffer[1]);
}

uint16_t Adafruit_BMP280::read16_LE(byte reg) {
  uint16_t temp = read16(reg);
    574e:	2196      	movs	r1, #150	; 0x96
    5750:	4620      	mov	r0, r4
    5752:	f7ff ff2d 	bl	55b0 <Adafruit_BMP280::read16(unsigned char)>

  _bmp280_calib.dig_P1 = read16_LE(BMP280_REGISTER_DIG_P1);
  _bmp280_calib.dig_P2 = readS16_LE(BMP280_REGISTER_DIG_P2);
  _bmp280_calib.dig_P3 = readS16_LE(BMP280_REGISTER_DIG_P3);
  _bmp280_calib.dig_P4 = readS16_LE(BMP280_REGISTER_DIG_P4);
  _bmp280_calib.dig_P5 = readS16_LE(BMP280_REGISTER_DIG_P5);
    5756:	ba40      	rev16	r0, r0
    5758:	85e0      	strh	r0, [r4, #46]	; 0x2e
  }
  return uint16_t(buffer[0]) << 8 | uint16_t(buffer[1]);
}

uint16_t Adafruit_BMP280::read16_LE(byte reg) {
  uint16_t temp = read16(reg);
    575a:	2198      	movs	r1, #152	; 0x98
    575c:	4620      	mov	r0, r4
    575e:	f7ff ff27 	bl	55b0 <Adafruit_BMP280::read16(unsigned char)>
  _bmp280_calib.dig_P1 = read16_LE(BMP280_REGISTER_DIG_P1);
  _bmp280_calib.dig_P2 = readS16_LE(BMP280_REGISTER_DIG_P2);
  _bmp280_calib.dig_P3 = readS16_LE(BMP280_REGISTER_DIG_P3);
  _bmp280_calib.dig_P4 = readS16_LE(BMP280_REGISTER_DIG_P4);
  _bmp280_calib.dig_P5 = readS16_LE(BMP280_REGISTER_DIG_P5);
  _bmp280_calib.dig_P6 = readS16_LE(BMP280_REGISTER_DIG_P6);
    5762:	ba40      	rev16	r0, r0
    5764:	8620      	strh	r0, [r4, #48]	; 0x30
  }
  return uint16_t(buffer[0]) << 8 | uint16_t(buffer[1]);
}

uint16_t Adafruit_BMP280::read16_LE(byte reg) {
  uint16_t temp = read16(reg);
    5766:	219a      	movs	r1, #154	; 0x9a
    5768:	4620      	mov	r0, r4
    576a:	f7ff ff21 	bl	55b0 <Adafruit_BMP280::read16(unsigned char)>
  _bmp280_calib.dig_P2 = readS16_LE(BMP280_REGISTER_DIG_P2);
  _bmp280_calib.dig_P3 = readS16_LE(BMP280_REGISTER_DIG_P3);
  _bmp280_calib.dig_P4 = readS16_LE(BMP280_REGISTER_DIG_P4);
  _bmp280_calib.dig_P5 = readS16_LE(BMP280_REGISTER_DIG_P5);
  _bmp280_calib.dig_P6 = readS16_LE(BMP280_REGISTER_DIG_P6);
  _bmp280_calib.dig_P7 = readS16_LE(BMP280_REGISTER_DIG_P7);
    576e:	ba40      	rev16	r0, r0
    5770:	8660      	strh	r0, [r4, #50]	; 0x32
  }
  return uint16_t(buffer[0]) << 8 | uint16_t(buffer[1]);
}

uint16_t Adafruit_BMP280::read16_LE(byte reg) {
  uint16_t temp = read16(reg);
    5772:	219c      	movs	r1, #156	; 0x9c
    5774:	4620      	mov	r0, r4
    5776:	f7ff ff1b 	bl	55b0 <Adafruit_BMP280::read16(unsigned char)>
  _bmp280_calib.dig_P3 = readS16_LE(BMP280_REGISTER_DIG_P3);
  _bmp280_calib.dig_P4 = readS16_LE(BMP280_REGISTER_DIG_P4);
  _bmp280_calib.dig_P5 = readS16_LE(BMP280_REGISTER_DIG_P5);
  _bmp280_calib.dig_P6 = readS16_LE(BMP280_REGISTER_DIG_P6);
  _bmp280_calib.dig_P7 = readS16_LE(BMP280_REGISTER_DIG_P7);
  _bmp280_calib.dig_P8 = readS16_LE(BMP280_REGISTER_DIG_P8);
    577a:	ba40      	rev16	r0, r0
    577c:	86a0      	strh	r0, [r4, #52]	; 0x34
  }
  return uint16_t(buffer[0]) << 8 | uint16_t(buffer[1]);
}

uint16_t Adafruit_BMP280::read16_LE(byte reg) {
  uint16_t temp = read16(reg);
    577e:	219e      	movs	r1, #158	; 0x9e
    5780:	4620      	mov	r0, r4
    5782:	f7ff ff15 	bl	55b0 <Adafruit_BMP280::read16(unsigned char)>
  _bmp280_calib.dig_P4 = readS16_LE(BMP280_REGISTER_DIG_P4);
  _bmp280_calib.dig_P5 = readS16_LE(BMP280_REGISTER_DIG_P5);
  _bmp280_calib.dig_P6 = readS16_LE(BMP280_REGISTER_DIG_P6);
  _bmp280_calib.dig_P7 = readS16_LE(BMP280_REGISTER_DIG_P7);
  _bmp280_calib.dig_P8 = readS16_LE(BMP280_REGISTER_DIG_P8);
  _bmp280_calib.dig_P9 = readS16_LE(BMP280_REGISTER_DIG_P9);
    5786:	ba40      	rev16	r0, r0
    5788:	86e0      	strh	r0, [r4, #54]	; 0x36
    578a:	bd10      	pop	{r4, pc}

0000578c <Adafruit_BMP280::begin(unsigned char, unsigned char)>:
 *         The I2C address to use (default = 0x77)
 *  @param chipid
 *         The expected chip ID (used to validate connection).
 *  @return True if the init was successful, otherwise false.
 */
bool Adafruit_BMP280::begin(uint8_t addr, uint8_t chipid) {
    578c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    578e:	4604      	mov	r4, r0
  if (spi_dev == NULL) {
    5790:	6880      	ldr	r0, [r0, #8]
 *         The I2C address to use (default = 0x77)
 *  @param chipid
 *         The expected chip ID (used to validate connection).
 *  @return True if the init was successful, otherwise false.
 */
bool Adafruit_BMP280::begin(uint8_t addr, uint8_t chipid) {
    5792:	4615      	mov	r5, r2
  if (spi_dev == NULL) {
    5794:	b158      	cbz	r0, 57ae <Adafruit_BMP280::begin(unsigned char, unsigned char)+0x22>
    i2c_dev = new Adafruit_I2CDevice(addr, _wire);
    if (!i2c_dev->begin())
      return false;
  } else {
    // SPI mode
    if (!spi_dev->begin())
    5796:	f000 fa97 	bl	5cc8 <Adafruit_SPIDevice::begin()>
    579a:	b130      	cbz	r0, 57aa <Adafruit_BMP280::begin(unsigned char, unsigned char)+0x1e>
      return false;
  }

  // check if sensor, i.e. the chip ID is correct
  _sensorID = read8(BMP280_REGISTER_CHIPID);
    579c:	21d0      	movs	r1, #208	; 0xd0
    579e:	4620      	mov	r0, r4
    57a0:	f7ff fee2 	bl	5568 <Adafruit_BMP280::read8(unsigned char)>
  if (_sensorID != chipid)
    57a4:	42a8      	cmp	r0, r5
    if (!spi_dev->begin())
      return false;
  }

  // check if sensor, i.e. the chip ID is correct
  _sensorID = read8(BMP280_REGISTER_CHIPID);
    57a6:	61a0      	str	r0, [r4, #24]
  if (_sensorID != chipid)
    57a8:	d017      	beq.n	57da <Adafruit_BMP280::begin(unsigned char, unsigned char)+0x4e>
    // I2C mode
    if (i2c_dev)
      delete i2c_dev;
    i2c_dev = new Adafruit_I2CDevice(addr, _wire);
    if (!i2c_dev->begin())
      return false;
    57aa:	2000      	movs	r0, #0
    57ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *  @return True if the init was successful, otherwise false.
 */
bool Adafruit_BMP280::begin(uint8_t addr, uint8_t chipid) {
  if (spi_dev == NULL) {
    // I2C mode
    if (i2c_dev)
    57ae:	6860      	ldr	r0, [r4, #4]
    57b0:	460e      	mov	r6, r1
    57b2:	b110      	cbz	r0, 57ba <Adafruit_BMP280::begin(unsigned char, unsigned char)+0x2e>
      delete i2c_dev;
    57b4:	2110      	movs	r1, #16
    57b6:	f002 fafd 	bl	7db4 <operator delete(void*, unsigned int)>
    i2c_dev = new Adafruit_I2CDevice(addr, _wire);
    57ba:	2010      	movs	r0, #16
    57bc:	f002 faf8 	bl	7db0 <operator new(unsigned int)>
    57c0:	4631      	mov	r1, r6
    57c2:	4607      	mov	r7, r0
    57c4:	6822      	ldr	r2, [r4, #0]
    57c6:	f000 f985 	bl	5ad4 <Adafruit_I2CDevice::Adafruit_I2CDevice(unsigned char, TwoWire*)>
    57ca:	6067      	str	r7, [r4, #4]
    if (!i2c_dev->begin())
    57cc:	4638      	mov	r0, r7
    57ce:	2101      	movs	r1, #1
    57d0:	f000 f9a6 	bl	5b20 <Adafruit_I2CDevice::begin(bool)>
    57d4:	2800      	cmp	r0, #0
    57d6:	d1e1      	bne.n	579c <Adafruit_BMP280::begin(unsigned char, unsigned char)+0x10>
    57d8:	e7e7      	b.n	57aa <Adafruit_BMP280::begin(unsigned char, unsigned char)+0x1e>
  // check if sensor, i.e. the chip ID is correct
  _sensorID = read8(BMP280_REGISTER_CHIPID);
  if (_sensorID != chipid)
    return false;

  readCoefficients();
    57da:	4620      	mov	r0, r4
    57dc:	f7ff ff8c 	bl	56f8 <Adafruit_BMP280::readCoefficients()>
void Adafruit_BMP280::setSampling(sensor_mode mode,
                                  sensor_sampling tempSampling,
                                  sensor_sampling pressSampling,
                                  sensor_filter filter,
                                  standby_duration duration) {
  if (!_sensorID)
    57e0:	69a3      	ldr	r3, [r4, #24]
    57e2:	b923      	cbnz	r3, 57ee <Adafruit_BMP280::begin(unsigned char, unsigned char)+0x62>
    return false;

  readCoefficients();
  // write8(BMP280_REGISTER_CONTROL, 0x3F); /* needed? */
  setSampling();
  delay(100);
    57e4:	2064      	movs	r0, #100	; 0x64
    57e6:	f001 fa39 	bl	6c5c <delay>
  return true;
    57ea:	2001      	movs	r0, #1
}
    57ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                                  sensor_sampling pressSampling,
                                  sensor_filter filter,
                                  standby_duration duration) {
  if (!_sensorID)
    return; // begin() not called yet
  _measReg.mode = mode;
    57ee:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
  _measReg.osrs_t = tempSampling;
  _measReg.osrs_p = pressSampling;

  _configReg.filter = filter;
    57f2:	f894 2038 	ldrb.w	r2, [r4, #56]	; 0x38
                                  sensor_filter filter,
                                  standby_duration duration) {
  if (!_sensorID)
    return; // begin() not called yet
  _measReg.mode = mode;
  _measReg.osrs_t = tempSampling;
    57f6:	2105      	movs	r1, #5
    57f8:	f063 033f 	orn	r3, r3, #63	; 0x3f
    57fc:	f361 0302 	bfi	r3, r1, #0, #3
  _measReg.osrs_p = pressSampling;

  _configReg.filter = filter;
  _configReg.t_sb = duration;
    5800:	f002 02c7 	and.w	r2, r2, #199	; 0xc7
                                  standby_duration duration) {
  if (!_sensorID)
    return; // begin() not called yet
  _measReg.mode = mode;
  _measReg.osrs_t = tempSampling;
  _measReg.osrs_p = pressSampling;
    5804:	f361 03c5 	bfi	r3, r1, #3, #3

  _configReg.filter = filter;
  _configReg.t_sb = duration;
    5808:	f36f 0202 	bfc	r2, #0, #3
                                  standby_duration duration) {
  if (!_sensorID)
    return; // begin() not called yet
  _measReg.mode = mode;
  _measReg.osrs_t = tempSampling;
  _measReg.osrs_p = pressSampling;
    580c:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c

  _configReg.filter = filter;
  _configReg.t_sb = duration;
    5810:	f884 2038 	strb.w	r2, [r4, #56]	; 0x38

  write8(BMP280_REGISTER_CONFIG, _configReg.get());
    5814:	4620      	mov	r0, r4
    5816:	f3c2 12c0 	ubfx	r2, r2, #7, #1
    581a:	21f5      	movs	r1, #245	; 0xf5
    581c:	f7ff fe82 	bl	5524 <Adafruit_BMP280::write8(unsigned char, unsigned char)>
    /** Pressure oversampling. */
    unsigned int osrs_p : 3;
    /** Device mode */
    unsigned int mode : 2;
    /** Used to retrieve the assembled ctrl_meas register's byte value. */
    unsigned int get() { return (osrs_t << 5) | (osrs_p << 2) | mode; }
    5820:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
  write8(BMP280_REGISTER_CONTROL, _measReg.get());
    5824:	f3c2 03c2 	ubfx	r3, r2, #3, #3
    5828:	f002 0107 	and.w	r1, r2, #7
    582c:	009b      	lsls	r3, r3, #2
    582e:	ea43 1341 	orr.w	r3, r3, r1, lsl #5
    5832:	4620      	mov	r0, r4
    5834:	ea43 1292 	orr.w	r2, r3, r2, lsr #6
    5838:	21f4      	movs	r1, #244	; 0xf4
    583a:	f7ff fe73 	bl	5524 <Adafruit_BMP280::write8(unsigned char, unsigned char)>
    583e:	e7d1      	b.n	57e4 <Adafruit_BMP280::begin(unsigned char, unsigned char)+0x58>

00005840 <Adafruit_BMP280::readPressure()>:
 * Reads the barometric pressure from the device.
 * @return Barometric pressure in Pa.
 */
float Adafruit_BMP280::readPressure() {
  int64_t var1, var2, p;
  if (!_sensorID)
    5840:	6983      	ldr	r3, [r0, #24]
    5842:	2b00      	cmp	r3, #0
    5844:	f000 8100 	beq.w	5a48 <Adafruit_BMP280::readPressure()+0x208>

/*!
 * Reads the barometric pressure from the device.
 * @return Barometric pressure in Pa.
 */
float Adafruit_BMP280::readPressure() {
    5848:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    584c:	4604      	mov	r4, r0
    584e:	b085      	sub	sp, #20
    5850:	f7ff fefe 	bl	5650 <Adafruit_BMP280::readTemperature() [clone .part.1]>
    return NAN; // begin() not called yet

  // Must be done first to get the t_fine variable set up
  readTemperature();

  int32_t adc_P = read24(BMP280_REGISTER_PRESSUREDATA);
    5854:	21f7      	movs	r1, #247	; 0xf7
    5856:	4620      	mov	r0, r4
    5858:	f7ff fed0 	bl	55fc <Adafruit_BMP280::read24(unsigned char)>
  adc_P >>= 4;

  var1 = ((int64_t)t_fine) - 128000;
    585c:	69e6      	ldr	r6, [r4, #28]
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
  var2 = var2 + (((int64_t)_bmp280_calib.dig_P4) << 35);
  var1 = ((var1 * var1 * (int64_t)_bmp280_calib.dig_P3) >> 8) +
         ((var1 * (int64_t)_bmp280_calib.dig_P2) << 12);
  var1 =
      (((((int64_t)1) << 47) + var1)) * ((int64_t)_bmp280_calib.dig_P1) >> 33;
    585e:	f9b4 202a 	ldrsh.w	r2, [r4, #42]	; 0x2a
  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
  var2 = var2 + (((int64_t)_bmp280_calib.dig_P4) << 35);
  var1 = ((var1 * var1 * (int64_t)_bmp280_calib.dig_P3) >> 8) +
         ((var1 * (int64_t)_bmp280_calib.dig_P2) << 12);
    5862:	f9b4 8028 	ldrsh.w	r8, [r4, #40]	; 0x28
    return NAN; // begin() not called yet

  // Must be done first to get the t_fine variable set up
  readTemperature();

  int32_t adc_P = read24(BMP280_REGISTER_PRESSUREDATA);
    5866:	9003      	str	r0, [sp, #12]
  adc_P >>= 4;

  var1 = ((int64_t)t_fine) - 128000;
    5868:	17f7      	asrs	r7, r6, #31
    586a:	f5b6 36fa 	subs.w	r6, r6, #128000	; 0x1f400
    586e:	f147 37ff 	adc.w	r7, r7, #4294967295	; 0xffffffff
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
    5872:	fba6 ab06 	umull	sl, fp, r6, r6
    5876:	fb06 f307 	mul.w	r3, r6, r7
    587a:	eb0b 0b43 	add.w	fp, fp, r3, lsl #1
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
  var2 = var2 + (((int64_t)_bmp280_calib.dig_P4) << 35);
  var1 = ((var1 * var1 * (int64_t)_bmp280_calib.dig_P3) >> 8) +
         ((var1 * (int64_t)_bmp280_calib.dig_P2) << 12);
  var1 =
      (((((int64_t)1) << 47) + var1)) * ((int64_t)_bmp280_calib.dig_P1) >> 33;
    587e:	fb02 fe0b 	mul.w	lr, r2, fp
    5882:	17d3      	asrs	r3, r2, #31
    5884:	fb0a ee03 	mla	lr, sl, r3, lr
    5888:	fba2 230a 	umull	r2, r3, r2, sl
    588c:	4473      	add	r3, lr
    588e:	0a15      	lsrs	r5, r2, #8
    5890:	ea45 6503 	orr.w	r5, r5, r3, lsl #24
    5894:	121b      	asrs	r3, r3, #8
  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
  var2 = var2 + (((int64_t)_bmp280_calib.dig_P4) << 35);
  var1 = ((var1 * var1 * (int64_t)_bmp280_calib.dig_P3) >> 8) +
         ((var1 * (int64_t)_bmp280_calib.dig_P2) << 12);
    5896:	ea4f 79e8 	mov.w	r9, r8, asr #31
    589a:	fb08 fc07 	mul.w	ip, r8, r7
  var1 =
      (((((int64_t)1) << 47) + var1)) * ((int64_t)_bmp280_calib.dig_P1) >> 33;
    589e:	9500      	str	r5, [sp, #0]
    58a0:	9301      	str	r3, [sp, #4]
  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
  var2 = var2 + (((int64_t)_bmp280_calib.dig_P4) << 35);
  var1 = ((var1 * var1 * (int64_t)_bmp280_calib.dig_P3) >> 8) +
         ((var1 * (int64_t)_bmp280_calib.dig_P2) << 12);
    58a2:	fba8 0106 	umull	r0, r1, r8, r6
    58a6:	fb06 cc09 	mla	ip, r6, r9, ip
  var1 =
      (((((int64_t)1) << 47) + var1)) * ((int64_t)_bmp280_calib.dig_P1) >> 33;
    58aa:	e9dd 2300 	ldrd	r2, r3, [sp]
  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
  var2 = var2 + (((int64_t)_bmp280_calib.dig_P4) << 35);
  var1 = ((var1 * var1 * (int64_t)_bmp280_calib.dig_P3) >> 8) +
         ((var1 * (int64_t)_bmp280_calib.dig_P2) << 12);
    58ae:	4461      	add	r1, ip
    58b0:	ea4f 3800 	mov.w	r8, r0, lsl #12
    58b4:	ea4f 3901 	mov.w	r9, r1, lsl #12
  var1 =
      (((((int64_t)1) << 47) + var1)) * ((int64_t)_bmp280_calib.dig_P1) >> 33;
    58b8:	eb12 0208 	adds.w	r2, r2, r8
  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
  var2 = var2 + (((int64_t)_bmp280_calib.dig_P4) << 35);
  var1 = ((var1 * var1 * (int64_t)_bmp280_calib.dig_P3) >> 8) +
         ((var1 * (int64_t)_bmp280_calib.dig_P2) << 12);
    58bc:	ea49 5910 	orr.w	r9, r9, r0, lsr #20
  var1 =
      (((((int64_t)1) << 47) + var1)) * ((int64_t)_bmp280_calib.dig_P1) >> 33;
    58c0:	eb43 0309 	adc.w	r3, r3, r9
    58c4:	1c10      	adds	r0, r2, #0
    58c6:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
    58c8:	f543 4100 	adc.w	r1, r3, #32768	; 0x8000
    58cc:	fba0 8902 	umull	r8, r9, r0, r2
    58d0:	fb02 9901 	mla	r9, r2, r1, r9
    58d4:	ea4f 0269 	mov.w	r2, r9, asr #1
    58d8:	ea4f 73e9 	mov.w	r3, r9, asr #31

  if (var1 == 0) {
    58dc:	ea52 0103 	orrs.w	r1, r2, r3
    58e0:	f000 80ad 	beq.w	5a3e <Adafruit_BMP280::readPressure()+0x1fe>
  int32_t adc_P = read24(BMP280_REGISTER_PRESSUREDATA);
  adc_P >>= 4;

  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
    58e4:	f9b4 802e 	ldrsh.w	r8, [r4, #46]	; 0x2e

  if (var1 == 0) {
    return 0; // avoid exception caused by division by zero
  }
  p = 1048576 - adc_P;
  p = (((p << 31) - var2) * 3125) / var1;
    58e8:	9803      	ldr	r0, [sp, #12]
  int32_t adc_P = read24(BMP280_REGISTER_PRESSUREDATA);
  adc_P >>= 4;

  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
    58ea:	ea4f 79e8 	mov.w	r9, r8, asr #31
    58ee:	fb08 f107 	mul.w	r1, r8, r7
    58f2:	fb06 1109 	mla	r1, r6, r9, r1
    58f6:	fba8 6706 	umull	r6, r7, r8, r6
    58fa:	440f      	add	r7, r1

  if (var1 == 0) {
    return 0; // avoid exception caused by division by zero
  }
  p = 1048576 - adc_P;
  p = (((p << 31) - var2) * 3125) / var1;
    58fc:	1105      	asrs	r5, r0, #4

  int32_t adc_P = read24(BMP280_REGISTER_PRESSUREDATA);
  adc_P >>= 4;

  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
    58fe:	f9b4 0030 	ldrsh.w	r0, [r4, #48]	; 0x30
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
    5902:	ea4f 4947 	mov.w	r9, r7, lsl #17

  int32_t adc_P = read24(BMP280_REGISTER_PRESSUREDATA);
  adc_P >>= 4;

  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
    5906:	17c1      	asrs	r1, r0, #31
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
    5908:	ea49 39d6 	orr.w	r9, r9, r6, lsr #15
    590c:	ea4f 4846 	mov.w	r8, r6, lsl #17

  int32_t adc_P = read24(BMP280_REGISTER_PRESSUREDATA);
  adc_P >>= 4;

  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
    5910:	fb00 f60b 	mul.w	r6, r0, fp
    5914:	fb0a 6601 	mla	r6, sl, r1, r6
    5918:	fba0 ab0a 	umull	sl, fp, r0, sl

  if (var1 == 0) {
    return 0; // avoid exception caused by division by zero
  }
  p = 1048576 - adc_P;
  p = (((p << 31) - var2) * 3125) / var1;
    591c:	f9b4 002c 	ldrsh.w	r0, [r4, #44]	; 0x2c

  int32_t adc_P = read24(BMP280_REGISTER_PRESSUREDATA);
  adc_P >>= 4;

  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
    5920:	44b3      	add	fp, r6

  if (var1 == 0) {
    return 0; // avoid exception caused by division by zero
  }
  p = 1048576 - adc_P;
  p = (((p << 31) - var2) * 3125) / var1;
    5922:	00c1      	lsls	r1, r0, #3
    5924:	2600      	movs	r6, #0
    5926:	9101      	str	r1, [sp, #4]
    5928:	9600      	str	r6, [sp, #0]
    592a:	e9dd 6700 	ldrd	r6, r7, [sp]
    592e:	f5c5 1580 	rsb	r5, r5, #1048576	; 0x100000
  int32_t adc_P = read24(BMP280_REGISTER_PRESSUREDATA);
  adc_P >>= 4;

  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
    5932:	eb1a 0a08 	adds.w	sl, sl, r8

  if (var1 == 0) {
    return 0; // avoid exception caused by division by zero
  }
  p = 1048576 - adc_P;
  p = (((p << 31) - var2) * 3125) / var1;
    5936:	ea4f 71e5 	mov.w	r1, r5, asr #31
  int32_t adc_P = read24(BMP280_REGISTER_PRESSUREDATA);
  adc_P >>= 4;

  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
    593a:	eb4b 0b09 	adc.w	fp, fp, r9

  if (var1 == 0) {
    return 0; // avoid exception caused by division by zero
  }
  p = 1048576 - adc_P;
  p = (((p << 31) - var2) * 3125) / var1;
    593e:	07e8      	lsls	r0, r5, #31
    5940:	eb16 060a 	adds.w	r6, r6, sl
    5944:	ea4f 71c1 	mov.w	r1, r1, lsl #31
    5948:	eb47 070b 	adc.w	r7, r7, fp
    594c:	ea41 0155 	orr.w	r1, r1, r5, lsr #1
    5950:	1b80      	subs	r0, r0, r6
    5952:	eb61 0107 	sbc.w	r1, r1, r7
    5956:	eb10 0800 	adds.w	r8, r0, r0
    595a:	eb41 0901 	adc.w	r9, r1, r1
    595e:	eb18 0600 	adds.w	r6, r8, r0
    5962:	eb49 0701 	adc.w	r7, r9, r1
    5966:	ea4f 1987 	mov.w	r9, r7, lsl #6
    596a:	ea4f 1886 	mov.w	r8, r6, lsl #6
    596e:	eb18 0806 	adds.w	r8, r8, r6
    5972:	ea49 6996 	orr.w	r9, r9, r6, lsr #26
    5976:	eb49 0907 	adc.w	r9, r9, r7
    597a:	ea4f 0589 	mov.w	r5, r9, lsl #2
    597e:	ea4f 0688 	mov.w	r6, r8, lsl #2
    5982:	ea45 7598 	orr.w	r5, r5, r8, lsr #30
    5986:	eb16 0800 	adds.w	r8, r6, r0
    598a:	eb45 0901 	adc.w	r9, r5, r1
    598e:	ea4f 0688 	mov.w	r6, r8, lsl #2
    5992:	ea4f 0589 	mov.w	r5, r9, lsl #2
    5996:	1980      	adds	r0, r0, r6
    5998:	ea45 7598 	orr.w	r5, r5, r8, lsr #30
    599c:	4169      	adcs	r1, r5
    599e:	f004 fd87 	bl	a4b0 <__aeabi_ldivmod>
  var1 = (((int64_t)_bmp280_calib.dig_P9) * (p >> 13) * (p >> 13)) >> 25;
  var2 = (((int64_t)_bmp280_calib.dig_P8) * p) >> 19;

  p = ((p + var1 + var2) >> 8) + (((int64_t)_bmp280_calib.dig_P7) << 4);
    59a2:	f9b4 2036 	ldrsh.w	r2, [r4, #54]	; 0x36
  if (var1 == 0) {
    return 0; // avoid exception caused by division by zero
  }
  p = 1048576 - adc_P;
  p = (((p << 31) - var2) * 3125) / var1;
  var1 = (((int64_t)_bmp280_calib.dig_P9) * (p >> 13) * (p >> 13)) >> 25;
    59a6:	134d      	asrs	r5, r1, #13
    59a8:	ea4f 3e50 	mov.w	lr, r0, lsr #13
    59ac:	ea4e 4ec1 	orr.w	lr, lr, r1, lsl #19
  var2 = (((int64_t)_bmp280_calib.dig_P8) * p) >> 19;

  p = ((p + var1 + var2) >> 8) + (((int64_t)_bmp280_calib.dig_P7) << 4);
    59b0:	fb02 f605 	mul.w	r6, r2, r5
    59b4:	17d3      	asrs	r3, r2, #31
    59b6:	fb0e 6603 	mla	r6, lr, r3, r6
    59ba:	fba2 230e 	umull	r2, r3, r2, lr
    59be:	4433      	add	r3, r6
    59c0:	f9b4 6034 	ldrsh.w	r6, [r4, #52]	; 0x34
  return (float)p / 256;
    59c4:	f9b4 4032 	ldrsh.w	r4, [r4, #50]	; 0x32
  p = 1048576 - adc_P;
  p = (((p << 31) - var2) * 3125) / var1;
  var1 = (((int64_t)_bmp280_calib.dig_P9) * (p >> 13) * (p >> 13)) >> 25;
  var2 = (((int64_t)_bmp280_calib.dig_P8) * p) >> 19;

  p = ((p + var1 + var2) >> 8) + (((int64_t)_bmp280_calib.dig_P7) << 4);
    59c8:	fb02 f505 	mul.w	r5, r2, r5
    59cc:	fb0e 5503 	mla	r5, lr, r3, r5
    59d0:	17f7      	asrs	r7, r6, #31
    59d2:	fba2 230e 	umull	r2, r3, r2, lr
    59d6:	fb06 fe01 	mul.w	lr, r6, r1
    59da:	442b      	add	r3, r5
    59dc:	ea4f 6852 	mov.w	r8, r2, lsr #25
    59e0:	fb00 e507 	mla	r5, r0, r7, lr
    59e4:	fba6 6700 	umull	r6, r7, r6, r0
    59e8:	442f      	add	r7, r5
    59ea:	ea48 18c3 	orr.w	r8, r8, r3, lsl #7
    59ee:	ea4f 4ad6 	mov.w	sl, r6, lsr #19
    59f2:	eb10 0008 	adds.w	r0, r0, r8
    59f6:	ea4f 6963 	mov.w	r9, r3, asr #25
    59fa:	ea4a 3a47 	orr.w	sl, sl, r7, lsl #13
    59fe:	eb41 0109 	adc.w	r1, r1, r9
    5a02:	ea4f 4be7 	mov.w	fp, r7, asr #19
    5a06:	eb1a 0a00 	adds.w	sl, sl, r0
    5a0a:	eb4b 0b01 	adc.w	fp, fp, r1
  return (float)p / 256;
    5a0e:	17e5      	asrs	r5, r4, #31
  p = 1048576 - adc_P;
  p = (((p << 31) - var2) * 3125) / var1;
  var1 = (((int64_t)_bmp280_calib.dig_P9) * (p >> 13) * (p >> 13)) >> 25;
  var2 = (((int64_t)_bmp280_calib.dig_P8) * p) >> 19;

  p = ((p + var1 + var2) >> 8) + (((int64_t)_bmp280_calib.dig_P7) << 4);
    5a10:	ea4f 221a 	mov.w	r2, sl, lsr #8
    5a14:	ea42 620b 	orr.w	r2, r2, fp, lsl #24
  return (float)p / 256;
    5a18:	0129      	lsls	r1, r5, #4
    5a1a:	0120      	lsls	r0, r4, #4
  p = 1048576 - adc_P;
  p = (((p << 31) - var2) * 3125) / var1;
  var1 = (((int64_t)_bmp280_calib.dig_P9) * (p >> 13) * (p >> 13)) >> 25;
  var2 = (((int64_t)_bmp280_calib.dig_P8) * p) >> 19;

  p = ((p + var1 + var2) >> 8) + (((int64_t)_bmp280_calib.dig_P7) << 4);
    5a1c:	ea4f 232b 	mov.w	r3, fp, asr #8
  return (float)p / 256;
    5a20:	1880      	adds	r0, r0, r2
    5a22:	ea41 7114 	orr.w	r1, r1, r4, lsr #28
    5a26:	4159      	adcs	r1, r3
    5a28:	f004 fd04 	bl	a434 <__aeabi_l2f>
    5a2c:	ed9f 0a08 	vldr	s0, [pc, #32]	; 5a50 <Adafruit_BMP280::readPressure()+0x210>
    5a30:	ee07 0a90 	vmov	s15, r0
    5a34:	ee27 0a80 	vmul.f32	s0, s15, s0
}
    5a38:	b005      	add	sp, #20
    5a3a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
         ((var1 * (int64_t)_bmp280_calib.dig_P2) << 12);
  var1 =
      (((((int64_t)1) << 47) + var1)) * ((int64_t)_bmp280_calib.dig_P1) >> 33;

  if (var1 == 0) {
    return 0; // avoid exception caused by division by zero
    5a3e:	ed9f 0a05 	vldr	s0, [pc, #20]	; 5a54 <Adafruit_BMP280::readPressure()+0x214>
  var1 = (((int64_t)_bmp280_calib.dig_P9) * (p >> 13) * (p >> 13)) >> 25;
  var2 = (((int64_t)_bmp280_calib.dig_P8) * p) >> 19;

  p = ((p + var1 + var2) >> 8) + (((int64_t)_bmp280_calib.dig_P7) << 4);
  return (float)p / 256;
}
    5a42:	b005      	add	sp, #20
    5a44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 * @return Barometric pressure in Pa.
 */
float Adafruit_BMP280::readPressure() {
  int64_t var1, var2, p;
  if (!_sensorID)
    return NAN; // begin() not called yet
    5a48:	ed9f 0a03 	vldr	s0, [pc, #12]	; 5a58 <Adafruit_BMP280::readPressure()+0x218>
  var1 = (((int64_t)_bmp280_calib.dig_P9) * (p >> 13) * (p >> 13)) >> 25;
  var2 = (((int64_t)_bmp280_calib.dig_P8) * p) >> 19;

  p = ((p + var1 + var2) >> 8) + (((int64_t)_bmp280_calib.dig_P7) << 4);
  return (float)p / 256;
}
    5a4c:	4770      	bx	lr
    5a4e:	bf00      	nop
    5a50:	3b800000 	.word	0x3b800000
    5a54:	00000000 	.word	0x00000000
    5a58:	7fc00000 	.word	0x7fc00000

00005a5c <Adafruit_BMP280_Pressure::getEvent(sensors_event_t*)>:
    @brief  Gets the pressure as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_BMP280_Pressure::getEvent(sensors_event_t *event) {
    5a5c:	b570      	push	{r4, r5, r6, lr}
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));
    5a5e:	2624      	movs	r6, #36	; 0x24
    @brief  Gets the pressure as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_BMP280_Pressure::getEvent(sensors_event_t *event) {
    5a60:	460c      	mov	r4, r1
    5a62:	b082      	sub	sp, #8
    5a64:	4605      	mov	r5, r0
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));
    5a66:	4632      	mov	r2, r6
    5a68:	4608      	mov	r0, r1
    5a6a:	2100      	movs	r1, #0
    5a6c:	f005 fa44 	bl	aef8 <memset>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5a70:	4b0a      	ldr	r3, [pc, #40]	; (5a9c <Adafruit_BMP280_Pressure::getEvent(sensors_event_t*)+0x40>)

  event->version = sizeof(sensors_event_t);
  event->sensor_id = _sensorID;
    5a72:	68a9      	ldr	r1, [r5, #8]
    5a74:	681b      	ldr	r3, [r3, #0]
    5a76:	9301      	str	r3, [sp, #4]
  event->type = SENSOR_TYPE_PRESSURE;
    5a78:	2206      	movs	r2, #6
	return ret;
    5a7a:	9b01      	ldr	r3, [sp, #4]
  event->timestamp = millis();
  event->pressure = _theBMP280->readPressure() / 100; // convert Pa to hPa
    5a7c:	68e8      	ldr	r0, [r5, #12]
/**************************************************************************/
bool Adafruit_BMP280_Pressure::getEvent(sensors_event_t *event) {
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));

  event->version = sizeof(sensors_event_t);
    5a7e:	6026      	str	r6, [r4, #0]
  event->sensor_id = _sensorID;
    5a80:	6061      	str	r1, [r4, #4]
  event->type = SENSOR_TYPE_PRESSURE;
    5a82:	60a2      	str	r2, [r4, #8]
  event->timestamp = millis();
    5a84:	6123      	str	r3, [r4, #16]
  event->pressure = _theBMP280->readPressure() / 100; // convert Pa to hPa
    5a86:	f7ff fedb 	bl	5840 <Adafruit_BMP280::readPressure()>
    5a8a:	eddf 7a05 	vldr	s15, [pc, #20]	; 5aa0 <Adafruit_BMP280_Pressure::getEvent(sensors_event_t*)+0x44>
    5a8e:	ee80 0a27 	vdiv.f32	s0, s0, s15
  return true;
}
    5a92:	2001      	movs	r0, #1

  event->version = sizeof(sensors_event_t);
  event->sensor_id = _sensorID;
  event->type = SENSOR_TYPE_PRESSURE;
  event->timestamp = millis();
  event->pressure = _theBMP280->readPressure() / 100; // convert Pa to hPa
    5a94:	ed84 0a05 	vstr	s0, [r4, #20]
  return true;
}
    5a98:	b002      	add	sp, #8
    5a9a:	bd70      	pop	{r4, r5, r6, pc}
    5a9c:	1fff2c04 	.word	0x1fff2c04
    5aa0:	42c80000 	.word	0x42c80000

00005aa4 <Adafruit_BMP280::getTemperatureSensor()>:
    @brief  Gets an Adafruit Unified Sensor object for the temp sensor component
    @return Adafruit_Sensor pointer to temperature sensor
 */
Adafruit_Sensor *Adafruit_BMP280::getTemperatureSensor(void) {
  return temp_sensor;
}
    5aa4:	68c0      	ldr	r0, [r0, #12]
    5aa6:	4770      	bx	lr

00005aa8 <Adafruit_BMP280::getPressureSensor()>:
   component
    @return Adafruit_Sensor pointer to pressure sensor
 */
Adafruit_Sensor *Adafruit_BMP280::getPressureSensor(void) {
  return pressure_sensor;
}
    5aa8:	6900      	ldr	r0, [r0, #16]
    5aaa:	4770      	bx	lr

00005aac <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .part.2]>:
 *            ensure the content of this buffer doesn't change.
 *    @param  prefix_len Number of bytes from prefix buffer to write
 *    @param  stop Whether to send an I2C STOP signal on write
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,
    5aac:	b570      	push	{r4, r5, r6, lr}
    5aae:	4604      	mov	r4, r0
      return false;
    }
  }

  // Write the data itself
  if (_wire->write(buffer, len) != len) {
    5ab0:	6840      	ldr	r0, [r0, #4]
 *            ensure the content of this buffer doesn't change.
 *    @param  prefix_len Number of bytes from prefix buffer to write
 *    @param  stop Whether to send an I2C STOP signal on write
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,
    5ab2:	461e      	mov	r6, r3
      return false;
    }
  }

  // Write the data itself
  if (_wire->write(buffer, len) != len) {
    5ab4:	6803      	ldr	r3, [r0, #0]
    5ab6:	685b      	ldr	r3, [r3, #4]
 *            ensure the content of this buffer doesn't change.
 *    @param  prefix_len Number of bytes from prefix buffer to write
 *    @param  stop Whether to send an I2C STOP signal on write
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,
    5ab8:	4615      	mov	r5, r2
      return false;
    }
  }

  // Write the data itself
  if (_wire->write(buffer, len) != len) {
    5aba:	4798      	blx	r3
    5abc:	4285      	cmp	r5, r0
    5abe:	d001      	beq.n	5ac4 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .part.2]+0x18>
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println(F("\tI2CDevice failed to write"));
#endif
    return false;
    5ac0:	2000      	movs	r0, #0
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println("Failed to send!");
#endif
    return false;
  }
}
    5ac2:	bd70      	pop	{r4, r5, r6, pc}
#ifdef DEBUG_SERIAL
  DEBUG_SERIAL.print("Stop: ");
  DEBUG_SERIAL.println(stop);
#endif

  if (_wire->endTransmission(stop) == 0) {
    5ac4:	4631      	mov	r1, r6
    5ac6:	6860      	ldr	r0, [r4, #4]
    5ac8:	f7ff fa20 	bl	4f0c <TwoWire::endTransmission(unsigned char)>
    5acc:	fab0 f080 	clz	r0, r0
    5ad0:	0940      	lsrs	r0, r0, #5
    5ad2:	bd70      	pop	{r4, r5, r6, pc}

00005ad4 <Adafruit_I2CDevice::Adafruit_I2CDevice(unsigned char, TwoWire*)>:
/*!
 *    @brief  Create an I2C device at a given address
 *    @param  addr The 7-bit I2C address for the device
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
    5ad4:	b430      	push	{r4, r5}
  _addr = addr;
  _wire = theWire;
  _begun = false;
    5ad6:	2500      	movs	r5, #0
#ifdef ARDUINO_ARCH_SAMD
  _maxBufferSize = 250; // as defined in Wire.h's RingBuffer
#else
  _maxBufferSize = 32;
    5ad8:	2420      	movs	r4, #32
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
  _addr = addr;
  _wire = theWire;
  _begun = false;
    5ada:	7205      	strb	r5, [r0, #8]
#ifdef ARDUINO_ARCH_SAMD
  _maxBufferSize = 250; // as defined in Wire.h's RingBuffer
#else
  _maxBufferSize = 32;
    5adc:	60c4      	str	r4, [r0, #12]
 *    @brief  Create an I2C device at a given address
 *    @param  addr The 7-bit I2C address for the device
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
  _addr = addr;
    5ade:	7001      	strb	r1, [r0, #0]
  _wire = theWire;
    5ae0:	6042      	str	r2, [r0, #4]
#ifdef ARDUINO_ARCH_SAMD
  _maxBufferSize = 250; // as defined in Wire.h's RingBuffer
#else
  _maxBufferSize = 32;
#endif
}
    5ae2:	bc30      	pop	{r4, r5}
    5ae4:	4770      	bx	lr
    5ae6:	bf00      	nop

00005ae8 <Adafruit_I2CDevice::detected()>:
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
  // Init I2C if not done yet
  if (!_begun && !begin()) {
    5ae8:	7a03      	ldrb	r3, [r0, #8]
/*!
 *    @brief  Scans I2C for the address - note will give a false-positive
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
    5aea:	b510      	push	{r4, lr}
    5aec:	4604      	mov	r4, r0
  // Init I2C if not done yet
  if (!_begun && !begin()) {
    5aee:	b183      	cbz	r3, 5b12 <Adafruit_I2CDevice::detected()+0x2a>
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    5af0:	7822      	ldrb	r2, [r4, #0]
    return false;
  }

  // A basic scanner, see if it ACK's
  _wire->beginTransmission(_addr);
    5af2:	6863      	ldr	r3, [r4, #4]
		transmitting = 1;
    5af4:	2101      	movs	r1, #1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    5af6:	0052      	lsls	r2, r2, #1
    5af8:	f883 203b 	strb.w	r2, [r3, #59]	; 0x3b
		transmitting = 1;
    5afc:	f883 105e 	strb.w	r1, [r3, #94]	; 0x5e
		txBufferLength = 1;
    5b00:	f883 105d 	strb.w	r1, [r3, #93]	; 0x5d
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    5b04:	6860      	ldr	r0, [r4, #4]
    5b06:	f7ff fa01 	bl	4f0c <TwoWire::endTransmission(unsigned char)>
  if (_wire->endTransmission() == 0) {
    5b0a:	fab0 f080 	clz	r0, r0
    5b0e:	0940      	lsrs	r0, r0, #5
  }
#ifdef DEBUG_SERIAL
  DEBUG_SERIAL.println(F("Not detected"));
#endif
  return false;
}
    5b10:	bd10      	pop	{r4, pc}
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
  // Init I2C if not done yet
  if (!_begun && !begin()) {
    5b12:	2101      	movs	r1, #1
    5b14:	f000 f804 	bl	5b20 <Adafruit_I2CDevice::begin(bool)>
    5b18:	2800      	cmp	r0, #0
    5b1a:	d1e9      	bne.n	5af0 <Adafruit_I2CDevice::detected()+0x8>
  }
#ifdef DEBUG_SERIAL
  DEBUG_SERIAL.println(F("Not detected"));
#endif
  return false;
}
    5b1c:	bd10      	pop	{r4, pc}
    5b1e:	bf00      	nop

00005b20 <Adafruit_I2CDevice::begin(bool)>:
 *    @param  addr_detect Whether we should attempt to detect the I2C address
 * with a scan. 99% of sensors/devices don't mind but once in a while, they spaz
 * on a scan!
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::begin(bool addr_detect) {
    5b20:	b538      	push	{r3, r4, r5, lr}
    5b22:	4604      	mov	r4, r0
  _wire->begin();
    5b24:	6840      	ldr	r0, [r0, #4]
 *    @param  addr_detect Whether we should attempt to detect the I2C address
 * with a scan. 99% of sensors/devices don't mind but once in a while, they spaz
 * on a scan!
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::begin(bool addr_detect) {
    5b26:	460d      	mov	r5, r1
  _wire->begin();
    5b28:	f7ff f898 	bl	4c5c <TwoWire::begin()>
  _begun = true;
    5b2c:	2001      	movs	r0, #1
    5b2e:	7220      	strb	r0, [r4, #8]

  if (addr_detect) {
    5b30:	b905      	cbnz	r5, 5b34 <Adafruit_I2CDevice::begin(bool)+0x14>
    return detected();
  }
  return true;
}
    5b32:	bd38      	pop	{r3, r4, r5, pc}
bool Adafruit_I2CDevice::begin(bool addr_detect) {
  _wire->begin();
  _begun = true;

  if (addr_detect) {
    return detected();
    5b34:	4620      	mov	r0, r4
  }
  return true;
}
    5b36:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
bool Adafruit_I2CDevice::begin(bool addr_detect) {
  _wire->begin();
  _begun = true;

  if (addr_detect) {
    return detected();
    5b3a:	f7ff bfd5 	b.w	5ae8 <Adafruit_I2CDevice::detected()>
    5b3e:	bf00      	nop

00005b40 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)>:
 *    @param  stop Whether to send an I2C STOP signal on write
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,
                               const uint8_t *prefix_buffer,
                               size_t prefix_len) {
    5b40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5b44:	9e07      	ldr	r6, [sp, #28]
  if ((len + prefix_len) > maxBufferSize()) {
    5b46:	68c4      	ldr	r4, [r0, #12]
 *    @param  stop Whether to send an I2C STOP signal on write
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,
                               const uint8_t *prefix_buffer,
                               size_t prefix_len) {
    5b48:	f8dd e018 	ldr.w	lr, [sp, #24]
  if ((len + prefix_len) > maxBufferSize()) {
    5b4c:	1995      	adds	r5, r2, r6
    5b4e:	42a5      	cmp	r5, r4
    5b50:	d819      	bhi.n	5b86 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x46>
    5b52:	4615      	mov	r5, r2
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    5b54:	7802      	ldrb	r2, [r0, #0]
    5b56:	4698      	mov	r8, r3
    DEBUG_SERIAL.println(F("\tI2CDevice could not write such a large buffer"));
#endif
    return false;
  }

  _wire->beginTransmission(_addr);
    5b58:	6843      	ldr	r3, [r0, #4]
    5b5a:	460f      	mov	r7, r1
    5b5c:	0052      	lsls	r2, r2, #1
		transmitting = 1;
    5b5e:	2101      	movs	r1, #1
    5b60:	4604      	mov	r4, r0
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    5b62:	f883 203b 	strb.w	r2, [r3, #59]	; 0x3b
		transmitting = 1;
    5b66:	f883 105e 	strb.w	r1, [r3, #94]	; 0x5e
		txBufferLength = 1;
    5b6a:	f883 105d 	strb.w	r1, [r3, #93]	; 0x5d

  // Write the prefix data (usually an address)
  if ((prefix_len != 0) && (prefix_buffer != NULL)) {
    5b6e:	b16e      	cbz	r6, 5b8c <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x4c>
    5b70:	f1be 0f00 	cmp.w	lr, #0
    5b74:	d00a      	beq.n	5b8c <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x4c>
    if (_wire->write(prefix_buffer, prefix_len) != prefix_len) {
    5b76:	6840      	ldr	r0, [r0, #4]
    5b78:	6803      	ldr	r3, [r0, #0]
    5b7a:	4671      	mov	r1, lr
    5b7c:	685b      	ldr	r3, [r3, #4]
    5b7e:	4632      	mov	r2, r6
    5b80:	4798      	blx	r3
    5b82:	4286      	cmp	r6, r0
    5b84:	d002      	beq.n	5b8c <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x4c>
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println("Failed to send!");
#endif
    return false;
  }
}
    5b86:	2000      	movs	r0, #0
    5b88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5b8c:	4643      	mov	r3, r8
    5b8e:	462a      	mov	r2, r5
    5b90:	4639      	mov	r1, r7
    5b92:	4620      	mov	r0, r4
    5b94:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    5b98:	f7ff bf88 	b.w	5aac <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .part.2]>

00005b9c <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)>:
    pos += read_len;
  }
  return true;
}

bool Adafruit_I2CDevice::_read(uint8_t *buffer, size_t len, bool stop) {
    5b9c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    5ba0:	4616      	mov	r6, r2
    5ba2:	4607      	mov	r7, r0
    5ba4:	4688      	mov	r8, r1
#if defined(TinyWireM_h)
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len);
#else
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len, (uint8_t)stop);
    5ba6:	b2d2      	uxtb	r2, r2
    5ba8:	7801      	ldrb	r1, [r0, #0]
    5baa:	6840      	ldr	r0, [r0, #4]
    5bac:	f7ff fa38 	bl	5020 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>
#endif

  if (recv != len) {
    5bb0:	4286      	cmp	r6, r0
    5bb2:	d002      	beq.n	5bba <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x1e>
    // Not enough data available to fulfill our obligation!
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.print(F("\tI2CDevice did not receive enough data: "));
    DEBUG_SERIAL.println(recv);
#endif
    return false;
    5bb4:	2000      	movs	r0, #0
  }
  DEBUG_SERIAL.println();
#endif

  return true;
}
    5bb6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    DEBUG_SERIAL.println(recv);
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    5bba:	b336      	cbz	r6, 5c0a <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x6e>
    5bbc:	2300      	movs	r3, #0
    5bbe:	f8df 9054 	ldr.w	r9, [pc, #84]	; 5c14 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x78>
    5bc2:	461c      	mov	r4, r3
    5bc4:	e012      	b.n	5bec <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x50>
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    5bc6:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
    5bca:	f890 2039 	ldrb.w	r2, [r0, #57]	; 0x39
    5bce:	429a      	cmp	r2, r3
		return rxBuffer[rxBufferIndex++];
    5bd0:	f103 0e01 	add.w	lr, r3, #1
    5bd4:	eb00 0103 	add.w	r1, r0, r3
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    5bd8:	d91a      	bls.n	5c10 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x74>
		return rxBuffer[rxBufferIndex++];
    5bda:	f880 e038 	strb.w	lr, [r0, #56]	; 0x38
    5bde:	7e08      	ldrb	r0, [r1, #24]
    buffer[i] = _wire->read();
    5be0:	7028      	strb	r0, [r5, #0]
    DEBUG_SERIAL.println(recv);
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    5be2:	3401      	adds	r4, #1
    5be4:	b2a4      	uxth	r4, r4
    5be6:	42a6      	cmp	r6, r4
    5be8:	4623      	mov	r3, r4
    5bea:	d90e      	bls.n	5c0a <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x6e>
    buffer[i] = _wire->read();
    5bec:	6878      	ldr	r0, [r7, #4]
    5bee:	6802      	ldr	r2, [r0, #0]
    5bf0:	6952      	ldr	r2, [r2, #20]
    5bf2:	454a      	cmp	r2, r9
    5bf4:	eb08 0503 	add.w	r5, r8, r3
    5bf8:	d0e5      	beq.n	5bc6 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x2a>
    5bfa:	4790      	blx	r2
    DEBUG_SERIAL.println(recv);
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    5bfc:	3401      	adds	r4, #1
    5bfe:	b2a4      	uxth	r4, r4
    5c00:	b2c0      	uxtb	r0, r0
    5c02:	42a6      	cmp	r6, r4
    buffer[i] = _wire->read();
    5c04:	7028      	strb	r0, [r5, #0]
    DEBUG_SERIAL.println(recv);
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    5c06:	4623      	mov	r3, r4
    5c08:	d8f0      	bhi.n	5bec <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x50>
    // Not enough data available to fulfill our obligation!
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.print(F("\tI2CDevice did not receive enough data: "));
    DEBUG_SERIAL.println(recv);
#endif
    return false;
    5c0a:	2001      	movs	r0, #1
    5c0c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    5c10:	20ff      	movs	r0, #255	; 0xff
    5c12:	e7e5      	b.n	5be0 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x44>
    5c14:	00004929 	.word	0x00004929

00005c18 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)>:
 *    @param  stop Whether to send an I2C STOP signal on read
 *    @return True if read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
  size_t pos = 0;
  while (pos < len) {
    5c18:	b30a      	cbz	r2, 5c5e <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x46>
 *    @param  buffer Pointer to buffer of data to read into
 *    @param  len Number of bytes from buffer to read.
 *    @param  stop Whether to send an I2C STOP signal on read
 *    @return True if read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
    5c1a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    5c1e:	4616      	mov	r6, r2
    5c20:	4699      	mov	r9, r3
    5c22:	4688      	mov	r8, r1
    5c24:	4607      	mov	r7, r0
  size_t pos = 0;
  while (pos < len) {
    5c26:	2400      	movs	r4, #0
    5c28:	e001      	b.n	5c2e <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x16>
    5c2a:	42a6      	cmp	r6, r4
    5c2c:	d914      	bls.n	5c58 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x40>
    5c2e:	68fd      	ldr	r5, [r7, #12]
    size_t read_len =
        ((len - pos) > maxBufferSize()) ? maxBufferSize() : (len - pos);
    5c30:	1b33      	subs	r3, r6, r4
    5c32:	429d      	cmp	r5, r3
    5c34:	bf28      	it	cs
    5c36:	461d      	movcs	r5, r3
    bool read_stop = (pos < (len - read_len)) ? false : stop;
    5c38:	1b73      	subs	r3, r6, r5
    if (!_read(buffer + pos, read_len, read_stop))
    5c3a:	42a3      	cmp	r3, r4
    5c3c:	bf94      	ite	ls
    5c3e:	464b      	movls	r3, r9
    5c40:	2300      	movhi	r3, #0
    5c42:	eb08 0104 	add.w	r1, r8, r4
    5c46:	462a      	mov	r2, r5
    5c48:	4638      	mov	r0, r7
    5c4a:	f7ff ffa7 	bl	5b9c <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)>
      return false;
    pos += read_len;
    5c4e:	442c      	add	r4, r5
  size_t pos = 0;
  while (pos < len) {
    size_t read_len =
        ((len - pos) > maxBufferSize()) ? maxBufferSize() : (len - pos);
    bool read_stop = (pos < (len - read_len)) ? false : stop;
    if (!_read(buffer + pos, read_len, read_stop))
    5c50:	2800      	cmp	r0, #0
    5c52:	d1ea      	bne.n	5c2a <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x12>
      return false;
    pos += read_len;
  }
  return true;
}
    5c54:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    bool read_stop = (pos < (len - read_len)) ? false : stop;
    if (!_read(buffer + pos, read_len, read_stop))
      return false;
    pos += read_len;
  }
  return true;
    5c58:	2001      	movs	r0, #1
    5c5a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    5c5e:	2001      	movs	r0, #1
}
    5c60:	4770      	bx	lr
    5c62:	bf00      	nop

00005c64 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool)>:
 *    @param  stop Whether to send an I2C STOP signal between the write and read
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, bool stop) {
    5c64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,
                               const uint8_t *prefix_buffer,
                               size_t prefix_len) {
  if ((len + prefix_len) > maxBufferSize()) {
    5c68:	68c5      	ldr	r5, [r0, #12]
 *    @param  stop Whether to send an I2C STOP signal between the write and read
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, bool stop) {
    5c6a:	9f06      	ldr	r7, [sp, #24]
    5c6c:	f89d 601c 	ldrb.w	r6, [sp, #28]
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,
                               const uint8_t *prefix_buffer,
                               size_t prefix_len) {
  if ((len + prefix_len) > maxBufferSize()) {
    5c70:	42aa      	cmp	r2, r5
    5c72:	d902      	bls.n	5c7a <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool)+0x16>
  if (!write(write_buffer, write_len, stop)) {
    return false;
  }

  return read(read_buffer, read_len);
}
    5c74:	2000      	movs	r0, #0
    5c76:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    5c7a:	f890 c000 	ldrb.w	ip, [r0]
    DEBUG_SERIAL.println(F("\tI2CDevice could not write such a large buffer"));
#endif
    return false;
  }

  _wire->beginTransmission(_addr);
    5c7e:	f8d0 e004 	ldr.w	lr, [r0, #4]
		transmitting = 1;
    5c82:	f04f 0801 	mov.w	r8, #1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    5c86:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
    5c8a:	461d      	mov	r5, r3
    5c8c:	f88e c03b 	strb.w	ip, [lr, #59]	; 0x3b
    5c90:	4633      	mov	r3, r6
		transmitting = 1;
    5c92:	f88e 805e 	strb.w	r8, [lr, #94]	; 0x5e
		txBufferLength = 1;
    5c96:	f88e 805d 	strb.w	r8, [lr, #93]	; 0x5d
    5c9a:	4604      	mov	r4, r0
    5c9c:	f7ff ff06 	bl	5aac <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .part.2]>
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, bool stop) {
  if (!write(write_buffer, write_len, stop)) {
    5ca0:	2800      	cmp	r0, #0
    5ca2:	d0e7      	beq.n	5c74 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool)+0x10>
    return false;
  }

  return read(read_buffer, read_len);
    5ca4:	4643      	mov	r3, r8
    5ca6:	463a      	mov	r2, r7
    5ca8:	4629      	mov	r1, r5
    5caa:	4620      	mov	r0, r4
}
    5cac:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
                                         size_t read_len, bool stop) {
  if (!write(write_buffer, write_len, stop)) {
    return false;
  }

  return read(read_buffer, read_len);
    5cb0:	f7ff bfb2 	b.w	5c18 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)>

00005cb4 <Adafruit_SPIDevice::~Adafruit_SPIDevice()>:
}

/*!
 *    @brief  Release memory allocated in constructors
 */
Adafruit_SPIDevice::~Adafruit_SPIDevice() {
    5cb4:	b510      	push	{r4, lr}
    5cb6:	4604      	mov	r4, r0
  if (_spiSetting) {
    5cb8:	6840      	ldr	r0, [r0, #4]
    5cba:	b110      	cbz	r0, 5cc2 <Adafruit_SPIDevice::~Adafruit_SPIDevice()+0xe>
    delete _spiSetting;
    5cbc:	2104      	movs	r1, #4
    5cbe:	f002 f879 	bl	7db4 <operator delete(void*, unsigned int)>
    _spiSetting = nullptr;
  }
}
    5cc2:	4620      	mov	r0, r4
    5cc4:	bd10      	pop	{r4, pc}
    5cc6:	bf00      	nop

00005cc8 <Adafruit_SPIDevice::begin()>:
/*!
 *    @brief  Initializes SPI bus and sets CS pin high
 *    @return Always returns true because there's no way to test success of SPI
 * init
 */
bool Adafruit_SPIDevice::begin(void) {
    5cc8:	b510      	push	{r4, lr}
    5cca:	4604      	mov	r4, r0
  pinMode(_cs, OUTPUT);
    5ccc:	2101      	movs	r1, #1
    5cce:	7b80      	ldrb	r0, [r0, #14]
    5cd0:	f000 ff9a 	bl	6c08 <pinMode>
  digitalWrite(_cs, HIGH);
    5cd4:	7ba0      	ldrb	r0, [r4, #14]
    5cd6:	2101      	movs	r1, #1
    5cd8:	f000 ff90 	bl	6bfc <digitalWrite>

  if (_spi) { // hardware SPI
    5cdc:	6820      	ldr	r0, [r4, #0]
    5cde:	b128      	cbz	r0, 5cec <Adafruit_SPIDevice::begin()+0x24>
    _spi->begin();
    5ce0:	f000 fb56 	bl	6390 <SPIClass::begin()>
    if (_miso != -1) {
      pinMode(_miso, INPUT);
    }
  }

  _begun = true;
    5ce4:	2001      	movs	r0, #1
    5ce6:	f884 0028 	strb.w	r0, [r4, #40]	; 0x28
  return true;
}
    5cea:	bd10      	pop	{r4, pc}
  digitalWrite(_cs, HIGH);

  if (_spi) { // hardware SPI
    _spi->begin();
  } else {
    pinMode(_sck, OUTPUT);
    5cec:	2101      	movs	r1, #1
    5cee:	7be0      	ldrb	r0, [r4, #15]
    5cf0:	f000 ff8a 	bl	6c08 <pinMode>

    if ((_dataMode == SPI_MODE0) || (_dataMode == SPI_MODE1)) {
    5cf4:	7b61      	ldrb	r1, [r4, #13]
      // idle low on mode 0 and 1
      digitalWrite(_sck, LOW);
    } else {
      // idle high on mode 2 or 3
      digitalWrite(_sck, HIGH);
    5cf6:	7be0      	ldrb	r0, [r4, #15]
  if (_spi) { // hardware SPI
    _spi->begin();
  } else {
    pinMode(_sck, OUTPUT);

    if ((_dataMode == SPI_MODE0) || (_dataMode == SPI_MODE1)) {
    5cf8:	f011 01fb 	ands.w	r1, r1, #251	; 0xfb
      // idle low on mode 0 and 1
      digitalWrite(_sck, LOW);
    } else {
      // idle high on mode 2 or 3
      digitalWrite(_sck, HIGH);
    5cfc:	bf18      	it	ne
    5cfe:	2101      	movne	r1, #1
    5d00:	f000 ff7c 	bl	6bfc <digitalWrite>
    }
    if (_mosi != -1) {
    5d04:	f994 0010 	ldrsb.w	r0, [r4, #16]
    5d08:	1c42      	adds	r2, r0, #1
    5d0a:	d007      	beq.n	5d1c <Adafruit_SPIDevice::begin()+0x54>
      pinMode(_mosi, OUTPUT);
    5d0c:	b2c0      	uxtb	r0, r0
    5d0e:	2101      	movs	r1, #1
    5d10:	f000 ff7a 	bl	6c08 <pinMode>
      digitalWrite(_mosi, HIGH);
    5d14:	2101      	movs	r1, #1
    5d16:	7c20      	ldrb	r0, [r4, #16]
    5d18:	f000 ff70 	bl	6bfc <digitalWrite>
    }
    if (_miso != -1) {
    5d1c:	f994 0011 	ldrsb.w	r0, [r4, #17]
    5d20:	1c43      	adds	r3, r0, #1
    5d22:	d0df      	beq.n	5ce4 <Adafruit_SPIDevice::begin()+0x1c>
      pinMode(_miso, INPUT);
    5d24:	b2c0      	uxtb	r0, r0
    5d26:	2100      	movs	r1, #0
    5d28:	f000 ff6e 	bl	6c08 <pinMode>
    }
  }

  _begun = true;
    5d2c:	2001      	movs	r0, #1
    5d2e:	f884 0028 	strb.w	r0, [r4, #40]	; 0x28
  return true;
}
    5d32:	bd10      	pop	{r4, pc}

00005d34 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>:
/*!
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  buffer The buffer to send and receive at the same time
 *    @param  len    The number of bytes to transfer
 */
void Adafruit_SPIDevice::transfer(uint8_t *buffer, size_t len) {
    5d34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if (_spi) {
    5d38:	6804      	ldr	r4, [r0, #0]
/*!
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  buffer The buffer to send and receive at the same time
 *    @param  len    The number of bytes to transfer
 */
void Adafruit_SPIDevice::transfer(uint8_t *buffer, size_t len) {
    5d3a:	4613      	mov	r3, r2
    5d3c:	460a      	mov	r2, r1
  if (_spi) {
    5d3e:	b124      	cbz	r4, 5d4a <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x16>
		port().PUSHR = data | SPI_PUSHR_CTAS(1);
		while (!(port().SR & SPI_SR_TCF)) ; // wait
		return port().POPR;
	}

	void inline transfer(void *buf, size_t count) {transfer(buf, buf, count);}
    5d40:	4620      	mov	r0, r4
        buffer[i] = reply;
      }
    }
  }
  return;
}
    5d42:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    5d46:	f000 bb61 	b.w	640c <SPIClass::transfer(void const*, void*, unsigned int)>
#endif
    return;
  }

  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    5d4a:	7b06      	ldrb	r6, [r0, #12]
    startbit = 0x1;
  } else {
    startbit = 0x80;
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
    5d4c:	780c      	ldrb	r4, [r1, #0]
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
    5d4e:	6885      	ldr	r5, [r0, #8]
    5d50:	4962      	ldr	r1, [pc, #392]	; (5edc <L_999_delayMicroseconds+0xc>)
    5d52:	fbb1 f5f5 	udiv	r5, r1, r5

  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    startbit = 0x1;
  } else {
    startbit = 0x80;
    5d56:	2e00      	cmp	r6, #0
    5d58:	bf0c      	ite	eq
    5d5a:	f04f 0901 	moveq.w	r9, #1
    5d5e:	f04f 0980 	movne.w	r9, #128	; 0x80
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
    5d62:	ea19 0f04 	tst.w	r9, r4
    5d66:	bf0c      	ite	eq
    5d68:	f04f 0c01 	moveq.w	ip, #1
    5d6c:	f04f 0c00 	movne.w	ip, #0
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
    5d70:	b2ed      	uxtb	r5, r5

  // for softSPI we'll do it by hand
  for (size_t i = 0; i < len; i++) {
    5d72:	2b00      	cmp	r3, #0
    5d74:	f000 80af 	beq.w	5ed6 <L_999_delayMicroseconds+0x6>
#elif F_CPU == 216000000
	uint32_t n = usec * 72;
#elif F_CPU == 192000000
	uint32_t n = usec * 64;
#elif F_CPU == 180000000
	uint32_t n = usec * 60;
    5d78:	ebc5 1705 	rsb	r7, r5, r5, lsl #4
    5d7c:	4611      	mov	r1, r2
    5d7e:	eb02 0803 	add.w	r8, r2, r3
    5d82:	00bf      	lsls	r7, r7, #2
    // software SPI
    uint8_t reply = 0;
    uint8_t send = buffer[i];
    5d84:	f811 eb01 	ldrb.w	lr, [r1], #1
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
    5d88:	464b      	mov	r3, r9
  uint8_t bitdelay_us = (1000000 / _freq) / 2;

  // for softSPI we'll do it by hand
  for (size_t i = 0; i < len; i++) {
    // software SPI
    uint8_t reply = 0;
    5d8a:	2600      	movs	r6, #0

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
         b = (_dataOrder == SPI_BITORDER_LSBFIRST) ? b << 1 : b >> 1) {

      if (bitdelay_us) {
    5d8c:	2d00      	cmp	r5, #0
    5d8e:	d050      	beq.n	5e32 <L_770_delayMicroseconds+0x4a>
	uint32_t n = usec;
#elif F_CPU == 2000000
	uint32_t n = usec >> 1;
#endif
    // changed because a delay of 1 micro Sec @ 2MHz will be 0
	if (n == 0) return;
    5d90:	2f00      	cmp	r7, #0
    5d92:	d04e      	beq.n	5e32 <L_770_delayMicroseconds+0x4a>
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    5d94:	463a      	mov	r2, r7

00005d96 <L_709_delayMicroseconds>:
    5d96:	3a01      	subs	r2, #1
    5d98:	d1fd      	bne.n	5d96 <L_709_delayMicroseconds>
        delayMicroseconds(bitdelay_us);
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
    5d9a:	7b42      	ldrb	r2, [r0, #13]
    5d9c:	f012 0ff7 	tst.w	r2, #247	; 0xf7
    5da0:	f040 808d 	bne.w	5ebe <L_770_delayMicroseconds+0xd6>
        towrite = send & b;
        if ((_mosi != -1) && (lastmosi != towrite)) {
    5da4:	f990 2010 	ldrsb.w	r2, [r0, #16]
    5da8:	3201      	adds	r2, #1
    5daa:	d012      	beq.n	5dd2 <L_709_delayMicroseconds+0x3c>
    5dac:	ea1e 0203 	ands.w	r2, lr, r3
    5db0:	bf14      	ite	ne
    5db2:	2401      	movne	r4, #1
    5db4:	2400      	moveq	r4, #0
    5db6:	4564      	cmp	r4, ip
    5db8:	d00b      	beq.n	5dd2 <L_709_delayMicroseconds+0x3c>
#ifdef BUSIO_USE_FAST_PINIO
          if (towrite)
    5dba:	2a00      	cmp	r2, #0
    5dbc:	d06c      	beq.n	5e98 <L_770_delayMicroseconds+0xb0>
            *mosiPort |= mosiPinMask;
    5dbe:	6944      	ldr	r4, [r0, #20]
    5dc0:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
    5dc4:	f894 c000 	ldrb.w	ip, [r4]
    5dc8:	ea4c 0202 	orr.w	r2, ip, r2
    5dcc:	7022      	strb	r2, [r4, #0]
    5dce:	f04f 0c01 	mov.w	ip, #1
#endif
          lastmosi = towrite;
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort |= clkPinMask; // Clock high
    5dd2:	6984      	ldr	r4, [r0, #24]
    5dd4:	f890 2026 	ldrb.w	r2, [r0, #38]	; 0x26
    5dd8:	f894 a000 	ldrb.w	sl, [r4]
    5ddc:	ea4a 0202 	orr.w	r2, sl, r2
    5de0:	7022      	strb	r2, [r4, #0]
#else
        digitalWrite(_sck, HIGH);
#endif

        if (bitdelay_us) {
    5de2:	b11d      	cbz	r5, 5dec <L_770_delayMicroseconds+0x4>
	uint32_t n = usec;
#elif F_CPU == 2000000
	uint32_t n = usec >> 1;
#endif
    // changed because a delay of 1 micro Sec @ 2MHz will be 0
	if (n == 0) return;
    5de4:	b117      	cbz	r7, 5dec <L_770_delayMicroseconds+0x4>
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    5de6:	463a      	mov	r2, r7

00005de8 <L_770_delayMicroseconds>:
    5de8:	3a01      	subs	r2, #1
    5dea:	d1fd      	bne.n	5de8 <L_770_delayMicroseconds>
          delayMicroseconds(bitdelay_us);
        }

        if (_miso != -1) {
    5dec:	f990 2011 	ldrsb.w	r2, [r0, #17]
    5df0:	3201      	adds	r2, #1
    5df2:	d006      	beq.n	5e02 <L_770_delayMicroseconds+0x1a>
#ifdef BUSIO_USE_FAST_PINIO
          if (*misoPort & misoPinMask) {
    5df4:	69c2      	ldr	r2, [r0, #28]
    5df6:	f890 4025 	ldrb.w	r4, [r0, #37]	; 0x25
    5dfa:	7812      	ldrb	r2, [r2, #0]
    5dfc:	4222      	tst	r2, r4
#else
          if (digitalRead(_miso)) {
#endif
            reply |= b;
    5dfe:	bf18      	it	ne
    5e00:	431e      	orrne	r6, r3
          }
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort &= ~clkPinMask; // Clock low
    5e02:	6982      	ldr	r2, [r0, #24]
    5e04:	f890 a026 	ldrb.w	sl, [r0, #38]	; 0x26
    5e08:	7814      	ldrb	r4, [r2, #0]
    5e0a:	ea24 040a 	bic.w	r4, r4, sl
    5e0e:	7014      	strb	r4, [r2, #0]
#endif
            reply |= b;
          }
        }
      }
      if (_miso != -1) {
    5e10:	f990 2011 	ldrsb.w	r2, [r0, #17]
    5e14:	3201      	adds	r2, #1
    5e16:	d001      	beq.n	5e1c <L_770_delayMicroseconds+0x34>
        buffer[i] = reply;
    5e18:	f801 6c01 	strb.w	r6, [r1, #-1]
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
    5e1c:	7b02      	ldrb	r2, [r0, #12]
    5e1e:	2a00      	cmp	r2, #0
    5e20:	d135      	bne.n	5e8e <L_770_delayMicroseconds+0xa6>
    5e22:	005b      	lsls	r3, r3, #1
    5e24:	b2db      	uxtb	r3, r3
    5e26:	2b00      	cmp	r3, #0
    5e28:	d1b0      	bne.n	5d8c <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x58>

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;

  // for softSPI we'll do it by hand
  for (size_t i = 0; i < len; i++) {
    5e2a:	4588      	cmp	r8, r1
    5e2c:	d1aa      	bne.n	5d84 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x50>
    5e2e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

      if (bitdelay_us) {
        delayMicroseconds(bitdelay_us);
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
    5e32:	7b42      	ldrb	r2, [r0, #13]
    5e34:	f012 0ff7 	tst.w	r2, #247	; 0xf7
    5e38:	d0b4      	beq.n	5da4 <L_709_delayMicroseconds+0xe>
        digitalWrite(_sck, LOW);
#endif
      } else { // if (_dataMode == SPI_MODE1 || _dataMode == SPI_MODE3)

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort |= clkPinMask; // Clock high
    5e3a:	6984      	ldr	r4, [r0, #24]
    5e3c:	f890 2026 	ldrb.w	r2, [r0, #38]	; 0x26
    5e40:	f894 a000 	ldrb.w	sl, [r4]
    5e44:	ea4a 0202 	orr.w	r2, sl, r2
    5e48:	7022      	strb	r2, [r4, #0]

        if (bitdelay_us) {
          delayMicroseconds(bitdelay_us);
        }

        if (_mosi != -1) {
    5e4a:	f990 2010 	ldrsb.w	r2, [r0, #16]
    5e4e:	3201      	adds	r2, #1
    5e50:	d00a      	beq.n	5e68 <L_770_delayMicroseconds+0x80>
#ifdef BUSIO_USE_FAST_PINIO
          if (send & b)
    5e52:	ea1e 0f03 	tst.w	lr, r3
            *mosiPort |= mosiPinMask;
    5e56:	6944      	ldr	r4, [r0, #20]
          delayMicroseconds(bitdelay_us);
        }

        if (_mosi != -1) {
#ifdef BUSIO_USE_FAST_PINIO
          if (send & b)
    5e58:	d02a      	beq.n	5eb0 <L_770_delayMicroseconds+0xc8>
            *mosiPort |= mosiPinMask;
    5e5a:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
    5e5e:	f894 a000 	ldrb.w	sl, [r4]
    5e62:	ea4a 0202 	orr.w	r2, sl, r2
    5e66:	7022      	strb	r2, [r4, #0]
          digitalWrite(_mosi, send & b);
#endif
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort &= ~clkPinMask; // Clock low
    5e68:	6984      	ldr	r4, [r0, #24]
    5e6a:	f890 a026 	ldrb.w	sl, [r0, #38]	; 0x26
    5e6e:	7822      	ldrb	r2, [r4, #0]
    5e70:	ea22 020a 	bic.w	r2, r2, sl
    5e74:	7022      	strb	r2, [r4, #0]
#else
        digitalWrite(_sck, LOW);
#endif

        if (_miso != -1) {
    5e76:	f990 2011 	ldrsb.w	r2, [r0, #17]
    5e7a:	3201      	adds	r2, #1
    5e7c:	d0ce      	beq.n	5e1c <L_770_delayMicroseconds+0x34>
#ifdef BUSIO_USE_FAST_PINIO
          if (*misoPort & misoPinMask) {
    5e7e:	69c2      	ldr	r2, [r0, #28]
    5e80:	f890 4025 	ldrb.w	r4, [r0, #37]	; 0x25
    5e84:	7812      	ldrb	r2, [r2, #0]
    5e86:	4222      	tst	r2, r4
#else
          if (digitalRead(_miso)) {
#endif
            reply |= b;
    5e88:	bf18      	it	ne
    5e8a:	431e      	orrne	r6, r3
    5e8c:	e7c4      	b.n	5e18 <L_770_delayMicroseconds+0x30>
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
    5e8e:	085b      	lsrs	r3, r3, #1
    5e90:	2b00      	cmp	r3, #0
    5e92:	f47f af7b 	bne.w	5d8c <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x58>
    5e96:	e7c8      	b.n	5e2a <L_770_delayMicroseconds+0x42>
        if ((_mosi != -1) && (lastmosi != towrite)) {
#ifdef BUSIO_USE_FAST_PINIO
          if (towrite)
            *mosiPort |= mosiPinMask;
          else
            *mosiPort &= ~mosiPinMask;
    5e98:	f8d0 a014 	ldr.w	sl, [r0, #20]
    5e9c:	f890 c024 	ldrb.w	ip, [r0, #36]	; 0x24
    5ea0:	f89a 4000 	ldrb.w	r4, [sl]
    5ea4:	ea24 040c 	bic.w	r4, r4, ip
    5ea8:	f88a 4000 	strb.w	r4, [sl]
    5eac:	4694      	mov	ip, r2
    5eae:	e790      	b.n	5dd2 <L_709_delayMicroseconds+0x3c>
        if (_mosi != -1) {
#ifdef BUSIO_USE_FAST_PINIO
          if (send & b)
            *mosiPort |= mosiPinMask;
          else
            *mosiPort &= ~mosiPinMask;
    5eb0:	f890 a024 	ldrb.w	sl, [r0, #36]	; 0x24
    5eb4:	7822      	ldrb	r2, [r4, #0]
    5eb6:	ea22 020a 	bic.w	r2, r2, sl
    5eba:	7022      	strb	r2, [r4, #0]
    5ebc:	e7d4      	b.n	5e68 <L_770_delayMicroseconds+0x80>
        digitalWrite(_sck, LOW);
#endif
      } else { // if (_dataMode == SPI_MODE1 || _dataMode == SPI_MODE3)

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort |= clkPinMask; // Clock high
    5ebe:	6984      	ldr	r4, [r0, #24]
    5ec0:	f890 2026 	ldrb.w	r2, [r0, #38]	; 0x26
    5ec4:	f894 a000 	ldrb.w	sl, [r4]
    5ec8:	ea4a 0202 	orr.w	r2, sl, r2
    5ecc:	7022      	strb	r2, [r4, #0]
    5ece:	463a      	mov	r2, r7

00005ed0 <L_999_delayMicroseconds>:
    5ed0:	3a01      	subs	r2, #1
    5ed2:	d1fd      	bne.n	5ed0 <L_999_delayMicroseconds>
    5ed4:	e7b9      	b.n	5e4a <L_770_delayMicroseconds+0x62>
    5ed6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5eda:	bf00      	nop
    5edc:	0007a120 	.word	0x0007a120

00005ee0 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)>:
 *    @param  prefix_len Number of bytes from prefix buffer to write
 *    @return Always returns true because there's no way to test success of SPI
 * writes
 */
bool Adafruit_SPIDevice::write(uint8_t *buffer, size_t len,
                               uint8_t *prefix_buffer, size_t prefix_len) {
    5ee0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    5ee4:	460c      	mov	r4, r1
    5ee6:	b083      	sub	sp, #12
  if (_spi) {
    5ee8:	6801      	ldr	r1, [r0, #0]
 *    @param  prefix_len Number of bytes from prefix buffer to write
 *    @return Always returns true because there's no way to test success of SPI
 * writes
 */
bool Adafruit_SPIDevice::write(uint8_t *buffer, size_t len,
                               uint8_t *prefix_buffer, size_t prefix_len) {
    5eea:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    5eec:	4606      	mov	r6, r0
    5eee:	4690      	mov	r8, r2
    5ef0:	461d      	mov	r5, r3
  if (_spi) {
    5ef2:	b181      	cbz	r1, 5f16 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x36>
    5ef4:	6842      	ldr	r2, [r0, #4]

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
    5ef6:	7acb      	ldrb	r3, [r1, #11]
    5ef8:	6812      	ldr	r2, [r2, #0]
    5efa:	2b00      	cmp	r3, #0
    5efc:	d154      	bne.n	5fa8 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0xc8>
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    5efe:	680b      	ldr	r3, [r1, #0]
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
    5f00:	68d9      	ldr	r1, [r3, #12]
    5f02:	4291      	cmp	r1, r2
    5f04:	d007      	beq.n	5f16 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x36>
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
    5f06:	4842      	ldr	r0, [pc, #264]	; (6010 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x130>)
    5f08:	6018      	str	r0, [r3, #0]
			port().CTAR0 = settings.ctar;
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    5f0a:	4942      	ldr	r1, [pc, #264]	; (6014 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x134>)
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
			port().CTAR0 = settings.ctar;
    5f0c:	60da      	str	r2, [r3, #12]
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
    5f0e:	f042 4080 	orr.w	r0, r2, #1073741824	; 0x40000000
    5f12:	6118      	str	r0, [r3, #16]
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    5f14:	6019      	str	r1, [r3, #0]
    _spi->beginTransaction(*_spiSetting);
  }

  digitalWrite(_cs, LOW);
    5f16:	2100      	movs	r1, #0
    5f18:	7bb0      	ldrb	r0, [r6, #14]
    5f1a:	f000 fe6f 	bl	6bfc <digitalWrite>
  // do the writing
  for (size_t i = 0; i < prefix_len; i++) {
    5f1e:	b177      	cbz	r7, 5f3e <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x5e>
    5f20:	eb05 0907 	add.w	r9, r5, r7
    5f24:	f10d 0707 	add.w	r7, sp, #7
    transfer(prefix_buffer[i]);
    5f28:	f815 3b01 	ldrb.w	r3, [r5], #1
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    5f2c:	f88d 3007 	strb.w	r3, [sp, #7]
  transfer(&data, 1);
    5f30:	2201      	movs	r2, #1
    5f32:	4639      	mov	r1, r7
    5f34:	4630      	mov	r0, r6
    5f36:	f7ff fefd 	bl	5d34 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
    _spi->beginTransaction(*_spiSetting);
  }

  digitalWrite(_cs, LOW);
  // do the writing
  for (size_t i = 0; i < prefix_len; i++) {
    5f3a:	45a9      	cmp	r9, r5
    5f3c:	d1f4      	bne.n	5f28 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x48>
    transfer(prefix_buffer[i]);
  }
  for (size_t i = 0; i < len; i++) {
    5f3e:	f1b8 0f00 	cmp.w	r8, #0
    5f42:	d00e      	beq.n	5f62 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x82>
    5f44:	eb04 0508 	add.w	r5, r4, r8
    5f48:	f10d 0707 	add.w	r7, sp, #7
    transfer(buffer[i]);
    5f4c:	f814 3b01 	ldrb.w	r3, [r4], #1
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    5f50:	f88d 3007 	strb.w	r3, [sp, #7]
  transfer(&data, 1);
    5f54:	2201      	movs	r2, #1
    5f56:	4639      	mov	r1, r7
    5f58:	4630      	mov	r0, r6
    5f5a:	f7ff feeb 	bl	5d34 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
  digitalWrite(_cs, LOW);
  // do the writing
  for (size_t i = 0; i < prefix_len; i++) {
    transfer(prefix_buffer[i]);
  }
  for (size_t i = 0; i < len; i++) {
    5f5e:	42a5      	cmp	r5, r4
    5f60:	d1f4      	bne.n	5f4c <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x6c>
    transfer(buffer[i]);
  }
  digitalWrite(_cs, HIGH);
    5f62:	2101      	movs	r1, #1
    5f64:	7bb0      	ldrb	r0, [r6, #14]
    5f66:	f000 fe49 	bl	6bfc <digitalWrite>

  if (_spi) {
    5f6a:	6833      	ldr	r3, [r6, #0]
    5f6c:	b1c3      	cbz	r3, 5fa0 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0xc0>
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
    5f6e:	7ada      	ldrb	r2, [r3, #11]
    5f70:	b1b2      	cbz	r2, 5fa0 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0xc0>
			if (interruptMasksUsed & 0x01) {
    5f72:	07d4      	lsls	r4, r2, #31
    5f74:	d503      	bpl.n	5f7e <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x9e>
				NVIC_ISER0 = interruptSave[0];
    5f76:	4a28      	ldr	r2, [pc, #160]	; (6018 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x138>)
    5f78:	69d9      	ldr	r1, [r3, #28]
    5f7a:	6011      	str	r1, [r2, #0]
    5f7c:	7ada      	ldrb	r2, [r3, #11]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    5f7e:	0790      	lsls	r0, r2, #30
    5f80:	d503      	bpl.n	5f8a <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0xaa>
				NVIC_ISER1 = interruptSave[1];
    5f82:	4a26      	ldr	r2, [pc, #152]	; (601c <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x13c>)
    5f84:	6a19      	ldr	r1, [r3, #32]
    5f86:	6011      	str	r1, [r2, #0]
    5f88:	7ada      	ldrb	r2, [r3, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    5f8a:	0751      	lsls	r1, r2, #29
    5f8c:	d503      	bpl.n	5f96 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0xb6>
				NVIC_ISER2 = interruptSave[2];
    5f8e:	4a24      	ldr	r2, [pc, #144]	; (6020 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x140>)
    5f90:	6a59      	ldr	r1, [r3, #36]	; 0x24
    5f92:	6011      	str	r1, [r2, #0]
    5f94:	7ada      	ldrb	r2, [r3, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
    5f96:	0712      	lsls	r2, r2, #28
    5f98:	d502      	bpl.n	5fa0 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0xc0>
				NVIC_ISER3 = interruptSave[3];
    5f9a:	4a22      	ldr	r2, [pc, #136]	; (6024 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x144>)
    5f9c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    5f9e:	6013      	str	r3, [r2, #0]
  }
  DEBUG_SERIAL.println();
#endif

  return true;
}
    5fa0:	2001      	movs	r0, #1
    5fa2:	b003      	add	sp, #12
    5fa4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
			__disable_irq();
    5fa8:	b672      	cpsid	i
			if (interruptMasksUsed & 0x01) {
    5faa:	7acb      	ldrb	r3, [r1, #11]
    5fac:	07d8      	lsls	r0, r3, #31
    5fae:	d509      	bpl.n	5fc4 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0xe4>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
    5fb0:	f8df e074 	ldr.w	lr, [pc, #116]	; 6028 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x148>
    5fb4:	68c8      	ldr	r0, [r1, #12]
    5fb6:	f8de 3000 	ldr.w	r3, [lr]
    5fba:	4003      	ands	r3, r0
    5fbc:	61cb      	str	r3, [r1, #28]
				NVIC_ICER0 = interruptSave[0];
    5fbe:	f8ce 3000 	str.w	r3, [lr]
    5fc2:	7acb      	ldrb	r3, [r1, #11]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    5fc4:	0798      	lsls	r0, r3, #30
    5fc6:	d509      	bpl.n	5fdc <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0xfc>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
    5fc8:	f8df e060 	ldr.w	lr, [pc, #96]	; 602c <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x14c>
    5fcc:	6908      	ldr	r0, [r1, #16]
    5fce:	f8de 3000 	ldr.w	r3, [lr]
    5fd2:	4003      	ands	r3, r0
    5fd4:	620b      	str	r3, [r1, #32]
				NVIC_ICER1 = interruptSave[1];
    5fd6:	f8ce 3000 	str.w	r3, [lr]
    5fda:	7acb      	ldrb	r3, [r1, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    5fdc:	0758      	lsls	r0, r3, #29
    5fde:	d509      	bpl.n	5ff4 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x114>
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
    5fe0:	f8df e04c 	ldr.w	lr, [pc, #76]	; 6030 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x150>
    5fe4:	6948      	ldr	r0, [r1, #20]
    5fe6:	f8de 3000 	ldr.w	r3, [lr]
    5fea:	4003      	ands	r3, r0
    5fec:	624b      	str	r3, [r1, #36]	; 0x24
				NVIC_ICER2 = interruptSave[2];
    5fee:	f8ce 3000 	str.w	r3, [lr]
    5ff2:	7acb      	ldrb	r3, [r1, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
    5ff4:	071b      	lsls	r3, r3, #28
    5ff6:	d508      	bpl.n	600a <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x12a>
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
    5ff8:	f8df e038 	ldr.w	lr, [pc, #56]	; 6034 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x154>
    5ffc:	6988      	ldr	r0, [r1, #24]
    5ffe:	f8de 3000 	ldr.w	r3, [lr]
    6002:	4003      	ands	r3, r0
    6004:	628b      	str	r3, [r1, #40]	; 0x28
				NVIC_ICER3 = interruptSave[3];
    6006:	f8ce 3000 	str.w	r3, [lr]
			}
			#endif
			__enable_irq();
    600a:	b662      	cpsie	i
    600c:	e777      	b.n	5efe <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x1e>
    600e:	bf00      	nop
    6010:	003f4001 	.word	0x003f4001
    6014:	803f0000 	.word	0x803f0000
    6018:	e000e100 	.word	0xe000e100
    601c:	e000e104 	.word	0xe000e104
    6020:	e000e108 	.word	0xe000e108
    6024:	e000e10c 	.word	0xe000e10c
    6028:	e000e180 	.word	0xe000e180
    602c:	e000e184 	.word	0xe000e184
    6030:	e000e188 	.word	0xe000e188
    6034:	e000e18c 	.word	0xe000e18c

00006038 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)>:
 *    @return Always returns true because there's no way to test success of SPI
 * writes
 */
bool Adafruit_SPIDevice::write_then_read(uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, uint8_t sendvalue) {
    6038:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    603c:	460d      	mov	r5, r1
    603e:	b082      	sub	sp, #8
  if (_spi) {
    6040:	6801      	ldr	r1, [r0, #0]
 *    @return Always returns true because there's no way to test success of SPI
 * writes
 */
bool Adafruit_SPIDevice::write_then_read(uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, uint8_t sendvalue) {
    6042:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
    6046:	f89d 802c 	ldrb.w	r8, [sp, #44]	; 0x2c
    604a:	4606      	mov	r6, r0
    604c:	4617      	mov	r7, r2
    604e:	461c      	mov	r4, r3
  if (_spi) {
    6050:	b181      	cbz	r1, 6074 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x3c>
    6052:	6842      	ldr	r2, [r0, #4]

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
    6054:	7acb      	ldrb	r3, [r1, #11]
    6056:	6812      	ldr	r2, [r2, #0]
    6058:	2b00      	cmp	r3, #0
    605a:	d155      	bne.n	6108 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0xd0>
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    605c:	680b      	ldr	r3, [r1, #0]
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
    605e:	68d9      	ldr	r1, [r3, #12]
    6060:	4291      	cmp	r1, r2
    6062:	d007      	beq.n	6074 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x3c>
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
    6064:	4842      	ldr	r0, [pc, #264]	; (6170 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x138>)
    6066:	6018      	str	r0, [r3, #0]
			port().CTAR0 = settings.ctar;
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    6068:	4942      	ldr	r1, [pc, #264]	; (6174 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x13c>)
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
			port().CTAR0 = settings.ctar;
    606a:	60da      	str	r2, [r3, #12]
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
    606c:	f042 4080 	orr.w	r0, r2, #1073741824	; 0x40000000
    6070:	6118      	str	r0, [r3, #16]
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    6072:	6019      	str	r1, [r3, #0]
    _spi->beginTransaction(*_spiSetting);
  }

  digitalWrite(_cs, LOW);
    6074:	2100      	movs	r1, #0
    6076:	7bb0      	ldrb	r0, [r6, #14]
    6078:	f000 fdc0 	bl	6bfc <digitalWrite>
  // do the writing
  for (size_t i = 0; i < write_len; i++) {
    607c:	b177      	cbz	r7, 609c <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x64>
    607e:	eb05 0a07 	add.w	sl, r5, r7
    6082:	f10d 0707 	add.w	r7, sp, #7
    transfer(write_buffer[i]);
    6086:	f815 3b01 	ldrb.w	r3, [r5], #1
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    608a:	f88d 3007 	strb.w	r3, [sp, #7]
  transfer(&data, 1);
    608e:	2201      	movs	r2, #1
    6090:	4639      	mov	r1, r7
    6092:	4630      	mov	r0, r6
    6094:	f7ff fe4e 	bl	5d34 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
    _spi->beginTransaction(*_spiSetting);
  }

  digitalWrite(_cs, LOW);
  // do the writing
  for (size_t i = 0; i < write_len; i++) {
    6098:	45aa      	cmp	sl, r5
    609a:	d1f4      	bne.n	6086 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x4e>
  }
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i = 0; i < read_len; i++) {
    609c:	f1b9 0f00 	cmp.w	r9, #0
    60a0:	d00f      	beq.n	60c2 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x8a>
    60a2:	44a1      	add	r9, r4
    60a4:	f10d 0707 	add.w	r7, sp, #7
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
    60a8:	2201      	movs	r2, #1
    60aa:	4639      	mov	r1, r7
    60ac:	4630      	mov	r0, r6
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    60ae:	f88d 8007 	strb.w	r8, [sp, #7]
  transfer(&data, 1);
    60b2:	f7ff fe3f 	bl	5d34 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
  return data;
    60b6:	f89d 3007 	ldrb.w	r3, [sp, #7]
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i = 0; i < read_len; i++) {
    read_buffer[i] = transfer(sendvalue);
    60ba:	f804 3b01 	strb.w	r3, [r4], #1
  }
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i = 0; i < read_len; i++) {
    60be:	45a1      	cmp	r9, r4
    60c0:	d1f2      	bne.n	60a8 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x70>
    }
  }
  DEBUG_SERIAL.println();
#endif

  digitalWrite(_cs, HIGH);
    60c2:	2101      	movs	r1, #1
    60c4:	7bb0      	ldrb	r0, [r6, #14]
    60c6:	f000 fd99 	bl	6bfc <digitalWrite>

  if (_spi) {
    60ca:	6833      	ldr	r3, [r6, #0]
    60cc:	b1c3      	cbz	r3, 6100 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0xc8>
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
    60ce:	7ada      	ldrb	r2, [r3, #11]
    60d0:	b1b2      	cbz	r2, 6100 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0xc8>
			if (interruptMasksUsed & 0x01) {
    60d2:	07d4      	lsls	r4, r2, #31
    60d4:	d503      	bpl.n	60de <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0xa6>
				NVIC_ISER0 = interruptSave[0];
    60d6:	4a28      	ldr	r2, [pc, #160]	; (6178 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x140>)
    60d8:	69d9      	ldr	r1, [r3, #28]
    60da:	6011      	str	r1, [r2, #0]
    60dc:	7ada      	ldrb	r2, [r3, #11]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    60de:	0790      	lsls	r0, r2, #30
    60e0:	d503      	bpl.n	60ea <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0xb2>
				NVIC_ISER1 = interruptSave[1];
    60e2:	4a26      	ldr	r2, [pc, #152]	; (617c <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x144>)
    60e4:	6a19      	ldr	r1, [r3, #32]
    60e6:	6011      	str	r1, [r2, #0]
    60e8:	7ada      	ldrb	r2, [r3, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    60ea:	0751      	lsls	r1, r2, #29
    60ec:	d503      	bpl.n	60f6 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0xbe>
				NVIC_ISER2 = interruptSave[2];
    60ee:	4a24      	ldr	r2, [pc, #144]	; (6180 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x148>)
    60f0:	6a59      	ldr	r1, [r3, #36]	; 0x24
    60f2:	6011      	str	r1, [r2, #0]
    60f4:	7ada      	ldrb	r2, [r3, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
    60f6:	0712      	lsls	r2, r2, #28
    60f8:	d502      	bpl.n	6100 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0xc8>
				NVIC_ISER3 = interruptSave[3];
    60fa:	4a22      	ldr	r2, [pc, #136]	; (6184 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x14c>)
    60fc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    60fe:	6013      	str	r3, [r2, #0]
    _spi->endTransaction();
  }

  return true;
}
    6100:	2001      	movs	r0, #1
    6102:	b002      	add	sp, #8
    6104:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
			__disable_irq();
    6108:	b672      	cpsid	i
			if (interruptMasksUsed & 0x01) {
    610a:	7acb      	ldrb	r3, [r1, #11]
    610c:	07d8      	lsls	r0, r3, #31
    610e:	d509      	bpl.n	6124 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0xec>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
    6110:	f8df e074 	ldr.w	lr, [pc, #116]	; 6188 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x150>
    6114:	68c8      	ldr	r0, [r1, #12]
    6116:	f8de 3000 	ldr.w	r3, [lr]
    611a:	4003      	ands	r3, r0
    611c:	61cb      	str	r3, [r1, #28]
				NVIC_ICER0 = interruptSave[0];
    611e:	f8ce 3000 	str.w	r3, [lr]
    6122:	7acb      	ldrb	r3, [r1, #11]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    6124:	0798      	lsls	r0, r3, #30
    6126:	d509      	bpl.n	613c <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x104>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
    6128:	f8df e060 	ldr.w	lr, [pc, #96]	; 618c <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x154>
    612c:	6908      	ldr	r0, [r1, #16]
    612e:	f8de 3000 	ldr.w	r3, [lr]
    6132:	4003      	ands	r3, r0
    6134:	620b      	str	r3, [r1, #32]
				NVIC_ICER1 = interruptSave[1];
    6136:	f8ce 3000 	str.w	r3, [lr]
    613a:	7acb      	ldrb	r3, [r1, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    613c:	0758      	lsls	r0, r3, #29
    613e:	d509      	bpl.n	6154 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x11c>
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
    6140:	f8df e04c 	ldr.w	lr, [pc, #76]	; 6190 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x158>
    6144:	6948      	ldr	r0, [r1, #20]
    6146:	f8de 3000 	ldr.w	r3, [lr]
    614a:	4003      	ands	r3, r0
    614c:	624b      	str	r3, [r1, #36]	; 0x24
				NVIC_ICER2 = interruptSave[2];
    614e:	f8ce 3000 	str.w	r3, [lr]
    6152:	7acb      	ldrb	r3, [r1, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
    6154:	071b      	lsls	r3, r3, #28
    6156:	d508      	bpl.n	616a <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x132>
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
    6158:	f8df e038 	ldr.w	lr, [pc, #56]	; 6194 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x15c>
    615c:	6988      	ldr	r0, [r1, #24]
    615e:	f8de 3000 	ldr.w	r3, [lr]
    6162:	4003      	ands	r3, r0
    6164:	628b      	str	r3, [r1, #40]	; 0x28
				NVIC_ICER3 = interruptSave[3];
    6166:	f8ce 3000 	str.w	r3, [lr]
			}
			#endif
			__enable_irq();
    616a:	b662      	cpsie	i
    616c:	e776      	b.n	605c <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x24>
    616e:	bf00      	nop
    6170:	003f4001 	.word	0x003f4001
    6174:	803f0000 	.word	0x803f0000
    6178:	e000e100 	.word	0xe000e100
    617c:	e000e104 	.word	0xe000e104
    6180:	e000e108 	.word	0xe000e108
    6184:	e000e10c 	.word	0xe000e10c
    6188:	e000e180 	.word	0xe000e180
    618c:	e000e184 	.word	0xe000e184
    6190:	e000e188 	.word	0xe000e188
    6194:	e000e18c 	.word	0xe000e18c

00006198 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]>:
			}
		}
	}
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
    6198:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    619c:	6804      	ldr	r4, [r0, #0]
{

	if (count == 0) return;
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    619e:	68e5      	ldr	r5, [r4, #12]
    61a0:	f015 7f80 	tst.w	r5, #16777216	; 0x1000000
		const uint8_t *p_write = (const uint8_t *)buf;
		uint8_t *p_read = (uint8_t *)retbuf;
		size_t count_read = count;

		// Lets clear the reader queue
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);
    61a4:	4d79      	ldr	r5, [pc, #484]	; (638c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1f4>)
    61a6:	6025      	str	r5, [r4, #0]

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    61a8:	d152      	bne.n	6250 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xb8>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    61aa:	07df      	lsls	r7, r3, #31
    61ac:	f140 80b3 	bpl.w	6316 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x17e>
		    if (p_write) {
    61b0:	2900      	cmp	r1, #0
    61b2:	f000 80e3 	beq.w	637c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1e4>
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    61b6:	780d      	ldrb	r5, [r1, #0]
		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
		    if (p_write) {
				if (count > 1)
    61b8:	2b01      	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    61ba:	bf18      	it	ne
    61bc:	f045 4500 	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    61c0:	6365      	str	r5, [r4, #52]	; 0x34
    61c2:	3101      	adds	r1, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    61c4:	f890 802c 	ldrb.w	r8, [r0, #44]	; 0x2c
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
    61c8:	f103 3cff 	add.w	ip, r3, #4294967295	; 0xffffffff
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    61cc:	ea48 2808 	orr.w	r8, r8, r8, lsl #8

		while (count > 0) {
    61d0:	f1bc 0f00 	cmp.w	ip, #0
    61d4:	f000 80a8 	beq.w	6328 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
			// Push out the next byte; 
		    if (p_write) {
    61d8:	b121      	cbz	r1, 61e4 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x4c>
		    	w = (*p_write++) << 8;
				w |= *p_write++;
    61da:	784d      	ldrb	r5, [r1, #1]
	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;

		while (count > 0) {
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
    61dc:	f811 8b02 	ldrb.w	r8, [r1], #2
				w |= *p_write++;
    61e0:	ea45 2808 	orr.w	r8, r5, r8, lsl #8
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    61e4:	6845      	ldr	r5, [r0, #4]
    61e6:	7a2e      	ldrb	r6, [r5, #8]
			if (count == 2)
    61e8:	f1bc 0f02 	cmp.w	ip, #2
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    61ec:	f106 36ff 	add.w	r6, r6, #4294967295	; 0xffffffff
    61f0:	ea4f 3606 	mov.w	r6, r6, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    61f4:	bf0c      	ite	eq
    61f6:	f048 5580 	orreq.w	r5, r8, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    61fa:	f048 4510 	orrne.w	r5, r8, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    61fe:	b2b6      	uxth	r6, r6
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    6200:	6365      	str	r5, [r4, #52]	; 0x34
			count -= 2; // how many bytes to output.
    6202:	f1ac 0c02 	sub.w	ip, ip, #2
    6206:	e008      	b.n	621a <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x82>
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
						if (p_read) {
    6208:	b10a      	cbz	r2, 620e <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x76>
							*p_read++ = w;  // Read any pending RX bytes in
    620a:	7014      	strb	r4, [r2, #0]
    620c:	3201      	adds	r2, #1
						} 
						count_read--;
    620e:	3b01      	subs	r3, #1
							*p_read++ = (w & 0xff);
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    6210:	f405 4570 	and.w	r5, r5, #61440	; 0xf000
    6214:	42b5      	cmp	r5, r6
    6216:	d916      	bls.n	6246 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xae>
    6218:	6804      	ldr	r4, [r0, #0]
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    621a:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
				if (sr & 0xF0)  {
    621c:	f015 0ff0 	tst.w	r5, #240	; 0xf0
    6220:	d0f6      	beq.n	6210 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x78>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    6222:	6ba4      	ldr	r4, [r4, #56]	; 0x38
					if (count_read & 1) {
    6224:	f013 0f01 	tst.w	r3, #1
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
							*p_read++ = w >> 8;
    6228:	4617      	mov	r7, r2
    622a:	ea4f 2e24 	mov.w	lr, r4, asr #8
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    622e:	d1eb      	bne.n	6208 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x70>
						if (p_read) {
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
    6230:	b11a      	cbz	r2, 623a <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xa2>
							*p_read++ = w >> 8;
    6232:	f807 eb02 	strb.w	lr, [r7], #2
							*p_read++ = (w & 0xff);
    6236:	7054      	strb	r4, [r2, #1]
    6238:	463a      	mov	r2, r7
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    623a:	f405 4570 	and.w	r5, r5, #61440	; 0xf000
    623e:	42b5      	cmp	r5, r6
					} else {
						if (p_read) {
							*p_read++ = w >> 8;
							*p_read++ = (w & 0xff);
						}
						count_read -= 2;
    6240:	f1a3 0302 	sub.w	r3, r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    6244:	d8e8      	bhi.n	6218 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x80>
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;

		while (count > 0) {
    6246:	f1bc 0f00 	cmp.w	ip, #0
    624a:	d06d      	beq.n	6328 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
    624c:	6804      	ldr	r4, [r0, #0]
    624e:	e7c3      	b.n	61d8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x40>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    6250:	07dd      	lsls	r5, r3, #31
    6252:	d54c      	bpl.n	62ee <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x156>
		    if (p_write) {
    6254:	2900      	cmp	r1, #0
    6256:	f000 8089 	beq.w	636c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1d4>
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    625a:	780d      	ldrb	r5, [r1, #0]
		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
		    if (p_write) {
				if (count > 1)
    625c:	2b01      	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    625e:	bf18      	it	ne
    6260:	f045 4500 	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    6264:	6365      	str	r5, [r4, #52]	; 0x34
    6266:	3101      	adds	r1, #1
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
    6268:	f103 3eff 	add.w	lr, r3, #4294967295	; 0xffffffff
		}

	    uint16_t w = _transferWriteFill;
    626c:	f890 c02c 	ldrb.w	ip, [r0, #44]	; 0x2c

		while (count > 0) {
    6270:	f1be 0f00 	cmp.w	lr, #0
    6274:	d041      	beq.n	62fa <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
			// Push out the next byte; 
		    if (p_write) {
    6276:	b129      	cbz	r1, 6284 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xec>
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
    6278:	f891 c001 	ldrb.w	ip, [r1, #1]
    627c:	780d      	ldrb	r5, [r1, #0]
    627e:	3102      	adds	r1, #2
    6280:	ea45 2c0c 	orr.w	ip, r5, ip, lsl #8
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    6284:	6845      	ldr	r5, [r0, #4]
    6286:	7a2e      	ldrb	r6, [r5, #8]
			if (count == 2)
    6288:	f1be 0f02 	cmp.w	lr, #2
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    628c:	f106 36ff 	add.w	r6, r6, #4294967295	; 0xffffffff
    6290:	ea4f 3606 	mov.w	r6, r6, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    6294:	bf0c      	ite	eq
    6296:	f04c 5580 	orreq.w	r5, ip, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    629a:	f04c 4510 	orrne.w	r5, ip, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    629e:	b2b6      	uxth	r6, r6
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    62a0:	6365      	str	r5, [r4, #52]	; 0x34
			count -= 2; // how many bytes to output.
    62a2:	f1ae 0e02 	sub.w	lr, lr, #2
    62a6:	e008      	b.n	62ba <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x122>
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
						if (p_read) {
    62a8:	b10a      	cbz	r2, 62ae <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x116>
							*p_read++ = w;  // Read any pending RX bytes in
    62aa:	7014      	strb	r4, [r2, #0]
    62ac:	3201      	adds	r2, #1
						} 
						count_read--;
    62ae:	3b01      	subs	r3, #1
							*p_read++ = w >> 8;
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    62b0:	f405 4570 	and.w	r5, r5, #61440	; 0xf000
    62b4:	42b5      	cmp	r5, r6
    62b6:	d915      	bls.n	62e4 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x14c>
    62b8:	6804      	ldr	r4, [r0, #0]
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    62ba:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
				if (sr & 0xF0)  {
    62bc:	f015 0ff0 	tst.w	r5, #240	; 0xf0
    62c0:	d0f6      	beq.n	62b0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x118>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    62c2:	f013 0f01 	tst.w	r3, #1
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
							*p_read++ = (w & 0xff);
    62c6:	4617      	mov	r7, r2
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    62c8:	6ba4      	ldr	r4, [r4, #56]	; 0x38
					if (count_read & 1) {
    62ca:	d1ed      	bne.n	62a8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x110>
						if (p_read) {
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
    62cc:	b122      	cbz	r2, 62d8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x140>
							*p_read++ = (w & 0xff);
    62ce:	f807 4b02 	strb.w	r4, [r7], #2
							*p_read++ = w >> 8;
    62d2:	1224      	asrs	r4, r4, #8
    62d4:	7054      	strb	r4, [r2, #1]
    62d6:	463a      	mov	r2, r7
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    62d8:	f405 4570 	and.w	r5, r5, #61440	; 0xf000
    62dc:	42b5      	cmp	r5, r6
					} else {
						if (p_read) {
							*p_read++ = (w & 0xff);
							*p_read++ = w >> 8;
						}
						count_read -= 2;
    62de:	f1a3 0302 	sub.w	r3, r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    62e2:	d8e9      	bhi.n	62b8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x120>
			count--;
		}

	    uint16_t w = _transferWriteFill;

		while (count > 0) {
    62e4:	f1be 0f00 	cmp.w	lr, #0
    62e8:	d007      	beq.n	62fa <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
    62ea:	6804      	ldr	r4, [r0, #0]
    62ec:	e7c3      	b.n	6276 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xde>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    62ee:	469e      	mov	lr, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w = _transferWriteFill;
    62f0:	f890 c02c 	ldrb.w	ip, [r0, #44]	; 0x2c

		while (count > 0) {
    62f4:	f1be 0f00 	cmp.w	lr, #0
    62f8:	d1bd      	bne.n	6276 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xde>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    62fa:	b31b      	cbz	r3, 6344 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1ac>
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    62fc:	6804      	ldr	r4, [r0, #0]
			sr = port().SR;
    62fe:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
			if (sr & 0xF0)  {
    6300:	f011 0ff0 	tst.w	r1, #240	; 0xf0
    6304:	d0fb      	beq.n	62fe <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x166>
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    6306:	6ba1      	ldr	r1, [r4, #56]	; 0x38
				if (count_read & 1) {
    6308:	07dc      	lsls	r4, r3, #31
    630a:	d51d      	bpl.n	6348 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1b0>
					if (p_read)
    630c:	b10a      	cbz	r2, 6312 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x17a>
						*p_read++ = w;  // Read any pending RX bytes in
    630e:	7011      	strb	r1, [r2, #0]
    6310:	3201      	adds	r2, #1
					count_read--;
    6312:	3b01      	subs	r3, #1
    6314:	e7f1      	b.n	62fa <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    6316:	f890 802c 	ldrb.w	r8, [r0, #44]	; 0x2c
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    631a:	469c      	mov	ip, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    631c:	ea48 2808 	orr.w	r8, r8, r8, lsl #8

		while (count > 0) {
    6320:	f1bc 0f00 	cmp.w	ip, #0
    6324:	f47f af58 	bne.w	61d8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x40>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    6328:	b163      	cbz	r3, 6344 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1ac>
    632a:	6804      	ldr	r4, [r0, #0]
			sr = port().SR;
    632c:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
			if (sr & 0xF0)  {
    632e:	f011 0ff0 	tst.w	r1, #240	; 0xf0
    6332:	d0fb      	beq.n	632c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x194>
				uint16_t w = port().POPR;  // Read any pending RX bytes in
				if (count_read & 1) {
    6334:	07de      	lsls	r6, r3, #31

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    6336:	6ba1      	ldr	r1, [r4, #56]	; 0x38
				if (count_read & 1) {
    6338:	d50f      	bpl.n	635a <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1c2>
					if (p_read)
    633a:	b10a      	cbz	r2, 6340 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1a8>
						*p_read++ = w;  // Read any pending RX bytes in
    633c:	7011      	strb	r1, [r2, #0]
    633e:	3201      	adds	r2, #1
					count_read--;
    6340:	3b01      	subs	r3, #1
    6342:	e7f1      	b.n	6328 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
    6344:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if (count_read & 1) {
					if (p_read)
						*p_read++ = w;  // Read any pending RX bytes in
					count_read--;
				} else {
					if (p_read) {
    6348:	b12a      	cbz	r2, 6356 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1be>
						*p_read++ = (w & 0xff);
    634a:	4614      	mov	r4, r2
						*p_read++ = w >> 8;
    634c:	120d      	asrs	r5, r1, #8
					if (p_read)
						*p_read++ = w;  // Read any pending RX bytes in
					count_read--;
				} else {
					if (p_read) {
						*p_read++ = (w & 0xff);
    634e:	f804 1b02 	strb.w	r1, [r4], #2
						*p_read++ = w >> 8;
    6352:	7055      	strb	r5, [r2, #1]
    6354:	4622      	mov	r2, r4
					}
					count_read -= 2;
    6356:	3b02      	subs	r3, #2
    6358:	e7cf      	b.n	62fa <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
				if (count_read & 1) {
					if (p_read)
						*p_read++ = w;  // Read any pending RX bytes in
					count_read--;
				} else {
					if (p_read) {
    635a:	b12a      	cbz	r2, 6368 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1d0>
						*p_read++ = w >> 8;
    635c:	4614      	mov	r4, r2
    635e:	120d      	asrs	r5, r1, #8
    6360:	f804 5b02 	strb.w	r5, [r4], #2
						*p_read++ = (w & 0xff);
    6364:	7051      	strb	r1, [r2, #1]
    6366:	4622      	mov	r2, r4
					}
					count_read -= 2;
    6368:	3b02      	subs	r3, #2
    636a:	e7dd      	b.n	6328 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    636c:	f890 502c 	ldrb.w	r5, [r0, #44]	; 0x2c
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
    6370:	2b01      	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    6372:	bf18      	it	ne
    6374:	f045 4500 	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    6378:	6365      	str	r5, [r4, #52]	; 0x34
    637a:	e775      	b.n	6268 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xd0>
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    637c:	f890 502c 	ldrb.w	r5, [r0, #44]	; 0x2c
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
    6380:	2b01      	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    6382:	bf18      	it	ne
    6384:	f045 4500 	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    6388:	6365      	str	r5, [r4, #52]	; 0x34
    638a:	e71b      	b.n	61c4 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x2c>
    638c:	801f0400 	.word	0x801f0400

00006390 <SPIClass::begin()>:
    6390:	e890 000c 	ldmia.w	r0, {r2, r3}
SPIClass SPI2((uintptr_t)&KINETISK_SPI2, (uintptr_t)&SPIClass::spi2_hardware);
#endif


void SPIClass::begin()
{
    6394:	b4f0      	push	{r4, r5, r6, r7}
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
    6396:	681c      	ldr	r4, [r3, #0]
    6398:	6859      	ldr	r1, [r3, #4]
    639a:	6825      	ldr	r5, [r4, #0]
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
    639c:	4f16      	ldr	r7, [pc, #88]	; (63f8 <SPIClass::begin()+0x68>)
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    639e:	4e17      	ldr	r6, [pc, #92]	; (63fc <SPIClass::begin()+0x6c>)

void SPIClass::begin()
{
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
    63a0:	4329      	orrs	r1, r5
    63a2:	6021      	str	r1, [r4, #0]
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    63a4:	4d16      	ldr	r5, [pc, #88]	; (6400 <SPIClass::begin()+0x70>)
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
    63a6:	4917      	ldr	r1, [pc, #92]	; (6404 <SPIClass::begin()+0x74>)
void SPIClass::begin()
{
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
    63a8:	6017      	str	r7, [r2, #0]
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    63aa:	60d6      	str	r6, [r2, #12]
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    63ac:	6115      	str	r5, [r2, #16]
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
    63ae:	6011      	str	r1, [r2, #0]
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    63b0:	7a41      	ldrb	r1, [r0, #9]
    63b2:	4a15      	ldr	r2, [pc, #84]	; (6408 <SPIClass::begin()+0x78>)
    63b4:	185c      	adds	r4, r3, r1
	*reg = hardware().mosi_mux[mosi_pin_index];
    63b6:	310c      	adds	r1, #12
	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    63b8:	f894 402c 	ldrb.w	r4, [r4, #44]	; 0x2c
	*reg = hardware().mosi_mux[mosi_pin_index];
    63bc:	f853 5021 	ldr.w	r5, [r3, r1, lsl #2]
	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    63c0:	eb02 01c4 	add.w	r1, r2, r4, lsl #3
    63c4:	6849      	ldr	r1, [r1, #4]
	*reg = hardware().mosi_mux[mosi_pin_index];
    63c6:	600d      	str	r5, [r1, #0]
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    63c8:	7a01      	ldrb	r1, [r0, #8]
    63ca:	185c      	adds	r4, r3, r1
	*reg= hardware().miso_mux[miso_pin_index];
    63cc:	eb03 0181 	add.w	r1, r3, r1, lsl #2
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    63d0:	7e24      	ldrb	r4, [r4, #24]
	*reg= hardware().miso_mux[miso_pin_index];
    63d2:	69cd      	ldr	r5, [r1, #28]
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    63d4:	eb02 01c4 	add.w	r1, r2, r4, lsl #3
    63d8:	6849      	ldr	r1, [r1, #4]
	*reg= hardware().miso_mux[miso_pin_index];
    63da:	600d      	str	r5, [r1, #0]
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    63dc:	7a81      	ldrb	r1, [r0, #10]
    63de:	1858      	adds	r0, r3, r1
	*reg = hardware().sck_mux[sck_pin_index];
    63e0:	eb03 0381 	add.w	r3, r3, r1, lsl #2
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    63e4:	f890 0040 	ldrb.w	r0, [r0, #64]	; 0x40
	*reg = hardware().sck_mux[sck_pin_index];
    63e8:	6c59      	ldr	r1, [r3, #68]	; 0x44
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    63ea:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
	*reg = hardware().sck_mux[sck_pin_index];
}
    63ee:	bcf0      	pop	{r4, r5, r6, r7}
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    63f0:	6853      	ldr	r3, [r2, #4]
	*reg = hardware().sck_mux[sck_pin_index];
    63f2:	6019      	str	r1, [r3, #0]
}
    63f4:	4770      	bx	lr
    63f6:	bf00      	nop
    63f8:	001f4001 	.word	0x001f4001
    63fc:	38001001 	.word	0x38001001
    6400:	78001001 	.word	0x78001001
    6404:	801f0000 	.word	0x801f0000
    6408:	0000c1bc 	.word	0x0000c1bc

0000640c <SPIClass::transfer(void const*, void*, unsigned int)>:
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
    640c:	b10b      	cbz	r3, 6412 <SPIClass::transfer(void const*, void*, unsigned int)+0x6>
    640e:	f7ff bec3 	b.w	6198 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]>
    6412:	4770      	bx	lr

00006414 <ros::normalizeSecNSec(unsigned long&, unsigned long&)>:
#include "ros/time.h"

namespace ros
{
void normalizeSecNSec(uint32_t& sec, uint32_t& nsec)
{
    6414:	b470      	push	{r4, r5, r6}
  uint32_t nsec_part = nsec % 1000000000UL;
    6416:	680d      	ldr	r5, [r1, #0]
  uint32_t sec_part = nsec / 1000000000UL;
  sec += sec_part;
    6418:	4b06      	ldr	r3, [pc, #24]	; (6434 <ros::normalizeSecNSec(unsigned long&, unsigned long&)+0x20>)
    641a:	6804      	ldr	r4, [r0, #0]
  nsec = nsec_part;
    641c:	4e06      	ldr	r6, [pc, #24]	; (6438 <ros::normalizeSecNSec(unsigned long&, unsigned long&)+0x24>)
{
void normalizeSecNSec(uint32_t& sec, uint32_t& nsec)
{
  uint32_t nsec_part = nsec % 1000000000UL;
  uint32_t sec_part = nsec / 1000000000UL;
  sec += sec_part;
    641e:	0a6a      	lsrs	r2, r5, #9
    6420:	fba3 3202 	umull	r3, r2, r3, r2
    6424:	09d3      	lsrs	r3, r2, #7
    6426:	441c      	add	r4, r3
  nsec = nsec_part;
    6428:	fb06 5313 	mls	r3, r6, r3, r5
{
void normalizeSecNSec(uint32_t& sec, uint32_t& nsec)
{
  uint32_t nsec_part = nsec % 1000000000UL;
  uint32_t sec_part = nsec / 1000000000UL;
  sec += sec_part;
    642c:	6004      	str	r4, [r0, #0]
  nsec = nsec_part;
    642e:	600b      	str	r3, [r1, #0]
}
    6430:	bc70      	pop	{r4, r5, r6}
    6432:	4770      	bx	lr
    6434:	00044b83 	.word	0x00044b83
    6438:	3b9aca00 	.word	0x3b9aca00

0000643c <memcpy>:
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
#else
	push	{r0}
    643c:	b401      	push	{r0}
#endif
	orr	r3, r1, r0
    643e:	ea41 0300 	orr.w	r3, r1, r0
	ands	r3, r3, #3
    6442:	f013 0303 	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    6446:	d16f      	bne.n	6528 <memcpy+0xec>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    6448:	3a40      	subs	r2, #64	; 0x40
	blo	.Lmid_block
    644a:	d341      	bcc.n	64d0 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    644c:	f851 3b04 	ldr.w	r3, [r1], #4
    6450:	f840 3b04 	str.w	r3, [r0], #4
    6454:	f851 3b04 	ldr.w	r3, [r1], #4
    6458:	f840 3b04 	str.w	r3, [r0], #4
    645c:	f851 3b04 	ldr.w	r3, [r1], #4
    6460:	f840 3b04 	str.w	r3, [r0], #4
    6464:	f851 3b04 	ldr.w	r3, [r1], #4
    6468:	f840 3b04 	str.w	r3, [r0], #4
    646c:	f851 3b04 	ldr.w	r3, [r1], #4
    6470:	f840 3b04 	str.w	r3, [r0], #4
    6474:	f851 3b04 	ldr.w	r3, [r1], #4
    6478:	f840 3b04 	str.w	r3, [r0], #4
    647c:	f851 3b04 	ldr.w	r3, [r1], #4
    6480:	f840 3b04 	str.w	r3, [r0], #4
    6484:	f851 3b04 	ldr.w	r3, [r1], #4
    6488:	f840 3b04 	str.w	r3, [r0], #4
    648c:	f851 3b04 	ldr.w	r3, [r1], #4
    6490:	f840 3b04 	str.w	r3, [r0], #4
    6494:	f851 3b04 	ldr.w	r3, [r1], #4
    6498:	f840 3b04 	str.w	r3, [r0], #4
    649c:	f851 3b04 	ldr.w	r3, [r1], #4
    64a0:	f840 3b04 	str.w	r3, [r0], #4
    64a4:	f851 3b04 	ldr.w	r3, [r1], #4
    64a8:	f840 3b04 	str.w	r3, [r0], #4
    64ac:	f851 3b04 	ldr.w	r3, [r1], #4
    64b0:	f840 3b04 	str.w	r3, [r0], #4
    64b4:	f851 3b04 	ldr.w	r3, [r1], #4
    64b8:	f840 3b04 	str.w	r3, [r0], #4
    64bc:	f851 3b04 	ldr.w	r3, [r1], #4
    64c0:	f840 3b04 	str.w	r3, [r0], #4
    64c4:	f851 3b04 	ldr.w	r3, [r1], #4
    64c8:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    64cc:	3a40      	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    64ce:	d2bd      	bcs.n	644c <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    64d0:	3230      	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    64d2:	d311      	bcc.n	64f8 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    64d4:	f851 3b04 	ldr.w	r3, [r1], #4
    64d8:	f840 3b04 	str.w	r3, [r0], #4
    64dc:	f851 3b04 	ldr.w	r3, [r1], #4
    64e0:	f840 3b04 	str.w	r3, [r0], #4
    64e4:	f851 3b04 	ldr.w	r3, [r1], #4
    64e8:	f840 3b04 	str.w	r3, [r0], #4
    64ec:	f851 3b04 	ldr.w	r3, [r1], #4
    64f0:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    64f4:	3a10      	subs	r2, #16
	bhs	.Lmid_block_loop
    64f6:	d2ed      	bcs.n	64d4 <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    64f8:	320c      	adds	r2, #12
	blo	.Lcopy_less_than_4
    64fa:	d305      	bcc.n	6508 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    64fc:	f851 3b04 	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    6500:	f840 3b04 	str.w	r3, [r0], #4
	subs	r2, #4
    6504:	3a04      	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    6506:	d2f9      	bcs.n	64fc <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    6508:	3204      	adds	r2, #4
	beq	.Ldone
    650a:	d00a      	beq.n	6522 <memcpy+0xe6>

	lsls	r2, r2, #31
    650c:	07d2      	lsls	r2, r2, #31
	itt ne
    650e:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    6510:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    6514:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc	.Ldone
    6518:	d303      	bcc.n	6522 <memcpy+0xe6>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
	strh	r3, [r0]
#else
	ldrb	r3, [r1]
    651a:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    651c:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    651e:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    6520:	7043      	strb	r3, [r0, #1]

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    6522:	bc01      	pop	{r0}
#endif
	bx	lr
    6524:	4770      	bx	lr
    6526:	bf00      	nop
	beq	.Ldst_aligned
#else
	/* if len < 12, misalignment adjustment has more overhead than
	just byte-to-byte copy.  Also, len must >=8 to guarantee code
	afterward work correctly.  */
	cmp	r2, #12
    6528:	2a0c      	cmp	r2, #12
	blo	.Lbyte_copy
    652a:	d34a      	bcc.n	65c2 <memcpy+0x186>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    652c:	f010 0303 	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    6530:	d011      	beq.n	6556 <memcpy+0x11a>

	rsb	r3, #4
    6532:	f1c3 0304 	rsb	r3, r3, #4
	subs	r2, r3
    6536:	1ad2      	subs	r2, r2, r3

	lsls    r3, r3, #31
    6538:	07db      	lsls	r3, r3, #31
	itt ne
    653a:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    653c:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    6540:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    6544:	d307      	bcc.n	6556 <memcpy+0x11a>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
	strh    r3, [r0], #2
	b	.Ldst_aligned
#else
	ldrb    r3, [r1], #1
    6546:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    654a:	f800 3b01 	strb.w	r3, [r0], #1
	ldrb    r3, [r1], #1
    654e:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    6552:	f800 3b01 	strb.w	r3, [r0], #1
	/* Now that dst is aligned */
.Ldst_aligned:
	/* if r1 is aligned now, it means r0/r1 has the same misalignment,
	and they are both aligned now.  Go aligned copy.  */
	ands	r3, r1, #3
    6556:	f011 0303 	ands.w	r3, r1, #3
	beq	.Lbig_block
    655a:	f43f af75 	beq.w	6448 <memcpy+0xc>

	/* dst is aligned, but src isn't.  Misaligned copy.  */

	push	{r4, r5}
    655e:	b430      	push	{r4, r5}
	subs	r2, #4
    6560:	3a04      	subs	r2, #4

	/* Backward r1 by misaligned bytes, to make r1 aligned.
	Since we need to restore r1 to unaligned address after the loop,
	we need keep the offset bytes to ip and sub it from r1 afterward.  */
	subs	r1, r3
    6562:	1ac9      	subs	r1, r1, r3
	rsb	ip, r3, #4
    6564:	f1c3 0c04 	rsb	ip, r3, #4

	/* Pre-load on word */
	ldr	r4, [r1], #4
    6568:	f851 4b04 	ldr.w	r4, [r1], #4

	cmp	r3, #2
    656c:	2b02      	cmp	r3, #2
	beq	.Lmisaligned_copy_2_2
    656e:	d019      	beq.n	65a4 <memcpy+0x168>
	cmp	r3, #3
    6570:	2b03      	cmp	r3, #3
	beq	.Lmisaligned_copy_3_1
    6572:	d00b      	beq.n	658c <memcpy+0x150>
	subs	r2, #4
	bhs	1b
	.endm

.Lmisaligned_copy_1_3:
	mis_src_copy shift=8
    6574:	0a24      	lsrs	r4, r4, #8
    6576:	f851 3b04 	ldr.w	r3, [r1], #4
    657a:	061d      	lsls	r5, r3, #24
    657c:	ea44 0405 	orr.w	r4, r4, r5
    6580:	f840 4b04 	str.w	r4, [r0], #4
    6584:	461c      	mov	r4, r3
    6586:	3a04      	subs	r2, #4
    6588:	d2f4      	bcs.n	6574 <memcpy+0x138>
	b	.Lsrc_misaligned_tail
    658a:	e016      	b.n	65ba <memcpy+0x17e>

.Lmisaligned_copy_3_1:
	mis_src_copy shift=24
    658c:	0e24      	lsrs	r4, r4, #24
    658e:	f851 3b04 	ldr.w	r3, [r1], #4
    6592:	021d      	lsls	r5, r3, #8
    6594:	ea44 0405 	orr.w	r4, r4, r5
    6598:	f840 4b04 	str.w	r4, [r0], #4
    659c:	461c      	mov	r4, r3
    659e:	3a04      	subs	r2, #4
    65a0:	d2f4      	bcs.n	658c <memcpy+0x150>
	b	.Lsrc_misaligned_tail
    65a2:	e00a      	b.n	65ba <memcpy+0x17e>

.Lmisaligned_copy_2_2:
	/* For 2_2 misalignment, ldr is still faster than 2 x ldrh.  */
	mis_src_copy shift=16
    65a4:	0c24      	lsrs	r4, r4, #16
    65a6:	f851 3b04 	ldr.w	r3, [r1], #4
    65aa:	041d      	lsls	r5, r3, #16
    65ac:	ea44 0405 	orr.w	r4, r4, r5
    65b0:	f840 4b04 	str.w	r4, [r0], #4
    65b4:	461c      	mov	r4, r3
    65b6:	3a04      	subs	r2, #4
    65b8:	d2f4      	bcs.n	65a4 <memcpy+0x168>

.Lsrc_misaligned_tail:
	adds	r2, #4
    65ba:	3204      	adds	r2, #4
	subs	r1, ip
    65bc:	ebb1 010c 	subs.w	r1, r1, ip
	pop	{r4, r5}
    65c0:	bc30      	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    65c2:	3a04      	subs	r2, #4
	blo	.Lcopy_less_than_4
    65c4:	d3a0      	bcc.n	6508 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    65c6:	3a01      	subs	r2, #1
	ldrb    r3, [r1], #1
    65c8:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    65cc:	f800 3b01 	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    65d0:	d2f9      	bcs.n	65c6 <memcpy+0x18a>

	ldrb	r3, [r1]
    65d2:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    65d4:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    65d6:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    65d8:	7043      	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    65da:	788b      	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    65dc:	7083      	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    65de:	bc01      	pop	{r0}
#endif
	bx	lr
    65e0:	4770      	bx	lr
    65e2:	bf00      	nop

000065e4 <fault_isr>:
void _init_Teensyduino_internal_(void) __attribute__((noinline));
void __libc_init_array(void);


void fault_isr(void)
{
    65e4:	b508      	push	{r3, lr}
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    65e6:	4c10      	ldr	r4, [pc, #64]	; (6628 <fault_isr+0x44>)
    65e8:	e008      	b.n	65fc <fault_isr+0x18>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    65ea:	6823      	ldr	r3, [r4, #0]
    65ec:	0559      	lsls	r1, r3, #21
    65ee:	d40d      	bmi.n	660c <fault_isr+0x28>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    65f0:	6823      	ldr	r3, [r4, #0]
    65f2:	051a      	lsls	r2, r3, #20
    65f4:	d40f      	bmi.n	6616 <fault_isr+0x32>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    65f6:	6823      	ldr	r3, [r4, #0]
    65f8:	04db      	lsls	r3, r3, #19
    65fa:	d411      	bmi.n	6620 <fault_isr+0x3c>
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    65fc:	6823      	ldr	r3, [r4, #0]
    65fe:	0358      	lsls	r0, r3, #13
    6600:	d5f3      	bpl.n	65ea <fault_isr+0x6>
    6602:	f000 fceb 	bl	6fdc <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    6606:	6823      	ldr	r3, [r4, #0]
    6608:	0559      	lsls	r1, r3, #21
    660a:	d5f1      	bpl.n	65f0 <fault_isr+0xc>
    660c:	f000 f80e 	bl	662c <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    6610:	6823      	ldr	r3, [r4, #0]
    6612:	051a      	lsls	r2, r3, #20
    6614:	d5ef      	bpl.n	65f6 <fault_isr+0x12>
    6616:	f000 f809 	bl	662c <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    661a:	6823      	ldr	r3, [r4, #0]
    661c:	04db      	lsls	r3, r3, #19
    661e:	d5ed      	bpl.n	65fc <fault_isr+0x18>
    6620:	f000 f804 	bl	662c <unused_isr>
    6624:	e7ea      	b.n	65fc <fault_isr+0x18>
    6626:	bf00      	nop
    6628:	40048034 	.word	0x40048034

0000662c <unused_isr>:
	}
}

void unused_isr(void)
{
    662c:	b508      	push	{r3, lr}
	fault_isr();
    662e:	f7ff ffd9 	bl	65e4 <fault_isr>
    6632:	bf00      	nop

00006634 <startup_early_hook>:
extern void rtc_set(unsigned long t);


static void startup_default_early_hook(void) {
#if defined(KINETISK)
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    6634:	4b01      	ldr	r3, [pc, #4]	; (663c <startup_early_hook+0x8>)
    6636:	2210      	movs	r2, #16
    6638:	801a      	strh	r2, [r3, #0]
    663a:	4770      	bx	lr
    663c:	40052000 	.word	0x40052000

00006640 <startup_late_hook>:
#elif defined(KINETISL)
	SIM_COPC = 0;  // disable the watchdog
#endif
}
static void startup_default_late_hook(void) {}
    6640:	4770      	bx	lr
    6642:	bf00      	nop

00006644 <_sbrk>:

void * _sbrk(int incr)
{
	char *prev, *stack;

	prev = __brkval;
    6644:	4909      	ldr	r1, [pc, #36]	; (666c <_sbrk+0x28>)

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

void * _sbrk(int incr)
{
    6646:	b508      	push	{r3, lr}
	char *prev, *stack;

	prev = __brkval;
    6648:	680b      	ldr	r3, [r1, #0]
	if (incr != 0) {
    664a:	b130      	cbz	r0, 665a <_sbrk+0x16>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
    664c:	466a      	mov	r2, sp
		if (prev + incr >= stack - STACK_MARGIN) {
    664e:	4418      	add	r0, r3
    6650:	f5a2 5200 	sub.w	r2, r2, #8192	; 0x2000
    6654:	4290      	cmp	r0, r2
    6656:	d202      	bcs.n	665e <_sbrk+0x1a>
			errno = ENOMEM;
			return (void *)-1;
		}
		__brkval = prev + incr;
    6658:	6008      	str	r0, [r1, #0]
	}
	return prev;
    665a:	4618      	mov	r0, r3
}
    665c:	bd08      	pop	{r3, pc}

	prev = __brkval;
	if (incr != 0) {
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
		if (prev + incr >= stack - STACK_MARGIN) {
			errno = ENOMEM;
    665e:	f004 f8f1 	bl	a844 <__errno>
    6662:	230c      	movs	r3, #12
    6664:	6003      	str	r3, [r0, #0]
			return (void *)-1;
    6666:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    666a:	bd08      	pop	{r3, pc}
    666c:	1fff0960 	.word	0x1fff0960

00006670 <kinetis_hsrun_disable>:


#if defined(HAS_KINETIS_HSRUN) && F_CPU > 120000000
int kinetis_hsrun_disable(void)
{
	if (SMC_PMSTAT == SMC_PMSTAT_HSRUN) {
    6670:	4a08      	ldr	r2, [pc, #32]	; (6694 <kinetis_hsrun_disable+0x24>)
    6672:	7813      	ldrb	r3, [r2, #0]
    6674:	2b80      	cmp	r3, #128	; 0x80
    6676:	d001      	beq.n	667c <kinetis_hsrun_disable+0xc>
		// Then turn off HSRUN mode
		SMC_PMCTRL = SMC_PMCTRL_RUNM(0);
		while (SMC_PMSTAT == SMC_PMSTAT_HSRUN) ; // wait
		return 1;
	}
	return 0;
    6678:	2000      	movs	r0, #0
}
    667a:	4770      	bx	lr
		#elif F_CPU == 192000000 && F_BUS == 64000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(2, 2, 2, 8); // ok
		#elif F_CPU == 192000000 && F_BUS == 96000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 7); // ok
		#elif F_CPU == 180000000 && F_BUS == 60000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(2, 2, 2, 8); // ok
    667c:	4906      	ldr	r1, [pc, #24]	; (6698 <kinetis_hsrun_disable+0x28>)
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 5); // ok
		#else
			return 0;
		#endif
		// Then turn off HSRUN mode
		SMC_PMCTRL = SMC_PMCTRL_RUNM(0);
    667e:	4b07      	ldr	r3, [pc, #28]	; (669c <kinetis_hsrun_disable+0x2c>)
		#elif F_CPU == 192000000 && F_BUS == 64000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(2, 2, 2, 8); // ok
		#elif F_CPU == 192000000 && F_BUS == 96000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 7); // ok
		#elif F_CPU == 180000000 && F_BUS == 60000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(2, 2, 2, 8); // ok
    6680:	4807      	ldr	r0, [pc, #28]	; (66a0 <kinetis_hsrun_disable+0x30>)
    6682:	6008      	str	r0, [r1, #0]
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 5); // ok
		#else
			return 0;
		#endif
		// Then turn off HSRUN mode
		SMC_PMCTRL = SMC_PMCTRL_RUNM(0);
    6684:	2100      	movs	r1, #0
    6686:	7019      	strb	r1, [r3, #0]
		while (SMC_PMSTAT == SMC_PMSTAT_HSRUN) ; // wait
    6688:	7813      	ldrb	r3, [r2, #0]
    668a:	2b80      	cmp	r3, #128	; 0x80
    668c:	d0fc      	beq.n	6688 <kinetis_hsrun_disable+0x18>
		return 1;
    668e:	2001      	movs	r0, #1
    6690:	4770      	bx	lr
    6692:	bf00      	nop
    6694:	4007e003 	.word	0x4007e003
    6698:	40048044 	.word	0x40048044
    669c:	4007e001 	.word	0x4007e001
    66a0:	22280000 	.word	0x22280000

000066a4 <kinetis_hsrun_enable>:
	return 0;
}

int kinetis_hsrun_enable(void)
{
	if (SMC_PMSTAT == SMC_PMSTAT_RUN) {
    66a4:	4a09      	ldr	r2, [pc, #36]	; (66cc <kinetis_hsrun_enable+0x28>)
    66a6:	7813      	ldrb	r3, [r2, #0]
    66a8:	2b01      	cmp	r3, #1
    66aa:	d001      	beq.n	66b0 <kinetis_hsrun_enable+0xc>
		#else
			return 0;
		#endif
		return 1;
	}
	return 0;
    66ac:	2000      	movs	r0, #0
}
    66ae:	4770      	bx	lr

int kinetis_hsrun_enable(void)
{
	if (SMC_PMSTAT == SMC_PMSTAT_RUN) {
		// Turn HSRUN mode on
		SMC_PMCTRL = SMC_PMCTRL_RUNM(3);
    66b0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    66b4:	f503 23fc 	add.w	r3, r3, #516096	; 0x7e000
    66b8:	2160      	movs	r1, #96	; 0x60
    66ba:	7019      	strb	r1, [r3, #0]
		while (SMC_PMSTAT != SMC_PMSTAT_HSRUN) {;} // wait
    66bc:	7813      	ldrb	r3, [r2, #0]
    66be:	2b80      	cmp	r3, #128	; 0x80
    66c0:	d1fc      	bne.n	66bc <kinetis_hsrun_enable+0x18>
		#elif F_CPU == 192000000 && F_BUS == 64000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 2, 0, 6);
		#elif F_CPU == 192000000 && F_BUS == 96000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 1, 0, 6);
		#elif F_CPU == 180000000 && F_BUS == 60000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 2, 0, 6);
    66c2:	4b03      	ldr	r3, [pc, #12]	; (66d0 <kinetis_hsrun_enable+0x2c>)
    66c4:	4a03      	ldr	r2, [pc, #12]	; (66d4 <kinetis_hsrun_enable+0x30>)
    66c6:	601a      	str	r2, [r3, #0]
		#elif F_CPU == 144000000 && F_BUS == 72000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 1, 0, 4);
		#else
			return 0;
		#endif
		return 1;
    66c8:	2001      	movs	r0, #1
    66ca:	4770      	bx	lr
    66cc:	4007e003 	.word	0x4007e003
    66d0:	40048044 	.word	0x40048044
    66d4:	02060000 	.word	0x02060000

000066d8 <dummy_isr>:
	{((volatile uint8_t *)&CORE_PIN26_PORTREG + (CORE_PIN26_BIT >> 3)), &CORE_PIN26_CONFIG, (1<<(CORE_PIN26_BIT & 7))}
};

#endif

static void dummy_isr() {};
    66d8:	4770      	bx	lr
    66da:	bf00      	nop

000066dc <digitalWrite.part.1>:



// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
    66dc:	b410      	push	{r4}
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
    66de:	4b11      	ldr	r3, [pc, #68]	; (6724 <digitalWrite.part.1+0x48>)
    66e0:	f853 2030 	ldr.w	r2, [r3, r0, lsl #3]
    66e4:	f892 4280 	ldrb.w	r4, [r2, #640]	; 0x280
    66e8:	b134      	cbz	r4, 66f8 <digitalWrite.part.1+0x1c>
		if (val) {
			*portSetRegister(pin) = 1;
    66ea:	2301      	movs	r3, #1
void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
    66ec:	b179      	cbz	r1, 670e <digitalWrite.part.1+0x32>
			*portSetRegister(pin) = 1;
    66ee:	f882 3080 	strb.w	r3, [r2, #128]	; 0x80
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    66f2:	f85d 4b04 	ldr.w	r4, [sp], #4
    66f6:	4770      	bx	lr
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
    66f8:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
    66fc:	685b      	ldr	r3, [r3, #4]
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    66fe:	681a      	ldr	r2, [r3, #0]
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
    6700:	b951      	cbnz	r1, 6718 <digitalWrite.part.1+0x3c>
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
			//*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else {
			// TODO use bitband for atomic read-mod-write
			*config &= ~(PORT_PCR_PE);
    6702:	f022 0202 	bic.w	r2, r2, #2
    6706:	601a      	str	r2, [r3, #0]
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    6708:	f85d 4b04 	ldr.w	r4, [sp], #4
    670c:	4770      	bx	lr
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
			*portSetRegister(pin) = 1;
		} else {
			*portClearRegister(pin) = 1;
    670e:	f882 3100 	strb.w	r3, [r2, #256]	; 0x100
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    6712:	f85d 4b04 	ldr.w	r4, [sp], #4
    6716:	4770      	bx	lr
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    6718:	f042 0203 	orr.w	r2, r2, #3
    671c:	601a      	str	r2, [r3, #0]
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    671e:	f85d 4b04 	ldr.w	r4, [sp], #4
    6722:	4770      	bx	lr
    6724:	0000c1bc 	.word	0x0000c1bc

00006728 <pinMode.part.2>:
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    6728:	4a1c      	ldr	r2, [pc, #112]	; (679c <pinMode.part.2+0x74>)
    672a:	eb02 03c0 	add.w	r3, r2, r0, lsl #3

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    672e:	2901      	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    6730:	685b      	ldr	r3, [r3, #4]

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    6732:	d011      	beq.n	6758 <pinMode.part.2+0x30>
    6734:	2904      	cmp	r1, #4
    6736:	d01b      	beq.n	6770 <pinMode.part.2+0x48>
		} else {
		    *config &= ~PORT_PCR_ODE;
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
    6738:	f852 0030 	ldr.w	r0, [r2, r0, lsl #3]
    673c:	2200      	movs	r2, #0
    673e:	f880 2280 	strb.w	r2, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
    6742:	b129      	cbz	r1, 6750 <pinMode.part.2+0x28>
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
    6744:	2902      	cmp	r1, #2
    6746:	d020      	beq.n	678a <pinMode.part.2+0x62>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else if (mode == INPUT_PULLDOWN) {
    6748:	2903      	cmp	r1, #3
    674a:	d022      	beq.n	6792 <pinMode.part.2+0x6a>
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    674c:	601a      	str	r2, [r3, #0]
    674e:	4770      	bx	lr
		*portModeRegister(pin) = 0;
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
    6750:	f44f 7280 	mov.w	r2, #256	; 0x100
    6754:	601a      	str	r2, [r3, #0]
    6756:	4770      	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    6758:	f852 0030 	ldr.w	r0, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    675c:	f44f 72a2 	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    6760:	f880 1280 	strb.w	r1, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    6764:	601a      	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    6766:	681a      	ldr	r2, [r3, #0]
    6768:	f022 0220 	bic.w	r2, r2, #32
    676c:	601a      	str	r2, [r3, #0]
    676e:	4770      	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    6770:	f852 1030 	ldr.w	r1, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    6774:	f44f 72a2 	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    6778:	2001      	movs	r0, #1
    677a:	f881 0280 	strb.w	r0, [r1, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    677e:	601a      	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
    6780:	681a      	ldr	r2, [r3, #0]
    6782:	f042 0220 	orr.w	r2, r2, #32
    6786:	601a      	str	r2, [r3, #0]
    6788:	4770      	bx	lr
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    678a:	f240 1203 	movw	r2, #259	; 0x103
    678e:	601a      	str	r2, [r3, #0]
    6790:	4770      	bx	lr
		} else if (mode == INPUT_PULLDOWN) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    6792:	f44f 7281 	mov.w	r2, #258	; 0x102
    6796:	601a      	str	r2, [r3, #0]
    6798:	4770      	bx	lr
    679a:	bf00      	nop
    679c:	0000c1bc 	.word	0x0000c1bc

000067a0 <attachInterrupt>:
void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
    67a0:	283f      	cmp	r0, #63	; 0x3f
    67a2:	d848      	bhi.n	6836 <attachInterrupt+0x96>
{
	_VectorsRam[irq + 16] = function;
}

void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
    67a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	switch (mode) {
    67a6:	2a04      	cmp	r2, #4
    67a8:	d844      	bhi.n	6834 <attachInterrupt+0x94>
    67aa:	e8df f002 	tbb	[pc, r2]
    67ae:	4b48      	.short	0x4b48
    67b0:	034e      	.short	0x034e
    67b2:	45          	.byte	0x45
    67b3:	00          	.byte	0x00
    67b4:	f44f 2610 	mov.w	r6, #589824	; 0x90000
	  case LOW:	mask = 0x08; break;
	  case HIGH:	mask = 0x0C; break;
	  default: return;
	}
	mask = (mask << 16) | 0x01000000;
	config = portConfigRegister(pin);
    67b8:	4b2b      	ldr	r3, [pc, #172]	; (6868 <attachInterrupt+0xc8>)
    67ba:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
    67be:	460d      	mov	r5, r1
    67c0:	685c      	ldr	r4, [r3, #4]
	if ((*config & 0x00000700) == 0) {
    67c2:	6821      	ldr	r1, [r4, #0]
    67c4:	f411 61e0 	ands.w	r1, r1, #1792	; 0x700
    67c8:	d048      	beq.n	685c <attachInterrupt+0xbc>
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    67ca:	4b28      	ldr	r3, [pc, #160]	; (686c <attachInterrupt+0xcc>)
    67cc:	4a28      	ldr	r2, [pc, #160]	; (6870 <attachInterrupt+0xd0>)
    67ce:	4929      	ldr	r1, [pc, #164]	; (6874 <attachInterrupt+0xd4>)
    67d0:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    67d4:	f104 4240 	add.w	r2, r4, #3221225472	; 0xc0000000
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    67d8:	4827      	ldr	r0, [pc, #156]	; (6878 <attachInterrupt+0xd8>)
    67da:	f8c3 1134 	str.w	r1, [r3, #308]	; 0x134

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    67de:	f5a2 2192 	sub.w	r1, r2, #299008	; 0x49000
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    67e2:	4f26      	ldr	r7, [pc, #152]	; (687c <attachInterrupt+0xdc>)
    67e4:	f8c3 0130 	str.w	r0, [r3, #304]	; 0x130

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    67e8:	297c      	cmp	r1, #124	; 0x7c
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    67ea:	4825      	ldr	r0, [pc, #148]	; (6880 <attachInterrupt+0xe0>)
    67ec:	f8c3 7138 	str.w	r7, [r3, #312]	; 0x138
    67f0:	f8c3 013c 	str.w	r0, [r3, #316]	; 0x13c

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    67f4:	d92c      	bls.n	6850 <attachInterrupt+0xb0>
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
    67f6:	f5a2 2394 	sub.w	r3, r2, #303104	; 0x4a000
    67fa:	2b7c      	cmp	r3, #124	; 0x7c
    67fc:	d92a      	bls.n	6854 <attachInterrupt+0xb4>
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
    67fe:	f5a2 2396 	sub.w	r3, r2, #307200	; 0x4b000
    6802:	2b7c      	cmp	r3, #124	; 0x7c
    6804:	d928      	bls.n	6858 <attachInterrupt+0xb8>
	else if(&PORTD_PCR0 <= config && config <= &PORTD_PCR31) isr_table = isr_table_portD;
    6806:	f5a2 2398 	sub.w	r3, r2, #311296	; 0x4c000
    680a:	2b7c      	cmp	r3, #124	; 0x7c
    680c:	d929      	bls.n	6862 <attachInterrupt+0xc2>
	else if(&PORTE_PCR0 <= config && config <= &PORTE_PCR31) isr_table = isr_table_portE;
    680e:	f5a2 229a 	sub.w	r2, r2, #315392	; 0x4d000
    6812:	2a7c      	cmp	r2, #124	; 0x7c
    6814:	d827      	bhi.n	6866 <attachInterrupt+0xc6>
    6816:	481b      	ldr	r0, [pc, #108]	; (6884 <attachInterrupt+0xe4>)
	attachInterruptVector(IRQ_PORTD, port_D_isr);
	attachInterruptVector(IRQ_PORTE, port_E_isr);
	voidFuncPtr* isr_table = getIsrTable(config);
	if(!isr_table) return;
	uint32_t pin_index = getPinIndex(config);
	__disable_irq();
    6818:	b672      	cpsid	i
	cfg = *config;
    681a:	6823      	ldr	r3, [r4, #0]
	cfg &= ~0x000F0000;		// disable any previous interrupt
    681c:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    6820:	f043 7280 	orr.w	r2, r3, #16777216	; 0x1000000
	*config = cfg;
	isr_table[pin_index] = function;	// set the function pointer
    6824:	f3c4 0184 	ubfx	r1, r4, #2, #5
	cfg |= mask;
    6828:	4316      	orrs	r6, r2
	if(!isr_table) return;
	uint32_t pin_index = getPinIndex(config);
	__disable_irq();
	cfg = *config;
	cfg &= ~0x000F0000;		// disable any previous interrupt
	*config = cfg;
    682a:	6023      	str	r3, [r4, #0]
	isr_table[pin_index] = function;	// set the function pointer
    682c:	f840 5021 	str.w	r5, [r0, r1, lsl #2]
	cfg |= mask;
	*config = cfg;			// enable the new interrupt
    6830:	6026      	str	r6, [r4, #0]
	__enable_irq();
    6832:	b662      	cpsie	i
    6834:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6836:	4770      	bx	lr
{
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	switch (mode) {
    6838:	f44f 2630 	mov.w	r6, #720896	; 0xb0000
    683c:	e7bc      	b.n	67b8 <attachInterrupt+0x18>
	  case CHANGE:	mask = 0x0B; break;
	  case RISING:	mask = 0x09; break;
	  case FALLING:	mask = 0x0A; break;
	  case LOW:	mask = 0x08; break;
    683e:	f44f 2600 	mov.w	r6, #524288	; 0x80000
    6842:	e7b9      	b.n	67b8 <attachInterrupt+0x18>
	  case HIGH:	mask = 0x0C; break;
    6844:	f44f 2640 	mov.w	r6, #786432	; 0xc0000
    6848:	e7b6      	b.n	67b8 <attachInterrupt+0x18>
{
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	switch (mode) {
    684a:	f44f 2620 	mov.w	r6, #655360	; 0xa0000
    684e:	e7b3      	b.n	67b8 <attachInterrupt+0x18>

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    6850:	480d      	ldr	r0, [pc, #52]	; (6888 <attachInterrupt+0xe8>)
    6852:	e7e1      	b.n	6818 <attachInterrupt+0x78>
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
    6854:	480d      	ldr	r0, [pc, #52]	; (688c <attachInterrupt+0xec>)
    6856:	e7df      	b.n	6818 <attachInterrupt+0x78>
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
    6858:	480d      	ldr	r0, [pc, #52]	; (6890 <attachInterrupt+0xf0>)
    685a:	e7dd      	b.n	6818 <attachInterrupt+0x78>
    685c:	f7ff ff64 	bl	6728 <pinMode.part.2>
    6860:	e7b3      	b.n	67ca <attachInterrupt+0x2a>
	else if(&PORTD_PCR0 <= config && config <= &PORTD_PCR31) isr_table = isr_table_portD;
    6862:	480c      	ldr	r0, [pc, #48]	; (6894 <attachInterrupt+0xf4>)
    6864:	e7d8      	b.n	6818 <attachInterrupt+0x78>
    6866:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6868:	0000c1bc 	.word	0x0000c1bc
    686c:	1fff0200 	.word	0x1fff0200
    6870:	1fff07e1 	.word	0x1fff07e1
    6874:	1fff0789 	.word	0x1fff0789
    6878:	1fff07b5 	.word	0x1fff07b5
    687c:	1fff075d 	.word	0x1fff075d
    6880:	1fff0731 	.word	0x1fff0731
    6884:	1fff0aac 	.word	0x1fff0aac
    6888:	1fff0964 	.word	0x1fff0964
    688c:	1fff09dc 	.word	0x1fff09dc
    6890:	1fff0a3c 	.word	0x1fff0a3c
    6894:	1fff0a6c 	.word	0x1fff0a6c

00006898 <rtc_set>:
{
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
    6898:	b430      	push	{r4, r5}
	RTC_SR = 0;
    689a:	4b05      	ldr	r3, [pc, #20]	; (68b0 <rtc_set+0x18>)
	RTC_TPR = 0;
    689c:	4d05      	ldr	r5, [pc, #20]	; (68b4 <rtc_set+0x1c>)
	RTC_TSR = t;
    689e:	4c06      	ldr	r4, [pc, #24]	; (68b8 <rtc_set+0x20>)
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    68a0:	2200      	movs	r2, #0
	RTC_TPR = 0;
	RTC_TSR = t;
	RTC_SR = RTC_SR_TCE;
    68a2:	2110      	movs	r1, #16
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    68a4:	601a      	str	r2, [r3, #0]
	RTC_TPR = 0;
    68a6:	602a      	str	r2, [r5, #0]
	RTC_TSR = t;
    68a8:	6020      	str	r0, [r4, #0]
	RTC_SR = RTC_SR_TCE;
    68aa:	6019      	str	r1, [r3, #0]
}
    68ac:	bc30      	pop	{r4, r5}
    68ae:	4770      	bx	lr
    68b0:	4003d014 	.word	0x4003d014
    68b4:	4003d004 	.word	0x4003d004
    68b8:	4003d000 	.word	0x4003d000

000068bc <analogWrite>:
// FTM is clocked by the bus clock, either 24 or 48 MHz
// input capture can be FTM1_CH0, CMP0 or CMP1 or USB start of frame
// 24 MHz with reload 49152 to match Arduino's speed = 488.28125 Hz

void analogWrite(uint8_t pin, int val)
{
    68bc:	b538      	push	{r3, r4, r5, lr}
		}
		analogWriteDAC0(val);
		return;
	}
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (pin == A21 || pin == A22) {
    68be:	f1a0 0342 	sub.w	r3, r0, #66	; 0x42
    68c2:	2b01      	cmp	r3, #1
// FTM is clocked by the bus clock, either 24 or 48 MHz
// input capture can be FTM1_CH0, CMP0 or CMP1 or USB start of frame
// 24 MHz with reload 49152 to match Arduino's speed = 488.28125 Hz

void analogWrite(uint8_t pin, int val)
{
    68c4:	4604      	mov	r4, r0
		}
		analogWriteDAC0(val);
		return;
	}
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (pin == A21 || pin == A22) {
    68c6:	d924      	bls.n	6912 <analogWrite+0x56>
		return;
	}
#endif

	max = 1 << analog_write_res;
	if (val <= 0) {
    68c8:	2900      	cmp	r1, #0
    68ca:	dd7a      	ble.n	69c2 <analogWrite+0x106>
		else analogWriteDAC1(val);
		return;
	}
#endif

	max = 1 << analog_write_res;
    68cc:	4b99      	ldr	r3, [pc, #612]	; (6b34 <analogWrite+0x278>)
    68ce:	781b      	ldrb	r3, [r3, #0]
	if (val <= 0) {
		digitalWrite(pin, LOW);
		pinMode(pin, OUTPUT);	// TODO: implement OUTPUT_LOW
		return;
	} else if (val >= max) {
    68d0:	2501      	movs	r5, #1
    68d2:	fa05 f203 	lsl.w	r2, r5, r3
    68d6:	428a      	cmp	r2, r1
    68d8:	d802      	bhi.n	68e0 <analogWrite+0x24>

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    68da:	283f      	cmp	r0, #63	; 0x3f
    68dc:	d92c      	bls.n	6938 <analogWrite+0x7c>
    68de:	bd38      	pop	{r3, r4, r5, pc}
	//serial_phex32(val);
	//serial_print("\n");
	//serial_print("analog_write_res = ");
	//serial_phex(analog_write_res);
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
    68e0:	1ec2      	subs	r2, r0, #3
    68e2:	2a01      	cmp	r2, #1
    68e4:	d930      	bls.n	6948 <analogWrite+0x8c>
		cval = ((uint32_t)val * (uint32_t)(FTM1_MOD + 1)) >> analog_write_res;
#if defined(FTM2_CH0_PIN)
	} else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
    68e6:	f1a0 021d 	sub.w	r2, r0, #29
    68ea:	2a01      	cmp	r2, #1
    68ec:	d978      	bls.n	69e0 <analogWrite+0x124>
		cval = ((uint32_t)val * (uint32_t)(FTM2_MOD + 1)) >> analog_write_res;
#endif
#if defined(FTM3_CH0_PIN)
	} else if (pin == FTM3_CH0_PIN || pin == FTM3_CH1_PIN || pin == FTM3_CH2_PIN
    68ee:	280e      	cmp	r0, #14
    68f0:	d95b      	bls.n	69aa <analogWrite+0xee>
	  || pin == FTM3_CH3_PIN || pin == FTM3_CH4_PIN || pin == FTM3_CH5_PIN
    68f2:	f1a4 0223 	sub.w	r2, r4, #35	; 0x23
    68f6:	2a03      	cmp	r2, #3
    68f8:	d95c      	bls.n	69b4 <analogWrite+0xf8>
	  || pin == FTM3_CH6_PIN || pin == FTM3_CH7_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM3_MOD + 1)) >> analog_write_res;
#endif
#if defined(TPM1_CH0_PIN)
	} else if (pin == TPM1_CH0_PIN || pin == TPM1_CH1_PIN) {
    68fa:	f1a4 0210 	sub.w	r2, r4, #16
    68fe:	2a01      	cmp	r2, #1
		cval = ((uint32_t)val * (uint32_t)(TPM1_MOD + 1)) >> analog_write_res;
    6900:	bf94      	ite	ls
    6902:	4a8d      	ldrls	r2, [pc, #564]	; (6b38 <analogWrite+0x27c>)
#endif
	} else {
		cval = ((uint32_t)val * (uint32_t)(FTM0_MOD + 1)) >> analog_write_res;
    6904:	4a8d      	ldrhi	r2, [pc, #564]	; (6b3c <analogWrite+0x280>)
    6906:	6812      	ldr	r2, [r2, #0]
    6908:	fb02 1201 	mla	r2, r2, r1, r1
    690c:	fa22 f303 	lsr.w	r3, r2, r3
    6910:	e020      	b.n	6954 <analogWrite+0x98>
		analogWriteDAC0(val);
		return;
	}
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (pin == A21 || pin == A22) {
		uint8_t res = analog_write_res;
    6912:	4b88      	ldr	r3, [pc, #544]	; (6b34 <analogWrite+0x278>)
    6914:	781b      	ldrb	r3, [r3, #0]
		if (res < 12) {
    6916:	2b0b      	cmp	r3, #11
    6918:	d90a      	bls.n	6930 <analogWrite+0x74>
			val <<= 12 - res;
		} else if (res > 12) {
    691a:	2b0c      	cmp	r3, #12
			val >>= res - 12;
    691c:	bf1c      	itt	ne
    691e:	3b0c      	subne	r3, #12
    6920:	4119      	asrne	r1, r3
		}
		if (pin == A21) analogWriteDAC0(val);
    6922:	2c42      	cmp	r4, #66	; 0x42
    6924:	4608      	mov	r0, r1
    6926:	d057      	beq.n	69d8 <analogWrite+0x11c>
#endif
	  default:
		digitalWrite(pin, (val > 127) ? HIGH : LOW);
		pinMode(pin, OUTPUT);
	}
}
    6928:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			val <<= 12 - res;
		} else if (res > 12) {
			val >>= res - 12;
		}
		if (pin == A21) analogWriteDAC0(val);
		else analogWriteDAC1(val);
    692c:	f001 bb56 	b.w	7fdc <analogWriteDAC1>
	}
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (pin == A21 || pin == A22) {
		uint8_t res = analog_write_res;
		if (res < 12) {
			val <<= 12 - res;
    6930:	f1c3 030c 	rsb	r3, r3, #12
    6934:	4099      	lsls	r1, r3
    6936:	e7f4      	b.n	6922 <analogWrite+0x66>
    6938:	4629      	mov	r1, r5
    693a:	f7ff fecf 	bl	66dc <digitalWrite.part.1>
    693e:	4629      	mov	r1, r5
#endif
	  default:
		digitalWrite(pin, (val > 127) ? HIGH : LOW);
		pinMode(pin, OUTPUT);
	}
}
    6940:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    6944:	f7ff bef0 	b.w	6728 <pinMode.part.2>
	//serial_print("\n");
	//serial_print("analog_write_res = ");
	//serial_phex(analog_write_res);
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM1_MOD + 1)) >> analog_write_res;
    6948:	4a7d      	ldr	r2, [pc, #500]	; (6b40 <analogWrite+0x284>)
    694a:	6812      	ldr	r2, [r2, #0]
    694c:	fb02 1201 	mla	r2, r2, r1, r1
    6950:	fa22 f303 	lsr.w	r3, r2, r3
		cval = ((uint32_t)val * (uint32_t)(FTM0_MOD + 1)) >> analog_write_res;
	}
	//serial_print("cval = ");
	//serial_phex32(cval);
	//serial_print("\n");
	switch (pin) {
    6954:	1ea2      	subs	r2, r4, #2
    6956:	2a24      	cmp	r2, #36	; 0x24
    6958:	f200 80e3 	bhi.w	6b22 <analogWrite+0x266>
    695c:	e8df f012 	tbh	[pc, r2, lsl #1]
    6960:	00d300da 	.word	0x00d300da
    6964:	00c500cc 	.word	0x00c500cc
    6968:	00b700be 	.word	0x00b700be
    696c:	00a900b0 	.word	0x00a900b0
    6970:	00e100a2 	.word	0x00e100a2
    6974:	00e100e1 	.word	0x00e100e1
    6978:	00e1009b 	.word	0x00e1009b
    697c:	008d0094 	.word	0x008d0094
    6980:	00e100e1 	.word	0x00e100e1
    6984:	007f0086 	.word	0x007f0086
    6988:	00710078 	.word	0x00710078
    698c:	00e100e1 	.word	0x00e100e1
    6990:	00e100e1 	.word	0x00e100e1
    6994:	006a00e1 	.word	0x006a00e1
    6998:	00e10063 	.word	0x00e10063
    699c:	00e100e1 	.word	0x00e100e1
    69a0:	005c00e1 	.word	0x005c00e1
    69a4:	004e0055 	.word	0x004e0055
    69a8:	0047      	.short	0x0047
#if defined(FTM2_CH0_PIN)
	} else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM2_MOD + 1)) >> analog_write_res;
#endif
#if defined(FTM3_CH0_PIN)
	} else if (pin == FTM3_CH0_PIN || pin == FTM3_CH1_PIN || pin == FTM3_CH2_PIN
    69aa:	f244 1284 	movw	r2, #16772	; 0x4184
    69ae:	40c2      	lsrs	r2, r0
    69b0:	07d2      	lsls	r2, r2, #31
    69b2:	d59e      	bpl.n	68f2 <analogWrite+0x36>
	  || pin == FTM3_CH3_PIN || pin == FTM3_CH4_PIN || pin == FTM3_CH5_PIN
	  || pin == FTM3_CH6_PIN || pin == FTM3_CH7_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM3_MOD + 1)) >> analog_write_res;
    69b4:	4a63      	ldr	r2, [pc, #396]	; (6b44 <analogWrite+0x288>)
    69b6:	6812      	ldr	r2, [r2, #0]
    69b8:	fb02 1201 	mla	r2, r2, r1, r1
    69bc:	fa22 f303 	lsr.w	r3, r2, r3
    69c0:	e7c8      	b.n	6954 <analogWrite+0x98>

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    69c2:	283f      	cmp	r0, #63	; 0x3f
    69c4:	d88b      	bhi.n	68de <analogWrite+0x22>
    69c6:	2100      	movs	r1, #0
    69c8:	f7ff fe88 	bl	66dc <digitalWrite.part.1>
    69cc:	4620      	mov	r0, r4
    69ce:	2101      	movs	r1, #1
#endif
	  default:
		digitalWrite(pin, (val > 127) ? HIGH : LOW);
		pinMode(pin, OUTPUT);
	}
}
    69d0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    69d4:	f7ff bea8 	b.w	6728 <pinMode.part.2>
    69d8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		if (res < 12) {
			val <<= 12 - res;
		} else if (res > 12) {
			val >>= res - 12;
		}
		if (pin == A21) analogWriteDAC0(val);
    69dc:	f001 bae0 	b.w	7fa0 <analogWriteDAC0>
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM1_MOD + 1)) >> analog_write_res;
#if defined(FTM2_CH0_PIN)
	} else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM2_MOD + 1)) >> analog_write_res;
    69e0:	4a59      	ldr	r2, [pc, #356]	; (6b48 <analogWrite+0x28c>)
    69e2:	6812      	ldr	r2, [r2, #0]
    69e4:	fb02 1201 	mla	r2, r2, r1, r1
    69e8:	fa22 f303 	lsr.w	r3, r2, r3
    69ec:	e7b2      	b.n	6954 <analogWrite+0x98>
		FTM_PINCFG(FTM3_CH6_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH7_PIN
	  case FTM3_CH7_PIN:
		FTM3_C7V = cval;
    69ee:	4957      	ldr	r1, [pc, #348]	; (6b4c <analogWrite+0x290>)
		FTM_PINCFG(FTM3_CH7_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    69f0:	4a57      	ldr	r2, [pc, #348]	; (6b50 <analogWrite+0x294>)
		FTM_PINCFG(FTM3_CH6_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH7_PIN
	  case FTM3_CH7_PIN:
		FTM3_C7V = cval;
    69f2:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH7_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    69f4:	f44f 7351 	mov.w	r3, #836	; 0x344
    69f8:	6013      	str	r3, [r2, #0]
		break;
    69fa:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH5_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH6_PIN
	  case FTM3_CH6_PIN:
		FTM3_C6V = cval;
    69fc:	4955      	ldr	r1, [pc, #340]	; (6b54 <analogWrite+0x298>)
		FTM_PINCFG(FTM3_CH6_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    69fe:	4a56      	ldr	r2, [pc, #344]	; (6b58 <analogWrite+0x29c>)
		FTM_PINCFG(FTM3_CH5_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH6_PIN
	  case FTM3_CH6_PIN:
		FTM3_C6V = cval;
    6a00:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH6_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a02:	f44f 7351 	mov.w	r3, #836	; 0x344
    6a06:	6013      	str	r3, [r2, #0]
		break;
    6a08:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH4_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH5_PIN
	  case FTM3_CH5_PIN:
		FTM3_C5V = cval;
    6a0a:	4954      	ldr	r1, [pc, #336]	; (6b5c <analogWrite+0x2a0>)
		FTM_PINCFG(FTM3_CH5_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a0c:	4a54      	ldr	r2, [pc, #336]	; (6b60 <analogWrite+0x2a4>)
		FTM_PINCFG(FTM3_CH4_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH5_PIN
	  case FTM3_CH5_PIN:
		FTM3_C5V = cval;
    6a0e:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH5_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a10:	f44f 7351 	mov.w	r3, #836	; 0x344
    6a14:	6013      	str	r3, [r2, #0]
		break;
    6a16:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH4_PIN
	  case FTM3_CH4_PIN:
		FTM3_C4V = cval;
    6a18:	4952      	ldr	r1, [pc, #328]	; (6b64 <analogWrite+0x2a8>)
		FTM_PINCFG(FTM3_CH4_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a1a:	4a53      	ldr	r2, [pc, #332]	; (6b68 <analogWrite+0x2ac>)
		FTM_PINCFG(FTM3_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH4_PIN
	  case FTM3_CH4_PIN:
		FTM3_C4V = cval;
    6a1c:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH4_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a1e:	f44f 7351 	mov.w	r3, #836	; 0x344
    6a22:	6013      	str	r3, [r2, #0]
		break;
    6a24:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH1_PIN
	  case FTM2_CH1_PIN: // PTB19, FTM1_CH1
		FTM2_C1V = cval;
    6a26:	4951      	ldr	r1, [pc, #324]	; (6b6c <analogWrite+0x2b0>)
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a28:	4a51      	ldr	r2, [pc, #324]	; (6b70 <analogWrite+0x2b4>)
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH1_PIN
	  case FTM2_CH1_PIN: // PTB19, FTM1_CH1
		FTM2_C1V = cval;
    6a2a:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a2c:	f44f 7351 	mov.w	r3, #836	; 0x344
    6a30:	6013      	str	r3, [r2, #0]
		break;
    6a32:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH0_PIN
	  case FTM2_CH0_PIN: // PTB18, FTM2_CH0
		FTM2_C0V = cval;
    6a34:	494f      	ldr	r1, [pc, #316]	; (6b74 <analogWrite+0x2b8>)
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a36:	4a50      	ldr	r2, [pc, #320]	; (6b78 <analogWrite+0x2bc>)
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH0_PIN
	  case FTM2_CH0_PIN: // PTB18, FTM2_CH0
		FTM2_C0V = cval;
    6a38:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a3a:	f44f 7351 	mov.w	r3, #836	; 0x344
    6a3e:	6013      	str	r3, [r2, #0]
		break;
    6a40:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH1_PIN
	  case FTM0_CH1_PIN: // PTC2, FTM0_CH1
		FTM0_C1V = cval;
    6a42:	494e      	ldr	r1, [pc, #312]	; (6b7c <analogWrite+0x2c0>)
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a44:	4a4e      	ldr	r2, [pc, #312]	; (6b80 <analogWrite+0x2c4>)
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH1_PIN
	  case FTM0_CH1_PIN: // PTC2, FTM0_CH1
		FTM0_C1V = cval;
    6a46:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a48:	f240 4344 	movw	r3, #1092	; 0x444
    6a4c:	6013      	str	r3, [r2, #0]
		break;
    6a4e:	bd38      	pop	{r3, r4, r5, pc}
	//serial_phex32(cval);
	//serial_print("\n");
	switch (pin) {
#ifdef FTM0_CH0_PIN
	  case FTM0_CH0_PIN: // PTC1, FTM0_CH0
		FTM0_C0V = cval;
    6a50:	494c      	ldr	r1, [pc, #304]	; (6b84 <analogWrite+0x2c8>)
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a52:	4a4d      	ldr	r2, [pc, #308]	; (6b88 <analogWrite+0x2cc>)
	//serial_phex32(cval);
	//serial_print("\n");
	switch (pin) {
#ifdef FTM0_CH0_PIN
	  case FTM0_CH0_PIN: // PTC1, FTM0_CH0
		FTM0_C0V = cval;
    6a54:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a56:	f240 4344 	movw	r3, #1092	; 0x444
    6a5a:	6013      	str	r3, [r2, #0]
		break;
    6a5c:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH6_PIN
	  case FTM0_CH6_PIN: // PTD6, FTM0_CH6
		FTM0_C6V = cval;
    6a5e:	494b      	ldr	r1, [pc, #300]	; (6b8c <analogWrite+0x2d0>)
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a60:	4a4b      	ldr	r2, [pc, #300]	; (6b90 <analogWrite+0x2d4>)
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH6_PIN
	  case FTM0_CH6_PIN: // PTD6, FTM0_CH6
		FTM0_C6V = cval;
    6a62:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a64:	f240 4344 	movw	r3, #1092	; 0x444
    6a68:	6013      	str	r3, [r2, #0]
		break;
    6a6a:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH5_PIN
	  case FTM0_CH5_PIN: // PTD5, FTM0_CH5
		FTM0_C5V = cval;
    6a6c:	4949      	ldr	r1, [pc, #292]	; (6b94 <analogWrite+0x2d8>)
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a6e:	4a4a      	ldr	r2, [pc, #296]	; (6b98 <analogWrite+0x2dc>)
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH5_PIN
	  case FTM0_CH5_PIN: // PTD5, FTM0_CH5
		FTM0_C5V = cval;
    6a70:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a72:	f240 4344 	movw	r3, #1092	; 0x444
    6a76:	6013      	str	r3, [r2, #0]
		break;
    6a78:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(TPM1_CH0_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef TPM1_CH1_PIN
	  case TPM1_CH1_PIN:
		TPM1_C1V = cval;
    6a7a:	4948      	ldr	r1, [pc, #288]	; (6b9c <analogWrite+0x2e0>)
		FTM_PINCFG(TPM1_CH1_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a7c:	4a48      	ldr	r2, [pc, #288]	; (6ba0 <analogWrite+0x2e4>)
		FTM_PINCFG(TPM1_CH0_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef TPM1_CH1_PIN
	  case TPM1_CH1_PIN:
		TPM1_C1V = cval;
    6a7e:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(TPM1_CH1_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a80:	f240 6344 	movw	r3, #1604	; 0x644
    6a84:	6013      	str	r3, [r2, #0]
		break;
    6a86:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH7_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef TPM1_CH0_PIN
	  case TPM1_CH0_PIN:
		TPM1_C0V = cval;
    6a88:	4946      	ldr	r1, [pc, #280]	; (6ba4 <analogWrite+0x2e8>)
		FTM_PINCFG(TPM1_CH0_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a8a:	4a47      	ldr	r2, [pc, #284]	; (6ba8 <analogWrite+0x2ec>)
		FTM_PINCFG(FTM3_CH7_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef TPM1_CH0_PIN
	  case TPM1_CH0_PIN:
		TPM1_C0V = cval;
    6a8c:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(TPM1_CH0_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a8e:	f240 6344 	movw	r3, #1604	; 0x644
    6a92:	6013      	str	r3, [r2, #0]
		break;
    6a94:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH1_PIN
	  case FTM3_CH1_PIN:
		FTM3_C1V = cval;
    6a96:	4945      	ldr	r1, [pc, #276]	; (6bac <analogWrite+0x2f0>)
		FTM_PINCFG(FTM3_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a98:	4a45      	ldr	r2, [pc, #276]	; (6bb0 <analogWrite+0x2f4>)
		FTM_PINCFG(FTM3_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH1_PIN
	  case FTM3_CH1_PIN:
		FTM3_C1V = cval;
    6a9a:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6a9c:	f240 4344 	movw	r3, #1092	; 0x444
    6aa0:	6013      	str	r3, [r2, #0]
		break;
    6aa2:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH3_PIN
	  case FTM0_CH3_PIN: // PTC4, FTM0_CH3
		FTM0_C3V = cval;
    6aa4:	4943      	ldr	r1, [pc, #268]	; (6bb4 <analogWrite+0x2f8>)
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6aa6:	4a44      	ldr	r2, [pc, #272]	; (6bb8 <analogWrite+0x2fc>)
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH3_PIN
	  case FTM0_CH3_PIN: // PTC4, FTM0_CH3
		FTM0_C3V = cval;
    6aa8:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6aaa:	f240 4344 	movw	r3, #1092	; 0x444
    6aae:	6013      	str	r3, [r2, #0]
		break;
    6ab0:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH2_PIN
	  case FTM0_CH2_PIN: // PTC3, FTM0_CH2
		FTM0_C2V = cval;
    6ab2:	4942      	ldr	r1, [pc, #264]	; (6bbc <analogWrite+0x300>)
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6ab4:	4a42      	ldr	r2, [pc, #264]	; (6bc0 <analogWrite+0x304>)
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH2_PIN
	  case FTM0_CH2_PIN: // PTC3, FTM0_CH2
		FTM0_C2V = cval;
    6ab6:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6ab8:	f240 4344 	movw	r3, #1092	; 0x444
    6abc:	6013      	str	r3, [r2, #0]
		break;
    6abe:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH3_PIN
	  case FTM3_CH3_PIN:
		FTM3_C3V = cval;
    6ac0:	4940      	ldr	r1, [pc, #256]	; (6bc4 <analogWrite+0x308>)
		FTM_PINCFG(FTM3_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6ac2:	4a41      	ldr	r2, [pc, #260]	; (6bc8 <analogWrite+0x30c>)
		FTM_PINCFG(FTM3_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH3_PIN
	  case FTM3_CH3_PIN:
		FTM3_C3V = cval;
    6ac4:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6ac6:	f240 4344 	movw	r3, #1092	; 0x444
    6aca:	6013      	str	r3, [r2, #0]
		break;
    6acc:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH2_PIN
	  case FTM3_CH2_PIN:
		FTM3_C2V = cval;
    6ace:	493f      	ldr	r1, [pc, #252]	; (6bcc <analogWrite+0x310>)
		FTM_PINCFG(FTM3_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6ad0:	4a3f      	ldr	r2, [pc, #252]	; (6bd0 <analogWrite+0x314>)
		FTM_PINCFG(FTM3_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH2_PIN
	  case FTM3_CH2_PIN:
		FTM3_C2V = cval;
    6ad2:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6ad4:	f240 4344 	movw	r3, #1092	; 0x444
    6ad8:	6013      	str	r3, [r2, #0]
		break;
    6ada:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH4_PIN
	  case FTM0_CH4_PIN: // PTD4, FTM0_CH4
		FTM0_C4V = cval;
    6adc:	493d      	ldr	r1, [pc, #244]	; (6bd4 <analogWrite+0x318>)
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6ade:	4a3e      	ldr	r2, [pc, #248]	; (6bd8 <analogWrite+0x31c>)
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH4_PIN
	  case FTM0_CH4_PIN: // PTD4, FTM0_CH4
		FTM0_C4V = cval;
    6ae0:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6ae2:	f240 4344 	movw	r3, #1092	; 0x444
    6ae6:	6013      	str	r3, [r2, #0]
		break;
    6ae8:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH7_PIN
	  case FTM0_CH7_PIN: // PTD7, FTM0_CH7
		FTM0_C7V = cval;
    6aea:	493c      	ldr	r1, [pc, #240]	; (6bdc <analogWrite+0x320>)
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6aec:	4a3c      	ldr	r2, [pc, #240]	; (6be0 <analogWrite+0x324>)
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH7_PIN
	  case FTM0_CH7_PIN: // PTD7, FTM0_CH7
		FTM0_C7V = cval;
    6aee:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6af0:	f240 4344 	movw	r3, #1092	; 0x444
    6af4:	6013      	str	r3, [r2, #0]
		break;
    6af6:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH1_PIN
	  case FTM1_CH1_PIN: // PTA13, FTM1_CH1
		FTM1_C1V = cval;
    6af8:	493a      	ldr	r1, [pc, #232]	; (6be4 <analogWrite+0x328>)
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6afa:	4a3b      	ldr	r2, [pc, #236]	; (6be8 <analogWrite+0x32c>)
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH1_PIN
	  case FTM1_CH1_PIN: // PTA13, FTM1_CH1
		FTM1_C1V = cval;
    6afc:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6afe:	f44f 7351 	mov.w	r3, #836	; 0x344
    6b02:	6013      	str	r3, [r2, #0]
		break;
    6b04:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH0_PIN
	  case FTM1_CH0_PIN: // PTA12, FTM1_CH0
		FTM1_C0V = cval;
    6b06:	4939      	ldr	r1, [pc, #228]	; (6bec <analogWrite+0x330>)
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6b08:	4a39      	ldr	r2, [pc, #228]	; (6bf0 <analogWrite+0x334>)
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH0_PIN
	  case FTM1_CH0_PIN: // PTA12, FTM1_CH0
		FTM1_C0V = cval;
    6b0a:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    6b0c:	f44f 7351 	mov.w	r3, #836	; 0x344
    6b10:	6013      	str	r3, [r2, #0]
		break;
    6b12:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH0_PIN
	  case FTM3_CH0_PIN:
		FTM3_C0V = cval;
    6b14:	4937      	ldr	r1, [pc, #220]	; (6bf4 <analogWrite+0x338>)
		FTM_PINCFG(FTM3_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6b16:	4a38      	ldr	r2, [pc, #224]	; (6bf8 <analogWrite+0x33c>)
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH0_PIN
	  case FTM3_CH0_PIN:
		FTM3_C0V = cval;
    6b18:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    6b1a:	f240 4344 	movw	r3, #1092	; 0x444
    6b1e:	6013      	str	r3, [r2, #0]
		break;
    6b20:	bd38      	pop	{r3, r4, r5, pc}

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    6b22:	2c3f      	cmp	r4, #63	; 0x3f
    6b24:	f63f aedb 	bhi.w	68de <analogWrite+0x22>
    6b28:	297f      	cmp	r1, #127	; 0x7f
    6b2a:	bfd4      	ite	le
    6b2c:	2100      	movle	r1, #0
    6b2e:	2101      	movgt	r1, #1
    6b30:	4620      	mov	r0, r4
    6b32:	e749      	b.n	69c8 <analogWrite+0x10c>
    6b34:	1fff0b18 	.word	0x1fff0b18
    6b38:	400c9008 	.word	0x400c9008
    6b3c:	40038008 	.word	0x40038008
    6b40:	40039008 	.word	0x40039008
    6b44:	400b9008 	.word	0x400b9008
    6b48:	400b8008 	.word	0x400b8008
    6b4c:	400b9048 	.word	0x400b9048
    6b50:	4004b02c 	.word	0x4004b02c
    6b54:	400b9040 	.word	0x400b9040
    6b58:	4004b028 	.word	0x4004b028
    6b5c:	400b9038 	.word	0x400b9038
    6b60:	4004b024 	.word	0x4004b024
    6b64:	400b9030 	.word	0x400b9030
    6b68:	4004b020 	.word	0x4004b020
    6b6c:	400b8018 	.word	0x400b8018
    6b70:	4004a04c 	.word	0x4004a04c
    6b74:	400b8010 	.word	0x400b8010
    6b78:	4004a048 	.word	0x4004a048
    6b7c:	40038018 	.word	0x40038018
    6b80:	4004b008 	.word	0x4004b008
    6b84:	40038010 	.word	0x40038010
    6b88:	4004b004 	.word	0x4004b004
    6b8c:	40038040 	.word	0x40038040
    6b90:	4004c018 	.word	0x4004c018
    6b94:	40038038 	.word	0x40038038
    6b98:	4004c014 	.word	0x4004c014
    6b9c:	400c9018 	.word	0x400c9018
    6ba0:	4004a004 	.word	0x4004a004
    6ba4:	400c9010 	.word	0x400c9010
    6ba8:	4004a000 	.word	0x4004a000
    6bac:	400b9018 	.word	0x400b9018
    6bb0:	4004c004 	.word	0x4004c004
    6bb4:	40038028 	.word	0x40038028
    6bb8:	4004b010 	.word	0x4004b010
    6bbc:	40038020 	.word	0x40038020
    6bc0:	4004b00c 	.word	0x4004b00c
    6bc4:	400b9028 	.word	0x400b9028
    6bc8:	4004c00c 	.word	0x4004c00c
    6bcc:	400b9020 	.word	0x400b9020
    6bd0:	4004c008 	.word	0x4004c008
    6bd4:	40038030 	.word	0x40038030
    6bd8:	4004c010 	.word	0x4004c010
    6bdc:	40038048 	.word	0x40038048
    6be0:	4004c01c 	.word	0x4004c01c
    6be4:	40039018 	.word	0x40039018
    6be8:	40049034 	.word	0x40049034
    6bec:	40039010 	.word	0x40039010
    6bf0:	40049030 	.word	0x40049030
    6bf4:	400b9010 	.word	0x400b9010
    6bf8:	4004c000 	.word	0x4004c000

00006bfc <digitalWrite>:
    6bfc:	283f      	cmp	r0, #63	; 0x3f
    6bfe:	d801      	bhi.n	6c04 <digitalWrite+0x8>
    6c00:	f7ff bd6c 	b.w	66dc <digitalWrite.part.1>
    6c04:	4770      	bx	lr
    6c06:	bf00      	nop

00006c08 <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    6c08:	283f      	cmp	r0, #63	; 0x3f
    6c0a:	d801      	bhi.n	6c10 <pinMode+0x8>
    6c0c:	f7ff bd8c 	b.w	6728 <pinMode.part.2>
    6c10:	4770      	bx	lr
    6c12:	bf00      	nop

00006c14 <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    6c14:	b672      	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    6c16:	490d      	ldr	r1, [pc, #52]	; (6c4c <micros+0x38>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    6c18:	4b0d      	ldr	r3, [pc, #52]	; (6c50 <micros+0x3c>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    6c1a:	4a0e      	ldr	r2, [pc, #56]	; (6c54 <micros+0x40>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    6c1c:	681b      	ldr	r3, [r3, #0]
	count = systick_millis_count;
    6c1e:	6808      	ldr	r0, [r1, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    6c20:	6812      	ldr	r2, [r2, #0]
	__enable_irq();
    6c22:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    6c24:	0152      	lsls	r2, r2, #5
    6c26:	d502      	bpl.n	6c2e <micros+0x1a>
    6c28:	2b32      	cmp	r3, #50	; 0x32
    6c2a:	bf88      	it	hi
    6c2c:	3001      	addhi	r0, #1
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    6c2e:	f5c3 332f 	rsb	r3, r3, #179200	; 0x2bc00
    6c32:	4909      	ldr	r1, [pc, #36]	; (6c58 <micros+0x44>)
    6c34:	f203 331f 	addw	r3, r3, #799	; 0x31f
    6c38:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    6c3c:	089b      	lsrs	r3, r3, #2
    6c3e:	fba1 1303 	umull	r1, r3, r1, r3
    6c42:	fb02 f000 	mul.w	r0, r2, r0
}
    6c46:	eb00 0093 	add.w	r0, r0, r3, lsr #2
    6c4a:	4770      	bx	lr
    6c4c:	1fff2c04 	.word	0x1fff2c04
    6c50:	e000e018 	.word	0xe000e018
    6c54:	e000ed04 	.word	0xe000ed04
    6c58:	16c16c17 	.word	0x16c16c17

00006c5c <delay>:

void delay(uint32_t ms)
{
    6c5c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    6c60:	4605      	mov	r5, r0

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    6c62:	b672      	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    6c64:	4f22      	ldr	r7, [pc, #136]	; (6cf0 <delay+0x94>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    6c66:	4b23      	ldr	r3, [pc, #140]	; (6cf4 <delay+0x98>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    6c68:	4a23      	ldr	r2, [pc, #140]	; (6cf8 <delay+0x9c>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    6c6a:	681b      	ldr	r3, [r3, #0]
	count = systick_millis_count;
    6c6c:	683c      	ldr	r4, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    6c6e:	6812      	ldr	r2, [r2, #0]
	__enable_irq();
    6c70:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    6c72:	0152      	lsls	r2, r2, #5
    6c74:	d502      	bpl.n	6c7c <delay+0x20>
    6c76:	2b32      	cmp	r3, #50	; 0x32
    6c78:	bf88      	it	hi
    6c7a:	3401      	addhi	r4, #1

void delay(uint32_t ms)
{
	uint32_t start = micros();

	if (ms > 0) {
    6c7c:	b3b5      	cbz	r5, 6cec <delay+0x90>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    6c7e:	f5c3 332f 	rsb	r3, r3, #179200	; 0x2bc00
    6c82:	f203 331f 	addw	r3, r3, #799	; 0x31f
    6c86:	4e1d      	ldr	r6, [pc, #116]	; (6cfc <delay+0xa0>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    6c88:	f8df 9068 	ldr.w	r9, [pc, #104]	; 6cf4 <delay+0x98>
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    6c8c:	f8df 8068 	ldr.w	r8, [pc, #104]	; 6cf8 <delay+0x9c>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    6c90:	089b      	lsrs	r3, r3, #2
    6c92:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    6c96:	fba6 1303 	umull	r1, r3, r6, r3
    6c9a:	fb02 f404 	mul.w	r4, r2, r4
    6c9e:	eb04 0493 	add.w	r4, r4, r3, lsr #2

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    6ca2:	b672      	cpsid	i
	current = SYST_CVR;
    6ca4:	f8d9 1000 	ldr.w	r1, [r9]
	count = systick_millis_count;
    6ca8:	683a      	ldr	r2, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    6caa:	f8d8 e000 	ldr.w	lr, [r8]
	__enable_irq();
    6cae:	b662      	cpsie	i
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    6cb0:	f5c1 332f 	rsb	r3, r1, #179200	; 0x2bc00
    6cb4:	f203 331f 	addw	r3, r3, #799	; 0x31f
    6cb8:	089b      	lsrs	r3, r3, #2
    6cba:	fba6 0303 	umull	r0, r3, r6, r3
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    6cbe:	f01e 6f80 	tst.w	lr, #67108864	; 0x4000000
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    6cc2:	ebc4 0393 	rsb	r3, r4, r3, lsr #2
    6cc6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    6cca:	d002      	beq.n	6cd2 <delay+0x76>
    6ccc:	2932      	cmp	r1, #50	; 0x32
    6cce:	bf88      	it	hi
    6cd0:	3201      	addhi	r2, #1
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    6cd2:	fb00 3302 	mla	r3, r0, r2, r3
    6cd6:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    6cda:	d304      	bcc.n	6ce6 <delay+0x8a>
				ms--;
				if (ms == 0) return;
    6cdc:	3d01      	subs	r5, #1
    6cde:	d005      	beq.n	6cec <delay+0x90>
				start += 1000;
    6ce0:	f504 747a 	add.w	r4, r4, #1000	; 0x3e8
    6ce4:	e7dd      	b.n	6ca2 <delay+0x46>
			}
			yield();
    6ce6:	f001 f875 	bl	7dd4 <yield>
		}
    6cea:	e7da      	b.n	6ca2 <delay+0x46>
    6cec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    6cf0:	1fff2c04 	.word	0x1fff2c04
    6cf4:	e000e018 	.word	0xe000e018
    6cf8:	e000ed04 	.word	0xe000ed04
    6cfc:	16c16c17 	.word	0x16c16c17

00006d00 <_init_Teensyduino_internal_>:
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
    6d00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    6d02:	4b4e      	ldr	r3, [pc, #312]	; (6e3c <_init_Teensyduino_internal_+0x13c>)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    6d04:	484e      	ldr	r0, [pc, #312]	; (6e40 <_init_Teensyduino_internal_+0x140>)
	FTM0_MOD = DEFAULT_FTM_MOD;
    6d06:	f8df c15c 	ldr.w	ip, [pc, #348]	; 6e64 <_init_Teensyduino_internal_+0x164>
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
    6d0a:	4c4e      	ldr	r4, [pc, #312]	; (6e44 <_init_Teensyduino_internal_+0x144>)
	FTM0_C2SC = 0x28;
    6d0c:	494e      	ldr	r1, [pc, #312]	; (6e48 <_init_Teensyduino_internal_+0x148>)
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    6d0e:	f8df e158 	ldr.w	lr, [pc, #344]	; 6e68 <_init_Teensyduino_internal_+0x168>
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
    6d12:	4e4e      	ldr	r6, [pc, #312]	; (6e4c <_init_Teensyduino_internal_+0x14c>)
	FTM0_C4SC = 0x28;
    6d14:	4d4e      	ldr	r5, [pc, #312]	; (6e50 <_init_Teensyduino_internal_+0x150>)
	FTM0_C5SC = 0x28;
    6d16:	4f4f      	ldr	r7, [pc, #316]	; (6e54 <_init_Teensyduino_internal_+0x154>)
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    6d18:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    6d1c:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    6d1e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    6d22:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    6d24:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
    6d28:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    6d2a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    6d2e:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    6d30:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    6d34:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    6d36:	2200      	movs	r2, #0
    6d38:	6002      	str	r2, [r0, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    6d3a:	2328      	movs	r3, #40	; 0x28
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
    6d3c:	f64e 70ff 	movw	r0, #61439	; 0xefff
    6d40:	f8cc 0000 	str.w	r0, [ip]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    6d44:	f8ce 3000 	str.w	r3, [lr]
	FTM0_C1SC = 0x28;
    6d48:	6023      	str	r3, [r4, #0]
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    6d4a:	f50e 2e01 	add.w	lr, lr, #528384	; 0x81000
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
    6d4e:	600b      	str	r3, [r1, #0]
	FTM0_C3SC = 0x28;
    6d50:	6033      	str	r3, [r6, #0]
	FTM0_C4SC = 0x28;
    6d52:	602b      	str	r3, [r5, #0]
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    6d54:	f506 2600 	add.w	r6, r6, #524288	; 0x80000
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
    6d58:	603b      	str	r3, [r7, #0]
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
    6d5a:	f505 2500 	add.w	r5, r5, #524288	; 0x80000
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
    6d5e:	62a3      	str	r3, [r4, #40]	; 0x28
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
    6d60:	f507 2700 	add.w	r7, r7, #524288	; 0x80000
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
    6d64:	628b      	str	r3, [r1, #40]	; 0x28
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
    6d66:	f504 2401 	add.w	r4, r4, #528384	; 0x81000
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
    6d6a:	f501 2101 	add.w	r1, r1, #528384	; 0x81000
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    6d6e:	f606 76e8 	addw	r6, r6, #4072	; 0xfe8
	FTM3_C1SC = 0x28;
    6d72:	f605 75e8 	addw	r5, r5, #4072	; 0xfe8
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
    6d76:	f507 677f 	add.w	r7, r7, #4080	; 0xff0
	FTM3_C4SC = 0x28;
    6d7a:	3110      	adds	r1, #16
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    6d7c:	f10e 0e10 	add.w	lr, lr, #16
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
    6d80:	3420      	adds	r4, #32
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    6d82:	6033      	str	r3, [r6, #0]
	FTM3_C1SC = 0x28;
    6d84:	602b      	str	r3, [r5, #0]
	FTM3_C2SC = 0x28;
    6d86:	f8ce 3000 	str.w	r3, [lr]
	FTM3_C3SC = 0x28;
    6d8a:	603b      	str	r3, [r7, #0]
	FTM3_C4SC = 0x28;
    6d8c:	600b      	str	r3, [r1, #0]
	FTM3_C5SC = 0x28;
    6d8e:	6023      	str	r3, [r4, #0]
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    6d90:	4c31      	ldr	r4, [pc, #196]	; (6e58 <_init_Teensyduino_internal_+0x158>)
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
    6d92:	61bb      	str	r3, [r7, #24]
	FTM3_C7SC = 0x28;
    6d94:	618b      	str	r3, [r1, #24]
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    6d96:	2109      	movs	r1, #9
    6d98:	6021      	str	r1, [r4, #0]
	FTM1_CNT = 0;
    6d9a:	f5a7 2700 	sub.w	r7, r7, #524288	; 0x80000
	FTM1_MOD = DEFAULT_FTM_MOD;
    6d9e:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
    6da2:	3f20      	subs	r7, #32
	FTM1_MOD = DEFAULT_FTM_MOD;
    6da4:	3408      	adds	r4, #8
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
    6da6:	603a      	str	r2, [r7, #0]
	FTM1_MOD = DEFAULT_FTM_MOD;
    6da8:	6020      	str	r0, [r4, #0]
	FTM1_C0SC = 0x28;
    6daa:	60bb      	str	r3, [r7, #8]
	FTM1_C1SC = 0x28;
    6dac:	60e3      	str	r3, [r4, #12]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    6dae:	f847 1c04 	str.w	r1, [r7, #-4]
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    6db2:	f504 24fd 	add.w	r4, r4, #518144	; 0x7e800
	FTM2_MOD = DEFAULT_FTM_MOD;
    6db6:	f507 27fe 	add.w	r7, r7, #520192	; 0x7f000
    6dba:	3704      	adds	r7, #4
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    6dbc:	f204 74fc 	addw	r4, r4, #2044	; 0x7fc
    6dc0:	6022      	str	r2, [r4, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
    6dc2:	6038      	str	r0, [r7, #0]
	FTM2_C0SC = 0x28;
    6dc4:	60a3      	str	r3, [r4, #8]
	FTM2_C1SC = 0x28;
    6dc6:	60fb      	str	r3, [r7, #12]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    6dc8:	f844 1c04 	str.w	r1, [r4, #-4]
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
	FTM2_MOD = DEFAULT_FTM_MOD;
	FTM2_C0SC = 0x28;
    6dcc:	3408      	adds	r4, #8
	FTM2_C1SC = 0x28;
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
    6dce:	f604 74fc 	addw	r4, r4, #4092	; 0xffc
	FTM2_C0SC = 0x28;
	FTM2_C1SC = 0x28;
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
    6dd2:	f8c7 2ffc 	str.w	r2, [r7, #4092]	; 0xffc
	FTM3_MOD = DEFAULT_FTM_MOD;
    6dd6:	6020      	str	r0, [r4, #0]
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    6dd8:	f5a4 24e1 	sub.w	r4, r4, #460800	; 0x70800
    6ddc:	f2a4 74dc 	subw	r4, r4, #2012	; 0x7dc
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
	FTM3_C0SC = 0x28;
    6de0:	6033      	str	r3, [r6, #0]
	FTM3_C1SC = 0x28;
    6de2:	602b      	str	r3, [r5, #0]
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    6de4:	f8c7 1ff8 	str.w	r1, [r7, #4088]	; 0xff8
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    6de8:	6821      	ldr	r1, [r4, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    6dea:	481c      	ldr	r0, [pc, #112]	; (6e5c <_init_Teensyduino_internal_+0x15c>)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    6dec:	f441 7100 	orr.w	r1, r1, #512	; 0x200
    6df0:	6021      	str	r1, [r4, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    6df2:	6801      	ldr	r1, [r0, #0]
	TPM1_CNT = 0;
	TPM1_MOD = 32767;
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    6df4:	4c1a      	ldr	r4, [pc, #104]	; (6e60 <_init_Teensyduino_internal_+0x160>)
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
	TPM1_CNT = 0;
    6df6:	f50e 4e7f 	add.w	lr, lr, #65280	; 0xff00
    6dfa:	f10e 0ee8 	add.w	lr, lr, #232	; 0xe8
	TPM1_MOD = 32767;
    6dfe:	f507 3788 	add.w	r7, r7, #69632	; 0x11000
	TPM1_C0SC = 0x28;
    6e02:	f506 3680 	add.w	r6, r6, #65536	; 0x10000
	TPM1_C1SC = 0x28;
    6e06:	f505 3580 	add.w	r5, r5, #65536	; 0x10000
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    6e0a:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
    6e0e:	6001      	str	r1, [r0, #0]
	TPM1_CNT = 0;
    6e10:	f8ce 2000 	str.w	r2, [lr]
	TPM1_MOD = 32767;
    6e14:	f647 71ff 	movw	r1, #32767	; 0x7fff
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    6e18:	2208      	movs	r2, #8
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
	TPM1_CNT = 0;
	TPM1_MOD = 32767;
    6e1a:	6039      	str	r1, [r7, #0]
	TPM1_C0SC = 0x28;
    6e1c:	6033      	str	r3, [r6, #0]
	TPM1_C1SC = 0x28;
    6e1e:	602b      	str	r3, [r5, #0]
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    6e20:	6022      	str	r2, [r4, #0]
#endif
	analog_init();
    6e22:	f001 f84d 	bl	7ec0 <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
    6e26:	2019      	movs	r0, #25
    6e28:	f7ff ff18 	bl	6c5c <delay>
	usb_init();
    6e2c:	f000 fd10 	bl	7850 <usb_init>
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    6e30:	f240 1013 	movw	r0, #275	; 0x113
}
    6e34:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
	usb_init();
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    6e38:	f7ff bf10 	b.w	6c5c <delay>
    6e3c:	e000e104 	.word	0xe000e104
    6e40:	40038004 	.word	0x40038004
    6e44:	40038014 	.word	0x40038014
    6e48:	4003801c 	.word	0x4003801c
    6e4c:	40038024 	.word	0x40038024
    6e50:	4003802c 	.word	0x4003802c
    6e54:	40038034 	.word	0x40038034
    6e58:	40038000 	.word	0x40038000
    6e5c:	40048004 	.word	0x40048004
    6e60:	400c9000 	.word	0x400c9000
    6e64:	40038008 	.word	0x40038008
    6e68:	4003800c 	.word	0x4003800c

00006e6c <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    6e6c:	1e43      	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    6e6e:	2b03      	cmp	r3, #3
    6e70:	d814      	bhi.n	6e9c <usb_rx+0x30>
	__disable_irq();
    6e72:	b672      	cpsid	i
	ret = rx_first[endpoint];
    6e74:	490a      	ldr	r1, [pc, #40]	; (6ea0 <usb_rx+0x34>)
    6e76:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
	if (ret) {
    6e7a:	b168      	cbz	r0, 6e98 <usb_rx+0x2c>




usb_packet_t *usb_rx(uint32_t endpoint)
{
    6e7c:	b470      	push	{r4, r5, r6}
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
    6e7e:	4c09      	ldr	r4, [pc, #36]	; (6ea4 <usb_rx+0x38>)
    6e80:	8805      	ldrh	r5, [r0, #0]
    6e82:	f834 2013 	ldrh.w	r2, [r4, r3, lsl #1]
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
    6e86:	6846      	ldr	r6, [r0, #4]
    6e88:	f841 6023 	str.w	r6, [r1, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    6e8c:	1b52      	subs	r2, r2, r5
    6e8e:	f824 2013 	strh.w	r2, [r4, r3, lsl #1]
	}
	__enable_irq();
    6e92:	b662      	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    6e94:	bc70      	pop	{r4, r5, r6}
    6e96:	4770      	bx	lr
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
	}
	__enable_irq();
    6e98:	b662      	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    6e9a:	4770      	bx	lr

usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    6e9c:	2000      	movs	r0, #0
    6e9e:	4770      	bx	lr
    6ea0:	1fff2c60 	.word	0x1fff2c60
    6ea4:	1fff2d68 	.word	0x1fff2d68

00006ea8 <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    6ea8:	3801      	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    6eaa:	2803      	cmp	r0, #3
    6eac:	d80b      	bhi.n	6ec6 <usb_tx_packet_count+0x1e>
	__disable_irq();
    6eae:	b672      	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    6eb0:	4b07      	ldr	r3, [pc, #28]	; (6ed0 <usb_tx_packet_count+0x28>)
    6eb2:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6eb6:	b143      	cbz	r3, 6eca <usb_tx_packet_count+0x22>
    6eb8:	2000      	movs	r0, #0
    6eba:	685b      	ldr	r3, [r3, #4]
    6ebc:	3001      	adds	r0, #1
    6ebe:	2b00      	cmp	r3, #0
    6ec0:	d1fb      	bne.n	6eba <usb_tx_packet_count+0x12>
	__enable_irq();
    6ec2:	b662      	cpsie	i
	return count;
    6ec4:	4770      	bx	lr
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
    6ec6:	2000      	movs	r0, #0
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
	__enable_irq();
	return count;
}
    6ec8:	4770      	bx	lr
// https://forum.pjrc.com/threads/58663?p=223513&viewfull=1#post223513
//
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;
    6eca:	4618      	mov	r0, r3
    6ecc:	e7f9      	b.n	6ec2 <usb_tx_packet_count+0x1a>
    6ece:	bf00      	nop
    6ed0:	1fff2cb4 	.word	0x1fff2cb4

00006ed4 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    6ed4:	b4f0      	push	{r4, r5, r6, r7}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    6ed6:	b672      	cpsid	i
void usb_rx_memory(usb_packet_t *packet)
{
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
    6ed8:	491a      	ldr	r1, [pc, #104]	; (6f44 <usb_rx_memory+0x70>)
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
    6eda:	4e1b      	ldr	r6, [pc, #108]	; (6f48 <usb_rx_memory+0x74>)
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    6edc:	2301      	movs	r3, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    6ede:	f811 4b01 	ldrb.w	r4, [r1], #1
			if (table[index(i, RX, EVEN)].desc == 0) {
    6ee2:	4f19      	ldr	r7, [pc, #100]	; (6f48 <usb_rx_memory+0x74>)
    6ee4:	009a      	lsls	r2, r3, #2
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    6ee6:	0724      	lsls	r4, r4, #28
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    6ee8:	f042 0501 	orr.w	r5, r2, #1
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    6eec:	d505      	bpl.n	6efa <usb_rx_memory+0x26>
			if (table[index(i, RX, EVEN)].desc == 0) {
    6eee:	f856 4032 	ldr.w	r4, [r6, r2, lsl #3]
    6ef2:	b164      	cbz	r4, 6f0e <usb_rx_memory+0x3a>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    6ef4:	f856 2035 	ldr.w	r2, [r6, r5, lsl #3]
    6ef8:	b1ba      	cbz	r2, 6f2a <usb_rx_memory+0x56>
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    6efa:	3301      	adds	r3, #1
    6efc:	2b05      	cmp	r3, #5
    6efe:	d1ee      	bne.n	6ede <usb_rx_memory+0xa>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    6f00:	b662      	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    6f02:	4b12      	ldr	r3, [pc, #72]	; (6f4c <usb_rx_memory+0x78>)
    6f04:	2200      	movs	r2, #0
    6f06:	701a      	strb	r2, [r3, #0]
	usb_free(packet);
	return;
}
    6f08:	bcf0      	pop	{r4, r5, r6, r7}
	__enable_irq();
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
    6f0a:	f000 bd23 	b.w	7954 <usb_free>
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    6f0e:	4c0f      	ldr	r4, [pc, #60]	; (6f4c <usb_rx_memory+0x78>)
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    6f10:	4d0f      	ldr	r5, [pc, #60]	; (6f50 <usb_rx_memory+0x7c>)
				usb_rx_memory_needed--;
    6f12:	7821      	ldrb	r1, [r4, #0]
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    6f14:	eb07 1343 	add.w	r3, r7, r3, lsl #5
    6f18:	3008      	adds	r0, #8
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    6f1a:	3901      	subs	r1, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    6f1c:	6058      	str	r0, [r3, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    6f1e:	7021      	strb	r1, [r4, #0]
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    6f20:	f847 5032 	str.w	r5, [r7, r2, lsl #3]
				usb_rx_memory_needed--;
				__enable_irq();
    6f24:	b662      	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
	return;
}
    6f26:	bcf0      	pop	{r4, r5, r6, r7}
    6f28:	4770      	bx	lr
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    6f2a:	4a08      	ldr	r2, [pc, #32]	; (6f4c <usb_rx_memory+0x78>)
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    6f2c:	4909      	ldr	r1, [pc, #36]	; (6f54 <usb_rx_memory+0x80>)
				usb_rx_memory_needed--;
    6f2e:	7813      	ldrb	r3, [r2, #0]
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    6f30:	eb07 04c5 	add.w	r4, r7, r5, lsl #3
    6f34:	3008      	adds	r0, #8
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    6f36:	3b01      	subs	r3, #1
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    6f38:	6060      	str	r0, [r4, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    6f3a:	7013      	strb	r3, [r2, #0]
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    6f3c:	f847 1035 	str.w	r1, [r7, r5, lsl #3]
				usb_rx_memory_needed--;
				__enable_irq();
    6f40:	b662      	cpsie	i
				//serial_phex(i);
				//serial_print(",odd\n");
				return;
    6f42:	e7f0      	b.n	6f26 <usb_rx_memory+0x52>
    6f44:	0000c3e4 	.word	0x0000c3e4
    6f48:	1fff0000 	.word	0x1fff0000
    6f4c:	1fff2cdd 	.word	0x1fff2cdd
    6f50:	00400088 	.word	0x00400088
    6f54:	004000c8 	.word	0x004000c8

00006f58 <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    6f58:	1e43      	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    6f5a:	2b03      	cmp	r3, #3
    6f5c:	d81d      	bhi.n	6f9a <usb_tx+0x42>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    6f5e:	4a1b      	ldr	r2, [pc, #108]	; (6fcc <usb_tx+0x74>)
    6f60:	0140      	lsls	r0, r0, #5
    6f62:	f040 0010 	orr.w	r0, r0, #16

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
    6f66:	b430      	push	{r4, r5}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    6f68:	4410      	add	r0, r2
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
	__disable_irq();
    6f6a:	b672      	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    6f6c:	4c18      	ldr	r4, [pc, #96]	; (6fd0 <usb_tx+0x78>)
    6f6e:	5ce2      	ldrb	r2, [r4, r3]
    6f70:	2a03      	cmp	r2, #3
    6f72:	d81b      	bhi.n	6fac <usb_tx+0x54>
    6f74:	e8df f002 	tbb	[pc, r2]
    6f78:	17151202 	.word	0x17151202
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    6f7c:	2203      	movs	r2, #3
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    6f7e:	880d      	ldrh	r5, [r1, #0]
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    6f80:	54e2      	strb	r2, [r4, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    6f82:	f010 0f08 	tst.w	r0, #8
    6f86:	bf14      	ite	ne
    6f88:	23c8      	movne	r3, #200	; 0xc8
    6f8a:	2388      	moveq	r3, #136	; 0x88
    6f8c:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    6f90:	3108      	adds	r1, #8
    6f92:	6041      	str	r1, [r0, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    6f94:	6003      	str	r3, [r0, #0]
	__enable_irq();
    6f96:	b662      	cpsie	i
}
    6f98:	bc30      	pop	{r4, r5}
    6f9a:	4770      	bx	lr
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    6f9c:	3008      	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    6f9e:	2202      	movs	r2, #2
		break;
    6fa0:	e7ed      	b.n	6f7e <usb_tx+0x26>
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    6fa2:	2205      	movs	r2, #5
    6fa4:	e7eb      	b.n	6f7e <usb_tx+0x26>
		break;
	  case TX_STATE_ODD_FREE:
		b++;
    6fa6:	3008      	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    6fa8:	2204      	movs	r2, #4
		break;
    6faa:	e7e8      	b.n	6f7e <usb_tx+0x26>
	  default:
		if (tx_first[endpoint] == NULL) {
    6fac:	4a09      	ldr	r2, [pc, #36]	; (6fd4 <usb_tx+0x7c>)
    6fae:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    6fb2:	b138      	cbz	r0, 6fc4 <usb_tx+0x6c>
			tx_first[endpoint] = packet;
		} else {
			tx_last[endpoint]->next = packet;
    6fb4:	4a08      	ldr	r2, [pc, #32]	; (6fd8 <usb_tx+0x80>)
    6fb6:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    6fba:	6041      	str	r1, [r0, #4]
		}
		tx_last[endpoint] = packet;
    6fbc:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		__enable_irq();
    6fc0:	b662      	cpsie	i
		return;
    6fc2:	e7e9      	b.n	6f98 <usb_tx+0x40>
		b++;
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
		break;
	  default:
		if (tx_first[endpoint] == NULL) {
			tx_first[endpoint] = packet;
    6fc4:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    6fc8:	4a03      	ldr	r2, [pc, #12]	; (6fd8 <usb_tx+0x80>)
    6fca:	e7f7      	b.n	6fbc <usb_tx+0x64>
    6fcc:	1fff0000 	.word	0x1fff0000
    6fd0:	1fff2cec 	.word	0x1fff2cec
    6fd4:	1fff2cb4 	.word	0x1fff2cb4
    6fd8:	1fff2cc4 	.word	0x1fff2cc4

00006fdc <usb_isr>:
}



void usb_isr(void)
{
    6fdc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    6fe0:	f8df b314 	ldr.w	fp, [pc, #788]	; 72f8 <usb_isr+0x31c>
		USB0_ISTAT = USB_ISTAT_SOFTOK;
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
		uint8_t endpoint;
		stat = USB0_STAT;
    6fe4:	f8df a314 	ldr.w	sl, [pc, #788]	; 72fc <usb_isr+0x320>
}



void usb_isr(void)
{
    6fe8:	b087      	sub	sp, #28
    6fea:	e044      	b.n	7076 <usb_isr+0x9a>
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    6fec:	4fad      	ldr	r7, [pc, #692]	; (72a4 <usb_isr+0x2c8>)
    6fee:	ea4f 0893 	mov.w	r8, r3, lsr #2
    6ff2:	eb07 09c8 	add.w	r9, r7, r8, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    6ff6:	3e01      	subs	r6, #1
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    6ff8:	f8d9 2004 	ldr.w	r2, [r9, #4]
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    6ffc:	f003 0308 	and.w	r3, r3, #8
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    7000:	b2f6      	uxtb	r6, r6
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    7002:	f1a2 0008 	sub.w	r0, r2, #8
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    7006:	f003 04ff 	and.w	r4, r3, #255	; 0xff
    700a:	2b00      	cmp	r3, #0
    700c:	f040 8103 	bne.w	7216 <usb_isr+0x23a>
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
    7010:	f857 3038 	ldr.w	r3, [r7, r8, lsl #3]
    7014:	0c1b      	lsrs	r3, r3, #16
    7016:	b299      	uxth	r1, r3
    7018:	f822 1c08 	strh.w	r1, [r2, #-8]
				if (packet->len > 0) {
    701c:	2b00      	cmp	r3, #0
    701e:	f000 80f1 	beq.w	7204 <usb_isr+0x228>
					packet->index = 0;
					packet->next = NULL;
					if (rx_first[endpoint] == NULL) {
    7022:	4ba1      	ldr	r3, [pc, #644]	; (72a8 <usb_isr+0x2cc>)
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
				if (packet->len > 0) {
					packet->index = 0;
    7024:	f822 4c06 	strh.w	r4, [r2, #-6]
					packet->next = NULL;
    7028:	f842 4c04 	str.w	r4, [r2, #-4]
					if (rx_first[endpoint] == NULL) {
    702c:	f853 2026 	ldr.w	r2, [r3, r6, lsl #2]
    7030:	2a00      	cmp	r2, #0
    7032:	f000 816c 	beq.w	730e <usb_isr+0x332>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
    7036:	4d9d      	ldr	r5, [pc, #628]	; (72ac <usb_isr+0x2d0>)
    7038:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
    703c:	6058      	str	r0, [r3, #4]
					}
					rx_last[endpoint] = packet;
					usb_rx_byte_count_data[endpoint] += packet->len;
    703e:	4c9c      	ldr	r4, [pc, #624]	; (72b0 <usb_isr+0x2d4>)
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
					}
					rx_last[endpoint] = packet;
    7040:	f845 0026 	str.w	r0, [r5, r6, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    7044:	f834 3016 	ldrh.w	r3, [r4, r6, lsl #1]
    7048:	4419      	add	r1, r3
    704a:	f824 1016 	strh.w	r1, [r4, r6, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
    704e:	f000 fc61 	bl	7914 <usb_malloc>
					if (packet) {
    7052:	2800      	cmp	r0, #0
    7054:	f000 8154 	beq.w	7300 <usb_isr+0x324>
						b->addr = packet->buf;
						b->desc = BDT_DESC(64,
    7058:	4a96      	ldr	r2, [pc, #600]	; (72b4 <usb_isr+0x2d8>)
    705a:	4b97      	ldr	r3, [pc, #604]	; (72b8 <usb_isr+0x2dc>)
    705c:	f019 0f08 	tst.w	r9, #8
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    7060:	f100 0008 	add.w	r0, r0, #8
						b->desc = BDT_DESC(64,
    7064:	bf18      	it	ne
    7066:	4613      	movne	r3, r2
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    7068:	f8c9 0004 	str.w	r0, [r9, #4]
						b->desc = BDT_DESC(64,
    706c:	f847 3038 	str.w	r3, [r7, r8, lsl #3]
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    7070:	2308      	movs	r3, #8
    7072:	f88b 3000 	strb.w	r3, [fp]
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    7076:	f89b 4000 	ldrb.w	r4, [fp]
    707a:	b2e4      	uxtb	r4, r4

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    707c:	0760      	lsls	r0, r4, #29
    707e:	d51b      	bpl.n	70b8 <usb_isr+0xdc>
		if (usb_configuration) {
    7080:	4b8e      	ldr	r3, [pc, #568]	; (72bc <usb_isr+0x2e0>)
    7082:	781b      	ldrb	r3, [r3, #0]
    7084:	b1ab      	cbz	r3, 70b2 <usb_isr+0xd6>
			t = usb_reboot_timer;
    7086:	498e      	ldr	r1, [pc, #568]	; (72c0 <usb_isr+0x2e4>)
    7088:	780a      	ldrb	r2, [r1, #0]
			if (t) {
    708a:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    708e:	b12a      	cbz	r2, 709c <usb_isr+0xc0>
				usb_reboot_timer = --t;
    7090:	3b01      	subs	r3, #1
    7092:	b2db      	uxtb	r3, r3
    7094:	700b      	strb	r3, [r1, #0]
				if (!t) _reboot_Teensyduino_();
    7096:	2b00      	cmp	r3, #0
    7098:	f000 83b5 	beq.w	7806 <usb_isr+0x82a>
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
    709c:	4989      	ldr	r1, [pc, #548]	; (72c4 <usb_isr+0x2e8>)
    709e:	780a      	ldrb	r2, [r1, #0]
			if (t) {
    70a0:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    70a4:	b12a      	cbz	r2, 70b2 <usb_isr+0xd6>
				usb_cdc_transmit_flush_timer = --t;
    70a6:	3b01      	subs	r3, #1
    70a8:	b2db      	uxtb	r3, r3
    70aa:	700b      	strb	r3, [r1, #0]
				if (t == 0) usb_serial_flush_callback();
    70ac:	2b00      	cmp	r3, #0
    70ae:	f000 80f6 	beq.w	729e <usb_isr+0x2c2>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    70b2:	2304      	movs	r3, #4
    70b4:	f88b 3000 	strb.w	r3, [fp]
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    70b8:	f004 0308 	and.w	r3, r4, #8
    70bc:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    70c0:	2b00      	cmp	r3, #0
    70c2:	f000 80d5 	beq.w	7270 <usb_isr+0x294>
		uint8_t endpoint;
		stat = USB0_STAT;
    70c6:	f89a 3000 	ldrb.w	r3, [sl]
    70ca:	b2db      	uxtb	r3, r3
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
    70cc:	091e      	lsrs	r6, r3, #4
    70ce:	d18d      	bne.n	6fec <usb_isr+0x10>
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    70d0:	089c      	lsrs	r4, r3, #2
    70d2:	4f74      	ldr	r7, [pc, #464]	; (72a4 <usb_isr+0x2c8>)
	pid = BDT_PID(b->desc);
    70d4:	f857 2034 	ldr.w	r2, [r7, r4, lsl #3]
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    70d8:	eb07 01c4 	add.w	r1, r7, r4, lsl #3
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    70dc:	f3c2 0283 	ubfx	r2, r2, #2, #4
    70e0:	3a01      	subs	r2, #1
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
	//count = b->desc >> 16;
	buf = b->addr;
    70e2:	6849      	ldr	r1, [r1, #4]
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    70e4:	2a0c      	cmp	r2, #12
    70e6:	d87e      	bhi.n	71e6 <usb_isr+0x20a>
    70e8:	e8df f002 	tbb	[pc, r2]
    70ec:	7d7d8181 	.word	0x7d7d8181
    70f0:	7d7d7d7d 	.word	0x7d7d7d7d
    70f4:	7d7d7d42 	.word	0x7d7d7d42
    70f8:	07          	.byte	0x07
    70f9:	00          	.byte	0x00
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    70fa:	6808      	ldr	r0, [r1, #0]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    70fc:	4b72      	ldr	r3, [pc, #456]	; (72c8 <usb_isr+0x2ec>)
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    70fe:	4d73      	ldr	r5, [pc, #460]	; (72cc <usb_isr+0x2f0>)
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    7100:	9301      	str	r3, [sp, #4]
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    7102:	4b6c      	ldr	r3, [pc, #432]	; (72b4 <usb_isr+0x2d8>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    7104:	684a      	ldr	r2, [r1, #4]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    7106:	4e72      	ldr	r6, [pc, #456]	; (72d0 <usb_isr+0x2f4>)
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    7108:	f847 3034 	str.w	r3, [r7, r4, lsl #3]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    710c:	b281      	uxth	r1, r0
    710e:	f240 6481 	movw	r4, #1665	; 0x681
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    7112:	4b6d      	ldr	r3, [pc, #436]	; (72c8 <usb_isr+0x2ec>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    7114:	606a      	str	r2, [r5, #4]
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    7116:	6028      	str	r0, [r5, #0]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    7118:	2200      	movs	r2, #0
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    711a:	2001      	movs	r0, #1
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    711c:	42a1      	cmp	r1, r4
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    711e:	613a      	str	r2, [r7, #16]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    7120:	601a      	str	r2, [r3, #0]
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
    7122:	61ba      	str	r2, [r7, #24]
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    7124:	7030      	strb	r0, [r6, #0]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    7126:	f200 80f6 	bhi.w	7316 <usb_isr+0x33a>
    712a:	f5b1 6fd0 	cmp.w	r1, #1664	; 0x680
    712e:	f080 82e8 	bcs.w	7702 <usb_isr+0x726>
    7132:	f5b1 7f81 	cmp.w	r1, #258	; 0x102
    7136:	f000 82d3 	beq.w	76e0 <usb_isr+0x704>
    713a:	f200 81d8 	bhi.w	74ee <usb_isr+0x512>
    713e:	2980      	cmp	r1, #128	; 0x80
    7140:	f000 814d 	beq.w	73de <usb_isr+0x402>
    7144:	2982      	cmp	r1, #130	; 0x82
    7146:	f040 8292 	bne.w	766e <usb_isr+0x692>
    714a:	88a9      	ldrh	r1, [r5, #4]
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    714c:	4b61      	ldr	r3, [pc, #388]	; (72d4 <usb_isr+0x2f8>)
    714e:	f001 017f 	and.w	r1, r1, #127	; 0x7f
		datalen = 2;
		data = reply_buffer;
		break;
	  case 0x0082: // GET_STATUS (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS) {
    7152:	2904      	cmp	r1, #4
    7154:	f200 828c 	bhi.w	7670 <usb_isr+0x694>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    7158:	4c5f      	ldr	r4, [pc, #380]	; (72d8 <usb_isr+0x2fc>)
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    715a:	0089      	lsls	r1, r1, #2
    715c:	440b      	add	r3, r1
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    715e:	7022      	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    7160:	7062      	strb	r2, [r4, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    7162:	781a      	ldrb	r2, [r3, #0]
    7164:	0793      	lsls	r3, r2, #30
    7166:	f140 8338 	bpl.w	77da <usb_isr+0x7fe>
    716a:	7020      	strb	r0, [r4, #0]
		data = reply_buffer;
		datalen = 2;
    716c:	2002      	movs	r0, #2
    716e:	e13a      	b.n	73e6 <usb_isr+0x40a>
		//serial_print("PID=IN:");
		//serial_phex(stat);
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
    7170:	4b55      	ldr	r3, [pc, #340]	; (72c8 <usb_isr+0x2ec>)
    7172:	9301      	str	r3, [sp, #4]
    7174:	681a      	ldr	r2, [r3, #0]
		if (data) {
    7176:	b362      	cbz	r2, 71d2 <usb_isr+0x1f6>
			size = ep0_tx_len;
    7178:	4b58      	ldr	r3, [pc, #352]	; (72dc <usb_isr+0x300>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    717a:	4959      	ldr	r1, [pc, #356]	; (72e0 <usb_isr+0x304>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    717c:	4e54      	ldr	r6, [pc, #336]	; (72d0 <usb_isr+0x2f4>)
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
    717e:	8818      	ldrh	r0, [r3, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    7180:	780c      	ldrb	r4, [r1, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    7182:	f896 e000 	ldrb.w	lr, [r6]
    7186:	2840      	cmp	r0, #64	; 0x40
    7188:	4605      	mov	r5, r0
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    718a:	f084 0c01 	eor.w	ip, r4, #1
    718e:	bf28      	it	cs
    7190:	2540      	movcs	r5, #64	; 0x40
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    7192:	f044 0402 	orr.w	r4, r4, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    7196:	f1be 0f00 	cmp.w	lr, #0
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    719a:	f881 c000 	strb.w	ip, [r1]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    719e:	eba0 0005 	sub.w	r0, r0, r5
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    71a2:	eb07 0cc4 	add.w	ip, r7, r4, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    71a6:	bf0c      	ite	eq
    71a8:	2188      	moveq	r1, #136	; 0x88
    71aa:	21c8      	movne	r1, #200	; 0xc8
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    71ac:	b280      	uxth	r0, r0
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    71ae:	f08e 0e01 	eor.w	lr, lr, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    71b2:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    71b6:	f8cc 2004 	str.w	r2, [ip, #4]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    71ba:	8018      	strh	r0, [r3, #0]
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    71bc:	f886 e000 	strb.w	lr, [r6]
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    71c0:	442a      	add	r2, r5
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    71c2:	f847 1034 	str.w	r1, [r7, r4, lsl #3]
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    71c6:	b910      	cbnz	r0, 71ce <usb_isr+0x1f2>
    71c8:	2d40      	cmp	r5, #64	; 0x40
    71ca:	bf18      	it	ne
    71cc:	2200      	movne	r2, #0
    71ce:	9b01      	ldr	r3, [sp, #4]
    71d0:	601a      	str	r2, [r3, #0]
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    71d2:	4b3e      	ldr	r3, [pc, #248]	; (72cc <usb_isr+0x2f0>)
    71d4:	881a      	ldrh	r2, [r3, #0]
    71d6:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
    71da:	d104      	bne.n	71e6 <usb_isr+0x20a>
			setup.bRequest = 0;
    71dc:	2100      	movs	r1, #0
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    71de:	789a      	ldrb	r2, [r3, #2]
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
			setup.bRequest = 0;
    71e0:	7059      	strb	r1, [r3, #1]
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    71e2:	4b40      	ldr	r3, [pc, #256]	; (72e4 <usb_isr+0x308>)
    71e4:	701a      	strb	r2, [r3, #0]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    71e6:	4a40      	ldr	r2, [pc, #256]	; (72e8 <usb_isr+0x30c>)
    71e8:	2301      	movs	r3, #1
    71ea:	7013      	strb	r3, [r2, #0]
    71ec:	e740      	b.n	7070 <usb_isr+0x94>
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
		break;
	case 0x01:  // OUT transaction received from host
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    71ee:	4a37      	ldr	r2, [pc, #220]	; (72cc <usb_isr+0x2f0>)
    71f0:	8815      	ldrh	r5, [r2, #0]
    71f2:	f242 0021 	movw	r0, #8225	; 0x2021
    71f6:	4285      	cmp	r5, r0
    71f8:	f000 8152 	beq.w	74a0 <usb_isr+0x4c4>
		if (usb_audio_set_feature(&setup, buf)) {
			endpoint0_transmit(NULL, 0);
		}
#endif
		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    71fc:	4a2d      	ldr	r2, [pc, #180]	; (72b4 <usb_isr+0x2d8>)
    71fe:	f847 2034 	str.w	r2, [r7, r4, lsl #3]
    7202:	e7f0      	b.n	71e6 <usb_isr+0x20a>
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
					}
				} else {
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    7204:	4a2b      	ldr	r2, [pc, #172]	; (72b4 <usb_isr+0x2d8>)
    7206:	4b2c      	ldr	r3, [pc, #176]	; (72b8 <usb_isr+0x2dc>)
    7208:	f019 0f08 	tst.w	r9, #8
    720c:	bf18      	it	ne
    720e:	4613      	movne	r3, r2
    7210:	f847 3038 	str.w	r3, [r7, r8, lsl #3]
    7214:	e72c      	b.n	7070 <usb_isr+0x94>
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
    7216:	f000 fb9d 	bl	7954 <usb_free>
				packet = tx_first[endpoint];
    721a:	4a34      	ldr	r2, [pc, #208]	; (72ec <usb_isr+0x310>)
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    721c:	4934      	ldr	r1, [pc, #208]	; (72f0 <usb_isr+0x314>)
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
    721e:	f852 3026 	ldr.w	r3, [r2, r6, lsl #2]
				if (packet) {
    7222:	2b00      	cmp	r3, #0
    7224:	f000 812d 	beq.w	7482 <usb_isr+0x4a6>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    7228:	6858      	ldr	r0, [r3, #4]
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    722a:	5d8c      	ldrb	r4, [r1, r6]
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    722c:	f842 0026 	str.w	r0, [r2, r6, lsl #2]
					b->addr = packet->buf;
    7230:	f103 0208 	add.w	r2, r3, #8
    7234:	f8c9 2004 	str.w	r2, [r9, #4]
					switch (tx_state[endpoint]) {
    7238:	2c03      	cmp	r4, #3
    723a:	d805      	bhi.n	7248 <usb_isr+0x26c>
    723c:	e8df f004 	tbb	[pc, r4]
    7240:	02150f12 	.word	0x02150f12
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    7244:	2204      	movs	r2, #4
    7246:	558a      	strb	r2, [r1, r6]
						break;
					  default:
						break;
					}
					b->desc = BDT_DESC(packet->len,
    7248:	881a      	ldrh	r2, [r3, #0]
    724a:	f019 0f08 	tst.w	r9, #8
    724e:	bf0c      	ite	eq
    7250:	2388      	moveq	r3, #136	; 0x88
    7252:	23c8      	movne	r3, #200	; 0xc8
    7254:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    7258:	f847 3038 	str.w	r3, [r7, r8, lsl #3]
    725c:	e708      	b.n	7070 <usb_isr+0x94>
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    725e:	2202      	movs	r2, #2
    7260:	558a      	strb	r2, [r1, r6]
						break;
    7262:	e7f1      	b.n	7248 <usb_isr+0x26c>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    7264:	2203      	movs	r2, #3
    7266:	558a      	strb	r2, [r1, r6]
						break;
    7268:	e7ee      	b.n	7248 <usb_isr+0x26c>
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    726a:	2205      	movs	r2, #5
    726c:	558a      	strb	r2, [r1, r6]
						break;
    726e:	e7eb      	b.n	7248 <usb_isr+0x26c>
		goto restart;
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    7270:	07e0      	lsls	r0, r4, #31
    7272:	f100 8178 	bmi.w	7566 <usb_isr+0x58a>
		USB0_CTL = USB_CTL_USBENSOFEN;
		return;
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    7276:	0621      	lsls	r1, r4, #24
    7278:	f100 81a2 	bmi.w	75c0 <usb_isr+0x5e4>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    727c:	07a2      	lsls	r2, r4, #30
    727e:	d506      	bpl.n	728e <usb_isr+0x2b2>
		uint8_t err = USB0_ERRSTAT;
    7280:	4a1c      	ldr	r2, [pc, #112]	; (72f4 <usb_isr+0x318>)
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    7282:	491d      	ldr	r1, [pc, #116]	; (72f8 <usb_isr+0x31c>)
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    7284:	7813      	ldrb	r3, [r2, #0]
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    7286:	2002      	movs	r0, #2
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    7288:	b2db      	uxtb	r3, r3
		USB0_ERRSTAT = err;
    728a:	7013      	strb	r3, [r2, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    728c:	7008      	strb	r0, [r1, #0]
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    728e:	06e3      	lsls	r3, r4, #27
    7290:	d502      	bpl.n	7298 <usb_isr+0x2bc>
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    7292:	4b19      	ldr	r3, [pc, #100]	; (72f8 <usb_isr+0x31c>)
    7294:	2210      	movs	r2, #16
    7296:	701a      	strb	r2, [r3, #0]
	}

}
    7298:	b007      	add	sp, #28
    729a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
			if (t) {
				usb_cdc_transmit_flush_timer = --t;
				if (t == 0) usb_serial_flush_callback();
    729e:	f000 fcc5 	bl	7c2c <usb_serial_flush_callback>
    72a2:	e706      	b.n	70b2 <usb_isr+0xd6>
    72a4:	1fff0000 	.word	0x1fff0000
    72a8:	1fff2c60 	.word	0x1fff2c60
    72ac:	1fff2c0c 	.word	0x1fff2c0c
    72b0:	1fff2d68 	.word	0x1fff2d68
    72b4:	004000c8 	.word	0x004000c8
    72b8:	00400088 	.word	0x00400088
    72bc:	1fff2ce8 	.word	0x1fff2ce8
    72c0:	1fff2c71 	.word	0x1fff2c71
    72c4:	1fff2cf0 	.word	0x1fff2cf0
    72c8:	1fff2c08 	.word	0x1fff2c08
    72cc:	1fff2cd4 	.word	0x1fff2cd4
    72d0:	1fff2c70 	.word	0x1fff2c70
    72d4:	400720c0 	.word	0x400720c0
    72d8:	1fff2ce0 	.word	0x1fff2ce0
    72dc:	1fff2c1c 	.word	0x1fff2c1c
    72e0:	1fff2cdc 	.word	0x1fff2cdc
    72e4:	40072098 	.word	0x40072098
    72e8:	40072094 	.word	0x40072094
    72ec:	1fff2cb4 	.word	0x1fff2cb4
    72f0:	1fff2cec 	.word	0x1fff2cec
    72f4:	40072088 	.word	0x40072088
    72f8:	40072080 	.word	0x40072080
    72fc:	40072090 	.word	0x40072090
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
    7300:	4ab7      	ldr	r2, [pc, #732]	; (75e0 <usb_isr+0x604>)
						b->desc = BDT_DESC(64,
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
    7302:	f847 0038 	str.w	r0, [r7, r8, lsl #3]
						usb_rx_memory_needed++;
    7306:	7813      	ldrb	r3, [r2, #0]
    7308:	3301      	adds	r3, #1
    730a:	7013      	strb	r3, [r2, #0]
    730c:	e6b0      	b.n	7070 <usb_isr+0x94>
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[endpoint] = packet;
    730e:	f843 0026 	str.w	r0, [r3, r6, lsl #2]
    7312:	4db4      	ldr	r5, [pc, #720]	; (75e4 <usb_isr+0x608>)
    7314:	e693      	b.n	703e <usb_isr+0x62>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    7316:	f242 0421 	movw	r4, #8225	; 0x2021
    731a:	42a1      	cmp	r1, r4
    731c:	f000 80ad 	beq.w	747a <usb_isr+0x49e>
    7320:	f200 810e 	bhi.w	7540 <usb_isr+0x564>
    7324:	f5b1 6f08 	cmp.w	r1, #2176	; 0x880
    7328:	f000 8154 	beq.w	75d4 <usb_isr+0x5f8>
    732c:	f5b1 6f10 	cmp.w	r1, #2304	; 0x900
    7330:	f040 819d 	bne.w	766e <usb_isr+0x692>
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
    7334:	4aac      	ldr	r2, [pc, #688]	; (75e8 <usb_isr+0x60c>)
    7336:	78a9      	ldrb	r1, [r5, #2]
    7338:	7011      	strb	r1, [r2, #0]
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
			if (table[i].desc & BDT_OWN) {
    733a:	4dac      	ldr	r5, [pc, #688]	; (75ec <usb_isr+0x610>)
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    733c:	2404      	movs	r4, #4
    733e:	e002      	b.n	7346 <usb_isr+0x36a>
    7340:	3401      	adds	r4, #1
    7342:	2c14      	cmp	r4, #20
    7344:	d00c      	beq.n	7360 <usb_isr+0x384>
			if (table[i].desc & BDT_OWN) {
    7346:	f857 3034 	ldr.w	r3, [r7, r4, lsl #3]
    734a:	0619      	lsls	r1, r3, #24
    734c:	d5f8      	bpl.n	7340 <usb_isr+0x364>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    734e:	eb05 03c4 	add.w	r3, r5, r4, lsl #3
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    7352:	3401      	adds	r4, #1
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    7354:	6858      	ldr	r0, [r3, #4]
    7356:	3808      	subs	r0, #8
    7358:	f000 fafc 	bl	7954 <usb_free>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    735c:	2c14      	cmp	r4, #20
    735e:	d1f2      	bne.n	7346 <usb_isr+0x36a>
    7360:	49a3      	ldr	r1, [pc, #652]	; (75f0 <usb_isr+0x614>)
    7362:	4ba4      	ldr	r3, [pc, #656]	; (75f4 <usb_isr+0x618>)
    7364:	4aa4      	ldr	r2, [pc, #656]	; (75f8 <usb_isr+0x61c>)
    7366:	9102      	str	r1, [sp, #8]
    7368:	49a4      	ldr	r1, [pc, #656]	; (75fc <usb_isr+0x620>)
    736a:	4ca5      	ldr	r4, [pc, #660]	; (7600 <usb_isr+0x624>)
    736c:	4d9d      	ldr	r5, [pc, #628]	; (75e4 <usb_isr+0x608>)
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    736e:	9403      	str	r4, [sp, #12]
    7370:	9605      	str	r6, [sp, #20]
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    7372:	f04f 0900 	mov.w	r9, #0
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    7376:	4688      	mov	r8, r1
    7378:	461c      	mov	r4, r3
    737a:	4616      	mov	r6, r2
    737c:	9504      	str	r5, [sp, #16]
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    737e:	6820      	ldr	r0, [r4, #0]
			while (p) {
    7380:	b128      	cbz	r0, 738e <usb_isr+0x3b2>
				n = p->next;
    7382:	6845      	ldr	r5, [r0, #4]
				usb_free(p);
    7384:	f000 fae6 	bl	7954 <usb_free>
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
			while (p) {
    7388:	4628      	mov	r0, r5
    738a:	2d00      	cmp	r5, #0
    738c:	d1f9      	bne.n	7382 <usb_isr+0x3a6>
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
    738e:	2300      	movs	r3, #0
    7390:	6023      	str	r3, [r4, #0]
			rx_last[i] = NULL;
    7392:	9b04      	ldr	r3, [sp, #16]
			p = tx_first[i];
    7394:	6830      	ldr	r0, [r6, #0]
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
    7396:	461a      	mov	r2, r3
    7398:	2300      	movs	r3, #0
    739a:	f842 3029 	str.w	r3, [r2, r9, lsl #2]
			p = tx_first[i];
			while (p) {
    739e:	b128      	cbz	r0, 73ac <usb_isr+0x3d0>
				n = p->next;
    73a0:	6845      	ldr	r5, [r0, #4]
				usb_free(p);
    73a2:	f000 fad7 	bl	7954 <usb_free>
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
			p = tx_first[i];
			while (p) {
    73a6:	4628      	mov	r0, r5
    73a8:	2d00      	cmp	r5, #0
    73aa:	d1f9      	bne.n	73a0 <usb_isr+0x3c4>
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    73ac:	2200      	movs	r2, #0
    73ae:	6032      	str	r2, [r6, #0]
			tx_last[i] = NULL;
    73b0:	9a02      	ldr	r2, [sp, #8]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    73b2:	f898 3000 	ldrb.w	r3, [r8]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    73b6:	4611      	mov	r1, r2
    73b8:	2200      	movs	r2, #0
    73ba:	f841 2b04 	str.w	r2, [r1], #4
			usb_rx_byte_count_data[i] = 0;
    73be:	9a03      	ldr	r2, [sp, #12]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    73c0:	9102      	str	r1, [sp, #8]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    73c2:	3b02      	subs	r3, #2
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    73c4:	f04f 0100 	mov.w	r1, #0
    73c8:	f822 1019 	strh.w	r1, [r2, r9, lsl #1]
			switch (tx_state[i]) {
    73cc:	2b03      	cmp	r3, #3
    73ce:	f200 81b4 	bhi.w	773a <usb_isr+0x75e>
    73d2:	e8df f013 	tbh	[pc, r3, lsl #1]
    73d6:	01e2      	.short	0x01e2
    73d8:	01e201ae 	.word	0x01e201ae
    73dc:	01ae      	.short	0x01ae
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    73de:	4c89      	ldr	r4, [pc, #548]	; (7604 <usb_isr+0x628>)
		reply_buffer[1] = 0;
		datalen = 2;
    73e0:	2002      	movs	r0, #2
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    73e2:	7022      	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    73e4:	7062      	strb	r2, [r4, #1]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    73e6:	88ea      	ldrh	r2, [r5, #6]
    73e8:	4282      	cmp	r2, r0
    73ea:	f080 820d 	bcs.w	7808 <usb_isr+0x82c>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    73ee:	4986      	ldr	r1, [pc, #536]	; (7608 <usb_isr+0x62c>)
    73f0:	780d      	ldrb	r5, [r1, #0]
    73f2:	2a40      	cmp	r2, #64	; 0x40
    73f4:	f045 0e02 	orr.w	lr, r5, #2
    73f8:	4694      	mov	ip, r2
    73fa:	eb07 00ce 	add.w	r0, r7, lr, lsl #3
    73fe:	bf28      	it	cs
    7400:	f04f 0c40 	movcs.w	ip, #64	; 0x40
    7404:	eb04 030c 	add.w	r3, r4, ip
    7408:	6044      	str	r4, [r0, #4]
    740a:	9302      	str	r3, [sp, #8]
    740c:	ebcc 0002 	rsb	r0, ip, r2
    7410:	ea4f 480c 	mov.w	r8, ip, lsl #16
    7414:	f04f 0901 	mov.w	r9, #1
    7418:	2200      	movs	r2, #0
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    741a:	24c8      	movs	r4, #200	; 0xc8
    741c:	ea44 0308 	orr.w	r3, r4, r8
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    7420:	f085 0401 	eor.w	r4, r5, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    7424:	f847 303e 	str.w	r3, [r7, lr, lsl #3]
	ep0_tx_data_toggle ^= 1;
    7428:	7032      	strb	r2, [r6, #0]
	ep0_tx_bdt_bank ^= 1;
    742a:	700c      	strb	r4, [r1, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    742c:	f8df e1bc 	ldr.w	lr, [pc, #444]	; 75ec <usb_isr+0x610>
	ep0_tx_data_toggle ^= 1;
    7430:	4b76      	ldr	r3, [pc, #472]	; (760c <usb_isr+0x630>)
	ep0_tx_bdt_bank ^= 1;
    7432:	f8df 81d4 	ldr.w	r8, [pc, #468]	; 7608 <usb_isr+0x62c>
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    7436:	2800      	cmp	r0, #0
    7438:	f040 8120 	bne.w	767c <usb_isr+0x6a0>
    743c:	f1bc 0f40 	cmp.w	ip, #64	; 0x40
    7440:	d11b      	bne.n	747a <usb_isr+0x49e>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    7442:	f044 0402 	orr.w	r4, r4, #2
    7446:	eb07 03c4 	add.w	r3, r7, r4, lsl #3
    744a:	9f02      	ldr	r7, [sp, #8]
    744c:	f8df e19c 	ldr.w	lr, [pc, #412]	; 75ec <usb_isr+0x610>
    7450:	605f      	str	r7, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    7452:	2a00      	cmp	r2, #0
    7454:	f040 8127 	bne.w	76a6 <usb_isr+0x6ca>
    7458:	0402      	lsls	r2, r0, #16
    745a:	f042 0288 	orr.w	r2, r2, #136	; 0x88
	ep0_tx_data_toggle ^= 1;
    745e:	f886 9000 	strb.w	r9, [r6]
	ep0_tx_bdt_bank ^= 1;
    7462:	700d      	strb	r5, [r1, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    7464:	4407      	add	r7, r0
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    7466:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    746a:	463b      	mov	r3, r7
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    746c:	2840      	cmp	r0, #64	; 0x40
    746e:	d104      	bne.n	747a <usb_isr+0x49e>
    7470:	2000      	movs	r0, #0

	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
    7472:	4a67      	ldr	r2, [pc, #412]	; (7610 <usb_isr+0x634>)
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    7474:	9901      	ldr	r1, [sp, #4]
	ep0_tx_len = datalen;
    7476:	8010      	strh	r0, [r2, #0]
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    7478:	600b      	str	r3, [r1, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    747a:	4a66      	ldr	r2, [pc, #408]	; (7614 <usb_isr+0x638>)
    747c:	2301      	movs	r3, #1
    747e:	7013      	strb	r3, [r2, #0]
    7480:	e6b1      	b.n	71e6 <usb_isr+0x20a>
					}
					b->desc = BDT_DESC(packet->len,
						((uint32_t)b & 8) ? DATA1 : DATA0);
				} else {
					//serial_print("tx no packet\n");
					switch (tx_state[endpoint]) {
    7482:	5d8b      	ldrb	r3, [r1, r6]
    7484:	2b03      	cmp	r3, #3
    7486:	f200 8124 	bhi.w	76d2 <usb_isr+0x6f6>
    748a:	a201      	add	r2, pc, #4	; (adr r2, 7490 <usb_isr+0x4b4>)
    748c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    7490:	00007071 	.word	0x00007071
    7494:	00007071 	.word	0x00007071
    7498:	000075b5 	.word	0x000075b5
    749c:	000075bb 	.word	0x000075bb
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
			int i;
			uint32_t *line_coding = NULL;
			switch (setup.wIndex) {
    74a0:	8892      	ldrh	r2, [r2, #4]
    74a2:	b962      	cbnz	r2, 74be <usb_isr+0x4e2>
    74a4:	4a5c      	ldr	r2, [pc, #368]	; (7618 <usb_isr+0x63c>)
    74a6:	1dcd      	adds	r5, r1, #7
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
					//serial_phex(*buf);
					*dst++ = *buf++;
    74a8:	f811 3b01 	ldrb.w	r3, [r1], #1
    74ac:	f802 3f01 	strb.w	r3, [r2, #1]!
#endif
			}
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
    74b0:	428d      	cmp	r5, r1
    74b2:	d1f9      	bne.n	74a8 <usb_isr+0x4cc>
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    74b4:	4a59      	ldr	r2, [pc, #356]	; (761c <usb_isr+0x640>)
    74b6:	6812      	ldr	r2, [r2, #0]
    74b8:	2a86      	cmp	r2, #134	; 0x86
    74ba:	f000 80c9 	beq.w	7650 <usb_isr+0x674>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    74be:	4952      	ldr	r1, [pc, #328]	; (7608 <usb_isr+0x62c>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    74c0:	4e52      	ldr	r6, [pc, #328]	; (760c <usb_isr+0x630>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    74c2:	7808      	ldrb	r0, [r1, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    74c4:	7832      	ldrb	r2, [r6, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    74c6:	f040 0502 	orr.w	r5, r0, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    74ca:	f080 0001 	eor.w	r0, r0, #1
    74ce:	7008      	strb	r0, [r1, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    74d0:	eb07 01c5 	add.w	r1, r7, r5, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    74d4:	2a00      	cmp	r2, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    74d6:	f04f 0000 	mov.w	r0, #0
    74da:	6048      	str	r0, [r1, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    74dc:	f082 0201 	eor.w	r2, r2, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    74e0:	bf0c      	ite	eq
    74e2:	2188      	moveq	r1, #136	; 0x88
    74e4:	21c8      	movne	r1, #200	; 0xc8
    74e6:	f847 1035 	str.w	r1, [r7, r5, lsl #3]
	ep0_tx_data_toggle ^= 1;
    74ea:	7032      	strb	r2, [r6, #0]
    74ec:	e686      	b.n	71fc <usb_isr+0x220>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    74ee:	f240 3202 	movw	r2, #770	; 0x302
    74f2:	4291      	cmp	r1, r2
    74f4:	f040 80b0 	bne.w	7658 <usb_isr+0x67c>
    74f8:	88a9      	ldrh	r1, [r5, #4]
    74fa:	f001 017f 	and.w	r1, r1, #127	; 0x7f
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
		// TODO: do we need to clear the data toggle here?
		break;
	  case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    74fe:	2904      	cmp	r1, #4
    7500:	f200 80b5 	bhi.w	766e <usb_isr+0x692>
    7504:	886a      	ldrh	r2, [r5, #2]
    7506:	2a00      	cmp	r2, #0
    7508:	f040 80b1 	bne.w	766e <usb_isr+0x692>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    750c:	4c44      	ldr	r4, [pc, #272]	; (7620 <usb_isr+0x644>)
    750e:	0089      	lsls	r1, r1, #2
    7510:	440c      	add	r4, r1
    7512:	4681      	mov	r9, r0
    7514:	7821      	ldrb	r1, [r4, #0]
    7516:	f041 0102 	orr.w	r1, r1, #2
    751a:	7021      	strb	r1, [r4, #0]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    751c:	2000      	movs	r0, #0
    751e:	9002      	str	r0, [sp, #8]
    7520:	4680      	mov	r8, r0
    7522:	4684      	mov	ip, r0
    7524:	4604      	mov	r4, r0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    7526:	4938      	ldr	r1, [pc, #224]	; (7608 <usb_isr+0x62c>)
    7528:	780d      	ldrb	r5, [r1, #0]
    752a:	f045 0e02 	orr.w	lr, r5, #2
    752e:	eb07 03ce 	add.w	r3, r7, lr, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    7532:	f1b9 0f00 	cmp.w	r9, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    7536:	605c      	str	r4, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    7538:	bf0c      	ite	eq
    753a:	2488      	moveq	r4, #136	; 0x88
    753c:	24c8      	movne	r4, #200	; 0xc8
    753e:	e76d      	b.n	741c <usb_isr+0x440>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    7540:	f242 2421 	movw	r4, #8737	; 0x2221
    7544:	42a1      	cmp	r1, r4
    7546:	f040 808e 	bne.w	7666 <usb_isr+0x68a>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    754a:	88a9      	ldrh	r1, [r5, #4]
    754c:	2900      	cmp	r1, #0
    754e:	f040 8142 	bne.w	77d6 <usb_isr+0x7fa>
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    7552:	4b34      	ldr	r3, [pc, #208]	; (7624 <usb_isr+0x648>)
    7554:	4a34      	ldr	r2, [pc, #208]	; (7628 <usb_isr+0x64c>)
			usb_cdc_line_rtsdtr = setup.wValue;
    7556:	4c35      	ldr	r4, [pc, #212]	; (762c <usb_isr+0x650>)
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    7558:	681b      	ldr	r3, [r3, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    755a:	78ad      	ldrb	r5, [r5, #2]
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    755c:	6013      	str	r3, [r2, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    755e:	4681      	mov	r9, r0
    7560:	460a      	mov	r2, r1
    7562:	7025      	strb	r5, [r4, #0]
    7564:	e7da      	b.n	751c <usb_isr+0x540>

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    7566:	492b      	ldr	r1, [pc, #172]	; (7614 <usb_isr+0x638>)
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    7568:	4b20      	ldr	r3, [pc, #128]	; (75ec <usb_isr+0x610>)
    756a:	4831      	ldr	r0, [pc, #196]	; (7630 <usb_isr+0x654>)
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    756c:	4e26      	ldr	r6, [pc, #152]	; (7608 <usb_isr+0x62c>)
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    756e:	f8df c0b0 	ldr.w	ip, [pc, #176]	; 7620 <usb_isr+0x644>

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    7572:	4d30      	ldr	r5, [pc, #192]	; (7634 <usb_isr+0x658>)
		USB0_ISTAT = 0xFF;
    7574:	f8df e0d4 	ldr.w	lr, [pc, #212]	; 764c <usb_isr+0x670>

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    7578:	4f2f      	ldr	r7, [pc, #188]	; (7638 <usb_isr+0x65c>)

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    757a:	2402      	movs	r4, #2
    757c:	700c      	strb	r4, [r1, #0]
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    757e:	4c2f      	ldr	r4, [pc, #188]	; (763c <usb_isr+0x660>)
		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    7580:	6018      	str	r0, [r3, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    7582:	605c      	str	r4, [r3, #4]
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    7584:	6098      	str	r0, [r3, #8]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    7586:	482e      	ldr	r0, [pc, #184]	; (7640 <usb_isr+0x664>)
    7588:	60d8      	str	r0, [r3, #12]
		table[index(0, TX, EVEN)].desc = 0;
    758a:	611a      	str	r2, [r3, #16]
		table[index(0, TX, ODD)].desc = 0;
    758c:	619a      	str	r2, [r3, #24]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    758e:	230d      	movs	r3, #13
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    7590:	7032      	strb	r2, [r6, #0]
		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    7592:	4c2c      	ldr	r4, [pc, #176]	; (7644 <usb_isr+0x668>)
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    7594:	f88c 3000 	strb.w	r3, [ip]

		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
    7598:	4e2b      	ldr	r6, [pc, #172]	; (7648 <usb_isr+0x66c>)

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    759a:	23ff      	movs	r3, #255	; 0xff
    759c:	702b      	strb	r3, [r5, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    759e:	2001      	movs	r0, #1
		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    75a0:	259f      	movs	r5, #159	; 0x9f
		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
		USB0_ISTAT = 0xFF;
    75a2:	f88e 3000 	strb.w	r3, [lr]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    75a6:	703a      	strb	r2, [r7, #0]

		// enable other interrupts
		USB0_ERREN = 0xFF;
    75a8:	7033      	strb	r3, [r6, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    75aa:	7025      	strb	r5, [r4, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    75ac:	7008      	strb	r0, [r1, #0]
	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
	}

}
    75ae:	b007      	add	sp, #28
    75b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    75b4:	2300      	movs	r3, #0
    75b6:	558b      	strb	r3, [r1, r6]
						break;
    75b8:	e55a      	b.n	7070 <usb_isr+0x94>
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    75ba:	2301      	movs	r3, #1
    75bc:	558b      	strb	r3, [r1, r6]
						break;
    75be:	e557      	b.n	7070 <usb_isr+0x94>
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    75c0:	4917      	ldr	r1, [pc, #92]	; (7620 <usb_isr+0x644>)
		USB0_ISTAT = USB_ISTAT_STALL;
    75c2:	4b22      	ldr	r3, [pc, #136]	; (764c <usb_isr+0x670>)
    75c4:	2280      	movs	r2, #128	; 0x80
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    75c6:	200d      	movs	r0, #13
    75c8:	7008      	strb	r0, [r1, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    75ca:	701a      	strb	r2, [r3, #0]
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    75cc:	07a2      	lsls	r2, r4, #30
    75ce:	f57f ae5e 	bpl.w	728e <usb_isr+0x2b2>
    75d2:	e655      	b.n	7280 <usb_isr+0x2a4>
			}
#endif
		}
		break;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    75d4:	4a04      	ldr	r2, [pc, #16]	; (75e8 <usb_isr+0x60c>)
    75d6:	4c0b      	ldr	r4, [pc, #44]	; (7604 <usb_isr+0x628>)
    75d8:	7812      	ldrb	r2, [r2, #0]
    75da:	7022      	strb	r2, [r4, #0]
    75dc:	e703      	b.n	73e6 <usb_isr+0x40a>
    75de:	bf00      	nop
    75e0:	1fff2cdd 	.word	0x1fff2cdd
    75e4:	1fff2c0c 	.word	0x1fff2c0c
    75e8:	1fff2ce8 	.word	0x1fff2ce8
    75ec:	1fff0000 	.word	0x1fff0000
    75f0:	1fff2cc4 	.word	0x1fff2cc4
    75f4:	1fff2c60 	.word	0x1fff2c60
    75f8:	1fff2cb4 	.word	0x1fff2cb4
    75fc:	1fff2cec 	.word	0x1fff2cec
    7600:	1fff2d68 	.word	0x1fff2d68
    7604:	1fff2ce0 	.word	0x1fff2ce0
    7608:	1fff2cdc 	.word	0x1fff2cdc
    760c:	1fff2c70 	.word	0x1fff2c70
    7610:	1fff2c1c 	.word	0x1fff2c1c
    7614:	40072094 	.word	0x40072094
    7618:	1fff2d6f 	.word	0x1fff2d6f
    761c:	1fff2d70 	.word	0x1fff2d70
    7620:	400720c0 	.word	0x400720c0
    7624:	1fff2c04 	.word	0x1fff2c04
    7628:	1fff2d78 	.word	0x1fff2d78
    762c:	1fff2d00 	.word	0x1fff2d00
    7630:	00400088 	.word	0x00400088
    7634:	40072088 	.word	0x40072088
    7638:	40072098 	.word	0x40072098
    763c:	1fff2c20 	.word	0x1fff2c20
    7640:	1fff2c74 	.word	0x1fff2c74
    7644:	40072084 	.word	0x40072084
    7648:	4007208c 	.word	0x4007208c
    764c:	40072080 	.word	0x40072080
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    7650:	4a75      	ldr	r2, [pc, #468]	; (7828 <usb_isr+0x84c>)
    7652:	210f      	movs	r1, #15
    7654:	7011      	strb	r1, [r2, #0]
    7656:	e732      	b.n	74be <usb_isr+0x4e2>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    7658:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
    765c:	d107      	bne.n	766e <usb_isr+0x692>
    765e:	2200      	movs	r2, #0
    7660:	f04f 0901 	mov.w	r9, #1
    7664:	e75a      	b.n	751c <usb_isr+0x540>
    7666:	f242 3221 	movw	r2, #8993	; 0x2321
    766a:	4291      	cmp	r1, r2
    766c:	d0f7      	beq.n	765e <usb_isr+0x682>
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    766e:	4b6f      	ldr	r3, [pc, #444]	; (782c <usb_isr+0x850>)
    7670:	220f      	movs	r2, #15
    7672:	701a      	strb	r2, [r3, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    7674:	4a6e      	ldr	r2, [pc, #440]	; (7830 <usb_isr+0x854>)
    7676:	2301      	movs	r3, #1
    7678:	7013      	strb	r3, [r2, #0]
    767a:	e5b4      	b.n	71e6 <usb_isr+0x20a>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
    767c:	2840      	cmp	r0, #64	; 0x40
    767e:	f67f aee0 	bls.w	7442 <usb_isr+0x466>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    7682:	f044 0402 	orr.w	r4, r4, #2
    7686:	eb0e 01c4 	add.w	r1, lr, r4, lsl #3
    768a:	9e02      	ldr	r6, [sp, #8]
    768c:	604e      	str	r6, [r1, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    768e:	b1aa      	cbz	r2, 76bc <usb_isr+0x6e0>
	ep0_tx_data_toggle ^= 1;
    7690:	f883 9000 	strb.w	r9, [r3]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    7694:	4a67      	ldr	r2, [pc, #412]	; (7834 <usb_isr+0x858>)
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    7696:	f888 5000 	strb.w	r5, [r8]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    769a:	4633      	mov	r3, r6
    769c:	3840      	subs	r0, #64	; 0x40
    769e:	3340      	adds	r3, #64	; 0x40
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    76a0:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
    76a4:	e6e5      	b.n	7472 <usb_isr+0x496>
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    76a6:	9b02      	ldr	r3, [sp, #8]
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    76a8:	f886 9000 	strb.w	r9, [r6]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    76ac:	0402      	lsls	r2, r0, #16
    76ae:	f042 02c8 	orr.w	r2, r2, #200	; 0xc8
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    76b2:	700d      	strb	r5, [r1, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    76b4:	4403      	add	r3, r0
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    76b6:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
    76ba:	e6d7      	b.n	746c <usb_isr+0x490>
	ep0_tx_data_toggle ^= 1;
    76bc:	f883 9000 	strb.w	r9, [r3]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    76c0:	9b02      	ldr	r3, [sp, #8]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    76c2:	4a5d      	ldr	r2, [pc, #372]	; (7838 <usb_isr+0x85c>)
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    76c4:	f888 5000 	strb.w	r5, [r8]
    76c8:	3840      	subs	r0, #64	; 0x40
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    76ca:	3340      	adds	r3, #64	; 0x40
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    76cc:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
    76d0:	e6cf      	b.n	7472 <usb_isr+0x496>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
						break;
					  default:
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    76d2:	f019 0f08 	tst.w	r9, #8
    76d6:	bf0c      	ite	eq
    76d8:	2302      	moveq	r3, #2
    76da:	2303      	movne	r3, #3
    76dc:	558b      	strb	r3, [r1, r6]
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
    76de:	e4c7      	b.n	7070 <usb_isr+0x94>
    76e0:	88a9      	ldrh	r1, [r5, #4]
    76e2:	f001 017f 	and.w	r1, r1, #127	; 0x7f
		data = reply_buffer;
		datalen = 2;
		break;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    76e6:	2904      	cmp	r1, #4
    76e8:	d8c1      	bhi.n	766e <usb_isr+0x692>
    76ea:	886a      	ldrh	r2, [r5, #2]
    76ec:	2a00      	cmp	r2, #0
    76ee:	d1be      	bne.n	766e <usb_isr+0x692>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    76f0:	4c4e      	ldr	r4, [pc, #312]	; (782c <usb_isr+0x850>)
    76f2:	0089      	lsls	r1, r1, #2
    76f4:	440c      	add	r4, r1
    76f6:	4681      	mov	r9, r0
    76f8:	7821      	ldrb	r1, [r4, #0]
    76fa:	f021 0102 	bic.w	r1, r1, #2
    76fe:	7021      	strb	r1, [r4, #0]
    7700:	e70c      	b.n	751c <usb_isr+0x540>
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
    7702:	4a4e      	ldr	r2, [pc, #312]	; (783c <usb_isr+0x860>)
    7704:	6854      	ldr	r4, [r2, #4]
    7706:	2c00      	cmp	r4, #0
    7708:	d0b1      	beq.n	766e <usb_isr+0x692>
    770a:	8868      	ldrh	r0, [r5, #2]
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    770c:	f8b5 e004 	ldrh.w	lr, [r5, #4]
    7710:	e003      	b.n	771a <usb_isr+0x73e>
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
    7712:	320c      	adds	r2, #12
			if (list->addr == NULL) break;
    7714:	6854      	ldr	r4, [r2, #4]
    7716:	2c00      	cmp	r4, #0
    7718:	d0a9      	beq.n	766e <usb_isr+0x692>
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    771a:	8813      	ldrh	r3, [r2, #0]
    771c:	4283      	cmp	r3, r0
    771e:	d1f8      	bne.n	7712 <usb_isr+0x736>
    7720:	8853      	ldrh	r3, [r2, #2]
    7722:	4573      	cmp	r3, lr
    7724:	d1f5      	bne.n	7712 <usb_isr+0x736>
				data = list->addr;
				if ((setup.wValue >> 8) == 3) {
    7726:	0a00      	lsrs	r0, r0, #8
    7728:	2803      	cmp	r0, #3
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    772a:	bf0c      	ite	eq
    772c:	7820      	ldrbeq	r0, [r4, #0]
				} else {
					datalen = list->length;
    772e:	8910      	ldrhne	r0, [r2, #8]
    7730:	e659      	b.n	73e6 <usb_isr+0x40a>
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    7732:	f04f 0301 	mov.w	r3, #1
    7736:	f888 3000 	strb.w	r3, [r8]
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
    773a:	f109 0901 	add.w	r9, r9, #1
    773e:	f1b9 0f04 	cmp.w	r9, #4
    7742:	f104 0404 	add.w	r4, r4, #4
    7746:	f106 0604 	add.w	r6, r6, #4
    774a:	f108 0801 	add.w	r8, r8, #1
    774e:	f47f ae16 	bne.w	737e <usb_isr+0x3a2>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    7752:	4b3b      	ldr	r3, [pc, #236]	; (7840 <usb_isr+0x864>)
    7754:	9e05      	ldr	r6, [sp, #20]
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
    7756:	4d3b      	ldr	r5, [pc, #236]	; (7844 <usb_isr+0x868>)
		cfg = usb_endpoint_config_table;
    7758:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 784c <usb_isr+0x870>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    775c:	2000      	movs	r0, #0
    775e:	7018      	strb	r0, [r3, #0]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    7760:	f04f 0901 	mov.w	r9, #1
			epconf = *cfg++;
    7764:	f818 3b01 	ldrb.w	r3, [r8], #1
			*reg = epconf;
    7768:	f805 3b04 	strb.w	r3, [r5], #4
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    776c:	071a      	lsls	r2, r3, #28
    776e:	d419      	bmi.n	77a4 <usb_isr+0x7c8>
    7770:	ea4f 0489 	mov.w	r4, r9, lsl #2
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    7774:	f044 0202 	orr.w	r2, r4, #2
			table[index(i, TX, ODD)].desc = 0;
    7778:	f044 0403 	orr.w	r4, r4, #3
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    777c:	2300      	movs	r3, #0
    777e:	f847 3032 	str.w	r3, [r7, r2, lsl #3]
			table[index(i, TX, ODD)].desc = 0;
    7782:	f847 3034 	str.w	r3, [r7, r4, lsl #3]
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    7786:	4b30      	ldr	r3, [pc, #192]	; (7848 <usb_isr+0x86c>)
    7788:	429d      	cmp	r5, r3
    778a:	f109 0901 	add.w	r9, r9, #1
    778e:	d1e9      	bne.n	7764 <usb_isr+0x788>
    7790:	f896 9000 	ldrb.w	r9, [r6]
    7794:	f089 0201 	eor.w	r2, r9, #1
    7798:	e6c0      	b.n	751c <usb_isr+0x540>
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
			  case TX_STATE_EVEN_FREE:
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    779a:	f04f 0300 	mov.w	r3, #0
    779e:	f888 3000 	strb.w	r3, [r8]
    77a2:	e7ca      	b.n	773a <usb_isr+0x75e>
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
    77a4:	f000 f8b6 	bl	7914 <usb_malloc>
				if (p) {
    77a8:	b318      	cbz	r0, 77f2 <usb_isr+0x816>
					table[index(i, RX, EVEN)].addr = p->buf;
    77aa:	eb07 1349 	add.w	r3, r7, r9, lsl #5
    77ae:	ea4f 0489 	mov.w	r4, r9, lsl #2
    77b2:	3008      	adds	r0, #8
    77b4:	6058      	str	r0, [r3, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    77b6:	4b20      	ldr	r3, [pc, #128]	; (7838 <usb_isr+0x85c>)
    77b8:	f847 3034 	str.w	r3, [r7, r4, lsl #3]
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
    77bc:	f000 f8aa 	bl	7914 <usb_malloc>
				if (p) {
    77c0:	b168      	cbz	r0, 77de <usb_isr+0x802>
					table[index(i, RX, ODD)].addr = p->buf;
    77c2:	f044 0301 	orr.w	r3, r4, #1
    77c6:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
    77ca:	3008      	adds	r0, #8
    77cc:	6050      	str	r0, [r2, #4]
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    77ce:	4a19      	ldr	r2, [pc, #100]	; (7834 <usb_isr+0x858>)
    77d0:	f847 2033 	str.w	r2, [r7, r3, lsl #3]
    77d4:	e7ce      	b.n	7774 <usb_isr+0x798>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    77d6:	4681      	mov	r9, r0
    77d8:	e6a0      	b.n	751c <usb_isr+0x540>
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
		data = reply_buffer;
		datalen = 2;
    77da:	2002      	movs	r0, #2
    77dc:	e603      	b.n	73e6 <usb_isr+0x40a>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
    77de:	4b18      	ldr	r3, [pc, #96]	; (7840 <usb_isr+0x864>)
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    77e0:	f044 0201 	orr.w	r2, r4, #1
					usb_rx_memory_needed++;
    77e4:	781b      	ldrb	r3, [r3, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    77e6:	f847 0032 	str.w	r0, [r7, r2, lsl #3]
					usb_rx_memory_needed++;
    77ea:	4a15      	ldr	r2, [pc, #84]	; (7840 <usb_isr+0x864>)
    77ec:	3301      	adds	r3, #1
    77ee:	7013      	strb	r3, [r2, #0]
    77f0:	e7c0      	b.n	7774 <usb_isr+0x798>
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
    77f2:	4b13      	ldr	r3, [pc, #76]	; (7840 <usb_isr+0x864>)
    77f4:	4a12      	ldr	r2, [pc, #72]	; (7840 <usb_isr+0x864>)
    77f6:	781b      	ldrb	r3, [r3, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    77f8:	ea4f 0489 	mov.w	r4, r9, lsl #2
					usb_rx_memory_needed++;
    77fc:	3301      	adds	r3, #1
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    77fe:	f847 0034 	str.w	r0, [r7, r4, lsl #3]
					usb_rx_memory_needed++;
    7802:	7013      	strb	r3, [r2, #0]
    7804:	e7da      	b.n	77bc <usb_isr+0x7e0>


void _reboot_Teensyduino_(void)
{
	// TODO: initialize R0 with a code....
	__asm__ volatile("bkpt");
    7806:	be00      	bkpt	0x0000
    7808:	2840      	cmp	r0, #64	; 0x40
    780a:	4684      	mov	ip, r0
    780c:	bf28      	it	cs
    780e:	f04f 0c40 	movcs.w	ip, #64	; 0x40
    7812:	eb04 030c 	add.w	r3, r4, ip
    7816:	ebcc 0000 	rsb	r0, ip, r0
    781a:	ea4f 480c 	mov.w	r8, ip, lsl #16
    781e:	9302      	str	r3, [sp, #8]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    7820:	2200      	movs	r2, #0
    7822:	f04f 0901 	mov.w	r9, #1
    7826:	e67e      	b.n	7526 <usb_isr+0x54a>
    7828:	1fff2c71 	.word	0x1fff2c71
    782c:	400720c0 	.word	0x400720c0
    7830:	40072094 	.word	0x40072094
    7834:	004000c8 	.word	0x004000c8
    7838:	00400088 	.word	0x00400088
    783c:	0000c3e8 	.word	0x0000c3e8
    7840:	1fff2cdd 	.word	0x1fff2cdd
    7844:	400720c4 	.word	0x400720c4
    7848:	400720d4 	.word	0x400720d4
    784c:	0000c3e4 	.word	0x0000c3e4

00007850 <usb_init>:
}



void usb_init(void)
{
    7850:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    7852:	f000 fc07 	bl	8064 <usb_init_serialnumber>

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    7856:	2300      	movs	r3, #0
    7858:	4924      	ldr	r1, [pc, #144]	; (78ec <usb_init+0x9c>)
		table[i].desc = 0;
    785a:	461a      	mov	r2, r3
		table[i].addr = 0;
    785c:	eb01 00c3 	add.w	r0, r1, r3, lsl #3
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
		table[i].desc = 0;
    7860:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    7864:	3301      	adds	r3, #1
    7866:	2b14      	cmp	r3, #20
		table[i].desc = 0;
		table[i].addr = 0;
    7868:	6042      	str	r2, [r0, #4]
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
		table[i].desc = 0;
    786a:	f04f 0400 	mov.w	r4, #0
    786e:	481f      	ldr	r0, [pc, #124]	; (78ec <usb_init+0x9c>)
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    7870:	d1f4      	bne.n	785c <usb_init+0xc>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    7872:	491f      	ldr	r1, [pc, #124]	; (78f0 <usb_init+0xa0>)
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    7874:	4a1f      	ldr	r2, [pc, #124]	; (78f4 <usb_init+0xa4>)
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    7876:	680b      	ldr	r3, [r1, #0]
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
#endif
#if F_CPU == 180000000 || F_CPU == 216000000 || F_CPU == 256000000
	// if using IRC48M, turn on the USB clock recovery hardware
	USB0_CLK_RECOVER_IRC_EN = USB_CLK_RECOVER_IRC_EN_IRC_EN | USB_CLK_RECOVER_IRC_EN_REG_EN;
    7878:	f8df c090 	ldr.w	ip, [pc, #144]	; 790c <usb_init+0xbc>
	USB0_CLK_RECOVER_CTRL = USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN |
    787c:	4e1e      	ldr	r6, [pc, #120]	; (78f8 <usb_init+0xa8>)
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    787e:	4f1f      	ldr	r7, [pc, #124]	; (78fc <usb_init+0xac>)
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    7880:	4d1f      	ldr	r5, [pc, #124]	; (7900 <usb_init+0xb0>)

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    7882:	f8df e08c 	ldr.w	lr, [pc, #140]	; 7910 <usb_init+0xc0>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    7886:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    788a:	600b      	str	r3, [r1, #0]
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    788c:	6813      	ldr	r3, [r2, #0]
    788e:	f043 7340 	orr.w	r3, r3, #50331648	; 0x3000000
    7892:	6013      	str	r3, [r2, #0]
#endif
#if F_CPU == 180000000 || F_CPU == 216000000 || F_CPU == 256000000
	// if using IRC48M, turn on the USB clock recovery hardware
	USB0_CLK_RECOVER_IRC_EN = USB_CLK_RECOVER_IRC_EN_IRC_EN | USB_CLK_RECOVER_IRC_EN_REG_EN;
    7894:	2303      	movs	r3, #3
    7896:	f88c 3000 	strb.w	r3, [ip]
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    789a:	f501 3128 	add.w	r1, r1, #172032	; 0x2a000
	MPU_RGDAAC0 |= 0x03000000;
#endif
#if F_CPU == 180000000 || F_CPU == 216000000 || F_CPU == 256000000
	// if using IRC48M, turn on the USB clock recovery hardware
	USB0_CLK_RECOVER_IRC_EN = USB_CLK_RECOVER_IRC_EN_IRC_EN | USB_CLK_RECOVER_IRC_EN_REG_EN;
	USB0_CLK_RECOVER_CTRL = USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN |
    789e:	23a0      	movs	r3, #160	; 0xa0
    78a0:	7033      	strb	r3, [r6, #0]
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    78a2:	317c      	adds	r1, #124	; 0x7c
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    78a4:	f502 22c9 	add.w	r2, r2, #411648	; 0x64800
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    78a8:	f3c0 2307 	ubfx	r3, r0, #8, #8
    78ac:	703b      	strb	r3, [r7, #0]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    78ae:	3210      	adds	r2, #16
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    78b0:	f3c0 4307 	ubfx	r3, r0, #16, #8
    78b4:	700b      	strb	r3, [r1, #0]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    78b6:	0e00      	lsrs	r0, r0, #24

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    78b8:	23ff      	movs	r3, #255	; 0xff
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    78ba:	7028      	strb	r0, [r5, #0]

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    78bc:	f88e 3000 	strb.w	r3, [lr]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    78c0:	4d10      	ldr	r5, [pc, #64]	; (7904 <usb_init+0xb4>)
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
    78c2:	f80c 3cbc 	strb.w	r3, [ip, #-188]
	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    78c6:	4810      	ldr	r0, [pc, #64]	; (7908 <usb_init+0xb8>)
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    78c8:	7013      	strb	r3, [r2, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    78ca:	2301      	movs	r3, #1
    78cc:	f806 3cac 	strb.w	r3, [r6, #-172]
	USB0_USBCTRL = 0;
    78d0:	f881 4050 	strb.w	r4, [r1, #80]	; 0x50

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    78d4:	2670      	movs	r6, #112	; 0x70
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    78d6:	f44f 1400 	mov.w	r4, #2097152	; 0x200000

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    78da:	2110      	movs	r1, #16
	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    78dc:	f807 3c18 	strb.w	r3, [r7, #-24]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    78e0:	702e      	strb	r6, [r5, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    78e2:	6004      	str	r4, [r0, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    78e4:	f882 10f8 	strb.w	r1, [r2, #248]	; 0xf8
    78e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    78ea:	bf00      	nop
    78ec:	1fff0000 	.word	0x1fff0000
    78f0:	40048034 	.word	0x40048034
    78f4:	4000d800 	.word	0x4000d800
    78f8:	40072140 	.word	0x40072140
    78fc:	4007209c 	.word	0x4007209c
    7900:	400720b4 	.word	0x400720b4
    7904:	e000e435 	.word	0xe000e435
    7908:	e000e104 	.word	0xe000e104
    790c:	40072144 	.word	0x40072144
    7910:	40072080 	.word	0x40072080

00007914 <usb_malloc>:
usb_packet_t * usb_malloc(void)
{
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    7914:	b672      	cpsid	i
	avail = usb_buffer_available;
    7916:	480d      	ldr	r0, [pc, #52]	; (794c <usb_malloc+0x38>)
    7918:	6802      	ldr	r2, [r0, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    791a:	fab2 f382 	clz	r3, r2
	if (n >= NUM_USB_BUFFERS) {
    791e:	2b0b      	cmp	r3, #11
    7920:	dc10      	bgt.n	7944 <usb_malloc+0x30>
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    7922:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    7926:	40d9      	lsrs	r1, r3
    7928:	ea22 0201 	bic.w	r2, r2, r1
    792c:	6002      	str	r2, [r0, #0]
	__enable_irq();
    792e:	b662      	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    7930:	4807      	ldr	r0, [pc, #28]	; (7950 <usb_malloc+0x3c>)
    7932:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
    7936:	00db      	lsls	r3, r3, #3
    7938:	18c2      	adds	r2, r0, r3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    793a:	2100      	movs	r1, #0
    793c:	50c1      	str	r1, [r0, r3]
	*(uint32_t *)(p + 4) = 0;
	return (usb_packet_t *)p;
    793e:	4610      	mov	r0, r2
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
	*(uint32_t *)(p + 4) = 0;
    7940:	6051      	str	r1, [r2, #4]
	return (usb_packet_t *)p;
}
    7942:	4770      	bx	lr

	__disable_irq();
	avail = usb_buffer_available;
	n = __builtin_clz(avail); // clz = count leading zeros
	if (n >= NUM_USB_BUFFERS) {
		__enable_irq();
    7944:	b662      	cpsie	i
		return NULL;
    7946:	2000      	movs	r0, #0
    7948:	4770      	bx	lr
    794a:	bf00      	nop
    794c:	1fff0b1c 	.word	0x1fff0b1c
    7950:	1fff03d0 	.word	0x1fff03d0

00007954 <usb_free>:
void usb_free(usb_packet_t *p)
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    7954:	4b0d      	ldr	r3, [pc, #52]	; (798c <usb_free+0x38>)
    7956:	4a0e      	ldr	r2, [pc, #56]	; (7990 <usb_free+0x3c>)
    7958:	1ac3      	subs	r3, r0, r3
    795a:	fba2 2303 	umull	r2, r3, r2, r3
    795e:	091b      	lsrs	r3, r3, #4
	if (n >= NUM_USB_BUFFERS) return;
    7960:	2b0b      	cmp	r3, #11
    7962:	d80c      	bhi.n	797e <usb_free+0x2a>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    7964:	4a0b      	ldr	r2, [pc, #44]	; (7994 <usb_free+0x40>)
    7966:	7812      	ldrb	r2, [r2, #0]
    7968:	b952      	cbnz	r2, 7980 <usb_free+0x2c>
		usb_rx_memory(p);
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    796a:	b672      	cpsid	i
	usb_buffer_available |= mask;
    796c:	480a      	ldr	r0, [pc, #40]	; (7998 <usb_free+0x44>)
    796e:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    7972:	6802      	ldr	r2, [r0, #0]
    7974:	fa21 f303 	lsr.w	r3, r1, r3
    7978:	431a      	orrs	r2, r3
    797a:	6002      	str	r2, [r0, #0]
	__enable_irq();
    797c:	b662      	cpsie	i
    797e:	4770      	bx	lr
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    7980:	4a06      	ldr	r2, [pc, #24]	; (799c <usb_free+0x48>)
    7982:	7812      	ldrb	r2, [r2, #0]
    7984:	2a00      	cmp	r2, #0
    7986:	d0f0      	beq.n	796a <usb_free+0x16>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    7988:	f7ff baa4 	b.w	6ed4 <usb_rx_memory>
    798c:	1fff03d0 	.word	0x1fff03d0
    7990:	38e38e39 	.word	0x38e38e39
    7994:	1fff2cdd 	.word	0x1fff2cdd
    7998:	1fff0b1c 	.word	0x1fff0b1c
    799c:	1fff2ce8 	.word	0x1fff2ce8

000079a0 <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    79a0:	b538      	push	{r3, r4, r5, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    79a2:	4d0f      	ldr	r5, [pc, #60]	; (79e0 <usb_serial_getchar+0x40>)
    79a4:	6828      	ldr	r0, [r5, #0]
    79a6:	b178      	cbz	r0, 79c8 <usb_serial_getchar+0x28>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    79a8:	8843      	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
    79aa:	8802      	ldrh	r2, [r0, #0]
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    79ac:	18c1      	adds	r1, r0, r3
    79ae:	3301      	adds	r3, #1
	if (i >= rx_packet->len) {
    79b0:	4293      	cmp	r3, r2
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    79b2:	7a0c      	ldrb	r4, [r1, #8]
	if (i >= rx_packet->len) {
    79b4:	d202      	bcs.n	79bc <usb_serial_getchar+0x1c>
		usb_free(rx_packet);
		rx_packet = NULL;
	} else {
		rx_packet->index = i;
    79b6:	8043      	strh	r3, [r0, #2]
	}
	return c;
    79b8:	4620      	mov	r0, r4
}
    79ba:	bd38      	pop	{r3, r4, r5, pc}
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
    79bc:	f7ff ffca 	bl	7954 <usb_free>
		rx_packet = NULL;
    79c0:	2300      	movs	r3, #0
	} else {
		rx_packet->index = i;
	}
	return c;
    79c2:	4620      	mov	r0, r4
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
		rx_packet = NULL;
    79c4:	602b      	str	r3, [r5, #0]
    79c6:	bd38      	pop	{r3, r4, r5, pc}
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    79c8:	4b06      	ldr	r3, [pc, #24]	; (79e4 <usb_serial_getchar+0x44>)
    79ca:	781b      	ldrb	r3, [r3, #0]
    79cc:	b12b      	cbz	r3, 79da <usb_serial_getchar+0x3a>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    79ce:	2003      	movs	r0, #3
    79d0:	f7ff fa4c 	bl	6e6c <usb_rx>
    79d4:	6028      	str	r0, [r5, #0]
		if (!rx_packet) return -1;
    79d6:	2800      	cmp	r0, #0
    79d8:	d1e6      	bne.n	79a8 <usb_serial_getchar+0x8>
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    79da:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    79de:	bd38      	pop	{r3, r4, r5, pc}
    79e0:	1fff2cfc 	.word	0x1fff2cfc
    79e4:	1fff2ce8 	.word	0x1fff2ce8

000079e8 <usb_serial_peekchar>:
	return c;
}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    79e8:	b510      	push	{r4, lr}
	if (!rx_packet) {
    79ea:	4c09      	ldr	r4, [pc, #36]	; (7a10 <usb_serial_peekchar+0x28>)
    79ec:	6820      	ldr	r0, [r4, #0]
    79ee:	b118      	cbz	r0, 79f8 <usb_serial_peekchar+0x10>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
	return rx_packet->buf[rx_packet->index];
    79f0:	8843      	ldrh	r3, [r0, #2]
    79f2:	4418      	add	r0, r3
    79f4:	7a00      	ldrb	r0, [r0, #8]
}
    79f6:	bd10      	pop	{r4, pc}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    79f8:	4b06      	ldr	r3, [pc, #24]	; (7a14 <usb_serial_peekchar+0x2c>)
    79fa:	781b      	ldrb	r3, [r3, #0]
    79fc:	b12b      	cbz	r3, 7a0a <usb_serial_peekchar+0x22>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    79fe:	2003      	movs	r0, #3
    7a00:	f7ff fa34 	bl	6e6c <usb_rx>
    7a04:	6020      	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    7a06:	2800      	cmp	r0, #0
    7a08:	d1f2      	bne.n	79f0 <usb_serial_peekchar+0x8>

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    7a0a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7a0e:	bd10      	pop	{r4, pc}
    7a10:	1fff2cfc 	.word	0x1fff2cfc
    7a14:	1fff2ce8 	.word	0x1fff2ce8

00007a18 <usb_serial_available>:
// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    7a18:	4b04      	ldr	r3, [pc, #16]	; (7a2c <usb_serial_available+0x14>)
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    7a1a:	4a05      	ldr	r2, [pc, #20]	; (7a30 <usb_serial_available+0x18>)
    7a1c:	681b      	ldr	r3, [r3, #0]

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    7a1e:	8890      	ldrh	r0, [r2, #4]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    7a20:	b11b      	cbz	r3, 7a2a <usb_serial_available+0x12>
    7a22:	881a      	ldrh	r2, [r3, #0]
    7a24:	885b      	ldrh	r3, [r3, #2]
    7a26:	1ad3      	subs	r3, r2, r3
    7a28:	4418      	add	r0, r3
	return count;
}
    7a2a:	4770      	bx	lr
    7a2c:	1fff2cfc 	.word	0x1fff2cfc
    7a30:	1fff2d68 	.word	0x1fff2d68

00007a34 <usb_serial_flush_input>:
// discard any buffered input
void usb_serial_flush_input(void)
{
	usb_packet_t *rx;

	if (!usb_configuration) return;
    7a34:	4b0b      	ldr	r3, [pc, #44]	; (7a64 <usb_serial_flush_input+0x30>)
    7a36:	781b      	ldrb	r3, [r3, #0]
    7a38:	b19b      	cbz	r3, 7a62 <usb_serial_flush_input+0x2e>
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    7a3a:	b510      	push	{r4, lr}
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
    7a3c:	4c0a      	ldr	r4, [pc, #40]	; (7a68 <usb_serial_flush_input+0x34>)
    7a3e:	6820      	ldr	r0, [r4, #0]
    7a40:	b148      	cbz	r0, 7a56 <usb_serial_flush_input+0x22>
		usb_free(rx_packet);
    7a42:	f7ff ff87 	bl	7954 <usb_free>
		rx_packet = NULL;
    7a46:	2300      	movs	r3, #0
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    7a48:	2003      	movs	r0, #3
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
    7a4a:	6023      	str	r3, [r4, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    7a4c:	f7ff fa0e 	bl	6e6c <usb_rx>
		if (!rx) break;
    7a50:	b130      	cbz	r0, 7a60 <usb_serial_flush_input+0x2c>
		usb_free(rx);
    7a52:	f7ff ff7f 	bl	7954 <usb_free>
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    7a56:	2003      	movs	r0, #3
    7a58:	f7ff fa08 	bl	6e6c <usb_rx>
		if (!rx) break;
    7a5c:	2800      	cmp	r0, #0
    7a5e:	d1f8      	bne.n	7a52 <usb_serial_flush_input+0x1e>
    7a60:	bd10      	pop	{r4, pc}
    7a62:	4770      	bx	lr
    7a64:	1fff2ce8 	.word	0x1fff2ce8
    7a68:	1fff2cfc 	.word	0x1fff2cfc

00007a6c <usb_serial_write>:
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    7a6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    7a70:	f8df 90f8 	ldr.w	r9, [pc, #248]	; 7b6c <usb_serial_write+0x100>
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    7a74:	b083      	sub	sp, #12
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    7a76:	2201      	movs	r2, #1
    7a78:	f889 2000 	strb.w	r2, [r9]
	while (size > 0) {
    7a7c:	9101      	str	r1, [sp, #4]
    7a7e:	b369      	cbz	r1, 7adc <usb_serial_write+0x70>
    7a80:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 7b70 <usb_serial_write+0x104>
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    7a84:	4f35      	ldr	r7, [pc, #212]	; (7b5c <usb_serial_write+0xf0>)
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    7a86:	9e01      	ldr	r6, [sp, #4]
    7a88:	4683      	mov	fp, r0
		if (!tx_packet) {
    7a8a:	f8d8 0000 	ldr.w	r0, [r8]
    7a8e:	b3b0      	cbz	r0, 7afe <usb_serial_write+0x92>
    7a90:	4d33      	ldr	r5, [pc, #204]	; (7b60 <usb_serial_write+0xf4>)
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
    7a92:	8844      	ldrh	r4, [r0, #2]
    7a94:	f1c4 0140 	rsb	r1, r4, #64	; 0x40
    7a98:	42b1      	cmp	r1, r6
    7a9a:	bf28      	it	cs
    7a9c:	4631      	movcs	r1, r6
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    7a9e:	eb04 0e01 	add.w	lr, r4, r1
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    7aa2:	2200      	movs	r2, #0
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    7aa4:	fa1f fe8e 	uxth.w	lr, lr
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    7aa8:	702a      	strb	r2, [r5, #0]
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
    7aaa:	1a76      	subs	r6, r6, r1
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    7aac:	f8a0 e002 	strh.w	lr, [r0, #2]
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
    7ab0:	f100 0208 	add.w	r2, r0, #8
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
    7ab4:	b151      	cbz	r1, 7acc <usb_serial_write+0x60>
    7ab6:	3c01      	subs	r4, #1
    7ab8:	4422      	add	r2, r4
    7aba:	4459      	add	r1, fp
    7abc:	f81b 4b01 	ldrb.w	r4, [fp], #1
    7ac0:	f802 4f01 	strb.w	r4, [r2, #1]!
    7ac4:	458b      	cmp	fp, r1
    7ac6:	d1f9      	bne.n	7abc <usb_serial_write+0x50>
    7ac8:	f8b0 e002 	ldrh.w	lr, [r0, #2]
		if (tx_packet->index >= CDC_TX_SIZE) {
    7acc:	f1be 0f3f 	cmp.w	lr, #63	; 0x3f
    7ad0:	d80b      	bhi.n	7aea <usb_serial_write+0x7e>
			tx_packet->len = CDC_TX_SIZE;
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    7ad2:	4a24      	ldr	r2, [pc, #144]	; (7b64 <usb_serial_write+0xf8>)
    7ad4:	2105      	movs	r1, #5
    7ad6:	7011      	strb	r1, [r2, #0]
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    7ad8:	2e00      	cmp	r6, #0
    7ada:	d1d6      	bne.n	7a8a <usb_serial_write+0x1e>
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
    7adc:	9801      	ldr	r0, [sp, #4]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
    7ade:	2300      	movs	r3, #0
    7ae0:	f889 3000 	strb.w	r3, [r9]
	return ret;
}
    7ae4:	b003      	add	sp, #12
    7ae6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
		if (tx_packet->index >= CDC_TX_SIZE) {
			tx_packet->len = CDC_TX_SIZE;
    7aea:	2240      	movs	r2, #64	; 0x40
    7aec:	8002      	strh	r2, [r0, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    7aee:	4601      	mov	r1, r0
    7af0:	2004      	movs	r0, #4
    7af2:	f7ff fa31 	bl	6f58 <usb_tx>
			tx_packet = NULL;
    7af6:	2200      	movs	r2, #0
    7af8:	f8c8 2000 	str.w	r2, [r8]
    7afc:	e7e9      	b.n	7ad2 <usb_serial_write+0x66>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    7afe:	783a      	ldrb	r2, [r7, #0]
    7b00:	b322      	cbz	r2, 7b4c <usb_serial_write+0xe0>
    7b02:	4c19      	ldr	r4, [pc, #100]	; (7b68 <usb_serial_write+0xfc>)
    7b04:	4d16      	ldr	r5, [pc, #88]	; (7b60 <usb_serial_write+0xf4>)
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
    7b06:	f04f 0a01 	mov.w	sl, #1
    7b0a:	e007      	b.n	7b1c <usb_serial_write+0xb0>
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    7b0c:	3c01      	subs	r4, #1
    7b0e:	d016      	beq.n	7b3e <usb_serial_write+0xd2>
    7b10:	782a      	ldrb	r2, [r5, #0]
    7b12:	b9a2      	cbnz	r2, 7b3e <usb_serial_write+0xd2>
					transmit_previous_timeout = 1;
					return -1;
				}
				yield();
    7b14:	f000 f95e 	bl	7dd4 <yield>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    7b18:	783a      	ldrb	r2, [r7, #0]
    7b1a:	b1ba      	cbz	r2, 7b4c <usb_serial_write+0xe0>
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    7b1c:	2004      	movs	r0, #4
    7b1e:	f7ff f9c3 	bl	6ea8 <usb_tx_packet_count>
    7b22:	2807      	cmp	r0, #7
    7b24:	d8f2      	bhi.n	7b0c <usb_serial_write+0xa0>
					tx_noautoflush = 1;
    7b26:	f889 a000 	strb.w	sl, [r9]
					tx_packet = usb_malloc();
    7b2a:	f7ff fef3 	bl	7914 <usb_malloc>
    7b2e:	f8c8 0000 	str.w	r0, [r8]
					if (tx_packet) break;
    7b32:	2800      	cmp	r0, #0
    7b34:	d1ad      	bne.n	7a92 <usb_serial_write+0x26>
					tx_noautoflush = 0;
    7b36:	4b0d      	ldr	r3, [pc, #52]	; (7b6c <usb_serial_write+0x100>)
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    7b38:	3c01      	subs	r4, #1
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
    7b3a:	7018      	strb	r0, [r3, #0]
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    7b3c:	d1e8      	bne.n	7b10 <usb_serial_write+0xa4>
					transmit_previous_timeout = 1;
    7b3e:	2301      	movs	r3, #1
					return -1;
    7b40:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
					transmit_previous_timeout = 1;
    7b44:	702b      	strb	r3, [r5, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    7b46:	b003      	add	sp, #12
    7b48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    7b4c:	2300      	movs	r3, #0
					return -1;
    7b4e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    7b52:	f889 3000 	strb.w	r3, [r9]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    7b56:	b003      	add	sp, #12
    7b58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7b5c:	1fff2ce8 	.word	0x1fff2ce8
    7b60:	1fff2cf8 	.word	0x1fff2cf8
    7b64:	1fff2cf0 	.word	0x1fff2cf0
    7b68:	00014821 	.word	0x00014821
    7b6c:	1fff2cf1 	.word	0x1fff2cf1
    7b70:	1fff2cf4 	.word	0x1fff2cf4

00007b74 <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    7b74:	b500      	push	{lr}
    7b76:	b083      	sub	sp, #12
    7b78:	ab02      	add	r3, sp, #8
	return usb_serial_write(&c, 1);
    7b7a:	2101      	movs	r1, #1
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    7b7c:	f803 0d01 	strb.w	r0, [r3, #-1]!
	return usb_serial_write(&c, 1);
    7b80:	4618      	mov	r0, r3
    7b82:	f7ff ff73 	bl	7a6c <usb_serial_write>
}
    7b86:	b003      	add	sp, #12
    7b88:	f85d fb04 	ldr.w	pc, [sp], #4

00007b8c <usb_serial_write_buffer_free>:
	tx_noautoflush = 0;
	return ret;
}

int usb_serial_write_buffer_free(void)
{
    7b8c:	b538      	push	{r3, r4, r5, lr}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
    7b8e:	4d0e      	ldr	r5, [pc, #56]	; (7bc8 <usb_serial_write_buffer_free+0x3c>)

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    7b90:	4c0e      	ldr	r4, [pc, #56]	; (7bcc <usb_serial_write_buffer_free+0x40>)
	if (!tx_packet) {
    7b92:	6828      	ldr	r0, [r5, #0]

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    7b94:	2301      	movs	r3, #1
    7b96:	7023      	strb	r3, [r4, #0]
	if (!tx_packet) {
    7b98:	b128      	cbz	r0, 7ba6 <usb_serial_write_buffer_free+0x1a>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    7b9a:	8840      	ldrh	r0, [r0, #2]
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    7b9c:	2300      	movs	r3, #0
    7b9e:	7023      	strb	r3, [r4, #0]
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    7ba0:	f1c0 0040 	rsb	r0, r0, #64	; 0x40
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
	return len;
}
    7ba4:	bd38      	pop	{r3, r4, r5, pc}
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    7ba6:	4b0a      	ldr	r3, [pc, #40]	; (7bd0 <usb_serial_write_buffer_free+0x44>)
    7ba8:	781b      	ldrb	r3, [r3, #0]
    7baa:	b913      	cbnz	r3, 7bb2 <usb_serial_write_buffer_free+0x26>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    7bac:	2000      	movs	r0, #0
    7bae:	7020      	strb	r0, [r4, #0]
			return 0;
    7bb0:	bd38      	pop	{r3, r4, r5, pc}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    7bb2:	2004      	movs	r0, #4
    7bb4:	f7ff f978 	bl	6ea8 <usb_tx_packet_count>
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    7bb8:	2807      	cmp	r0, #7
    7bba:	d8f7      	bhi.n	7bac <usb_serial_write_buffer_free+0x20>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
    7bbc:	f7ff feaa 	bl	7914 <usb_malloc>
    7bc0:	6028      	str	r0, [r5, #0]
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    7bc2:	2800      	cmp	r0, #0
    7bc4:	d1e9      	bne.n	7b9a <usb_serial_write_buffer_free+0xe>
    7bc6:	e7f1      	b.n	7bac <usb_serial_write_buffer_free+0x20>
    7bc8:	1fff2cf4 	.word	0x1fff2cf4
    7bcc:	1fff2cf1 	.word	0x1fff2cf1
    7bd0:	1fff2ce8 	.word	0x1fff2ce8

00007bd4 <usb_serial_flush_output>:
	tx_noautoflush = 0;
	return len;
}

void usb_serial_flush_output(void)
{
    7bd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!usb_configuration) return;
    7bd6:	4b11      	ldr	r3, [pc, #68]	; (7c1c <usb_serial_flush_output+0x48>)
    7bd8:	781b      	ldrb	r3, [r3, #0]
    7bda:	b18b      	cbz	r3, 7c00 <usb_serial_flush_output+0x2c>
	tx_noautoflush = 1;
	if (tx_packet) {
    7bdc:	4e10      	ldr	r6, [pc, #64]	; (7c20 <usb_serial_flush_output+0x4c>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    7bde:	4d11      	ldr	r5, [pc, #68]	; (7c24 <usb_serial_flush_output+0x50>)
	if (tx_packet) {
    7be0:	6834      	ldr	r4, [r6, #0]
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    7be2:	2701      	movs	r7, #1
    7be4:	702f      	strb	r7, [r5, #0]
	if (tx_packet) {
    7be6:	b164      	cbz	r4, 7c02 <usb_serial_flush_output+0x2e>
		usb_cdc_transmit_flush_timer = 0;
    7be8:	4a0f      	ldr	r2, [pc, #60]	; (7c28 <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
    7bea:	8863      	ldrh	r3, [r4, #2]
void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
    7bec:	2700      	movs	r7, #0
    7bee:	7017      	strb	r7, [r2, #0]
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    7bf0:	4621      	mov	r1, r4
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
    7bf2:	8023      	strh	r3, [r4, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    7bf4:	2004      	movs	r0, #4
    7bf6:	f7ff f9af 	bl	6f58 <usb_tx>
		tx_packet = NULL;
    7bfa:	6037      	str	r7, [r6, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
	tx_noautoflush = 0;
    7bfc:	2300      	movs	r3, #0
    7bfe:	702b      	strb	r3, [r5, #0]
    7c00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    7c02:	f7ff fe87 	bl	7914 <usb_malloc>
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    7c06:	4b08      	ldr	r3, [pc, #32]	; (7c28 <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
    7c08:	b128      	cbz	r0, 7c16 <usb_serial_flush_output+0x42>
			usb_cdc_transmit_flush_timer = 0;
			usb_tx(CDC_TX_ENDPOINT, tx);
    7c0a:	4601      	mov	r1, r0
    7c0c:	2004      	movs	r0, #4
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    7c0e:	701c      	strb	r4, [r3, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    7c10:	f7ff f9a2 	bl	6f58 <usb_tx>
    7c14:	e7f2      	b.n	7bfc <usb_serial_flush_output+0x28>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    7c16:	701f      	strb	r7, [r3, #0]
    7c18:	e7f0      	b.n	7bfc <usb_serial_flush_output+0x28>
    7c1a:	bf00      	nop
    7c1c:	1fff2ce8 	.word	0x1fff2ce8
    7c20:	1fff2cf4 	.word	0x1fff2cf4
    7c24:	1fff2cf1 	.word	0x1fff2cf1
    7c28:	1fff2cf0 	.word	0x1fff2cf0

00007c2c <usb_serial_flush_callback>:
	}
	tx_noautoflush = 0;
}

void usb_serial_flush_callback(void)
{
    7c2c:	b538      	push	{r3, r4, r5, lr}
	if (tx_noautoflush) return;
    7c2e:	4b0e      	ldr	r3, [pc, #56]	; (7c68 <usb_serial_flush_callback+0x3c>)
    7c30:	781b      	ldrb	r3, [r3, #0]
    7c32:	b973      	cbnz	r3, 7c52 <usb_serial_flush_callback+0x26>
	if (tx_packet) {
    7c34:	4c0d      	ldr	r4, [pc, #52]	; (7c6c <usb_serial_flush_callback+0x40>)
    7c36:	6821      	ldr	r1, [r4, #0]
    7c38:	b161      	cbz	r1, 7c54 <usb_serial_flush_callback+0x28>
    7c3a:	f003 05ff 	and.w	r5, r3, #255	; 0xff
		tx_packet->len = tx_packet->index;
    7c3e:	884b      	ldrh	r3, [r1, #2]
    7c40:	800b      	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    7c42:	2004      	movs	r0, #4
    7c44:	f7ff f988 	bl	6f58 <usb_tx>
		tx_packet = NULL;
    7c48:	6025      	str	r5, [r4, #0]
    7c4a:	bd38      	pop	{r3, r4, r5, pc}
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
    7c4c:	4b08      	ldr	r3, [pc, #32]	; (7c70 <usb_serial_flush_callback+0x44>)
    7c4e:	2201      	movs	r2, #1
    7c50:	701a      	strb	r2, [r3, #0]
    7c52:	bd38      	pop	{r3, r4, r5, pc}
	if (tx_packet) {
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    7c54:	f7ff fe5e 	bl	7914 <usb_malloc>
		if (tx) {
    7c58:	2800      	cmp	r0, #0
    7c5a:	d0f7      	beq.n	7c4c <usb_serial_flush_callback+0x20>
			usb_tx(CDC_TX_ENDPOINT, tx);
    7c5c:	4601      	mov	r1, r0
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    7c5e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
    7c62:	2004      	movs	r0, #4
    7c64:	f7ff b978 	b.w	6f58 <usb_tx>
    7c68:	1fff2cf1 	.word	0x1fff2cf1
    7c6c:	1fff2cf4 	.word	0x1fff2cf4
    7c70:	1fff2cf0 	.word	0x1fff2cf0

00007c74 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    7c74:	b570      	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    7c76:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    7c7a:	b672      	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    7c7c:	4c0c      	ldr	r4, [pc, #48]	; (7cb0 <EventResponder::runFromInterrupt()+0x3c>)
    7c7e:	6820      	ldr	r0, [r4, #0]
		if (first) {
    7c80:	b180      	cbz	r0, 7ca4 <EventResponder::runFromInterrupt()+0x30>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    7c82:	4e0c      	ldr	r6, [pc, #48]	; (7cb4 <EventResponder::runFromInterrupt()+0x40>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    7c84:	2500      	movs	r5, #0
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
    7c86:	6943      	ldr	r3, [r0, #20]
    7c88:	6023      	str	r3, [r4, #0]
			if (firstInterrupt) {
    7c8a:	b173      	cbz	r3, 7caa <EventResponder::runFromInterrupt()+0x36>
				firstInterrupt->_prev = nullptr;
    7c8c:	619d      	str	r5, [r3, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    7c8e:	b902      	cbnz	r2, 7c92 <EventResponder::runFromInterrupt()+0x1e>
    7c90:	b662      	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    7c92:	7745      	strb	r5, [r0, #29]
			(*(first->_function))(*first);
    7c94:	6883      	ldr	r3, [r0, #8]
    7c96:	4798      	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    7c98:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    7c9c:	b672      	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    7c9e:	6820      	ldr	r0, [r4, #0]
		if (first) {
    7ca0:	2800      	cmp	r0, #0
    7ca2:	d1f0      	bne.n	7c86 <EventResponder::runFromInterrupt()+0x12>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    7ca4:	b902      	cbnz	r2, 7ca8 <EventResponder::runFromInterrupt()+0x34>
    7ca6:	b662      	cpsie	i
    7ca8:	bd70      	pop	{r4, r5, r6, pc}
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    7caa:	6033      	str	r3, [r6, #0]
    7cac:	e7ef      	b.n	7c8e <EventResponder::runFromInterrupt()+0x1a>
    7cae:	bf00      	nop
    7cb0:	1fff2d04 	.word	0x1fff2d04
    7cb4:	1fff2d08 	.word	0x1fff2d08

00007cb8 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    7cb8:	f7ff bfdc 	b.w	7c74 <EventResponder::runFromInterrupt()>

00007cbc <systick_isr>:

extern "C" volatile uint32_t systick_millis_count;

void systick_isr(void)
{
	systick_millis_count++;
    7cbc:	4a02      	ldr	r2, [pc, #8]	; (7cc8 <systick_isr+0xc>)
    7cbe:	6813      	ldr	r3, [r2, #0]
    7cc0:	3301      	adds	r3, #1
    7cc2:	6013      	str	r3, [r2, #0]
    7cc4:	4770      	bx	lr
    7cc6:	bf00      	nop
    7cc8:	1fff2c04 	.word	0x1fff2c04

00007ccc <String::~String()>:
	init();
	char buf[40];
	*this = dtostrf(num, digits + 2, digits, buf);
}

String::~String()
    7ccc:	b510      	push	{r4, lr}
    7cce:	4604      	mov	r4, r0
{
	free(buffer);
    7cd0:	6800      	ldr	r0, [r0, #0]
    7cd2:	f002 fded 	bl	a8b0 <free>
}
    7cd6:	4620      	mov	r0, r4
    7cd8:	bd10      	pop	{r4, pc}
    7cda:	bf00      	nop

00007cdc <String::reserve(unsigned int)>:
	len = 0;
	flags = 0;
}

unsigned char String::reserve(unsigned int size)
{
    7cdc:	b538      	push	{r3, r4, r5, lr}
	if (capacity >= size) return 1;
    7cde:	6843      	ldr	r3, [r0, #4]
    7ce0:	428b      	cmp	r3, r1
    7ce2:	d301      	bcc.n	7ce8 <String::reserve(unsigned int)+0xc>
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    7ce4:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
    7ce6:	bd38      	pop	{r3, r4, r5, pc}
    7ce8:	460d      	mov	r5, r1
    7cea:	4604      	mov	r4, r0

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
    7cec:	3101      	adds	r1, #1
    7cee:	6800      	ldr	r0, [r0, #0]
    7cf0:	f003 f954 	bl	af9c <realloc>
	if (newbuffer) {
    7cf4:	2800      	cmp	r0, #0
    7cf6:	d0f6      	beq.n	7ce6 <String::reserve(unsigned int)+0xa>

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    7cf8:	68a3      	ldr	r3, [r4, #8]
unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
	if (newbuffer) {
		buffer = newbuffer;
		capacity = maxStrLen;
    7cfa:	e884 0021 	stmia.w	r4, {r0, r5}

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    7cfe:	2b00      	cmp	r3, #0
    7d00:	d1f0      	bne.n	7ce4 <String::reserve(unsigned int)+0x8>
    7d02:	7003      	strb	r3, [r0, #0]
    7d04:	e7ee      	b.n	7ce4 <String::reserve(unsigned int)+0x8>
    7d06:	bf00      	nop

00007d08 <String::copy(char const*, unsigned int)>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
    7d08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7d0a:	4604      	mov	r4, r0
	if (length == 0) {
    7d0c:	4615      	mov	r5, r2
    7d0e:	b932      	cbnz	r2, 7d1e <String::copy(char const*, unsigned int)+0x16>
		if (buffer) buffer[0] = 0;
    7d10:	6803      	ldr	r3, [r0, #0]
    7d12:	b103      	cbz	r3, 7d16 <String::copy(char const*, unsigned int)+0xe>
    7d14:	701a      	strb	r2, [r3, #0]
		len = 0;
    7d16:	2300      	movs	r3, #0
    7d18:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    7d1a:	4620      	mov	r0, r4
    7d1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7d1e:	460e      	mov	r6, r1
	if (length == 0) {
		if (buffer) buffer[0] = 0;
		len = 0;
		return *this;
	}
	if (!reserve(length)) {
    7d20:	4611      	mov	r1, r2
    7d22:	f7ff ffdb 	bl	7cdc <String::reserve(unsigned int)>
    7d26:	4607      	mov	r7, r0
    7d28:	b948      	cbnz	r0, 7d3e <String::copy(char const*, unsigned int)+0x36>
		if (buffer) {
    7d2a:	6820      	ldr	r0, [r4, #0]
    7d2c:	b110      	cbz	r0, 7d34 <String::copy(char const*, unsigned int)+0x2c>
			free(buffer);
    7d2e:	f002 fdbf 	bl	a8b0 <free>
			buffer = NULL;
    7d32:	6027      	str	r7, [r4, #0]
		}
		len = capacity = 0;
    7d34:	2300      	movs	r3, #0
    7d36:	6063      	str	r3, [r4, #4]
    7d38:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    7d3a:	4620      	mov	r0, r4
    7d3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			buffer = NULL;
		}
		len = capacity = 0;
		return *this;
	}
	len = length;
    7d3e:	60a5      	str	r5, [r4, #8]
	strcpy(buffer, cstr);
    7d40:	4631      	mov	r1, r6
    7d42:	6820      	ldr	r0, [r4, #0]
    7d44:	f003 fcaa 	bl	b69c <strcpy>
	return *this;
    7d48:	e7e7      	b.n	7d1a <String::copy(char const*, unsigned int)+0x12>
    7d4a:	bf00      	nop

00007d4c <String::String(char const*)>:

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    7d4c:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    7d4e:	2300      	movs	r3, #0

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    7d50:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    7d52:	6003      	str	r3, [r0, #0]
	capacity = 0;
    7d54:	6043      	str	r3, [r0, #4]
	len = 0;
    7d56:	6083      	str	r3, [r0, #8]
	flags = 0;
    7d58:	7303      	strb	r3, [r0, #12]
/*********************************************/

String::String(const char *cstr)
{
	init();
	if (cstr) copy(cstr, strlen(cstr));
    7d5a:	b141      	cbz	r1, 7d6e <String::String(char const*)+0x22>
    7d5c:	4608      	mov	r0, r1
    7d5e:	460d      	mov	r5, r1
    7d60:	f003 fd0e 	bl	b780 <strlen>
    7d64:	4629      	mov	r1, r5
    7d66:	4602      	mov	r2, r0
    7d68:	4620      	mov	r0, r4
    7d6a:	f7ff ffcd 	bl	7d08 <String::copy(char const*, unsigned int)>
}
    7d6e:	4620      	mov	r0, r4
    7d70:	bd38      	pop	{r3, r4, r5, pc}
    7d72:	bf00      	nop

00007d74 <String::equals(char const*) const>:
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    7d74:	6882      	ldr	r2, [r0, #8]
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
    7d76:	b508      	push	{r3, lr}
    7d78:	460b      	mov	r3, r1
	if (len == 0) return (cstr == NULL || *cstr == 0);
    7d7a:	b92a      	cbnz	r2, 7d88 <String::equals(char const*) const+0x14>
    7d7c:	b171      	cbz	r1, 7d9c <String::equals(char const*) const+0x28>
	if (cstr == NULL) return buffer[0] == 0;
    7d7e:	7818      	ldrb	r0, [r3, #0]
    7d80:	fab0 f080 	clz	r0, r0
    7d84:	0940      	lsrs	r0, r0, #5
    7d86:	bd08      	pop	{r3, pc}
    7d88:	b131      	cbz	r1, 7d98 <String::equals(char const*) const+0x24>
	return strcmp(buffer, cstr) == 0;
    7d8a:	6800      	ldr	r0, [r0, #0]
    7d8c:	f003 fb1c 	bl	b3c8 <strcmp>
    7d90:	fab0 f080 	clz	r0, r0
    7d94:	0940      	lsrs	r0, r0, #5
}
    7d96:	bd08      	pop	{r3, pc}
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
	if (cstr == NULL) return buffer[0] == 0;
    7d98:	6803      	ldr	r3, [r0, #0]
    7d9a:	e7f0      	b.n	7d7e <String::equals(char const*) const+0xa>
    7d9c:	2001      	movs	r0, #1
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    7d9e:	bd08      	pop	{r3, pc}

00007da0 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    7da0:	b508      	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    7da2:	f7fa fcdd 	bl	2760 <setup>
	while (1) {
		loop();
    7da6:	f7fa fdcf 	bl	2948 <loop>
		yield();
    7daa:	f000 f813 	bl	7dd4 <yield>
    7dae:	e7fa      	b.n	7da6 <main+0x6>

00007db0 <operator new(unsigned int)>:
    7db0:	f002 bd76 	b.w	a8a0 <malloc>

00007db4 <operator delete(void*, unsigned int)>:
    7db4:	f002 bd7c 	b.w	a8b0 <free>

00007db8 <usb_serial_class::clear()>:
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    7db8:	f7ff be3c 	b.w	7a34 <usb_serial_flush_input>

00007dbc <usb_serial_class::peek()>:
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    7dbc:	f7ff be14 	b.w	79e8 <usb_serial_peekchar>

00007dc0 <usb_serial_class::available()>:
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    7dc0:	f7ff be2a 	b.w	7a18 <usb_serial_available>

00007dc4 <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    7dc4:	f7ff bf06 	b.w	7bd4 <usb_serial_flush_output>

00007dc8 <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    7dc8:	f7ff bee0 	b.w	7b8c <usb_serial_write_buffer_free>

00007dcc <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    7dcc:	4608      	mov	r0, r1
    7dce:	f7ff bed1 	b.w	7b74 <usb_serial_putchar>
    7dd2:	bf00      	nop

00007dd4 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    7dd4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    7dd8:	4e31      	ldr	r6, [pc, #196]	; (7ea0 <yield+0xcc>)
    7dda:	7833      	ldrb	r3, [r6, #0]
    7ddc:	b193      	cbz	r3, 7e04 <yield+0x30>
	if (running) return; // TODO: does this need to be atomic?
    7dde:	4f31      	ldr	r7, [pc, #196]	; (7ea4 <yield+0xd0>)
    7de0:	783a      	ldrb	r2, [r7, #0]
    7de2:	b97a      	cbnz	r2, 7e04 <yield+0x30>
	running = 1;
    7de4:	2201      	movs	r2, #1


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    7de6:	07d9      	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    7de8:	703a      	strb	r2, [r7, #0]


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    7dea:	d436      	bmi.n	7e5a <yield+0x86>
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIALUSB2) {
		if (SerialUSB2.available()) serialEventUSB2();
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    7dec:	079a      	lsls	r2, r3, #30
    7dee:	d419      	bmi.n	7e24 <yield+0x50>
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    7df0:	2200      	movs	r2, #0
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    7df2:	075b      	lsls	r3, r3, #29
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    7df4:	703a      	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    7df6:	d505      	bpl.n	7e04 <yield+0x30>
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;  
    7df8:	4b2b      	ldr	r3, [pc, #172]	; (7ea8 <yield+0xd4>)
    7dfa:	681a      	ldr	r2, [r3, #0]
    7dfc:	b112      	cbz	r2, 7e04 <yield+0x30>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    7dfe:	f3ef 8205 	mrs	r2, IPSR
		if (ipsr != 0) return;
    7e02:	b10a      	cbz	r2, 7e08 <yield+0x34>
    7e04:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    7e08:	f3ef 8110 	mrs	r1, PRIMASK
		__disable_irq();
    7e0c:	b672      	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    7e0e:	6818      	ldr	r0, [r3, #0]
		if (first == nullptr) {
    7e10:	b118      	cbz	r0, 7e1a <yield+0x46>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    7e12:	4c26      	ldr	r4, [pc, #152]	; (7eac <yield+0xd8>)
    7e14:	7822      	ldrb	r2, [r4, #0]
    7e16:	2a00      	cmp	r2, #0
    7e18:	d02e      	beq.n	7e78 <yield+0xa4>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    7e1a:	2900      	cmp	r1, #0
    7e1c:	d1f2      	bne.n	7e04 <yield+0x30>
    7e1e:	b662      	cpsie	i
    7e20:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    7e24:	f8df 8090 	ldr.w	r8, [pc, #144]	; 7eb8 <yield+0xe4>
    7e28:	f898 2000 	ldrb.w	r2, [r8]
    7e2c:	2a00      	cmp	r2, #0
    7e2e:	d0df      	beq.n	7df0 <yield+0x1c>
    7e30:	f8df 9088 	ldr.w	r9, [pc, #136]	; 7ebc <yield+0xe8>
    7e34:	2400      	movs	r4, #0
    7e36:	e005      	b.n	7e44 <yield+0x70>
    7e38:	3401      	adds	r4, #1
    7e3a:	f898 3000 	ldrb.w	r3, [r8]
    7e3e:	b2e4      	uxtb	r4, r4
    7e40:	42a3      	cmp	r3, r4
    7e42:	d912      	bls.n	7e6a <yield+0x96>
			s_serials_with_serial_events[i]->doYieldCode();
    7e44:	f859 5024 	ldr.w	r5, [r9, r4, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
	static uint8_t 			s_count_serials_with_serial_events;
	void 		(* const _serialEvent)(); 
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*_serialEvent)();
    7e48:	682b      	ldr	r3, [r5, #0]
    7e4a:	4628      	mov	r0, r5
    7e4c:	691b      	ldr	r3, [r3, #16]
    7e4e:	4798      	blx	r3
    7e50:	2800      	cmp	r0, #0
    7e52:	d0f1      	beq.n	7e38 <yield+0x64>
    7e54:	692b      	ldr	r3, [r5, #16]
    7e56:	4798      	blx	r3
    7e58:	e7ee      	b.n	7e38 <yield+0x64>
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    7e5a:	f7ff fddd 	bl	7a18 <usb_serial_available>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    7e5e:	b9c8      	cbnz	r0, 7e94 <yield+0xc0>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    7e60:	4b13      	ldr	r3, [pc, #76]	; (7eb0 <yield+0xdc>)
    7e62:	781b      	ldrb	r3, [r3, #0]
    7e64:	b91b      	cbnz	r3, 7e6e <yield+0x9a>
    7e66:	7833      	ldrb	r3, [r6, #0]
    7e68:	e7c0      	b.n	7dec <yield+0x18>
    7e6a:	7833      	ldrb	r3, [r6, #0]
    7e6c:	e7c0      	b.n	7df0 <yield+0x1c>
    7e6e:	7833      	ldrb	r3, [r6, #0]
    7e70:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    7e74:	7033      	strb	r3, [r6, #0]
    7e76:	e7b9      	b.n	7dec <yield+0x18>
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
		firstYield = first->_next;
    7e78:	6945      	ldr	r5, [r0, #20]
    7e7a:	601d      	str	r5, [r3, #0]
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    7e7c:	2301      	movs	r3, #1
    7e7e:	7023      	strb	r3, [r4, #0]
		firstYield = first->_next;
		if (firstYield) {
    7e80:	b15d      	cbz	r5, 7e9a <yield+0xc6>
			firstYield->_prev = nullptr;
    7e82:	61aa      	str	r2, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    7e84:	b901      	cbnz	r1, 7e88 <yield+0xb4>
    7e86:	b662      	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    7e88:	2500      	movs	r5, #0
    7e8a:	7745      	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    7e8c:	6883      	ldr	r3, [r0, #8]
    7e8e:	4798      	blx	r3
		runningFromYield = false;
    7e90:	7025      	strb	r5, [r4, #0]
    7e92:	e7b7      	b.n	7e04 <yield+0x30>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    7e94:	f000 f928 	bl	80e8 <serialEvent()>
    7e98:	e7e2      	b.n	7e60 <yield+0x8c>
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
    7e9a:	4b06      	ldr	r3, [pc, #24]	; (7eb4 <yield+0xe0>)
    7e9c:	601d      	str	r5, [r3, #0]
    7e9e:	e7f1      	b.n	7e84 <yield+0xb0>
    7ea0:	1fff0b30 	.word	0x1fff0b30
    7ea4:	1fff2d15 	.word	0x1fff2d15
    7ea8:	1fff2d10 	.word	0x1fff2d10
    7eac:	1fff2d14 	.word	0x1fff2d14
    7eb0:	1fff0bd6 	.word	0x1fff0bd6
    7eb4:	1fff2d0c 	.word	0x1fff2d0c
    7eb8:	1fff2d30 	.word	0x1fff2d30
    7ebc:	1fff2d18 	.word	0x1fff2d18

00007ec0 <analog_init>:
#else
#error "F_BUS must be 128, 120, 108, 96, 90, 80, 72, 64, 60, 56, 54, 48, 40, 36, 24, 4 or 2 MHz"
#endif

void analog_init(void)
{
    7ec0:	b430      	push	{r4, r5}
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    7ec2:	4829      	ldr	r0, [pc, #164]	; (7f68 <analog_init+0xa8>)
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    7ec4:	4a29      	ldr	r2, [pc, #164]	; (7f6c <analog_init+0xac>)
	#endif

	if (analog_config_bits == 8) {
    7ec6:	4b2a      	ldr	r3, [pc, #168]	; (7f70 <analog_init+0xb0>)
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    7ec8:	4d2a      	ldr	r5, [pc, #168]	; (7f74 <analog_init+0xb4>)
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    7eca:	2460      	movs	r4, #96	; 0x60
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    7ecc:	21e1      	movs	r1, #225	; 0xe1
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    7ece:	7004      	strb	r4, [r0, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    7ed0:	7011      	strb	r1, [r2, #0]
	#endif

	if (analog_config_bits == 8) {
    7ed2:	781b      	ldrb	r3, [r3, #0]
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    7ed4:	4c28      	ldr	r4, [pc, #160]	; (7f78 <analog_init+0xb8>)
	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
    7ed6:	2b08      	cmp	r3, #8
    7ed8:	d030      	beq.n	7f3c <analog_init+0x7c>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    7eda:	2b0a      	cmp	r3, #10
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    7edc:	4827      	ldr	r0, [pc, #156]	; (7f7c <analog_init+0xbc>)
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    7ede:	4928      	ldr	r1, [pc, #160]	; (7f80 <analog_init+0xc0>)
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    7ee0:	d037      	beq.n	7f52 <analog_init+0x92>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    7ee2:	2b0c      	cmp	r3, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    7ee4:	bf0c      	ite	eq
    7ee6:	2235      	moveq	r2, #53	; 0x35
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    7ee8:	225d      	movne	r2, #93	; 0x5d
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    7eea:	2312      	movs	r3, #18
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    7eec:	602a      	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    7eee:	6023      	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    7ef0:	6002      	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    7ef2:	600b      	str	r3, [r1, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    7ef4:	4b23      	ldr	r3, [pc, #140]	; (7f84 <analog_init+0xc4>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    7ef6:	4924      	ldr	r1, [pc, #144]	; (7f88 <analog_init+0xc8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    7ef8:	781b      	ldrb	r3, [r3, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    7efa:	4a24      	ldr	r2, [pc, #144]	; (7f8c <analog_init+0xcc>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    7efc:	b1bb      	cbz	r3, 7f2e <analog_init+0x6e>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    7efe:	2301      	movs	r3, #1
    7f00:	600b      	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    7f02:	6013      	str	r3, [r2, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    7f04:	4b22      	ldr	r3, [pc, #136]	; (7f90 <analog_init+0xd0>)
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    7f06:	4923      	ldr	r1, [pc, #140]	; (7f94 <analog_init+0xd4>)
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    7f08:	781b      	ldrb	r3, [r3, #0]
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    7f0a:	4a23      	ldr	r2, [pc, #140]	; (7f98 <analog_init+0xd8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
    7f0c:	2b01      	cmp	r3, #1
    7f0e:	d926      	bls.n	7f5e <analog_init+0x9e>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
    7f10:	2b04      	cmp	r3, #4
    7f12:	d90f      	bls.n	7f34 <analog_init+0x74>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
    7f14:	2b08      	cmp	r3, #8
    7f16:	d91e      	bls.n	7f56 <analog_init+0x96>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#endif
	} else if (num <= 16) {
    7f18:	2b10      	cmp	r3, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    7f1a:	bf94      	ite	ls
    7f1c:	2386      	movls	r3, #134	; 0x86
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    7f1e:	2387      	movhi	r3, #135	; 0x87
    7f20:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    7f22:	6013      	str	r3, [r2, #0]
		#endif
	}
	calibrating = 1;
    7f24:	4b1d      	ldr	r3, [pc, #116]	; (7f9c <analog_init+0xdc>)
    7f26:	2201      	movs	r2, #1
    7f28:	701a      	strb	r2, [r3, #0]
}
    7f2a:	bc30      	pop	{r4, r5}
    7f2c:	4770      	bx	lr
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    7f2e:	600b      	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    7f30:	6013      	str	r3, [r2, #0]
    7f32:	e7e7      	b.n	7f04 <analog_init+0x44>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    7f34:	2384      	movs	r3, #132	; 0x84
    7f36:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    7f38:	6013      	str	r3, [r2, #0]
    7f3a:	e7f3      	b.n	7f24 <analog_init+0x64>

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    7f3c:	f500 208e 	add.w	r0, r0, #290816	; 0x47000
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    7f40:	490f      	ldr	r1, [pc, #60]	; (7f80 <analog_init+0xc0>)

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    7f42:	3008      	adds	r0, #8
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    7f44:	2221      	movs	r2, #33	; 0x21
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    7f46:	2313      	movs	r3, #19
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    7f48:	602a      	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    7f4a:	6023      	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    7f4c:	6002      	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    7f4e:	600b      	str	r3, [r1, #0]
    7f50:	e7d0      	b.n	7ef4 <analog_init+0x34>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    7f52:	2239      	movs	r2, #57	; 0x39
    7f54:	e7f7      	b.n	7f46 <analog_init+0x86>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    7f56:	2385      	movs	r3, #133	; 0x85
    7f58:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    7f5a:	6013      	str	r3, [r2, #0]
    7f5c:	e7e2      	b.n	7f24 <analog_init+0x64>
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    7f5e:	2380      	movs	r3, #128	; 0x80
    7f60:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    7f62:	6013      	str	r3, [r2, #0]
    7f64:	e7de      	b.n	7f24 <analog_init+0x64>
    7f66:	bf00      	nop
    7f68:	40074000 	.word	0x40074000
    7f6c:	40074001 	.word	0x40074001
    7f70:	1fff0b31 	.word	0x1fff0b31
    7f74:	4003b008 	.word	0x4003b008
    7f78:	4003b00c 	.word	0x4003b00c
    7f7c:	400bb008 	.word	0x400bb008
    7f80:	400bb00c 	.word	0x400bb00c
    7f84:	1fff2d17 	.word	0x1fff2d17
    7f88:	4003b020 	.word	0x4003b020
    7f8c:	400bb020 	.word	0x400bb020
    7f90:	1fff0b32 	.word	0x1fff0b32
    7f94:	4003b024 	.word	0x4003b024
    7f98:	400bb024 	.word	0x400bb024
    7f9c:	1fff2d16 	.word	0x1fff2d16

00007fa0 <analogWriteDAC0>:
typedef int16_t __attribute__((__may_alias__)) aliased_int16_t;

void analogWriteDAC0(int val)
{
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_DAC0;
    7fa0:	4a0a      	ldr	r2, [pc, #40]	; (7fcc <analogWriteDAC0+0x2c>)
	if (analog_reference_internal) {
    7fa2:	490b      	ldr	r1, [pc, #44]	; (7fd0 <analogWriteDAC0+0x30>)
typedef int16_t __attribute__((__may_alias__)) aliased_int16_t;

void analogWriteDAC0(int val)
{
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_DAC0;
    7fa4:	6813      	ldr	r3, [r2, #0]
    7fa6:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    7faa:	6013      	str	r3, [r2, #0]
	if (analog_reference_internal) {
    7fac:	780b      	ldrb	r3, [r1, #0]
    7fae:	b943      	cbnz	r3, 7fc2 <analogWriteDAC0+0x22>
		DAC0_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC0_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
    7fb0:	4b08      	ldr	r3, [pc, #32]	; (7fd4 <analogWriteDAC0+0x34>)
    7fb2:	22c0      	movs	r2, #192	; 0xc0
    7fb4:	701a      	strb	r2, [r3, #0]
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095

	*(volatile aliased_int16_t *)&(DAC0_DAT0L) = val;
    7fb6:	4b08      	ldr	r3, [pc, #32]	; (7fd8 <analogWriteDAC0+0x38>)
	if (analog_reference_internal) {
		DAC0_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC0_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095
    7fb8:	f380 000c 	usat	r0, #12, r0

	*(volatile aliased_int16_t *)&(DAC0_DAT0L) = val;
    7fbc:	b200      	sxth	r0, r0
    7fbe:	8018      	strh	r0, [r3, #0]
    7fc0:	4770      	bx	lr
void analogWriteDAC0(int val)
{
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_DAC0;
	if (analog_reference_internal) {
		DAC0_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
    7fc2:	4b04      	ldr	r3, [pc, #16]	; (7fd4 <analogWriteDAC0+0x34>)
    7fc4:	2280      	movs	r2, #128	; 0x80
    7fc6:	701a      	strb	r2, [r3, #0]
    7fc8:	e7f5      	b.n	7fb6 <analogWriteDAC0+0x16>
    7fca:	bf00      	nop
    7fcc:	4004802c 	.word	0x4004802c
    7fd0:	1fff2d17 	.word	0x1fff2d17
    7fd4:	400cc021 	.word	0x400cc021
    7fd8:	400cc000 	.word	0x400cc000

00007fdc <analogWriteDAC1>:


#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
void analogWriteDAC1(int val)
{
	SIM_SCGC2 |= SIM_SCGC2_DAC1;
    7fdc:	4a0a      	ldr	r2, [pc, #40]	; (8008 <analogWriteDAC1+0x2c>)
	if (analog_reference_internal) {
    7fde:	490b      	ldr	r1, [pc, #44]	; (800c <analogWriteDAC1+0x30>)


#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
void analogWriteDAC1(int val)
{
	SIM_SCGC2 |= SIM_SCGC2_DAC1;
    7fe0:	6813      	ldr	r3, [r2, #0]
    7fe2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    7fe6:	6013      	str	r3, [r2, #0]
	if (analog_reference_internal) {
    7fe8:	780b      	ldrb	r3, [r1, #0]
    7fea:	b943      	cbnz	r3, 7ffe <analogWriteDAC1+0x22>
		DAC1_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC1_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
    7fec:	4b08      	ldr	r3, [pc, #32]	; (8010 <analogWriteDAC1+0x34>)
    7fee:	22c0      	movs	r2, #192	; 0xc0
    7ff0:	701a      	strb	r2, [r3, #0]
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095

	*(volatile aliased_int16_t *)&(DAC1_DAT0L) = val;
    7ff2:	4b08      	ldr	r3, [pc, #32]	; (8014 <analogWriteDAC1+0x38>)
	if (analog_reference_internal) {
		DAC1_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC1_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095
    7ff4:	f380 000c 	usat	r0, #12, r0

	*(volatile aliased_int16_t *)&(DAC1_DAT0L) = val;
    7ff8:	b200      	sxth	r0, r0
    7ffa:	8018      	strh	r0, [r3, #0]
    7ffc:	4770      	bx	lr
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
void analogWriteDAC1(int val)
{
	SIM_SCGC2 |= SIM_SCGC2_DAC1;
	if (analog_reference_internal) {
		DAC1_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
    7ffe:	4b04      	ldr	r3, [pc, #16]	; (8010 <analogWriteDAC1+0x34>)
    8000:	2280      	movs	r2, #128	; 0x80
    8002:	701a      	strb	r2, [r3, #0]
    8004:	e7f5      	b.n	7ff2 <analogWriteDAC1+0x16>
    8006:	bf00      	nop
    8008:	4004802c 	.word	0x4004802c
    800c:	1fff2d17 	.word	0x1fff2d17
    8010:	400cd021 	.word	0x400cd021
    8014:	400cd000 	.word	0x400cd000

00008018 <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    8018:	b4f0      	push	{r4, r5, r6, r7}
    801a:	1e4d      	subs	r5, r1, #1
    801c:	462e      	mov	r6, r5
	unsigned digit;
	int i=0, j;
    801e:	2400      	movs	r4, #0
    8020:	e000      	b.n	8024 <ultoa+0xc>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    8022:	3401      	adds	r4, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
    8024:	fbb0 f3f2 	udiv	r3, r0, r2
    8028:	fb02 0013 	mls	r0, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    802c:	2809      	cmp	r0, #9
    802e:	f100 0730 	add.w	r7, r0, #48	; 0x30
    8032:	bf8a      	itet	hi
    8034:	3037      	addhi	r0, #55	; 0x37
    8036:	b2f8      	uxtbls	r0, r7
    8038:	b2c0      	uxtbhi	r0, r0
    803a:	f806 0f01 	strb.w	r0, [r6, #1]!
		val /= radix;
		if (val == 0) break;
    803e:	4618      	mov	r0, r3
    8040:	2b00      	cmp	r3, #0
    8042:	d1ee      	bne.n	8022 <ultoa+0xa>
		i++;
	}
	buf[i + 1] = 0;
    8044:	190a      	adds	r2, r1, r4
    8046:	7053      	strb	r3, [r2, #1]
	for (j=0; j < i; j++, i--) {
    8048:	b14c      	cbz	r4, 805e <ultoa+0x46>
		t = buf[j];
		buf[j] = buf[i];
    804a:	7810      	ldrb	r0, [r2, #0]
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
		t = buf[j];
    804c:	f815 6f01 	ldrb.w	r6, [r5, #1]!
		buf[j] = buf[i];
    8050:	7028      	strb	r0, [r5, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    8052:	3301      	adds	r3, #1
    8054:	1ae0      	subs	r0, r4, r3
    8056:	4283      	cmp	r3, r0
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
    8058:	f802 6901 	strb.w	r6, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    805c:	dbf5      	blt.n	804a <ultoa+0x32>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    805e:	4608      	mov	r0, r1
    8060:	bcf0      	pop	{r4, r5, r6, r7}
    8062:	4770      	bx	lr

00008064 <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    8064:	b510      	push	{r4, lr}
    8066:	b084      	sub	sp, #16
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    8068:	b672      	cpsid	i
	FTFL_FCCOB1 = 15;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
    806a:	f7fe fb01 	bl	6670 <kinetis_hsrun_disable>
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    806e:	4a18      	ldr	r2, [pc, #96]	; (80d0 <usb_init_serialnumber+0x6c>)
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    8070:	4b18      	ldr	r3, [pc, #96]	; (80d4 <usb_init_serialnumber+0x70>)
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    8072:	4919      	ldr	r1, [pc, #100]	; (80d8 <usb_init_serialnumber+0x74>)
    8074:	6011      	str	r1, [r2, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    8076:	2270      	movs	r2, #112	; 0x70
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    8078:	2180      	movs	r1, #128	; 0x80
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    807a:	701a      	strb	r2, [r3, #0]
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    807c:	461a      	mov	r2, r3
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    807e:	7019      	strb	r1, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    8080:	7813      	ldrb	r3, [r2, #0]
    8082:	061b      	lsls	r3, r3, #24
    8084:	d5fc      	bpl.n	8080 <usb_init_serialnumber+0x1c>
	num = *(uint32_t *)&FTFL_FCCOBB;
    8086:	4b15      	ldr	r3, [pc, #84]	; (80dc <usb_init_serialnumber+0x78>)
    8088:	681c      	ldr	r4, [r3, #0]
	kinetis_hsrun_enable();
    808a:	f7fe fb0b 	bl	66a4 <kinetis_hsrun_enable>
#endif
	__enable_irq();
    808e:	b662      	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    8090:	4b13      	ldr	r3, [pc, #76]	; (80e0 <usb_init_serialnumber+0x7c>)
    8092:	429c      	cmp	r4, r3
    8094:	bf9c      	itt	ls
    8096:	eb04 0484 	addls.w	r4, r4, r4, lsl #2
    809a:	0064      	lslls	r4, r4, #1
	ultoa(num, buf, 10);
    809c:	4620      	mov	r0, r4
    809e:	4c11      	ldr	r4, [pc, #68]	; (80e4 <usb_init_serialnumber+0x80>)
    80a0:	a901      	add	r1, sp, #4
    80a2:	220a      	movs	r2, #10
    80a4:	f7ff ffb8 	bl	8018 <ultoa>
    80a8:	a901      	add	r1, sp, #4
    80aa:	4620      	mov	r0, r4
	for (i=0; i<10; i++) {
    80ac:	2300      	movs	r3, #0
		char c = buf[i];
    80ae:	f811 2b01 	ldrb.w	r2, [r1], #1
    80b2:	3301      	adds	r3, #1
		if (!c) break;
    80b4:	b13a      	cbz	r2, 80c6 <usb_init_serialnumber+0x62>
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    80b6:	2b0a      	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    80b8:	f820 2f02 	strh.w	r2, [r0, #2]!
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    80bc:	d1f7      	bne.n	80ae <usb_init_serialnumber+0x4a>
    80be:	2316      	movs	r3, #22
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    80c0:	7023      	strb	r3, [r4, #0]
}
    80c2:	b004      	add	sp, #16
    80c4:	bd10      	pop	{r4, pc}
    80c6:	005b      	lsls	r3, r3, #1
    80c8:	b2db      	uxtb	r3, r3
	for (i=0; i<10; i++) {
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    80ca:	7023      	strb	r3, [r4, #0]
}
    80cc:	b004      	add	sp, #16
    80ce:	bd10      	pop	{r4, pc}
    80d0:	40020004 	.word	0x40020004
    80d4:	40020000 	.word	0x40020000
    80d8:	41070000 	.word	0x41070000
    80dc:	4002000c 	.word	0x4002000c
    80e0:	0098967f 	.word	0x0098967f
    80e4:	1fff0bc0 	.word	0x1fff0bc0

000080e8 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    80e8:	4770      	bx	lr
    80ea:	bf00      	nop

000080ec <atan2>:
    80ec:	f000 b99c 	b.w	8428 <__ieee754_atan2>

000080f0 <pow>:
    80f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    80f4:	ed2d 8b02 	vpush	{d8}
    80f8:	f8df a324 	ldr.w	sl, [pc, #804]	; 8420 <pow+0x330>
    80fc:	b08b      	sub	sp, #44	; 0x2c
    80fe:	ec57 6b10 	vmov	r6, r7, d0
    8102:	ec55 4b11 	vmov	r4, r5, d1
    8106:	f000 fa87 	bl	8618 <__ieee754_pow>
    810a:	f99a 8000 	ldrsb.w	r8, [sl]
    810e:	eeb0 8a40 	vmov.f32	s16, s0
    8112:	eef0 8a60 	vmov.f32	s17, s1
    8116:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
    811a:	d048      	beq.n	81ae <pow+0xbe>
    811c:	4622      	mov	r2, r4
    811e:	462b      	mov	r3, r5
    8120:	4620      	mov	r0, r4
    8122:	4629      	mov	r1, r5
    8124:	f002 f828 	bl	a178 <__aeabi_dcmpun>
    8128:	4683      	mov	fp, r0
    812a:	2800      	cmp	r0, #0
    812c:	d13f      	bne.n	81ae <pow+0xbe>
    812e:	4632      	mov	r2, r6
    8130:	463b      	mov	r3, r7
    8132:	4630      	mov	r0, r6
    8134:	4639      	mov	r1, r7
    8136:	f002 f81f 	bl	a178 <__aeabi_dcmpun>
    813a:	4681      	mov	r9, r0
    813c:	2800      	cmp	r0, #0
    813e:	f040 8090 	bne.w	8262 <pow+0x172>
    8142:	4630      	mov	r0, r6
    8144:	4639      	mov	r1, r7
    8146:	2200      	movs	r2, #0
    8148:	2300      	movs	r3, #0
    814a:	f001 ffe3 	bl	a114 <__aeabi_dcmpeq>
    814e:	2800      	cmp	r0, #0
    8150:	d036      	beq.n	81c0 <pow+0xd0>
    8152:	2200      	movs	r2, #0
    8154:	2300      	movs	r3, #0
    8156:	4620      	mov	r0, r4
    8158:	4629      	mov	r1, r5
    815a:	f001 ffdb 	bl	a114 <__aeabi_dcmpeq>
    815e:	4683      	mov	fp, r0
    8160:	b1b8      	cbz	r0, 8192 <pow+0xa2>
    8162:	ed9f 7ba5 	vldr	d7, [pc, #660]	; 83f8 <pow+0x308>
    8166:	2201      	movs	r2, #1
    8168:	4ba9      	ldr	r3, [pc, #676]	; (8410 <pow+0x320>)
    816a:	f8cd 9020 	str.w	r9, [sp, #32]
    816e:	9200      	str	r2, [sp, #0]
    8170:	e9cd 6702 	strd	r6, r7, [sp, #8]
    8174:	e9cd 4504 	strd	r4, r5, [sp, #16]
    8178:	ed8d 7b06 	vstr	d7, [sp, #24]
    817c:	9301      	str	r3, [sp, #4]
    817e:	f1b8 0f00 	cmp.w	r8, #0
    8182:	d05b      	beq.n	823c <pow+0x14c>
    8184:	ed9f 0b9e 	vldr	d0, [pc, #632]	; 8400 <pow+0x310>
    8188:	b00b      	add	sp, #44	; 0x2c
    818a:	ecbd 8b02 	vpop	{d8}
    818e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8192:	ec45 4b10 	vmov	d0, r4, r5
    8196:	f001 fa5b 	bl	9650 <finite>
    819a:	b140      	cbz	r0, 81ae <pow+0xbe>
    819c:	2200      	movs	r2, #0
    819e:	2300      	movs	r3, #0
    81a0:	4620      	mov	r0, r4
    81a2:	4629      	mov	r1, r5
    81a4:	f001 ffc0 	bl	a128 <__aeabi_dcmplt>
    81a8:	2800      	cmp	r0, #0
    81aa:	f040 80c5 	bne.w	8338 <pow+0x248>
    81ae:	eeb0 0a48 	vmov.f32	s0, s16
    81b2:	eef0 0a68 	vmov.f32	s1, s17
    81b6:	b00b      	add	sp, #44	; 0x2c
    81b8:	ecbd 8b02 	vpop	{d8}
    81bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    81c0:	eeb0 0a48 	vmov.f32	s0, s16
    81c4:	eef0 0a68 	vmov.f32	s1, s17
    81c8:	f001 fa42 	bl	9650 <finite>
    81cc:	4680      	mov	r8, r0
    81ce:	2800      	cmp	r0, #0
    81d0:	d061      	beq.n	8296 <pow+0x1a6>
    81d2:	f04f 0800 	mov.w	r8, #0
    81d6:	f04f 0900 	mov.w	r9, #0
    81da:	ec51 0b18 	vmov	r0, r1, d8
    81de:	4642      	mov	r2, r8
    81e0:	464b      	mov	r3, r9
    81e2:	f001 ff97 	bl	a114 <__aeabi_dcmpeq>
    81e6:	2800      	cmp	r0, #0
    81e8:	d0e1      	beq.n	81ae <pow+0xbe>
    81ea:	ec47 6b10 	vmov	d0, r6, r7
    81ee:	f001 fa2f 	bl	9650 <finite>
    81f2:	2800      	cmp	r0, #0
    81f4:	d0db      	beq.n	81ae <pow+0xbe>
    81f6:	ec45 4b10 	vmov	d0, r4, r5
    81fa:	f001 fa29 	bl	9650 <finite>
    81fe:	2800      	cmp	r0, #0
    8200:	d0d5      	beq.n	81ae <pow+0xbe>
    8202:	f99a 3000 	ldrsb.w	r3, [sl]
    8206:	4a82      	ldr	r2, [pc, #520]	; (8410 <pow+0x320>)
    8208:	9201      	str	r2, [sp, #4]
    820a:	2104      	movs	r1, #4
    820c:	2200      	movs	r2, #0
    820e:	2b02      	cmp	r3, #2
    8210:	e9cd 6702 	strd	r6, r7, [sp, #8]
    8214:	e9cd 4504 	strd	r4, r5, [sp, #16]
    8218:	e9cd 8906 	strd	r8, r9, [sp, #24]
    821c:	9100      	str	r1, [sp, #0]
    821e:	9208      	str	r2, [sp, #32]
    8220:	d003      	beq.n	822a <pow+0x13a>
    8222:	4668      	mov	r0, sp
    8224:	f001 fa1c 	bl	9660 <matherr>
    8228:	b970      	cbnz	r0, 8248 <pow+0x158>
    822a:	f002 fb0b 	bl	a844 <__errno>
    822e:	2322      	movs	r3, #34	; 0x22
    8230:	6003      	str	r3, [r0, #0]
    8232:	e009      	b.n	8248 <pow+0x158>
    8234:	ed9f 7b70 	vldr	d7, [pc, #448]	; 83f8 <pow+0x308>
    8238:	ed8d 7b06 	vstr	d7, [sp, #24]
    823c:	4668      	mov	r0, sp
    823e:	f001 fa0f 	bl	9660 <matherr>
    8242:	2800      	cmp	r0, #0
    8244:	f000 808e 	beq.w	8364 <pow+0x274>
    8248:	9b08      	ldr	r3, [sp, #32]
    824a:	b11b      	cbz	r3, 8254 <pow+0x164>
    824c:	f002 fafa 	bl	a844 <__errno>
    8250:	9b08      	ldr	r3, [sp, #32]
    8252:	6003      	str	r3, [r0, #0]
    8254:	ed9d 0b06 	vldr	d0, [sp, #24]
    8258:	b00b      	add	sp, #44	; 0x2c
    825a:	ecbd 8b02 	vpop	{d8}
    825e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8262:	2200      	movs	r2, #0
    8264:	2300      	movs	r3, #0
    8266:	4620      	mov	r0, r4
    8268:	4629      	mov	r1, r5
    826a:	f001 ff53 	bl	a114 <__aeabi_dcmpeq>
    826e:	2800      	cmp	r0, #0
    8270:	d09d      	beq.n	81ae <pow+0xbe>
    8272:	ed9f 0b63 	vldr	d0, [pc, #396]	; 8400 <pow+0x310>
    8276:	4b66      	ldr	r3, [pc, #408]	; (8410 <pow+0x320>)
    8278:	f8cd b020 	str.w	fp, [sp, #32]
    827c:	2201      	movs	r2, #1
    827e:	f1b8 0f02 	cmp.w	r8, #2
    8282:	e9cd 6702 	strd	r6, r7, [sp, #8]
    8286:	e9cd 4504 	strd	r4, r5, [sp, #16]
    828a:	ed8d 0b06 	vstr	d0, [sp, #24]
    828e:	e88d 000c 	stmia.w	sp, {r2, r3}
    8292:	d1d3      	bne.n	823c <pow+0x14c>
    8294:	e78f      	b.n	81b6 <pow+0xc6>
    8296:	ec47 6b10 	vmov	d0, r6, r7
    829a:	f001 f9d9 	bl	9650 <finite>
    829e:	2800      	cmp	r0, #0
    82a0:	d097      	beq.n	81d2 <pow+0xe2>
    82a2:	ec45 4b10 	vmov	d0, r4, r5
    82a6:	f001 f9d3 	bl	9650 <finite>
    82aa:	2800      	cmp	r0, #0
    82ac:	d091      	beq.n	81d2 <pow+0xe2>
    82ae:	ec53 2b18 	vmov	r2, r3, d8
    82b2:	ee18 0a10 	vmov	r0, s16
    82b6:	4619      	mov	r1, r3
    82b8:	f001 ff5e 	bl	a178 <__aeabi_dcmpun>
    82bc:	2800      	cmp	r0, #0
    82be:	d17c      	bne.n	83ba <pow+0x2ca>
    82c0:	2303      	movs	r3, #3
    82c2:	f99a 8000 	ldrsb.w	r8, [sl]
    82c6:	9300      	str	r3, [sp, #0]
    82c8:	4b51      	ldr	r3, [pc, #324]	; (8410 <pow+0x320>)
    82ca:	9008      	str	r0, [sp, #32]
    82cc:	e9cd 6702 	strd	r6, r7, [sp, #8]
    82d0:	e9cd 4504 	strd	r4, r5, [sp, #16]
    82d4:	9301      	str	r3, [sp, #4]
    82d6:	f1b8 0f00 	cmp.w	r8, #0
    82da:	d148      	bne.n	836e <pow+0x27e>
    82dc:	f8df 9144 	ldr.w	r9, [pc, #324]	; 8424 <pow+0x334>
    82e0:	f04f 4860 	mov.w	r8, #3758096384	; 0xe0000000
    82e4:	2200      	movs	r2, #0
    82e6:	2300      	movs	r3, #0
    82e8:	4630      	mov	r0, r6
    82ea:	4639      	mov	r1, r7
    82ec:	e9cd 8906 	strd	r8, r9, [sp, #24]
    82f0:	f001 ff1a 	bl	a128 <__aeabi_dcmplt>
    82f4:	2800      	cmp	r0, #0
    82f6:	d094      	beq.n	8222 <pow+0x132>
    82f8:	2200      	movs	r2, #0
    82fa:	4b46      	ldr	r3, [pc, #280]	; (8414 <pow+0x324>)
    82fc:	4620      	mov	r0, r4
    82fe:	4629      	mov	r1, r5
    8300:	f001 fca0 	bl	9c44 <__aeabi_dmul>
    8304:	4604      	mov	r4, r0
    8306:	460d      	mov	r5, r1
    8308:	ec45 4b10 	vmov	d0, r4, r5
    830c:	f001 f9b4 	bl	9678 <rint>
    8310:	4620      	mov	r0, r4
    8312:	ec53 2b10 	vmov	r2, r3, d0
    8316:	4629      	mov	r1, r5
    8318:	f001 fefc 	bl	a114 <__aeabi_dcmpeq>
    831c:	2800      	cmp	r0, #0
    831e:	d149      	bne.n	83b4 <pow+0x2c4>
    8320:	4b3d      	ldr	r3, [pc, #244]	; (8418 <pow+0x328>)
    8322:	f99a 8000 	ldrsb.w	r8, [sl]
    8326:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
    832a:	e9cd 2306 	strd	r2, r3, [sp, #24]
    832e:	f1b8 0f02 	cmp.w	r8, #2
    8332:	f47f af76 	bne.w	8222 <pow+0x132>
    8336:	e778      	b.n	822a <pow+0x13a>
    8338:	4a35      	ldr	r2, [pc, #212]	; (8410 <pow+0x320>)
    833a:	f99a 3000 	ldrsb.w	r3, [sl]
    833e:	f8cd b020 	str.w	fp, [sp, #32]
    8342:	2101      	movs	r1, #1
    8344:	e9cd 6702 	strd	r6, r7, [sp, #8]
    8348:	e9cd 4504 	strd	r4, r5, [sp, #16]
    834c:	e88d 0006 	stmia.w	sp, {r1, r2}
    8350:	2b00      	cmp	r3, #0
    8352:	f43f af6f 	beq.w	8234 <pow+0x144>
    8356:	4931      	ldr	r1, [pc, #196]	; (841c <pow+0x32c>)
    8358:	2000      	movs	r0, #0
    835a:	2b02      	cmp	r3, #2
    835c:	e9cd 0106 	strd	r0, r1, [sp, #24]
    8360:	f47f af6c 	bne.w	823c <pow+0x14c>
    8364:	f002 fa6e 	bl	a844 <__errno>
    8368:	2321      	movs	r3, #33	; 0x21
    836a:	6003      	str	r3, [r0, #0]
    836c:	e76c      	b.n	8248 <pow+0x158>
    836e:	ed9f 7b26 	vldr	d7, [pc, #152]	; 8408 <pow+0x318>
    8372:	2200      	movs	r2, #0
    8374:	2300      	movs	r3, #0
    8376:	4630      	mov	r0, r6
    8378:	4639      	mov	r1, r7
    837a:	ed8d 7b06 	vstr	d7, [sp, #24]
    837e:	f001 fed3 	bl	a128 <__aeabi_dcmplt>
    8382:	2800      	cmp	r0, #0
    8384:	d0d3      	beq.n	832e <pow+0x23e>
    8386:	2200      	movs	r2, #0
    8388:	4b22      	ldr	r3, [pc, #136]	; (8414 <pow+0x324>)
    838a:	4620      	mov	r0, r4
    838c:	4629      	mov	r1, r5
    838e:	f001 fc59 	bl	9c44 <__aeabi_dmul>
    8392:	4604      	mov	r4, r0
    8394:	460d      	mov	r5, r1
    8396:	ec45 4b10 	vmov	d0, r4, r5
    839a:	f001 f96d 	bl	9678 <rint>
    839e:	4620      	mov	r0, r4
    83a0:	ec53 2b10 	vmov	r2, r3, d0
    83a4:	4629      	mov	r1, r5
    83a6:	f001 feb5 	bl	a114 <__aeabi_dcmpeq>
    83aa:	b918      	cbnz	r0, 83b4 <pow+0x2c4>
    83ac:	4b1b      	ldr	r3, [pc, #108]	; (841c <pow+0x32c>)
    83ae:	2200      	movs	r2, #0
    83b0:	e9cd 2306 	strd	r2, r3, [sp, #24]
    83b4:	f99a 8000 	ldrsb.w	r8, [sl]
    83b8:	e7b9      	b.n	832e <pow+0x23e>
    83ba:	4b15      	ldr	r3, [pc, #84]	; (8410 <pow+0x320>)
    83bc:	f99a 9000 	ldrsb.w	r9, [sl]
    83c0:	f8cd 8020 	str.w	r8, [sp, #32]
    83c4:	2201      	movs	r2, #1
    83c6:	e9cd 6702 	strd	r6, r7, [sp, #8]
    83ca:	e9cd 4504 	strd	r4, r5, [sp, #16]
    83ce:	e88d 000c 	stmia.w	sp, {r2, r3}
    83d2:	f1b9 0f00 	cmp.w	r9, #0
    83d6:	f43f af2d 	beq.w	8234 <pow+0x144>
    83da:	2200      	movs	r2, #0
    83dc:	2300      	movs	r3, #0
    83de:	4610      	mov	r0, r2
    83e0:	4619      	mov	r1, r3
    83e2:	f001 fd59 	bl	9e98 <__aeabi_ddiv>
    83e6:	f1b9 0f02 	cmp.w	r9, #2
    83ea:	e9cd 0106 	strd	r0, r1, [sp, #24]
    83ee:	d0b9      	beq.n	8364 <pow+0x274>
    83f0:	e724      	b.n	823c <pow+0x14c>
    83f2:	bf00      	nop
    83f4:	f3af 8000 	nop.w
	...
    8404:	3ff00000 	.word	0x3ff00000
    8408:	00000000 	.word	0x00000000
    840c:	7ff00000 	.word	0x7ff00000
    8410:	0000c43c 	.word	0x0000c43c
    8414:	3fe00000 	.word	0x3fe00000
    8418:	c7efffff 	.word	0xc7efffff
    841c:	fff00000 	.word	0xfff00000
    8420:	1fff0bd7 	.word	0x1fff0bd7
    8424:	47efffff 	.word	0x47efffff

00008428 <__ieee754_atan2>:
    8428:	ec51 0b11 	vmov	r0, r1, d1
    842c:	4243      	negs	r3, r0
    842e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    8432:	4303      	orrs	r3, r0
    8434:	f021 4800 	bic.w	r8, r1, #2147483648	; 0x80000000
    8438:	4f75      	ldr	r7, [pc, #468]	; (8610 <__ieee754_atan2+0x1e8>)
    843a:	ea48 73d3 	orr.w	r3, r8, r3, lsr #31
    843e:	42bb      	cmp	r3, r7
    8440:	ec55 4b10 	vmov	r4, r5, d0
    8444:	d849      	bhi.n	84da <__ieee754_atan2+0xb2>
    8446:	4263      	negs	r3, r4
    8448:	4323      	orrs	r3, r4
    844a:	f025 4a00 	bic.w	sl, r5, #2147483648	; 0x80000000
    844e:	ea4a 73d3 	orr.w	r3, sl, r3, lsr #31
    8452:	42bb      	cmp	r3, r7
    8454:	46a9      	mov	r9, r5
    8456:	d840      	bhi.n	84da <__ieee754_atan2+0xb2>
    8458:	f101 4340 	add.w	r3, r1, #3221225472	; 0xc0000000
    845c:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
    8460:	4303      	orrs	r3, r0
    8462:	468e      	mov	lr, r1
    8464:	d050      	beq.n	8508 <__ieee754_atan2+0xe0>
    8466:	178e      	asrs	r6, r1, #30
    8468:	f006 0602 	and.w	r6, r6, #2
    846c:	ea54 030a 	orrs.w	r3, r4, sl
    8470:	ea46 76d5 	orr.w	r6, r6, r5, lsr #31
    8474:	d039      	beq.n	84ea <__ieee754_atan2+0xc2>
    8476:	ea50 0308 	orrs.w	r3, r0, r8
    847a:	d03e      	beq.n	84fa <__ieee754_atan2+0xd2>
    847c:	45b8      	cmp	r8, r7
    847e:	d055      	beq.n	852c <__ieee754_atan2+0x104>
    8480:	45ba      	cmp	sl, r7
    8482:	d03a      	beq.n	84fa <__ieee754_atan2+0xd2>
    8484:	ebc8 080a 	rsb	r8, r8, sl
    8488:	ea4f 5828 	mov.w	r8, r8, asr #20
    848c:	f1b8 0f3c 	cmp.w	r8, #60	; 0x3c
    8490:	dc40      	bgt.n	8514 <__ieee754_atan2+0xec>
    8492:	2900      	cmp	r1, #0
    8494:	db70      	blt.n	8578 <__ieee754_atan2+0x150>
    8496:	4602      	mov	r2, r0
    8498:	460b      	mov	r3, r1
    849a:	4620      	mov	r0, r4
    849c:	4629      	mov	r1, r5
    849e:	f001 fcfb 	bl	9e98 <__aeabi_ddiv>
    84a2:	ec41 0b10 	vmov	d0, r0, r1
    84a6:	f001 f8cb 	bl	9640 <fabs>
    84aa:	f000 ff0d 	bl	92c8 <atan>
    84ae:	ec51 0b10 	vmov	r0, r1, d0
    84b2:	2e01      	cmp	r6, #1
    84b4:	d05a      	beq.n	856c <__ieee754_atan2+0x144>
    84b6:	2e02      	cmp	r6, #2
    84b8:	d048      	beq.n	854c <__ieee754_atan2+0x124>
    84ba:	2e00      	cmp	r6, #0
    84bc:	d042      	beq.n	8544 <__ieee754_atan2+0x11c>
    84be:	a33e      	add	r3, pc, #248	; (adr r3, 85b8 <__ieee754_atan2+0x190>)
    84c0:	e9d3 2300 	ldrd	r2, r3, [r3]
    84c4:	f001 fa0a 	bl	98dc <__aeabi_dsub>
    84c8:	a33d      	add	r3, pc, #244	; (adr r3, 85c0 <__ieee754_atan2+0x198>)
    84ca:	e9d3 2300 	ldrd	r2, r3, [r3]
    84ce:	f001 fa05 	bl	98dc <__aeabi_dsub>
    84d2:	ec41 0b10 	vmov	d0, r0, r1
    84d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    84da:	4622      	mov	r2, r4
    84dc:	462b      	mov	r3, r5
    84de:	f001 f9ff 	bl	98e0 <__adddf3>
    84e2:	ec41 0b10 	vmov	d0, r0, r1
    84e6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    84ea:	2e02      	cmp	r6, #2
    84ec:	d016      	beq.n	851c <__ieee754_atan2+0xf4>
    84ee:	2e03      	cmp	r6, #3
    84f0:	d10e      	bne.n	8510 <__ieee754_atan2+0xe8>
    84f2:	ed9f 0b35 	vldr	d0, [pc, #212]	; 85c8 <__ieee754_atan2+0x1a0>
    84f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    84fa:	f1b9 0f00 	cmp.w	r9, #0
    84fe:	db11      	blt.n	8524 <__ieee754_atan2+0xfc>
    8500:	ed9f 0b33 	vldr	d0, [pc, #204]	; 85d0 <__ieee754_atan2+0x1a8>
    8504:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8508:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    850c:	f000 bedc 	b.w	92c8 <atan>
    8510:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8514:	a12e      	add	r1, pc, #184	; (adr r1, 85d0 <__ieee754_atan2+0x1a8>)
    8516:	e9d1 0100 	ldrd	r0, r1, [r1]
    851a:	e7ca      	b.n	84b2 <__ieee754_atan2+0x8a>
    851c:	ed9f 0b28 	vldr	d0, [pc, #160]	; 85c0 <__ieee754_atan2+0x198>
    8520:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8524:	ed9f 0b2c 	vldr	d0, [pc, #176]	; 85d8 <__ieee754_atan2+0x1b0>
    8528:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    852c:	45c2      	cmp	sl, r8
    852e:	d029      	beq.n	8584 <__ieee754_atan2+0x15c>
    8530:	2e02      	cmp	r6, #2
    8532:	d0f3      	beq.n	851c <__ieee754_atan2+0xf4>
    8534:	2e03      	cmp	r6, #3
    8536:	d0dc      	beq.n	84f2 <__ieee754_atan2+0xca>
    8538:	2e01      	cmp	r6, #1
    853a:	d02d      	beq.n	8598 <__ieee754_atan2+0x170>
    853c:	ed9f 0b28 	vldr	d0, [pc, #160]	; 85e0 <__ieee754_atan2+0x1b8>
    8540:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8544:	ec41 0b10 	vmov	d0, r0, r1
    8548:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    854c:	a31a      	add	r3, pc, #104	; (adr r3, 85b8 <__ieee754_atan2+0x190>)
    854e:	e9d3 2300 	ldrd	r2, r3, [r3]
    8552:	f001 f9c3 	bl	98dc <__aeabi_dsub>
    8556:	4602      	mov	r2, r0
    8558:	460b      	mov	r3, r1
    855a:	a119      	add	r1, pc, #100	; (adr r1, 85c0 <__ieee754_atan2+0x198>)
    855c:	e9d1 0100 	ldrd	r0, r1, [r1]
    8560:	f001 f9bc 	bl	98dc <__aeabi_dsub>
    8564:	ec41 0b10 	vmov	d0, r0, r1
    8568:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    856c:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
    8570:	ec41 0b10 	vmov	d0, r0, r1
    8574:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8578:	f118 0f3c 	cmn.w	r8, #60	; 0x3c
    857c:	da8b      	bge.n	8496 <__ieee754_atan2+0x6e>
    857e:	2000      	movs	r0, #0
    8580:	2100      	movs	r1, #0
    8582:	e796      	b.n	84b2 <__ieee754_atan2+0x8a>
    8584:	2e02      	cmp	r6, #2
    8586:	d013      	beq.n	85b0 <__ieee754_atan2+0x188>
    8588:	2e03      	cmp	r6, #3
    858a:	d00d      	beq.n	85a8 <__ieee754_atan2+0x180>
    858c:	2e01      	cmp	r6, #1
    858e:	d007      	beq.n	85a0 <__ieee754_atan2+0x178>
    8590:	ed9f 0b15 	vldr	d0, [pc, #84]	; 85e8 <__ieee754_atan2+0x1c0>
    8594:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8598:	ed9f 0b15 	vldr	d0, [pc, #84]	; 85f0 <__ieee754_atan2+0x1c8>
    859c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    85a0:	ed9f 0b15 	vldr	d0, [pc, #84]	; 85f8 <__ieee754_atan2+0x1d0>
    85a4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    85a8:	ed9f 0b15 	vldr	d0, [pc, #84]	; 8600 <__ieee754_atan2+0x1d8>
    85ac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    85b0:	ed9f 0b15 	vldr	d0, [pc, #84]	; 8608 <__ieee754_atan2+0x1e0>
    85b4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    85b8:	33145c07 	.word	0x33145c07
    85bc:	3ca1a626 	.word	0x3ca1a626
    85c0:	54442d18 	.word	0x54442d18
    85c4:	400921fb 	.word	0x400921fb
    85c8:	54442d18 	.word	0x54442d18
    85cc:	c00921fb 	.word	0xc00921fb
    85d0:	54442d18 	.word	0x54442d18
    85d4:	3ff921fb 	.word	0x3ff921fb
    85d8:	54442d18 	.word	0x54442d18
    85dc:	bff921fb 	.word	0xbff921fb
	...
    85e8:	54442d18 	.word	0x54442d18
    85ec:	3fe921fb 	.word	0x3fe921fb
    85f0:	00000000 	.word	0x00000000
    85f4:	80000000 	.word	0x80000000
    85f8:	54442d18 	.word	0x54442d18
    85fc:	bfe921fb 	.word	0xbfe921fb
    8600:	7f3321d2 	.word	0x7f3321d2
    8604:	c002d97c 	.word	0xc002d97c
    8608:	7f3321d2 	.word	0x7f3321d2
    860c:	4002d97c 	.word	0x4002d97c
    8610:	7ff00000 	.word	0x7ff00000
    8614:	ffffffff 	.word	0xffffffff

00008618 <__ieee754_pow>:
    8618:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    861c:	ec51 0b11 	vmov	r0, r1, d1
    8620:	f021 4800 	bic.w	r8, r1, #2147483648	; 0x80000000
    8624:	ea58 0400 	orrs.w	r4, r8, r0
    8628:	b093      	sub	sp, #76	; 0x4c
    862a:	d03c      	beq.n	86a6 <__ieee754_pow+0x8e>
    862c:	ec53 2b10 	vmov	r2, r3, d0
    8630:	4e6d      	ldr	r6, [pc, #436]	; (87e8 <__ieee754_pow+0x1d0>)
    8632:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
    8636:	42b4      	cmp	r4, r6
    8638:	ee10 aa10 	vmov	sl, s0
    863c:	461d      	mov	r5, r3
    863e:	dc2b      	bgt.n	8698 <__ieee754_pow+0x80>
    8640:	4689      	mov	r9, r1
    8642:	ee11 ea10 	vmov	lr, s2
    8646:	d026      	beq.n	8696 <__ieee754_pow+0x7e>
    8648:	45b0      	cmp	r8, r6
    864a:	dc25      	bgt.n	8698 <__ieee754_pow+0x80>
    864c:	4e66      	ldr	r6, [pc, #408]	; (87e8 <__ieee754_pow+0x1d0>)
    864e:	45b0      	cmp	r8, r6
    8650:	d077      	beq.n	8742 <__ieee754_pow+0x12a>
    8652:	2d00      	cmp	r5, #0
    8654:	4616      	mov	r6, r2
    8656:	461f      	mov	r7, r3
    8658:	e9cd 0100 	strd	r0, r1, [sp]
    865c:	db75      	blt.n	874a <__ieee754_pow+0x132>
    865e:	f04f 0b00 	mov.w	fp, #0
    8662:	f1be 0f00 	cmp.w	lr, #0
    8666:	d12d      	bne.n	86c4 <__ieee754_pow+0xac>
    8668:	4b5f      	ldr	r3, [pc, #380]	; (87e8 <__ieee754_pow+0x1d0>)
    866a:	4598      	cmp	r8, r3
    866c:	f000 8089 	beq.w	8782 <__ieee754_pow+0x16a>
    8670:	4b5e      	ldr	r3, [pc, #376]	; (87ec <__ieee754_pow+0x1d4>)
    8672:	4598      	cmp	r8, r3
    8674:	d05e      	beq.n	8734 <__ieee754_pow+0x11c>
    8676:	f1b9 4f80 	cmp.w	r9, #1073741824	; 0x40000000
    867a:	f000 83de 	beq.w	8e3a <__ieee754_pow+0x822>
    867e:	4b5c      	ldr	r3, [pc, #368]	; (87f0 <__ieee754_pow+0x1d8>)
    8680:	4599      	cmp	r9, r3
    8682:	d11f      	bne.n	86c4 <__ieee754_pow+0xac>
    8684:	2d00      	cmp	r5, #0
    8686:	db1d      	blt.n	86c4 <__ieee754_pow+0xac>
    8688:	ec47 6b10 	vmov	d0, r6, r7
    868c:	b013      	add	sp, #76	; 0x4c
    868e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8692:	f000 bd49 	b.w	9128 <__ieee754_sqrt>
    8696:	b15a      	cbz	r2, 86b0 <__ieee754_pow+0x98>
    8698:	f104 4440 	add.w	r4, r4, #3221225472	; 0xc0000000
    869c:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
    86a0:	ea54 030a 	orrs.w	r3, r4, sl
    86a4:	d106      	bne.n	86b4 <__ieee754_pow+0x9c>
    86a6:	ed9f 0b4a 	vldr	d0, [pc, #296]	; 87d0 <__ieee754_pow+0x1b8>
    86aa:	b013      	add	sp, #76	; 0x4c
    86ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    86b0:	45a0      	cmp	r8, r4
    86b2:	ddcb      	ble.n	864c <__ieee754_pow+0x34>
    86b4:	484f      	ldr	r0, [pc, #316]	; (87f4 <__ieee754_pow+0x1dc>)
    86b6:	b013      	add	sp, #76	; 0x4c
    86b8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    86bc:	f000 bfd4 	b.w	9668 <nan>
    86c0:	f04f 0b00 	mov.w	fp, #0
    86c4:	ec47 6b10 	vmov	d0, r6, r7
    86c8:	f000 ffba 	bl	9640 <fabs>
    86cc:	ec51 0b10 	vmov	r0, r1, d0
    86d0:	f1ba 0f00 	cmp.w	sl, #0
    86d4:	d01e      	beq.n	8714 <__ieee754_pow+0xfc>
    86d6:	0fed      	lsrs	r5, r5, #31
    86d8:	f105 3aff 	add.w	sl, r5, #4294967295	; 0xffffffff
    86dc:	ea5b 030a 	orrs.w	r3, fp, sl
    86e0:	d063      	beq.n	87aa <__ieee754_pow+0x192>
    86e2:	4b45      	ldr	r3, [pc, #276]	; (87f8 <__ieee754_pow+0x1e0>)
    86e4:	4598      	cmp	r8, r3
    86e6:	f340 808d 	ble.w	8804 <__ieee754_pow+0x1ec>
    86ea:	f103 7304 	add.w	r3, r3, #34603008	; 0x2100000
    86ee:	4598      	cmp	r8, r3
    86f0:	f340 8438 	ble.w	8f64 <__ieee754_pow+0x94c>
    86f4:	4b41      	ldr	r3, [pc, #260]	; (87fc <__ieee754_pow+0x1e4>)
    86f6:	429c      	cmp	r4, r3
    86f8:	dd62      	ble.n	87c0 <__ieee754_pow+0x1a8>
    86fa:	f1b9 0f00 	cmp.w	r9, #0
    86fe:	dd62      	ble.n	87c6 <__ieee754_pow+0x1ae>
    8700:	a335      	add	r3, pc, #212	; (adr r3, 87d8 <__ieee754_pow+0x1c0>)
    8702:	e9d3 2300 	ldrd	r2, r3, [r3]
    8706:	4610      	mov	r0, r2
    8708:	4619      	mov	r1, r3
    870a:	f001 fa9b 	bl	9c44 <__aeabi_dmul>
    870e:	ec41 0b10 	vmov	d0, r0, r1
    8712:	e7ca      	b.n	86aa <__ieee754_pow+0x92>
    8714:	b124      	cbz	r4, 8720 <__ieee754_pow+0x108>
    8716:	4b35      	ldr	r3, [pc, #212]	; (87ec <__ieee754_pow+0x1d4>)
    8718:	f025 4240 	bic.w	r2, r5, #3221225472	; 0xc0000000
    871c:	429a      	cmp	r2, r3
    871e:	d1da      	bne.n	86d6 <__ieee754_pow+0xbe>
    8720:	f1b9 0f00 	cmp.w	r9, #0
    8724:	f2c0 83cb 	blt.w	8ebe <__ieee754_pow+0x8a6>
    8728:	2d00      	cmp	r5, #0
    872a:	f2c0 8374 	blt.w	8e16 <__ieee754_pow+0x7fe>
    872e:	ec41 0b10 	vmov	d0, r0, r1
    8732:	e7ba      	b.n	86aa <__ieee754_pow+0x92>
    8734:	f1b9 0f00 	cmp.w	r9, #0
    8738:	f2c0 847a 	blt.w	9030 <__ieee754_pow+0xa18>
    873c:	ec47 6b10 	vmov	d0, r6, r7
    8740:	e7b3      	b.n	86aa <__ieee754_pow+0x92>
    8742:	f1be 0f00 	cmp.w	lr, #0
    8746:	d084      	beq.n	8652 <__ieee754_pow+0x3a>
    8748:	e7a6      	b.n	8698 <__ieee754_pow+0x80>
    874a:	4b2d      	ldr	r3, [pc, #180]	; (8800 <__ieee754_pow+0x1e8>)
    874c:	4598      	cmp	r8, r3
    874e:	dc29      	bgt.n	87a4 <__ieee754_pow+0x18c>
    8750:	f1a3 7354 	sub.w	r3, r3, #55574528	; 0x3500000
    8754:	4598      	cmp	r8, r3
    8756:	dd82      	ble.n	865e <__ieee754_pow+0x46>
    8758:	ea4f 5328 	mov.w	r3, r8, asr #20
    875c:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
    8760:	2b14      	cmp	r3, #20
    8762:	f340 847f 	ble.w	9064 <__ieee754_pow+0xa4c>
    8766:	f1c3 0334 	rsb	r3, r3, #52	; 0x34
    876a:	fa2e f203 	lsr.w	r2, lr, r3
    876e:	fa02 f303 	lsl.w	r3, r2, r3
    8772:	459e      	cmp	lr, r3
    8774:	f47f af73 	bne.w	865e <__ieee754_pow+0x46>
    8778:	f002 0201 	and.w	r2, r2, #1
    877c:	f1c2 0b02 	rsb	fp, r2, #2
    8780:	e76f      	b.n	8662 <__ieee754_pow+0x4a>
    8782:	f104 4340 	add.w	r3, r4, #3221225472	; 0xc0000000
    8786:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
    878a:	ea53 030a 	orrs.w	r3, r3, sl
    878e:	d08a      	beq.n	86a6 <__ieee754_pow+0x8e>
    8790:	4b1a      	ldr	r3, [pc, #104]	; (87fc <__ieee754_pow+0x1e4>)
    8792:	429c      	cmp	r4, r3
    8794:	f340 8385 	ble.w	8ea2 <__ieee754_pow+0x88a>
    8798:	f1b9 0f00 	cmp.w	r9, #0
    879c:	db13      	blt.n	87c6 <__ieee754_pow+0x1ae>
    879e:	ed9d 0b00 	vldr	d0, [sp]
    87a2:	e782      	b.n	86aa <__ieee754_pow+0x92>
    87a4:	f04f 0b02 	mov.w	fp, #2
    87a8:	e75b      	b.n	8662 <__ieee754_pow+0x4a>
    87aa:	4632      	mov	r2, r6
    87ac:	463b      	mov	r3, r7
    87ae:	4610      	mov	r0, r2
    87b0:	4619      	mov	r1, r3
    87b2:	f001 f893 	bl	98dc <__aeabi_dsub>
    87b6:	4602      	mov	r2, r0
    87b8:	460b      	mov	r3, r1
    87ba:	f001 fb6d 	bl	9e98 <__aeabi_ddiv>
    87be:	e7b6      	b.n	872e <__ieee754_pow+0x116>
    87c0:	f1b9 0f00 	cmp.w	r9, #0
    87c4:	db9c      	blt.n	8700 <__ieee754_pow+0xe8>
    87c6:	ed9f 0b06 	vldr	d0, [pc, #24]	; 87e0 <__ieee754_pow+0x1c8>
    87ca:	e76e      	b.n	86aa <__ieee754_pow+0x92>
    87cc:	f3af 8000 	nop.w
    87d0:	00000000 	.word	0x00000000
    87d4:	3ff00000 	.word	0x3ff00000
    87d8:	8800759c 	.word	0x8800759c
    87dc:	7e37e43c 	.word	0x7e37e43c
	...
    87e8:	7ff00000 	.word	0x7ff00000
    87ec:	3ff00000 	.word	0x3ff00000
    87f0:	3fe00000 	.word	0x3fe00000
    87f4:	0000bfa0 	.word	0x0000bfa0
    87f8:	41e00000 	.word	0x41e00000
    87fc:	3fefffff 	.word	0x3fefffff
    8800:	433fffff 	.word	0x433fffff
    8804:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    8808:	f04f 0200 	mov.w	r2, #0
    880c:	da05      	bge.n	881a <__ieee754_pow+0x202>
    880e:	4bd6      	ldr	r3, [pc, #856]	; (8b68 <__ieee754_pow+0x550>)
    8810:	f001 fa18 	bl	9c44 <__aeabi_dmul>
    8814:	f06f 0234 	mvn.w	r2, #52	; 0x34
    8818:	460c      	mov	r4, r1
    881a:	1523      	asrs	r3, r4, #20
    881c:	4ed3      	ldr	r6, [pc, #844]	; (8b6c <__ieee754_pow+0x554>)
    881e:	f3c4 0413 	ubfx	r4, r4, #0, #20
    8822:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
    8826:	4413      	add	r3, r2
    8828:	f044 557f 	orr.w	r5, r4, #1069547520	; 0x3fc00000
    882c:	42b4      	cmp	r4, r6
    882e:	461a      	mov	r2, r3
    8830:	930d      	str	r3, [sp, #52]	; 0x34
    8832:	f445 1540 	orr.w	r5, r5, #3145728	; 0x300000
    8836:	f340 8349 	ble.w	8ecc <__ieee754_pow+0x8b4>
    883a:	4bcd      	ldr	r3, [pc, #820]	; (8b70 <__ieee754_pow+0x558>)
    883c:	429c      	cmp	r4, r3
    883e:	f340 842d 	ble.w	909c <__ieee754_pow+0xa84>
    8842:	ed9f 7bb3 	vldr	d7, [pc, #716]	; 8b10 <__ieee754_pow+0x4f8>
    8846:	ed8d 7b08 	vstr	d7, [sp, #32]
    884a:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
    884e:	ed9f 7bb2 	vldr	d7, [pc, #712]	; 8b18 <__ieee754_pow+0x500>
    8852:	4613      	mov	r3, r2
    8854:	ed8d 7b06 	vstr	d7, [sp, #24]
    8858:	3301      	adds	r3, #1
    885a:	930d      	str	r3, [sp, #52]	; 0x34
    885c:	f5a5 1580 	sub.w	r5, r5, #1048576	; 0x100000
    8860:	f04f 0800 	mov.w	r8, #0
    8864:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    8868:	4629      	mov	r1, r5
    886a:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
    886e:	f001 f835 	bl	98dc <__aeabi_dsub>
    8872:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    8876:	4606      	mov	r6, r0
    8878:	460f      	mov	r7, r1
    887a:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    887e:	f001 f82f 	bl	98e0 <__adddf3>
    8882:	4602      	mov	r2, r0
    8884:	460b      	mov	r3, r1
    8886:	2000      	movs	r0, #0
    8888:	49ba      	ldr	r1, [pc, #744]	; (8b74 <__ieee754_pow+0x55c>)
    888a:	f001 fb05 	bl	9e98 <__aeabi_ddiv>
    888e:	4603      	mov	r3, r0
    8890:	460c      	mov	r4, r1
    8892:	e9cd 3410 	strd	r3, r4, [sp, #64]	; 0x40
    8896:	4602      	mov	r2, r0
    8898:	460b      	mov	r3, r1
    889a:	4630      	mov	r0, r6
    889c:	4639      	mov	r1, r7
    889e:	f001 f9d1 	bl	9c44 <__aeabi_dmul>
    88a2:	106b      	asrs	r3, r5, #1
    88a4:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    88a8:	f503 2300 	add.w	r3, r3, #524288	; 0x80000
    88ac:	eb03 0508 	add.w	r5, r3, r8
    88b0:	460a      	mov	r2, r1
    88b2:	2300      	movs	r3, #0
    88b4:	4601      	mov	r1, r0
    88b6:	e9cd 1202 	strd	r1, r2, [sp, #8]
    88ba:	9302      	str	r3, [sp, #8]
    88bc:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
    88c0:	2400      	movs	r4, #0
    88c2:	e9cd 1204 	strd	r1, r2, [sp, #16]
    88c6:	462b      	mov	r3, r5
    88c8:	4622      	mov	r2, r4
    88ca:	4640      	mov	r0, r8
    88cc:	4649      	mov	r1, r9
    88ce:	f001 f9b9 	bl	9c44 <__aeabi_dmul>
    88d2:	4602      	mov	r2, r0
    88d4:	460b      	mov	r3, r1
    88d6:	4630      	mov	r0, r6
    88d8:	4639      	mov	r1, r7
    88da:	f000 ffff 	bl	98dc <__aeabi_dsub>
    88de:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    88e2:	4606      	mov	r6, r0
    88e4:	460f      	mov	r7, r1
    88e6:	4620      	mov	r0, r4
    88e8:	4629      	mov	r1, r5
    88ea:	f000 fff7 	bl	98dc <__aeabi_dsub>
    88ee:	4602      	mov	r2, r0
    88f0:	460b      	mov	r3, r1
    88f2:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    88f6:	f000 fff1 	bl	98dc <__aeabi_dsub>
    88fa:	4642      	mov	r2, r8
    88fc:	464b      	mov	r3, r9
    88fe:	f001 f9a1 	bl	9c44 <__aeabi_dmul>
    8902:	4602      	mov	r2, r0
    8904:	460b      	mov	r3, r1
    8906:	4630      	mov	r0, r6
    8908:	4639      	mov	r1, r7
    890a:	f000 ffe7 	bl	98dc <__aeabi_dsub>
    890e:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
    8912:	f001 f997 	bl	9c44 <__aeabi_dmul>
    8916:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
    891a:	e9cd 0106 	strd	r0, r1, [sp, #24]
    891e:	4622      	mov	r2, r4
    8920:	462b      	mov	r3, r5
    8922:	4620      	mov	r0, r4
    8924:	4629      	mov	r1, r5
    8926:	f001 f98d 	bl	9c44 <__aeabi_dmul>
    892a:	a37d      	add	r3, pc, #500	; (adr r3, 8b20 <__ieee754_pow+0x508>)
    892c:	e9d3 2300 	ldrd	r2, r3, [r3]
    8930:	4604      	mov	r4, r0
    8932:	460d      	mov	r5, r1
    8934:	f001 f986 	bl	9c44 <__aeabi_dmul>
    8938:	a37b      	add	r3, pc, #492	; (adr r3, 8b28 <__ieee754_pow+0x510>)
    893a:	e9d3 2300 	ldrd	r2, r3, [r3]
    893e:	f000 ffcf 	bl	98e0 <__adddf3>
    8942:	4622      	mov	r2, r4
    8944:	462b      	mov	r3, r5
    8946:	f001 f97d 	bl	9c44 <__aeabi_dmul>
    894a:	a379      	add	r3, pc, #484	; (adr r3, 8b30 <__ieee754_pow+0x518>)
    894c:	e9d3 2300 	ldrd	r2, r3, [r3]
    8950:	f000 ffc6 	bl	98e0 <__adddf3>
    8954:	4622      	mov	r2, r4
    8956:	462b      	mov	r3, r5
    8958:	f001 f974 	bl	9c44 <__aeabi_dmul>
    895c:	a376      	add	r3, pc, #472	; (adr r3, 8b38 <__ieee754_pow+0x520>)
    895e:	e9d3 2300 	ldrd	r2, r3, [r3]
    8962:	f000 ffbd 	bl	98e0 <__adddf3>
    8966:	4622      	mov	r2, r4
    8968:	462b      	mov	r3, r5
    896a:	f001 f96b 	bl	9c44 <__aeabi_dmul>
    896e:	a374      	add	r3, pc, #464	; (adr r3, 8b40 <__ieee754_pow+0x528>)
    8970:	e9d3 2300 	ldrd	r2, r3, [r3]
    8974:	f000 ffb4 	bl	98e0 <__adddf3>
    8978:	4622      	mov	r2, r4
    897a:	462b      	mov	r3, r5
    897c:	f001 f962 	bl	9c44 <__aeabi_dmul>
    8980:	a371      	add	r3, pc, #452	; (adr r3, 8b48 <__ieee754_pow+0x530>)
    8982:	e9d3 2300 	ldrd	r2, r3, [r3]
    8986:	f000 ffab 	bl	98e0 <__adddf3>
    898a:	4622      	mov	r2, r4
    898c:	4606      	mov	r6, r0
    898e:	460f      	mov	r7, r1
    8990:	462b      	mov	r3, r5
    8992:	4620      	mov	r0, r4
    8994:	4629      	mov	r1, r5
    8996:	f001 f955 	bl	9c44 <__aeabi_dmul>
    899a:	4602      	mov	r2, r0
    899c:	460b      	mov	r3, r1
    899e:	4630      	mov	r0, r6
    89a0:	4639      	mov	r1, r7
    89a2:	f001 f94f 	bl	9c44 <__aeabi_dmul>
    89a6:	4642      	mov	r2, r8
    89a8:	4604      	mov	r4, r0
    89aa:	460d      	mov	r5, r1
    89ac:	464b      	mov	r3, r9
    89ae:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    89b2:	f000 ff95 	bl	98e0 <__adddf3>
    89b6:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    89ba:	f001 f943 	bl	9c44 <__aeabi_dmul>
    89be:	4622      	mov	r2, r4
    89c0:	462b      	mov	r3, r5
    89c2:	f000 ff8d 	bl	98e0 <__adddf3>
    89c6:	4642      	mov	r2, r8
    89c8:	4606      	mov	r6, r0
    89ca:	460f      	mov	r7, r1
    89cc:	464b      	mov	r3, r9
    89ce:	4640      	mov	r0, r8
    89d0:	4649      	mov	r1, r9
    89d2:	f001 f937 	bl	9c44 <__aeabi_dmul>
    89d6:	2200      	movs	r2, #0
    89d8:	4b67      	ldr	r3, [pc, #412]	; (8b78 <__ieee754_pow+0x560>)
    89da:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
    89de:	f000 ff7f 	bl	98e0 <__adddf3>
    89e2:	4632      	mov	r2, r6
    89e4:	463b      	mov	r3, r7
    89e6:	f000 ff7b 	bl	98e0 <__adddf3>
    89ea:	9802      	ldr	r0, [sp, #8]
    89ec:	460d      	mov	r5, r1
    89ee:	4604      	mov	r4, r0
    89f0:	4622      	mov	r2, r4
    89f2:	462b      	mov	r3, r5
    89f4:	4640      	mov	r0, r8
    89f6:	4649      	mov	r1, r9
    89f8:	f001 f924 	bl	9c44 <__aeabi_dmul>
    89fc:	2200      	movs	r2, #0
    89fe:	4680      	mov	r8, r0
    8a00:	4689      	mov	r9, r1
    8a02:	4b5d      	ldr	r3, [pc, #372]	; (8b78 <__ieee754_pow+0x560>)
    8a04:	4620      	mov	r0, r4
    8a06:	4629      	mov	r1, r5
    8a08:	f000 ff68 	bl	98dc <__aeabi_dsub>
    8a0c:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
    8a10:	f000 ff64 	bl	98dc <__aeabi_dsub>
    8a14:	4602      	mov	r2, r0
    8a16:	460b      	mov	r3, r1
    8a18:	4630      	mov	r0, r6
    8a1a:	4639      	mov	r1, r7
    8a1c:	f000 ff5e 	bl	98dc <__aeabi_dsub>
    8a20:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    8a24:	f001 f90e 	bl	9c44 <__aeabi_dmul>
    8a28:	4622      	mov	r2, r4
    8a2a:	4606      	mov	r6, r0
    8a2c:	460f      	mov	r7, r1
    8a2e:	462b      	mov	r3, r5
    8a30:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    8a34:	f001 f906 	bl	9c44 <__aeabi_dmul>
    8a38:	4602      	mov	r2, r0
    8a3a:	460b      	mov	r3, r1
    8a3c:	4630      	mov	r0, r6
    8a3e:	4639      	mov	r1, r7
    8a40:	f000 ff4e 	bl	98e0 <__adddf3>
    8a44:	4606      	mov	r6, r0
    8a46:	460f      	mov	r7, r1
    8a48:	4602      	mov	r2, r0
    8a4a:	460b      	mov	r3, r1
    8a4c:	4640      	mov	r0, r8
    8a4e:	4649      	mov	r1, r9
    8a50:	e9cd 8904 	strd	r8, r9, [sp, #16]
    8a54:	f000 ff44 	bl	98e0 <__adddf3>
    8a58:	9802      	ldr	r0, [sp, #8]
    8a5a:	a33d      	add	r3, pc, #244	; (adr r3, 8b50 <__ieee754_pow+0x538>)
    8a5c:	e9d3 2300 	ldrd	r2, r3, [r3]
    8a60:	4604      	mov	r4, r0
    8a62:	460d      	mov	r5, r1
    8a64:	f001 f8ee 	bl	9c44 <__aeabi_dmul>
    8a68:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    8a6c:	4680      	mov	r8, r0
    8a6e:	4689      	mov	r9, r1
    8a70:	4620      	mov	r0, r4
    8a72:	4629      	mov	r1, r5
    8a74:	f000 ff32 	bl	98dc <__aeabi_dsub>
    8a78:	4602      	mov	r2, r0
    8a7a:	460b      	mov	r3, r1
    8a7c:	4630      	mov	r0, r6
    8a7e:	4639      	mov	r1, r7
    8a80:	f000 ff2c 	bl	98dc <__aeabi_dsub>
    8a84:	a334      	add	r3, pc, #208	; (adr r3, 8b58 <__ieee754_pow+0x540>)
    8a86:	e9d3 2300 	ldrd	r2, r3, [r3]
    8a8a:	f001 f8db 	bl	9c44 <__aeabi_dmul>
    8a8e:	a334      	add	r3, pc, #208	; (adr r3, 8b60 <__ieee754_pow+0x548>)
    8a90:	e9d3 2300 	ldrd	r2, r3, [r3]
    8a94:	4606      	mov	r6, r0
    8a96:	460f      	mov	r7, r1
    8a98:	4620      	mov	r0, r4
    8a9a:	4629      	mov	r1, r5
    8a9c:	f001 f8d2 	bl	9c44 <__aeabi_dmul>
    8aa0:	4602      	mov	r2, r0
    8aa2:	460b      	mov	r3, r1
    8aa4:	4630      	mov	r0, r6
    8aa6:	4639      	mov	r1, r7
    8aa8:	f000 ff1a 	bl	98e0 <__adddf3>
    8aac:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
    8ab0:	f000 ff16 	bl	98e0 <__adddf3>
    8ab4:	4606      	mov	r6, r0
    8ab6:	980d      	ldr	r0, [sp, #52]	; 0x34
    8ab8:	460f      	mov	r7, r1
    8aba:	f001 f85d 	bl	9b78 <__aeabi_i2d>
    8abe:	4632      	mov	r2, r6
    8ac0:	4604      	mov	r4, r0
    8ac2:	460d      	mov	r5, r1
    8ac4:	463b      	mov	r3, r7
    8ac6:	4640      	mov	r0, r8
    8ac8:	4649      	mov	r1, r9
    8aca:	f000 ff09 	bl	98e0 <__adddf3>
    8ace:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
    8ad2:	f000 ff05 	bl	98e0 <__adddf3>
    8ad6:	4622      	mov	r2, r4
    8ad8:	462b      	mov	r3, r5
    8ada:	f000 ff01 	bl	98e0 <__adddf3>
    8ade:	9802      	ldr	r0, [sp, #8]
    8ae0:	4622      	mov	r2, r4
    8ae2:	462b      	mov	r3, r5
    8ae4:	e9cd 0102 	strd	r0, r1, [sp, #8]
    8ae8:	f000 fef8 	bl	98dc <__aeabi_dsub>
    8aec:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
    8af0:	f000 fef4 	bl	98dc <__aeabi_dsub>
    8af4:	4642      	mov	r2, r8
    8af6:	464b      	mov	r3, r9
    8af8:	f000 fef0 	bl	98dc <__aeabi_dsub>
    8afc:	4602      	mov	r2, r0
    8afe:	460b      	mov	r3, r1
    8b00:	4630      	mov	r0, r6
    8b02:	4639      	mov	r1, r7
    8b04:	f000 feea 	bl	98dc <__aeabi_dsub>
    8b08:	4680      	mov	r8, r0
    8b0a:	4689      	mov	r9, r1
    8b0c:	e036      	b.n	8b7c <__ieee754_pow+0x564>
    8b0e:	bf00      	nop
	...
    8b1c:	3ff00000 	.word	0x3ff00000
    8b20:	4a454eef 	.word	0x4a454eef
    8b24:	3fca7e28 	.word	0x3fca7e28
    8b28:	93c9db65 	.word	0x93c9db65
    8b2c:	3fcd864a 	.word	0x3fcd864a
    8b30:	a91d4101 	.word	0xa91d4101
    8b34:	3fd17460 	.word	0x3fd17460
    8b38:	518f264d 	.word	0x518f264d
    8b3c:	3fd55555 	.word	0x3fd55555
    8b40:	db6fabff 	.word	0xdb6fabff
    8b44:	3fdb6db6 	.word	0x3fdb6db6
    8b48:	33333303 	.word	0x33333303
    8b4c:	3fe33333 	.word	0x3fe33333
    8b50:	e0000000 	.word	0xe0000000
    8b54:	3feec709 	.word	0x3feec709
    8b58:	dc3a03fd 	.word	0xdc3a03fd
    8b5c:	3feec709 	.word	0x3feec709
    8b60:	145b01f5 	.word	0x145b01f5
    8b64:	be3e2fe0 	.word	0xbe3e2fe0
    8b68:	43400000 	.word	0x43400000
    8b6c:	0003988e 	.word	0x0003988e
    8b70:	000bb679 	.word	0x000bb679
    8b74:	3ff00000 	.word	0x3ff00000
    8b78:	40080000 	.word	0x40080000
    8b7c:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
    8b80:	ea53 030a 	orrs.w	r3, r3, sl
    8b84:	f000 8188 	beq.w	8e98 <__ieee754_pow+0x880>
    8b88:	ed9f 7bd7 	vldr	d7, [pc, #860]	; 8ee8 <__ieee754_pow+0x8d0>
    8b8c:	ed8d 7b06 	vstr	d7, [sp, #24]
    8b90:	e9dd ab00 	ldrd	sl, fp, [sp]
    8b94:	4653      	mov	r3, sl
    8b96:	465c      	mov	r4, fp
    8b98:	e9cd 3400 	strd	r3, r4, [sp]
    8b9c:	2300      	movs	r3, #0
    8b9e:	9300      	str	r3, [sp, #0]
    8ba0:	e9dd 4500 	ldrd	r4, r5, [sp]
    8ba4:	4650      	mov	r0, sl
    8ba6:	4622      	mov	r2, r4
    8ba8:	462b      	mov	r3, r5
    8baa:	4659      	mov	r1, fp
    8bac:	f000 fe96 	bl	98dc <__aeabi_dsub>
    8bb0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    8bb4:	f001 f846 	bl	9c44 <__aeabi_dmul>
    8bb8:	4652      	mov	r2, sl
    8bba:	4606      	mov	r6, r0
    8bbc:	460f      	mov	r7, r1
    8bbe:	465b      	mov	r3, fp
    8bc0:	4640      	mov	r0, r8
    8bc2:	4649      	mov	r1, r9
    8bc4:	f001 f83e 	bl	9c44 <__aeabi_dmul>
    8bc8:	4602      	mov	r2, r0
    8bca:	460b      	mov	r3, r1
    8bcc:	4630      	mov	r0, r6
    8bce:	4639      	mov	r1, r7
    8bd0:	f000 fe86 	bl	98e0 <__adddf3>
    8bd4:	4622      	mov	r2, r4
    8bd6:	4680      	mov	r8, r0
    8bd8:	4689      	mov	r9, r1
    8bda:	462b      	mov	r3, r5
    8bdc:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    8be0:	e9cd 8904 	strd	r8, r9, [sp, #16]
    8be4:	f001 f82e 	bl	9c44 <__aeabi_dmul>
    8be8:	460b      	mov	r3, r1
    8bea:	4602      	mov	r2, r0
    8bec:	4606      	mov	r6, r0
    8bee:	460f      	mov	r7, r1
    8bf0:	4640      	mov	r0, r8
    8bf2:	4649      	mov	r1, r9
    8bf4:	f000 fe74 	bl	98e0 <__adddf3>
    8bf8:	4bd5      	ldr	r3, [pc, #852]	; (8f50 <__ieee754_pow+0x938>)
    8bfa:	4299      	cmp	r1, r3
    8bfc:	4604      	mov	r4, r0
    8bfe:	460d      	mov	r5, r1
    8c00:	468a      	mov	sl, r1
    8c02:	f340 8123 	ble.w	8e4c <__ieee754_pow+0x834>
    8c06:	f101 433f 	add.w	r3, r1, #3204448256	; 0xbf000000
    8c0a:	f503 03e0 	add.w	r3, r3, #7340032	; 0x700000
    8c0e:	4303      	orrs	r3, r0
    8c10:	f040 8218 	bne.w	9044 <__ieee754_pow+0xa2c>
    8c14:	a3b6      	add	r3, pc, #728	; (adr r3, 8ef0 <__ieee754_pow+0x8d8>)
    8c16:	e9d3 2300 	ldrd	r2, r3, [r3]
    8c1a:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    8c1e:	f000 fe5f 	bl	98e0 <__adddf3>
    8c22:	4632      	mov	r2, r6
    8c24:	4680      	mov	r8, r0
    8c26:	4689      	mov	r9, r1
    8c28:	463b      	mov	r3, r7
    8c2a:	4620      	mov	r0, r4
    8c2c:	4629      	mov	r1, r5
    8c2e:	f000 fe55 	bl	98dc <__aeabi_dsub>
    8c32:	4602      	mov	r2, r0
    8c34:	460b      	mov	r3, r1
    8c36:	4640      	mov	r0, r8
    8c38:	4649      	mov	r1, r9
    8c3a:	f001 fa93 	bl	a164 <__aeabi_dcmpgt>
    8c3e:	2800      	cmp	r0, #0
    8c40:	f040 8200 	bne.w	9044 <__ieee754_pow+0xa2c>
    8c44:	46a8      	mov	r8, r5
    8c46:	ea4f 5328 	mov.w	r3, r8, asr #20
    8c4a:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    8c4e:	f2a3 33fe 	subw	r3, r3, #1022	; 0x3fe
    8c52:	fa42 f303 	asr.w	r3, r2, r3
    8c56:	4453      	add	r3, sl
    8c58:	f3c3 520a 	ubfx	r2, r3, #20, #11
    8c5c:	4dbd      	ldr	r5, [pc, #756]	; (8f54 <__ieee754_pow+0x93c>)
    8c5e:	f2a2 32ff 	subw	r2, r2, #1023	; 0x3ff
    8c62:	4115      	asrs	r5, r2
    8c64:	f3c3 0b13 	ubfx	fp, r3, #0, #20
    8c68:	2000      	movs	r0, #0
    8c6a:	f1c2 0414 	rsb	r4, r2, #20
    8c6e:	ea23 0105 	bic.w	r1, r3, r5
    8c72:	f44b 1b80 	orr.w	fp, fp, #1048576	; 0x100000
    8c76:	f1ba 0f00 	cmp.w	sl, #0
    8c7a:	4602      	mov	r2, r0
    8c7c:	460b      	mov	r3, r1
    8c7e:	fa4b fb04 	asr.w	fp, fp, r4
    8c82:	4630      	mov	r0, r6
    8c84:	4639      	mov	r1, r7
    8c86:	bfb8      	it	lt
    8c88:	f1cb 0b00 	rsblt	fp, fp, #0
    8c8c:	f000 fe26 	bl	98dc <__aeabi_dsub>
    8c90:	4602      	mov	r2, r0
    8c92:	460b      	mov	r3, r1
    8c94:	4606      	mov	r6, r0
    8c96:	460f      	mov	r7, r1
    8c98:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    8c9c:	f000 fe20 	bl	98e0 <__adddf3>
    8ca0:	ea4f 5a0b 	mov.w	sl, fp, lsl #20
    8ca4:	2400      	movs	r4, #0
    8ca6:	a394      	add	r3, pc, #592	; (adr r3, 8ef8 <__ieee754_pow+0x8e0>)
    8ca8:	e9d3 2300 	ldrd	r2, r3, [r3]
    8cac:	4620      	mov	r0, r4
    8cae:	460d      	mov	r5, r1
    8cb0:	f000 ffc8 	bl	9c44 <__aeabi_dmul>
    8cb4:	4632      	mov	r2, r6
    8cb6:	4680      	mov	r8, r0
    8cb8:	4689      	mov	r9, r1
    8cba:	463b      	mov	r3, r7
    8cbc:	4620      	mov	r0, r4
    8cbe:	4629      	mov	r1, r5
    8cc0:	f000 fe0c 	bl	98dc <__aeabi_dsub>
    8cc4:	4602      	mov	r2, r0
    8cc6:	460b      	mov	r3, r1
    8cc8:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    8ccc:	f000 fe06 	bl	98dc <__aeabi_dsub>
    8cd0:	a38b      	add	r3, pc, #556	; (adr r3, 8f00 <__ieee754_pow+0x8e8>)
    8cd2:	e9d3 2300 	ldrd	r2, r3, [r3]
    8cd6:	f000 ffb5 	bl	9c44 <__aeabi_dmul>
    8cda:	a38b      	add	r3, pc, #556	; (adr r3, 8f08 <__ieee754_pow+0x8f0>)
    8cdc:	e9d3 2300 	ldrd	r2, r3, [r3]
    8ce0:	4606      	mov	r6, r0
    8ce2:	460f      	mov	r7, r1
    8ce4:	4620      	mov	r0, r4
    8ce6:	4629      	mov	r1, r5
    8ce8:	f000 ffac 	bl	9c44 <__aeabi_dmul>
    8cec:	4602      	mov	r2, r0
    8cee:	460b      	mov	r3, r1
    8cf0:	4630      	mov	r0, r6
    8cf2:	4639      	mov	r1, r7
    8cf4:	f000 fdf4 	bl	98e0 <__adddf3>
    8cf8:	4606      	mov	r6, r0
    8cfa:	460f      	mov	r7, r1
    8cfc:	4602      	mov	r2, r0
    8cfe:	460b      	mov	r3, r1
    8d00:	4640      	mov	r0, r8
    8d02:	4649      	mov	r1, r9
    8d04:	f000 fdec 	bl	98e0 <__adddf3>
    8d08:	4642      	mov	r2, r8
    8d0a:	464b      	mov	r3, r9
    8d0c:	4604      	mov	r4, r0
    8d0e:	460d      	mov	r5, r1
    8d10:	f000 fde4 	bl	98dc <__aeabi_dsub>
    8d14:	4602      	mov	r2, r0
    8d16:	460b      	mov	r3, r1
    8d18:	4630      	mov	r0, r6
    8d1a:	4639      	mov	r1, r7
    8d1c:	f000 fdde 	bl	98dc <__aeabi_dsub>
    8d20:	4622      	mov	r2, r4
    8d22:	4680      	mov	r8, r0
    8d24:	4689      	mov	r9, r1
    8d26:	462b      	mov	r3, r5
    8d28:	4620      	mov	r0, r4
    8d2a:	4629      	mov	r1, r5
    8d2c:	f000 ff8a 	bl	9c44 <__aeabi_dmul>
    8d30:	a377      	add	r3, pc, #476	; (adr r3, 8f10 <__ieee754_pow+0x8f8>)
    8d32:	e9d3 2300 	ldrd	r2, r3, [r3]
    8d36:	4606      	mov	r6, r0
    8d38:	460f      	mov	r7, r1
    8d3a:	f000 ff83 	bl	9c44 <__aeabi_dmul>
    8d3e:	a376      	add	r3, pc, #472	; (adr r3, 8f18 <__ieee754_pow+0x900>)
    8d40:	e9d3 2300 	ldrd	r2, r3, [r3]
    8d44:	f000 fdca 	bl	98dc <__aeabi_dsub>
    8d48:	4632      	mov	r2, r6
    8d4a:	463b      	mov	r3, r7
    8d4c:	f000 ff7a 	bl	9c44 <__aeabi_dmul>
    8d50:	a373      	add	r3, pc, #460	; (adr r3, 8f20 <__ieee754_pow+0x908>)
    8d52:	e9d3 2300 	ldrd	r2, r3, [r3]
    8d56:	f000 fdc3 	bl	98e0 <__adddf3>
    8d5a:	4632      	mov	r2, r6
    8d5c:	463b      	mov	r3, r7
    8d5e:	f000 ff71 	bl	9c44 <__aeabi_dmul>
    8d62:	a371      	add	r3, pc, #452	; (adr r3, 8f28 <__ieee754_pow+0x910>)
    8d64:	e9d3 2300 	ldrd	r2, r3, [r3]
    8d68:	f000 fdb8 	bl	98dc <__aeabi_dsub>
    8d6c:	4632      	mov	r2, r6
    8d6e:	463b      	mov	r3, r7
    8d70:	f000 ff68 	bl	9c44 <__aeabi_dmul>
    8d74:	a36e      	add	r3, pc, #440	; (adr r3, 8f30 <__ieee754_pow+0x918>)
    8d76:	e9d3 2300 	ldrd	r2, r3, [r3]
    8d7a:	f000 fdb1 	bl	98e0 <__adddf3>
    8d7e:	4632      	mov	r2, r6
    8d80:	463b      	mov	r3, r7
    8d82:	f000 ff5f 	bl	9c44 <__aeabi_dmul>
    8d86:	4602      	mov	r2, r0
    8d88:	460b      	mov	r3, r1
    8d8a:	4620      	mov	r0, r4
    8d8c:	4629      	mov	r1, r5
    8d8e:	f000 fda5 	bl	98dc <__aeabi_dsub>
    8d92:	4606      	mov	r6, r0
    8d94:	460f      	mov	r7, r1
    8d96:	4602      	mov	r2, r0
    8d98:	460b      	mov	r3, r1
    8d9a:	4620      	mov	r0, r4
    8d9c:	4629      	mov	r1, r5
    8d9e:	f000 ff51 	bl	9c44 <__aeabi_dmul>
    8da2:	2200      	movs	r2, #0
    8da4:	e9cd 0100 	strd	r0, r1, [sp]
    8da8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    8dac:	4630      	mov	r0, r6
    8dae:	4639      	mov	r1, r7
    8db0:	f000 fd94 	bl	98dc <__aeabi_dsub>
    8db4:	4602      	mov	r2, r0
    8db6:	460b      	mov	r3, r1
    8db8:	e9dd 0100 	ldrd	r0, r1, [sp]
    8dbc:	f001 f86c 	bl	9e98 <__aeabi_ddiv>
    8dc0:	4642      	mov	r2, r8
    8dc2:	4606      	mov	r6, r0
    8dc4:	460f      	mov	r7, r1
    8dc6:	464b      	mov	r3, r9
    8dc8:	4620      	mov	r0, r4
    8dca:	4629      	mov	r1, r5
    8dcc:	f000 ff3a 	bl	9c44 <__aeabi_dmul>
    8dd0:	4642      	mov	r2, r8
    8dd2:	464b      	mov	r3, r9
    8dd4:	f000 fd84 	bl	98e0 <__adddf3>
    8dd8:	4602      	mov	r2, r0
    8dda:	460b      	mov	r3, r1
    8ddc:	4630      	mov	r0, r6
    8dde:	4639      	mov	r1, r7
    8de0:	f000 fd7c 	bl	98dc <__aeabi_dsub>
    8de4:	4622      	mov	r2, r4
    8de6:	462b      	mov	r3, r5
    8de8:	f000 fd78 	bl	98dc <__aeabi_dsub>
    8dec:	4602      	mov	r2, r0
    8dee:	460b      	mov	r3, r1
    8df0:	2000      	movs	r0, #0
    8df2:	4959      	ldr	r1, [pc, #356]	; (8f58 <__ieee754_pow+0x940>)
    8df4:	f000 fd72 	bl	98dc <__aeabi_dsub>
    8df8:	448a      	add	sl, r1
    8dfa:	f5ba 1f80 	cmp.w	sl, #1048576	; 0x100000
    8dfe:	4602      	mov	r2, r0
    8e00:	460b      	mov	r3, r1
    8e02:	f2c0 815b 	blt.w	90bc <__ieee754_pow+0xaa4>
    8e06:	4651      	mov	r1, sl
    8e08:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    8e0c:	f000 ff1a 	bl	9c44 <__aeabi_dmul>
    8e10:	ec41 0b10 	vmov	d0, r0, r1
    8e14:	e449      	b.n	86aa <__ieee754_pow+0x92>
    8e16:	f104 4440 	add.w	r4, r4, #3221225472	; 0xc0000000
    8e1a:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
    8e1e:	ea54 030b 	orrs.w	r3, r4, fp
    8e22:	f000 8137 	beq.w	9094 <__ieee754_pow+0xa7c>
    8e26:	f1bb 0f01 	cmp.w	fp, #1
    8e2a:	f47f ac80 	bne.w	872e <__ieee754_pow+0x116>
    8e2e:	4602      	mov	r2, r0
    8e30:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
    8e34:	ec43 2b10 	vmov	d0, r2, r3
    8e38:	e437      	b.n	86aa <__ieee754_pow+0x92>
    8e3a:	4632      	mov	r2, r6
    8e3c:	463b      	mov	r3, r7
    8e3e:	4630      	mov	r0, r6
    8e40:	4639      	mov	r1, r7
    8e42:	f000 feff 	bl	9c44 <__aeabi_dmul>
    8e46:	ec41 0b10 	vmov	d0, r0, r1
    8e4a:	e42e      	b.n	86aa <__ieee754_pow+0x92>
    8e4c:	4b43      	ldr	r3, [pc, #268]	; (8f5c <__ieee754_pow+0x944>)
    8e4e:	f021 4800 	bic.w	r8, r1, #2147483648	; 0x80000000
    8e52:	4598      	cmp	r8, r3
    8e54:	f340 8115 	ble.w	9082 <__ieee754_pow+0xa6a>
    8e58:	4b41      	ldr	r3, [pc, #260]	; (8f60 <__ieee754_pow+0x948>)
    8e5a:	440b      	add	r3, r1
    8e5c:	4303      	orrs	r3, r0
    8e5e:	d10c      	bne.n	8e7a <__ieee754_pow+0x862>
    8e60:	4632      	mov	r2, r6
    8e62:	463b      	mov	r3, r7
    8e64:	f000 fd3a 	bl	98dc <__aeabi_dsub>
    8e68:	4602      	mov	r2, r0
    8e6a:	460b      	mov	r3, r1
    8e6c:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    8e70:	f001 f964 	bl	a13c <__aeabi_dcmple>
    8e74:	2800      	cmp	r0, #0
    8e76:	f43f aee6 	beq.w	8c46 <__ieee754_pow+0x62e>
    8e7a:	a32f      	add	r3, pc, #188	; (adr r3, 8f38 <__ieee754_pow+0x920>)
    8e7c:	e9d3 2300 	ldrd	r2, r3, [r3]
    8e80:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    8e84:	f000 fede 	bl	9c44 <__aeabi_dmul>
    8e88:	a32b      	add	r3, pc, #172	; (adr r3, 8f38 <__ieee754_pow+0x920>)
    8e8a:	e9d3 2300 	ldrd	r2, r3, [r3]
    8e8e:	f000 fed9 	bl	9c44 <__aeabi_dmul>
    8e92:	ec41 0b10 	vmov	d0, r0, r1
    8e96:	e408      	b.n	86aa <__ieee754_pow+0x92>
    8e98:	ed9f 7b29 	vldr	d7, [pc, #164]	; 8f40 <__ieee754_pow+0x928>
    8e9c:	ed8d 7b06 	vstr	d7, [sp, #24]
    8ea0:	e676      	b.n	8b90 <__ieee754_pow+0x578>
    8ea2:	f1b9 0f00 	cmp.w	r9, #0
    8ea6:	f6bf ac8e 	bge.w	87c6 <__ieee754_pow+0x1ae>
    8eaa:	e9dd 3400 	ldrd	r3, r4, [sp]
    8eae:	ee00 3a10 	vmov	s0, r3
    8eb2:	f104 4300 	add.w	r3, r4, #2147483648	; 0x80000000
    8eb6:	ee00 3a90 	vmov	s1, r3
    8eba:	f7ff bbf6 	b.w	86aa <__ieee754_pow+0x92>
    8ebe:	4602      	mov	r2, r0
    8ec0:	460b      	mov	r3, r1
    8ec2:	2000      	movs	r0, #0
    8ec4:	4924      	ldr	r1, [pc, #144]	; (8f58 <__ieee754_pow+0x940>)
    8ec6:	f000 ffe7 	bl	9e98 <__aeabi_ddiv>
    8eca:	e42d      	b.n	8728 <__ieee754_pow+0x110>
    8ecc:	ed9f 7b1e 	vldr	d7, [pc, #120]	; 8f48 <__ieee754_pow+0x930>
    8ed0:	ed8d 7b08 	vstr	d7, [sp, #32]
    8ed4:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
    8ed8:	ed9f 7b03 	vldr	d7, [pc, #12]	; 8ee8 <__ieee754_pow+0x8d0>
    8edc:	f04f 0800 	mov.w	r8, #0
    8ee0:	ed8d 7b06 	vstr	d7, [sp, #24]
    8ee4:	e4be      	b.n	8864 <__ieee754_pow+0x24c>
    8ee6:	bf00      	nop
    8ee8:	00000000 	.word	0x00000000
    8eec:	3ff00000 	.word	0x3ff00000
    8ef0:	652b82fe 	.word	0x652b82fe
    8ef4:	3c971547 	.word	0x3c971547
    8ef8:	00000000 	.word	0x00000000
    8efc:	3fe62e43 	.word	0x3fe62e43
    8f00:	fefa39ef 	.word	0xfefa39ef
    8f04:	3fe62e42 	.word	0x3fe62e42
    8f08:	0ca86c39 	.word	0x0ca86c39
    8f0c:	be205c61 	.word	0xbe205c61
    8f10:	72bea4d0 	.word	0x72bea4d0
    8f14:	3e663769 	.word	0x3e663769
    8f18:	c5d26bf1 	.word	0xc5d26bf1
    8f1c:	3ebbbd41 	.word	0x3ebbbd41
    8f20:	af25de2c 	.word	0xaf25de2c
    8f24:	3f11566a 	.word	0x3f11566a
    8f28:	16bebd93 	.word	0x16bebd93
    8f2c:	3f66c16c 	.word	0x3f66c16c
    8f30:	5555553e 	.word	0x5555553e
    8f34:	3fc55555 	.word	0x3fc55555
    8f38:	c2f8f359 	.word	0xc2f8f359
    8f3c:	01a56e1f 	.word	0x01a56e1f
    8f40:	00000000 	.word	0x00000000
    8f44:	bff00000 	.word	0xbff00000
	...
    8f50:	408fffff 	.word	0x408fffff
    8f54:	000fffff 	.word	0x000fffff
    8f58:	3ff00000 	.word	0x3ff00000
    8f5c:	4090cbff 	.word	0x4090cbff
    8f60:	3f6f3400 	.word	0x3f6f3400
    8f64:	4b6c      	ldr	r3, [pc, #432]	; (9118 <__ieee754_pow+0xb00>)
    8f66:	429c      	cmp	r4, r3
    8f68:	f77f ac2a 	ble.w	87c0 <__ieee754_pow+0x1a8>
    8f6c:	4b6b      	ldr	r3, [pc, #428]	; (911c <__ieee754_pow+0xb04>)
    8f6e:	429c      	cmp	r4, r3
    8f70:	f73f abc3 	bgt.w	86fa <__ieee754_pow+0xe2>
    8f74:	2200      	movs	r2, #0
    8f76:	4b69      	ldr	r3, [pc, #420]	; (911c <__ieee754_pow+0xb04>)
    8f78:	f000 fcb0 	bl	98dc <__aeabi_dsub>
    8f7c:	a356      	add	r3, pc, #344	; (adr r3, 90d8 <__ieee754_pow+0xac0>)
    8f7e:	e9d3 2300 	ldrd	r2, r3, [r3]
    8f82:	4604      	mov	r4, r0
    8f84:	460d      	mov	r5, r1
    8f86:	f000 fe5d 	bl	9c44 <__aeabi_dmul>
    8f8a:	a355      	add	r3, pc, #340	; (adr r3, 90e0 <__ieee754_pow+0xac8>)
    8f8c:	e9d3 2300 	ldrd	r2, r3, [r3]
    8f90:	4680      	mov	r8, r0
    8f92:	4689      	mov	r9, r1
    8f94:	4620      	mov	r0, r4
    8f96:	4629      	mov	r1, r5
    8f98:	f000 fe54 	bl	9c44 <__aeabi_dmul>
    8f9c:	2200      	movs	r2, #0
    8f9e:	e9cd 0102 	strd	r0, r1, [sp, #8]
    8fa2:	4b5f      	ldr	r3, [pc, #380]	; (9120 <__ieee754_pow+0xb08>)
    8fa4:	4620      	mov	r0, r4
    8fa6:	4629      	mov	r1, r5
    8fa8:	f000 fe4c 	bl	9c44 <__aeabi_dmul>
    8fac:	4602      	mov	r2, r0
    8fae:	460b      	mov	r3, r1
    8fb0:	a14d      	add	r1, pc, #308	; (adr r1, 90e8 <__ieee754_pow+0xad0>)
    8fb2:	e9d1 0100 	ldrd	r0, r1, [r1]
    8fb6:	f000 fc91 	bl	98dc <__aeabi_dsub>
    8fba:	4622      	mov	r2, r4
    8fbc:	462b      	mov	r3, r5
    8fbe:	f000 fe41 	bl	9c44 <__aeabi_dmul>
    8fc2:	4602      	mov	r2, r0
    8fc4:	460b      	mov	r3, r1
    8fc6:	2000      	movs	r0, #0
    8fc8:	4956      	ldr	r1, [pc, #344]	; (9124 <__ieee754_pow+0xb0c>)
    8fca:	f000 fc87 	bl	98dc <__aeabi_dsub>
    8fce:	4622      	mov	r2, r4
    8fd0:	462b      	mov	r3, r5
    8fd2:	4606      	mov	r6, r0
    8fd4:	460f      	mov	r7, r1
    8fd6:	4620      	mov	r0, r4
    8fd8:	4629      	mov	r1, r5
    8fda:	f000 fe33 	bl	9c44 <__aeabi_dmul>
    8fde:	4602      	mov	r2, r0
    8fe0:	460b      	mov	r3, r1
    8fe2:	4630      	mov	r0, r6
    8fe4:	4639      	mov	r1, r7
    8fe6:	f000 fe2d 	bl	9c44 <__aeabi_dmul>
    8fea:	a341      	add	r3, pc, #260	; (adr r3, 90f0 <__ieee754_pow+0xad8>)
    8fec:	e9d3 2300 	ldrd	r2, r3, [r3]
    8ff0:	f000 fe28 	bl	9c44 <__aeabi_dmul>
    8ff4:	4602      	mov	r2, r0
    8ff6:	460b      	mov	r3, r1
    8ff8:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    8ffc:	f000 fc6e 	bl	98dc <__aeabi_dsub>
    9000:	4602      	mov	r2, r0
    9002:	460b      	mov	r3, r1
    9004:	4604      	mov	r4, r0
    9006:	460d      	mov	r5, r1
    9008:	4640      	mov	r0, r8
    900a:	4649      	mov	r1, r9
    900c:	f000 fc68 	bl	98e0 <__adddf3>
    9010:	4642      	mov	r2, r8
    9012:	464b      	mov	r3, r9
    9014:	2000      	movs	r0, #0
    9016:	e9cd 0102 	strd	r0, r1, [sp, #8]
    901a:	f000 fc5f 	bl	98dc <__aeabi_dsub>
    901e:	4602      	mov	r2, r0
    9020:	460b      	mov	r3, r1
    9022:	4620      	mov	r0, r4
    9024:	4629      	mov	r1, r5
    9026:	f000 fc59 	bl	98dc <__aeabi_dsub>
    902a:	4680      	mov	r8, r0
    902c:	4689      	mov	r9, r1
    902e:	e5a5      	b.n	8b7c <__ieee754_pow+0x564>
    9030:	4632      	mov	r2, r6
    9032:	463b      	mov	r3, r7
    9034:	2000      	movs	r0, #0
    9036:	4939      	ldr	r1, [pc, #228]	; (911c <__ieee754_pow+0xb04>)
    9038:	f000 ff2e 	bl	9e98 <__aeabi_ddiv>
    903c:	ec41 0b10 	vmov	d0, r0, r1
    9040:	f7ff bb33 	b.w	86aa <__ieee754_pow+0x92>
    9044:	a32c      	add	r3, pc, #176	; (adr r3, 90f8 <__ieee754_pow+0xae0>)
    9046:	e9d3 2300 	ldrd	r2, r3, [r3]
    904a:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    904e:	f000 fdf9 	bl	9c44 <__aeabi_dmul>
    9052:	a329      	add	r3, pc, #164	; (adr r3, 90f8 <__ieee754_pow+0xae0>)
    9054:	e9d3 2300 	ldrd	r2, r3, [r3]
    9058:	f000 fdf4 	bl	9c44 <__aeabi_dmul>
    905c:	ec41 0b10 	vmov	d0, r0, r1
    9060:	f7ff bb23 	b.w	86aa <__ieee754_pow+0x92>
    9064:	f1be 0f00 	cmp.w	lr, #0
    9068:	f47f ab2a 	bne.w	86c0 <__ieee754_pow+0xa8>
    906c:	f1c3 0314 	rsb	r3, r3, #20
    9070:	fa48 f203 	asr.w	r2, r8, r3
    9074:	fa02 f303 	lsl.w	r3, r2, r3
    9078:	4598      	cmp	r8, r3
    907a:	d027      	beq.n	90cc <__ieee754_pow+0xab4>
    907c:	46f3      	mov	fp, lr
    907e:	f7ff baf7 	b.w	8670 <__ieee754_pow+0x58>
    9082:	4b28      	ldr	r3, [pc, #160]	; (9124 <__ieee754_pow+0xb0c>)
    9084:	4598      	cmp	r8, r3
    9086:	f73f adde 	bgt.w	8c46 <__ieee754_pow+0x62e>
    908a:	e9dd 3400 	ldrd	r3, r4, [sp]
    908e:	469a      	mov	sl, r3
    9090:	469b      	mov	fp, r3
    9092:	e607      	b.n	8ca4 <__ieee754_pow+0x68c>
    9094:	4602      	mov	r2, r0
    9096:	460b      	mov	r3, r1
    9098:	f7ff bb89 	b.w	87ae <__ieee754_pow+0x196>
    909c:	ed9f 7b18 	vldr	d7, [pc, #96]	; 9100 <__ieee754_pow+0xae8>
    90a0:	ed8d 7b08 	vstr	d7, [sp, #32]
    90a4:	ed9f 7b18 	vldr	d7, [pc, #96]	; 9108 <__ieee754_pow+0xaf0>
    90a8:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
    90ac:	ed9f 7b18 	vldr	d7, [pc, #96]	; 9110 <__ieee754_pow+0xaf8>
    90b0:	f44f 2880 	mov.w	r8, #262144	; 0x40000
    90b4:	ed8d 7b06 	vstr	d7, [sp, #24]
    90b8:	f7ff bbd4 	b.w	8864 <__ieee754_pow+0x24c>
    90bc:	4658      	mov	r0, fp
    90be:	ec43 2b10 	vmov	d0, r2, r3
    90c2:	f000 fb6d 	bl	97a0 <scalbn>
    90c6:	ec51 0b10 	vmov	r0, r1, d0
    90ca:	e69d      	b.n	8e08 <__ieee754_pow+0x7f0>
    90cc:	f002 0201 	and.w	r2, r2, #1
    90d0:	f1c2 0b02 	rsb	fp, r2, #2
    90d4:	f7ff bacc 	b.w	8670 <__ieee754_pow+0x58>
    90d8:	60000000 	.word	0x60000000
    90dc:	3ff71547 	.word	0x3ff71547
    90e0:	f85ddf44 	.word	0xf85ddf44
    90e4:	3e54ae0b 	.word	0x3e54ae0b
    90e8:	55555555 	.word	0x55555555
    90ec:	3fd55555 	.word	0x3fd55555
    90f0:	652b82fe 	.word	0x652b82fe
    90f4:	3ff71547 	.word	0x3ff71547
    90f8:	8800759c 	.word	0x8800759c
    90fc:	7e37e43c 	.word	0x7e37e43c
    9100:	40000000 	.word	0x40000000
    9104:	3fe2b803 	.word	0x3fe2b803
    9108:	43cfd006 	.word	0x43cfd006
    910c:	3e4cfdeb 	.word	0x3e4cfdeb
    9110:	00000000 	.word	0x00000000
    9114:	3ff80000 	.word	0x3ff80000
    9118:	3feffffe 	.word	0x3feffffe
    911c:	3ff00000 	.word	0x3ff00000
    9120:	3fd00000 	.word	0x3fd00000
    9124:	3fe00000 	.word	0x3fe00000

00009128 <__ieee754_sqrt>:
    9128:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    912c:	4965      	ldr	r1, [pc, #404]	; (92c4 <__ieee754_sqrt+0x19c>)
    912e:	ec55 4b10 	vmov	r4, r5, d0
    9132:	460e      	mov	r6, r1
    9134:	4029      	ands	r1, r5
    9136:	42b1      	cmp	r1, r6
    9138:	f000 8097 	beq.w	926a <__ieee754_sqrt+0x142>
    913c:	2d00      	cmp	r5, #0
    913e:	462b      	mov	r3, r5
    9140:	ee10 2a10 	vmov	r2, s0
    9144:	dd74      	ble.n	9230 <__ieee754_sqrt+0x108>
    9146:	152f      	asrs	r7, r5, #20
    9148:	d07f      	beq.n	924a <__ieee754_sqrt+0x122>
    914a:	f2a7 37ff 	subw	r7, r7, #1023	; 0x3ff
    914e:	f3c3 0313 	ubfx	r3, r3, #0, #20
    9152:	07f9      	lsls	r1, r7, #31
    9154:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    9158:	d465      	bmi.n	9226 <__ieee754_sqrt+0xfe>
    915a:	eb03 71d2 	add.w	r1, r3, r2, lsr #31
    915e:	2600      	movs	r6, #0
    9160:	440b      	add	r3, r1
    9162:	107f      	asrs	r7, r7, #1
    9164:	0052      	lsls	r2, r2, #1
    9166:	46b6      	mov	lr, r6
    9168:	2016      	movs	r0, #22
    916a:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
    916e:	eb0e 0401 	add.w	r4, lr, r1
    9172:	429c      	cmp	r4, r3
    9174:	ea4f 75d2 	mov.w	r5, r2, lsr #31
    9178:	ea4f 0242 	mov.w	r2, r2, lsl #1
    917c:	dc03      	bgt.n	9186 <__ieee754_sqrt+0x5e>
    917e:	1b1b      	subs	r3, r3, r4
    9180:	eb04 0e01 	add.w	lr, r4, r1
    9184:	440e      	add	r6, r1
    9186:	3801      	subs	r0, #1
    9188:	eb05 0343 	add.w	r3, r5, r3, lsl #1
    918c:	ea4f 0151 	mov.w	r1, r1, lsr #1
    9190:	d1ed      	bne.n	916e <__ieee754_sqrt+0x46>
    9192:	4684      	mov	ip, r0
    9194:	2420      	movs	r4, #32
    9196:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    919a:	e009      	b.n	91b0 <__ieee754_sqrt+0x88>
    919c:	d020      	beq.n	91e0 <__ieee754_sqrt+0xb8>
    919e:	eb03 75d2 	add.w	r5, r3, r2, lsr #31
    91a2:	3c01      	subs	r4, #1
    91a4:	ea4f 0151 	mov.w	r1, r1, lsr #1
    91a8:	442b      	add	r3, r5
    91aa:	ea4f 0242 	mov.w	r2, r2, lsl #1
    91ae:	d020      	beq.n	91f2 <__ieee754_sqrt+0xca>
    91b0:	459e      	cmp	lr, r3
    91b2:	eb01 050c 	add.w	r5, r1, ip
    91b6:	daf1      	bge.n	919c <__ieee754_sqrt+0x74>
    91b8:	2d00      	cmp	r5, #0
    91ba:	eb05 0c01 	add.w	ip, r5, r1
    91be:	db09      	blt.n	91d4 <__ieee754_sqrt+0xac>
    91c0:	46f0      	mov	r8, lr
    91c2:	4295      	cmp	r5, r2
    91c4:	ebce 0303 	rsb	r3, lr, r3
    91c8:	d900      	bls.n	91cc <__ieee754_sqrt+0xa4>
    91ca:	3b01      	subs	r3, #1
    91cc:	1b52      	subs	r2, r2, r5
    91ce:	4408      	add	r0, r1
    91d0:	46c6      	mov	lr, r8
    91d2:	e7e4      	b.n	919e <__ieee754_sqrt+0x76>
    91d4:	f1bc 0f00 	cmp.w	ip, #0
    91d8:	dbf2      	blt.n	91c0 <__ieee754_sqrt+0x98>
    91da:	f10e 0801 	add.w	r8, lr, #1
    91de:	e7f0      	b.n	91c2 <__ieee754_sqrt+0x9a>
    91e0:	4295      	cmp	r5, r2
    91e2:	d81e      	bhi.n	9222 <__ieee754_sqrt+0xfa>
    91e4:	2d00      	cmp	r5, #0
    91e6:	eb05 0c01 	add.w	ip, r5, r1
    91ea:	db50      	blt.n	928e <__ieee754_sqrt+0x166>
    91ec:	4698      	mov	r8, r3
    91ee:	2300      	movs	r3, #0
    91f0:	e7ec      	b.n	91cc <__ieee754_sqrt+0xa4>
    91f2:	4313      	orrs	r3, r2
    91f4:	d004      	beq.n	9200 <__ieee754_sqrt+0xd8>
    91f6:	1c42      	adds	r2, r0, #1
    91f8:	d04d      	beq.n	9296 <__ieee754_sqrt+0x16e>
    91fa:	f000 0301 	and.w	r3, r0, #1
    91fe:	4418      	add	r0, r3
    9200:	0840      	lsrs	r0, r0, #1
    9202:	1071      	asrs	r1, r6, #1
    9204:	07f3      	lsls	r3, r6, #31
    9206:	f101 517f 	add.w	r1, r1, #1069547520	; 0x3fc00000
    920a:	f501 1100 	add.w	r1, r1, #2097152	; 0x200000
    920e:	bf48      	it	mi
    9210:	f040 4000 	orrmi.w	r0, r0, #2147483648	; 0x80000000
    9214:	eb01 5307 	add.w	r3, r1, r7, lsl #20
    9218:	4602      	mov	r2, r0
    921a:	ec43 2b10 	vmov	d0, r2, r3
    921e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9222:	4673      	mov	r3, lr
    9224:	e7bb      	b.n	919e <__ieee754_sqrt+0x76>
    9226:	005b      	lsls	r3, r3, #1
    9228:	eb03 73d2 	add.w	r3, r3, r2, lsr #31
    922c:	0052      	lsls	r2, r2, #1
    922e:	e794      	b.n	915a <__ieee754_sqrt+0x32>
    9230:	f025 4100 	bic.w	r1, r5, #2147483648	; 0x80000000
    9234:	4321      	orrs	r1, r4
    9236:	d028      	beq.n	928a <__ieee754_sqrt+0x162>
    9238:	bbad      	cbnz	r5, 92a6 <__ieee754_sqrt+0x17e>
    923a:	462f      	mov	r7, r5
    923c:	0ad3      	lsrs	r3, r2, #11
    923e:	3f15      	subs	r7, #21
    9240:	0552      	lsls	r2, r2, #21
    9242:	2b00      	cmp	r3, #0
    9244:	d0fa      	beq.n	923c <__ieee754_sqrt+0x114>
    9246:	02dd      	lsls	r5, r3, #11
    9248:	d428      	bmi.n	929c <__ieee754_sqrt+0x174>
    924a:	2100      	movs	r1, #0
    924c:	e000      	b.n	9250 <__ieee754_sqrt+0x128>
    924e:	4601      	mov	r1, r0
    9250:	005b      	lsls	r3, r3, #1
    9252:	02dc      	lsls	r4, r3, #11
    9254:	f101 0001 	add.w	r0, r1, #1
    9258:	d5f9      	bpl.n	924e <__ieee754_sqrt+0x126>
    925a:	f1c0 0420 	rsb	r4, r0, #32
    925e:	fa22 f404 	lsr.w	r4, r2, r4
    9262:	4323      	orrs	r3, r4
    9264:	1a7f      	subs	r7, r7, r1
    9266:	4082      	lsls	r2, r0
    9268:	e76f      	b.n	914a <__ieee754_sqrt+0x22>
    926a:	ee10 2a10 	vmov	r2, s0
    926e:	462b      	mov	r3, r5
    9270:	ee10 0a10 	vmov	r0, s0
    9274:	4629      	mov	r1, r5
    9276:	f000 fce5 	bl	9c44 <__aeabi_dmul>
    927a:	4622      	mov	r2, r4
    927c:	462b      	mov	r3, r5
    927e:	f000 fb2f 	bl	98e0 <__adddf3>
    9282:	ec41 0b10 	vmov	d0, r0, r1
    9286:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    928a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    928e:	f1bc 0f00 	cmp.w	ip, #0
    9292:	daa2      	bge.n	91da <__ieee754_sqrt+0xb2>
    9294:	e7aa      	b.n	91ec <__ieee754_sqrt+0xc4>
    9296:	3601      	adds	r6, #1
    9298:	4620      	mov	r0, r4
    929a:	e7b2      	b.n	9202 <__ieee754_sqrt+0xda>
    929c:	2420      	movs	r4, #32
    929e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    92a2:	2000      	movs	r0, #0
    92a4:	e7db      	b.n	925e <__ieee754_sqrt+0x136>
    92a6:	ee10 2a10 	vmov	r2, s0
    92aa:	462b      	mov	r3, r5
    92ac:	4620      	mov	r0, r4
    92ae:	4629      	mov	r1, r5
    92b0:	f000 fb14 	bl	98dc <__aeabi_dsub>
    92b4:	4602      	mov	r2, r0
    92b6:	460b      	mov	r3, r1
    92b8:	f000 fdee 	bl	9e98 <__aeabi_ddiv>
    92bc:	ec41 0b10 	vmov	d0, r0, r1
    92c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    92c4:	7ff00000 	.word	0x7ff00000

000092c8 <atan>:
    92c8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    92cc:	ec55 4b10 	vmov	r4, r5, d0
    92d0:	4bd1      	ldr	r3, [pc, #836]	; (9618 <atan+0x350>)
    92d2:	f025 4600 	bic.w	r6, r5, #2147483648	; 0x80000000
    92d6:	429e      	cmp	r6, r3
    92d8:	46ab      	mov	fp, r5
    92da:	dd10      	ble.n	92fe <atan+0x36>
    92dc:	4bcf      	ldr	r3, [pc, #828]	; (961c <atan+0x354>)
    92de:	429e      	cmp	r6, r3
    92e0:	f300 80b2 	bgt.w	9448 <atan+0x180>
    92e4:	f000 80ad 	beq.w	9442 <atan+0x17a>
    92e8:	f1bb 0f00 	cmp.w	fp, #0
    92ec:	f340 80fd 	ble.w	94ea <atan+0x222>
    92f0:	a5ad      	add	r5, pc, #692	; (adr r5, 95a8 <atan+0x2e0>)
    92f2:	e9d5 4500 	ldrd	r4, r5, [r5]
    92f6:	ec45 4b10 	vmov	d0, r4, r5
    92fa:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    92fe:	4bc8      	ldr	r3, [pc, #800]	; (9620 <atan+0x358>)
    9300:	429e      	cmp	r6, r3
    9302:	f300 80c0 	bgt.w	9486 <atan+0x1be>
    9306:	f1a3 73de 	sub.w	r3, r3, #29097984	; 0x1bc0000
    930a:	429e      	cmp	r6, r3
    930c:	f340 80a8 	ble.w	9460 <atan+0x198>
    9310:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
    9314:	4622      	mov	r2, r4
    9316:	462b      	mov	r3, r5
    9318:	4620      	mov	r0, r4
    931a:	4629      	mov	r1, r5
    931c:	f000 fc92 	bl	9c44 <__aeabi_dmul>
    9320:	4602      	mov	r2, r0
    9322:	460b      	mov	r3, r1
    9324:	4680      	mov	r8, r0
    9326:	4689      	mov	r9, r1
    9328:	f000 fc8c 	bl	9c44 <__aeabi_dmul>
    932c:	a3a0      	add	r3, pc, #640	; (adr r3, 95b0 <atan+0x2e8>)
    932e:	e9d3 2300 	ldrd	r2, r3, [r3]
    9332:	4606      	mov	r6, r0
    9334:	460f      	mov	r7, r1
    9336:	f000 fc85 	bl	9c44 <__aeabi_dmul>
    933a:	a39f      	add	r3, pc, #636	; (adr r3, 95b8 <atan+0x2f0>)
    933c:	e9d3 2300 	ldrd	r2, r3, [r3]
    9340:	f000 face 	bl	98e0 <__adddf3>
    9344:	4632      	mov	r2, r6
    9346:	463b      	mov	r3, r7
    9348:	f000 fc7c 	bl	9c44 <__aeabi_dmul>
    934c:	a39c      	add	r3, pc, #624	; (adr r3, 95c0 <atan+0x2f8>)
    934e:	e9d3 2300 	ldrd	r2, r3, [r3]
    9352:	f000 fac5 	bl	98e0 <__adddf3>
    9356:	4632      	mov	r2, r6
    9358:	463b      	mov	r3, r7
    935a:	f000 fc73 	bl	9c44 <__aeabi_dmul>
    935e:	a39a      	add	r3, pc, #616	; (adr r3, 95c8 <atan+0x300>)
    9360:	e9d3 2300 	ldrd	r2, r3, [r3]
    9364:	f000 fabc 	bl	98e0 <__adddf3>
    9368:	4632      	mov	r2, r6
    936a:	463b      	mov	r3, r7
    936c:	f000 fc6a 	bl	9c44 <__aeabi_dmul>
    9370:	a397      	add	r3, pc, #604	; (adr r3, 95d0 <atan+0x308>)
    9372:	e9d3 2300 	ldrd	r2, r3, [r3]
    9376:	f000 fab3 	bl	98e0 <__adddf3>
    937a:	4632      	mov	r2, r6
    937c:	463b      	mov	r3, r7
    937e:	f000 fc61 	bl	9c44 <__aeabi_dmul>
    9382:	a395      	add	r3, pc, #596	; (adr r3, 95d8 <atan+0x310>)
    9384:	e9d3 2300 	ldrd	r2, r3, [r3]
    9388:	f000 faaa 	bl	98e0 <__adddf3>
    938c:	4642      	mov	r2, r8
    938e:	464b      	mov	r3, r9
    9390:	f000 fc58 	bl	9c44 <__aeabi_dmul>
    9394:	a392      	add	r3, pc, #584	; (adr r3, 95e0 <atan+0x318>)
    9396:	e9d3 2300 	ldrd	r2, r3, [r3]
    939a:	4680      	mov	r8, r0
    939c:	4689      	mov	r9, r1
    939e:	4630      	mov	r0, r6
    93a0:	4639      	mov	r1, r7
    93a2:	f000 fc4f 	bl	9c44 <__aeabi_dmul>
    93a6:	a390      	add	r3, pc, #576	; (adr r3, 95e8 <atan+0x320>)
    93a8:	e9d3 2300 	ldrd	r2, r3, [r3]
    93ac:	f000 fa96 	bl	98dc <__aeabi_dsub>
    93b0:	4632      	mov	r2, r6
    93b2:	463b      	mov	r3, r7
    93b4:	f000 fc46 	bl	9c44 <__aeabi_dmul>
    93b8:	a38d      	add	r3, pc, #564	; (adr r3, 95f0 <atan+0x328>)
    93ba:	e9d3 2300 	ldrd	r2, r3, [r3]
    93be:	f000 fa8d 	bl	98dc <__aeabi_dsub>
    93c2:	4632      	mov	r2, r6
    93c4:	463b      	mov	r3, r7
    93c6:	f000 fc3d 	bl	9c44 <__aeabi_dmul>
    93ca:	a38b      	add	r3, pc, #556	; (adr r3, 95f8 <atan+0x330>)
    93cc:	e9d3 2300 	ldrd	r2, r3, [r3]
    93d0:	f000 fa84 	bl	98dc <__aeabi_dsub>
    93d4:	4632      	mov	r2, r6
    93d6:	463b      	mov	r3, r7
    93d8:	f000 fc34 	bl	9c44 <__aeabi_dmul>
    93dc:	a388      	add	r3, pc, #544	; (adr r3, 9600 <atan+0x338>)
    93de:	e9d3 2300 	ldrd	r2, r3, [r3]
    93e2:	f000 fa7b 	bl	98dc <__aeabi_dsub>
    93e6:	4632      	mov	r2, r6
    93e8:	463b      	mov	r3, r7
    93ea:	f000 fc2b 	bl	9c44 <__aeabi_dmul>
    93ee:	f1ba 3fff 	cmp.w	sl, #4294967295	; 0xffffffff
    93f2:	4602      	mov	r2, r0
    93f4:	460b      	mov	r3, r1
    93f6:	d07c      	beq.n	94f2 <atan+0x22a>
    93f8:	4640      	mov	r0, r8
    93fa:	4649      	mov	r1, r9
    93fc:	f000 fa70 	bl	98e0 <__adddf3>
    9400:	4622      	mov	r2, r4
    9402:	462b      	mov	r3, r5
    9404:	f000 fc1e 	bl	9c44 <__aeabi_dmul>
    9408:	4e86      	ldr	r6, [pc, #536]	; (9624 <atan+0x35c>)
    940a:	4b87      	ldr	r3, [pc, #540]	; (9628 <atan+0x360>)
    940c:	ea4f 0aca 	mov.w	sl, sl, lsl #3
    9410:	4456      	add	r6, sl
    9412:	449a      	add	sl, r3
    9414:	e9da 2300 	ldrd	r2, r3, [sl]
    9418:	f000 fa60 	bl	98dc <__aeabi_dsub>
    941c:	4622      	mov	r2, r4
    941e:	462b      	mov	r3, r5
    9420:	f000 fa5c 	bl	98dc <__aeabi_dsub>
    9424:	4602      	mov	r2, r0
    9426:	460b      	mov	r3, r1
    9428:	e9d6 0100 	ldrd	r0, r1, [r6]
    942c:	f000 fa56 	bl	98dc <__aeabi_dsub>
    9430:	f1bb 0f00 	cmp.w	fp, #0
    9434:	db52      	blt.n	94dc <atan+0x214>
    9436:	4604      	mov	r4, r0
    9438:	460d      	mov	r5, r1
    943a:	ec45 4b10 	vmov	d0, r4, r5
    943e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9442:	2c00      	cmp	r4, #0
    9444:	f43f af50 	beq.w	92e8 <atan+0x20>
    9448:	4622      	mov	r2, r4
    944a:	462b      	mov	r3, r5
    944c:	4620      	mov	r0, r4
    944e:	4629      	mov	r1, r5
    9450:	f000 fa46 	bl	98e0 <__adddf3>
    9454:	4604      	mov	r4, r0
    9456:	460d      	mov	r5, r1
    9458:	ec45 4b10 	vmov	d0, r4, r5
    945c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9460:	a369      	add	r3, pc, #420	; (adr r3, 9608 <atan+0x340>)
    9462:	e9d3 2300 	ldrd	r2, r3, [r3]
    9466:	ee10 0a10 	vmov	r0, s0
    946a:	4629      	mov	r1, r5
    946c:	f000 fa38 	bl	98e0 <__adddf3>
    9470:	2200      	movs	r2, #0
    9472:	4b6e      	ldr	r3, [pc, #440]	; (962c <atan+0x364>)
    9474:	f000 fe76 	bl	a164 <__aeabi_dcmpgt>
    9478:	2800      	cmp	r0, #0
    947a:	f43f af49 	beq.w	9310 <atan+0x48>
    947e:	ec45 4b10 	vmov	d0, r4, r5
    9482:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9486:	f000 f8db 	bl	9640 <fabs>
    948a:	4b69      	ldr	r3, [pc, #420]	; (9630 <atan+0x368>)
    948c:	429e      	cmp	r6, r3
    948e:	ec55 4b10 	vmov	r4, r5, d0
    9492:	dc3f      	bgt.n	9514 <atan+0x24c>
    9494:	f5a3 2350 	sub.w	r3, r3, #851968	; 0xd0000
    9498:	429e      	cmp	r6, r3
    949a:	dc68      	bgt.n	956e <atan+0x2a6>
    949c:	ee10 2a10 	vmov	r2, s0
    94a0:	ee10 0a10 	vmov	r0, s0
    94a4:	462b      	mov	r3, r5
    94a6:	4629      	mov	r1, r5
    94a8:	f000 fa1a 	bl	98e0 <__adddf3>
    94ac:	2200      	movs	r2, #0
    94ae:	4b5f      	ldr	r3, [pc, #380]	; (962c <atan+0x364>)
    94b0:	f000 fa14 	bl	98dc <__aeabi_dsub>
    94b4:	2200      	movs	r2, #0
    94b6:	4606      	mov	r6, r0
    94b8:	460f      	mov	r7, r1
    94ba:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    94be:	4620      	mov	r0, r4
    94c0:	4629      	mov	r1, r5
    94c2:	f000 fa0d 	bl	98e0 <__adddf3>
    94c6:	4602      	mov	r2, r0
    94c8:	460b      	mov	r3, r1
    94ca:	4630      	mov	r0, r6
    94cc:	4639      	mov	r1, r7
    94ce:	f000 fce3 	bl	9e98 <__aeabi_ddiv>
    94d2:	f04f 0a00 	mov.w	sl, #0
    94d6:	4604      	mov	r4, r0
    94d8:	460d      	mov	r5, r1
    94da:	e71b      	b.n	9314 <atan+0x4c>
    94dc:	4604      	mov	r4, r0
    94de:	f101 4500 	add.w	r5, r1, #2147483648	; 0x80000000
    94e2:	ec45 4b10 	vmov	d0, r4, r5
    94e6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    94ea:	a549      	add	r5, pc, #292	; (adr r5, 9610 <atan+0x348>)
    94ec:	e9d5 4500 	ldrd	r4, r5, [r5]
    94f0:	e7b2      	b.n	9458 <atan+0x190>
    94f2:	4640      	mov	r0, r8
    94f4:	4649      	mov	r1, r9
    94f6:	f000 f9f3 	bl	98e0 <__adddf3>
    94fa:	4622      	mov	r2, r4
    94fc:	462b      	mov	r3, r5
    94fe:	f000 fba1 	bl	9c44 <__aeabi_dmul>
    9502:	4602      	mov	r2, r0
    9504:	460b      	mov	r3, r1
    9506:	4620      	mov	r0, r4
    9508:	4629      	mov	r1, r5
    950a:	f000 f9e7 	bl	98dc <__aeabi_dsub>
    950e:	4604      	mov	r4, r0
    9510:	460d      	mov	r5, r1
    9512:	e7a1      	b.n	9458 <atan+0x190>
    9514:	4b47      	ldr	r3, [pc, #284]	; (9634 <atan+0x36c>)
    9516:	429e      	cmp	r6, r3
    9518:	dc1d      	bgt.n	9556 <atan+0x28e>
    951a:	ee10 0a10 	vmov	r0, s0
    951e:	2200      	movs	r2, #0
    9520:	4b45      	ldr	r3, [pc, #276]	; (9638 <atan+0x370>)
    9522:	4629      	mov	r1, r5
    9524:	f000 f9da 	bl	98dc <__aeabi_dsub>
    9528:	2200      	movs	r2, #0
    952a:	4606      	mov	r6, r0
    952c:	460f      	mov	r7, r1
    952e:	4b42      	ldr	r3, [pc, #264]	; (9638 <atan+0x370>)
    9530:	4620      	mov	r0, r4
    9532:	4629      	mov	r1, r5
    9534:	f000 fb86 	bl	9c44 <__aeabi_dmul>
    9538:	2200      	movs	r2, #0
    953a:	4b3c      	ldr	r3, [pc, #240]	; (962c <atan+0x364>)
    953c:	f000 f9d0 	bl	98e0 <__adddf3>
    9540:	4602      	mov	r2, r0
    9542:	460b      	mov	r3, r1
    9544:	4630      	mov	r0, r6
    9546:	4639      	mov	r1, r7
    9548:	f000 fca6 	bl	9e98 <__aeabi_ddiv>
    954c:	f04f 0a02 	mov.w	sl, #2
    9550:	4604      	mov	r4, r0
    9552:	460d      	mov	r5, r1
    9554:	e6de      	b.n	9314 <atan+0x4c>
    9556:	462b      	mov	r3, r5
    9558:	ee10 2a10 	vmov	r2, s0
    955c:	2000      	movs	r0, #0
    955e:	4937      	ldr	r1, [pc, #220]	; (963c <atan+0x374>)
    9560:	f000 fc9a 	bl	9e98 <__aeabi_ddiv>
    9564:	f04f 0a03 	mov.w	sl, #3
    9568:	4604      	mov	r4, r0
    956a:	460d      	mov	r5, r1
    956c:	e6d2      	b.n	9314 <atan+0x4c>
    956e:	ee10 0a10 	vmov	r0, s0
    9572:	2200      	movs	r2, #0
    9574:	4b2d      	ldr	r3, [pc, #180]	; (962c <atan+0x364>)
    9576:	4629      	mov	r1, r5
    9578:	f000 f9b0 	bl	98dc <__aeabi_dsub>
    957c:	2200      	movs	r2, #0
    957e:	4606      	mov	r6, r0
    9580:	460f      	mov	r7, r1
    9582:	4b2a      	ldr	r3, [pc, #168]	; (962c <atan+0x364>)
    9584:	4620      	mov	r0, r4
    9586:	4629      	mov	r1, r5
    9588:	f000 f9aa 	bl	98e0 <__adddf3>
    958c:	4602      	mov	r2, r0
    958e:	460b      	mov	r3, r1
    9590:	4630      	mov	r0, r6
    9592:	4639      	mov	r1, r7
    9594:	f000 fc80 	bl	9e98 <__aeabi_ddiv>
    9598:	f04f 0a01 	mov.w	sl, #1
    959c:	4604      	mov	r4, r0
    959e:	460d      	mov	r5, r1
    95a0:	e6b8      	b.n	9314 <atan+0x4c>
    95a2:	bf00      	nop
    95a4:	f3af 8000 	nop.w
    95a8:	54442d18 	.word	0x54442d18
    95ac:	3ff921fb 	.word	0x3ff921fb
    95b0:	e322da11 	.word	0xe322da11
    95b4:	3f90ad3a 	.word	0x3f90ad3a
    95b8:	24760deb 	.word	0x24760deb
    95bc:	3fa97b4b 	.word	0x3fa97b4b
    95c0:	a0d03d51 	.word	0xa0d03d51
    95c4:	3fb10d66 	.word	0x3fb10d66
    95c8:	c54c206e 	.word	0xc54c206e
    95cc:	3fb745cd 	.word	0x3fb745cd
    95d0:	920083ff 	.word	0x920083ff
    95d4:	3fc24924 	.word	0x3fc24924
    95d8:	5555550d 	.word	0x5555550d
    95dc:	3fd55555 	.word	0x3fd55555
    95e0:	2c6a6c2f 	.word	0x2c6a6c2f
    95e4:	bfa2b444 	.word	0xbfa2b444
    95e8:	52defd9a 	.word	0x52defd9a
    95ec:	3fadde2d 	.word	0x3fadde2d
    95f0:	af749a6d 	.word	0xaf749a6d
    95f4:	3fb3b0f2 	.word	0x3fb3b0f2
    95f8:	fe231671 	.word	0xfe231671
    95fc:	3fbc71c6 	.word	0x3fbc71c6
    9600:	9998ebc4 	.word	0x9998ebc4
    9604:	3fc99999 	.word	0x3fc99999
    9608:	8800759c 	.word	0x8800759c
    960c:	7e37e43c 	.word	0x7e37e43c
    9610:	54442d18 	.word	0x54442d18
    9614:	bff921fb 	.word	0xbff921fb
    9618:	440fffff 	.word	0x440fffff
    961c:	7ff00000 	.word	0x7ff00000
    9620:	3fdbffff 	.word	0x3fdbffff
    9624:	0000c460 	.word	0x0000c460
    9628:	0000c440 	.word	0x0000c440
    962c:	3ff00000 	.word	0x3ff00000
    9630:	3ff2ffff 	.word	0x3ff2ffff
    9634:	40037fff 	.word	0x40037fff
    9638:	3ff80000 	.word	0x3ff80000
    963c:	bff00000 	.word	0xbff00000

00009640 <fabs>:
    9640:	ec53 2b10 	vmov	r2, r3, d0
    9644:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    9648:	ec43 2b10 	vmov	d0, r2, r3
    964c:	4770      	bx	lr
    964e:	bf00      	nop

00009650 <finite>:
    9650:	ee10 3a90 	vmov	r3, s1
    9654:	f043 4000 	orr.w	r0, r3, #2147483648	; 0x80000000
    9658:	f500 1080 	add.w	r0, r0, #1048576	; 0x100000
    965c:	0fc0      	lsrs	r0, r0, #31
    965e:	4770      	bx	lr

00009660 <matherr>:
    9660:	2000      	movs	r0, #0
    9662:	4770      	bx	lr
    9664:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

00009668 <nan>:
    9668:	ed9f 0b01 	vldr	d0, [pc, #4]	; 9670 <nan+0x8>
    966c:	4770      	bx	lr
    966e:	bf00      	nop
    9670:	00000000 	.word	0x00000000
    9674:	7ff80000 	.word	0x7ff80000

00009678 <rint>:
    9678:	b5f0      	push	{r4, r5, r6, r7, lr}
    967a:	ec53 2b10 	vmov	r2, r3, d0
    967e:	f3c3 560a 	ubfx	r6, r3, #20, #11
    9682:	f2a6 30ff 	subw	r0, r6, #1023	; 0x3ff
    9686:	2813      	cmp	r0, #19
    9688:	b083      	sub	sp, #12
    968a:	4619      	mov	r1, r3
    968c:	ea4f 74d3 	mov.w	r4, r3, lsr #31
    9690:	ee10 5a10 	vmov	r5, s0
    9694:	dc2f      	bgt.n	96f6 <rint+0x7e>
    9696:	2800      	cmp	r0, #0
    9698:	db49      	blt.n	972e <rint+0xb6>
    969a:	4e3f      	ldr	r6, [pc, #252]	; (9798 <rint+0x120>)
    969c:	4106      	asrs	r6, r0
    969e:	ea03 0706 	and.w	r7, r3, r6
    96a2:	4317      	orrs	r7, r2
    96a4:	d02c      	beq.n	9700 <rint+0x88>
    96a6:	0876      	lsrs	r6, r6, #1
    96a8:	4033      	ands	r3, r6
    96aa:	431d      	orrs	r5, r3
    96ac:	d00c      	beq.n	96c8 <rint+0x50>
    96ae:	f44f 2380 	mov.w	r3, #262144	; 0x40000
    96b2:	2813      	cmp	r0, #19
    96b4:	ea21 0606 	bic.w	r6, r1, r6
    96b8:	fa43 f100 	asr.w	r1, r3, r0
    96bc:	ea41 0106 	orr.w	r1, r1, r6
    96c0:	bf0c      	ite	eq
    96c2:	f04f 4500 	moveq.w	r5, #2147483648	; 0x80000000
    96c6:	2500      	movne	r5, #0
    96c8:	4834      	ldr	r0, [pc, #208]	; (979c <rint+0x124>)
    96ca:	eb00 04c4 	add.w	r4, r0, r4, lsl #3
    96ce:	462a      	mov	r2, r5
    96d0:	e9d4 4500 	ldrd	r4, r5, [r4]
    96d4:	4610      	mov	r0, r2
    96d6:	462b      	mov	r3, r5
    96d8:	4622      	mov	r2, r4
    96da:	f000 f901 	bl	98e0 <__adddf3>
    96de:	e9cd 0100 	strd	r0, r1, [sp]
    96e2:	4622      	mov	r2, r4
    96e4:	462b      	mov	r3, r5
    96e6:	e9dd 0100 	ldrd	r0, r1, [sp]
    96ea:	f000 f8f7 	bl	98dc <__aeabi_dsub>
    96ee:	ec41 0b10 	vmov	d0, r0, r1
    96f2:	b003      	add	sp, #12
    96f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    96f6:	2833      	cmp	r0, #51	; 0x33
    96f8:	dd06      	ble.n	9708 <rint+0x90>
    96fa:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
    96fe:	d042      	beq.n	9786 <rint+0x10e>
    9700:	ec43 2b10 	vmov	d0, r2, r3
    9704:	b003      	add	sp, #12
    9706:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9708:	f2a6 4613 	subw	r6, r6, #1043	; 0x413
    970c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    9710:	40f0      	lsrs	r0, r6
    9712:	4202      	tst	r2, r0
    9714:	d0f4      	beq.n	9700 <rint+0x88>
    9716:	0840      	lsrs	r0, r0, #1
    9718:	4202      	tst	r2, r0
    971a:	d0d5      	beq.n	96c8 <rint+0x50>
    971c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    9720:	ea25 0000 	bic.w	r0, r5, r0
    9724:	fa43 f606 	asr.w	r6, r3, r6
    9728:	ea46 0500 	orr.w	r5, r6, r0
    972c:	e7cc      	b.n	96c8 <rint+0x50>
    972e:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
    9732:	4310      	orrs	r0, r2
    9734:	ee10 7a10 	vmov	r7, s0
    9738:	d0e2      	beq.n	9700 <rint+0x88>
    973a:	f3c3 0013 	ubfx	r0, r3, #0, #20
    973e:	4307      	orrs	r7, r0
    9740:	4278      	negs	r0, r7
    9742:	4307      	orrs	r7, r0
    9744:	4815      	ldr	r0, [pc, #84]	; (979c <rint+0x124>)
    9746:	0c59      	lsrs	r1, r3, #17
    9748:	0b3f      	lsrs	r7, r7, #12
    974a:	0449      	lsls	r1, r1, #17
    974c:	f407 2700 	and.w	r7, r7, #524288	; 0x80000
    9750:	eb00 00c4 	add.w	r0, r0, r4, lsl #3
    9754:	ea47 0301 	orr.w	r3, r7, r1
    9758:	e9d0 6700 	ldrd	r6, r7, [r0]
    975c:	4619      	mov	r1, r3
    975e:	4610      	mov	r0, r2
    9760:	463b      	mov	r3, r7
    9762:	4632      	mov	r2, r6
    9764:	f000 f8bc 	bl	98e0 <__adddf3>
    9768:	e9cd 0100 	strd	r0, r1, [sp]
    976c:	463b      	mov	r3, r7
    976e:	4632      	mov	r2, r6
    9770:	e9dd 0100 	ldrd	r0, r1, [sp]
    9774:	f000 f8b2 	bl	98dc <__aeabi_dsub>
    9778:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
    977c:	ea43 71c4 	orr.w	r1, r3, r4, lsl #31
    9780:	ec41 0b10 	vmov	d0, r0, r1
    9784:	e7be      	b.n	9704 <rint+0x8c>
    9786:	ee10 0a10 	vmov	r0, s0
    978a:	4619      	mov	r1, r3
    978c:	f000 f8a8 	bl	98e0 <__adddf3>
    9790:	ec41 0b10 	vmov	d0, r0, r1
    9794:	e7b6      	b.n	9704 <rint+0x8c>
    9796:	bf00      	nop
    9798:	000fffff 	.word	0x000fffff
    979c:	0000c480 	.word	0x0000c480

000097a0 <scalbn>:
    97a0:	ec53 2b10 	vmov	r2, r3, d0
    97a4:	b570      	push	{r4, r5, r6, lr}
    97a6:	f3c3 540a 	ubfx	r4, r3, #20, #11
    97aa:	4619      	mov	r1, r3
    97ac:	4605      	mov	r5, r0
    97ae:	bb14      	cbnz	r4, 97f6 <scalbn+0x56>
    97b0:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
    97b4:	4311      	orrs	r1, r2
    97b6:	d02a      	beq.n	980e <scalbn+0x6e>
    97b8:	4619      	mov	r1, r3
    97ba:	2200      	movs	r2, #0
    97bc:	4b38      	ldr	r3, [pc, #224]	; (98a0 <scalbn+0x100>)
    97be:	4e39      	ldr	r6, [pc, #228]	; (98a4 <scalbn+0x104>)
    97c0:	ee10 0a10 	vmov	r0, s0
    97c4:	f000 fa3e 	bl	9c44 <__aeabi_dmul>
    97c8:	42b5      	cmp	r5, r6
    97ca:	4602      	mov	r2, r0
    97cc:	460b      	mov	r3, r1
    97ce:	db1f      	blt.n	9810 <scalbn+0x70>
    97d0:	f3c1 540a 	ubfx	r4, r1, #20, #11
    97d4:	3c36      	subs	r4, #54	; 0x36
    97d6:	442c      	add	r4, r5
    97d8:	f240 70fe 	movw	r0, #2046	; 0x7fe
    97dc:	4284      	cmp	r4, r0
    97de:	dc1f      	bgt.n	9820 <scalbn+0x80>
    97e0:	2c00      	cmp	r4, #0
    97e2:	dd2d      	ble.n	9840 <scalbn+0xa0>
    97e4:	f021 41ff 	bic.w	r1, r1, #2139095040	; 0x7f800000
    97e8:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
    97ec:	ea41 5304 	orr.w	r3, r1, r4, lsl #20
    97f0:	ec43 2b10 	vmov	d0, r2, r3
    97f4:	bd70      	pop	{r4, r5, r6, pc}
    97f6:	f240 70ff 	movw	r0, #2047	; 0x7ff
    97fa:	4284      	cmp	r4, r0
    97fc:	d1eb      	bne.n	97d6 <scalbn+0x36>
    97fe:	ee10 0a10 	vmov	r0, s0
    9802:	4619      	mov	r1, r3
    9804:	f000 f86c 	bl	98e0 <__adddf3>
    9808:	ec41 0b10 	vmov	d0, r0, r1
    980c:	bd70      	pop	{r4, r5, r6, pc}
    980e:	bd70      	pop	{r4, r5, r6, pc}
    9810:	a31f      	add	r3, pc, #124	; (adr r3, 9890 <scalbn+0xf0>)
    9812:	e9d3 2300 	ldrd	r2, r3, [r3]
    9816:	f000 fa15 	bl	9c44 <__aeabi_dmul>
    981a:	ec41 0b10 	vmov	d0, r0, r1
    981e:	bd70      	pop	{r4, r5, r6, pc}
    9820:	ec43 2b11 	vmov	d1, r2, r3
    9824:	ed9f 0b1c 	vldr	d0, [pc, #112]	; 9898 <scalbn+0xf8>
    9828:	f000 f840 	bl	98ac <copysign>
    982c:	a31a      	add	r3, pc, #104	; (adr r3, 9898 <scalbn+0xf8>)
    982e:	e9d3 2300 	ldrd	r2, r3, [r3]
    9832:	ec51 0b10 	vmov	r0, r1, d0
    9836:	f000 fa05 	bl	9c44 <__aeabi_dmul>
    983a:	ec41 0b10 	vmov	d0, r0, r1
    983e:	bd70      	pop	{r4, r5, r6, pc}
    9840:	f114 0f35 	cmn.w	r4, #53	; 0x35
    9844:	da13      	bge.n	986e <scalbn+0xce>
    9846:	f24c 3150 	movw	r1, #50000	; 0xc350
    984a:	428d      	cmp	r5, r1
    984c:	ec43 2b11 	vmov	d1, r2, r3
    9850:	dce8      	bgt.n	9824 <scalbn+0x84>
    9852:	ed9f 0b0f 	vldr	d0, [pc, #60]	; 9890 <scalbn+0xf0>
    9856:	f000 f829 	bl	98ac <copysign>
    985a:	a30d      	add	r3, pc, #52	; (adr r3, 9890 <scalbn+0xf0>)
    985c:	e9d3 2300 	ldrd	r2, r3, [r3]
    9860:	ec51 0b10 	vmov	r0, r1, d0
    9864:	f000 f9ee 	bl	9c44 <__aeabi_dmul>
    9868:	ec41 0b10 	vmov	d0, r0, r1
    986c:	bd70      	pop	{r4, r5, r6, pc}
    986e:	f021 41ff 	bic.w	r1, r1, #2139095040	; 0x7f800000
    9872:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
    9876:	3436      	adds	r4, #54	; 0x36
    9878:	ea41 5304 	orr.w	r3, r1, r4, lsl #20
    987c:	4610      	mov	r0, r2
    987e:	4619      	mov	r1, r3
    9880:	2200      	movs	r2, #0
    9882:	4b09      	ldr	r3, [pc, #36]	; (98a8 <scalbn+0x108>)
    9884:	f000 f9de 	bl	9c44 <__aeabi_dmul>
    9888:	ec41 0b10 	vmov	d0, r0, r1
    988c:	bd70      	pop	{r4, r5, r6, pc}
    988e:	bf00      	nop
    9890:	c2f8f359 	.word	0xc2f8f359
    9894:	01a56e1f 	.word	0x01a56e1f
    9898:	8800759c 	.word	0x8800759c
    989c:	7e37e43c 	.word	0x7e37e43c
    98a0:	43500000 	.word	0x43500000
    98a4:	ffff3cb0 	.word	0xffff3cb0
    98a8:	3c900000 	.word	0x3c900000

000098ac <copysign>:
    98ac:	ec53 2b10 	vmov	r2, r3, d0
    98b0:	ee11 0a90 	vmov	r0, s3
    98b4:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
    98b8:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
    98bc:	ea41 0300 	orr.w	r3, r1, r0
    98c0:	ec43 2b10 	vmov	d0, r2, r3
    98c4:	4770      	bx	lr
    98c6:	bf00      	nop

000098c8 <__aeabi_atexit>:
    98c8:	460b      	mov	r3, r1
    98ca:	4601      	mov	r1, r0
    98cc:	4618      	mov	r0, r3
    98ce:	f000 bfb3 	b.w	a838 <__cxa_atexit>
    98d2:	bf00      	nop

000098d4 <__aeabi_drsub>:
    98d4:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
    98d8:	e002      	b.n	98e0 <__adddf3>
    98da:	bf00      	nop

000098dc <__aeabi_dsub>:
    98dc:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

000098e0 <__adddf3>:
    98e0:	b530      	push	{r4, r5, lr}
    98e2:	ea4f 0441 	mov.w	r4, r1, lsl #1
    98e6:	ea4f 0543 	mov.w	r5, r3, lsl #1
    98ea:	ea94 0f05 	teq	r4, r5
    98ee:	bf08      	it	eq
    98f0:	ea90 0f02 	teqeq	r0, r2
    98f4:	bf1f      	itttt	ne
    98f6:	ea54 0c00 	orrsne.w	ip, r4, r0
    98fa:	ea55 0c02 	orrsne.w	ip, r5, r2
    98fe:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
    9902:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    9906:	f000 80e2 	beq.w	9ace <__adddf3+0x1ee>
    990a:	ea4f 5454 	mov.w	r4, r4, lsr #21
    990e:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
    9912:	bfb8      	it	lt
    9914:	426d      	neglt	r5, r5
    9916:	dd0c      	ble.n	9932 <__adddf3+0x52>
    9918:	442c      	add	r4, r5
    991a:	ea80 0202 	eor.w	r2, r0, r2
    991e:	ea81 0303 	eor.w	r3, r1, r3
    9922:	ea82 0000 	eor.w	r0, r2, r0
    9926:	ea83 0101 	eor.w	r1, r3, r1
    992a:	ea80 0202 	eor.w	r2, r0, r2
    992e:	ea81 0303 	eor.w	r3, r1, r3
    9932:	2d36      	cmp	r5, #54	; 0x36
    9934:	bf88      	it	hi
    9936:	bd30      	pophi	{r4, r5, pc}
    9938:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    993c:	ea4f 3101 	mov.w	r1, r1, lsl #12
    9940:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
    9944:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
    9948:	d002      	beq.n	9950 <__adddf3+0x70>
    994a:	4240      	negs	r0, r0
    994c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    9950:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
    9954:	ea4f 3303 	mov.w	r3, r3, lsl #12
    9958:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
    995c:	d002      	beq.n	9964 <__adddf3+0x84>
    995e:	4252      	negs	r2, r2
    9960:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    9964:	ea94 0f05 	teq	r4, r5
    9968:	f000 80a7 	beq.w	9aba <__adddf3+0x1da>
    996c:	f1a4 0401 	sub.w	r4, r4, #1
    9970:	f1d5 0e20 	rsbs	lr, r5, #32
    9974:	db0d      	blt.n	9992 <__adddf3+0xb2>
    9976:	fa02 fc0e 	lsl.w	ip, r2, lr
    997a:	fa22 f205 	lsr.w	r2, r2, r5
    997e:	1880      	adds	r0, r0, r2
    9980:	f141 0100 	adc.w	r1, r1, #0
    9984:	fa03 f20e 	lsl.w	r2, r3, lr
    9988:	1880      	adds	r0, r0, r2
    998a:	fa43 f305 	asr.w	r3, r3, r5
    998e:	4159      	adcs	r1, r3
    9990:	e00e      	b.n	99b0 <__adddf3+0xd0>
    9992:	f1a5 0520 	sub.w	r5, r5, #32
    9996:	f10e 0e20 	add.w	lr, lr, #32
    999a:	2a01      	cmp	r2, #1
    999c:	fa03 fc0e 	lsl.w	ip, r3, lr
    99a0:	bf28      	it	cs
    99a2:	f04c 0c02 	orrcs.w	ip, ip, #2
    99a6:	fa43 f305 	asr.w	r3, r3, r5
    99aa:	18c0      	adds	r0, r0, r3
    99ac:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
    99b0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    99b4:	d507      	bpl.n	99c6 <__adddf3+0xe6>
    99b6:	f04f 0e00 	mov.w	lr, #0
    99ba:	f1dc 0c00 	rsbs	ip, ip, #0
    99be:	eb7e 0000 	sbcs.w	r0, lr, r0
    99c2:	eb6e 0101 	sbc.w	r1, lr, r1
    99c6:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    99ca:	d31b      	bcc.n	9a04 <__adddf3+0x124>
    99cc:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    99d0:	d30c      	bcc.n	99ec <__adddf3+0x10c>
    99d2:	0849      	lsrs	r1, r1, #1
    99d4:	ea5f 0030 	movs.w	r0, r0, rrx
    99d8:	ea4f 0c3c 	mov.w	ip, ip, rrx
    99dc:	f104 0401 	add.w	r4, r4, #1
    99e0:	ea4f 5244 	mov.w	r2, r4, lsl #21
    99e4:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
    99e8:	f080 809a 	bcs.w	9b20 <__adddf3+0x240>
    99ec:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    99f0:	bf08      	it	eq
    99f2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    99f6:	f150 0000 	adcs.w	r0, r0, #0
    99fa:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    99fe:	ea41 0105 	orr.w	r1, r1, r5
    9a02:	bd30      	pop	{r4, r5, pc}
    9a04:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
    9a08:	4140      	adcs	r0, r0
    9a0a:	eb41 0101 	adc.w	r1, r1, r1
    9a0e:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    9a12:	f1a4 0401 	sub.w	r4, r4, #1
    9a16:	d1e9      	bne.n	99ec <__adddf3+0x10c>
    9a18:	f091 0f00 	teq	r1, #0
    9a1c:	bf04      	itt	eq
    9a1e:	4601      	moveq	r1, r0
    9a20:	2000      	moveq	r0, #0
    9a22:	fab1 f381 	clz	r3, r1
    9a26:	bf08      	it	eq
    9a28:	3320      	addeq	r3, #32
    9a2a:	f1a3 030b 	sub.w	r3, r3, #11
    9a2e:	f1b3 0220 	subs.w	r2, r3, #32
    9a32:	da0c      	bge.n	9a4e <__adddf3+0x16e>
    9a34:	320c      	adds	r2, #12
    9a36:	dd08      	ble.n	9a4a <__adddf3+0x16a>
    9a38:	f102 0c14 	add.w	ip, r2, #20
    9a3c:	f1c2 020c 	rsb	r2, r2, #12
    9a40:	fa01 f00c 	lsl.w	r0, r1, ip
    9a44:	fa21 f102 	lsr.w	r1, r1, r2
    9a48:	e00c      	b.n	9a64 <__adddf3+0x184>
    9a4a:	f102 0214 	add.w	r2, r2, #20
    9a4e:	bfd8      	it	le
    9a50:	f1c2 0c20 	rsble	ip, r2, #32
    9a54:	fa01 f102 	lsl.w	r1, r1, r2
    9a58:	fa20 fc0c 	lsr.w	ip, r0, ip
    9a5c:	bfdc      	itt	le
    9a5e:	ea41 010c 	orrle.w	r1, r1, ip
    9a62:	4090      	lslle	r0, r2
    9a64:	1ae4      	subs	r4, r4, r3
    9a66:	bfa2      	ittt	ge
    9a68:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
    9a6c:	4329      	orrge	r1, r5
    9a6e:	bd30      	popge	{r4, r5, pc}
    9a70:	ea6f 0404 	mvn.w	r4, r4
    9a74:	3c1f      	subs	r4, #31
    9a76:	da1c      	bge.n	9ab2 <__adddf3+0x1d2>
    9a78:	340c      	adds	r4, #12
    9a7a:	dc0e      	bgt.n	9a9a <__adddf3+0x1ba>
    9a7c:	f104 0414 	add.w	r4, r4, #20
    9a80:	f1c4 0220 	rsb	r2, r4, #32
    9a84:	fa20 f004 	lsr.w	r0, r0, r4
    9a88:	fa01 f302 	lsl.w	r3, r1, r2
    9a8c:	ea40 0003 	orr.w	r0, r0, r3
    9a90:	fa21 f304 	lsr.w	r3, r1, r4
    9a94:	ea45 0103 	orr.w	r1, r5, r3
    9a98:	bd30      	pop	{r4, r5, pc}
    9a9a:	f1c4 040c 	rsb	r4, r4, #12
    9a9e:	f1c4 0220 	rsb	r2, r4, #32
    9aa2:	fa20 f002 	lsr.w	r0, r0, r2
    9aa6:	fa01 f304 	lsl.w	r3, r1, r4
    9aaa:	ea40 0003 	orr.w	r0, r0, r3
    9aae:	4629      	mov	r1, r5
    9ab0:	bd30      	pop	{r4, r5, pc}
    9ab2:	fa21 f004 	lsr.w	r0, r1, r4
    9ab6:	4629      	mov	r1, r5
    9ab8:	bd30      	pop	{r4, r5, pc}
    9aba:	f094 0f00 	teq	r4, #0
    9abe:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
    9ac2:	bf06      	itte	eq
    9ac4:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
    9ac8:	3401      	addeq	r4, #1
    9aca:	3d01      	subne	r5, #1
    9acc:	e74e      	b.n	996c <__adddf3+0x8c>
    9ace:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    9ad2:	bf18      	it	ne
    9ad4:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    9ad8:	d029      	beq.n	9b2e <__adddf3+0x24e>
    9ada:	ea94 0f05 	teq	r4, r5
    9ade:	bf08      	it	eq
    9ae0:	ea90 0f02 	teqeq	r0, r2
    9ae4:	d005      	beq.n	9af2 <__adddf3+0x212>
    9ae6:	ea54 0c00 	orrs.w	ip, r4, r0
    9aea:	bf04      	itt	eq
    9aec:	4619      	moveq	r1, r3
    9aee:	4610      	moveq	r0, r2
    9af0:	bd30      	pop	{r4, r5, pc}
    9af2:	ea91 0f03 	teq	r1, r3
    9af6:	bf1e      	ittt	ne
    9af8:	2100      	movne	r1, #0
    9afa:	2000      	movne	r0, #0
    9afc:	bd30      	popne	{r4, r5, pc}
    9afe:	ea5f 5c54 	movs.w	ip, r4, lsr #21
    9b02:	d105      	bne.n	9b10 <__adddf3+0x230>
    9b04:	0040      	lsls	r0, r0, #1
    9b06:	4149      	adcs	r1, r1
    9b08:	bf28      	it	cs
    9b0a:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
    9b0e:	bd30      	pop	{r4, r5, pc}
    9b10:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
    9b14:	bf3c      	itt	cc
    9b16:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
    9b1a:	bd30      	popcc	{r4, r5, pc}
    9b1c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    9b20:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
    9b24:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    9b28:	f04f 0000 	mov.w	r0, #0
    9b2c:	bd30      	pop	{r4, r5, pc}
    9b2e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    9b32:	bf1a      	itte	ne
    9b34:	4619      	movne	r1, r3
    9b36:	4610      	movne	r0, r2
    9b38:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
    9b3c:	bf1c      	itt	ne
    9b3e:	460b      	movne	r3, r1
    9b40:	4602      	movne	r2, r0
    9b42:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    9b46:	bf06      	itte	eq
    9b48:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
    9b4c:	ea91 0f03 	teqeq	r1, r3
    9b50:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
    9b54:	bd30      	pop	{r4, r5, pc}
    9b56:	bf00      	nop

00009b58 <__aeabi_ui2d>:
    9b58:	f090 0f00 	teq	r0, #0
    9b5c:	bf04      	itt	eq
    9b5e:	2100      	moveq	r1, #0
    9b60:	4770      	bxeq	lr
    9b62:	b530      	push	{r4, r5, lr}
    9b64:	f44f 6480 	mov.w	r4, #1024	; 0x400
    9b68:	f104 0432 	add.w	r4, r4, #50	; 0x32
    9b6c:	f04f 0500 	mov.w	r5, #0
    9b70:	f04f 0100 	mov.w	r1, #0
    9b74:	e750      	b.n	9a18 <__adddf3+0x138>
    9b76:	bf00      	nop

00009b78 <__aeabi_i2d>:
    9b78:	f090 0f00 	teq	r0, #0
    9b7c:	bf04      	itt	eq
    9b7e:	2100      	moveq	r1, #0
    9b80:	4770      	bxeq	lr
    9b82:	b530      	push	{r4, r5, lr}
    9b84:	f44f 6480 	mov.w	r4, #1024	; 0x400
    9b88:	f104 0432 	add.w	r4, r4, #50	; 0x32
    9b8c:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
    9b90:	bf48      	it	mi
    9b92:	4240      	negmi	r0, r0
    9b94:	f04f 0100 	mov.w	r1, #0
    9b98:	e73e      	b.n	9a18 <__adddf3+0x138>
    9b9a:	bf00      	nop

00009b9c <__aeabi_f2d>:
    9b9c:	0042      	lsls	r2, r0, #1
    9b9e:	ea4f 01e2 	mov.w	r1, r2, asr #3
    9ba2:	ea4f 0131 	mov.w	r1, r1, rrx
    9ba6:	ea4f 7002 	mov.w	r0, r2, lsl #28
    9baa:	bf1f      	itttt	ne
    9bac:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
    9bb0:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    9bb4:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
    9bb8:	4770      	bxne	lr
    9bba:	f092 0f00 	teq	r2, #0
    9bbe:	bf14      	ite	ne
    9bc0:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    9bc4:	4770      	bxeq	lr
    9bc6:	b530      	push	{r4, r5, lr}
    9bc8:	f44f 7460 	mov.w	r4, #896	; 0x380
    9bcc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    9bd0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    9bd4:	e720      	b.n	9a18 <__adddf3+0x138>
    9bd6:	bf00      	nop

00009bd8 <__aeabi_ul2d>:
    9bd8:	ea50 0201 	orrs.w	r2, r0, r1
    9bdc:	bf08      	it	eq
    9bde:	4770      	bxeq	lr
    9be0:	b530      	push	{r4, r5, lr}
    9be2:	f04f 0500 	mov.w	r5, #0
    9be6:	e00a      	b.n	9bfe <__aeabi_l2d+0x16>

00009be8 <__aeabi_l2d>:
    9be8:	ea50 0201 	orrs.w	r2, r0, r1
    9bec:	bf08      	it	eq
    9bee:	4770      	bxeq	lr
    9bf0:	b530      	push	{r4, r5, lr}
    9bf2:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
    9bf6:	d502      	bpl.n	9bfe <__aeabi_l2d+0x16>
    9bf8:	4240      	negs	r0, r0
    9bfa:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    9bfe:	f44f 6480 	mov.w	r4, #1024	; 0x400
    9c02:	f104 0432 	add.w	r4, r4, #50	; 0x32
    9c06:	ea5f 5c91 	movs.w	ip, r1, lsr #22
    9c0a:	f43f aedc 	beq.w	99c6 <__adddf3+0xe6>
    9c0e:	f04f 0203 	mov.w	r2, #3
    9c12:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    9c16:	bf18      	it	ne
    9c18:	3203      	addne	r2, #3
    9c1a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    9c1e:	bf18      	it	ne
    9c20:	3203      	addne	r2, #3
    9c22:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
    9c26:	f1c2 0320 	rsb	r3, r2, #32
    9c2a:	fa00 fc03 	lsl.w	ip, r0, r3
    9c2e:	fa20 f002 	lsr.w	r0, r0, r2
    9c32:	fa01 fe03 	lsl.w	lr, r1, r3
    9c36:	ea40 000e 	orr.w	r0, r0, lr
    9c3a:	fa21 f102 	lsr.w	r1, r1, r2
    9c3e:	4414      	add	r4, r2
    9c40:	e6c1      	b.n	99c6 <__adddf3+0xe6>
    9c42:	bf00      	nop

00009c44 <__aeabi_dmul>:
    9c44:	b570      	push	{r4, r5, r6, lr}
    9c46:	f04f 0cff 	mov.w	ip, #255	; 0xff
    9c4a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    9c4e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    9c52:	bf1d      	ittte	ne
    9c54:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    9c58:	ea94 0f0c 	teqne	r4, ip
    9c5c:	ea95 0f0c 	teqne	r5, ip
    9c60:	f000 f8de 	bleq	9e20 <__aeabi_dmul+0x1dc>
    9c64:	442c      	add	r4, r5
    9c66:	ea81 0603 	eor.w	r6, r1, r3
    9c6a:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
    9c6e:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
    9c72:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
    9c76:	bf18      	it	ne
    9c78:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
    9c7c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    9c80:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    9c84:	d038      	beq.n	9cf8 <__aeabi_dmul+0xb4>
    9c86:	fba0 ce02 	umull	ip, lr, r0, r2
    9c8a:	f04f 0500 	mov.w	r5, #0
    9c8e:	fbe1 e502 	umlal	lr, r5, r1, r2
    9c92:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
    9c96:	fbe0 e503 	umlal	lr, r5, r0, r3
    9c9a:	f04f 0600 	mov.w	r6, #0
    9c9e:	fbe1 5603 	umlal	r5, r6, r1, r3
    9ca2:	f09c 0f00 	teq	ip, #0
    9ca6:	bf18      	it	ne
    9ca8:	f04e 0e01 	orrne.w	lr, lr, #1
    9cac:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
    9cb0:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
    9cb4:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
    9cb8:	d204      	bcs.n	9cc4 <__aeabi_dmul+0x80>
    9cba:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
    9cbe:	416d      	adcs	r5, r5
    9cc0:	eb46 0606 	adc.w	r6, r6, r6
    9cc4:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
    9cc8:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
    9ccc:	ea4f 20c5 	mov.w	r0, r5, lsl #11
    9cd0:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
    9cd4:	ea4f 2ece 	mov.w	lr, lr, lsl #11
    9cd8:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    9cdc:	bf88      	it	hi
    9cde:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    9ce2:	d81e      	bhi.n	9d22 <__aeabi_dmul+0xde>
    9ce4:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
    9ce8:	bf08      	it	eq
    9cea:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
    9cee:	f150 0000 	adcs.w	r0, r0, #0
    9cf2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    9cf6:	bd70      	pop	{r4, r5, r6, pc}
    9cf8:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
    9cfc:	ea46 0101 	orr.w	r1, r6, r1
    9d00:	ea40 0002 	orr.w	r0, r0, r2
    9d04:	ea81 0103 	eor.w	r1, r1, r3
    9d08:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
    9d0c:	bfc2      	ittt	gt
    9d0e:	ebd4 050c 	rsbsgt	r5, r4, ip
    9d12:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    9d16:	bd70      	popgt	{r4, r5, r6, pc}
    9d18:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    9d1c:	f04f 0e00 	mov.w	lr, #0
    9d20:	3c01      	subs	r4, #1
    9d22:	f300 80ab 	bgt.w	9e7c <__aeabi_dmul+0x238>
    9d26:	f114 0f36 	cmn.w	r4, #54	; 0x36
    9d2a:	bfde      	ittt	le
    9d2c:	2000      	movle	r0, #0
    9d2e:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
    9d32:	bd70      	pople	{r4, r5, r6, pc}
    9d34:	f1c4 0400 	rsb	r4, r4, #0
    9d38:	3c20      	subs	r4, #32
    9d3a:	da35      	bge.n	9da8 <__aeabi_dmul+0x164>
    9d3c:	340c      	adds	r4, #12
    9d3e:	dc1b      	bgt.n	9d78 <__aeabi_dmul+0x134>
    9d40:	f104 0414 	add.w	r4, r4, #20
    9d44:	f1c4 0520 	rsb	r5, r4, #32
    9d48:	fa00 f305 	lsl.w	r3, r0, r5
    9d4c:	fa20 f004 	lsr.w	r0, r0, r4
    9d50:	fa01 f205 	lsl.w	r2, r1, r5
    9d54:	ea40 0002 	orr.w	r0, r0, r2
    9d58:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
    9d5c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    9d60:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    9d64:	fa21 f604 	lsr.w	r6, r1, r4
    9d68:	eb42 0106 	adc.w	r1, r2, r6
    9d6c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    9d70:	bf08      	it	eq
    9d72:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    9d76:	bd70      	pop	{r4, r5, r6, pc}
    9d78:	f1c4 040c 	rsb	r4, r4, #12
    9d7c:	f1c4 0520 	rsb	r5, r4, #32
    9d80:	fa00 f304 	lsl.w	r3, r0, r4
    9d84:	fa20 f005 	lsr.w	r0, r0, r5
    9d88:	fa01 f204 	lsl.w	r2, r1, r4
    9d8c:	ea40 0002 	orr.w	r0, r0, r2
    9d90:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    9d94:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    9d98:	f141 0100 	adc.w	r1, r1, #0
    9d9c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    9da0:	bf08      	it	eq
    9da2:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    9da6:	bd70      	pop	{r4, r5, r6, pc}
    9da8:	f1c4 0520 	rsb	r5, r4, #32
    9dac:	fa00 f205 	lsl.w	r2, r0, r5
    9db0:	ea4e 0e02 	orr.w	lr, lr, r2
    9db4:	fa20 f304 	lsr.w	r3, r0, r4
    9db8:	fa01 f205 	lsl.w	r2, r1, r5
    9dbc:	ea43 0302 	orr.w	r3, r3, r2
    9dc0:	fa21 f004 	lsr.w	r0, r1, r4
    9dc4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    9dc8:	fa21 f204 	lsr.w	r2, r1, r4
    9dcc:	ea20 0002 	bic.w	r0, r0, r2
    9dd0:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
    9dd4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    9dd8:	bf08      	it	eq
    9dda:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    9dde:	bd70      	pop	{r4, r5, r6, pc}
    9de0:	f094 0f00 	teq	r4, #0
    9de4:	d10f      	bne.n	9e06 <__aeabi_dmul+0x1c2>
    9de6:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
    9dea:	0040      	lsls	r0, r0, #1
    9dec:	eb41 0101 	adc.w	r1, r1, r1
    9df0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    9df4:	bf08      	it	eq
    9df6:	3c01      	subeq	r4, #1
    9df8:	d0f7      	beq.n	9dea <__aeabi_dmul+0x1a6>
    9dfa:	ea41 0106 	orr.w	r1, r1, r6
    9dfe:	f095 0f00 	teq	r5, #0
    9e02:	bf18      	it	ne
    9e04:	4770      	bxne	lr
    9e06:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
    9e0a:	0052      	lsls	r2, r2, #1
    9e0c:	eb43 0303 	adc.w	r3, r3, r3
    9e10:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    9e14:	bf08      	it	eq
    9e16:	3d01      	subeq	r5, #1
    9e18:	d0f7      	beq.n	9e0a <__aeabi_dmul+0x1c6>
    9e1a:	ea43 0306 	orr.w	r3, r3, r6
    9e1e:	4770      	bx	lr
    9e20:	ea94 0f0c 	teq	r4, ip
    9e24:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    9e28:	bf18      	it	ne
    9e2a:	ea95 0f0c 	teqne	r5, ip
    9e2e:	d00c      	beq.n	9e4a <__aeabi_dmul+0x206>
    9e30:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    9e34:	bf18      	it	ne
    9e36:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    9e3a:	d1d1      	bne.n	9de0 <__aeabi_dmul+0x19c>
    9e3c:	ea81 0103 	eor.w	r1, r1, r3
    9e40:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    9e44:	f04f 0000 	mov.w	r0, #0
    9e48:	bd70      	pop	{r4, r5, r6, pc}
    9e4a:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    9e4e:	bf06      	itte	eq
    9e50:	4610      	moveq	r0, r2
    9e52:	4619      	moveq	r1, r3
    9e54:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    9e58:	d019      	beq.n	9e8e <__aeabi_dmul+0x24a>
    9e5a:	ea94 0f0c 	teq	r4, ip
    9e5e:	d102      	bne.n	9e66 <__aeabi_dmul+0x222>
    9e60:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
    9e64:	d113      	bne.n	9e8e <__aeabi_dmul+0x24a>
    9e66:	ea95 0f0c 	teq	r5, ip
    9e6a:	d105      	bne.n	9e78 <__aeabi_dmul+0x234>
    9e6c:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
    9e70:	bf1c      	itt	ne
    9e72:	4610      	movne	r0, r2
    9e74:	4619      	movne	r1, r3
    9e76:	d10a      	bne.n	9e8e <__aeabi_dmul+0x24a>
    9e78:	ea81 0103 	eor.w	r1, r1, r3
    9e7c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    9e80:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    9e84:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    9e88:	f04f 0000 	mov.w	r0, #0
    9e8c:	bd70      	pop	{r4, r5, r6, pc}
    9e8e:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    9e92:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
    9e96:	bd70      	pop	{r4, r5, r6, pc}

00009e98 <__aeabi_ddiv>:
    9e98:	b570      	push	{r4, r5, r6, lr}
    9e9a:	f04f 0cff 	mov.w	ip, #255	; 0xff
    9e9e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    9ea2:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    9ea6:	bf1d      	ittte	ne
    9ea8:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    9eac:	ea94 0f0c 	teqne	r4, ip
    9eb0:	ea95 0f0c 	teqne	r5, ip
    9eb4:	f000 f8a7 	bleq	a006 <__aeabi_ddiv+0x16e>
    9eb8:	eba4 0405 	sub.w	r4, r4, r5
    9ebc:	ea81 0e03 	eor.w	lr, r1, r3
    9ec0:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    9ec4:	ea4f 3101 	mov.w	r1, r1, lsl #12
    9ec8:	f000 8088 	beq.w	9fdc <__aeabi_ddiv+0x144>
    9ecc:	ea4f 3303 	mov.w	r3, r3, lsl #12
    9ed0:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
    9ed4:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
    9ed8:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    9edc:	ea4f 2202 	mov.w	r2, r2, lsl #8
    9ee0:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
    9ee4:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
    9ee8:	ea4f 2600 	mov.w	r6, r0, lsl #8
    9eec:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
    9ef0:	429d      	cmp	r5, r3
    9ef2:	bf08      	it	eq
    9ef4:	4296      	cmpeq	r6, r2
    9ef6:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
    9efa:	f504 7440 	add.w	r4, r4, #768	; 0x300
    9efe:	d202      	bcs.n	9f06 <__aeabi_ddiv+0x6e>
    9f00:	085b      	lsrs	r3, r3, #1
    9f02:	ea4f 0232 	mov.w	r2, r2, rrx
    9f06:	1ab6      	subs	r6, r6, r2
    9f08:	eb65 0503 	sbc.w	r5, r5, r3
    9f0c:	085b      	lsrs	r3, r3, #1
    9f0e:	ea4f 0232 	mov.w	r2, r2, rrx
    9f12:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
    9f16:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
    9f1a:	ebb6 0e02 	subs.w	lr, r6, r2
    9f1e:	eb75 0e03 	sbcs.w	lr, r5, r3
    9f22:	bf22      	ittt	cs
    9f24:	1ab6      	subcs	r6, r6, r2
    9f26:	4675      	movcs	r5, lr
    9f28:	ea40 000c 	orrcs.w	r0, r0, ip
    9f2c:	085b      	lsrs	r3, r3, #1
    9f2e:	ea4f 0232 	mov.w	r2, r2, rrx
    9f32:	ebb6 0e02 	subs.w	lr, r6, r2
    9f36:	eb75 0e03 	sbcs.w	lr, r5, r3
    9f3a:	bf22      	ittt	cs
    9f3c:	1ab6      	subcs	r6, r6, r2
    9f3e:	4675      	movcs	r5, lr
    9f40:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    9f44:	085b      	lsrs	r3, r3, #1
    9f46:	ea4f 0232 	mov.w	r2, r2, rrx
    9f4a:	ebb6 0e02 	subs.w	lr, r6, r2
    9f4e:	eb75 0e03 	sbcs.w	lr, r5, r3
    9f52:	bf22      	ittt	cs
    9f54:	1ab6      	subcs	r6, r6, r2
    9f56:	4675      	movcs	r5, lr
    9f58:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    9f5c:	085b      	lsrs	r3, r3, #1
    9f5e:	ea4f 0232 	mov.w	r2, r2, rrx
    9f62:	ebb6 0e02 	subs.w	lr, r6, r2
    9f66:	eb75 0e03 	sbcs.w	lr, r5, r3
    9f6a:	bf22      	ittt	cs
    9f6c:	1ab6      	subcs	r6, r6, r2
    9f6e:	4675      	movcs	r5, lr
    9f70:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    9f74:	ea55 0e06 	orrs.w	lr, r5, r6
    9f78:	d018      	beq.n	9fac <__aeabi_ddiv+0x114>
    9f7a:	ea4f 1505 	mov.w	r5, r5, lsl #4
    9f7e:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
    9f82:	ea4f 1606 	mov.w	r6, r6, lsl #4
    9f86:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    9f8a:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
    9f8e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    9f92:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
    9f96:	d1c0      	bne.n	9f1a <__aeabi_ddiv+0x82>
    9f98:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    9f9c:	d10b      	bne.n	9fb6 <__aeabi_ddiv+0x11e>
    9f9e:	ea41 0100 	orr.w	r1, r1, r0
    9fa2:	f04f 0000 	mov.w	r0, #0
    9fa6:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
    9faa:	e7b6      	b.n	9f1a <__aeabi_ddiv+0x82>
    9fac:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    9fb0:	bf04      	itt	eq
    9fb2:	4301      	orreq	r1, r0
    9fb4:	2000      	moveq	r0, #0
    9fb6:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    9fba:	bf88      	it	hi
    9fbc:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    9fc0:	f63f aeaf 	bhi.w	9d22 <__aeabi_dmul+0xde>
    9fc4:	ebb5 0c03 	subs.w	ip, r5, r3
    9fc8:	bf04      	itt	eq
    9fca:	ebb6 0c02 	subseq.w	ip, r6, r2
    9fce:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    9fd2:	f150 0000 	adcs.w	r0, r0, #0
    9fd6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    9fda:	bd70      	pop	{r4, r5, r6, pc}
    9fdc:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
    9fe0:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
    9fe4:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
    9fe8:	bfc2      	ittt	gt
    9fea:	ebd4 050c 	rsbsgt	r5, r4, ip
    9fee:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    9ff2:	bd70      	popgt	{r4, r5, r6, pc}
    9ff4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    9ff8:	f04f 0e00 	mov.w	lr, #0
    9ffc:	3c01      	subs	r4, #1
    9ffe:	e690      	b.n	9d22 <__aeabi_dmul+0xde>
    a000:	ea45 0e06 	orr.w	lr, r5, r6
    a004:	e68d      	b.n	9d22 <__aeabi_dmul+0xde>
    a006:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    a00a:	ea94 0f0c 	teq	r4, ip
    a00e:	bf08      	it	eq
    a010:	ea95 0f0c 	teqeq	r5, ip
    a014:	f43f af3b 	beq.w	9e8e <__aeabi_dmul+0x24a>
    a018:	ea94 0f0c 	teq	r4, ip
    a01c:	d10a      	bne.n	a034 <__aeabi_ddiv+0x19c>
    a01e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    a022:	f47f af34 	bne.w	9e8e <__aeabi_dmul+0x24a>
    a026:	ea95 0f0c 	teq	r5, ip
    a02a:	f47f af25 	bne.w	9e78 <__aeabi_dmul+0x234>
    a02e:	4610      	mov	r0, r2
    a030:	4619      	mov	r1, r3
    a032:	e72c      	b.n	9e8e <__aeabi_dmul+0x24a>
    a034:	ea95 0f0c 	teq	r5, ip
    a038:	d106      	bne.n	a048 <__aeabi_ddiv+0x1b0>
    a03a:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    a03e:	f43f aefd 	beq.w	9e3c <__aeabi_dmul+0x1f8>
    a042:	4610      	mov	r0, r2
    a044:	4619      	mov	r1, r3
    a046:	e722      	b.n	9e8e <__aeabi_dmul+0x24a>
    a048:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    a04c:	bf18      	it	ne
    a04e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    a052:	f47f aec5 	bne.w	9de0 <__aeabi_dmul+0x19c>
    a056:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
    a05a:	f47f af0d 	bne.w	9e78 <__aeabi_dmul+0x234>
    a05e:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
    a062:	f47f aeeb 	bne.w	9e3c <__aeabi_dmul+0x1f8>
    a066:	e712      	b.n	9e8e <__aeabi_dmul+0x24a>

0000a068 <__gedf2>:
    a068:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
    a06c:	e006      	b.n	a07c <__cmpdf2+0x4>
    a06e:	bf00      	nop

0000a070 <__ledf2>:
    a070:	f04f 0c01 	mov.w	ip, #1
    a074:	e002      	b.n	a07c <__cmpdf2+0x4>
    a076:	bf00      	nop

0000a078 <__cmpdf2>:
    a078:	f04f 0c01 	mov.w	ip, #1
    a07c:	f84d cd04 	str.w	ip, [sp, #-4]!
    a080:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    a084:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    a088:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    a08c:	bf18      	it	ne
    a08e:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
    a092:	d01b      	beq.n	a0cc <__cmpdf2+0x54>
    a094:	b001      	add	sp, #4
    a096:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
    a09a:	bf0c      	ite	eq
    a09c:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
    a0a0:	ea91 0f03 	teqne	r1, r3
    a0a4:	bf02      	ittt	eq
    a0a6:	ea90 0f02 	teqeq	r0, r2
    a0aa:	2000      	moveq	r0, #0
    a0ac:	4770      	bxeq	lr
    a0ae:	f110 0f00 	cmn.w	r0, #0
    a0b2:	ea91 0f03 	teq	r1, r3
    a0b6:	bf58      	it	pl
    a0b8:	4299      	cmppl	r1, r3
    a0ba:	bf08      	it	eq
    a0bc:	4290      	cmpeq	r0, r2
    a0be:	bf2c      	ite	cs
    a0c0:	17d8      	asrcs	r0, r3, #31
    a0c2:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
    a0c6:	f040 0001 	orr.w	r0, r0, #1
    a0ca:	4770      	bx	lr
    a0cc:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    a0d0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    a0d4:	d102      	bne.n	a0dc <__cmpdf2+0x64>
    a0d6:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    a0da:	d107      	bne.n	a0ec <__cmpdf2+0x74>
    a0dc:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    a0e0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    a0e4:	d1d6      	bne.n	a094 <__cmpdf2+0x1c>
    a0e6:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    a0ea:	d0d3      	beq.n	a094 <__cmpdf2+0x1c>
    a0ec:	f85d 0b04 	ldr.w	r0, [sp], #4
    a0f0:	4770      	bx	lr
    a0f2:	bf00      	nop

0000a0f4 <__aeabi_cdrcmple>:
    a0f4:	4684      	mov	ip, r0
    a0f6:	4610      	mov	r0, r2
    a0f8:	4662      	mov	r2, ip
    a0fa:	468c      	mov	ip, r1
    a0fc:	4619      	mov	r1, r3
    a0fe:	4663      	mov	r3, ip
    a100:	e000      	b.n	a104 <__aeabi_cdcmpeq>
    a102:	bf00      	nop

0000a104 <__aeabi_cdcmpeq>:
    a104:	b501      	push	{r0, lr}
    a106:	f7ff ffb7 	bl	a078 <__cmpdf2>
    a10a:	2800      	cmp	r0, #0
    a10c:	bf48      	it	mi
    a10e:	f110 0f00 	cmnmi.w	r0, #0
    a112:	bd01      	pop	{r0, pc}

0000a114 <__aeabi_dcmpeq>:
    a114:	f84d ed08 	str.w	lr, [sp, #-8]!
    a118:	f7ff fff4 	bl	a104 <__aeabi_cdcmpeq>
    a11c:	bf0c      	ite	eq
    a11e:	2001      	moveq	r0, #1
    a120:	2000      	movne	r0, #0
    a122:	f85d fb08 	ldr.w	pc, [sp], #8
    a126:	bf00      	nop

0000a128 <__aeabi_dcmplt>:
    a128:	f84d ed08 	str.w	lr, [sp, #-8]!
    a12c:	f7ff ffea 	bl	a104 <__aeabi_cdcmpeq>
    a130:	bf34      	ite	cc
    a132:	2001      	movcc	r0, #1
    a134:	2000      	movcs	r0, #0
    a136:	f85d fb08 	ldr.w	pc, [sp], #8
    a13a:	bf00      	nop

0000a13c <__aeabi_dcmple>:
    a13c:	f84d ed08 	str.w	lr, [sp, #-8]!
    a140:	f7ff ffe0 	bl	a104 <__aeabi_cdcmpeq>
    a144:	bf94      	ite	ls
    a146:	2001      	movls	r0, #1
    a148:	2000      	movhi	r0, #0
    a14a:	f85d fb08 	ldr.w	pc, [sp], #8
    a14e:	bf00      	nop

0000a150 <__aeabi_dcmpge>:
    a150:	f84d ed08 	str.w	lr, [sp, #-8]!
    a154:	f7ff ffce 	bl	a0f4 <__aeabi_cdrcmple>
    a158:	bf94      	ite	ls
    a15a:	2001      	movls	r0, #1
    a15c:	2000      	movhi	r0, #0
    a15e:	f85d fb08 	ldr.w	pc, [sp], #8
    a162:	bf00      	nop

0000a164 <__aeabi_dcmpgt>:
    a164:	f84d ed08 	str.w	lr, [sp, #-8]!
    a168:	f7ff ffc4 	bl	a0f4 <__aeabi_cdrcmple>
    a16c:	bf34      	ite	cc
    a16e:	2001      	movcc	r0, #1
    a170:	2000      	movcs	r0, #0
    a172:	f85d fb08 	ldr.w	pc, [sp], #8
    a176:	bf00      	nop

0000a178 <__aeabi_dcmpun>:
    a178:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    a17c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    a180:	d102      	bne.n	a188 <__aeabi_dcmpun+0x10>
    a182:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    a186:	d10a      	bne.n	a19e <__aeabi_dcmpun+0x26>
    a188:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    a18c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    a190:	d102      	bne.n	a198 <__aeabi_dcmpun+0x20>
    a192:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    a196:	d102      	bne.n	a19e <__aeabi_dcmpun+0x26>
    a198:	f04f 0000 	mov.w	r0, #0
    a19c:	4770      	bx	lr
    a19e:	f04f 0001 	mov.w	r0, #1
    a1a2:	4770      	bx	lr

0000a1a4 <__aeabi_d2iz>:
    a1a4:	ea4f 0241 	mov.w	r2, r1, lsl #1
    a1a8:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
    a1ac:	d215      	bcs.n	a1da <__aeabi_d2iz+0x36>
    a1ae:	d511      	bpl.n	a1d4 <__aeabi_d2iz+0x30>
    a1b0:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
    a1b4:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
    a1b8:	d912      	bls.n	a1e0 <__aeabi_d2iz+0x3c>
    a1ba:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    a1be:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    a1c2:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
    a1c6:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    a1ca:	fa23 f002 	lsr.w	r0, r3, r2
    a1ce:	bf18      	it	ne
    a1d0:	4240      	negne	r0, r0
    a1d2:	4770      	bx	lr
    a1d4:	f04f 0000 	mov.w	r0, #0
    a1d8:	4770      	bx	lr
    a1da:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
    a1de:	d105      	bne.n	a1ec <__aeabi_d2iz+0x48>
    a1e0:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
    a1e4:	bf08      	it	eq
    a1e6:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
    a1ea:	4770      	bx	lr
    a1ec:	f04f 0000 	mov.w	r0, #0
    a1f0:	4770      	bx	lr
    a1f2:	bf00      	nop

0000a1f4 <__aeabi_d2f>:
    a1f4:	ea4f 0241 	mov.w	r2, r1, lsl #1
    a1f8:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
    a1fc:	bf24      	itt	cs
    a1fe:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
    a202:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
    a206:	d90d      	bls.n	a224 <__aeabi_d2f+0x30>
    a208:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    a20c:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    a210:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
    a214:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    a218:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
    a21c:	bf08      	it	eq
    a21e:	f020 0001 	biceq.w	r0, r0, #1
    a222:	4770      	bx	lr
    a224:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
    a228:	d121      	bne.n	a26e <__aeabi_d2f+0x7a>
    a22a:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
    a22e:	bfbc      	itt	lt
    a230:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
    a234:	4770      	bxlt	lr
    a236:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    a23a:	ea4f 5252 	mov.w	r2, r2, lsr #21
    a23e:	f1c2 0218 	rsb	r2, r2, #24
    a242:	f1c2 0c20 	rsb	ip, r2, #32
    a246:	fa10 f30c 	lsls.w	r3, r0, ip
    a24a:	fa20 f002 	lsr.w	r0, r0, r2
    a24e:	bf18      	it	ne
    a250:	f040 0001 	orrne.w	r0, r0, #1
    a254:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    a258:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    a25c:	fa03 fc0c 	lsl.w	ip, r3, ip
    a260:	ea40 000c 	orr.w	r0, r0, ip
    a264:	fa23 f302 	lsr.w	r3, r3, r2
    a268:	ea4f 0343 	mov.w	r3, r3, lsl #1
    a26c:	e7cc      	b.n	a208 <__aeabi_d2f+0x14>
    a26e:	ea7f 5362 	mvns.w	r3, r2, asr #21
    a272:	d107      	bne.n	a284 <__aeabi_d2f+0x90>
    a274:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
    a278:	bf1e      	ittt	ne
    a27a:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
    a27e:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
    a282:	4770      	bxne	lr
    a284:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
    a288:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    a28c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    a290:	4770      	bx	lr
    a292:	bf00      	nop

0000a294 <__aeabi_frsub>:
    a294:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
    a298:	e002      	b.n	a2a0 <__addsf3>
    a29a:	bf00      	nop

0000a29c <__aeabi_fsub>:
    a29c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

0000a2a0 <__addsf3>:
    a2a0:	0042      	lsls	r2, r0, #1
    a2a2:	bf1f      	itttt	ne
    a2a4:	ea5f 0341 	movsne.w	r3, r1, lsl #1
    a2a8:	ea92 0f03 	teqne	r2, r3
    a2ac:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
    a2b0:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
    a2b4:	d06a      	beq.n	a38c <__addsf3+0xec>
    a2b6:	ea4f 6212 	mov.w	r2, r2, lsr #24
    a2ba:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
    a2be:	bfc1      	itttt	gt
    a2c0:	18d2      	addgt	r2, r2, r3
    a2c2:	4041      	eorgt	r1, r0
    a2c4:	4048      	eorgt	r0, r1
    a2c6:	4041      	eorgt	r1, r0
    a2c8:	bfb8      	it	lt
    a2ca:	425b      	neglt	r3, r3
    a2cc:	2b19      	cmp	r3, #25
    a2ce:	bf88      	it	hi
    a2d0:	4770      	bxhi	lr
    a2d2:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
    a2d6:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    a2da:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    a2de:	bf18      	it	ne
    a2e0:	4240      	negne	r0, r0
    a2e2:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    a2e6:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
    a2ea:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
    a2ee:	bf18      	it	ne
    a2f0:	4249      	negne	r1, r1
    a2f2:	ea92 0f03 	teq	r2, r3
    a2f6:	d03f      	beq.n	a378 <__addsf3+0xd8>
    a2f8:	f1a2 0201 	sub.w	r2, r2, #1
    a2fc:	fa41 fc03 	asr.w	ip, r1, r3
    a300:	eb10 000c 	adds.w	r0, r0, ip
    a304:	f1c3 0320 	rsb	r3, r3, #32
    a308:	fa01 f103 	lsl.w	r1, r1, r3
    a30c:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
    a310:	d502      	bpl.n	a318 <__addsf3+0x78>
    a312:	4249      	negs	r1, r1
    a314:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
    a318:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    a31c:	d313      	bcc.n	a346 <__addsf3+0xa6>
    a31e:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
    a322:	d306      	bcc.n	a332 <__addsf3+0x92>
    a324:	0840      	lsrs	r0, r0, #1
    a326:	ea4f 0131 	mov.w	r1, r1, rrx
    a32a:	f102 0201 	add.w	r2, r2, #1
    a32e:	2afe      	cmp	r2, #254	; 0xfe
    a330:	d251      	bcs.n	a3d6 <__addsf3+0x136>
    a332:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
    a336:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
    a33a:	bf08      	it	eq
    a33c:	f020 0001 	biceq.w	r0, r0, #1
    a340:	ea40 0003 	orr.w	r0, r0, r3
    a344:	4770      	bx	lr
    a346:	0049      	lsls	r1, r1, #1
    a348:	eb40 0000 	adc.w	r0, r0, r0
    a34c:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
    a350:	f1a2 0201 	sub.w	r2, r2, #1
    a354:	d1ed      	bne.n	a332 <__addsf3+0x92>
    a356:	fab0 fc80 	clz	ip, r0
    a35a:	f1ac 0c08 	sub.w	ip, ip, #8
    a35e:	ebb2 020c 	subs.w	r2, r2, ip
    a362:	fa00 f00c 	lsl.w	r0, r0, ip
    a366:	bfaa      	itet	ge
    a368:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
    a36c:	4252      	neglt	r2, r2
    a36e:	4318      	orrge	r0, r3
    a370:	bfbc      	itt	lt
    a372:	40d0      	lsrlt	r0, r2
    a374:	4318      	orrlt	r0, r3
    a376:	4770      	bx	lr
    a378:	f092 0f00 	teq	r2, #0
    a37c:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
    a380:	bf06      	itte	eq
    a382:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
    a386:	3201      	addeq	r2, #1
    a388:	3b01      	subne	r3, #1
    a38a:	e7b5      	b.n	a2f8 <__addsf3+0x58>
    a38c:	ea4f 0341 	mov.w	r3, r1, lsl #1
    a390:	ea7f 6c22 	mvns.w	ip, r2, asr #24
    a394:	bf18      	it	ne
    a396:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
    a39a:	d021      	beq.n	a3e0 <__addsf3+0x140>
    a39c:	ea92 0f03 	teq	r2, r3
    a3a0:	d004      	beq.n	a3ac <__addsf3+0x10c>
    a3a2:	f092 0f00 	teq	r2, #0
    a3a6:	bf08      	it	eq
    a3a8:	4608      	moveq	r0, r1
    a3aa:	4770      	bx	lr
    a3ac:	ea90 0f01 	teq	r0, r1
    a3b0:	bf1c      	itt	ne
    a3b2:	2000      	movne	r0, #0
    a3b4:	4770      	bxne	lr
    a3b6:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
    a3ba:	d104      	bne.n	a3c6 <__addsf3+0x126>
    a3bc:	0040      	lsls	r0, r0, #1
    a3be:	bf28      	it	cs
    a3c0:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
    a3c4:	4770      	bx	lr
    a3c6:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
    a3ca:	bf3c      	itt	cc
    a3cc:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
    a3d0:	4770      	bxcc	lr
    a3d2:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
    a3d6:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
    a3da:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    a3de:	4770      	bx	lr
    a3e0:	ea7f 6222 	mvns.w	r2, r2, asr #24
    a3e4:	bf16      	itet	ne
    a3e6:	4608      	movne	r0, r1
    a3e8:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
    a3ec:	4601      	movne	r1, r0
    a3ee:	0242      	lsls	r2, r0, #9
    a3f0:	bf06      	itte	eq
    a3f2:	ea5f 2341 	movseq.w	r3, r1, lsl #9
    a3f6:	ea90 0f01 	teqeq	r0, r1
    a3fa:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
    a3fe:	4770      	bx	lr

0000a400 <__aeabi_ui2f>:
    a400:	f04f 0300 	mov.w	r3, #0
    a404:	e004      	b.n	a410 <__aeabi_i2f+0x8>
    a406:	bf00      	nop

0000a408 <__aeabi_i2f>:
    a408:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
    a40c:	bf48      	it	mi
    a40e:	4240      	negmi	r0, r0
    a410:	ea5f 0c00 	movs.w	ip, r0
    a414:	bf08      	it	eq
    a416:	4770      	bxeq	lr
    a418:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
    a41c:	4601      	mov	r1, r0
    a41e:	f04f 0000 	mov.w	r0, #0
    a422:	e01c      	b.n	a45e <__aeabi_l2f+0x2a>

0000a424 <__aeabi_ul2f>:
    a424:	ea50 0201 	orrs.w	r2, r0, r1
    a428:	bf08      	it	eq
    a42a:	4770      	bxeq	lr
    a42c:	f04f 0300 	mov.w	r3, #0
    a430:	e00a      	b.n	a448 <__aeabi_l2f+0x14>
    a432:	bf00      	nop

0000a434 <__aeabi_l2f>:
    a434:	ea50 0201 	orrs.w	r2, r0, r1
    a438:	bf08      	it	eq
    a43a:	4770      	bxeq	lr
    a43c:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
    a440:	d502      	bpl.n	a448 <__aeabi_l2f+0x14>
    a442:	4240      	negs	r0, r0
    a444:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    a448:	ea5f 0c01 	movs.w	ip, r1
    a44c:	bf02      	ittt	eq
    a44e:	4684      	moveq	ip, r0
    a450:	4601      	moveq	r1, r0
    a452:	2000      	moveq	r0, #0
    a454:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
    a458:	bf08      	it	eq
    a45a:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
    a45e:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
    a462:	fabc f28c 	clz	r2, ip
    a466:	3a08      	subs	r2, #8
    a468:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
    a46c:	db10      	blt.n	a490 <__aeabi_l2f+0x5c>
    a46e:	fa01 fc02 	lsl.w	ip, r1, r2
    a472:	4463      	add	r3, ip
    a474:	fa00 fc02 	lsl.w	ip, r0, r2
    a478:	f1c2 0220 	rsb	r2, r2, #32
    a47c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    a480:	fa20 f202 	lsr.w	r2, r0, r2
    a484:	eb43 0002 	adc.w	r0, r3, r2
    a488:	bf08      	it	eq
    a48a:	f020 0001 	biceq.w	r0, r0, #1
    a48e:	4770      	bx	lr
    a490:	f102 0220 	add.w	r2, r2, #32
    a494:	fa01 fc02 	lsl.w	ip, r1, r2
    a498:	f1c2 0220 	rsb	r2, r2, #32
    a49c:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
    a4a0:	fa21 f202 	lsr.w	r2, r1, r2
    a4a4:	eb43 0002 	adc.w	r0, r3, r2
    a4a8:	bf08      	it	eq
    a4aa:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
    a4ae:	4770      	bx	lr

0000a4b0 <__aeabi_ldivmod>:
    a4b0:	b97b      	cbnz	r3, a4d2 <__aeabi_ldivmod+0x22>
    a4b2:	b972      	cbnz	r2, a4d2 <__aeabi_ldivmod+0x22>
    a4b4:	2900      	cmp	r1, #0
    a4b6:	bfbe      	ittt	lt
    a4b8:	2000      	movlt	r0, #0
    a4ba:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
    a4be:	e006      	blt.n	a4ce <__aeabi_ldivmod+0x1e>
    a4c0:	bf08      	it	eq
    a4c2:	2800      	cmpeq	r0, #0
    a4c4:	bf1c      	itt	ne
    a4c6:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
    a4ca:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    a4ce:	f000 b9b1 	b.w	a834 <__aeabi_idiv0>
    a4d2:	f1ad 0c08 	sub.w	ip, sp, #8
    a4d6:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    a4da:	2900      	cmp	r1, #0
    a4dc:	db09      	blt.n	a4f2 <__aeabi_ldivmod+0x42>
    a4de:	2b00      	cmp	r3, #0
    a4e0:	db1a      	blt.n	a518 <__aeabi_ldivmod+0x68>
    a4e2:	f000 f835 	bl	a550 <__udivmoddi4>
    a4e6:	f8dd e004 	ldr.w	lr, [sp, #4]
    a4ea:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    a4ee:	b004      	add	sp, #16
    a4f0:	4770      	bx	lr
    a4f2:	4240      	negs	r0, r0
    a4f4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    a4f8:	2b00      	cmp	r3, #0
    a4fa:	db1b      	blt.n	a534 <__aeabi_ldivmod+0x84>
    a4fc:	f000 f828 	bl	a550 <__udivmoddi4>
    a500:	f8dd e004 	ldr.w	lr, [sp, #4]
    a504:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    a508:	b004      	add	sp, #16
    a50a:	4240      	negs	r0, r0
    a50c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    a510:	4252      	negs	r2, r2
    a512:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    a516:	4770      	bx	lr
    a518:	4252      	negs	r2, r2
    a51a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    a51e:	f000 f817 	bl	a550 <__udivmoddi4>
    a522:	f8dd e004 	ldr.w	lr, [sp, #4]
    a526:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    a52a:	b004      	add	sp, #16
    a52c:	4240      	negs	r0, r0
    a52e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    a532:	4770      	bx	lr
    a534:	4252      	negs	r2, r2
    a536:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    a53a:	f000 f809 	bl	a550 <__udivmoddi4>
    a53e:	f8dd e004 	ldr.w	lr, [sp, #4]
    a542:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    a546:	b004      	add	sp, #16
    a548:	4252      	negs	r2, r2
    a54a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    a54e:	4770      	bx	lr

0000a550 <__udivmoddi4>:
    a550:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    a554:	468c      	mov	ip, r1
    a556:	460e      	mov	r6, r1
    a558:	4604      	mov	r4, r0
    a55a:	9d08      	ldr	r5, [sp, #32]
    a55c:	2b00      	cmp	r3, #0
    a55e:	d150      	bne.n	a602 <__udivmoddi4+0xb2>
    a560:	428a      	cmp	r2, r1
    a562:	4617      	mov	r7, r2
    a564:	d96c      	bls.n	a640 <__udivmoddi4+0xf0>
    a566:	fab2 fe82 	clz	lr, r2
    a56a:	f1be 0f00 	cmp.w	lr, #0
    a56e:	d00b      	beq.n	a588 <__udivmoddi4+0x38>
    a570:	f1ce 0420 	rsb	r4, lr, #32
    a574:	fa20 f404 	lsr.w	r4, r0, r4
    a578:	fa01 f60e 	lsl.w	r6, r1, lr
    a57c:	ea44 0c06 	orr.w	ip, r4, r6
    a580:	fa02 f70e 	lsl.w	r7, r2, lr
    a584:	fa00 f40e 	lsl.w	r4, r0, lr
    a588:	ea4f 4917 	mov.w	r9, r7, lsr #16
    a58c:	0c22      	lsrs	r2, r4, #16
    a58e:	fbbc f0f9 	udiv	r0, ip, r9
    a592:	fa1f f887 	uxth.w	r8, r7
    a596:	fb09 c610 	mls	r6, r9, r0, ip
    a59a:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
    a59e:	fb00 f308 	mul.w	r3, r0, r8
    a5a2:	42b3      	cmp	r3, r6
    a5a4:	d909      	bls.n	a5ba <__udivmoddi4+0x6a>
    a5a6:	19f6      	adds	r6, r6, r7
    a5a8:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
    a5ac:	f080 8122 	bcs.w	a7f4 <__udivmoddi4+0x2a4>
    a5b0:	42b3      	cmp	r3, r6
    a5b2:	f240 811f 	bls.w	a7f4 <__udivmoddi4+0x2a4>
    a5b6:	3802      	subs	r0, #2
    a5b8:	443e      	add	r6, r7
    a5ba:	1af6      	subs	r6, r6, r3
    a5bc:	b2a2      	uxth	r2, r4
    a5be:	fbb6 f3f9 	udiv	r3, r6, r9
    a5c2:	fb09 6613 	mls	r6, r9, r3, r6
    a5c6:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
    a5ca:	fb03 f808 	mul.w	r8, r3, r8
    a5ce:	45a0      	cmp	r8, r4
    a5d0:	d909      	bls.n	a5e6 <__udivmoddi4+0x96>
    a5d2:	19e4      	adds	r4, r4, r7
    a5d4:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
    a5d8:	f080 810a 	bcs.w	a7f0 <__udivmoddi4+0x2a0>
    a5dc:	45a0      	cmp	r8, r4
    a5de:	f240 8107 	bls.w	a7f0 <__udivmoddi4+0x2a0>
    a5e2:	3b02      	subs	r3, #2
    a5e4:	443c      	add	r4, r7
    a5e6:	ebc8 0404 	rsb	r4, r8, r4
    a5ea:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    a5ee:	2100      	movs	r1, #0
    a5f0:	2d00      	cmp	r5, #0
    a5f2:	d062      	beq.n	a6ba <__udivmoddi4+0x16a>
    a5f4:	fa24 f40e 	lsr.w	r4, r4, lr
    a5f8:	2300      	movs	r3, #0
    a5fa:	602c      	str	r4, [r5, #0]
    a5fc:	606b      	str	r3, [r5, #4]
    a5fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a602:	428b      	cmp	r3, r1
    a604:	d907      	bls.n	a616 <__udivmoddi4+0xc6>
    a606:	2d00      	cmp	r5, #0
    a608:	d055      	beq.n	a6b6 <__udivmoddi4+0x166>
    a60a:	2100      	movs	r1, #0
    a60c:	e885 0041 	stmia.w	r5, {r0, r6}
    a610:	4608      	mov	r0, r1
    a612:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a616:	fab3 f183 	clz	r1, r3
    a61a:	2900      	cmp	r1, #0
    a61c:	f040 8090 	bne.w	a740 <__udivmoddi4+0x1f0>
    a620:	42b3      	cmp	r3, r6
    a622:	d302      	bcc.n	a62a <__udivmoddi4+0xda>
    a624:	4282      	cmp	r2, r0
    a626:	f200 80f8 	bhi.w	a81a <__udivmoddi4+0x2ca>
    a62a:	1a84      	subs	r4, r0, r2
    a62c:	eb66 0603 	sbc.w	r6, r6, r3
    a630:	2001      	movs	r0, #1
    a632:	46b4      	mov	ip, r6
    a634:	2d00      	cmp	r5, #0
    a636:	d040      	beq.n	a6ba <__udivmoddi4+0x16a>
    a638:	e885 1010 	stmia.w	r5, {r4, ip}
    a63c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a640:	b912      	cbnz	r2, a648 <__udivmoddi4+0xf8>
    a642:	2701      	movs	r7, #1
    a644:	fbb7 f7f2 	udiv	r7, r7, r2
    a648:	fab7 fe87 	clz	lr, r7
    a64c:	f1be 0f00 	cmp.w	lr, #0
    a650:	d135      	bne.n	a6be <__udivmoddi4+0x16e>
    a652:	1bf3      	subs	r3, r6, r7
    a654:	ea4f 4817 	mov.w	r8, r7, lsr #16
    a658:	fa1f fc87 	uxth.w	ip, r7
    a65c:	2101      	movs	r1, #1
    a65e:	fbb3 f0f8 	udiv	r0, r3, r8
    a662:	0c22      	lsrs	r2, r4, #16
    a664:	fb08 3610 	mls	r6, r8, r0, r3
    a668:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
    a66c:	fb0c f300 	mul.w	r3, ip, r0
    a670:	42b3      	cmp	r3, r6
    a672:	d907      	bls.n	a684 <__udivmoddi4+0x134>
    a674:	19f6      	adds	r6, r6, r7
    a676:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
    a67a:	d202      	bcs.n	a682 <__udivmoddi4+0x132>
    a67c:	42b3      	cmp	r3, r6
    a67e:	f200 80ce 	bhi.w	a81e <__udivmoddi4+0x2ce>
    a682:	4610      	mov	r0, r2
    a684:	1af6      	subs	r6, r6, r3
    a686:	b2a2      	uxth	r2, r4
    a688:	fbb6 f3f8 	udiv	r3, r6, r8
    a68c:	fb08 6613 	mls	r6, r8, r3, r6
    a690:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
    a694:	fb0c fc03 	mul.w	ip, ip, r3
    a698:	45a4      	cmp	ip, r4
    a69a:	d907      	bls.n	a6ac <__udivmoddi4+0x15c>
    a69c:	19e4      	adds	r4, r4, r7
    a69e:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
    a6a2:	d202      	bcs.n	a6aa <__udivmoddi4+0x15a>
    a6a4:	45a4      	cmp	ip, r4
    a6a6:	f200 80b5 	bhi.w	a814 <__udivmoddi4+0x2c4>
    a6aa:	4613      	mov	r3, r2
    a6ac:	ebcc 0404 	rsb	r4, ip, r4
    a6b0:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    a6b4:	e79c      	b.n	a5f0 <__udivmoddi4+0xa0>
    a6b6:	4629      	mov	r1, r5
    a6b8:	4628      	mov	r0, r5
    a6ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a6be:	f1ce 0120 	rsb	r1, lr, #32
    a6c2:	fa06 f30e 	lsl.w	r3, r6, lr
    a6c6:	fa07 f70e 	lsl.w	r7, r7, lr
    a6ca:	fa20 f901 	lsr.w	r9, r0, r1
    a6ce:	ea4f 4817 	mov.w	r8, r7, lsr #16
    a6d2:	40ce      	lsrs	r6, r1
    a6d4:	ea49 0903 	orr.w	r9, r9, r3
    a6d8:	fbb6 faf8 	udiv	sl, r6, r8
    a6dc:	ea4f 4419 	mov.w	r4, r9, lsr #16
    a6e0:	fb08 661a 	mls	r6, r8, sl, r6
    a6e4:	fa1f fc87 	uxth.w	ip, r7
    a6e8:	ea44 4306 	orr.w	r3, r4, r6, lsl #16
    a6ec:	fb0a f20c 	mul.w	r2, sl, ip
    a6f0:	429a      	cmp	r2, r3
    a6f2:	fa00 f40e 	lsl.w	r4, r0, lr
    a6f6:	d90a      	bls.n	a70e <__udivmoddi4+0x1be>
    a6f8:	19db      	adds	r3, r3, r7
    a6fa:	f10a 31ff 	add.w	r1, sl, #4294967295	; 0xffffffff
    a6fe:	f080 8087 	bcs.w	a810 <__udivmoddi4+0x2c0>
    a702:	429a      	cmp	r2, r3
    a704:	f240 8084 	bls.w	a810 <__udivmoddi4+0x2c0>
    a708:	f1aa 0a02 	sub.w	sl, sl, #2
    a70c:	443b      	add	r3, r7
    a70e:	1a9b      	subs	r3, r3, r2
    a710:	fa1f f989 	uxth.w	r9, r9
    a714:	fbb3 f1f8 	udiv	r1, r3, r8
    a718:	fb08 3311 	mls	r3, r8, r1, r3
    a71c:	ea49 4303 	orr.w	r3, r9, r3, lsl #16
    a720:	fb01 f60c 	mul.w	r6, r1, ip
    a724:	429e      	cmp	r6, r3
    a726:	d907      	bls.n	a738 <__udivmoddi4+0x1e8>
    a728:	19db      	adds	r3, r3, r7
    a72a:	f101 32ff 	add.w	r2, r1, #4294967295	; 0xffffffff
    a72e:	d26b      	bcs.n	a808 <__udivmoddi4+0x2b8>
    a730:	429e      	cmp	r6, r3
    a732:	d969      	bls.n	a808 <__udivmoddi4+0x2b8>
    a734:	3902      	subs	r1, #2
    a736:	443b      	add	r3, r7
    a738:	1b9b      	subs	r3, r3, r6
    a73a:	ea41 410a 	orr.w	r1, r1, sl, lsl #16
    a73e:	e78e      	b.n	a65e <__udivmoddi4+0x10e>
    a740:	f1c1 0e20 	rsb	lr, r1, #32
    a744:	fa22 f40e 	lsr.w	r4, r2, lr
    a748:	408b      	lsls	r3, r1
    a74a:	4323      	orrs	r3, r4
    a74c:	fa20 f70e 	lsr.w	r7, r0, lr
    a750:	fa06 f401 	lsl.w	r4, r6, r1
    a754:	ea4f 4c13 	mov.w	ip, r3, lsr #16
    a758:	fa26 f60e 	lsr.w	r6, r6, lr
    a75c:	433c      	orrs	r4, r7
    a75e:	fbb6 f9fc 	udiv	r9, r6, ip
    a762:	0c27      	lsrs	r7, r4, #16
    a764:	fb0c 6619 	mls	r6, ip, r9, r6
    a768:	fa1f f883 	uxth.w	r8, r3
    a76c:	ea47 4606 	orr.w	r6, r7, r6, lsl #16
    a770:	fb09 f708 	mul.w	r7, r9, r8
    a774:	42b7      	cmp	r7, r6
    a776:	fa02 f201 	lsl.w	r2, r2, r1
    a77a:	fa00 fa01 	lsl.w	sl, r0, r1
    a77e:	d908      	bls.n	a792 <__udivmoddi4+0x242>
    a780:	18f6      	adds	r6, r6, r3
    a782:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
    a786:	d241      	bcs.n	a80c <__udivmoddi4+0x2bc>
    a788:	42b7      	cmp	r7, r6
    a78a:	d93f      	bls.n	a80c <__udivmoddi4+0x2bc>
    a78c:	f1a9 0902 	sub.w	r9, r9, #2
    a790:	441e      	add	r6, r3
    a792:	1bf6      	subs	r6, r6, r7
    a794:	b2a0      	uxth	r0, r4
    a796:	fbb6 f4fc 	udiv	r4, r6, ip
    a79a:	fb0c 6614 	mls	r6, ip, r4, r6
    a79e:	ea40 4706 	orr.w	r7, r0, r6, lsl #16
    a7a2:	fb04 f808 	mul.w	r8, r4, r8
    a7a6:	45b8      	cmp	r8, r7
    a7a8:	d907      	bls.n	a7ba <__udivmoddi4+0x26a>
    a7aa:	18ff      	adds	r7, r7, r3
    a7ac:	f104 30ff 	add.w	r0, r4, #4294967295	; 0xffffffff
    a7b0:	d228      	bcs.n	a804 <__udivmoddi4+0x2b4>
    a7b2:	45b8      	cmp	r8, r7
    a7b4:	d926      	bls.n	a804 <__udivmoddi4+0x2b4>
    a7b6:	3c02      	subs	r4, #2
    a7b8:	441f      	add	r7, r3
    a7ba:	ea44 4009 	orr.w	r0, r4, r9, lsl #16
    a7be:	ebc8 0707 	rsb	r7, r8, r7
    a7c2:	fba0 8902 	umull	r8, r9, r0, r2
    a7c6:	454f      	cmp	r7, r9
    a7c8:	4644      	mov	r4, r8
    a7ca:	464e      	mov	r6, r9
    a7cc:	d314      	bcc.n	a7f8 <__udivmoddi4+0x2a8>
    a7ce:	d029      	beq.n	a824 <__udivmoddi4+0x2d4>
    a7d0:	b365      	cbz	r5, a82c <__udivmoddi4+0x2dc>
    a7d2:	ebba 0304 	subs.w	r3, sl, r4
    a7d6:	eb67 0706 	sbc.w	r7, r7, r6
    a7da:	fa07 fe0e 	lsl.w	lr, r7, lr
    a7de:	40cb      	lsrs	r3, r1
    a7e0:	40cf      	lsrs	r7, r1
    a7e2:	ea4e 0303 	orr.w	r3, lr, r3
    a7e6:	e885 0088 	stmia.w	r5, {r3, r7}
    a7ea:	2100      	movs	r1, #0
    a7ec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a7f0:	4613      	mov	r3, r2
    a7f2:	e6f8      	b.n	a5e6 <__udivmoddi4+0x96>
    a7f4:	4610      	mov	r0, r2
    a7f6:	e6e0      	b.n	a5ba <__udivmoddi4+0x6a>
    a7f8:	ebb8 0402 	subs.w	r4, r8, r2
    a7fc:	eb69 0603 	sbc.w	r6, r9, r3
    a800:	3801      	subs	r0, #1
    a802:	e7e5      	b.n	a7d0 <__udivmoddi4+0x280>
    a804:	4604      	mov	r4, r0
    a806:	e7d8      	b.n	a7ba <__udivmoddi4+0x26a>
    a808:	4611      	mov	r1, r2
    a80a:	e795      	b.n	a738 <__udivmoddi4+0x1e8>
    a80c:	4681      	mov	r9, r0
    a80e:	e7c0      	b.n	a792 <__udivmoddi4+0x242>
    a810:	468a      	mov	sl, r1
    a812:	e77c      	b.n	a70e <__udivmoddi4+0x1be>
    a814:	3b02      	subs	r3, #2
    a816:	443c      	add	r4, r7
    a818:	e748      	b.n	a6ac <__udivmoddi4+0x15c>
    a81a:	4608      	mov	r0, r1
    a81c:	e70a      	b.n	a634 <__udivmoddi4+0xe4>
    a81e:	3802      	subs	r0, #2
    a820:	443e      	add	r6, r7
    a822:	e72f      	b.n	a684 <__udivmoddi4+0x134>
    a824:	45c2      	cmp	sl, r8
    a826:	d3e7      	bcc.n	a7f8 <__udivmoddi4+0x2a8>
    a828:	463e      	mov	r6, r7
    a82a:	e7d1      	b.n	a7d0 <__udivmoddi4+0x280>
    a82c:	4629      	mov	r1, r5
    a82e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a832:	bf00      	nop

0000a834 <__aeabi_idiv0>:
    a834:	4770      	bx	lr
    a836:	bf00      	nop

0000a838 <__cxa_atexit>:
    a838:	4613      	mov	r3, r2
    a83a:	460a      	mov	r2, r1
    a83c:	4601      	mov	r1, r0
    a83e:	2002      	movs	r0, #2
    a840:	f001 b840 	b.w	b8c4 <__register_exitproc>

0000a844 <__errno>:
    a844:	4b01      	ldr	r3, [pc, #4]	; (a84c <__errno+0x8>)
    a846:	6818      	ldr	r0, [r3, #0]
    a848:	4770      	bx	lr
    a84a:	bf00      	nop
    a84c:	1fff1000 	.word	0x1fff1000

0000a850 <__libc_init_array>:
    a850:	b570      	push	{r4, r5, r6, lr}
    a852:	4e0f      	ldr	r6, [pc, #60]	; (a890 <__libc_init_array+0x40>)
    a854:	4d0f      	ldr	r5, [pc, #60]	; (a894 <__libc_init_array+0x44>)
    a856:	1b76      	subs	r6, r6, r5
    a858:	10b6      	asrs	r6, r6, #2
    a85a:	bf18      	it	ne
    a85c:	2400      	movne	r4, #0
    a85e:	d005      	beq.n	a86c <__libc_init_array+0x1c>
    a860:	3401      	adds	r4, #1
    a862:	f855 3b04 	ldr.w	r3, [r5], #4
    a866:	4798      	blx	r3
    a868:	42a6      	cmp	r6, r4
    a86a:	d1f9      	bne.n	a860 <__libc_init_array+0x10>
    a86c:	4e0a      	ldr	r6, [pc, #40]	; (a898 <__libc_init_array+0x48>)
    a86e:	4d0b      	ldr	r5, [pc, #44]	; (a89c <__libc_init_array+0x4c>)
    a870:	1b76      	subs	r6, r6, r5
    a872:	f001 fe0f 	bl	c494 <_init>
    a876:	10b6      	asrs	r6, r6, #2
    a878:	bf18      	it	ne
    a87a:	2400      	movne	r4, #0
    a87c:	d006      	beq.n	a88c <__libc_init_array+0x3c>
    a87e:	3401      	adds	r4, #1
    a880:	f855 3b04 	ldr.w	r3, [r5], #4
    a884:	4798      	blx	r3
    a886:	42a6      	cmp	r6, r4
    a888:	d1f9      	bne.n	a87e <__libc_init_array+0x2e>
    a88a:	bd70      	pop	{r4, r5, r6, pc}
    a88c:	bd70      	pop	{r4, r5, r6, pc}
    a88e:	bf00      	nop
    a890:	0000c4a0 	.word	0x0000c4a0
    a894:	0000c4a0 	.word	0x0000c4a0
    a898:	0000c4ac 	.word	0x0000c4ac
    a89c:	0000c4a0 	.word	0x0000c4a0

0000a8a0 <malloc>:
    a8a0:	4b02      	ldr	r3, [pc, #8]	; (a8ac <malloc+0xc>)
    a8a2:	4601      	mov	r1, r0
    a8a4:	6818      	ldr	r0, [r3, #0]
    a8a6:	f000 b80b 	b.w	a8c0 <_malloc_r>
    a8aa:	bf00      	nop
    a8ac:	1fff1000 	.word	0x1fff1000

0000a8b0 <free>:
    a8b0:	4b02      	ldr	r3, [pc, #8]	; (a8bc <free+0xc>)
    a8b2:	4601      	mov	r1, r0
    a8b4:	6818      	ldr	r0, [r3, #0]
    a8b6:	f001 b8c9 	b.w	ba4c <_free_r>
    a8ba:	bf00      	nop
    a8bc:	1fff1000 	.word	0x1fff1000

0000a8c0 <_malloc_r>:
    a8c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a8c4:	f101 050b 	add.w	r5, r1, #11
    a8c8:	2d16      	cmp	r5, #22
    a8ca:	b083      	sub	sp, #12
    a8cc:	4606      	mov	r6, r0
    a8ce:	f240 809f 	bls.w	aa10 <_malloc_r+0x150>
    a8d2:	f035 0507 	bics.w	r5, r5, #7
    a8d6:	f100 80bf 	bmi.w	aa58 <_malloc_r+0x198>
    a8da:	42a9      	cmp	r1, r5
    a8dc:	f200 80bc 	bhi.w	aa58 <_malloc_r+0x198>
    a8e0:	f000 fb58 	bl	af94 <__malloc_lock>
    a8e4:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
    a8e8:	f0c0 829c 	bcc.w	ae24 <_malloc_r+0x564>
    a8ec:	0a6b      	lsrs	r3, r5, #9
    a8ee:	f000 80ba 	beq.w	aa66 <_malloc_r+0x1a6>
    a8f2:	2b04      	cmp	r3, #4
    a8f4:	f200 8183 	bhi.w	abfe <_malloc_r+0x33e>
    a8f8:	09a8      	lsrs	r0, r5, #6
    a8fa:	f100 0e39 	add.w	lr, r0, #57	; 0x39
    a8fe:	ea4f 034e 	mov.w	r3, lr, lsl #1
    a902:	3038      	adds	r0, #56	; 0x38
    a904:	4fc4      	ldr	r7, [pc, #784]	; (ac18 <_malloc_r+0x358>)
    a906:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    a90a:	f1a3 0108 	sub.w	r1, r3, #8
    a90e:	685c      	ldr	r4, [r3, #4]
    a910:	42a1      	cmp	r1, r4
    a912:	d107      	bne.n	a924 <_malloc_r+0x64>
    a914:	e0ac      	b.n	aa70 <_malloc_r+0x1b0>
    a916:	2a00      	cmp	r2, #0
    a918:	f280 80ac 	bge.w	aa74 <_malloc_r+0x1b4>
    a91c:	68e4      	ldr	r4, [r4, #12]
    a91e:	42a1      	cmp	r1, r4
    a920:	f000 80a6 	beq.w	aa70 <_malloc_r+0x1b0>
    a924:	6863      	ldr	r3, [r4, #4]
    a926:	f023 0303 	bic.w	r3, r3, #3
    a92a:	1b5a      	subs	r2, r3, r5
    a92c:	2a0f      	cmp	r2, #15
    a92e:	ddf2      	ble.n	a916 <_malloc_r+0x56>
    a930:	49b9      	ldr	r1, [pc, #740]	; (ac18 <_malloc_r+0x358>)
    a932:	693c      	ldr	r4, [r7, #16]
    a934:	f101 0e08 	add.w	lr, r1, #8
    a938:	4574      	cmp	r4, lr
    a93a:	f000 81b3 	beq.w	aca4 <_malloc_r+0x3e4>
    a93e:	6863      	ldr	r3, [r4, #4]
    a940:	f023 0303 	bic.w	r3, r3, #3
    a944:	1b5a      	subs	r2, r3, r5
    a946:	2a0f      	cmp	r2, #15
    a948:	f300 8199 	bgt.w	ac7e <_malloc_r+0x3be>
    a94c:	2a00      	cmp	r2, #0
    a94e:	f8c1 e014 	str.w	lr, [r1, #20]
    a952:	f8c1 e010 	str.w	lr, [r1, #16]
    a956:	f280 809e 	bge.w	aa96 <_malloc_r+0x1d6>
    a95a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    a95e:	f080 8167 	bcs.w	ac30 <_malloc_r+0x370>
    a962:	08db      	lsrs	r3, r3, #3
    a964:	f103 0c01 	add.w	ip, r3, #1
    a968:	2201      	movs	r2, #1
    a96a:	109b      	asrs	r3, r3, #2
    a96c:	fa02 f303 	lsl.w	r3, r2, r3
    a970:	684a      	ldr	r2, [r1, #4]
    a972:	f851 803c 	ldr.w	r8, [r1, ip, lsl #3]
    a976:	f8c4 8008 	str.w	r8, [r4, #8]
    a97a:	eb01 09cc 	add.w	r9, r1, ip, lsl #3
    a97e:	431a      	orrs	r2, r3
    a980:	f1a9 0308 	sub.w	r3, r9, #8
    a984:	60e3      	str	r3, [r4, #12]
    a986:	604a      	str	r2, [r1, #4]
    a988:	f841 403c 	str.w	r4, [r1, ip, lsl #3]
    a98c:	f8c8 400c 	str.w	r4, [r8, #12]
    a990:	1083      	asrs	r3, r0, #2
    a992:	2401      	movs	r4, #1
    a994:	409c      	lsls	r4, r3
    a996:	4294      	cmp	r4, r2
    a998:	f200 808a 	bhi.w	aab0 <_malloc_r+0x1f0>
    a99c:	4214      	tst	r4, r2
    a99e:	d106      	bne.n	a9ae <_malloc_r+0xee>
    a9a0:	f020 0003 	bic.w	r0, r0, #3
    a9a4:	0064      	lsls	r4, r4, #1
    a9a6:	4214      	tst	r4, r2
    a9a8:	f100 0004 	add.w	r0, r0, #4
    a9ac:	d0fa      	beq.n	a9a4 <_malloc_r+0xe4>
    a9ae:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
    a9b2:	46cc      	mov	ip, r9
    a9b4:	4680      	mov	r8, r0
    a9b6:	f8dc 100c 	ldr.w	r1, [ip, #12]
    a9ba:	458c      	cmp	ip, r1
    a9bc:	d107      	bne.n	a9ce <_malloc_r+0x10e>
    a9be:	e173      	b.n	aca8 <_malloc_r+0x3e8>
    a9c0:	2a00      	cmp	r2, #0
    a9c2:	f280 8181 	bge.w	acc8 <_malloc_r+0x408>
    a9c6:	68c9      	ldr	r1, [r1, #12]
    a9c8:	458c      	cmp	ip, r1
    a9ca:	f000 816d 	beq.w	aca8 <_malloc_r+0x3e8>
    a9ce:	684b      	ldr	r3, [r1, #4]
    a9d0:	f023 0303 	bic.w	r3, r3, #3
    a9d4:	1b5a      	subs	r2, r3, r5
    a9d6:	2a0f      	cmp	r2, #15
    a9d8:	ddf2      	ble.n	a9c0 <_malloc_r+0x100>
    a9da:	460c      	mov	r4, r1
    a9dc:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    a9e0:	f854 8f08 	ldr.w	r8, [r4, #8]!
    a9e4:	194b      	adds	r3, r1, r5
    a9e6:	f045 0501 	orr.w	r5, r5, #1
    a9ea:	604d      	str	r5, [r1, #4]
    a9ec:	f042 0101 	orr.w	r1, r2, #1
    a9f0:	f8c8 c00c 	str.w	ip, [r8, #12]
    a9f4:	4630      	mov	r0, r6
    a9f6:	f8cc 8008 	str.w	r8, [ip, #8]
    a9fa:	617b      	str	r3, [r7, #20]
    a9fc:	613b      	str	r3, [r7, #16]
    a9fe:	f8c3 e00c 	str.w	lr, [r3, #12]
    aa02:	f8c3 e008 	str.w	lr, [r3, #8]
    aa06:	6059      	str	r1, [r3, #4]
    aa08:	509a      	str	r2, [r3, r2]
    aa0a:	f000 fac5 	bl	af98 <__malloc_unlock>
    aa0e:	e01f      	b.n	aa50 <_malloc_r+0x190>
    aa10:	2910      	cmp	r1, #16
    aa12:	d821      	bhi.n	aa58 <_malloc_r+0x198>
    aa14:	f000 fabe 	bl	af94 <__malloc_lock>
    aa18:	2510      	movs	r5, #16
    aa1a:	2306      	movs	r3, #6
    aa1c:	2002      	movs	r0, #2
    aa1e:	4f7e      	ldr	r7, [pc, #504]	; (ac18 <_malloc_r+0x358>)
    aa20:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    aa24:	f1a3 0208 	sub.w	r2, r3, #8
    aa28:	685c      	ldr	r4, [r3, #4]
    aa2a:	4294      	cmp	r4, r2
    aa2c:	f000 8145 	beq.w	acba <_malloc_r+0x3fa>
    aa30:	6863      	ldr	r3, [r4, #4]
    aa32:	68e1      	ldr	r1, [r4, #12]
    aa34:	68a5      	ldr	r5, [r4, #8]
    aa36:	f023 0303 	bic.w	r3, r3, #3
    aa3a:	4423      	add	r3, r4
    aa3c:	4630      	mov	r0, r6
    aa3e:	685a      	ldr	r2, [r3, #4]
    aa40:	60e9      	str	r1, [r5, #12]
    aa42:	f042 0201 	orr.w	r2, r2, #1
    aa46:	608d      	str	r5, [r1, #8]
    aa48:	605a      	str	r2, [r3, #4]
    aa4a:	f000 faa5 	bl	af98 <__malloc_unlock>
    aa4e:	3408      	adds	r4, #8
    aa50:	4620      	mov	r0, r4
    aa52:	b003      	add	sp, #12
    aa54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    aa58:	2400      	movs	r4, #0
    aa5a:	230c      	movs	r3, #12
    aa5c:	4620      	mov	r0, r4
    aa5e:	6033      	str	r3, [r6, #0]
    aa60:	b003      	add	sp, #12
    aa62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    aa66:	2380      	movs	r3, #128	; 0x80
    aa68:	f04f 0e40 	mov.w	lr, #64	; 0x40
    aa6c:	203f      	movs	r0, #63	; 0x3f
    aa6e:	e749      	b.n	a904 <_malloc_r+0x44>
    aa70:	4670      	mov	r0, lr
    aa72:	e75d      	b.n	a930 <_malloc_r+0x70>
    aa74:	4423      	add	r3, r4
    aa76:	68e1      	ldr	r1, [r4, #12]
    aa78:	685a      	ldr	r2, [r3, #4]
    aa7a:	68a5      	ldr	r5, [r4, #8]
    aa7c:	f042 0201 	orr.w	r2, r2, #1
    aa80:	60e9      	str	r1, [r5, #12]
    aa82:	4630      	mov	r0, r6
    aa84:	608d      	str	r5, [r1, #8]
    aa86:	605a      	str	r2, [r3, #4]
    aa88:	f000 fa86 	bl	af98 <__malloc_unlock>
    aa8c:	3408      	adds	r4, #8
    aa8e:	4620      	mov	r0, r4
    aa90:	b003      	add	sp, #12
    aa92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    aa96:	4423      	add	r3, r4
    aa98:	4630      	mov	r0, r6
    aa9a:	685a      	ldr	r2, [r3, #4]
    aa9c:	f042 0201 	orr.w	r2, r2, #1
    aaa0:	605a      	str	r2, [r3, #4]
    aaa2:	f000 fa79 	bl	af98 <__malloc_unlock>
    aaa6:	3408      	adds	r4, #8
    aaa8:	4620      	mov	r0, r4
    aaaa:	b003      	add	sp, #12
    aaac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    aab0:	68bc      	ldr	r4, [r7, #8]
    aab2:	6863      	ldr	r3, [r4, #4]
    aab4:	f023 0803 	bic.w	r8, r3, #3
    aab8:	45a8      	cmp	r8, r5
    aaba:	d304      	bcc.n	aac6 <_malloc_r+0x206>
    aabc:	ebc5 0308 	rsb	r3, r5, r8
    aac0:	2b0f      	cmp	r3, #15
    aac2:	f300 808c 	bgt.w	abde <_malloc_r+0x31e>
    aac6:	4b55      	ldr	r3, [pc, #340]	; (ac1c <_malloc_r+0x35c>)
    aac8:	f8df 9160 	ldr.w	r9, [pc, #352]	; ac2c <_malloc_r+0x36c>
    aacc:	681a      	ldr	r2, [r3, #0]
    aace:	f8d9 3000 	ldr.w	r3, [r9]
    aad2:	3301      	adds	r3, #1
    aad4:	442a      	add	r2, r5
    aad6:	eb04 0a08 	add.w	sl, r4, r8
    aada:	f000 8160 	beq.w	ad9e <_malloc_r+0x4de>
    aade:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    aae2:	320f      	adds	r2, #15
    aae4:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
    aae8:	f022 020f 	bic.w	r2, r2, #15
    aaec:	4611      	mov	r1, r2
    aaee:	4630      	mov	r0, r6
    aaf0:	9201      	str	r2, [sp, #4]
    aaf2:	f000 fc4b 	bl	b38c <_sbrk_r>
    aaf6:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    aafa:	4683      	mov	fp, r0
    aafc:	9a01      	ldr	r2, [sp, #4]
    aafe:	f000 8158 	beq.w	adb2 <_malloc_r+0x4f2>
    ab02:	4582      	cmp	sl, r0
    ab04:	f200 80fc 	bhi.w	ad00 <_malloc_r+0x440>
    ab08:	4b45      	ldr	r3, [pc, #276]	; (ac20 <_malloc_r+0x360>)
    ab0a:	6819      	ldr	r1, [r3, #0]
    ab0c:	45da      	cmp	sl, fp
    ab0e:	4411      	add	r1, r2
    ab10:	6019      	str	r1, [r3, #0]
    ab12:	f000 8153 	beq.w	adbc <_malloc_r+0x4fc>
    ab16:	f8d9 0000 	ldr.w	r0, [r9]
    ab1a:	f8df e110 	ldr.w	lr, [pc, #272]	; ac2c <_malloc_r+0x36c>
    ab1e:	3001      	adds	r0, #1
    ab20:	bf1b      	ittet	ne
    ab22:	ebca 0a0b 	rsbne	sl, sl, fp
    ab26:	4451      	addne	r1, sl
    ab28:	f8ce b000 	streq.w	fp, [lr]
    ab2c:	6019      	strne	r1, [r3, #0]
    ab2e:	f01b 0107 	ands.w	r1, fp, #7
    ab32:	f000 8117 	beq.w	ad64 <_malloc_r+0x4a4>
    ab36:	f1c1 0008 	rsb	r0, r1, #8
    ab3a:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
    ab3e:	4483      	add	fp, r0
    ab40:	3108      	adds	r1, #8
    ab42:	445a      	add	r2, fp
    ab44:	f3c2 020b 	ubfx	r2, r2, #0, #12
    ab48:	ebc2 0901 	rsb	r9, r2, r1
    ab4c:	4649      	mov	r1, r9
    ab4e:	4630      	mov	r0, r6
    ab50:	9301      	str	r3, [sp, #4]
    ab52:	f000 fc1b 	bl	b38c <_sbrk_r>
    ab56:	1c43      	adds	r3, r0, #1
    ab58:	9b01      	ldr	r3, [sp, #4]
    ab5a:	f000 813f 	beq.w	addc <_malloc_r+0x51c>
    ab5e:	ebcb 0200 	rsb	r2, fp, r0
    ab62:	444a      	add	r2, r9
    ab64:	f042 0201 	orr.w	r2, r2, #1
    ab68:	6819      	ldr	r1, [r3, #0]
    ab6a:	f8c7 b008 	str.w	fp, [r7, #8]
    ab6e:	4449      	add	r1, r9
    ab70:	42bc      	cmp	r4, r7
    ab72:	f8cb 2004 	str.w	r2, [fp, #4]
    ab76:	6019      	str	r1, [r3, #0]
    ab78:	f8df 90a4 	ldr.w	r9, [pc, #164]	; ac20 <_malloc_r+0x360>
    ab7c:	d016      	beq.n	abac <_malloc_r+0x2ec>
    ab7e:	f1b8 0f0f 	cmp.w	r8, #15
    ab82:	f240 80fd 	bls.w	ad80 <_malloc_r+0x4c0>
    ab86:	6862      	ldr	r2, [r4, #4]
    ab88:	f1a8 030c 	sub.w	r3, r8, #12
    ab8c:	f023 0307 	bic.w	r3, r3, #7
    ab90:	18e0      	adds	r0, r4, r3
    ab92:	f002 0201 	and.w	r2, r2, #1
    ab96:	f04f 0e05 	mov.w	lr, #5
    ab9a:	431a      	orrs	r2, r3
    ab9c:	2b0f      	cmp	r3, #15
    ab9e:	6062      	str	r2, [r4, #4]
    aba0:	f8c0 e004 	str.w	lr, [r0, #4]
    aba4:	f8c0 e008 	str.w	lr, [r0, #8]
    aba8:	f200 811c 	bhi.w	ade4 <_malloc_r+0x524>
    abac:	4b1d      	ldr	r3, [pc, #116]	; (ac24 <_malloc_r+0x364>)
    abae:	68bc      	ldr	r4, [r7, #8]
    abb0:	681a      	ldr	r2, [r3, #0]
    abb2:	4291      	cmp	r1, r2
    abb4:	bf88      	it	hi
    abb6:	6019      	strhi	r1, [r3, #0]
    abb8:	4b1b      	ldr	r3, [pc, #108]	; (ac28 <_malloc_r+0x368>)
    abba:	681a      	ldr	r2, [r3, #0]
    abbc:	4291      	cmp	r1, r2
    abbe:	6862      	ldr	r2, [r4, #4]
    abc0:	bf88      	it	hi
    abc2:	6019      	strhi	r1, [r3, #0]
    abc4:	f022 0203 	bic.w	r2, r2, #3
    abc8:	4295      	cmp	r5, r2
    abca:	eba2 0305 	sub.w	r3, r2, r5
    abce:	d801      	bhi.n	abd4 <_malloc_r+0x314>
    abd0:	2b0f      	cmp	r3, #15
    abd2:	dc04      	bgt.n	abde <_malloc_r+0x31e>
    abd4:	4630      	mov	r0, r6
    abd6:	f000 f9df 	bl	af98 <__malloc_unlock>
    abda:	2400      	movs	r4, #0
    abdc:	e738      	b.n	aa50 <_malloc_r+0x190>
    abde:	1962      	adds	r2, r4, r5
    abe0:	f043 0301 	orr.w	r3, r3, #1
    abe4:	f045 0501 	orr.w	r5, r5, #1
    abe8:	6065      	str	r5, [r4, #4]
    abea:	4630      	mov	r0, r6
    abec:	60ba      	str	r2, [r7, #8]
    abee:	6053      	str	r3, [r2, #4]
    abf0:	f000 f9d2 	bl	af98 <__malloc_unlock>
    abf4:	3408      	adds	r4, #8
    abf6:	4620      	mov	r0, r4
    abf8:	b003      	add	sp, #12
    abfa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    abfe:	2b14      	cmp	r3, #20
    ac00:	d971      	bls.n	ace6 <_malloc_r+0x426>
    ac02:	2b54      	cmp	r3, #84	; 0x54
    ac04:	f200 80a4 	bhi.w	ad50 <_malloc_r+0x490>
    ac08:	0b28      	lsrs	r0, r5, #12
    ac0a:	f100 0e6f 	add.w	lr, r0, #111	; 0x6f
    ac0e:	ea4f 034e 	mov.w	r3, lr, lsl #1
    ac12:	306e      	adds	r0, #110	; 0x6e
    ac14:	e676      	b.n	a904 <_malloc_r+0x44>
    ac16:	bf00      	nop
    ac18:	1fff1004 	.word	0x1fff1004
    ac1c:	1fff2d3c 	.word	0x1fff2d3c
    ac20:	1fff2d40 	.word	0x1fff2d40
    ac24:	1fff2d38 	.word	0x1fff2d38
    ac28:	1fff2d34 	.word	0x1fff2d34
    ac2c:	1fff1410 	.word	0x1fff1410
    ac30:	0a5a      	lsrs	r2, r3, #9
    ac32:	2a04      	cmp	r2, #4
    ac34:	d95e      	bls.n	acf4 <_malloc_r+0x434>
    ac36:	2a14      	cmp	r2, #20
    ac38:	f200 80b3 	bhi.w	ada2 <_malloc_r+0x4e2>
    ac3c:	f102 015c 	add.w	r1, r2, #92	; 0x5c
    ac40:	0049      	lsls	r1, r1, #1
    ac42:	325b      	adds	r2, #91	; 0x5b
    ac44:	eb07 0c81 	add.w	ip, r7, r1, lsl #2
    ac48:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
    ac4c:	f8df 81dc 	ldr.w	r8, [pc, #476]	; ae2c <_malloc_r+0x56c>
    ac50:	f1ac 0c08 	sub.w	ip, ip, #8
    ac54:	458c      	cmp	ip, r1
    ac56:	f000 8088 	beq.w	ad6a <_malloc_r+0x4aa>
    ac5a:	684a      	ldr	r2, [r1, #4]
    ac5c:	f022 0203 	bic.w	r2, r2, #3
    ac60:	4293      	cmp	r3, r2
    ac62:	d202      	bcs.n	ac6a <_malloc_r+0x3aa>
    ac64:	6889      	ldr	r1, [r1, #8]
    ac66:	458c      	cmp	ip, r1
    ac68:	d1f7      	bne.n	ac5a <_malloc_r+0x39a>
    ac6a:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    ac6e:	687a      	ldr	r2, [r7, #4]
    ac70:	f8c4 c00c 	str.w	ip, [r4, #12]
    ac74:	60a1      	str	r1, [r4, #8]
    ac76:	f8cc 4008 	str.w	r4, [ip, #8]
    ac7a:	60cc      	str	r4, [r1, #12]
    ac7c:	e688      	b.n	a990 <_malloc_r+0xd0>
    ac7e:	1963      	adds	r3, r4, r5
    ac80:	f042 0701 	orr.w	r7, r2, #1
    ac84:	f045 0501 	orr.w	r5, r5, #1
    ac88:	6065      	str	r5, [r4, #4]
    ac8a:	4630      	mov	r0, r6
    ac8c:	614b      	str	r3, [r1, #20]
    ac8e:	610b      	str	r3, [r1, #16]
    ac90:	f8c3 e00c 	str.w	lr, [r3, #12]
    ac94:	f8c3 e008 	str.w	lr, [r3, #8]
    ac98:	605f      	str	r7, [r3, #4]
    ac9a:	509a      	str	r2, [r3, r2]
    ac9c:	3408      	adds	r4, #8
    ac9e:	f000 f97b 	bl	af98 <__malloc_unlock>
    aca2:	e6d5      	b.n	aa50 <_malloc_r+0x190>
    aca4:	684a      	ldr	r2, [r1, #4]
    aca6:	e673      	b.n	a990 <_malloc_r+0xd0>
    aca8:	f108 0801 	add.w	r8, r8, #1
    acac:	f018 0f03 	tst.w	r8, #3
    acb0:	f10c 0c08 	add.w	ip, ip, #8
    acb4:	f47f ae7f 	bne.w	a9b6 <_malloc_r+0xf6>
    acb8:	e030      	b.n	ad1c <_malloc_r+0x45c>
    acba:	68dc      	ldr	r4, [r3, #12]
    acbc:	42a3      	cmp	r3, r4
    acbe:	bf08      	it	eq
    acc0:	3002      	addeq	r0, #2
    acc2:	f43f ae35 	beq.w	a930 <_malloc_r+0x70>
    acc6:	e6b3      	b.n	aa30 <_malloc_r+0x170>
    acc8:	440b      	add	r3, r1
    acca:	460c      	mov	r4, r1
    accc:	685a      	ldr	r2, [r3, #4]
    acce:	68c9      	ldr	r1, [r1, #12]
    acd0:	f854 5f08 	ldr.w	r5, [r4, #8]!
    acd4:	f042 0201 	orr.w	r2, r2, #1
    acd8:	605a      	str	r2, [r3, #4]
    acda:	4630      	mov	r0, r6
    acdc:	60e9      	str	r1, [r5, #12]
    acde:	608d      	str	r5, [r1, #8]
    ace0:	f000 f95a 	bl	af98 <__malloc_unlock>
    ace4:	e6b4      	b.n	aa50 <_malloc_r+0x190>
    ace6:	f103 0e5c 	add.w	lr, r3, #92	; 0x5c
    acea:	f103 005b 	add.w	r0, r3, #91	; 0x5b
    acee:	ea4f 034e 	mov.w	r3, lr, lsl #1
    acf2:	e607      	b.n	a904 <_malloc_r+0x44>
    acf4:	099a      	lsrs	r2, r3, #6
    acf6:	f102 0139 	add.w	r1, r2, #57	; 0x39
    acfa:	0049      	lsls	r1, r1, #1
    acfc:	3238      	adds	r2, #56	; 0x38
    acfe:	e7a1      	b.n	ac44 <_malloc_r+0x384>
    ad00:	42bc      	cmp	r4, r7
    ad02:	4b4a      	ldr	r3, [pc, #296]	; (ae2c <_malloc_r+0x56c>)
    ad04:	f43f af00 	beq.w	ab08 <_malloc_r+0x248>
    ad08:	689c      	ldr	r4, [r3, #8]
    ad0a:	6862      	ldr	r2, [r4, #4]
    ad0c:	f022 0203 	bic.w	r2, r2, #3
    ad10:	e75a      	b.n	abc8 <_malloc_r+0x308>
    ad12:	f859 3908 	ldr.w	r3, [r9], #-8
    ad16:	4599      	cmp	r9, r3
    ad18:	f040 8082 	bne.w	ae20 <_malloc_r+0x560>
    ad1c:	f010 0f03 	tst.w	r0, #3
    ad20:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
    ad24:	d1f5      	bne.n	ad12 <_malloc_r+0x452>
    ad26:	687b      	ldr	r3, [r7, #4]
    ad28:	ea23 0304 	bic.w	r3, r3, r4
    ad2c:	607b      	str	r3, [r7, #4]
    ad2e:	0064      	lsls	r4, r4, #1
    ad30:	429c      	cmp	r4, r3
    ad32:	f63f aebd 	bhi.w	aab0 <_malloc_r+0x1f0>
    ad36:	2c00      	cmp	r4, #0
    ad38:	f43f aeba 	beq.w	aab0 <_malloc_r+0x1f0>
    ad3c:	421c      	tst	r4, r3
    ad3e:	4640      	mov	r0, r8
    ad40:	f47f ae35 	bne.w	a9ae <_malloc_r+0xee>
    ad44:	0064      	lsls	r4, r4, #1
    ad46:	421c      	tst	r4, r3
    ad48:	f100 0004 	add.w	r0, r0, #4
    ad4c:	d0fa      	beq.n	ad44 <_malloc_r+0x484>
    ad4e:	e62e      	b.n	a9ae <_malloc_r+0xee>
    ad50:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
    ad54:	d818      	bhi.n	ad88 <_malloc_r+0x4c8>
    ad56:	0be8      	lsrs	r0, r5, #15
    ad58:	f100 0e78 	add.w	lr, r0, #120	; 0x78
    ad5c:	ea4f 034e 	mov.w	r3, lr, lsl #1
    ad60:	3077      	adds	r0, #119	; 0x77
    ad62:	e5cf      	b.n	a904 <_malloc_r+0x44>
    ad64:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    ad68:	e6eb      	b.n	ab42 <_malloc_r+0x282>
    ad6a:	2101      	movs	r1, #1
    ad6c:	f8d8 3004 	ldr.w	r3, [r8, #4]
    ad70:	1092      	asrs	r2, r2, #2
    ad72:	fa01 f202 	lsl.w	r2, r1, r2
    ad76:	431a      	orrs	r2, r3
    ad78:	f8c8 2004 	str.w	r2, [r8, #4]
    ad7c:	4661      	mov	r1, ip
    ad7e:	e777      	b.n	ac70 <_malloc_r+0x3b0>
    ad80:	2301      	movs	r3, #1
    ad82:	f8cb 3004 	str.w	r3, [fp, #4]
    ad86:	e725      	b.n	abd4 <_malloc_r+0x314>
    ad88:	f240 5254 	movw	r2, #1364	; 0x554
    ad8c:	4293      	cmp	r3, r2
    ad8e:	d820      	bhi.n	add2 <_malloc_r+0x512>
    ad90:	0ca8      	lsrs	r0, r5, #18
    ad92:	f100 0e7d 	add.w	lr, r0, #125	; 0x7d
    ad96:	ea4f 034e 	mov.w	r3, lr, lsl #1
    ad9a:	307c      	adds	r0, #124	; 0x7c
    ad9c:	e5b2      	b.n	a904 <_malloc_r+0x44>
    ad9e:	3210      	adds	r2, #16
    ada0:	e6a4      	b.n	aaec <_malloc_r+0x22c>
    ada2:	2a54      	cmp	r2, #84	; 0x54
    ada4:	d826      	bhi.n	adf4 <_malloc_r+0x534>
    ada6:	0b1a      	lsrs	r2, r3, #12
    ada8:	f102 016f 	add.w	r1, r2, #111	; 0x6f
    adac:	0049      	lsls	r1, r1, #1
    adae:	326e      	adds	r2, #110	; 0x6e
    adb0:	e748      	b.n	ac44 <_malloc_r+0x384>
    adb2:	68bc      	ldr	r4, [r7, #8]
    adb4:	6862      	ldr	r2, [r4, #4]
    adb6:	f022 0203 	bic.w	r2, r2, #3
    adba:	e705      	b.n	abc8 <_malloc_r+0x308>
    adbc:	f3ca 000b 	ubfx	r0, sl, #0, #12
    adc0:	2800      	cmp	r0, #0
    adc2:	f47f aea8 	bne.w	ab16 <_malloc_r+0x256>
    adc6:	4442      	add	r2, r8
    adc8:	68bb      	ldr	r3, [r7, #8]
    adca:	f042 0201 	orr.w	r2, r2, #1
    adce:	605a      	str	r2, [r3, #4]
    add0:	e6ec      	b.n	abac <_malloc_r+0x2ec>
    add2:	23fe      	movs	r3, #254	; 0xfe
    add4:	f04f 0e7f 	mov.w	lr, #127	; 0x7f
    add8:	207e      	movs	r0, #126	; 0x7e
    adda:	e593      	b.n	a904 <_malloc_r+0x44>
    addc:	2201      	movs	r2, #1
    adde:	f04f 0900 	mov.w	r9, #0
    ade2:	e6c1      	b.n	ab68 <_malloc_r+0x2a8>
    ade4:	f104 0108 	add.w	r1, r4, #8
    ade8:	4630      	mov	r0, r6
    adea:	f000 fe2f 	bl	ba4c <_free_r>
    adee:	f8d9 1000 	ldr.w	r1, [r9]
    adf2:	e6db      	b.n	abac <_malloc_r+0x2ec>
    adf4:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    adf8:	d805      	bhi.n	ae06 <_malloc_r+0x546>
    adfa:	0bda      	lsrs	r2, r3, #15
    adfc:	f102 0178 	add.w	r1, r2, #120	; 0x78
    ae00:	0049      	lsls	r1, r1, #1
    ae02:	3277      	adds	r2, #119	; 0x77
    ae04:	e71e      	b.n	ac44 <_malloc_r+0x384>
    ae06:	f240 5154 	movw	r1, #1364	; 0x554
    ae0a:	428a      	cmp	r2, r1
    ae0c:	d805      	bhi.n	ae1a <_malloc_r+0x55a>
    ae0e:	0c9a      	lsrs	r2, r3, #18
    ae10:	f102 017d 	add.w	r1, r2, #125	; 0x7d
    ae14:	0049      	lsls	r1, r1, #1
    ae16:	327c      	adds	r2, #124	; 0x7c
    ae18:	e714      	b.n	ac44 <_malloc_r+0x384>
    ae1a:	21fe      	movs	r1, #254	; 0xfe
    ae1c:	227e      	movs	r2, #126	; 0x7e
    ae1e:	e711      	b.n	ac44 <_malloc_r+0x384>
    ae20:	687b      	ldr	r3, [r7, #4]
    ae22:	e784      	b.n	ad2e <_malloc_r+0x46e>
    ae24:	08e8      	lsrs	r0, r5, #3
    ae26:	1c43      	adds	r3, r0, #1
    ae28:	005b      	lsls	r3, r3, #1
    ae2a:	e5f8      	b.n	aa1e <_malloc_r+0x15e>
    ae2c:	1fff1004 	.word	0x1fff1004

0000ae30 <memmove>:
    ae30:	4288      	cmp	r0, r1
    ae32:	b5f0      	push	{r4, r5, r6, r7, lr}
    ae34:	d90d      	bls.n	ae52 <memmove+0x22>
    ae36:	188b      	adds	r3, r1, r2
    ae38:	4298      	cmp	r0, r3
    ae3a:	d20a      	bcs.n	ae52 <memmove+0x22>
    ae3c:	1881      	adds	r1, r0, r2
    ae3e:	2a00      	cmp	r2, #0
    ae40:	d051      	beq.n	aee6 <memmove+0xb6>
    ae42:	1a9a      	subs	r2, r3, r2
    ae44:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
    ae48:	f801 4d01 	strb.w	r4, [r1, #-1]!
    ae4c:	4293      	cmp	r3, r2
    ae4e:	d1f9      	bne.n	ae44 <memmove+0x14>
    ae50:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ae52:	2a0f      	cmp	r2, #15
    ae54:	d948      	bls.n	aee8 <memmove+0xb8>
    ae56:	ea41 0300 	orr.w	r3, r1, r0
    ae5a:	079b      	lsls	r3, r3, #30
    ae5c:	d146      	bne.n	aeec <memmove+0xbc>
    ae5e:	f100 0410 	add.w	r4, r0, #16
    ae62:	f101 0310 	add.w	r3, r1, #16
    ae66:	4615      	mov	r5, r2
    ae68:	f853 6c10 	ldr.w	r6, [r3, #-16]
    ae6c:	f844 6c10 	str.w	r6, [r4, #-16]
    ae70:	f853 6c0c 	ldr.w	r6, [r3, #-12]
    ae74:	f844 6c0c 	str.w	r6, [r4, #-12]
    ae78:	f853 6c08 	ldr.w	r6, [r3, #-8]
    ae7c:	f844 6c08 	str.w	r6, [r4, #-8]
    ae80:	3d10      	subs	r5, #16
    ae82:	f853 6c04 	ldr.w	r6, [r3, #-4]
    ae86:	f844 6c04 	str.w	r6, [r4, #-4]
    ae8a:	2d0f      	cmp	r5, #15
    ae8c:	f103 0310 	add.w	r3, r3, #16
    ae90:	f104 0410 	add.w	r4, r4, #16
    ae94:	d8e8      	bhi.n	ae68 <memmove+0x38>
    ae96:	f1a2 0310 	sub.w	r3, r2, #16
    ae9a:	f023 030f 	bic.w	r3, r3, #15
    ae9e:	f002 0e0f 	and.w	lr, r2, #15
    aea2:	3310      	adds	r3, #16
    aea4:	f1be 0f03 	cmp.w	lr, #3
    aea8:	4419      	add	r1, r3
    aeaa:	4403      	add	r3, r0
    aeac:	d921      	bls.n	aef2 <memmove+0xc2>
    aeae:	1f1e      	subs	r6, r3, #4
    aeb0:	460d      	mov	r5, r1
    aeb2:	4674      	mov	r4, lr
    aeb4:	3c04      	subs	r4, #4
    aeb6:	f855 7b04 	ldr.w	r7, [r5], #4
    aeba:	f846 7f04 	str.w	r7, [r6, #4]!
    aebe:	2c03      	cmp	r4, #3
    aec0:	d8f8      	bhi.n	aeb4 <memmove+0x84>
    aec2:	f1ae 0404 	sub.w	r4, lr, #4
    aec6:	f024 0403 	bic.w	r4, r4, #3
    aeca:	3404      	adds	r4, #4
    aecc:	4423      	add	r3, r4
    aece:	4421      	add	r1, r4
    aed0:	f002 0203 	and.w	r2, r2, #3
    aed4:	b162      	cbz	r2, aef0 <memmove+0xc0>
    aed6:	3b01      	subs	r3, #1
    aed8:	440a      	add	r2, r1
    aeda:	f811 4b01 	ldrb.w	r4, [r1], #1
    aede:	f803 4f01 	strb.w	r4, [r3, #1]!
    aee2:	428a      	cmp	r2, r1
    aee4:	d1f9      	bne.n	aeda <memmove+0xaa>
    aee6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    aee8:	4603      	mov	r3, r0
    aeea:	e7f3      	b.n	aed4 <memmove+0xa4>
    aeec:	4603      	mov	r3, r0
    aeee:	e7f2      	b.n	aed6 <memmove+0xa6>
    aef0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    aef2:	4672      	mov	r2, lr
    aef4:	e7ee      	b.n	aed4 <memmove+0xa4>
    aef6:	bf00      	nop

0000aef8 <memset>:
    aef8:	b470      	push	{r4, r5, r6}
    aefa:	0784      	lsls	r4, r0, #30
    aefc:	d046      	beq.n	af8c <memset+0x94>
    aefe:	1e54      	subs	r4, r2, #1
    af00:	2a00      	cmp	r2, #0
    af02:	d041      	beq.n	af88 <memset+0x90>
    af04:	b2cd      	uxtb	r5, r1
    af06:	4603      	mov	r3, r0
    af08:	e002      	b.n	af10 <memset+0x18>
    af0a:	1e62      	subs	r2, r4, #1
    af0c:	b3e4      	cbz	r4, af88 <memset+0x90>
    af0e:	4614      	mov	r4, r2
    af10:	f803 5b01 	strb.w	r5, [r3], #1
    af14:	079a      	lsls	r2, r3, #30
    af16:	d1f8      	bne.n	af0a <memset+0x12>
    af18:	2c03      	cmp	r4, #3
    af1a:	d92e      	bls.n	af7a <memset+0x82>
    af1c:	b2cd      	uxtb	r5, r1
    af1e:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    af22:	2c0f      	cmp	r4, #15
    af24:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    af28:	d919      	bls.n	af5e <memset+0x66>
    af2a:	f103 0210 	add.w	r2, r3, #16
    af2e:	4626      	mov	r6, r4
    af30:	3e10      	subs	r6, #16
    af32:	2e0f      	cmp	r6, #15
    af34:	f842 5c10 	str.w	r5, [r2, #-16]
    af38:	f842 5c0c 	str.w	r5, [r2, #-12]
    af3c:	f842 5c08 	str.w	r5, [r2, #-8]
    af40:	f842 5c04 	str.w	r5, [r2, #-4]
    af44:	f102 0210 	add.w	r2, r2, #16
    af48:	d8f2      	bhi.n	af30 <memset+0x38>
    af4a:	f1a4 0210 	sub.w	r2, r4, #16
    af4e:	f022 020f 	bic.w	r2, r2, #15
    af52:	f004 040f 	and.w	r4, r4, #15
    af56:	3210      	adds	r2, #16
    af58:	2c03      	cmp	r4, #3
    af5a:	4413      	add	r3, r2
    af5c:	d90d      	bls.n	af7a <memset+0x82>
    af5e:	461e      	mov	r6, r3
    af60:	4622      	mov	r2, r4
    af62:	3a04      	subs	r2, #4
    af64:	2a03      	cmp	r2, #3
    af66:	f846 5b04 	str.w	r5, [r6], #4
    af6a:	d8fa      	bhi.n	af62 <memset+0x6a>
    af6c:	1f22      	subs	r2, r4, #4
    af6e:	f022 0203 	bic.w	r2, r2, #3
    af72:	3204      	adds	r2, #4
    af74:	4413      	add	r3, r2
    af76:	f004 0403 	and.w	r4, r4, #3
    af7a:	b12c      	cbz	r4, af88 <memset+0x90>
    af7c:	b2c9      	uxtb	r1, r1
    af7e:	441c      	add	r4, r3
    af80:	f803 1b01 	strb.w	r1, [r3], #1
    af84:	42a3      	cmp	r3, r4
    af86:	d1fb      	bne.n	af80 <memset+0x88>
    af88:	bc70      	pop	{r4, r5, r6}
    af8a:	4770      	bx	lr
    af8c:	4614      	mov	r4, r2
    af8e:	4603      	mov	r3, r0
    af90:	e7c2      	b.n	af18 <memset+0x20>
    af92:	bf00      	nop

0000af94 <__malloc_lock>:
    af94:	4770      	bx	lr
    af96:	bf00      	nop

0000af98 <__malloc_unlock>:
    af98:	4770      	bx	lr
    af9a:	bf00      	nop

0000af9c <realloc>:
    af9c:	4b02      	ldr	r3, [pc, #8]	; (afa8 <realloc+0xc>)
    af9e:	460a      	mov	r2, r1
    afa0:	4601      	mov	r1, r0
    afa2:	6818      	ldr	r0, [r3, #0]
    afa4:	f000 b802 	b.w	afac <_realloc_r>
    afa8:	1fff1000 	.word	0x1fff1000

0000afac <_realloc_r>:
    afac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    afb0:	4617      	mov	r7, r2
    afb2:	b083      	sub	sp, #12
    afb4:	2900      	cmp	r1, #0
    afb6:	f000 80c1 	beq.w	b13c <_realloc_r+0x190>
    afba:	460e      	mov	r6, r1
    afbc:	4681      	mov	r9, r0
    afbe:	f107 050b 	add.w	r5, r7, #11
    afc2:	f7ff ffe7 	bl	af94 <__malloc_lock>
    afc6:	f856 ec04 	ldr.w	lr, [r6, #-4]
    afca:	2d16      	cmp	r5, #22
    afcc:	f02e 0403 	bic.w	r4, lr, #3
    afd0:	f1a6 0808 	sub.w	r8, r6, #8
    afd4:	d840      	bhi.n	b058 <_realloc_r+0xac>
    afd6:	2210      	movs	r2, #16
    afd8:	4615      	mov	r5, r2
    afda:	42af      	cmp	r7, r5
    afdc:	d841      	bhi.n	b062 <_realloc_r+0xb6>
    afde:	4294      	cmp	r4, r2
    afe0:	da75      	bge.n	b0ce <_realloc_r+0x122>
    afe2:	4bc9      	ldr	r3, [pc, #804]	; (b308 <_realloc_r+0x35c>)
    afe4:	6899      	ldr	r1, [r3, #8]
    afe6:	eb08 0004 	add.w	r0, r8, r4
    afea:	4288      	cmp	r0, r1
    afec:	6841      	ldr	r1, [r0, #4]
    afee:	f000 80d9 	beq.w	b1a4 <_realloc_r+0x1f8>
    aff2:	f021 0301 	bic.w	r3, r1, #1
    aff6:	4403      	add	r3, r0
    aff8:	685b      	ldr	r3, [r3, #4]
    affa:	07db      	lsls	r3, r3, #31
    affc:	d57d      	bpl.n	b0fa <_realloc_r+0x14e>
    affe:	f01e 0f01 	tst.w	lr, #1
    b002:	d035      	beq.n	b070 <_realloc_r+0xc4>
    b004:	4639      	mov	r1, r7
    b006:	4648      	mov	r0, r9
    b008:	f7ff fc5a 	bl	a8c0 <_malloc_r>
    b00c:	4607      	mov	r7, r0
    b00e:	b1e0      	cbz	r0, b04a <_realloc_r+0x9e>
    b010:	f856 3c04 	ldr.w	r3, [r6, #-4]
    b014:	f023 0301 	bic.w	r3, r3, #1
    b018:	4443      	add	r3, r8
    b01a:	f1a0 0208 	sub.w	r2, r0, #8
    b01e:	429a      	cmp	r2, r3
    b020:	f000 8144 	beq.w	b2ac <_realloc_r+0x300>
    b024:	1f22      	subs	r2, r4, #4
    b026:	2a24      	cmp	r2, #36	; 0x24
    b028:	f200 8131 	bhi.w	b28e <_realloc_r+0x2e2>
    b02c:	2a13      	cmp	r2, #19
    b02e:	f200 8104 	bhi.w	b23a <_realloc_r+0x28e>
    b032:	4603      	mov	r3, r0
    b034:	4632      	mov	r2, r6
    b036:	6811      	ldr	r1, [r2, #0]
    b038:	6019      	str	r1, [r3, #0]
    b03a:	6851      	ldr	r1, [r2, #4]
    b03c:	6059      	str	r1, [r3, #4]
    b03e:	6892      	ldr	r2, [r2, #8]
    b040:	609a      	str	r2, [r3, #8]
    b042:	4631      	mov	r1, r6
    b044:	4648      	mov	r0, r9
    b046:	f000 fd01 	bl	ba4c <_free_r>
    b04a:	4648      	mov	r0, r9
    b04c:	f7ff ffa4 	bl	af98 <__malloc_unlock>
    b050:	4638      	mov	r0, r7
    b052:	b003      	add	sp, #12
    b054:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b058:	f025 0507 	bic.w	r5, r5, #7
    b05c:	2d00      	cmp	r5, #0
    b05e:	462a      	mov	r2, r5
    b060:	dabb      	bge.n	afda <_realloc_r+0x2e>
    b062:	230c      	movs	r3, #12
    b064:	2000      	movs	r0, #0
    b066:	f8c9 3000 	str.w	r3, [r9]
    b06a:	b003      	add	sp, #12
    b06c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b070:	f856 3c08 	ldr.w	r3, [r6, #-8]
    b074:	ebc3 0a08 	rsb	sl, r3, r8
    b078:	f8da 3004 	ldr.w	r3, [sl, #4]
    b07c:	f023 0c03 	bic.w	ip, r3, #3
    b080:	eb04 030c 	add.w	r3, r4, ip
    b084:	4293      	cmp	r3, r2
    b086:	dbbd      	blt.n	b004 <_realloc_r+0x58>
    b088:	4657      	mov	r7, sl
    b08a:	f8da 100c 	ldr.w	r1, [sl, #12]
    b08e:	f857 0f08 	ldr.w	r0, [r7, #8]!
    b092:	1f22      	subs	r2, r4, #4
    b094:	2a24      	cmp	r2, #36	; 0x24
    b096:	60c1      	str	r1, [r0, #12]
    b098:	6088      	str	r0, [r1, #8]
    b09a:	f200 8117 	bhi.w	b2cc <_realloc_r+0x320>
    b09e:	2a13      	cmp	r2, #19
    b0a0:	f240 8112 	bls.w	b2c8 <_realloc_r+0x31c>
    b0a4:	6831      	ldr	r1, [r6, #0]
    b0a6:	f8ca 1008 	str.w	r1, [sl, #8]
    b0aa:	6871      	ldr	r1, [r6, #4]
    b0ac:	f8ca 100c 	str.w	r1, [sl, #12]
    b0b0:	2a1b      	cmp	r2, #27
    b0b2:	f200 812b 	bhi.w	b30c <_realloc_r+0x360>
    b0b6:	3608      	adds	r6, #8
    b0b8:	f10a 0210 	add.w	r2, sl, #16
    b0bc:	6831      	ldr	r1, [r6, #0]
    b0be:	6011      	str	r1, [r2, #0]
    b0c0:	6871      	ldr	r1, [r6, #4]
    b0c2:	6051      	str	r1, [r2, #4]
    b0c4:	68b1      	ldr	r1, [r6, #8]
    b0c6:	6091      	str	r1, [r2, #8]
    b0c8:	463e      	mov	r6, r7
    b0ca:	461c      	mov	r4, r3
    b0cc:	46d0      	mov	r8, sl
    b0ce:	1b63      	subs	r3, r4, r5
    b0d0:	2b0f      	cmp	r3, #15
    b0d2:	d81d      	bhi.n	b110 <_realloc_r+0x164>
    b0d4:	f8d8 3004 	ldr.w	r3, [r8, #4]
    b0d8:	f003 0301 	and.w	r3, r3, #1
    b0dc:	4323      	orrs	r3, r4
    b0de:	4444      	add	r4, r8
    b0e0:	f8c8 3004 	str.w	r3, [r8, #4]
    b0e4:	6863      	ldr	r3, [r4, #4]
    b0e6:	f043 0301 	orr.w	r3, r3, #1
    b0ea:	6063      	str	r3, [r4, #4]
    b0ec:	4648      	mov	r0, r9
    b0ee:	f7ff ff53 	bl	af98 <__malloc_unlock>
    b0f2:	4630      	mov	r0, r6
    b0f4:	b003      	add	sp, #12
    b0f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b0fa:	f021 0103 	bic.w	r1, r1, #3
    b0fe:	4421      	add	r1, r4
    b100:	4291      	cmp	r1, r2
    b102:	db21      	blt.n	b148 <_realloc_r+0x19c>
    b104:	68c3      	ldr	r3, [r0, #12]
    b106:	6882      	ldr	r2, [r0, #8]
    b108:	460c      	mov	r4, r1
    b10a:	60d3      	str	r3, [r2, #12]
    b10c:	609a      	str	r2, [r3, #8]
    b10e:	e7de      	b.n	b0ce <_realloc_r+0x122>
    b110:	f8d8 2004 	ldr.w	r2, [r8, #4]
    b114:	eb08 0105 	add.w	r1, r8, r5
    b118:	f002 0201 	and.w	r2, r2, #1
    b11c:	4315      	orrs	r5, r2
    b11e:	f043 0201 	orr.w	r2, r3, #1
    b122:	440b      	add	r3, r1
    b124:	f8c8 5004 	str.w	r5, [r8, #4]
    b128:	604a      	str	r2, [r1, #4]
    b12a:	685a      	ldr	r2, [r3, #4]
    b12c:	f042 0201 	orr.w	r2, r2, #1
    b130:	3108      	adds	r1, #8
    b132:	605a      	str	r2, [r3, #4]
    b134:	4648      	mov	r0, r9
    b136:	f000 fc89 	bl	ba4c <_free_r>
    b13a:	e7d7      	b.n	b0ec <_realloc_r+0x140>
    b13c:	4611      	mov	r1, r2
    b13e:	b003      	add	sp, #12
    b140:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b144:	f7ff bbbc 	b.w	a8c0 <_malloc_r>
    b148:	f01e 0f01 	tst.w	lr, #1
    b14c:	f47f af5a 	bne.w	b004 <_realloc_r+0x58>
    b150:	f856 3c08 	ldr.w	r3, [r6, #-8]
    b154:	ebc3 0a08 	rsb	sl, r3, r8
    b158:	f8da 3004 	ldr.w	r3, [sl, #4]
    b15c:	f023 0c03 	bic.w	ip, r3, #3
    b160:	eb01 0e0c 	add.w	lr, r1, ip
    b164:	4596      	cmp	lr, r2
    b166:	db8b      	blt.n	b080 <_realloc_r+0xd4>
    b168:	68c3      	ldr	r3, [r0, #12]
    b16a:	6882      	ldr	r2, [r0, #8]
    b16c:	4657      	mov	r7, sl
    b16e:	60d3      	str	r3, [r2, #12]
    b170:	609a      	str	r2, [r3, #8]
    b172:	f857 1f08 	ldr.w	r1, [r7, #8]!
    b176:	f8da 300c 	ldr.w	r3, [sl, #12]
    b17a:	60cb      	str	r3, [r1, #12]
    b17c:	1f22      	subs	r2, r4, #4
    b17e:	2a24      	cmp	r2, #36	; 0x24
    b180:	6099      	str	r1, [r3, #8]
    b182:	f200 8099 	bhi.w	b2b8 <_realloc_r+0x30c>
    b186:	2a13      	cmp	r2, #19
    b188:	d962      	bls.n	b250 <_realloc_r+0x2a4>
    b18a:	6833      	ldr	r3, [r6, #0]
    b18c:	f8ca 3008 	str.w	r3, [sl, #8]
    b190:	6873      	ldr	r3, [r6, #4]
    b192:	f8ca 300c 	str.w	r3, [sl, #12]
    b196:	2a1b      	cmp	r2, #27
    b198:	f200 80a0 	bhi.w	b2dc <_realloc_r+0x330>
    b19c:	3608      	adds	r6, #8
    b19e:	f10a 0310 	add.w	r3, sl, #16
    b1a2:	e056      	b.n	b252 <_realloc_r+0x2a6>
    b1a4:	f021 0b03 	bic.w	fp, r1, #3
    b1a8:	44a3      	add	fp, r4
    b1aa:	f105 0010 	add.w	r0, r5, #16
    b1ae:	4583      	cmp	fp, r0
    b1b0:	da59      	bge.n	b266 <_realloc_r+0x2ba>
    b1b2:	f01e 0f01 	tst.w	lr, #1
    b1b6:	f47f af25 	bne.w	b004 <_realloc_r+0x58>
    b1ba:	f856 1c08 	ldr.w	r1, [r6, #-8]
    b1be:	ebc1 0a08 	rsb	sl, r1, r8
    b1c2:	f8da 1004 	ldr.w	r1, [sl, #4]
    b1c6:	f021 0c03 	bic.w	ip, r1, #3
    b1ca:	44e3      	add	fp, ip
    b1cc:	4558      	cmp	r0, fp
    b1ce:	f73f af57 	bgt.w	b080 <_realloc_r+0xd4>
    b1d2:	4657      	mov	r7, sl
    b1d4:	f8da 100c 	ldr.w	r1, [sl, #12]
    b1d8:	f857 0f08 	ldr.w	r0, [r7, #8]!
    b1dc:	1f22      	subs	r2, r4, #4
    b1de:	2a24      	cmp	r2, #36	; 0x24
    b1e0:	60c1      	str	r1, [r0, #12]
    b1e2:	6088      	str	r0, [r1, #8]
    b1e4:	f200 80b4 	bhi.w	b350 <_realloc_r+0x3a4>
    b1e8:	2a13      	cmp	r2, #19
    b1ea:	f240 80a5 	bls.w	b338 <_realloc_r+0x38c>
    b1ee:	6831      	ldr	r1, [r6, #0]
    b1f0:	f8ca 1008 	str.w	r1, [sl, #8]
    b1f4:	6871      	ldr	r1, [r6, #4]
    b1f6:	f8ca 100c 	str.w	r1, [sl, #12]
    b1fa:	2a1b      	cmp	r2, #27
    b1fc:	f200 80af 	bhi.w	b35e <_realloc_r+0x3b2>
    b200:	3608      	adds	r6, #8
    b202:	f10a 0210 	add.w	r2, sl, #16
    b206:	6831      	ldr	r1, [r6, #0]
    b208:	6011      	str	r1, [r2, #0]
    b20a:	6871      	ldr	r1, [r6, #4]
    b20c:	6051      	str	r1, [r2, #4]
    b20e:	68b1      	ldr	r1, [r6, #8]
    b210:	6091      	str	r1, [r2, #8]
    b212:	eb0a 0105 	add.w	r1, sl, r5
    b216:	ebc5 020b 	rsb	r2, r5, fp
    b21a:	f042 0201 	orr.w	r2, r2, #1
    b21e:	6099      	str	r1, [r3, #8]
    b220:	604a      	str	r2, [r1, #4]
    b222:	f8da 3004 	ldr.w	r3, [sl, #4]
    b226:	f003 0301 	and.w	r3, r3, #1
    b22a:	431d      	orrs	r5, r3
    b22c:	4648      	mov	r0, r9
    b22e:	f8ca 5004 	str.w	r5, [sl, #4]
    b232:	f7ff feb1 	bl	af98 <__malloc_unlock>
    b236:	4638      	mov	r0, r7
    b238:	e75c      	b.n	b0f4 <_realloc_r+0x148>
    b23a:	6833      	ldr	r3, [r6, #0]
    b23c:	6003      	str	r3, [r0, #0]
    b23e:	6873      	ldr	r3, [r6, #4]
    b240:	6043      	str	r3, [r0, #4]
    b242:	2a1b      	cmp	r2, #27
    b244:	d827      	bhi.n	b296 <_realloc_r+0x2ea>
    b246:	f100 0308 	add.w	r3, r0, #8
    b24a:	f106 0208 	add.w	r2, r6, #8
    b24e:	e6f2      	b.n	b036 <_realloc_r+0x8a>
    b250:	463b      	mov	r3, r7
    b252:	6832      	ldr	r2, [r6, #0]
    b254:	601a      	str	r2, [r3, #0]
    b256:	6872      	ldr	r2, [r6, #4]
    b258:	605a      	str	r2, [r3, #4]
    b25a:	68b2      	ldr	r2, [r6, #8]
    b25c:	609a      	str	r2, [r3, #8]
    b25e:	463e      	mov	r6, r7
    b260:	4674      	mov	r4, lr
    b262:	46d0      	mov	r8, sl
    b264:	e733      	b.n	b0ce <_realloc_r+0x122>
    b266:	eb08 0105 	add.w	r1, r8, r5
    b26a:	ebc5 0b0b 	rsb	fp, r5, fp
    b26e:	f04b 0201 	orr.w	r2, fp, #1
    b272:	6099      	str	r1, [r3, #8]
    b274:	604a      	str	r2, [r1, #4]
    b276:	f856 3c04 	ldr.w	r3, [r6, #-4]
    b27a:	f003 0301 	and.w	r3, r3, #1
    b27e:	431d      	orrs	r5, r3
    b280:	4648      	mov	r0, r9
    b282:	f846 5c04 	str.w	r5, [r6, #-4]
    b286:	f7ff fe87 	bl	af98 <__malloc_unlock>
    b28a:	4630      	mov	r0, r6
    b28c:	e732      	b.n	b0f4 <_realloc_r+0x148>
    b28e:	4631      	mov	r1, r6
    b290:	f7ff fdce 	bl	ae30 <memmove>
    b294:	e6d5      	b.n	b042 <_realloc_r+0x96>
    b296:	68b3      	ldr	r3, [r6, #8]
    b298:	6083      	str	r3, [r0, #8]
    b29a:	68f3      	ldr	r3, [r6, #12]
    b29c:	60c3      	str	r3, [r0, #12]
    b29e:	2a24      	cmp	r2, #36	; 0x24
    b2a0:	d028      	beq.n	b2f4 <_realloc_r+0x348>
    b2a2:	f100 0310 	add.w	r3, r0, #16
    b2a6:	f106 0210 	add.w	r2, r6, #16
    b2aa:	e6c4      	b.n	b036 <_realloc_r+0x8a>
    b2ac:	f850 3c04 	ldr.w	r3, [r0, #-4]
    b2b0:	f023 0303 	bic.w	r3, r3, #3
    b2b4:	441c      	add	r4, r3
    b2b6:	e70a      	b.n	b0ce <_realloc_r+0x122>
    b2b8:	4631      	mov	r1, r6
    b2ba:	4638      	mov	r0, r7
    b2bc:	4674      	mov	r4, lr
    b2be:	46d0      	mov	r8, sl
    b2c0:	f7ff fdb6 	bl	ae30 <memmove>
    b2c4:	463e      	mov	r6, r7
    b2c6:	e702      	b.n	b0ce <_realloc_r+0x122>
    b2c8:	463a      	mov	r2, r7
    b2ca:	e6f7      	b.n	b0bc <_realloc_r+0x110>
    b2cc:	4631      	mov	r1, r6
    b2ce:	4638      	mov	r0, r7
    b2d0:	461c      	mov	r4, r3
    b2d2:	46d0      	mov	r8, sl
    b2d4:	f7ff fdac 	bl	ae30 <memmove>
    b2d8:	463e      	mov	r6, r7
    b2da:	e6f8      	b.n	b0ce <_realloc_r+0x122>
    b2dc:	68b3      	ldr	r3, [r6, #8]
    b2de:	f8ca 3010 	str.w	r3, [sl, #16]
    b2e2:	68f3      	ldr	r3, [r6, #12]
    b2e4:	f8ca 3014 	str.w	r3, [sl, #20]
    b2e8:	2a24      	cmp	r2, #36	; 0x24
    b2ea:	d01b      	beq.n	b324 <_realloc_r+0x378>
    b2ec:	3610      	adds	r6, #16
    b2ee:	f10a 0318 	add.w	r3, sl, #24
    b2f2:	e7ae      	b.n	b252 <_realloc_r+0x2a6>
    b2f4:	6933      	ldr	r3, [r6, #16]
    b2f6:	6103      	str	r3, [r0, #16]
    b2f8:	6973      	ldr	r3, [r6, #20]
    b2fa:	6143      	str	r3, [r0, #20]
    b2fc:	f106 0218 	add.w	r2, r6, #24
    b300:	f100 0318 	add.w	r3, r0, #24
    b304:	e697      	b.n	b036 <_realloc_r+0x8a>
    b306:	bf00      	nop
    b308:	1fff1004 	.word	0x1fff1004
    b30c:	68b1      	ldr	r1, [r6, #8]
    b30e:	f8ca 1010 	str.w	r1, [sl, #16]
    b312:	68f1      	ldr	r1, [r6, #12]
    b314:	f8ca 1014 	str.w	r1, [sl, #20]
    b318:	2a24      	cmp	r2, #36	; 0x24
    b31a:	d00f      	beq.n	b33c <_realloc_r+0x390>
    b31c:	3610      	adds	r6, #16
    b31e:	f10a 0218 	add.w	r2, sl, #24
    b322:	e6cb      	b.n	b0bc <_realloc_r+0x110>
    b324:	6933      	ldr	r3, [r6, #16]
    b326:	f8ca 3018 	str.w	r3, [sl, #24]
    b32a:	6973      	ldr	r3, [r6, #20]
    b32c:	f8ca 301c 	str.w	r3, [sl, #28]
    b330:	3618      	adds	r6, #24
    b332:	f10a 0320 	add.w	r3, sl, #32
    b336:	e78c      	b.n	b252 <_realloc_r+0x2a6>
    b338:	463a      	mov	r2, r7
    b33a:	e764      	b.n	b206 <_realloc_r+0x25a>
    b33c:	6932      	ldr	r2, [r6, #16]
    b33e:	f8ca 2018 	str.w	r2, [sl, #24]
    b342:	6972      	ldr	r2, [r6, #20]
    b344:	f8ca 201c 	str.w	r2, [sl, #28]
    b348:	3618      	adds	r6, #24
    b34a:	f10a 0220 	add.w	r2, sl, #32
    b34e:	e6b5      	b.n	b0bc <_realloc_r+0x110>
    b350:	4631      	mov	r1, r6
    b352:	4638      	mov	r0, r7
    b354:	9301      	str	r3, [sp, #4]
    b356:	f7ff fd6b 	bl	ae30 <memmove>
    b35a:	9b01      	ldr	r3, [sp, #4]
    b35c:	e759      	b.n	b212 <_realloc_r+0x266>
    b35e:	68b1      	ldr	r1, [r6, #8]
    b360:	f8ca 1010 	str.w	r1, [sl, #16]
    b364:	68f1      	ldr	r1, [r6, #12]
    b366:	f8ca 1014 	str.w	r1, [sl, #20]
    b36a:	2a24      	cmp	r2, #36	; 0x24
    b36c:	d003      	beq.n	b376 <_realloc_r+0x3ca>
    b36e:	3610      	adds	r6, #16
    b370:	f10a 0218 	add.w	r2, sl, #24
    b374:	e747      	b.n	b206 <_realloc_r+0x25a>
    b376:	6932      	ldr	r2, [r6, #16]
    b378:	f8ca 2018 	str.w	r2, [sl, #24]
    b37c:	6972      	ldr	r2, [r6, #20]
    b37e:	f8ca 201c 	str.w	r2, [sl, #28]
    b382:	3618      	adds	r6, #24
    b384:	f10a 0220 	add.w	r2, sl, #32
    b388:	e73d      	b.n	b206 <_realloc_r+0x25a>
    b38a:	bf00      	nop

0000b38c <_sbrk_r>:
    b38c:	b538      	push	{r3, r4, r5, lr}
    b38e:	4c07      	ldr	r4, [pc, #28]	; (b3ac <_sbrk_r+0x20>)
    b390:	2300      	movs	r3, #0
    b392:	4605      	mov	r5, r0
    b394:	4608      	mov	r0, r1
    b396:	6023      	str	r3, [r4, #0]
    b398:	f7fb f954 	bl	6644 <_sbrk>
    b39c:	1c43      	adds	r3, r0, #1
    b39e:	d000      	beq.n	b3a2 <_sbrk_r+0x16>
    b3a0:	bd38      	pop	{r3, r4, r5, pc}
    b3a2:	6823      	ldr	r3, [r4, #0]
    b3a4:	2b00      	cmp	r3, #0
    b3a6:	d0fb      	beq.n	b3a0 <_sbrk_r+0x14>
    b3a8:	602b      	str	r3, [r5, #0]
    b3aa:	bd38      	pop	{r3, r4, r5, pc}
    b3ac:	1fff2d7c 	.word	0x1fff2d7c
    b3b0:	ffffffff 	.word	0xffffffff
    b3b4:	ffffffff 	.word	0xffffffff
    b3b8:	ffffffff 	.word	0xffffffff
    b3bc:	ffffffff 	.word	0xffffffff
    b3c0:	eba2 0003 	sub.w	r0, r2, r3
    b3c4:	4770      	bx	lr
    b3c6:	bf00      	nop

0000b3c8 <strcmp>:
    b3c8:	7802      	ldrb	r2, [r0, #0]
    b3ca:	780b      	ldrb	r3, [r1, #0]
    b3cc:	2a01      	cmp	r2, #1
    b3ce:	bf28      	it	cs
    b3d0:	429a      	cmpcs	r2, r3
    b3d2:	d1f5      	bne.n	b3c0 <_sbrk_r+0x34>
    b3d4:	e96d 4504 	strd	r4, r5, [sp, #-16]!
    b3d8:	ea40 0401 	orr.w	r4, r0, r1
    b3dc:	e9cd 6702 	strd	r6, r7, [sp, #8]
    b3e0:	f06f 0c00 	mvn.w	ip, #0
    b3e4:	ea4f 7244 	mov.w	r2, r4, lsl #29
    b3e8:	b312      	cbz	r2, b430 <strcmp+0x68>
    b3ea:	ea80 0401 	eor.w	r4, r0, r1
    b3ee:	f014 0f07 	tst.w	r4, #7
    b3f2:	d16a      	bne.n	b4ca <strcmp+0x102>
    b3f4:	f000 0407 	and.w	r4, r0, #7
    b3f8:	f020 0007 	bic.w	r0, r0, #7
    b3fc:	f004 0503 	and.w	r5, r4, #3
    b400:	f021 0107 	bic.w	r1, r1, #7
    b404:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    b408:	e8f0 2304 	ldrd	r2, r3, [r0], #16
    b40c:	f014 0f04 	tst.w	r4, #4
    b410:	e8f1 6704 	ldrd	r6, r7, [r1], #16
    b414:	fa0c f405 	lsl.w	r4, ip, r5
    b418:	ea62 0204 	orn	r2, r2, r4
    b41c:	ea66 0604 	orn	r6, r6, r4
    b420:	d00a      	beq.n	b438 <strcmp+0x70>
    b422:	ea63 0304 	orn	r3, r3, r4
    b426:	4662      	mov	r2, ip
    b428:	ea67 0704 	orn	r7, r7, r4
    b42c:	4666      	mov	r6, ip
    b42e:	e003      	b.n	b438 <strcmp+0x70>
    b430:	e8f0 2304 	ldrd	r2, r3, [r0], #16
    b434:	e8f1 6704 	ldrd	r6, r7, [r1], #16
    b438:	fa82 f54c 	uadd8	r5, r2, ip
    b43c:	ea82 0406 	eor.w	r4, r2, r6
    b440:	faa4 f48c 	sel	r4, r4, ip
    b444:	bb6c      	cbnz	r4, b4a2 <strcmp+0xda>
    b446:	fa83 f54c 	uadd8	r5, r3, ip
    b44a:	ea83 0507 	eor.w	r5, r3, r7
    b44e:	faa5 f58c 	sel	r5, r5, ip
    b452:	b995      	cbnz	r5, b47a <strcmp+0xb2>
    b454:	e950 2302 	ldrd	r2, r3, [r0, #-8]
    b458:	e951 6702 	ldrd	r6, r7, [r1, #-8]
    b45c:	fa82 f54c 	uadd8	r5, r2, ip
    b460:	ea82 0406 	eor.w	r4, r2, r6
    b464:	faa4 f48c 	sel	r4, r4, ip
    b468:	fa83 f54c 	uadd8	r5, r3, ip
    b46c:	ea83 0507 	eor.w	r5, r3, r7
    b470:	faa5 f58c 	sel	r5, r5, ip
    b474:	4325      	orrs	r5, r4
    b476:	d0db      	beq.n	b430 <strcmp+0x68>
    b478:	b99c      	cbnz	r4, b4a2 <strcmp+0xda>
    b47a:	ba2d      	rev	r5, r5
    b47c:	fab5 f485 	clz	r4, r5
    b480:	f024 0407 	bic.w	r4, r4, #7
    b484:	fa27 f104 	lsr.w	r1, r7, r4
    b488:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    b48c:	fa23 f304 	lsr.w	r3, r3, r4
    b490:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    b494:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    b498:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    b49c:	eba0 0001 	sub.w	r0, r0, r1
    b4a0:	4770      	bx	lr
    b4a2:	ba24      	rev	r4, r4
    b4a4:	fab4 f484 	clz	r4, r4
    b4a8:	f024 0407 	bic.w	r4, r4, #7
    b4ac:	fa26 f104 	lsr.w	r1, r6, r4
    b4b0:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    b4b4:	fa22 f204 	lsr.w	r2, r2, r4
    b4b8:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    b4bc:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    b4c0:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    b4c4:	eba0 0001 	sub.w	r0, r0, r1
    b4c8:	4770      	bx	lr
    b4ca:	f014 0f03 	tst.w	r4, #3
    b4ce:	d13c      	bne.n	b54a <strcmp+0x182>
    b4d0:	f010 0403 	ands.w	r4, r0, #3
    b4d4:	d128      	bne.n	b528 <strcmp+0x160>
    b4d6:	f850 2b08 	ldr.w	r2, [r0], #8
    b4da:	f851 3b08 	ldr.w	r3, [r1], #8
    b4de:	fa82 f54c 	uadd8	r5, r2, ip
    b4e2:	ea82 0503 	eor.w	r5, r2, r3
    b4e6:	faa5 f58c 	sel	r5, r5, ip
    b4ea:	b95d      	cbnz	r5, b504 <strcmp+0x13c>
    b4ec:	f850 2c04 	ldr.w	r2, [r0, #-4]
    b4f0:	f851 3c04 	ldr.w	r3, [r1, #-4]
    b4f4:	fa82 f54c 	uadd8	r5, r2, ip
    b4f8:	ea82 0503 	eor.w	r5, r2, r3
    b4fc:	faa5 f58c 	sel	r5, r5, ip
    b500:	2d00      	cmp	r5, #0
    b502:	d0e8      	beq.n	b4d6 <strcmp+0x10e>
    b504:	ba2d      	rev	r5, r5
    b506:	fab5 f485 	clz	r4, r5
    b50a:	f024 0407 	bic.w	r4, r4, #7
    b50e:	fa23 f104 	lsr.w	r1, r3, r4
    b512:	fa22 f204 	lsr.w	r2, r2, r4
    b516:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    b51a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    b51e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    b522:	eba0 0001 	sub.w	r0, r0, r1
    b526:	4770      	bx	lr
    b528:	ea4f 04c4 	mov.w	r4, r4, lsl #3
    b52c:	f020 0003 	bic.w	r0, r0, #3
    b530:	f850 2b08 	ldr.w	r2, [r0], #8
    b534:	f021 0103 	bic.w	r1, r1, #3
    b538:	f851 3b08 	ldr.w	r3, [r1], #8
    b53c:	fa0c f404 	lsl.w	r4, ip, r4
    b540:	ea62 0204 	orn	r2, r2, r4
    b544:	ea63 0304 	orn	r3, r3, r4
    b548:	e7c9      	b.n	b4de <strcmp+0x116>
    b54a:	f010 0403 	ands.w	r4, r0, #3
    b54e:	d01a      	beq.n	b586 <strcmp+0x1be>
    b550:	eba1 0104 	sub.w	r1, r1, r4
    b554:	f020 0003 	bic.w	r0, r0, #3
    b558:	07e4      	lsls	r4, r4, #31
    b55a:	f850 2b04 	ldr.w	r2, [r0], #4
    b55e:	d006      	beq.n	b56e <strcmp+0x1a6>
    b560:	d20f      	bcs.n	b582 <strcmp+0x1ba>
    b562:	788b      	ldrb	r3, [r1, #2]
    b564:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
    b568:	1ae4      	subs	r4, r4, r3
    b56a:	d106      	bne.n	b57a <strcmp+0x1b2>
    b56c:	b12b      	cbz	r3, b57a <strcmp+0x1b2>
    b56e:	78cb      	ldrb	r3, [r1, #3]
    b570:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
    b574:	1ae4      	subs	r4, r4, r3
    b576:	d100      	bne.n	b57a <strcmp+0x1b2>
    b578:	b91b      	cbnz	r3, b582 <strcmp+0x1ba>
    b57a:	4620      	mov	r0, r4
    b57c:	f85d 4b10 	ldr.w	r4, [sp], #16
    b580:	4770      	bx	lr
    b582:	f101 0104 	add.w	r1, r1, #4
    b586:	f850 2b04 	ldr.w	r2, [r0], #4
    b58a:	07cc      	lsls	r4, r1, #31
    b58c:	f021 0103 	bic.w	r1, r1, #3
    b590:	f851 3b04 	ldr.w	r3, [r1], #4
    b594:	d848      	bhi.n	b628 <strcmp+0x260>
    b596:	d224      	bcs.n	b5e2 <strcmp+0x21a>
    b598:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
    b59c:	fa82 f54c 	uadd8	r5, r2, ip
    b5a0:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
    b5a4:	faa5 f58c 	sel	r5, r5, ip
    b5a8:	d10a      	bne.n	b5c0 <strcmp+0x1f8>
    b5aa:	b965      	cbnz	r5, b5c6 <strcmp+0x1fe>
    b5ac:	f851 3b04 	ldr.w	r3, [r1], #4
    b5b0:	ea84 0402 	eor.w	r4, r4, r2
    b5b4:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
    b5b8:	d10e      	bne.n	b5d8 <strcmp+0x210>
    b5ba:	f850 2b04 	ldr.w	r2, [r0], #4
    b5be:	e7eb      	b.n	b598 <strcmp+0x1d0>
    b5c0:	ea4f 2313 	mov.w	r3, r3, lsr #8
    b5c4:	e055      	b.n	b672 <strcmp+0x2aa>
    b5c6:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
    b5ca:	d14d      	bne.n	b668 <strcmp+0x2a0>
    b5cc:	7808      	ldrb	r0, [r1, #0]
    b5ce:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    b5d2:	f1c0 0000 	rsb	r0, r0, #0
    b5d6:	4770      	bx	lr
    b5d8:	ea4f 6212 	mov.w	r2, r2, lsr #24
    b5dc:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    b5e0:	e047      	b.n	b672 <strcmp+0x2aa>
    b5e2:	ea02 441c 	and.w	r4, r2, ip, lsr #16
    b5e6:	fa82 f54c 	uadd8	r5, r2, ip
    b5ea:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
    b5ee:	faa5 f58c 	sel	r5, r5, ip
    b5f2:	d10a      	bne.n	b60a <strcmp+0x242>
    b5f4:	b965      	cbnz	r5, b610 <strcmp+0x248>
    b5f6:	f851 3b04 	ldr.w	r3, [r1], #4
    b5fa:	ea84 0402 	eor.w	r4, r4, r2
    b5fe:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
    b602:	d10c      	bne.n	b61e <strcmp+0x256>
    b604:	f850 2b04 	ldr.w	r2, [r0], #4
    b608:	e7eb      	b.n	b5e2 <strcmp+0x21a>
    b60a:	ea4f 4313 	mov.w	r3, r3, lsr #16
    b60e:	e030      	b.n	b672 <strcmp+0x2aa>
    b610:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
    b614:	d128      	bne.n	b668 <strcmp+0x2a0>
    b616:	880b      	ldrh	r3, [r1, #0]
    b618:	ea4f 4212 	mov.w	r2, r2, lsr #16
    b61c:	e029      	b.n	b672 <strcmp+0x2aa>
    b61e:	ea4f 4212 	mov.w	r2, r2, lsr #16
    b622:	ea03 431c 	and.w	r3, r3, ip, lsr #16
    b626:	e024      	b.n	b672 <strcmp+0x2aa>
    b628:	f002 04ff 	and.w	r4, r2, #255	; 0xff
    b62c:	fa82 f54c 	uadd8	r5, r2, ip
    b630:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
    b634:	faa5 f58c 	sel	r5, r5, ip
    b638:	d10a      	bne.n	b650 <strcmp+0x288>
    b63a:	b965      	cbnz	r5, b656 <strcmp+0x28e>
    b63c:	f851 3b04 	ldr.w	r3, [r1], #4
    b640:	ea84 0402 	eor.w	r4, r4, r2
    b644:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
    b648:	d109      	bne.n	b65e <strcmp+0x296>
    b64a:	f850 2b04 	ldr.w	r2, [r0], #4
    b64e:	e7eb      	b.n	b628 <strcmp+0x260>
    b650:	ea4f 6313 	mov.w	r3, r3, lsr #24
    b654:	e00d      	b.n	b672 <strcmp+0x2aa>
    b656:	f015 0fff 	tst.w	r5, #255	; 0xff
    b65a:	d105      	bne.n	b668 <strcmp+0x2a0>
    b65c:	680b      	ldr	r3, [r1, #0]
    b65e:	ea4f 2212 	mov.w	r2, r2, lsr #8
    b662:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    b666:	e004      	b.n	b672 <strcmp+0x2aa>
    b668:	f04f 0000 	mov.w	r0, #0
    b66c:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    b670:	4770      	bx	lr
    b672:	ba12      	rev	r2, r2
    b674:	ba1b      	rev	r3, r3
    b676:	fa82 f44c 	uadd8	r4, r2, ip
    b67a:	ea82 0403 	eor.w	r4, r2, r3
    b67e:	faa4 f58c 	sel	r5, r4, ip
    b682:	fab5 f485 	clz	r4, r5
    b686:	fa02 f204 	lsl.w	r2, r2, r4
    b68a:	fa03 f304 	lsl.w	r3, r3, r4
    b68e:	ea4f 6012 	mov.w	r0, r2, lsr #24
    b692:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    b696:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
    b69a:	4770      	bx	lr

0000b69c <strcpy>:
    b69c:	ea80 0201 	eor.w	r2, r0, r1
    b6a0:	4684      	mov	ip, r0
    b6a2:	f012 0f03 	tst.w	r2, #3
    b6a6:	d14f      	bne.n	b748 <strcpy+0xac>
    b6a8:	f011 0f03 	tst.w	r1, #3
    b6ac:	d132      	bne.n	b714 <strcpy+0x78>
    b6ae:	f84d 4d04 	str.w	r4, [sp, #-4]!
    b6b2:	f011 0f04 	tst.w	r1, #4
    b6b6:	f851 3b04 	ldr.w	r3, [r1], #4
    b6ba:	d00b      	beq.n	b6d4 <strcpy+0x38>
    b6bc:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    b6c0:	439a      	bics	r2, r3
    b6c2:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    b6c6:	bf04      	itt	eq
    b6c8:	f84c 3b04 	streq.w	r3, [ip], #4
    b6cc:	f851 3b04 	ldreq.w	r3, [r1], #4
    b6d0:	d116      	bne.n	b700 <strcpy+0x64>
    b6d2:	bf00      	nop
    b6d4:	f851 4b04 	ldr.w	r4, [r1], #4
    b6d8:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    b6dc:	439a      	bics	r2, r3
    b6de:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    b6e2:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
    b6e6:	d10b      	bne.n	b700 <strcpy+0x64>
    b6e8:	f84c 3b04 	str.w	r3, [ip], #4
    b6ec:	43a2      	bics	r2, r4
    b6ee:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    b6f2:	bf04      	itt	eq
    b6f4:	f851 3b04 	ldreq.w	r3, [r1], #4
    b6f8:	f84c 4b04 	streq.w	r4, [ip], #4
    b6fc:	d0ea      	beq.n	b6d4 <strcpy+0x38>
    b6fe:	4623      	mov	r3, r4
    b700:	f80c 3b01 	strb.w	r3, [ip], #1
    b704:	f013 0fff 	tst.w	r3, #255	; 0xff
    b708:	ea4f 2333 	mov.w	r3, r3, ror #8
    b70c:	d1f8      	bne.n	b700 <strcpy+0x64>
    b70e:	f85d 4b04 	ldr.w	r4, [sp], #4
    b712:	4770      	bx	lr
    b714:	f011 0f01 	tst.w	r1, #1
    b718:	d006      	beq.n	b728 <strcpy+0x8c>
    b71a:	f811 2b01 	ldrb.w	r2, [r1], #1
    b71e:	f80c 2b01 	strb.w	r2, [ip], #1
    b722:	2a00      	cmp	r2, #0
    b724:	bf08      	it	eq
    b726:	4770      	bxeq	lr
    b728:	f011 0f02 	tst.w	r1, #2
    b72c:	d0bf      	beq.n	b6ae <strcpy+0x12>
    b72e:	f831 2b02 	ldrh.w	r2, [r1], #2
    b732:	f012 0fff 	tst.w	r2, #255	; 0xff
    b736:	bf16      	itet	ne
    b738:	f82c 2b02 	strhne.w	r2, [ip], #2
    b73c:	f88c 2000 	strbeq.w	r2, [ip]
    b740:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
    b744:	d1b3      	bne.n	b6ae <strcpy+0x12>
    b746:	4770      	bx	lr
    b748:	f811 2b01 	ldrb.w	r2, [r1], #1
    b74c:	f80c 2b01 	strb.w	r2, [ip], #1
    b750:	2a00      	cmp	r2, #0
    b752:	d1f9      	bne.n	b748 <strcpy+0xac>
    b754:	4770      	bx	lr
    b756:	bf00      	nop
    b758:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    b75c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    b760:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    b764:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    b768:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    b76c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    b770:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    b774:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    b778:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    b77c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

0000b780 <strlen>:
    b780:	f890 f000 	pld	[r0]
    b784:	e96d 4502 	strd	r4, r5, [sp, #-8]!
    b788:	f020 0107 	bic.w	r1, r0, #7
    b78c:	f06f 0c00 	mvn.w	ip, #0
    b790:	f010 0407 	ands.w	r4, r0, #7
    b794:	f891 f020 	pld	[r1, #32]
    b798:	f040 8049 	bne.w	b82e <strlen+0xae>
    b79c:	f04f 0400 	mov.w	r4, #0
    b7a0:	f06f 0007 	mvn.w	r0, #7
    b7a4:	e9d1 2300 	ldrd	r2, r3, [r1]
    b7a8:	f891 f040 	pld	[r1, #64]	; 0x40
    b7ac:	f100 0008 	add.w	r0, r0, #8
    b7b0:	fa82 f24c 	uadd8	r2, r2, ip
    b7b4:	faa4 f28c 	sel	r2, r4, ip
    b7b8:	fa83 f34c 	uadd8	r3, r3, ip
    b7bc:	faa2 f38c 	sel	r3, r2, ip
    b7c0:	bb4b      	cbnz	r3, b816 <strlen+0x96>
    b7c2:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
    b7c6:	fa82 f24c 	uadd8	r2, r2, ip
    b7ca:	f100 0008 	add.w	r0, r0, #8
    b7ce:	faa4 f28c 	sel	r2, r4, ip
    b7d2:	fa83 f34c 	uadd8	r3, r3, ip
    b7d6:	faa2 f38c 	sel	r3, r2, ip
    b7da:	b9e3      	cbnz	r3, b816 <strlen+0x96>
    b7dc:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
    b7e0:	fa82 f24c 	uadd8	r2, r2, ip
    b7e4:	f100 0008 	add.w	r0, r0, #8
    b7e8:	faa4 f28c 	sel	r2, r4, ip
    b7ec:	fa83 f34c 	uadd8	r3, r3, ip
    b7f0:	faa2 f38c 	sel	r3, r2, ip
    b7f4:	b97b      	cbnz	r3, b816 <strlen+0x96>
    b7f6:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
    b7fa:	f101 0120 	add.w	r1, r1, #32
    b7fe:	fa82 f24c 	uadd8	r2, r2, ip
    b802:	f100 0008 	add.w	r0, r0, #8
    b806:	faa4 f28c 	sel	r2, r4, ip
    b80a:	fa83 f34c 	uadd8	r3, r3, ip
    b80e:	faa2 f38c 	sel	r3, r2, ip
    b812:	2b00      	cmp	r3, #0
    b814:	d0c6      	beq.n	b7a4 <strlen+0x24>
    b816:	2a00      	cmp	r2, #0
    b818:	bf04      	itt	eq
    b81a:	3004      	addeq	r0, #4
    b81c:	461a      	moveq	r2, r3
    b81e:	ba12      	rev	r2, r2
    b820:	fab2 f282 	clz	r2, r2
    b824:	e8fd 4502 	ldrd	r4, r5, [sp], #8
    b828:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
    b82c:	4770      	bx	lr
    b82e:	e9d1 2300 	ldrd	r2, r3, [r1]
    b832:	f004 0503 	and.w	r5, r4, #3
    b836:	f1c4 0000 	rsb	r0, r4, #0
    b83a:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    b83e:	f014 0f04 	tst.w	r4, #4
    b842:	f891 f040 	pld	[r1, #64]	; 0x40
    b846:	fa0c f505 	lsl.w	r5, ip, r5
    b84a:	ea62 0205 	orn	r2, r2, r5
    b84e:	bf1c      	itt	ne
    b850:	ea63 0305 	ornne	r3, r3, r5
    b854:	4662      	movne	r2, ip
    b856:	f04f 0400 	mov.w	r4, #0
    b85a:	e7a9      	b.n	b7b0 <strlen+0x30>

0000b85c <strncpy>:
    b85c:	ea40 0301 	orr.w	r3, r0, r1
    b860:	079b      	lsls	r3, r3, #30
    b862:	b470      	push	{r4, r5, r6}
    b864:	d12b      	bne.n	b8be <strncpy+0x62>
    b866:	2a03      	cmp	r2, #3
    b868:	d929      	bls.n	b8be <strncpy+0x62>
    b86a:	460c      	mov	r4, r1
    b86c:	4603      	mov	r3, r0
    b86e:	4621      	mov	r1, r4
    b870:	f854 6b04 	ldr.w	r6, [r4], #4
    b874:	f1a6 3501 	sub.w	r5, r6, #16843009	; 0x1010101
    b878:	ea25 0506 	bic.w	r5, r5, r6
    b87c:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
    b880:	d106      	bne.n	b890 <strncpy+0x34>
    b882:	3a04      	subs	r2, #4
    b884:	2a03      	cmp	r2, #3
    b886:	f843 6b04 	str.w	r6, [r3], #4
    b88a:	4621      	mov	r1, r4
    b88c:	d8ef      	bhi.n	b86e <strncpy+0x12>
    b88e:	b1a2      	cbz	r2, b8ba <strncpy+0x5e>
    b890:	780c      	ldrb	r4, [r1, #0]
    b892:	701c      	strb	r4, [r3, #0]
    b894:	3a01      	subs	r2, #1
    b896:	3301      	adds	r3, #1
    b898:	3101      	adds	r1, #1
    b89a:	b13c      	cbz	r4, b8ac <strncpy+0x50>
    b89c:	b16a      	cbz	r2, b8ba <strncpy+0x5e>
    b89e:	f811 4b01 	ldrb.w	r4, [r1], #1
    b8a2:	f803 4b01 	strb.w	r4, [r3], #1
    b8a6:	3a01      	subs	r2, #1
    b8a8:	2c00      	cmp	r4, #0
    b8aa:	d1f7      	bne.n	b89c <strncpy+0x40>
    b8ac:	b12a      	cbz	r2, b8ba <strncpy+0x5e>
    b8ae:	441a      	add	r2, r3
    b8b0:	2100      	movs	r1, #0
    b8b2:	f803 1b01 	strb.w	r1, [r3], #1
    b8b6:	429a      	cmp	r2, r3
    b8b8:	d1fb      	bne.n	b8b2 <strncpy+0x56>
    b8ba:	bc70      	pop	{r4, r5, r6}
    b8bc:	4770      	bx	lr
    b8be:	4603      	mov	r3, r0
    b8c0:	e7e5      	b.n	b88e <strncpy+0x32>
    b8c2:	bf00      	nop

0000b8c4 <__register_exitproc>:
    b8c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    b8c8:	4c25      	ldr	r4, [pc, #148]	; (b960 <__register_exitproc+0x9c>)
    b8ca:	6825      	ldr	r5, [r4, #0]
    b8cc:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
    b8d0:	4606      	mov	r6, r0
    b8d2:	4688      	mov	r8, r1
    b8d4:	4692      	mov	sl, r2
    b8d6:	4699      	mov	r9, r3
    b8d8:	b3c4      	cbz	r4, b94c <__register_exitproc+0x88>
    b8da:	6860      	ldr	r0, [r4, #4]
    b8dc:	281f      	cmp	r0, #31
    b8de:	dc17      	bgt.n	b910 <__register_exitproc+0x4c>
    b8e0:	1c43      	adds	r3, r0, #1
    b8e2:	b176      	cbz	r6, b902 <__register_exitproc+0x3e>
    b8e4:	eb04 0580 	add.w	r5, r4, r0, lsl #2
    b8e8:	2201      	movs	r2, #1
    b8ea:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
    b8ee:	f8d4 1188 	ldr.w	r1, [r4, #392]	; 0x188
    b8f2:	4082      	lsls	r2, r0
    b8f4:	4311      	orrs	r1, r2
    b8f6:	2e02      	cmp	r6, #2
    b8f8:	f8c4 1188 	str.w	r1, [r4, #392]	; 0x188
    b8fc:	f8c5 9108 	str.w	r9, [r5, #264]	; 0x108
    b900:	d01e      	beq.n	b940 <__register_exitproc+0x7c>
    b902:	3002      	adds	r0, #2
    b904:	6063      	str	r3, [r4, #4]
    b906:	f844 8020 	str.w	r8, [r4, r0, lsl #2]
    b90a:	2000      	movs	r0, #0
    b90c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b910:	4b14      	ldr	r3, [pc, #80]	; (b964 <__register_exitproc+0xa0>)
    b912:	b303      	cbz	r3, b956 <__register_exitproc+0x92>
    b914:	f44f 70c8 	mov.w	r0, #400	; 0x190
    b918:	f7fe ffc2 	bl	a8a0 <malloc>
    b91c:	4604      	mov	r4, r0
    b91e:	b1d0      	cbz	r0, b956 <__register_exitproc+0x92>
    b920:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
    b924:	2700      	movs	r7, #0
    b926:	e880 0088 	stmia.w	r0, {r3, r7}
    b92a:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    b92e:	4638      	mov	r0, r7
    b930:	2301      	movs	r3, #1
    b932:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
    b936:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
    b93a:	2e00      	cmp	r6, #0
    b93c:	d0e1      	beq.n	b902 <__register_exitproc+0x3e>
    b93e:	e7d1      	b.n	b8e4 <__register_exitproc+0x20>
    b940:	f8d4 118c 	ldr.w	r1, [r4, #396]	; 0x18c
    b944:	430a      	orrs	r2, r1
    b946:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
    b94a:	e7da      	b.n	b902 <__register_exitproc+0x3e>
    b94c:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
    b950:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    b954:	e7c1      	b.n	b8da <__register_exitproc+0x16>
    b956:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    b95a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b95e:	bf00      	nop
    b960:	0000c490 	.word	0x0000c490
    b964:	0000a8a1 	.word	0x0000a8a1

0000b968 <register_fini>:
    b968:	4b02      	ldr	r3, [pc, #8]	; (b974 <register_fini+0xc>)
    b96a:	b113      	cbz	r3, b972 <register_fini+0xa>
    b96c:	4802      	ldr	r0, [pc, #8]	; (b978 <register_fini+0x10>)
    b96e:	f000 b805 	b.w	b97c <atexit>
    b972:	4770      	bx	lr
    b974:	00000000 	.word	0x00000000
    b978:	0000b989 	.word	0x0000b989

0000b97c <atexit>:
    b97c:	2300      	movs	r3, #0
    b97e:	4601      	mov	r1, r0
    b980:	461a      	mov	r2, r3
    b982:	4618      	mov	r0, r3
    b984:	f7ff bf9e 	b.w	b8c4 <__register_exitproc>

0000b988 <__libc_fini_array>:
    b988:	b538      	push	{r3, r4, r5, lr}
    b98a:	4d07      	ldr	r5, [pc, #28]	; (b9a8 <__libc_fini_array+0x20>)
    b98c:	4c07      	ldr	r4, [pc, #28]	; (b9ac <__libc_fini_array+0x24>)
    b98e:	1b2c      	subs	r4, r5, r4
    b990:	10a4      	asrs	r4, r4, #2
    b992:	d005      	beq.n	b9a0 <__libc_fini_array+0x18>
    b994:	3c01      	subs	r4, #1
    b996:	f855 3d04 	ldr.w	r3, [r5, #-4]!
    b99a:	4798      	blx	r3
    b99c:	2c00      	cmp	r4, #0
    b99e:	d1f9      	bne.n	b994 <__libc_fini_array+0xc>
    b9a0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    b9a4:	f000 bd82 	b.w	c4ac <__init_array_end>
	...

0000b9b0 <_malloc_trim_r>:
    b9b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b9b2:	4f23      	ldr	r7, [pc, #140]	; (ba40 <_malloc_trim_r+0x90>)
    b9b4:	460c      	mov	r4, r1
    b9b6:	4606      	mov	r6, r0
    b9b8:	f7ff faec 	bl	af94 <__malloc_lock>
    b9bc:	68bb      	ldr	r3, [r7, #8]
    b9be:	685d      	ldr	r5, [r3, #4]
    b9c0:	f025 0503 	bic.w	r5, r5, #3
    b9c4:	1b29      	subs	r1, r5, r4
    b9c6:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
    b9ca:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
    b9ce:	f021 010f 	bic.w	r1, r1, #15
    b9d2:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
    b9d6:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    b9da:	db07      	blt.n	b9ec <_malloc_trim_r+0x3c>
    b9dc:	2100      	movs	r1, #0
    b9de:	4630      	mov	r0, r6
    b9e0:	f7ff fcd4 	bl	b38c <_sbrk_r>
    b9e4:	68bb      	ldr	r3, [r7, #8]
    b9e6:	442b      	add	r3, r5
    b9e8:	4298      	cmp	r0, r3
    b9ea:	d004      	beq.n	b9f6 <_malloc_trim_r+0x46>
    b9ec:	4630      	mov	r0, r6
    b9ee:	f7ff fad3 	bl	af98 <__malloc_unlock>
    b9f2:	2000      	movs	r0, #0
    b9f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    b9f6:	4261      	negs	r1, r4
    b9f8:	4630      	mov	r0, r6
    b9fa:	f7ff fcc7 	bl	b38c <_sbrk_r>
    b9fe:	3001      	adds	r0, #1
    ba00:	d00d      	beq.n	ba1e <_malloc_trim_r+0x6e>
    ba02:	4b10      	ldr	r3, [pc, #64]	; (ba44 <_malloc_trim_r+0x94>)
    ba04:	68ba      	ldr	r2, [r7, #8]
    ba06:	6819      	ldr	r1, [r3, #0]
    ba08:	1b2d      	subs	r5, r5, r4
    ba0a:	f045 0501 	orr.w	r5, r5, #1
    ba0e:	4630      	mov	r0, r6
    ba10:	1b09      	subs	r1, r1, r4
    ba12:	6055      	str	r5, [r2, #4]
    ba14:	6019      	str	r1, [r3, #0]
    ba16:	f7ff fabf 	bl	af98 <__malloc_unlock>
    ba1a:	2001      	movs	r0, #1
    ba1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ba1e:	2100      	movs	r1, #0
    ba20:	4630      	mov	r0, r6
    ba22:	f7ff fcb3 	bl	b38c <_sbrk_r>
    ba26:	68ba      	ldr	r2, [r7, #8]
    ba28:	1a83      	subs	r3, r0, r2
    ba2a:	2b0f      	cmp	r3, #15
    ba2c:	ddde      	ble.n	b9ec <_malloc_trim_r+0x3c>
    ba2e:	4c06      	ldr	r4, [pc, #24]	; (ba48 <_malloc_trim_r+0x98>)
    ba30:	4904      	ldr	r1, [pc, #16]	; (ba44 <_malloc_trim_r+0x94>)
    ba32:	6824      	ldr	r4, [r4, #0]
    ba34:	f043 0301 	orr.w	r3, r3, #1
    ba38:	1b00      	subs	r0, r0, r4
    ba3a:	6053      	str	r3, [r2, #4]
    ba3c:	6008      	str	r0, [r1, #0]
    ba3e:	e7d5      	b.n	b9ec <_malloc_trim_r+0x3c>
    ba40:	1fff1004 	.word	0x1fff1004
    ba44:	1fff2d40 	.word	0x1fff2d40
    ba48:	1fff1410 	.word	0x1fff1410

0000ba4c <_free_r>:
    ba4c:	2900      	cmp	r1, #0
    ba4e:	d045      	beq.n	badc <_free_r+0x90>
    ba50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ba54:	460d      	mov	r5, r1
    ba56:	4680      	mov	r8, r0
    ba58:	f7ff fa9c 	bl	af94 <__malloc_lock>
    ba5c:	f855 7c04 	ldr.w	r7, [r5, #-4]
    ba60:	496a      	ldr	r1, [pc, #424]	; (bc0c <_free_r+0x1c0>)
    ba62:	f027 0301 	bic.w	r3, r7, #1
    ba66:	f1a5 0408 	sub.w	r4, r5, #8
    ba6a:	18e2      	adds	r2, r4, r3
    ba6c:	688e      	ldr	r6, [r1, #8]
    ba6e:	6850      	ldr	r0, [r2, #4]
    ba70:	42b2      	cmp	r2, r6
    ba72:	f020 0003 	bic.w	r0, r0, #3
    ba76:	d062      	beq.n	bb3e <_free_r+0xf2>
    ba78:	07fe      	lsls	r6, r7, #31
    ba7a:	6050      	str	r0, [r2, #4]
    ba7c:	d40b      	bmi.n	ba96 <_free_r+0x4a>
    ba7e:	f855 7c08 	ldr.w	r7, [r5, #-8]
    ba82:	1be4      	subs	r4, r4, r7
    ba84:	f101 0e08 	add.w	lr, r1, #8
    ba88:	68a5      	ldr	r5, [r4, #8]
    ba8a:	4575      	cmp	r5, lr
    ba8c:	443b      	add	r3, r7
    ba8e:	d06f      	beq.n	bb70 <_free_r+0x124>
    ba90:	68e7      	ldr	r7, [r4, #12]
    ba92:	60ef      	str	r7, [r5, #12]
    ba94:	60bd      	str	r5, [r7, #8]
    ba96:	1815      	adds	r5, r2, r0
    ba98:	686d      	ldr	r5, [r5, #4]
    ba9a:	07ed      	lsls	r5, r5, #31
    ba9c:	d542      	bpl.n	bb24 <_free_r+0xd8>
    ba9e:	f043 0201 	orr.w	r2, r3, #1
    baa2:	6062      	str	r2, [r4, #4]
    baa4:	50e3      	str	r3, [r4, r3]
    baa6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    baaa:	d218      	bcs.n	bade <_free_r+0x92>
    baac:	08db      	lsrs	r3, r3, #3
    baae:	1c5a      	adds	r2, r3, #1
    bab0:	684d      	ldr	r5, [r1, #4]
    bab2:	f851 7032 	ldr.w	r7, [r1, r2, lsl #3]
    bab6:	60a7      	str	r7, [r4, #8]
    bab8:	2001      	movs	r0, #1
    baba:	109b      	asrs	r3, r3, #2
    babc:	fa00 f303 	lsl.w	r3, r0, r3
    bac0:	eb01 00c2 	add.w	r0, r1, r2, lsl #3
    bac4:	431d      	orrs	r5, r3
    bac6:	3808      	subs	r0, #8
    bac8:	60e0      	str	r0, [r4, #12]
    baca:	604d      	str	r5, [r1, #4]
    bacc:	f841 4032 	str.w	r4, [r1, r2, lsl #3]
    bad0:	60fc      	str	r4, [r7, #12]
    bad2:	4640      	mov	r0, r8
    bad4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    bad8:	f7ff ba5e 	b.w	af98 <__malloc_unlock>
    badc:	4770      	bx	lr
    bade:	0a5a      	lsrs	r2, r3, #9
    bae0:	2a04      	cmp	r2, #4
    bae2:	d853      	bhi.n	bb8c <_free_r+0x140>
    bae4:	099a      	lsrs	r2, r3, #6
    bae6:	f102 0739 	add.w	r7, r2, #57	; 0x39
    baea:	007f      	lsls	r7, r7, #1
    baec:	f102 0538 	add.w	r5, r2, #56	; 0x38
    baf0:	eb01 0087 	add.w	r0, r1, r7, lsl #2
    baf4:	f851 2027 	ldr.w	r2, [r1, r7, lsl #2]
    baf8:	4944      	ldr	r1, [pc, #272]	; (bc0c <_free_r+0x1c0>)
    bafa:	3808      	subs	r0, #8
    bafc:	4290      	cmp	r0, r2
    bafe:	d04d      	beq.n	bb9c <_free_r+0x150>
    bb00:	6851      	ldr	r1, [r2, #4]
    bb02:	f021 0103 	bic.w	r1, r1, #3
    bb06:	428b      	cmp	r3, r1
    bb08:	d202      	bcs.n	bb10 <_free_r+0xc4>
    bb0a:	6892      	ldr	r2, [r2, #8]
    bb0c:	4290      	cmp	r0, r2
    bb0e:	d1f7      	bne.n	bb00 <_free_r+0xb4>
    bb10:	68d0      	ldr	r0, [r2, #12]
    bb12:	60e0      	str	r0, [r4, #12]
    bb14:	60a2      	str	r2, [r4, #8]
    bb16:	6084      	str	r4, [r0, #8]
    bb18:	60d4      	str	r4, [r2, #12]
    bb1a:	4640      	mov	r0, r8
    bb1c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    bb20:	f7ff ba3a 	b.w	af98 <__malloc_unlock>
    bb24:	6895      	ldr	r5, [r2, #8]
    bb26:	4f3a      	ldr	r7, [pc, #232]	; (bc10 <_free_r+0x1c4>)
    bb28:	42bd      	cmp	r5, r7
    bb2a:	4403      	add	r3, r0
    bb2c:	d03f      	beq.n	bbae <_free_r+0x162>
    bb2e:	68d0      	ldr	r0, [r2, #12]
    bb30:	60e8      	str	r0, [r5, #12]
    bb32:	f043 0201 	orr.w	r2, r3, #1
    bb36:	6085      	str	r5, [r0, #8]
    bb38:	6062      	str	r2, [r4, #4]
    bb3a:	50e3      	str	r3, [r4, r3]
    bb3c:	e7b3      	b.n	baa6 <_free_r+0x5a>
    bb3e:	07ff      	lsls	r7, r7, #31
    bb40:	4403      	add	r3, r0
    bb42:	d407      	bmi.n	bb54 <_free_r+0x108>
    bb44:	f855 2c08 	ldr.w	r2, [r5, #-8]
    bb48:	1aa4      	subs	r4, r4, r2
    bb4a:	4413      	add	r3, r2
    bb4c:	68a0      	ldr	r0, [r4, #8]
    bb4e:	68e2      	ldr	r2, [r4, #12]
    bb50:	60c2      	str	r2, [r0, #12]
    bb52:	6090      	str	r0, [r2, #8]
    bb54:	4a2f      	ldr	r2, [pc, #188]	; (bc14 <_free_r+0x1c8>)
    bb56:	6812      	ldr	r2, [r2, #0]
    bb58:	f043 0001 	orr.w	r0, r3, #1
    bb5c:	4293      	cmp	r3, r2
    bb5e:	6060      	str	r0, [r4, #4]
    bb60:	608c      	str	r4, [r1, #8]
    bb62:	d3b6      	bcc.n	bad2 <_free_r+0x86>
    bb64:	4b2c      	ldr	r3, [pc, #176]	; (bc18 <_free_r+0x1cc>)
    bb66:	4640      	mov	r0, r8
    bb68:	6819      	ldr	r1, [r3, #0]
    bb6a:	f7ff ff21 	bl	b9b0 <_malloc_trim_r>
    bb6e:	e7b0      	b.n	bad2 <_free_r+0x86>
    bb70:	1811      	adds	r1, r2, r0
    bb72:	6849      	ldr	r1, [r1, #4]
    bb74:	07c9      	lsls	r1, r1, #31
    bb76:	d444      	bmi.n	bc02 <_free_r+0x1b6>
    bb78:	6891      	ldr	r1, [r2, #8]
    bb7a:	68d2      	ldr	r2, [r2, #12]
    bb7c:	60ca      	str	r2, [r1, #12]
    bb7e:	4403      	add	r3, r0
    bb80:	f043 0001 	orr.w	r0, r3, #1
    bb84:	6091      	str	r1, [r2, #8]
    bb86:	6060      	str	r0, [r4, #4]
    bb88:	50e3      	str	r3, [r4, r3]
    bb8a:	e7a2      	b.n	bad2 <_free_r+0x86>
    bb8c:	2a14      	cmp	r2, #20
    bb8e:	d817      	bhi.n	bbc0 <_free_r+0x174>
    bb90:	f102 075c 	add.w	r7, r2, #92	; 0x5c
    bb94:	007f      	lsls	r7, r7, #1
    bb96:	f102 055b 	add.w	r5, r2, #91	; 0x5b
    bb9a:	e7a9      	b.n	baf0 <_free_r+0xa4>
    bb9c:	10aa      	asrs	r2, r5, #2
    bb9e:	684b      	ldr	r3, [r1, #4]
    bba0:	2501      	movs	r5, #1
    bba2:	fa05 f202 	lsl.w	r2, r5, r2
    bba6:	4313      	orrs	r3, r2
    bba8:	604b      	str	r3, [r1, #4]
    bbaa:	4602      	mov	r2, r0
    bbac:	e7b1      	b.n	bb12 <_free_r+0xc6>
    bbae:	f043 0201 	orr.w	r2, r3, #1
    bbb2:	614c      	str	r4, [r1, #20]
    bbb4:	610c      	str	r4, [r1, #16]
    bbb6:	60e5      	str	r5, [r4, #12]
    bbb8:	60a5      	str	r5, [r4, #8]
    bbba:	6062      	str	r2, [r4, #4]
    bbbc:	50e3      	str	r3, [r4, r3]
    bbbe:	e788      	b.n	bad2 <_free_r+0x86>
    bbc0:	2a54      	cmp	r2, #84	; 0x54
    bbc2:	d806      	bhi.n	bbd2 <_free_r+0x186>
    bbc4:	0b1a      	lsrs	r2, r3, #12
    bbc6:	f102 076f 	add.w	r7, r2, #111	; 0x6f
    bbca:	007f      	lsls	r7, r7, #1
    bbcc:	f102 056e 	add.w	r5, r2, #110	; 0x6e
    bbd0:	e78e      	b.n	baf0 <_free_r+0xa4>
    bbd2:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    bbd6:	d806      	bhi.n	bbe6 <_free_r+0x19a>
    bbd8:	0bda      	lsrs	r2, r3, #15
    bbda:	f102 0778 	add.w	r7, r2, #120	; 0x78
    bbde:	007f      	lsls	r7, r7, #1
    bbe0:	f102 0577 	add.w	r5, r2, #119	; 0x77
    bbe4:	e784      	b.n	baf0 <_free_r+0xa4>
    bbe6:	f240 5054 	movw	r0, #1364	; 0x554
    bbea:	4282      	cmp	r2, r0
    bbec:	d806      	bhi.n	bbfc <_free_r+0x1b0>
    bbee:	0c9a      	lsrs	r2, r3, #18
    bbf0:	f102 077d 	add.w	r7, r2, #125	; 0x7d
    bbf4:	007f      	lsls	r7, r7, #1
    bbf6:	f102 057c 	add.w	r5, r2, #124	; 0x7c
    bbfa:	e779      	b.n	baf0 <_free_r+0xa4>
    bbfc:	27fe      	movs	r7, #254	; 0xfe
    bbfe:	257e      	movs	r5, #126	; 0x7e
    bc00:	e776      	b.n	baf0 <_free_r+0xa4>
    bc02:	f043 0201 	orr.w	r2, r3, #1
    bc06:	6062      	str	r2, [r4, #4]
    bc08:	50e3      	str	r3, [r4, r3]
    bc0a:	e762      	b.n	bad2 <_free_r+0x86>
    bc0c:	1fff1004 	.word	0x1fff1004
    bc10:	1fff100c 	.word	0x1fff100c
    bc14:	1fff140c 	.word	0x1fff140c
    bc18:	1fff2d3c 	.word	0x1fff2d3c

0000bc1c <vtable for std_msgs::Time>:
	...
    bc24:	0000046d 00000495 000004d1 000004d9     m...............

0000bc34 <vtable for rosserial_msgs::TopicInfo>:
	...
    bc3c:	00000e25 000004e1 000005c9 000005d1     %...............

0000bc4c <vtable for rosserial_msgs::Log>:
	...
    bc54:	00000df1 000005d9 00000621 00000629     ........!...)...

0000bc64 <vtable for rosserial_msgs::RequestParamResponse>:
	...
    bc6c:	00000ca9 00000ec9 00000631 00000639     ........1...9...

0000bc7c <vtable for std_msgs::Int16>:
	...
    bc84:	00000641 00000651 00000661 00000669     A...Q...a...i...

0000bc94 <vtable for std_msgs::Float32>:
	...
    bc9c:	00000671 0000068d 000006ad 000006b5     q...............

0000bcac <vtable for geometry_msgs::Vector3>:
	...
    bcb4:	000006bd 00000725 000007d1 000007d9     ....%...........

0000bcc4 <vtable for geometry_msgs::Quaternion>:
	...
    bccc:	000007e1 00000869 00000949 00000951     ....i...I...Q...

0000bcdc <vtable for geometry_msgs::Twist>:
	...
    bce4:	000010b1 000015e1 00000959 00000961     ........Y...a...

0000bcf4 <vtable for custom_msgs::odom_and_imu>:
	...
    bcfc:	00001199 0000174d 00000969 00000971     ....M...i...q...

0000bd0c <vtable for ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>>:
	...
    bd14:	00001a4d 00003e51 0000098d              M...Q>......

0000bd20 <vtable for ros::Subscriber<geometry_msgs::Twist, void>>:
	...
    bd28:	0000146d 00000979 0000097d 00000985     m...y...}.......
    bd38:	5f647473 7367736d 6d69542f 00000065     std_msgs/Time...
    bd48:	31376463 37633636 35356334 31336332     cd7166c74c552c31
    bd58:	63626631 65663263 62376135 39383263     1fbcc2fe5a7bc289
    bd68:	00000000 73736f72 61697265 736d5f6c     ....rosserial_ms
    bd78:	542f7367 6369706f 6f666e49 00000000     gs/TopicInfo....
    bd88:	35646130 38386631 34346366 66323938     0ad51f88fc44892f
    bd98:	30316338 30343836 34363737 35303036     8c10684077646005
    bda8:	00000000 73736f72 61697265 736d5f6c     ....rosserial_ms
    bdb8:	4c2f7367 0000676f 62613131 31333764     gs/Log..11abd731
    bdc8:	39353263 36323333 36646331 62333831     c25933261cd6183b
    bdd8:	64323164 35393236 00000000 65306639     d12d6295....9f0e
    bde8:	64623839 39353661 38393138 66646436     98bda65981986ddf
    bdf8:	66613335 34613761 39346530 00000000     53afa7a40e49....
    be08:	5f647473 7367736d 746e492f 00003631     std_msgs/Int16..
    be18:	34323538 65363835 62663433 62633764     8524586e34fbd7cb
    be28:	38306331 35663563 61633166 37356530     1c08c5f5f1ca0e57
    be38:	00000000 5f647473 7367736d 6f6c462f     ....std_msgs/Flo
    be48:	32337461 00000000 63663337 36346662     at32....73fcbf46
    be58:	31393462 36653139 30393237 30356538     b49191e672908e50
    be68:	61323438 34643338 00000000 6d6f6567     842a83d4....geom
    be78:	79727465 67736d5f 65562f73 726f7463     etry_msgs/Vector
    be88:	00000033 34386134 35366232 33313466     3...4a842b65f413
    be98:	64343830 31623263 34626630 61653438     084dc2b10fb484ea
    bea8:	37316637 00000000 6d6f6567 79727465     7f17....geometry
    beb8:	67736d5f 75512f73 72657461 6e6f696e     _msgs/Quaternion
    bec8:	00000000 39373761 66393738 30666461     ....a779879fadf0
    bed8:	37303631 39663433 38623630 63393163     160734f906b8c19c
    bee8:	34303037 00000000 6d6f6567 79727465     7004....geometry
    bef8:	67736d5f 77542f73 00747369 39316639     _msgs/Twist.9f19
    bf08:	38386635 36343231 61666466 38393732     5f881246fdfa2798
    bf18:	33643164 63626565 61343861 00000000     d1d3eebca84a....
    bf28:	74737563 6d5f6d6f 2f736773 6d6f646f     custom_msgs/odom
    bf38:	646e615f 756d695f 00000000 32663061     _and_imu....a0f2
    bf48:	36616232 64313563 39643134 61663637     2ba6c51d41d976fa
    bf58:	62633835 32333338 30666335 00000000     58cb83325cf0....
    bf68:	7373654d 20656761 6d6f7266 76656420     Message from dev
    bf78:	20656369 706f7264 3a646570 73656d20     ice dropped: mes
    bf88:	65676173 72616c20 20726567 6e616874     sage larger than
    bf98:	66756220 2e726566 00000000 00646572      buffer.....red.
    bfa8:	00646552 00444552 65657267 0000006e     Red.RED.green...
    bfb8:	65657247 0000006e 45455247 0000004e     Green...GREEN...
    bfc8:	65756c62 00000000 65756c42 00000000     blue....Blue....
    bfd8:	45554c42 00000000 6e617963 00000000     BLUE....cyan....
    bfe8:	6e617943 00000000 4e415943 00000000     Cyan....CYAN....
    bff8:	70727570 0000656c 70727550 0000656c     purple..Purple..
    c008:	50525550 0000454c 6e61726f 00006567     PURPLE..orange..
    c018:	6e61724f 00006567 4e41524f 00004547     Orange..ORANGE..
    c028:	74696877 00002065 74696857 00000065     white ..White...
    c038:	54494857 00000045 74696877 00000065     WHITE...white...
    c048:	6c756f43 6f6e2064 69662074 6120646e     Could not find a
    c058:	6c617620 42206469 3832504d 65732030      valid BMP280 se
    c068:	726f736e 6863202c 206b6365 69726977     nsor, check wiri
    c078:	0000676e 68676972 69745f74 00006b63     ng..right_tick..
    c088:	7466656c 6369745f 0000006b 65656877     left_tick...whee
    c098:	6e615f6c 00656c67 65657073 6e615f64     l_angle.speed_an
    c0a8:	69745f64 00006b63 7361656d 64657275     d_tick..measured
    c0b8:	676e615f 0000656c 6d6f646f 79727465     _angle..odometry
    c0c8:	646e615f 554d495f 00000000 5f646d63     _and_IMU....cmd_
    c0d8:	006c6576                                vel.

0000c0dc <rosserial_msgs::REQUESTPARAM>:
    c0dc:	73736f72 61697265 736d5f6c 522f7367     rosserial_msgs/R
    c0ec:	65757165 61507473 006d6172              equestParam.

0000c0f8 <TwoWire::i2c0_hardware>:
    c0f8:	40048034 00000040 08221112 05020230     4..@@.....".0...
    c108:	10130207 022f0721 02070502 00000018     ....!./.........

0000c118 <TwoWire::i2c1_hardware>:
    c118:	40048034 00000080 ffff3a26 000602ff     4..@....&:......
    c128:	3b250000 02ffffff 00000006 00000019     ..%;............

0000c138 <TwoWire::i2c2_hardware>:
    c138:	40048028 00000040 ffffff04 000005ff     (..@@...........
    c148:	1a030000 05ffffff 00000005 0000004a     ............J...

0000c158 <vtable for TwoWire>:
	...
    c160:	00004c35 00004bf9 00004bd9 00004bf5     5L...K...K...K..
    c170:	0000491d 00004929 00004bdd              .I..)I...K..

0000c17c <vtable for Adafruit_BMP280_Temp>:
	...
    c184:	000053c1 000053c5 000053b9 000056a5     .S...S...S...V..
    c194:	000053e5 32504d42 ff003038              .S..BMP280..

0000c1a0 <vtable for Adafruit_BMP280_Pressure>:
	...
    c1a8:	000053bd 000053d5 000053b9 00005a5d     .S...S...S..]Z..
    c1b8:	00005431                                1T..

0000c1bc <digital_pin_to_info_PGM>:
    c1bc:	43fe0840 4004a040 43fe0844 4004a044     @..C@..@D..CD..@
    c1cc:	43fe1800 4004c000 43fe0030 40049030     ...C...@0..C0..@
    c1dc:	43fe0034 40049034 43fe181c 4004c01c     4..C4..@...C...@
    c1ec:	43fe1810 4004c010 43fe1808 4004c008     ...C...@...C...@
    c1fc:	43fe180c 4004c00c 43fe100c 4004b00c     ...C...@...C...@
    c20c:	43fe1010 4004b010 43fe1018 4004b018     ...C...@...C...@
    c21c:	43fe101c 4004b01c 43fe1014 4004b014     ...C...@...C...@
    c22c:	43fe1804 4004c004 43fe1000 4004b000     ...C...@...C...@
    c23c:	43fe0800 4004a000 43fe0804 4004a004     ...C...@...C...@
    c24c:	43fe080c 4004a00c 43fe0808 4004a008     ...C...@...C...@
    c25c:	43fe1814 4004c014 43fe1818 4004c018     ...C...@...C...@
    c26c:	43fe1004 4004b004 43fe1008 4004b008     ...C...@...C...@
    c27c:	43fe2068 4004d068 43fe0014 40049014     h .Ch..@...C...@
    c28c:	43fe0038 40049038 43fe003c 4004903c     8..C8..@<..C<..@
    c29c:	43fe0040 40049040 43fe0848 4004a048     @..C@..@H..CH..@
    c2ac:	43fe084c 4004a04c 43fe0828 4004a028     L..CL..@(..C(..@
    c2bc:	43fe082c 4004a02c 43fe2060 4004d060     ,..C,..@` .C`..@
    c2cc:	43fe2064 4004d064 43fe1020 4004b020     d .Cd..@ ..C ..@
    c2dc:	43fe1024 4004b024 43fe1028 4004b028     $..C$..@(..C(..@
    c2ec:	43fe102c 4004b02c 43fe0044 40049044     ,..C,..@D..CD..@
    c2fc:	43fe0070 40049070 43fe0074 40049074     p..Cp..@t..Ct..@
    c30c:	43fe0068 40049068 43fe0850 4004a050     h..Ch..@P..CP..@
    c31c:	43fe0858 4004a058 43fe085c 4004a05c     X..CX..@\..C\..@
    c32c:	43fe0854 4004a054 43fe1820 4004c020     T..CT..@ ..C ..@
    c33c:	43fe1824 4004c024 43fe0810 4004a010     $..C$..@...C...@
    c34c:	43fe0814 4004a014 43fe1838 4004c038     ...C...@8..C8..@
    c35c:	43fe1834 4004c034 43fe1830 4004c030     4..C4..@0..C0..@
    c36c:	43fe183c 4004c03c 43fe182c 4004c02c     <..C<..@,..C,..@
    c37c:	43fe2028 4004d028 43fe202c 4004d02c     ( .C(..@, .C,..@
    c38c:	43fe2000 4004d000 43fe2004 4004d004     . .C...@. .C...@
    c39c:	43fe2008 4004d008 43fe200c 4004d00c     . .C...@. .C...@
    c3ac:	43fe2010 4004d010 43fe2014 4004d014     . .C...@. .C...@

0000c3bc <vtable for usb_serial_class>:
	...
    c3c4:	00007dcd 00000ebd 00007dc9 00007dc5     .}.......}...}..
    c3d4:	00007dc1 00000ec5 00007dbd 00007db9     .}.......}...}..

0000c3e4 <usb_endpoint_config_table>:
    c3e4:	15191500                                ....

0000c3e8 <usb_descriptor_list>:
    c3e8:	00000100 1fff0b34 00000012 00000200     ....4...........
    c3f8:	1fff0b60 00000043 00000300 1fff0bbc     `...C...........
    c408:	00000000 04090301 1fff0b48 00000000     ........H.......
    c418:	04090302 1fff0ba4 00000000 04090303     ................
    c428:	1fff0bc0 00000000 00000000 00000000     ................
    c438:	00000000 00776f70                       ....pow.

0000c440 <atanlo>:
    c440:	222f65e2 3c7a2b7f 33145c07 3c81a626     .e/".+z<.\.3&..<
    c450:	7af0cbbd 3c700788 33145c07 3c91a626     ...z..p<.\.3&..<

0000c460 <atanhi>:
    c460:	0561bb4f 3fddac67 54442d18 3fe921fb     O.a.g..?.-DT.!.?
    c470:	d281f69b 3fef730b 54442d18 3ff921fb     .....s.?.-DT.!.?

0000c480 <TWO52>:
    c480:	00000000 43300000 00000000 c3300000     ......0C......0.

0000c490 <_global_impure_ptr>:
    c490:	1fff0bd8                                ....

0000c494 <_init>:
    c494:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c496:	bf00      	nop
    c498:	bcf8      	pop	{r3, r4, r5, r6, r7}
    c49a:	bc08      	pop	{r3}
    c49c:	469e      	mov	lr, r3
    c49e:	4770      	bx	lr

0000c4a0 <__init_array_start>:
    c4a0:	0000b969 	.word	0x0000b969

0000c4a4 <__frame_dummy_init_array_entry>:
    c4a4:	00000435 000046a9                       5....F..

Disassembly of section .fini:

0000c4ac <_fini>:
    c4ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c4ae:	bf00      	nop

Disassembly of section .data:

1fff0730 <port_E_isr>:
#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
PORT_ISR_FUNCTION_CLZ(C)
PORT_ISR_FUNCTION_CLZ(D)
PORT_ISR_FUNCTION_CLZ(E)
1fff0730:	b538      	push	{r3, r4, r5, lr}
1fff0732:	4b08      	ldr	r3, [pc, #32]	; (1fff0754 <port_E_isr+0x24>)
1fff0734:	681c      	ldr	r4, [r3, #0]
1fff0736:	601c      	str	r4, [r3, #0]
1fff0738:	b154      	cbz	r4, 1fff0750 <port_E_isr+0x20>
1fff073a:	4d07      	ldr	r5, [pc, #28]	; (1fff0758 <port_E_isr+0x28>)
1fff073c:	fa94 f3a4 	rbit	r3, r4
1fff0740:	fab3 f383 	clz	r3, r3
1fff0744:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff0748:	4798      	blx	r3
1fff074a:	1e63      	subs	r3, r4, #1
1fff074c:	401c      	ands	r4, r3
1fff074e:	d1f5      	bne.n	1fff073c <port_E_isr+0xc>
1fff0750:	bd38      	pop	{r3, r4, r5, pc}
1fff0752:	bf00      	nop
1fff0754:	4004d0a0 	.word	0x4004d0a0
1fff0758:	1fff0aac 	.word	0x1fff0aac

1fff075c <port_D_isr>:

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
PORT_ISR_FUNCTION_CLZ(C)
PORT_ISR_FUNCTION_CLZ(D)
1fff075c:	b538      	push	{r3, r4, r5, lr}
1fff075e:	4b08      	ldr	r3, [pc, #32]	; (1fff0780 <port_D_isr+0x24>)
1fff0760:	681c      	ldr	r4, [r3, #0]
1fff0762:	601c      	str	r4, [r3, #0]
1fff0764:	b154      	cbz	r4, 1fff077c <port_D_isr+0x20>
1fff0766:	4d07      	ldr	r5, [pc, #28]	; (1fff0784 <port_D_isr+0x28>)
1fff0768:	fa94 f3a4 	rbit	r3, r4
1fff076c:	fab3 f383 	clz	r3, r3
1fff0770:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff0774:	4798      	blx	r3
1fff0776:	1e63      	subs	r3, r4, #1
1fff0778:	401c      	ands	r4, r3
1fff077a:	d1f5      	bne.n	1fff0768 <port_D_isr+0xc>
1fff077c:	bd38      	pop	{r3, r4, r5, pc}
1fff077e:	bf00      	nop
1fff0780:	4004c0a0 	.word	0x4004c0a0
1fff0784:	1fff0a6c 	.word	0x1fff0a6c

1fff0788 <port_C_isr>:
// END PORT_ISR_FUNCTION_CLZ

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
PORT_ISR_FUNCTION_CLZ(C)
1fff0788:	b538      	push	{r3, r4, r5, lr}
1fff078a:	4b08      	ldr	r3, [pc, #32]	; (1fff07ac <port_C_isr+0x24>)
1fff078c:	681c      	ldr	r4, [r3, #0]
1fff078e:	601c      	str	r4, [r3, #0]
1fff0790:	b154      	cbz	r4, 1fff07a8 <port_C_isr+0x20>
1fff0792:	4d07      	ldr	r5, [pc, #28]	; (1fff07b0 <port_C_isr+0x28>)
1fff0794:	fa94 f3a4 	rbit	r3, r4
1fff0798:	fab3 f383 	clz	r3, r3
1fff079c:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff07a0:	4798      	blx	r3
1fff07a2:	1e63      	subs	r3, r4, #1
1fff07a4:	401c      	ands	r4, r3
1fff07a6:	d1f5      	bne.n	1fff0794 <port_C_isr+0xc>
1fff07a8:	bd38      	pop	{r3, r4, r5, pc}
1fff07aa:	bf00      	nop
1fff07ac:	4004b0a0 	.word	0x4004b0a0
1fff07b0:	1fff0a3c 	.word	0x1fff0a3c

1fff07b4 <port_B_isr>:
	}
// END PORT_ISR_FUNCTION_CLZ

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
1fff07b4:	b538      	push	{r3, r4, r5, lr}
1fff07b6:	4b08      	ldr	r3, [pc, #32]	; (1fff07d8 <port_B_isr+0x24>)
1fff07b8:	681c      	ldr	r4, [r3, #0]
1fff07ba:	601c      	str	r4, [r3, #0]
1fff07bc:	b154      	cbz	r4, 1fff07d4 <port_B_isr+0x20>
1fff07be:	4d07      	ldr	r5, [pc, #28]	; (1fff07dc <port_B_isr+0x28>)
1fff07c0:	fa94 f3a4 	rbit	r3, r4
1fff07c4:	fab3 f383 	clz	r3, r3
1fff07c8:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff07cc:	4798      	blx	r3
1fff07ce:	1e63      	subs	r3, r4, #1
1fff07d0:	401c      	ands	r4, r3
1fff07d2:	d1f5      	bne.n	1fff07c0 <port_B_isr+0xc>
1fff07d4:	bd38      	pop	{r3, r4, r5, pc}
1fff07d6:	bf00      	nop
1fff07d8:	4004a0a0 	.word	0x4004a0a0
1fff07dc:	1fff09dc 	.word	0x1fff09dc

1fff07e0 <port_A_isr>:
		}                                                     \
	}
// END PORT_ISR_FUNCTION_CLZ

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
1fff07e0:	b538      	push	{r3, r4, r5, lr}
1fff07e2:	4b08      	ldr	r3, [pc, #32]	; (1fff0804 <port_A_isr+0x24>)
1fff07e4:	681c      	ldr	r4, [r3, #0]
1fff07e6:	601c      	str	r4, [r3, #0]
1fff07e8:	b154      	cbz	r4, 1fff0800 <port_A_isr+0x20>
1fff07ea:	4d07      	ldr	r5, [pc, #28]	; (1fff0808 <port_A_isr+0x28>)
1fff07ec:	fa94 f3a4 	rbit	r3, r4
1fff07f0:	fab3 f383 	clz	r3, r3
1fff07f4:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff07f8:	4798      	blx	r3
1fff07fa:	1e63      	subs	r3, r4, #1
1fff07fc:	401c      	ands	r4, r3
1fff07fe:	d1f5      	bne.n	1fff07ec <port_A_isr+0xc>
1fff0800:	bd38      	pop	{r3, r4, r5, pc}
1fff0802:	bf00      	nop
1fff0804:	400490a0 	.word	0x400490a0
1fff0808:	1fff0964 	.word	0x1fff0964

1fff080c <__dso_handle>:
1fff080c:	00000000                                ....

1fff0810 <mag_y_cal>:
1fff0810:	fffffffa                                ....

1fff0814 <mag_x_cal>:
1fff0814:	ffffffec                                ....

1fff0818 <I2Cdev::readTimeout>:
1fff0818:	000003e8                                ....

1fff081c <Wire2>:
1fff081c:	0000c160 00000000 000003e8 00000000     `...............
1fff082c:	400e6000 0000c138 00000000 00000000     .`.@8...........
	...

1fff0888 <Wire>:
1fff0888:	0000c160 00000000 000003e8 00000000     `...............
1fff0898:	40066000 0000c0f8 00000000 00000000     .`.@............
	...

1fff08f4 <Wire1>:
1fff08f4:	0000c160 00000000 000003e8 00000000     `...............
1fff0904:	40067000 0000c118 00000000 00000000     .p.@............
	...

1fff0960 <__brkval>:
1fff0960:	1fff2d80                                .-..

1fff0964 <isr_table_portA>:
1fff0964:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff0974:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff0984:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff0994:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff09a4:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff09b4:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff09c4:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff09d4:	000066d9 000066d9                       .f...f..

1fff09dc <isr_table_portB>:
1fff09dc:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff09ec:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff09fc:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff0a0c:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff0a1c:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff0a2c:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..

1fff0a3c <isr_table_portC>:
1fff0a3c:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff0a4c:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff0a5c:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..

1fff0a6c <isr_table_portD>:
1fff0a6c:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff0a7c:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff0a8c:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff0a9c:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..

1fff0aac <isr_table_portE>:
1fff0aac:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff0abc:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff0acc:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff0adc:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff0aec:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff0afc:	000066d9 000066d9 000066d9 000066d9     .f...f...f...f..
1fff0b0c:	000066d9 000066d9 000066d9              .f...f...f..

1fff0b18 <analog_write_res>:
1fff0b18:	00000008                                ....

1fff0b1c <usb_buffer_available>:
1fff0b1c:	ffffffff                                ....

1fff0b20 <Serial>:
1fff0b20:	0000c3c4 00000000 000003e8 00000000     ................

1fff0b30 <yield_active_check_flags>:
1fff0b30:	00040a01                                         .

1fff0b31 <analog_config_bits>:
1fff0b31:	1200040a                                         .

1fff0b32 <analog_num_average>:
1fff0b32:	01120004                                         ..

1fff0b34 <device_descriptor>:
1fff0b34:	01100112 40000002 048316c0 02010277     .......@....w...
1fff0b44:	00000103                                ....

1fff0b48 <usb_string_manufacturer_name_default>:
1fff0b48:	00540318 00650065 0073006e 00640079     ..T.e.e.n.s.y.d.
1fff0b58:	00690075 006f006e                       u.i.n.o.

1fff0b60 <config_descriptor>:
1fff0b60:	00430209 c0000102 00040932 02020100     ..C.....2.......
1fff0b70:	24050001 05011000 01010124 06022404     ...$....$....$..
1fff0b80:	00062405 82050701 40001003 00010409     .$.........@....
1fff0b90:	00000a02 03050700 00004002 02840507     .........@......
1fff0ba0:	00000040                                @...

1fff0ba4 <usb_string_product_name_default>:
1fff0ba4:	00550316 00420053 00530020 00720065     ..U.S.B. .S.e.r.
1fff0bb4:	00610069 0000006c                       i.a.l...

1fff0bbc <string0>:
1fff0bbc:	04090304                                ....

1fff0bc0 <usb_string_serial_number_default>:
1fff0bc0:	0000030c 00000000 00000000 00000000     ................
1fff0bd0:	00000000 01010000                                ......

1fff0bd6 <_serialEvent_default>:
1fff0bd6:	00000101                                         .

1fff0bd7 <__fdlib_version>:
1fff0bd7:	00000001                                         .

1fff0bd8 <impure_data>:
1fff0bd8:	00000000 1fff0ec4 1fff0f2c 1fff0f94     ........,.......
	...
1fff0c80:	00000001 00000000 abcd330e e66d1234     .........3..4.m.
1fff0c90:	0005deec 0000000b 00000000 00000000     ................
	...

1fff1000 <_impure_ptr>:
1fff1000:	1fff0bd8                                ....

1fff1004 <__malloc_av_>:
	...
1fff100c:	1fff1004 1fff1004 1fff100c 1fff100c     ................
1fff101c:	1fff1014 1fff1014 1fff101c 1fff101c     ................
1fff102c:	1fff1024 1fff1024 1fff102c 1fff102c     $...$...,...,...
1fff103c:	1fff1034 1fff1034 1fff103c 1fff103c     4...4...<...<...
1fff104c:	1fff1044 1fff1044 1fff104c 1fff104c     D...D...L...L...
1fff105c:	1fff1054 1fff1054 1fff105c 1fff105c     T...T...\...\...
1fff106c:	1fff1064 1fff1064 1fff106c 1fff106c     d...d...l...l...
1fff107c:	1fff1074 1fff1074 1fff107c 1fff107c     t...t...|...|...
1fff108c:	1fff1084 1fff1084 1fff108c 1fff108c     ................
1fff109c:	1fff1094 1fff1094 1fff109c 1fff109c     ................
1fff10ac:	1fff10a4 1fff10a4 1fff10ac 1fff10ac     ................
1fff10bc:	1fff10b4 1fff10b4 1fff10bc 1fff10bc     ................
1fff10cc:	1fff10c4 1fff10c4 1fff10cc 1fff10cc     ................
1fff10dc:	1fff10d4 1fff10d4 1fff10dc 1fff10dc     ................
1fff10ec:	1fff10e4 1fff10e4 1fff10ec 1fff10ec     ................
1fff10fc:	1fff10f4 1fff10f4 1fff10fc 1fff10fc     ................
1fff110c:	1fff1104 1fff1104 1fff110c 1fff110c     ................
1fff111c:	1fff1114 1fff1114 1fff111c 1fff111c     ................
1fff112c:	1fff1124 1fff1124 1fff112c 1fff112c     $...$...,...,...
1fff113c:	1fff1134 1fff1134 1fff113c 1fff113c     4...4...<...<...
1fff114c:	1fff1144 1fff1144 1fff114c 1fff114c     D...D...L...L...
1fff115c:	1fff1154 1fff1154 1fff115c 1fff115c     T...T...\...\...
1fff116c:	1fff1164 1fff1164 1fff116c 1fff116c     d...d...l...l...
1fff117c:	1fff1174 1fff1174 1fff117c 1fff117c     t...t...|...|...
1fff118c:	1fff1184 1fff1184 1fff118c 1fff118c     ................
1fff119c:	1fff1194 1fff1194 1fff119c 1fff119c     ................
1fff11ac:	1fff11a4 1fff11a4 1fff11ac 1fff11ac     ................
1fff11bc:	1fff11b4 1fff11b4 1fff11bc 1fff11bc     ................
1fff11cc:	1fff11c4 1fff11c4 1fff11cc 1fff11cc     ................
1fff11dc:	1fff11d4 1fff11d4 1fff11dc 1fff11dc     ................
1fff11ec:	1fff11e4 1fff11e4 1fff11ec 1fff11ec     ................
1fff11fc:	1fff11f4 1fff11f4 1fff11fc 1fff11fc     ................
1fff120c:	1fff1204 1fff1204 1fff120c 1fff120c     ................
1fff121c:	1fff1214 1fff1214 1fff121c 1fff121c     ................
1fff122c:	1fff1224 1fff1224 1fff122c 1fff122c     $...$...,...,...
1fff123c:	1fff1234 1fff1234 1fff123c 1fff123c     4...4...<...<...
1fff124c:	1fff1244 1fff1244 1fff124c 1fff124c     D...D...L...L...
1fff125c:	1fff1254 1fff1254 1fff125c 1fff125c     T...T...\...\...
1fff126c:	1fff1264 1fff1264 1fff126c 1fff126c     d...d...l...l...
1fff127c:	1fff1274 1fff1274 1fff127c 1fff127c     t...t...|...|...
1fff128c:	1fff1284 1fff1284 1fff128c 1fff128c     ................
1fff129c:	1fff1294 1fff1294 1fff129c 1fff129c     ................
1fff12ac:	1fff12a4 1fff12a4 1fff12ac 1fff12ac     ................
1fff12bc:	1fff12b4 1fff12b4 1fff12bc 1fff12bc     ................
1fff12cc:	1fff12c4 1fff12c4 1fff12cc 1fff12cc     ................
1fff12dc:	1fff12d4 1fff12d4 1fff12dc 1fff12dc     ................
1fff12ec:	1fff12e4 1fff12e4 1fff12ec 1fff12ec     ................
1fff12fc:	1fff12f4 1fff12f4 1fff12fc 1fff12fc     ................
1fff130c:	1fff1304 1fff1304 1fff130c 1fff130c     ................
1fff131c:	1fff1314 1fff1314 1fff131c 1fff131c     ................
1fff132c:	1fff1324 1fff1324 1fff132c 1fff132c     $...$...,...,...
1fff133c:	1fff1334 1fff1334 1fff133c 1fff133c     4...4...<...<...
1fff134c:	1fff1344 1fff1344 1fff134c 1fff134c     D...D...L...L...
1fff135c:	1fff1354 1fff1354 1fff135c 1fff135c     T...T...\...\...
1fff136c:	1fff1364 1fff1364 1fff136c 1fff136c     d...d...l...l...
1fff137c:	1fff1374 1fff1374 1fff137c 1fff137c     t...t...|...|...
1fff138c:	1fff1384 1fff1384 1fff138c 1fff138c     ................
1fff139c:	1fff1394 1fff1394 1fff139c 1fff139c     ................
1fff13ac:	1fff13a4 1fff13a4 1fff13ac 1fff13ac     ................
1fff13bc:	1fff13b4 1fff13b4 1fff13bc 1fff13bc     ................
1fff13cc:	1fff13c4 1fff13c4 1fff13cc 1fff13cc     ................
1fff13dc:	1fff13d4 1fff13d4 1fff13dc 1fff13dc     ................
1fff13ec:	1fff13e4 1fff13e4 1fff13ec 1fff13ec     ................
1fff13fc:	1fff13f4 1fff13f4 1fff13fc 1fff13fc     ................

1fff140c <__malloc_trim_threshold>:
1fff140c:	00020000                                ....

1fff1410 <__malloc_sbrk_base>:
1fff1410:	ffffffff                                ....
