
/tmp/arduino-sketch-1A5AB903302D1BEDD698E1DA3B58D00C/motor_strait_driving.ino.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <_VectorsFlash>:
HardwareSerial 	*HardwareSerial::s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
uint8_t 		HardwareSerial::s_count_serials_with_serial_events = 0;

// simple helper function that add us to the list of Serial ports that have
// their own serialEvent code defined that needs to be called at yield.
void HardwareSerial::addToSerialEventsList() {
       0:	00 00 03 20 d1 01 00 00 71 4c 00 00 29 4c 00 00     ... ....qL..)L..
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
		if (s_serials_with_serial_events[i] == this) return; // already in the list.
      10:	29 4c 00 00 29 4c 00 00 29 4c 00 00 29 4c 00 00     )L..)L..)L..)L..
      20:	29 4c 00 00 29 4c 00 00 29 4c 00 00 71 4c 00 00     )L..)L..)L..qL..
	}

	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
      30:	71 4c 00 00 29 4c 00 00 fd 62 00 00 01 63 00 00     qL..)L...b...c..
uint8_t 		HardwareSerial::s_count_serials_with_serial_events = 0;

// simple helper function that add us to the list of Serial ports that have
// their own serialEvent code defined that needs to be called at yield.
void HardwareSerial::addToSerialEventsList() {
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
      40:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..
      50:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..
      60:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..
      70:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..
      80:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..
      90:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..
      a0:	2d 4a 00 00 39 4a 00 00 71 4c 00 00 71 4c 00 00     -J..9J..qL..qL..
      b0:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..
      c0:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..
      d0:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..
      e0:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..
      f0:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..
     100:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..
     110:	71 4c 00 00 21 56 00 00 71 4c 00 00 71 4c 00 00     qL..!V..qL..qL..
     120:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..
     130:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..
     140:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..
     150:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..
     160:	71 4c 00 00 71 4c 00 00 45 4a 00 00 71 4c 00 00     qL..qL..EJ..qL..
     170:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..
     180:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..
     190:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..
     1a0:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..
     1b0:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..
     1c0:	71 4c 00 00 71 4c 00 00 71 4c 00 00 71 4c 00 00     qL..qL..qL..qL..

000001d0 <ResetHandler>:
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d0:	4b5c      	ldr	r3, [pc, #368]	; (344 <ResetHandler+0x174>)
     1d2:	f24c 5220 	movw	r2, #50464	; 0xc520
#else
// hopefully all others fit into startup section (below 0x400)
__attribute__ ((section(".startup"),optimize("-Os")))
#endif
void ResetHandler(void)
{
     1d6:	b510      	push	{r4, lr}
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d8:	801a      	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
     1da:	f64d 1228 	movw	r2, #55592	; 0xd928
     1de:	801a      	strh	r2, [r3, #0]
	__asm__ volatile ("nop");
     1e0:	bf00      	nop
	__asm__ volatile ("nop");
     1e2:	bf00      	nop
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
     1e4:	f004 fd48 	bl	4c78 <startup_early_hook>
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1e8:	4b57      	ldr	r3, [pc, #348]	; (348 <ResetHandler+0x178>)
     1ea:	f04f 6230 	mov.w	r2, #184549376	; 0xb000000
     1ee:	601a      	str	r2, [r3, #0]
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
     1f0:	4a56      	ldr	r2, [pc, #344]	; (34c <ResetHandler+0x17c>)
     1f2:	609a      	str	r2, [r3, #8]
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
     1f4:	4a56      	ldr	r2, [pc, #344]	; (350 <ResetHandler+0x180>)
     1f6:	60da      	str	r2, [r3, #12]
	SIM_SCGC4 = SIM_SCGC4_USBOTG | 0xF0000030;
	SIM_SCGC5 = 0x00003F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_ADC0 | SIM_SCGC6_TPM0 | SIM_SCGC6_TPM1 | SIM_SCGC6_TPM2 | SIM_SCGC6_FTFL;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SCB_CPACR = 0x00F00000;
     1f8:	4b56      	ldr	r3, [pc, #344]	; (354 <ResetHandler+0x184>)
     1fa:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
     1fe:	601a      	str	r2, [r3, #0]
#endif
#if defined(__MK66FX1M0__)
	LMEM_PCCCR = 0x85000003;
     200:	4b55      	ldr	r3, [pc, #340]	; (358 <ResetHandler+0x188>)
     202:	4a56      	ldr	r2, [pc, #344]	; (35c <ResetHandler+0x18c>)
     204:	601a      	str	r2, [r3, #0]
		RTC_SR = 0;
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
     206:	4b56      	ldr	r3, [pc, #344]	; (360 <ResetHandler+0x190>)
     208:	781a      	ldrb	r2, [r3, #0]
     20a:	0711      	lsls	r1, r2, #28
     20c:	d503      	bpl.n	216 <ResetHandler+0x46>
     20e:	781a      	ldrb	r2, [r3, #0]
     210:	f042 0208 	orr.w	r2, r2, #8
     214:	701a      	strb	r2, [r3, #0]

    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     216:	4b53      	ldr	r3, [pc, #332]	; (364 <ResetHandler+0x194>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     218:	4953      	ldr	r1, [pc, #332]	; (368 <ResetHandler+0x198>)
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;

    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     21a:	22aa      	movs	r2, #170	; 0xaa
     21c:	701a      	strb	r2, [r3, #0]
     21e:	4a53      	ldr	r2, [pc, #332]	; (36c <ResetHandler+0x19c>)
     220:	4b53      	ldr	r3, [pc, #332]	; (370 <ResetHandler+0x1a0>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     222:	428b      	cmp	r3, r1
     224:	d204      	bcs.n	230 <ResetHandler+0x60>
     226:	f852 0f04 	ldr.w	r0, [r2, #4]!
     22a:	f843 0b04 	str.w	r0, [r3], #4
     22e:	e7f8      	b.n	222 <ResetHandler+0x52>
     230:	4b50      	ldr	r3, [pc, #320]	; (374 <ResetHandler+0x1a4>)
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
     232:	4951      	ldr	r1, [pc, #324]	; (378 <ResetHandler+0x1a8>)
     234:	2200      	movs	r2, #0
     236:	428b      	cmp	r3, r1
     238:	d202      	bcs.n	240 <ResetHandler+0x70>
     23a:	f843 2b04 	str.w	r2, [r3], #4
     23e:	e7fa      	b.n	236 <ResetHandler+0x66>

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
     240:	494e      	ldr	r1, [pc, #312]	; (37c <ResetHandler+0x1ac>)
     242:	4a4f      	ldr	r2, [pc, #316]	; (380 <ResetHandler+0x1b0>)
     244:	2300      	movs	r3, #0
     246:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
     24a:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
     24e:	3301      	adds	r3, #1
     250:	2b74      	cmp	r3, #116	; 0x74
     252:	d1f8      	bne.n	246 <ResetHandler+0x76>
     254:	4b4b      	ldr	r3, [pc, #300]	; (384 <ResetHandler+0x1b4>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
     256:	4a4c      	ldr	r2, [pc, #304]	; (388 <ResetHandler+0x1b8>)
     258:	2180      	movs	r1, #128	; 0x80
     25a:	f803 1b01 	strb.w	r1, [r3], #1
     25e:	4293      	cmp	r3, r2
     260:	d1fb      	bne.n	25a <ResetHandler+0x8a>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
     262:	4b4a      	ldr	r3, [pc, #296]	; (38c <ResetHandler+0x1bc>)
     264:	4a45      	ldr	r2, [pc, #276]	; (37c <ResetHandler+0x1ac>)
     266:	601a      	str	r2, [r3, #0]
	//  C6[PLLS] bit is written to 0
	//  C2[LP] bit is written to 1
#else
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
     268:	4b49      	ldr	r3, [pc, #292]	; (390 <ResetHandler+0x1c0>)
     26a:	228a      	movs	r2, #138	; 0x8a
     26c:	701a      	strb	r2, [r3, #0]
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
     26e:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
     272:	2224      	movs	r2, #36	; 0x24
     274:	705a      	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
     276:	22a0      	movs	r2, #160	; 0xa0
     278:	701a      	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
     27a:	799a      	ldrb	r2, [r3, #6]
     27c:	0792      	lsls	r2, r2, #30
     27e:	d5fc      	bpl.n	27a <ResetHandler+0xaa>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
     280:	799a      	ldrb	r2, [r3, #6]
     282:	06d4      	lsls	r4, r2, #27
     284:	d4fc      	bmi.n	280 <ResetHandler+0xb0>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     286:	4a43      	ldr	r2, [pc, #268]	; (394 <ResetHandler+0x1c4>)
     288:	7993      	ldrb	r3, [r2, #6]
     28a:	f003 030c 	and.w	r3, r3, #12
     28e:	2b08      	cmp	r3, #8
     290:	d1fa      	bne.n	288 <ResetHandler+0xb8>
	//   C2[LP] bit is written to 1
  #else
	// if we need faster than the crystal, turn on the PLL
   #if defined(__MK66FX1M0__)
    #if F_CPU > 120000000
	SMC_PMCTRL = SMC_PMCTRL_RUNM(3); // enter HSRUN mode
     292:	4b41      	ldr	r3, [pc, #260]	; (398 <ResetHandler+0x1c8>)
     294:	2260      	movs	r2, #96	; 0x60
     296:	701a      	strb	r2, [r3, #0]
	while (SMC_PMSTAT != SMC_PMSTAT_HSRUN) ; // wait for HSRUN
     298:	3302      	adds	r3, #2
     29a:	781a      	ldrb	r2, [r3, #0]
     29c:	2a80      	cmp	r2, #128	; 0x80
     29e:	d1fc      	bne.n	29a <ResetHandler+0xca>
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(11);
    #elif F_CPU == 192000000
	MCG_C5 = MCG_C5_PRDIV0(0);
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(8);
    #elif F_CPU == 180000000
	MCG_C5 = MCG_C5_PRDIV0(1);
     2a0:	4b3c      	ldr	r3, [pc, #240]	; (394 <ResetHandler+0x1c4>)
     2a2:	2201      	movs	r2, #1
     2a4:	711a      	strb	r2, [r3, #4]
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(29);
     2a6:	225d      	movs	r2, #93	; 0x5d
     2a8:	715a      	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     2aa:	799a      	ldrb	r2, [r3, #6]
     2ac:	0690      	lsls	r0, r2, #26
     2ae:	d5fc      	bpl.n	2aa <ResetHandler+0xda>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     2b0:	7999      	ldrb	r1, [r3, #6]
     2b2:	4a38      	ldr	r2, [pc, #224]	; (394 <ResetHandler+0x1c4>)
     2b4:	0649      	lsls	r1, r1, #25
     2b6:	d5fb      	bpl.n	2b0 <ResetHandler+0xe0>
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(3);
#elif F_CPU == 180000000
	// config divisors: 180 MHz core, 60 MHz bus, 25.7 MHz flash, USB = IRC48M
	#if F_BUS == 60000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(2) | SIM_CLKDIV1_OUTDIV4(6);
     2b8:	4b38      	ldr	r3, [pc, #224]	; (39c <ResetHandler+0x1cc>)
     2ba:	4939      	ldr	r1, [pc, #228]	; (3a0 <ResetHandler+0x1d0>)
     2bc:	6019      	str	r1, [r3, #0]
	#elif F_BUS == 90000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(6);
	#else
	#error "This F_CPU & F_BUS combination is not supported"
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(0);
     2be:	2100      	movs	r1, #0
     2c0:	6059      	str	r1, [r3, #4]
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     2c2:	2320      	movs	r3, #32
     2c4:	7013      	strb	r3, [r2, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     2c6:	7993      	ldrb	r3, [r2, #6]
     2c8:	f003 030c 	and.w	r3, r3, #12
     2cc:	2b0c      	cmp	r3, #12
     2ce:	d1fa      	bne.n	2c6 <ResetHandler+0xf6>
	// now we're in PEE mode
	// trace is CPU clock, CLKOUT=OSCERCLK0
	#if defined(KINETISK)
	#if F_CPU == 256000000 || F_CPU == 216000000 || F_CPU == 180000000
	// USB uses IRC48
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
     2d0:	4b34      	ldr	r3, [pc, #208]	; (3a4 <ResetHandler+0x1d4>)
     2d2:	4a35      	ldr	r2, [pc, #212]	; (3a8 <ResetHandler+0x1d8>)
     2d4:	601a      	str	r2, [r3, #0]
#endif

#if defined(__MK66FX1M0__)
	// If the RTC oscillator isn't enabled, get it started.  For Teensy 3.6
	// we don't do this early.  See comment above about slow rising power.
	if (!(RTC_CR & RTC_CR_OSCE)) {
     2d6:	4a35      	ldr	r2, [pc, #212]	; (3ac <ResetHandler+0x1dc>)
     2d8:	4c35      	ldr	r4, [pc, #212]	; (3b0 <ResetHandler+0x1e0>)
     2da:	6813      	ldr	r3, [r2, #0]
     2dc:	f413 7380 	ands.w	r3, r3, #256	; 0x100
     2e0:	d103      	bne.n	2ea <ResetHandler+0x11a>
		RTC_SR = 0;
     2e2:	6023      	str	r3, [r4, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
     2e4:	f44f 53a8 	mov.w	r3, #5376	; 0x1500
     2e8:	6013      	str	r3, [r2, #0]
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     2ea:	4b32      	ldr	r3, [pc, #200]	; (3b4 <ResetHandler+0x1e4>)
     2ec:	4a32      	ldr	r2, [pc, #200]	; (3b8 <ResetHandler+0x1e8>)
     2ee:	601a      	str	r2, [r3, #0]
	SYST_CVR = 0;
     2f0:	2200      	movs	r2, #0
     2f2:	605a      	str	r2, [r3, #4]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     2f4:	2207      	movs	r2, #7
     2f6:	f843 2c04 	str.w	r2, [r3, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     2fa:	4a30      	ldr	r2, [pc, #192]	; (3bc <ResetHandler+0x1ec>)
     2fc:	f8c3 2d0c 	str.w	r2, [r3, #3340]	; 0xd0c

	//init_pins();
	__enable_irq();
     300:	b662      	cpsie	i

	_init_Teensyduino_internal_();
     302:	f005 f81f 	bl	5344 <_init_Teensyduino_internal_>

#if defined(KINETISK)
	// RTC initialization
	if (RTC_SR & RTC_SR_TIF) {
     306:	6823      	ldr	r3, [r4, #0]
     308:	07da      	lsls	r2, r3, #31
     30a:	d505      	bpl.n	318 <ResetHandler+0x148>
		// compiled-in time will be stale.  Write a special
		// flag into the VBAT register file indicating the
		// RTC is set with known-stale time and should be
		// updated when fresh time is known.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     30c:	482c      	ldr	r0, [pc, #176]	; (3c0 <ResetHandler+0x1f0>)
     30e:	f004 fde5 	bl	4edc <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
     312:	4b2c      	ldr	r3, [pc, #176]	; (3c4 <ResetHandler+0x1f4>)
     314:	4a2c      	ldr	r2, [pc, #176]	; (3c8 <ResetHandler+0x1f8>)
     316:	601a      	str	r2, [r3, #0]
	}
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
     318:	4b2c      	ldr	r3, [pc, #176]	; (3cc <ResetHandler+0x1fc>)
     31a:	781b      	ldrb	r3, [r3, #0]
     31c:	065b      	lsls	r3, r3, #25
     31e:	d509      	bpl.n	334 <ResetHandler+0x164>
     320:	4c28      	ldr	r4, [pc, #160]	; (3c4 <ResetHandler+0x1f4>)
     322:	4b29      	ldr	r3, [pc, #164]	; (3c8 <ResetHandler+0x1f8>)
     324:	6822      	ldr	r2, [r4, #0]
     326:	429a      	cmp	r2, r3
     328:	d104      	bne.n	334 <ResetHandler+0x164>
		// Our compiled-in time will be very fresh, so set
		// the RTC with this, and clear the VBAT resister file
		// data so we don't mess with the time after it's been
		// set well.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     32a:	4825      	ldr	r0, [pc, #148]	; (3c0 <ResetHandler+0x1f0>)
     32c:	f004 fdd6 	bl	4edc <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0;
     330:	2300      	movs	r3, #0
     332:	6023      	str	r3, [r4, #0]
	}
#endif

	__libc_init_array();
     334:	f008 f816 	bl	8364 <__libc_init_array>

	startup_late_hook();
     338:	f004 fca4 	bl	4c84 <startup_late_hook>
	main();
     33c:	f006 f852 	bl	63e4 <main>
     340:	e7fe      	b.n	340 <ResetHandler+0x170>
     342:	bf00      	nop
     344:	4005200e 	.word	0x4005200e
     348:	40048030 	.word	0x40048030
     34c:	00043f82 	.word	0x00043f82
     350:	2b000001 	.word	0x2b000001
     354:	e000ed88 	.word	0xe000ed88
     358:	e0082000 	.word	0xe0082000
     35c:	85000003 	.word	0x85000003
     360:	4007d002 	.word	0x4007d002
     364:	4007e000 	.word	0x4007e000
     368:	1fff141c 	.word	0x1fff141c
     36c:	00009e94 	.word	0x00009e94
     370:	1fff0730 	.word	0x1fff0730
     374:	1fff1420 	.word	0x1fff1420
     378:	1fff2d20 	.word	0x1fff2d20
     37c:	1fff0200 	.word	0x1fff0200
     380:	00000000 	.word	0x00000000
     384:	e000e400 	.word	0xe000e400
     388:	e000e464 	.word	0xe000e464
     38c:	e000ed08 	.word	0xe000ed08
     390:	40065000 	.word	0x40065000
     394:	40064000 	.word	0x40064000
     398:	4007e001 	.word	0x4007e001
     39c:	40048044 	.word	0x40048044
     3a0:	02060000 	.word	0x02060000
     3a4:	40048004 	.word	0x40048004
     3a8:	000710c0 	.word	0x000710c0
     3ac:	4003d010 	.word	0x4003d010
     3b0:	4003d014 	.word	0x4003d014
     3b4:	e000e014 	.word	0xe000e014
     3b8:	0002bf1f 	.word	0x0002bf1f
     3bc:	20200000 	.word	0x20200000
     3c0:	623afdd6 	.word	0x623afdd6
     3c4:	4003e01c 	.word	0x4003e01c
     3c8:	5a94c3a5 	.word	0x5a94c3a5
     3cc:	4007f000 	.word	0x4007f000
     3d0:	ffffffff 	.word	0xffffffff
     3d4:	ffffffff 	.word	0xffffffff
     3d8:	ffffffff 	.word	0xffffffff
     3dc:	ffffffff 	.word	0xffffffff
     3e0:	ffffffff 	.word	0xffffffff
     3e4:	ffffffff 	.word	0xffffffff
     3e8:	ffffffff 	.word	0xffffffff
     3ec:	ffffffff 	.word	0xffffffff
     3f0:	ffffffff 	.word	0xffffffff
     3f4:	ffffffff 	.word	0xffffffff
     3f8:	ffffffff 	.word	0xffffffff
     3fc:	ffffffff 	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	ffffffff ffffffff ffffffff fffff9de     ................

00000410 <__do_global_dtors_aux>:
     410:	b510      	push	{r4, lr}
     412:	4c05      	ldr	r4, [pc, #20]	; (428 <__do_global_dtors_aux+0x18>)
     414:	7823      	ldrb	r3, [r4, #0]
     416:	b933      	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
     418:	4b04      	ldr	r3, [pc, #16]	; (42c <__do_global_dtors_aux+0x1c>)
     41a:	b113      	cbz	r3, 422 <__do_global_dtors_aux+0x12>
     41c:	4804      	ldr	r0, [pc, #16]	; (430 <__do_global_dtors_aux+0x20>)
     41e:	f3af 8000 	nop.w
     422:	2301      	movs	r3, #1
     424:	7023      	strb	r3, [r4, #0]
     426:	bd10      	pop	{r4, pc}
     428:	1fff1420 	.word	0x1fff1420
     42c:	00000000 	.word	0x00000000
     430:	00009e98 	.word	0x00009e98

00000434 <frame_dummy>:
     434:	4b08      	ldr	r3, [pc, #32]	; (458 <frame_dummy+0x24>)
     436:	b510      	push	{r4, lr}
     438:	b11b      	cbz	r3, 442 <frame_dummy+0xe>
     43a:	4908      	ldr	r1, [pc, #32]	; (45c <frame_dummy+0x28>)
     43c:	4808      	ldr	r0, [pc, #32]	; (460 <frame_dummy+0x2c>)
     43e:	f3af 8000 	nop.w
     442:	4808      	ldr	r0, [pc, #32]	; (464 <frame_dummy+0x30>)
     444:	6803      	ldr	r3, [r0, #0]
     446:	b903      	cbnz	r3, 44a <frame_dummy+0x16>
     448:	bd10      	pop	{r4, pc}
     44a:	4b07      	ldr	r3, [pc, #28]	; (468 <frame_dummy+0x34>)
     44c:	2b00      	cmp	r3, #0
     44e:	d0fb      	beq.n	448 <frame_dummy+0x14>
     450:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     454:	4718      	bx	r3
     456:	bf00      	nop
     458:	00000000 	.word	0x00000000
     45c:	1fff1424 	.word	0x1fff1424
     460:	00009e98 	.word	0x00009e98
     464:	1fff141c 	.word	0x1fff141c
     468:	00000000 	.word	0x00000000

0000046c <std_msgs::Time::serialize(unsigned char*) const>:
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->data.sec >> (8 * 0)) & 0xFF;
     46c:	6843      	ldr	r3, [r0, #4]
     46e:	700b      	strb	r3, [r1, #0]
      *(outbuffer + offset + 1) = (this->data.sec >> (8 * 1)) & 0xFF;
     470:	6843      	ldr	r3, [r0, #4]
     472:	0a1b      	lsrs	r3, r3, #8
     474:	704b      	strb	r3, [r1, #1]
      *(outbuffer + offset + 2) = (this->data.sec >> (8 * 2)) & 0xFF;
     476:	88c3      	ldrh	r3, [r0, #6]
     478:	708b      	strb	r3, [r1, #2]
      *(outbuffer + offset + 3) = (this->data.sec >> (8 * 3)) & 0xFF;
     47a:	79c3      	ldrb	r3, [r0, #7]
     47c:	70cb      	strb	r3, [r1, #3]
      offset += sizeof(this->data.sec);
      *(outbuffer + offset + 0) = (this->data.nsec >> (8 * 0)) & 0xFF;
     47e:	6883      	ldr	r3, [r0, #8]
     480:	710b      	strb	r3, [r1, #4]
      *(outbuffer + offset + 1) = (this->data.nsec >> (8 * 1)) & 0xFF;
     482:	6883      	ldr	r3, [r0, #8]
     484:	0a1b      	lsrs	r3, r3, #8
     486:	714b      	strb	r3, [r1, #5]
      *(outbuffer + offset + 2) = (this->data.nsec >> (8 * 2)) & 0xFF;
     488:	8943      	ldrh	r3, [r0, #10]
     48a:	718b      	strb	r3, [r1, #6]
      *(outbuffer + offset + 3) = (this->data.nsec >> (8 * 3)) & 0xFF;
     48c:	7ac3      	ldrb	r3, [r0, #11]
     48e:	71cb      	strb	r3, [r1, #7]
      offset += sizeof(this->data.nsec);
      return offset;
    }
     490:	2008      	movs	r0, #8
     492:	4770      	bx	lr

00000494 <std_msgs::Time::deserialize(unsigned char*)>:

    virtual int deserialize(unsigned char *inbuffer) override
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
     494:	780b      	ldrb	r3, [r1, #0]
     496:	6043      	str	r3, [r0, #4]
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
     498:	784a      	ldrb	r2, [r1, #1]
     49a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
     49e:	6043      	str	r3, [r0, #4]
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
     4a0:	788a      	ldrb	r2, [r1, #2]
     4a2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
     4a6:	6043      	str	r3, [r0, #4]
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
     4a8:	78ca      	ldrb	r2, [r1, #3]
     4aa:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
     4ae:	6043      	str	r3, [r0, #4]
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
     4b0:	790b      	ldrb	r3, [r1, #4]
     4b2:	6083      	str	r3, [r0, #8]
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
     4b4:	794a      	ldrb	r2, [r1, #5]
     4b6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
     4ba:	6083      	str	r3, [r0, #8]
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
     4bc:	798a      	ldrb	r2, [r1, #6]
     4be:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
     4c2:	6083      	str	r3, [r0, #8]
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
     4c4:	79ca      	ldrb	r2, [r1, #7]
     4c6:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
     4ca:	6083      	str	r3, [r0, #8]
      offset += sizeof(this->data.nsec);
     return offset;
    }
     4cc:	2008      	movs	r0, #8
     4ce:	4770      	bx	lr

000004d0 <std_msgs::Time::getType()>:

    virtual const char * getType() override { return "std_msgs/Time"; };
     4d0:	4800      	ldr	r0, [pc, #0]	; (4d4 <std_msgs::Time::getType()+0x4>)
     4d2:	4770      	bx	lr
     4d4:	000097ec 	.word	0x000097ec

000004d8 <std_msgs::Time::getMD5()>:
    virtual const char * getMD5() override { return "cd7166c74c552c311fbcc2fe5a7bc289"; };
     4d8:	4800      	ldr	r0, [pc, #0]	; (4dc <std_msgs::Time::getMD5()+0x4>)
     4da:	4770      	bx	lr
     4dc:	000097fc 	.word	0x000097fc

000004e0 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)>:
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     4e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    {
      int offset = 0;
      this->topic_id =  ((uint16_t) (*(inbuffer + offset)));
      this->topic_id |= ((uint16_t) (*(inbuffer + offset + 1))) << (8 * 1);
     4e2:	460c      	mov	r4, r1
    }

    virtual int deserialize(unsigned char *inbuffer) override
    {
      int offset = 0;
      this->topic_id =  ((uint16_t) (*(inbuffer + offset)));
     4e4:	780a      	ldrb	r2, [r1, #0]
     4e6:	8082      	strh	r2, [r0, #4]
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     4e8:	4606      	mov	r6, r0
    {
      int offset = 0;
      this->topic_id =  ((uint16_t) (*(inbuffer + offset)));
      this->topic_id |= ((uint16_t) (*(inbuffer + offset + 1))) << (8 * 1);
     4ea:	f814 0f01 	ldrb.w	r0, [r4, #1]!
     4ee:	2300      	movs	r3, #0
     4f0:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
     4f4:	80b2      	strh	r2, [r6, #4]

  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
     4f6:	461a      	mov	r2, r3
    for (size_t i = 0; i < sizeof(V); i++)
      var |= (arr[i] << (8 * i));
     4f8:	f814 0f01 	ldrb.w	r0, [r4, #1]!
     4fc:	4098      	lsls	r0, r3
     4fe:	3308      	adds	r3, #8
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
     500:	2b20      	cmp	r3, #32
      var |= (arr[i] << (8 * i));
     502:	ea42 0200 	orr.w	r2, r2, r0
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
     506:	d1f7      	bne.n	4f8 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x18>
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name;
      arrToVar(length_topic_name, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_topic_name; ++k){
     508:	1d97      	adds	r7, r2, #6
     50a:	2f06      	cmp	r7, #6
     50c:	d958      	bls.n	5c0 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0xe0>
     50e:	f101 0e05 	add.w	lr, r1, #5
     512:	1d55      	adds	r5, r2, #5
     514:	4673      	mov	r3, lr
     516:	194c      	adds	r4, r1, r5
          inbuffer[k-1]=inbuffer[k];
     518:	f813 0f01 	ldrb.w	r0, [r3, #1]!
     51c:	f803 0c01 	strb.w	r0, [r3, #-1]
      this->topic_id |= ((uint16_t) (*(inbuffer + offset + 1))) << (8 * 1);
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name;
      arrToVar(length_topic_name, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_topic_name; ++k){
     520:	42a3      	cmp	r3, r4
     522:	d1f9      	bne.n	518 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x38>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_topic_name-1]=0;
     524:	2300      	movs	r3, #0
     526:	554b      	strb	r3, [r1, r5]
      this->topic_name = (char *)(inbuffer + offset-1);
      offset += length_topic_name;
     528:	4618      	mov	r0, r3
     52a:	440d      	add	r5, r1
      offset += 4;
      for(unsigned int k= offset; k< offset+length_topic_name; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_topic_name-1]=0;
      this->topic_name = (char *)(inbuffer + offset-1);
     52c:	f8c6 e008 	str.w	lr, [r6, #8]
      var |= (arr[i] << (8 * i));
     530:	f815 4f01 	ldrb.w	r4, [r5, #1]!
     534:	4084      	lsls	r4, r0
     536:	3008      	adds	r0, #8
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
     538:	2820      	cmp	r0, #32
      var |= (arr[i] << (8 * i));
     53a:	ea43 0304 	orr.w	r3, r3, r4
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
     53e:	d1f7      	bne.n	530 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x50>
      offset += length_topic_name;
      uint32_t length_message_type;
      arrToVar(length_message_type, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_message_type; ++k){
     540:	1d38      	adds	r0, r7, #4
     542:	4403      	add	r3, r0
     544:	4283      	cmp	r3, r0
     546:	d909      	bls.n	55c <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x7c>
     548:	3209      	adds	r2, #9
     54a:	440a      	add	r2, r1
     54c:	4604      	mov	r4, r0
     54e:	3401      	adds	r4, #1
          inbuffer[k-1]=inbuffer[k];
     550:	f812 5f01 	ldrb.w	r5, [r2, #1]!
     554:	f802 5c01 	strb.w	r5, [r2, #-1]
      this->topic_name = (char *)(inbuffer + offset-1);
      offset += length_topic_name;
      uint32_t length_message_type;
      arrToVar(length_message_type, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_message_type; ++k){
     558:	42a3      	cmp	r3, r4
     55a:	d8f8      	bhi.n	54e <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x6e>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_message_type-1]=0;
      this->message_type = (char *)(inbuffer + offset-1);
     55c:	3801      	subs	r0, #1
      arrToVar(length_message_type, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_message_type; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_message_type-1]=0;
     55e:	18cf      	adds	r7, r1, r3
     560:	2400      	movs	r4, #0
      this->message_type = (char *)(inbuffer + offset-1);
     562:	4408      	add	r0, r1
      arrToVar(length_message_type, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_message_type; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_message_type-1]=0;
     564:	f807 4c01 	strb.w	r4, [r7, #-1]
      this->message_type = (char *)(inbuffer + offset-1);
      offset += length_message_type;
     568:	4622      	mov	r2, r4
      offset += 4;
      for(unsigned int k= offset; k< offset+length_message_type; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_message_type-1]=0;
      this->message_type = (char *)(inbuffer + offset-1);
     56a:	60f0      	str	r0, [r6, #12]
      var |= (arr[i] << (8 * i));
     56c:	f817 5b01 	ldrb.w	r5, [r7], #1
     570:	4095      	lsls	r5, r2
     572:	3208      	adds	r2, #8
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
     574:	2a20      	cmp	r2, #32
      var |= (arr[i] << (8 * i));
     576:	ea44 0405 	orr.w	r4, r4, r5
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
     57a:	d1f7      	bne.n	56c <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x8c>
      offset += length_message_type;
      uint32_t length_md5sum;
      arrToVar(length_md5sum, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_md5sum; ++k){
     57c:	1d18      	adds	r0, r3, #4
     57e:	4404      	add	r4, r0
     580:	42a0      	cmp	r0, r4
     582:	d209      	bcs.n	598 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0xb8>
     584:	3303      	adds	r3, #3
     586:	440b      	add	r3, r1
     588:	4602      	mov	r2, r0
     58a:	3201      	adds	r2, #1
          inbuffer[k-1]=inbuffer[k];
     58c:	f813 5f01 	ldrb.w	r5, [r3, #1]!
     590:	f803 5c01 	strb.w	r5, [r3, #-1]
      this->message_type = (char *)(inbuffer + offset-1);
      offset += length_message_type;
      uint32_t length_md5sum;
      arrToVar(length_md5sum, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_md5sum; ++k){
     594:	42a2      	cmp	r2, r4
     596:	d3f8      	bcc.n	58a <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0xaa>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_md5sum-1]=0;
     598:	190d      	adds	r5, r1, r4
      this->md5sum = (char *)(inbuffer + offset-1);
     59a:	3801      	subs	r0, #1
     59c:	4408      	add	r0, r1
      arrToVar(length_md5sum, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_md5sum; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_md5sum-1]=0;
     59e:	2300      	movs	r3, #0
     5a0:	f805 3c01 	strb.w	r3, [r5, #-1]
      this->md5sum = (char *)(inbuffer + offset-1);
     5a4:	6130      	str	r0, [r6, #16]
      u_buffer_size.base = 0;
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->buffer_size = u_buffer_size.real;
     5a6:	78a8      	ldrb	r0, [r5, #2]
     5a8:	786b      	ldrb	r3, [r5, #1]
     5aa:	5d0a      	ldrb	r2, [r1, r4]
     5ac:	78ed      	ldrb	r5, [r5, #3]
     5ae:	0401      	lsls	r1, r0, #16
     5b0:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
     5b4:	4313      	orrs	r3, r2
     5b6:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
      offset += sizeof(this->buffer_size);
     return offset;
     5ba:	1d20      	adds	r0, r4, #4
      u_buffer_size.base = 0;
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->buffer_size = u_buffer_size.real;
     5bc:	6173      	str	r3, [r6, #20]
      offset += sizeof(this->buffer_size);
     return offset;
    }
     5be:	bdf0      	pop	{r4, r5, r6, r7, pc}
     5c0:	1d55      	adds	r5, r2, #5
     5c2:	f101 0e05 	add.w	lr, r1, #5
     5c6:	e7ad      	b.n	524 <rosserial_msgs::TopicInfo::deserialize(unsigned char*)+0x44>

000005c8 <rosserial_msgs::TopicInfo::getType()>:

    virtual const char * getType() override { return "rosserial_msgs/TopicInfo"; };
     5c8:	4800      	ldr	r0, [pc, #0]	; (5cc <rosserial_msgs::TopicInfo::getType()+0x4>)
     5ca:	4770      	bx	lr
     5cc:	00009820 	.word	0x00009820

000005d0 <rosserial_msgs::TopicInfo::getMD5()>:
    virtual const char * getMD5() override { return "0ad51f88fc44892f8c10684077646005"; };
     5d0:	4800      	ldr	r0, [pc, #0]	; (5d4 <rosserial_msgs::TopicInfo::getMD5()+0x4>)
     5d2:	4770      	bx	lr
     5d4:	0000983c 	.word	0x0000983c

000005d8 <rosserial_msgs::Log::deserialize(unsigned char*)>:
    }

    virtual int deserialize(unsigned char *inbuffer) override
    {
      int offset = 0;
      this->level =  ((uint8_t) (*(inbuffer + offset)));
     5d8:	780b      	ldrb	r3, [r1, #0]
      memcpy(outbuffer + offset, this->msg, length_msg);
      offset += length_msg;
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     5da:	b4f0      	push	{r4, r5, r6, r7}
    {
      int offset = 0;
      this->level =  ((uint8_t) (*(inbuffer + offset)));
     5dc:	7103      	strb	r3, [r0, #4]
     5de:	2300      	movs	r3, #0
      memcpy(outbuffer + offset, this->msg, length_msg);
      offset += length_msg;
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     5e0:	4606      	mov	r6, r0
     5e2:	460c      	mov	r4, r1

  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
     5e4:	461d      	mov	r5, r3
    for (size_t i = 0; i < sizeof(V); i++)
      var |= (arr[i] << (8 * i));
     5e6:	f814 2f01 	ldrb.w	r2, [r4, #1]!
     5ea:	409a      	lsls	r2, r3
     5ec:	3308      	adds	r3, #8
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
     5ee:	2b20      	cmp	r3, #32
      var |= (arr[i] << (8 * i));
     5f0:	ea45 0502 	orr.w	r5, r5, r2
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
     5f4:	d1f7      	bne.n	5e6 <rosserial_msgs::Log::deserialize(unsigned char*)+0xe>
      this->level =  ((uint8_t) (*(inbuffer + offset)));
      offset += sizeof(this->level);
      uint32_t length_msg;
      arrToVar(length_msg, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_msg; ++k){
     5f6:	1d68      	adds	r0, r5, #5
     5f8:	2805      	cmp	r0, #5
     5fa:	f101 0704 	add.w	r7, r1, #4
     5fe:	d908      	bls.n	612 <rosserial_msgs::Log::deserialize(unsigned char*)+0x3a>
     600:	1d2c      	adds	r4, r5, #4
     602:	463b      	mov	r3, r7
     604:	440c      	add	r4, r1
          inbuffer[k-1]=inbuffer[k];
     606:	f813 2f01 	ldrb.w	r2, [r3, #1]!
     60a:	f803 2c01 	strb.w	r2, [r3, #-1]
      this->level =  ((uint8_t) (*(inbuffer + offset)));
      offset += sizeof(this->level);
      uint32_t length_msg;
      arrToVar(length_msg, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_msg; ++k){
     60e:	429c      	cmp	r4, r3
     610:	d1f9      	bne.n	606 <rosserial_msgs::Log::deserialize(unsigned char*)+0x2e>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_msg-1]=0;
     612:	440d      	add	r5, r1
     614:	2300      	movs	r3, #0
     616:	712b      	strb	r3, [r5, #4]
      this->msg = (char *)(inbuffer + offset-1);
     618:	60b7      	str	r7, [r6, #8]
      offset += length_msg;
     return offset;
    }
     61a:	bcf0      	pop	{r4, r5, r6, r7}
     61c:	4770      	bx	lr
     61e:	bf00      	nop

00000620 <rosserial_msgs::Log::getType()>:

    virtual const char * getType() override { return "rosserial_msgs/Log"; };
     620:	4800      	ldr	r0, [pc, #0]	; (624 <rosserial_msgs::Log::getType()+0x4>)
     622:	4770      	bx	lr
     624:	00009860 	.word	0x00009860

00000628 <rosserial_msgs::Log::getMD5()>:
    virtual const char * getMD5() override { return "11abd731c25933261cd6183bd12d6295"; };
     628:	4800      	ldr	r0, [pc, #0]	; (62c <rosserial_msgs::Log::getMD5()+0x4>)
     62a:	4770      	bx	lr
     62c:	00009874 	.word	0x00009874

00000630 <rosserial_msgs::RequestParamResponse::getType()>:
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
      }
     return offset;
    }

    virtual const char * getType() override { return REQUESTPARAM; };
     630:	4800      	ldr	r0, [pc, #0]	; (634 <rosserial_msgs::RequestParamResponse::getType()+0x4>)
     632:	4770      	bx	lr
     634:	000097d0 	.word	0x000097d0

00000638 <rosserial_msgs::RequestParamResponse::getMD5()>:
    virtual const char * getMD5() override { return "9f0e98bda65981986ddf53afa7a40e49"; };
     638:	4800      	ldr	r0, [pc, #0]	; (63c <rosserial_msgs::RequestParamResponse::getMD5()+0x4>)
     63a:	4770      	bx	lr
     63c:	00009898 	.word	0x00009898

00000640 <std_msgs::Int16::serialize(unsigned char*) const>:
      int offset = 0;
      union {
        int16_t real;
        uint16_t base;
      } u_data;
      u_data.real = this->data;
     640:	f9b0 3004 	ldrsh.w	r3, [r0, #4]
      *(outbuffer + offset + 0) = (u_data.base >> (8 * 0)) & 0xFF;
     644:	700b      	strb	r3, [r1, #0]
      *(outbuffer + offset + 1) = (u_data.base >> (8 * 1)) & 0xFF;
     646:	f3c3 2207 	ubfx	r2, r3, #8, #8
     64a:	704a      	strb	r2, [r1, #1]
      offset += sizeof(this->data);
      return offset;
    }
     64c:	2002      	movs	r0, #2
     64e:	4770      	bx	lr

00000650 <std_msgs::Int16::deserialize(unsigned char*)>:
        uint16_t base;
      } u_data;
      u_data.base = 0;
      u_data.base |= ((uint16_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_data.base |= ((uint16_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data = u_data.real;
     650:	784a      	ldrb	r2, [r1, #1]
     652:	780b      	ldrb	r3, [r1, #0]
     654:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
     658:	8083      	strh	r3, [r0, #4]
      offset += sizeof(this->data);
     return offset;
    }
     65a:	2002      	movs	r0, #2
     65c:	4770      	bx	lr
     65e:	bf00      	nop

00000660 <std_msgs::Int16::getType()>:

    virtual const char * getType() override { return "std_msgs/Int16"; };
     660:	4800      	ldr	r0, [pc, #0]	; (664 <std_msgs::Int16::getType()+0x4>)
     662:	4770      	bx	lr
     664:	000098bc 	.word	0x000098bc

00000668 <std_msgs::Int16::getMD5()>:
    virtual const char * getMD5() override { return "8524586e34fbd7cb1c08c5f5f1ca0e57"; };
     668:	4800      	ldr	r0, [pc, #0]	; (66c <std_msgs::Int16::getMD5()+0x4>)
     66a:	4770      	bx	lr
     66c:	000098cc 	.word	0x000098cc

00000670 <std_msgs::Float32::serialize(unsigned char*) const>:
      union {
        float real;
        uint32_t base;
      } u_data;
      u_data.real = this->data;
      *(outbuffer + offset + 0) = (u_data.base >> (8 * 0)) & 0xFF;
     670:	6843      	ldr	r3, [r0, #4]
     672:	700b      	strb	r3, [r1, #0]
    Float32():
      data(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
     674:	b410      	push	{r4}
        uint32_t base;
      } u_data;
      u_data.real = this->data;
      *(outbuffer + offset + 0) = (u_data.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_data.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_data.base >> (8 * 2)) & 0xFF;
     676:	0c18      	lsrs	r0, r3, #16
        float real;
        uint32_t base;
      } u_data;
      u_data.real = this->data;
      *(outbuffer + offset + 0) = (u_data.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_data.base >> (8 * 1)) & 0xFF;
     678:	0a1c      	lsrs	r4, r3, #8
      *(outbuffer + offset + 2) = (u_data.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_data.base >> (8 * 3)) & 0xFF;
     67a:	0e1a      	lsrs	r2, r3, #24
        float real;
        uint32_t base;
      } u_data;
      u_data.real = this->data;
      *(outbuffer + offset + 0) = (u_data.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_data.base >> (8 * 1)) & 0xFF;
     67c:	704c      	strb	r4, [r1, #1]
      *(outbuffer + offset + 2) = (u_data.base >> (8 * 2)) & 0xFF;
     67e:	7088      	strb	r0, [r1, #2]
      *(outbuffer + offset + 3) = (u_data.base >> (8 * 3)) & 0xFF;
     680:	70ca      	strb	r2, [r1, #3]
      offset += sizeof(this->data);
      return offset;
    }
     682:	2004      	movs	r0, #4
     684:	f85d 4b04 	ldr.w	r4, [sp], #4
     688:	4770      	bx	lr
     68a:	bf00      	nop

0000068c <std_msgs::Float32::deserialize(unsigned char*)>:

    virtual int deserialize(unsigned char *inbuffer) override
     68c:	b410      	push	{r4}
      } u_data;
      u_data.base = 0;
      u_data.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_data.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_data.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_data.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
     68e:	784c      	ldrb	r4, [r1, #1]
     690:	780a      	ldrb	r2, [r1, #0]
     692:	788b      	ldrb	r3, [r1, #2]
     694:	78c9      	ldrb	r1, [r1, #3]
     696:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
     69a:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
      this->data = u_data.real;
     69e:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
     6a2:	6043      	str	r3, [r0, #4]
      offset += sizeof(this->data);
     return offset;
    }
     6a4:	f85d 4b04 	ldr.w	r4, [sp], #4
     6a8:	2004      	movs	r0, #4
     6aa:	4770      	bx	lr

000006ac <std_msgs::Float32::getType()>:

    virtual const char * getType() override { return "std_msgs/Float32"; };
     6ac:	4800      	ldr	r0, [pc, #0]	; (6b0 <std_msgs::Float32::getType()+0x4>)
     6ae:	4770      	bx	lr
     6b0:	000098f0 	.word	0x000098f0

000006b4 <std_msgs::Float32::getMD5()>:
    virtual const char * getMD5() override { return "73fcbf46b49191e672908e50842a83d4"; };
     6b4:	4800      	ldr	r0, [pc, #0]	; (6b8 <std_msgs::Float32::getMD5()+0x4>)
     6b6:	4770      	bx	lr
     6b8:	00009904 	.word	0x00009904

000006bc <geometry_msgs::Vector3::serialize(unsigned char*) const>:
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
     6bc:	6882      	ldr	r2, [r0, #8]
     6be:	68c3      	ldr	r3, [r0, #12]
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
     6c0:	710b      	strb	r3, [r1, #4]
      y(0),
      z(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
     6c2:	b4f0      	push	{r4, r5, r6, r7}
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
     6c4:	0a14      	lsrs	r4, r2, #8
     6c6:	704c      	strb	r4, [r1, #1]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
     6c8:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
     6ca:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
     6cc:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
     6ce:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
     6d0:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
     6d2:	708f      	strb	r7, [r1, #2]
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
     6d4:	70ce      	strb	r6, [r1, #3]
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
     6d6:	714d      	strb	r5, [r1, #5]
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
     6d8:	718c      	strb	r4, [r1, #6]
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
     6da:	700a      	strb	r2, [r1, #0]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
     6dc:	71cb      	strb	r3, [r1, #7]
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
     6de:	6902      	ldr	r2, [r0, #16]
     6e0:	6943      	ldr	r3, [r0, #20]
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
     6e2:	730b      	strb	r3, [r1, #12]
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
     6e4:	0a14      	lsrs	r4, r2, #8
     6e6:	724c      	strb	r4, [r1, #9]
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
     6e8:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
     6ea:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
     6ec:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
     6ee:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
     6f0:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
     6f2:	728f      	strb	r7, [r1, #10]
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
     6f4:	72ce      	strb	r6, [r1, #11]
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
     6f6:	734d      	strb	r5, [r1, #13]
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
     6f8:	738c      	strb	r4, [r1, #14]
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
     6fa:	720a      	strb	r2, [r1, #8]
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
     6fc:	73cb      	strb	r3, [r1, #15]
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
     6fe:	6982      	ldr	r2, [r0, #24]
     700:	69c3      	ldr	r3, [r0, #28]
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
     702:	750b      	strb	r3, [r1, #20]
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
     704:	0a1c      	lsrs	r4, r3, #8
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
     706:	0c18      	lsrs	r0, r3, #16
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
     708:	0a17      	lsrs	r7, r2, #8
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
     70a:	0c16      	lsrs	r6, r2, #16
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
     70c:	0e15      	lsrs	r5, r2, #24
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
     70e:	0e1b      	lsrs	r3, r3, #24
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
     710:	7588      	strb	r0, [r1, #22]
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
     712:	740a      	strb	r2, [r1, #16]
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
     714:	744f      	strb	r7, [r1, #17]
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
     716:	748e      	strb	r6, [r1, #18]
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
     718:	74cd      	strb	r5, [r1, #19]
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
     71a:	754c      	strb	r4, [r1, #21]
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
     71c:	75cb      	strb	r3, [r1, #23]
      offset += sizeof(this->z);
      return offset;
    }
     71e:	2018      	movs	r0, #24
     720:	bcf0      	pop	{r4, r5, r6, r7}
     722:	4770      	bx	lr

00000724 <geometry_msgs::Vector3::deserialize(unsigned char*)>:

    virtual int deserialize(unsigned char *inbuffer) override
     724:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
     728:	f891 c001 	ldrb.w	ip, [r1, #1]
     72c:	f891 e000 	ldrb.w	lr, [r1]
     730:	790f      	ldrb	r7, [r1, #4]
     732:	f891 b002 	ldrb.w	fp, [r1, #2]
     736:	f891 a003 	ldrb.w	sl, [r1, #3]
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
      offset += sizeof(this->z);
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     73a:	4606      	mov	r6, r0
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
     73c:	7948      	ldrb	r0, [r1, #5]
     73e:	ea4e 2e0c 	orr.w	lr, lr, ip, lsl #8
     742:	f891 c006 	ldrb.w	ip, [r1, #6]
     746:	ea47 2000 	orr.w	r0, r7, r0, lsl #8
     74a:	79cf      	ldrb	r7, [r1, #7]
     74c:	ea4e 4e0b 	orr.w	lr, lr, fp, lsl #16
     750:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
     754:	ea4e 680a 	orr.w	r8, lr, sl, lsl #24
     758:	ea40 6907 	orr.w	r9, r0, r7, lsl #24
      this->x = u_x.real;
     75c:	e9c6 8902 	strd	r8, r9, [r6, #8]
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
     760:	f891 c008 	ldrb.w	ip, [r1, #8]
     764:	f891 e009 	ldrb.w	lr, [r1, #9]
     768:	7b0f      	ldrb	r7, [r1, #12]
     76a:	7b48      	ldrb	r0, [r1, #13]
     76c:	f891 900a 	ldrb.w	r9, [r1, #10]
     770:	f891 800b 	ldrb.w	r8, [r1, #11]
     774:	ea4c 2e0e 	orr.w	lr, ip, lr, lsl #8
     778:	f891 c00e 	ldrb.w	ip, [r1, #14]
     77c:	ea47 2000 	orr.w	r0, r7, r0, lsl #8
     780:	7bcf      	ldrb	r7, [r1, #15]
     782:	ea4e 4e09 	orr.w	lr, lr, r9, lsl #16
     786:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
     78a:	ea4e 6408 	orr.w	r4, lr, r8, lsl #24
     78e:	ea40 6507 	orr.w	r5, r0, r7, lsl #24
      this->y = u_y.real;
     792:	e9c6 4504 	strd	r4, r5, [r6, #16]
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
     796:	7c0d      	ldrb	r5, [r1, #16]
     798:	7c4c      	ldrb	r4, [r1, #17]
     79a:	7d08      	ldrb	r0, [r1, #20]
     79c:	f891 c015 	ldrb.w	ip, [r1, #21]
     7a0:	f891 8012 	ldrb.w	r8, [r1, #18]
     7a4:	7d8f      	ldrb	r7, [r1, #22]
     7a6:	f891 e013 	ldrb.w	lr, [r1, #19]
     7aa:	ea45 2404 	orr.w	r4, r5, r4, lsl #8
     7ae:	7dcd      	ldrb	r5, [r1, #23]
     7b0:	ea40 210c 	orr.w	r1, r0, ip, lsl #8
     7b4:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
     7b8:	ea41 4107 	orr.w	r1, r1, r7, lsl #16
     7bc:	ea44 620e 	orr.w	r2, r4, lr, lsl #24
     7c0:	ea41 6305 	orr.w	r3, r1, r5, lsl #24
      this->z = u_z.real;
      offset += sizeof(this->z);
     return offset;
    }
     7c4:	2018      	movs	r0, #24
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
      this->z = u_z.real;
     7c6:	e9c6 2306 	strd	r2, r3, [r6, #24]
      offset += sizeof(this->z);
     return offset;
    }
     7ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     7ce:	bf00      	nop

000007d0 <geometry_msgs::Vector3::getType()>:

    virtual const char * getType() override { return "geometry_msgs/Vector3"; };
     7d0:	4800      	ldr	r0, [pc, #0]	; (7d4 <geometry_msgs::Vector3::getType()+0x4>)
     7d2:	4770      	bx	lr
     7d4:	00009928 	.word	0x00009928

000007d8 <geometry_msgs::Vector3::getMD5()>:
    virtual const char * getMD5() override { return "4a842b65f413084dc2b10fb484ea7f17"; };
     7d8:	4800      	ldr	r0, [pc, #0]	; (7dc <geometry_msgs::Vector3::getMD5()+0x4>)
     7da:	4770      	bx	lr
     7dc:	00009940 	.word	0x00009940

000007e0 <geometry_msgs::Quaternion::serialize(unsigned char*) const>:
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
     7e0:	6882      	ldr	r2, [r0, #8]
     7e2:	68c3      	ldr	r3, [r0, #12]
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
     7e4:	710b      	strb	r3, [r1, #4]
      z(0),
      w(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
     7e6:	b4f0      	push	{r4, r5, r6, r7}
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
     7e8:	0a14      	lsrs	r4, r2, #8
     7ea:	704c      	strb	r4, [r1, #1]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
     7ec:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
     7ee:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
     7f0:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
     7f2:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
     7f4:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
     7f6:	708f      	strb	r7, [r1, #2]
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
     7f8:	70ce      	strb	r6, [r1, #3]
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
     7fa:	714d      	strb	r5, [r1, #5]
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
     7fc:	718c      	strb	r4, [r1, #6]
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
     7fe:	700a      	strb	r2, [r1, #0]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
     800:	71cb      	strb	r3, [r1, #7]
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
     802:	6902      	ldr	r2, [r0, #16]
     804:	6943      	ldr	r3, [r0, #20]
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
     806:	730b      	strb	r3, [r1, #12]
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
     808:	0a14      	lsrs	r4, r2, #8
     80a:	724c      	strb	r4, [r1, #9]
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
     80c:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
     80e:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
     810:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
     812:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
     814:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
     816:	728f      	strb	r7, [r1, #10]
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
     818:	72ce      	strb	r6, [r1, #11]
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
     81a:	734d      	strb	r5, [r1, #13]
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
     81c:	738c      	strb	r4, [r1, #14]
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
     81e:	720a      	strb	r2, [r1, #8]
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
     820:	73cb      	strb	r3, [r1, #15]
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
     822:	6982      	ldr	r2, [r0, #24]
     824:	69c3      	ldr	r3, [r0, #28]
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
     826:	750b      	strb	r3, [r1, #20]
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
     828:	0a14      	lsrs	r4, r2, #8
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
     82a:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
     82c:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
     82e:	0a1d      	lsrs	r5, r3, #8
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
     830:	744c      	strb	r4, [r1, #17]
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
     832:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
     834:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
     836:	748f      	strb	r7, [r1, #18]
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
     838:	74ce      	strb	r6, [r1, #19]
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
     83a:	754d      	strb	r5, [r1, #21]
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
     83c:	758c      	strb	r4, [r1, #22]
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
     83e:	740a      	strb	r2, [r1, #16]
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
     840:	75cb      	strb	r3, [r1, #23]
      union {
        double real;
        uint64_t base;
      } u_w;
      u_w.real = this->w;
      *(outbuffer + offset + 0) = (u_w.base >> (8 * 0)) & 0xFF;
     842:	6a03      	ldr	r3, [r0, #32]
     844:	6a42      	ldr	r2, [r0, #36]	; 0x24
     846:	760b      	strb	r3, [r1, #24]
      *(outbuffer + offset + 1) = (u_w.base >> (8 * 1)) & 0xFF;
     848:	0a1f      	lsrs	r7, r3, #8
      *(outbuffer + offset + 2) = (u_w.base >> (8 * 2)) & 0xFF;
     84a:	0c1e      	lsrs	r6, r3, #16
      *(outbuffer + offset + 3) = (u_w.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_w.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_w.base >> (8 * 5)) & 0xFF;
     84c:	0a15      	lsrs	r5, r2, #8
      *(outbuffer + offset + 6) = (u_w.base >> (8 * 6)) & 0xFF;
     84e:	0c14      	lsrs	r4, r2, #16
      *(outbuffer + offset + 7) = (u_w.base >> (8 * 7)) & 0xFF;
     850:	0e10      	lsrs	r0, r2, #24
      } u_w;
      u_w.real = this->w;
      *(outbuffer + offset + 0) = (u_w.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_w.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_w.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_w.base >> (8 * 3)) & 0xFF;
     852:	0e1b      	lsrs	r3, r3, #24
        double real;
        uint64_t base;
      } u_w;
      u_w.real = this->w;
      *(outbuffer + offset + 0) = (u_w.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_w.base >> (8 * 1)) & 0xFF;
     854:	764f      	strb	r7, [r1, #25]
      *(outbuffer + offset + 2) = (u_w.base >> (8 * 2)) & 0xFF;
     856:	768e      	strb	r6, [r1, #26]
      *(outbuffer + offset + 3) = (u_w.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_w.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_w.base >> (8 * 5)) & 0xFF;
     858:	774d      	strb	r5, [r1, #29]
      *(outbuffer + offset + 6) = (u_w.base >> (8 * 6)) & 0xFF;
     85a:	778c      	strb	r4, [r1, #30]
      *(outbuffer + offset + 7) = (u_w.base >> (8 * 7)) & 0xFF;
     85c:	77c8      	strb	r0, [r1, #31]
      u_w.real = this->w;
      *(outbuffer + offset + 0) = (u_w.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_w.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_w.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_w.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_w.base >> (8 * 4)) & 0xFF;
     85e:	770a      	strb	r2, [r1, #28]
      *(outbuffer + offset + 5) = (u_w.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_w.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_w.base >> (8 * 7)) & 0xFF;
      offset += sizeof(this->w);
      return offset;
    }
     860:	2020      	movs	r0, #32
      } u_w;
      u_w.real = this->w;
      *(outbuffer + offset + 0) = (u_w.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_w.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_w.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_w.base >> (8 * 3)) & 0xFF;
     862:	76cb      	strb	r3, [r1, #27]
      *(outbuffer + offset + 5) = (u_w.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_w.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_w.base >> (8 * 7)) & 0xFF;
      offset += sizeof(this->w);
      return offset;
    }
     864:	bcf0      	pop	{r4, r5, r6, r7}
     866:	4770      	bx	lr

00000868 <geometry_msgs::Quaternion::deserialize(unsigned char*)>:

    virtual int deserialize(unsigned char *inbuffer) override
     868:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
     86c:	f891 9001 	ldrb.w	r9, [r1, #1]
     870:	f891 c000 	ldrb.w	ip, [r1]
     874:	f891 e004 	ldrb.w	lr, [r1, #4]
     878:	f891 b002 	ldrb.w	fp, [r1, #2]
     87c:	f891 a003 	ldrb.w	sl, [r1, #3]
      *(outbuffer + offset + 7) = (u_w.base >> (8 * 7)) & 0xFF;
      offset += sizeof(this->w);
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     880:	4680      	mov	r8, r0
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
     882:	7948      	ldrb	r0, [r1, #5]
     884:	ea4c 2c09 	orr.w	ip, ip, r9, lsl #8
     888:	f891 9006 	ldrb.w	r9, [r1, #6]
     88c:	ea4e 2000 	orr.w	r0, lr, r0, lsl #8
     890:	f891 e007 	ldrb.w	lr, [r1, #7]
     894:	ea4c 4c0b 	orr.w	ip, ip, fp, lsl #16
     898:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
     89c:	ea4c 660a 	orr.w	r6, ip, sl, lsl #24
     8a0:	ea40 670e 	orr.w	r7, r0, lr, lsl #24
      this->x = u_x.real;
     8a4:	e9c8 6702 	strd	r6, r7, [r8, #8]
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
     8a8:	f891 e009 	ldrb.w	lr, [r1, #9]
     8ac:	7a0f      	ldrb	r7, [r1, #8]
     8ae:	7b0e      	ldrb	r6, [r1, #12]
     8b0:	7b48      	ldrb	r0, [r1, #13]
     8b2:	f891 900a 	ldrb.w	r9, [r1, #10]
     8b6:	f891 c00b 	ldrb.w	ip, [r1, #11]
     8ba:	ea47 270e 	orr.w	r7, r7, lr, lsl #8
     8be:	f891 e00e 	ldrb.w	lr, [r1, #14]
     8c2:	ea46 2000 	orr.w	r0, r6, r0, lsl #8
     8c6:	7bce      	ldrb	r6, [r1, #15]
     8c8:	ea47 4709 	orr.w	r7, r7, r9, lsl #16
     8cc:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     8d0:	ea47 640c 	orr.w	r4, r7, ip, lsl #24
     8d4:	ea40 6506 	orr.w	r5, r0, r6, lsl #24
      this->y = u_y.real;
     8d8:	e9c8 4504 	strd	r4, r5, [r8, #16]
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
     8dc:	7c0e      	ldrb	r6, [r1, #16]
     8de:	7c4d      	ldrb	r5, [r1, #17]
     8e0:	7d0c      	ldrb	r4, [r1, #20]
     8e2:	7d48      	ldrb	r0, [r1, #21]
     8e4:	f891 e012 	ldrb.w	lr, [r1, #18]
     8e8:	7ccf      	ldrb	r7, [r1, #19]
     8ea:	ea46 2505 	orr.w	r5, r6, r5, lsl #8
     8ee:	7d8e      	ldrb	r6, [r1, #22]
     8f0:	ea44 2000 	orr.w	r0, r4, r0, lsl #8
     8f4:	7dcc      	ldrb	r4, [r1, #23]
     8f6:	ea45 450e 	orr.w	r5, r5, lr, lsl #16
     8fa:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
     8fe:	ea45 6207 	orr.w	r2, r5, r7, lsl #24
     902:	ea40 6304 	orr.w	r3, r0, r4, lsl #24
      this->z = u_z.real;
     906:	e9c8 2306 	strd	r2, r3, [r8, #24]
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
     90a:	7e4c      	ldrb	r4, [r1, #25]
     90c:	7e08      	ldrb	r0, [r1, #24]
     90e:	7e8f      	ldrb	r7, [r1, #26]
     910:	7ece      	ldrb	r6, [r1, #27]
     912:	7f0a      	ldrb	r2, [r1, #28]
     914:	7f4b      	ldrb	r3, [r1, #29]
     916:	7f8d      	ldrb	r5, [r1, #30]
     918:	ea40 2004 	orr.w	r0, r0, r4, lsl #8
     91c:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
     920:	7fcc      	ldrb	r4, [r1, #31]
      *(outbuffer + offset + 7) = (u_w.base >> (8 * 7)) & 0xFF;
      offset += sizeof(this->w);
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     922:	b083      	sub	sp, #12
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
     924:	ea40 4107 	orr.w	r1, r0, r7, lsl #16
     928:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
     92c:	ea41 6206 	orr.w	r2, r1, r6, lsl #24
     930:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
     934:	9200      	str	r2, [sp, #0]
     936:	9301      	str	r3, [sp, #4]
      this->w = u_w.real;
     938:	e9dd 2300 	ldrd	r2, r3, [sp]
      offset += sizeof(this->w);
     return offset;
    }
     93c:	2020      	movs	r0, #32
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_w.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
      this->w = u_w.real;
     93e:	e9c8 2308 	strd	r2, r3, [r8, #32]
      offset += sizeof(this->w);
     return offset;
    }
     942:	b003      	add	sp, #12
     944:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00000948 <geometry_msgs::Quaternion::getType()>:

    virtual const char * getType() override { return "geometry_msgs/Quaternion"; };
     948:	4800      	ldr	r0, [pc, #0]	; (94c <geometry_msgs::Quaternion::getType()+0x4>)
     94a:	4770      	bx	lr
     94c:	00009964 	.word	0x00009964

00000950 <geometry_msgs::Quaternion::getMD5()>:
    virtual const char * getMD5() override { return "a779879fadf0160734f906b8c19c7004"; };
     950:	4800      	ldr	r0, [pc, #0]	; (954 <geometry_msgs::Quaternion::getMD5()+0x4>)
     952:	4770      	bx	lr
     954:	00009980 	.word	0x00009980

00000958 <geometry_msgs::Twist::getType()>:
      offset += this->linear.deserialize(inbuffer + offset);
      offset += this->angular.deserialize(inbuffer + offset);
     return offset;
    }

    virtual const char * getType() override { return "geometry_msgs/Twist"; };
     958:	4800      	ldr	r0, [pc, #0]	; (95c <geometry_msgs::Twist::getType()+0x4>)
     95a:	4770      	bx	lr
     95c:	000099a4 	.word	0x000099a4

00000960 <geometry_msgs::Twist::getMD5()>:
    virtual const char * getMD5() override { return "9f195f881246fdfa2798d1d3eebca84a"; };
     960:	4800      	ldr	r0, [pc, #0]	; (964 <geometry_msgs::Twist::getMD5()+0x4>)
     962:	4770      	bx	lr
     964:	000099b8 	.word	0x000099b8

00000968 <custom_msgs::odom_and_imu::getType()>:
      this->temp = u_temp.real;
      offset += sizeof(this->temp);
     return offset;
    }

    virtual const char * getType() override { return "custom_msgs/odom_and_imu"; };
     968:	4800      	ldr	r0, [pc, #0]	; (96c <custom_msgs::odom_and_imu::getType()+0x4>)
     96a:	4770      	bx	lr
     96c:	000099dc 	.word	0x000099dc

00000970 <custom_msgs::odom_and_imu::getMD5()>:
    virtual const char * getMD5() override { return "a0f22ba6c51d41d976fa58cb83325cf0"; };
     970:	4800      	ldr	r0, [pc, #0]	; (974 <custom_msgs::odom_and_imu::getMD5()+0x4>)
     972:	4770      	bx	lr
     974:	000099f8 	.word	0x000099f8

00000978 <ros::Subscriber<geometry_msgs::Twist, void>::getEndpointType()>:
    return this->msg.getMD5();
  }
  virtual int getEndpointType() override
  {
    return endpoint_;
  }
     978:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
     97a:	4770      	bx	lr

0000097c <ros::Subscriber<geometry_msgs::Twist, void>::getMsgType()>:
  }

  virtual const char * getMsgType() override
  {
    return this->msg.getType();
  }
     97c:	4800      	ldr	r0, [pc, #0]	; (980 <ros::Subscriber<geometry_msgs::Twist, void>::getMsgType()+0x4>)
     97e:	4770      	bx	lr
     980:	000099a4 	.word	0x000099a4

00000984 <ros::Subscriber<geometry_msgs::Twist, void>::getMsgMD5()>:
  virtual const char * getMsgMD5() override
  {
    return this->msg.getMD5();
  }
     984:	4800      	ldr	r0, [pc, #0]	; (988 <ros::Subscriber<geometry_msgs::Twist, void>::getMsgMD5()+0x4>)
     986:	4770      	bx	lr
     988:	000099b8 	.word	0x000099b8

0000098c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::connected()>:

  /* Are we connected to the PC? */
  virtual bool connected() override
  {
    return configured_;
  };
     98c:	f890 04f8 	ldrb.w	r0, [r0, #1272]	; 0x4f8
     990:	4770      	bx	lr
     992:	bf00      	nop
     994:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

00000998 <encoder_count_chage_right()>:
  result = result / sizeof(the_input_array);
  return result;
}


void encoder_count_chage_right() {
     998:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  delta_time_right =  double(micros()) / 1000000 - old_time_right;
     99a:	f004 fc5d 	bl	5258 <micros>
     99e:	4c50      	ldr	r4, [pc, #320]	; (ae0 <encoder_count_chage_right()+0x148>)
     9a0:	4d50      	ldr	r5, [pc, #320]	; (ae4 <encoder_count_chage_right()+0x14c>)
     9a2:	f007 f93b 	bl	7c1c <__aeabi_ui2d>
     9a6:	a34c      	add	r3, pc, #304	; (adr r3, ad8 <encoder_count_chage_right()+0x140>)
     9a8:	e9d3 2300 	ldrd	r2, r3, [r3]
     9ac:	f007 fad6 	bl	7f5c <__aeabi_ddiv>
     9b0:	e9d4 2300 	ldrd	r2, r3, [r4]
     9b4:	f006 fff4 	bl	79a0 <__aeabi_dsub>
     9b8:	e9c5 0100 	strd	r0, r1, [r5]
  old_time_right = double(micros()) / 1000000;
     9bc:	f004 fc4c 	bl	5258 <micros>
     9c0:	f007 f92c 	bl	7c1c <__aeabi_ui2d>
     9c4:	a344      	add	r3, pc, #272	; (adr r3, ad8 <encoder_count_chage_right()+0x140>)
     9c6:	e9d3 2300 	ldrd	r2, r3, [r3]
     9ca:	f007 fac7 	bl	7f5c <__aeabi_ddiv>
  if (encoder_counter_right < counts_per_revolution && encoder_counter_right > -counts_per_revolution) {
     9ce:	4b46      	ldr	r3, [pc, #280]	; (ae8 <encoder_count_chage_right()+0x150>)
     9d0:	e9d3 6700 	ldrd	r6, r7, [r3]
}


void encoder_count_chage_right() {
  delta_time_right =  double(micros()) / 1000000 - old_time_right;
  old_time_right = double(micros()) / 1000000;
     9d4:	e9c4 0100 	strd	r0, r1, [r4]
  if (encoder_counter_right < counts_per_revolution && encoder_counter_right > -counts_per_revolution) {
     9d8:	2200      	movs	r2, #0
     9da:	4b44      	ldr	r3, [pc, #272]	; (aec <encoder_count_chage_right()+0x154>)
     9dc:	4630      	mov	r0, r6
     9de:	4639      	mov	r1, r7
     9e0:	f007 fc04 	bl	81ec <__aeabi_dcmplt>
     9e4:	b138      	cbz	r0, 9f6 <encoder_count_chage_right()+0x5e>
     9e6:	4630      	mov	r0, r6
     9e8:	4639      	mov	r1, r7
     9ea:	2200      	movs	r2, #0
     9ec:	4b40      	ldr	r3, [pc, #256]	; (af0 <encoder_count_chage_right()+0x158>)
     9ee:	f007 fc1b 	bl	8228 <__aeabi_dcmpgt>
     9f2:	2800      	cmp	r0, #0
     9f4:	d14e      	bne.n	a94 <encoder_count_chage_right()+0xfc>
     9f6:	4b3f      	ldr	r3, [pc, #252]	; (af4 <encoder_count_chage_right()+0x15c>)
     9f8:	edd3 7a00 	vldr	s15, [r3]
//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
  }
  the_input_array[0] = data * float_to_long_factor;
     9fc:	4a3e      	ldr	r2, [pc, #248]	; (af8 <encoder_count_chage_right()+0x160>)


//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
     9fe:	4b3f      	ldr	r3, [pc, #252]	; (afc <encoder_count_chage_right()+0x164>)
      current_omega_right = -count_to_rad / delta_time_right;
    }
  }


  if (current_omega_right < 20 && current_omega_right > -20) {
     a00:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
     a04:	eef4 7ac7 	vcmpe.f32	s15, s14
     a08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     a0c:	d506      	bpl.n	a1c <encoder_count_chage_right()+0x84>
     a0e:	eebb 7a04 	vmov.f32	s14, #180	; 0xc1a00000 -20.0
     a12:	eef4 7ac7 	vcmpe.f32	s15, s14
     a16:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     a1a:	dc2b      	bgt.n	a74 <encoder_count_chage_right()+0xdc>
     a1c:	edd2 6a00 	vldr	s13, [r2]
     a20:	edd3 7a00 	vldr	s15, [r3]
}

float averaging_array(long the_input_array[]) {
  float result = 0;
  for (int x = 0; x < sizeof(the_input_array); x++) {
    result = result + (the_input_array[x] / float_to_long_factor);
     a24:	ed93 6a01 	vldr	s12, [r3, #4]
     a28:	ed93 7a02 	vldr	s14, [r3, #8]
     a2c:	edd3 4a03 	vldr	s9, [r3, #12]
     a30:	ed9f 4a33 	vldr	s8, [pc, #204]	; b00 <encoder_count_chage_right()+0x168>
    array_push(speed_array_right, current_omega_right);
  }

  //right_tick.data = right_count_tick;
  //right_tick_pub.publish(&right_tick);
  average_omega_right = averaging_array(speed_array_right);
     a34:	4b33      	ldr	r3, [pc, #204]	; (b04 <encoder_count_chage_right()+0x16c>)
}

float averaging_array(long the_input_array[]) {
  float result = 0;
  for (int x = 0; x < sizeof(the_input_array); x++) {
    result = result + (the_input_array[x] / float_to_long_factor);
     a36:	eef8 7ae7 	vcvt.f32.s32	s15, s15
     a3a:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
     a3e:	ee87 5aa6 	vdiv.f32	s10, s15, s13
     a42:	eec6 5a26 	vdiv.f32	s11, s12, s13
     a46:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
     a4a:	eef8 4ae4 	vcvt.f32.s32	s9, s9
     a4e:	ee87 6a26 	vdiv.f32	s12, s14, s13
     a52:	ee84 7aa6 	vdiv.f32	s14, s9, s13
     a56:	ee75 7a04 	vadd.f32	s15, s10, s8
    array_push(speed_array_right, current_omega_right);
  }

  //right_tick.data = right_count_tick;
  //right_tick_pub.publish(&right_tick);
  average_omega_right = averaging_array(speed_array_right);
     a5a:	eef5 6a00 	vmov.f32	s13, #80	; 0x3e800000  0.250
}

float averaging_array(long the_input_array[]) {
  float result = 0;
  for (int x = 0; x < sizeof(the_input_array); x++) {
    result = result + (the_input_array[x] / float_to_long_factor);
     a5e:	ee75 7aa7 	vadd.f32	s15, s11, s15
     a62:	ee76 7a27 	vadd.f32	s15, s12, s15
     a66:	ee77 7a27 	vadd.f32	s15, s14, s15
    array_push(speed_array_right, current_omega_right);
  }

  //right_tick.data = right_count_tick;
  //right_tick_pub.publish(&right_tick);
  average_omega_right = averaging_array(speed_array_right);
     a6a:	ee67 7aa6 	vmul.f32	s15, s15, s13
     a6e:	edc3 7a00 	vstr	s15, [r3]
     a72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
  }
  the_input_array[0] = data * float_to_long_factor;
     a74:	edd2 6a00 	vldr	s13, [r2]


//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
     a78:	681c      	ldr	r4, [r3, #0]
     a7a:	1d18      	adds	r0, r3, #4
     a7c:	c807      	ldmia	r0, {r0, r1, r2}
  }
  the_input_array[0] = data * float_to_long_factor;
     a7e:	ee66 7aa7 	vmul.f32	s15, s13, s15


//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
     a82:	605c      	str	r4, [r3, #4]
  }
  the_input_array[0] = data * float_to_long_factor;
     a84:	eefd 7ae7 	vcvt.s32.f32	s15, s15


//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
     a88:	6098      	str	r0, [r3, #8]
     a8a:	60d9      	str	r1, [r3, #12]
  }
  the_input_array[0] = data * float_to_long_factor;
     a8c:	edc3 7a00 	vstr	s15, [r3]


//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
     a90:	611a      	str	r2, [r3, #16]
     a92:	e7c7      	b.n	a24 <encoder_count_chage_right()+0x8c>

void encoder_count_chage_right() {
  delta_time_right =  double(micros()) / 1000000 - old_time_right;
  old_time_right = double(micros()) / 1000000;
  if (encoder_counter_right < counts_per_revolution && encoder_counter_right > -counts_per_revolution) {
    if (direction_indicator_right == 1) {
     a94:	4b1c      	ldr	r3, [pc, #112]	; (b08 <encoder_count_chage_right()+0x170>)
     a96:	681b      	ldr	r3, [r3, #0]
     a98:	2b01      	cmp	r3, #1
     a9a:	d015      	beq.n	ac8 <encoder_count_chage_right()+0x130>
    //  encoder_counter_right++;
      right_count_tick += 1;
      current_omega_right = count_to_rad / delta_time_right;
    }
    if (direction_indicator_right == 0) {
     a9c:	2b00      	cmp	r3, #0
     a9e:	d1aa      	bne.n	9f6 <encoder_count_chage_right()+0x5e>
    //  encoder_counter_right = encoder_counter_right - 1;
      right_count_tick += -1;
      current_omega_right = -count_to_rad / delta_time_right;
     aa0:	4b1a      	ldr	r3, [pc, #104]	; (b0c <encoder_count_chage_right()+0x174>)
      right_count_tick += 1;
      current_omega_right = count_to_rad / delta_time_right;
    }
    if (direction_indicator_right == 0) {
    //  encoder_counter_right = encoder_counter_right - 1;
      right_count_tick += -1;
     aa2:	4e1b      	ldr	r6, [pc, #108]	; (b10 <encoder_count_chage_right()+0x178>)
      current_omega_right = -count_to_rad / delta_time_right;
     aa4:	e893 0005 	ldmia.w	r3, {r0, r2}
      right_count_tick += 1;
      current_omega_right = count_to_rad / delta_time_right;
    }
    if (direction_indicator_right == 0) {
    //  encoder_counter_right = encoder_counter_right - 1;
      right_count_tick += -1;
     aa8:	6833      	ldr	r3, [r6, #0]
      current_omega_right = -count_to_rad / delta_time_right;
     aaa:	f102 4100 	add.w	r1, r2, #2147483648	; 0x80000000
      right_count_tick += 1;
      current_omega_right = count_to_rad / delta_time_right;
    }
    if (direction_indicator_right == 0) {
    //  encoder_counter_right = encoder_counter_right - 1;
      right_count_tick += -1;
     aae:	1e5c      	subs	r4, r3, #1
      current_omega_right = -count_to_rad / delta_time_right;
     ab0:	e9d5 2300 	ldrd	r2, r3, [r5]
      right_count_tick += 1;
      current_omega_right = count_to_rad / delta_time_right;
    }
    if (direction_indicator_right == 0) {
    //  encoder_counter_right = encoder_counter_right - 1;
      right_count_tick += -1;
     ab4:	6034      	str	r4, [r6, #0]
      current_omega_right = -count_to_rad / delta_time_right;
     ab6:	f007 fa51 	bl	7f5c <__aeabi_ddiv>
     aba:	f007 fbfd 	bl	82b8 <__aeabi_d2f>
     abe:	4b0d      	ldr	r3, [pc, #52]	; (af4 <encoder_count_chage_right()+0x15c>)
     ac0:	ee07 0a90 	vmov	s15, r0
     ac4:	6018      	str	r0, [r3, #0]
     ac6:	e799      	b.n	9fc <encoder_count_chage_right()+0x64>
  delta_time_right =  double(micros()) / 1000000 - old_time_right;
  old_time_right = double(micros()) / 1000000;
  if (encoder_counter_right < counts_per_revolution && encoder_counter_right > -counts_per_revolution) {
    if (direction_indicator_right == 1) {
    //  encoder_counter_right++;
      right_count_tick += 1;
     ac8:	4e11      	ldr	r6, [pc, #68]	; (b10 <encoder_count_chage_right()+0x178>)
      current_omega_right = count_to_rad / delta_time_right;
     aca:	4a10      	ldr	r2, [pc, #64]	; (b0c <encoder_count_chage_right()+0x174>)
  delta_time_right =  double(micros()) / 1000000 - old_time_right;
  old_time_right = double(micros()) / 1000000;
  if (encoder_counter_right < counts_per_revolution && encoder_counter_right > -counts_per_revolution) {
    if (direction_indicator_right == 1) {
    //  encoder_counter_right++;
      right_count_tick += 1;
     acc:	6833      	ldr	r3, [r6, #0]
      current_omega_right = count_to_rad / delta_time_right;
     ace:	e9d2 0100 	ldrd	r0, r1, [r2]
  delta_time_right =  double(micros()) / 1000000 - old_time_right;
  old_time_right = double(micros()) / 1000000;
  if (encoder_counter_right < counts_per_revolution && encoder_counter_right > -counts_per_revolution) {
    if (direction_indicator_right == 1) {
    //  encoder_counter_right++;
      right_count_tick += 1;
     ad2:	1c5c      	adds	r4, r3, #1
     ad4:	e7ec      	b.n	ab0 <encoder_count_chage_right()+0x118>
     ad6:	bf00      	nop
     ad8:	00000000 	.word	0x00000000
     adc:	412e8480 	.word	0x412e8480
     ae0:	1fff1d40 	.word	0x1fff1d40
     ae4:	1fff1468 	.word	0x1fff1468
     ae8:	1fff1d30 	.word	0x1fff1d30
     aec:	409e0000 	.word	0x409e0000
     af0:	c09e0000 	.word	0xc09e0000
     af4:	1fff2b70 	.word	0x1fff2b70
     af8:	1fff0820 	.word	0x1fff0820
     afc:	1fff22a4 	.word	0x1fff22a4
     b00:	00000000 	.word	0x00000000
     b04:	1fff1494 	.word	0x1fff1494
     b08:	1fff228c 	.word	0x1fff228c
     b0c:	1fff0818 	.word	0x1fff0818
     b10:	1fff1490 	.word	0x1fff1490
     b14:	ffffffff 	.word	0xffffffff

00000b18 <encoder_count_chage_left()>:
  //right_tick.data = right_count_tick;
  //right_tick_pub.publish(&right_tick);
  average_omega_right = averaging_array(speed_array_right);
}

void encoder_count_chage_left() {
     b18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  delta_time_left = double(micros()) / 1000000 - old_time_left;
     b1a:	f004 fb9d 	bl	5258 <micros>
     b1e:	4c50      	ldr	r4, [pc, #320]	; (c60 <encoder_count_chage_left()+0x148>)
     b20:	4d50      	ldr	r5, [pc, #320]	; (c64 <encoder_count_chage_left()+0x14c>)
     b22:	f007 f87b 	bl	7c1c <__aeabi_ui2d>
     b26:	a34c      	add	r3, pc, #304	; (adr r3, c58 <encoder_count_chage_left()+0x140>)
     b28:	e9d3 2300 	ldrd	r2, r3, [r3]
     b2c:	f007 fa16 	bl	7f5c <__aeabi_ddiv>
     b30:	e9d4 2300 	ldrd	r2, r3, [r4]
     b34:	f006 ff34 	bl	79a0 <__aeabi_dsub>
     b38:	e9c5 0100 	strd	r0, r1, [r5]
  old_time_left = double(micros()) / 1000000;
     b3c:	f004 fb8c 	bl	5258 <micros>
     b40:	f007 f86c 	bl	7c1c <__aeabi_ui2d>
     b44:	a344      	add	r3, pc, #272	; (adr r3, c58 <encoder_count_chage_left()+0x140>)
     b46:	e9d3 2300 	ldrd	r2, r3, [r3]
     b4a:	f007 fa07 	bl	7f5c <__aeabi_ddiv>
  if (encoder_counter_left < counts_per_revolution && encoder_counter_left > -counts_per_revolution) {
     b4e:	4b46      	ldr	r3, [pc, #280]	; (c68 <encoder_count_chage_left()+0x150>)
     b50:	e9d3 6700 	ldrd	r6, r7, [r3]
  average_omega_right = averaging_array(speed_array_right);
}

void encoder_count_chage_left() {
  delta_time_left = double(micros()) / 1000000 - old_time_left;
  old_time_left = double(micros()) / 1000000;
     b54:	e9c4 0100 	strd	r0, r1, [r4]
  if (encoder_counter_left < counts_per_revolution && encoder_counter_left > -counts_per_revolution) {
     b58:	2200      	movs	r2, #0
     b5a:	4b44      	ldr	r3, [pc, #272]	; (c6c <encoder_count_chage_left()+0x154>)
     b5c:	4630      	mov	r0, r6
     b5e:	4639      	mov	r1, r7
     b60:	f007 fb44 	bl	81ec <__aeabi_dcmplt>
     b64:	b138      	cbz	r0, b76 <encoder_count_chage_left()+0x5e>
     b66:	4630      	mov	r0, r6
     b68:	4639      	mov	r1, r7
     b6a:	2200      	movs	r2, #0
     b6c:	4b40      	ldr	r3, [pc, #256]	; (c70 <encoder_count_chage_left()+0x158>)
     b6e:	f007 fb5b 	bl	8228 <__aeabi_dcmpgt>
     b72:	2800      	cmp	r0, #0
     b74:	d14e      	bne.n	c14 <encoder_count_chage_left()+0xfc>
     b76:	4b3f      	ldr	r3, [pc, #252]	; (c74 <encoder_count_chage_left()+0x15c>)
     b78:	edd3 7a00 	vldr	s15, [r3]
//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
  }
  the_input_array[0] = data * float_to_long_factor;
     b7c:	4a3e      	ldr	r2, [pc, #248]	; (c78 <encoder_count_chage_left()+0x160>)


//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
     b7e:	4b3f      	ldr	r3, [pc, #252]	; (c7c <encoder_count_chage_left()+0x164>)
      left_count_tick += -1;
      current_omega_left = -count_to_rad / delta_time_left;
    }
  }

  if (current_omega_left < 20 && current_omega_left > -20) {
     b80:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
     b84:	eef4 7ac7 	vcmpe.f32	s15, s14
     b88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     b8c:	d506      	bpl.n	b9c <encoder_count_chage_left()+0x84>
     b8e:	eebb 7a04 	vmov.f32	s14, #180	; 0xc1a00000 -20.0
     b92:	eef4 7ac7 	vcmpe.f32	s15, s14
     b96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     b9a:	dc2b      	bgt.n	bf4 <encoder_count_chage_left()+0xdc>
     b9c:	edd2 6a00 	vldr	s13, [r2]
     ba0:	edd3 7a00 	vldr	s15, [r3]
}

float averaging_array(long the_input_array[]) {
  float result = 0;
  for (int x = 0; x < sizeof(the_input_array); x++) {
    result = result + (the_input_array[x] / float_to_long_factor);
     ba4:	ed93 6a01 	vldr	s12, [r3, #4]
     ba8:	ed93 7a02 	vldr	s14, [r3, #8]
     bac:	edd3 4a03 	vldr	s9, [r3, #12]
     bb0:	ed9f 4a33 	vldr	s8, [pc, #204]	; c80 <encoder_count_chage_left()+0x168>
  }

  //left_tick.data = left_count_tick;
  //left_tick_pub.publish(&left_tick);

  average_omega_left = averaging_array(speed_array_left);
     bb4:	4b33      	ldr	r3, [pc, #204]	; (c84 <encoder_count_chage_left()+0x16c>)
}

float averaging_array(long the_input_array[]) {
  float result = 0;
  for (int x = 0; x < sizeof(the_input_array); x++) {
    result = result + (the_input_array[x] / float_to_long_factor);
     bb6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
     bba:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
     bbe:	ee87 5aa6 	vdiv.f32	s10, s15, s13
     bc2:	eec6 5a26 	vdiv.f32	s11, s12, s13
     bc6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
     bca:	eef8 4ae4 	vcvt.f32.s32	s9, s9
     bce:	ee87 6a26 	vdiv.f32	s12, s14, s13
     bd2:	ee84 7aa6 	vdiv.f32	s14, s9, s13
     bd6:	ee75 7a04 	vadd.f32	s15, s10, s8
  }

  //left_tick.data = left_count_tick;
  //left_tick_pub.publish(&left_tick);

  average_omega_left = averaging_array(speed_array_left);
     bda:	eef5 6a00 	vmov.f32	s13, #80	; 0x3e800000  0.250
}

float averaging_array(long the_input_array[]) {
  float result = 0;
  for (int x = 0; x < sizeof(the_input_array); x++) {
    result = result + (the_input_array[x] / float_to_long_factor);
     bde:	ee75 7aa7 	vadd.f32	s15, s11, s15
     be2:	ee76 7a27 	vadd.f32	s15, s12, s15
     be6:	ee77 7a27 	vadd.f32	s15, s14, s15
  }

  //left_tick.data = left_count_tick;
  //left_tick_pub.publish(&left_tick);

  average_omega_left = averaging_array(speed_array_left);
     bea:	ee67 7aa6 	vmul.f32	s15, s15, s13
     bee:	edc3 7a00 	vstr	s15, [r3]
     bf2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
  }
  the_input_array[0] = data * float_to_long_factor;
     bf4:	edd2 6a00 	vldr	s13, [r2]


//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
     bf8:	681c      	ldr	r4, [r3, #0]
     bfa:	1d18      	adds	r0, r3, #4
     bfc:	c807      	ldmia	r0, {r0, r1, r2}
  }
  the_input_array[0] = data * float_to_long_factor;
     bfe:	ee66 7aa7 	vmul.f32	s15, s13, s15


//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
     c02:	605c      	str	r4, [r3, #4]
  }
  the_input_array[0] = data * float_to_long_factor;
     c04:	eefd 7ae7 	vcvt.s32.f32	s15, s15


//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
     c08:	6098      	str	r0, [r3, #8]
     c0a:	60d9      	str	r1, [r3, #12]
  }
  the_input_array[0] = data * float_to_long_factor;
     c0c:	edc3 7a00 	vstr	s15, [r3]


//-----Functions-----//
void array_push(long the_input_array[], float data) {
  for (int x = sizeof(the_input_array); x > 0; x = x - 1) {
    the_input_array[x] = the_input_array[x - 1];
     c10:	611a      	str	r2, [r3, #16]
     c12:	e7c7      	b.n	ba4 <encoder_count_chage_left()+0x8c>

void encoder_count_chage_left() {
  delta_time_left = double(micros()) / 1000000 - old_time_left;
  old_time_left = double(micros()) / 1000000;
  if (encoder_counter_left < counts_per_revolution && encoder_counter_left > -counts_per_revolution) {
    if (direction_indicator_left == 1) {
     c14:	4b1c      	ldr	r3, [pc, #112]	; (c88 <encoder_count_chage_left()+0x170>)
     c16:	681b      	ldr	r3, [r3, #0]
     c18:	2b01      	cmp	r3, #1
     c1a:	d015      	beq.n	c48 <encoder_count_chage_left()+0x130>
    //  encoder_counter_left++;
      left_count_tick += 1;
      current_omega_left = count_to_rad / delta_time_left;
    }
    if (direction_indicator_left == 0) {
     c1c:	2b00      	cmp	r3, #0
     c1e:	d1aa      	bne.n	b76 <encoder_count_chage_left()+0x5e>
    //  encoder_counter_left = encoder_counter_left - 1;
      left_count_tick += -1;
      current_omega_left = -count_to_rad / delta_time_left;
     c20:	4b1a      	ldr	r3, [pc, #104]	; (c8c <encoder_count_chage_left()+0x174>)
      left_count_tick += 1;
      current_omega_left = count_to_rad / delta_time_left;
    }
    if (direction_indicator_left == 0) {
    //  encoder_counter_left = encoder_counter_left - 1;
      left_count_tick += -1;
     c22:	4e1b      	ldr	r6, [pc, #108]	; (c90 <encoder_count_chage_left()+0x178>)
      current_omega_left = -count_to_rad / delta_time_left;
     c24:	e893 0005 	ldmia.w	r3, {r0, r2}
      left_count_tick += 1;
      current_omega_left = count_to_rad / delta_time_left;
    }
    if (direction_indicator_left == 0) {
    //  encoder_counter_left = encoder_counter_left - 1;
      left_count_tick += -1;
     c28:	6833      	ldr	r3, [r6, #0]
      current_omega_left = -count_to_rad / delta_time_left;
     c2a:	f102 4100 	add.w	r1, r2, #2147483648	; 0x80000000
      left_count_tick += 1;
      current_omega_left = count_to_rad / delta_time_left;
    }
    if (direction_indicator_left == 0) {
    //  encoder_counter_left = encoder_counter_left - 1;
      left_count_tick += -1;
     c2e:	1e5c      	subs	r4, r3, #1
      current_omega_left = -count_to_rad / delta_time_left;
     c30:	e9d5 2300 	ldrd	r2, r3, [r5]
      left_count_tick += 1;
      current_omega_left = count_to_rad / delta_time_left;
    }
    if (direction_indicator_left == 0) {
    //  encoder_counter_left = encoder_counter_left - 1;
      left_count_tick += -1;
     c34:	6034      	str	r4, [r6, #0]
      current_omega_left = -count_to_rad / delta_time_left;
     c36:	f007 f991 	bl	7f5c <__aeabi_ddiv>
     c3a:	f007 fb3d 	bl	82b8 <__aeabi_d2f>
     c3e:	4b0d      	ldr	r3, [pc, #52]	; (c74 <encoder_count_chage_left()+0x15c>)
     c40:	ee07 0a90 	vmov	s15, r0
     c44:	6018      	str	r0, [r3, #0]
     c46:	e799      	b.n	b7c <encoder_count_chage_left()+0x64>
  delta_time_left = double(micros()) / 1000000 - old_time_left;
  old_time_left = double(micros()) / 1000000;
  if (encoder_counter_left < counts_per_revolution && encoder_counter_left > -counts_per_revolution) {
    if (direction_indicator_left == 1) {
    //  encoder_counter_left++;
      left_count_tick += 1;
     c48:	4e11      	ldr	r6, [pc, #68]	; (c90 <encoder_count_chage_left()+0x178>)
      current_omega_left = count_to_rad / delta_time_left;
     c4a:	4a10      	ldr	r2, [pc, #64]	; (c8c <encoder_count_chage_left()+0x174>)
  delta_time_left = double(micros()) / 1000000 - old_time_left;
  old_time_left = double(micros()) / 1000000;
  if (encoder_counter_left < counts_per_revolution && encoder_counter_left > -counts_per_revolution) {
    if (direction_indicator_left == 1) {
    //  encoder_counter_left++;
      left_count_tick += 1;
     c4c:	6833      	ldr	r3, [r6, #0]
      current_omega_left = count_to_rad / delta_time_left;
     c4e:	e9d2 0100 	ldrd	r0, r1, [r2]
  delta_time_left = double(micros()) / 1000000 - old_time_left;
  old_time_left = double(micros()) / 1000000;
  if (encoder_counter_left < counts_per_revolution && encoder_counter_left > -counts_per_revolution) {
    if (direction_indicator_left == 1) {
    //  encoder_counter_left++;
      left_count_tick += 1;
     c52:	1c5c      	adds	r4, r3, #1
     c54:	e7ec      	b.n	c30 <encoder_count_chage_left()+0x118>
     c56:	bf00      	nop
     c58:	00000000 	.word	0x00000000
     c5c:	412e8480 	.word	0x412e8480
     c60:	1fff2a78 	.word	0x1fff2a78
     c64:	1fff2b58 	.word	0x1fff2b58
     c68:	1fff1498 	.word	0x1fff1498
     c6c:	409e0000 	.word	0x409e0000
     c70:	c09e0000 	.word	0xc09e0000
     c74:	1fff1d3c 	.word	0x1fff1d3c
     c78:	1fff0820 	.word	0x1fff0820
     c7c:	1fff14a8 	.word	0x1fff14a8
     c80:	00000000 	.word	0x00000000
     c84:	1fff1c9c 	.word	0x1fff1c9c
     c88:	1fff1d54 	.word	0x1fff1d54
     c8c:	1fff0818 	.word	0x1fff0818
     c90:	1fff2b8c 	.word	0x1fff2b8c

00000c94 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const>:
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->ints_length >> (8 * 0)) & 0xFF;
     c94:	6843      	ldr	r3, [r0, #4]
      floats_length(0), st_floats(), floats(nullptr),
      strings_length(0), st_strings(), strings(nullptr)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
     c96:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->ints_length >> (8 * 0)) & 0xFF;
     c9a:	700b      	strb	r3, [r1, #0]
      *(outbuffer + offset + 1) = (this->ints_length >> (8 * 1)) & 0xFF;
     c9c:	6843      	ldr	r3, [r0, #4]
     c9e:	0a1b      	lsrs	r3, r3, #8
     ca0:	704b      	strb	r3, [r1, #1]
      *(outbuffer + offset + 2) = (this->ints_length >> (8 * 2)) & 0xFF;
     ca2:	88c3      	ldrh	r3, [r0, #6]
     ca4:	708b      	strb	r3, [r1, #2]
      *(outbuffer + offset + 3) = (this->ints_length >> (8 * 3)) & 0xFF;
     ca6:	79c3      	ldrb	r3, [r0, #7]
     ca8:	70cb      	strb	r3, [r1, #3]
      offset += sizeof(this->ints_length);
      for( uint32_t i = 0; i < ints_length; i++){
     caa:	6843      	ldr	r3, [r0, #4]
     cac:	2b00      	cmp	r3, #0
     cae:	f000 8085 	beq.w	dbc <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0x128>
     cb2:	460a      	mov	r2, r1
     cb4:	2500      	movs	r5, #0
     cb6:	2604      	movs	r6, #4
      union {
        int32_t real;
        uint32_t base;
      } u_intsi;
      u_intsi.real = this->ints[i];
     cb8:	68c3      	ldr	r3, [r0, #12]
     cba:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
      *(outbuffer + offset + 0) = (u_intsi.base >> (8 * 0)) & 0xFF;
     cbe:	7113      	strb	r3, [r2, #4]
      *(outbuffer + offset + 1) = (u_intsi.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_intsi.base >> (8 * 2)) & 0xFF;
     cc0:	0c1c      	lsrs	r4, r3, #16
        int32_t real;
        uint32_t base;
      } u_intsi;
      u_intsi.real = this->ints[i];
      *(outbuffer + offset + 0) = (u_intsi.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_intsi.base >> (8 * 1)) & 0xFF;
     cc2:	0a1f      	lsrs	r7, r3, #8
      *(outbuffer + offset + 2) = (u_intsi.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_intsi.base >> (8 * 3)) & 0xFF;
     cc4:	0e1b      	lsrs	r3, r3, #24
        uint32_t base;
      } u_intsi;
      u_intsi.real = this->ints[i];
      *(outbuffer + offset + 0) = (u_intsi.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_intsi.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_intsi.base >> (8 * 2)) & 0xFF;
     cc6:	7194      	strb	r4, [r2, #6]
        int32_t real;
        uint32_t base;
      } u_intsi;
      u_intsi.real = this->ints[i];
      *(outbuffer + offset + 0) = (u_intsi.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_intsi.base >> (8 * 1)) & 0xFF;
     cc8:	7157      	strb	r7, [r2, #5]
      *(outbuffer + offset + 2) = (u_intsi.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_intsi.base >> (8 * 3)) & 0xFF;
     cca:	71d3      	strb	r3, [r2, #7]
      *(outbuffer + offset + 0) = (this->ints_length >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->ints_length >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (this->ints_length >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (this->ints_length >> (8 * 3)) & 0xFF;
      offset += sizeof(this->ints_length);
      for( uint32_t i = 0; i < ints_length; i++){
     ccc:	6843      	ldr	r3, [r0, #4]
     cce:	3501      	adds	r5, #1
     cd0:	42ab      	cmp	r3, r5
     cd2:	4634      	mov	r4, r6
     cd4:	f102 0204 	add.w	r2, r2, #4
     cd8:	f106 0604 	add.w	r6, r6, #4
     cdc:	d8ec      	bhi.n	cb8 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0x24>
     cde:	f104 0208 	add.w	r2, r4, #8
     ce2:	f104 0a05 	add.w	sl, r4, #5
     ce6:	f104 0906 	add.w	r9, r4, #6
     cea:	f104 0807 	add.w	r8, r4, #7
     cee:	f104 0c09 	add.w	ip, r4, #9
     cf2:	f104 0e0a 	add.w	lr, r4, #10
     cf6:	f104 050b 	add.w	r5, r4, #11
     cfa:	4617      	mov	r7, r2
     cfc:	340c      	adds	r4, #12
      *(outbuffer + offset + 1) = (u_intsi.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_intsi.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_intsi.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->ints[i]);
      }
      *(outbuffer + offset + 0) = (this->floats_length >> (8 * 0)) & 0xFF;
     cfe:	6903      	ldr	r3, [r0, #16]
     d00:	558b      	strb	r3, [r1, r6]
      *(outbuffer + offset + 1) = (this->floats_length >> (8 * 1)) & 0xFF;
     d02:	6903      	ldr	r3, [r0, #16]
     d04:	0a1b      	lsrs	r3, r3, #8
     d06:	f801 300a 	strb.w	r3, [r1, sl]
      *(outbuffer + offset + 2) = (this->floats_length >> (8 * 2)) & 0xFF;
     d0a:	8a43      	ldrh	r3, [r0, #18]
     d0c:	f801 3009 	strb.w	r3, [r1, r9]
      *(outbuffer + offset + 3) = (this->floats_length >> (8 * 3)) & 0xFF;
     d10:	7cc3      	ldrb	r3, [r0, #19]
     d12:	f801 3008 	strb.w	r3, [r1, r8]
      offset += sizeof(this->floats_length);
      for( uint32_t i = 0; i < floats_length; i++){
     d16:	6903      	ldr	r3, [r0, #16]
     d18:	b1f3      	cbz	r3, d58 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0xc4>
     d1a:	eb01 0e07 	add.w	lr, r1, r7
     d1e:	4675      	mov	r5, lr
     d20:	2200      	movs	r2, #0
      union {
        float real;
        uint32_t base;
      } u_floatsi;
      u_floatsi.real = this->floats[i];
     d22:	6983      	ldr	r3, [r0, #24]
      *(outbuffer + offset + 0) = (u_floatsi.base >> (8 * 0)) & 0xFF;
     d24:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
     d28:	f80e 3022 	strb.w	r3, [lr, r2, lsl #2]
      *(outbuffer + offset + 1) = (u_floatsi.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_floatsi.base >> (8 * 2)) & 0xFF;
     d2c:	0c1c      	lsrs	r4, r3, #16
        float real;
        uint32_t base;
      } u_floatsi;
      u_floatsi.real = this->floats[i];
      *(outbuffer + offset + 0) = (u_floatsi.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_floatsi.base >> (8 * 1)) & 0xFF;
     d2e:	0a1e      	lsrs	r6, r3, #8
      *(outbuffer + offset + 2) = (u_floatsi.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_floatsi.base >> (8 * 3)) & 0xFF;
     d30:	0e1b      	lsrs	r3, r3, #24
        uint32_t base;
      } u_floatsi;
      u_floatsi.real = this->floats[i];
      *(outbuffer + offset + 0) = (u_floatsi.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_floatsi.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_floatsi.base >> (8 * 2)) & 0xFF;
     d32:	70ac      	strb	r4, [r5, #2]
        float real;
        uint32_t base;
      } u_floatsi;
      u_floatsi.real = this->floats[i];
      *(outbuffer + offset + 0) = (u_floatsi.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_floatsi.base >> (8 * 1)) & 0xFF;
     d34:	706e      	strb	r6, [r5, #1]
      *(outbuffer + offset + 2) = (u_floatsi.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_floatsi.base >> (8 * 3)) & 0xFF;
     d36:	70eb      	strb	r3, [r5, #3]
      *(outbuffer + offset + 0) = (this->floats_length >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->floats_length >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (this->floats_length >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (this->floats_length >> (8 * 3)) & 0xFF;
      offset += sizeof(this->floats_length);
      for( uint32_t i = 0; i < floats_length; i++){
     d38:	6903      	ldr	r3, [r0, #16]
     d3a:	3201      	adds	r2, #1
     d3c:	4293      	cmp	r3, r2
     d3e:	463c      	mov	r4, r7
     d40:	f105 0504 	add.w	r5, r5, #4
     d44:	f107 0704 	add.w	r7, r7, #4
     d48:	d8eb      	bhi.n	d22 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0x8e>
     d4a:	f104 0c05 	add.w	ip, r4, #5
     d4e:	f104 0e06 	add.w	lr, r4, #6
     d52:	1de5      	adds	r5, r4, #7
     d54:	463a      	mov	r2, r7
     d56:	3408      	adds	r4, #8
      *(outbuffer + offset + 1) = (u_floatsi.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_floatsi.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_floatsi.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->floats[i]);
      }
      *(outbuffer + offset + 0) = (this->strings_length >> (8 * 0)) & 0xFF;
     d58:	69c3      	ldr	r3, [r0, #28]
     d5a:	548b      	strb	r3, [r1, r2]
      *(outbuffer + offset + 1) = (this->strings_length >> (8 * 1)) & 0xFF;
     d5c:	69c3      	ldr	r3, [r0, #28]
     d5e:	0a1b      	lsrs	r3, r3, #8
     d60:	f801 300c 	strb.w	r3, [r1, ip]
      *(outbuffer + offset + 2) = (this->strings_length >> (8 * 2)) & 0xFF;
     d64:	8bc3      	ldrh	r3, [r0, #30]
     d66:	f801 300e 	strb.w	r3, [r1, lr]
      *(outbuffer + offset + 3) = (this->strings_length >> (8 * 3)) & 0xFF;
     d6a:	7fc3      	ldrb	r3, [r0, #31]
     d6c:	554b      	strb	r3, [r1, r5]
      offset += sizeof(this->strings_length);
      for( uint32_t i = 0; i < strings_length; i++){
     d6e:	69c3      	ldr	r3, [r0, #28]
     d70:	b30b      	cbz	r3, db6 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0x122>
     d72:	460f      	mov	r7, r1
     d74:	4680      	mov	r8, r0
     d76:	2600      	movs	r6, #0
      uint32_t length_stringsi = strlen(this->strings[i]);
     d78:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
     d7c:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
     d80:	f008 fa7e 	bl	9280 <strlen>
     d84:	00b1      	lsls	r1, r6, #2
     d86:	4605      	mov	r5, r0
     d88:	193a      	adds	r2, r7, r4
      varToArr(outbuffer + offset, length_stringsi);
     d8a:	2300      	movs	r3, #0
  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
      arr[i] = (var >> (8 * i));
     d8c:	fa25 f003 	lsr.w	r0, r5, r3
     d90:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
     d92:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
     d94:	f802 0b01 	strb.w	r0, [r2], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
     d98:	d1f8      	bne.n	d8c <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0xf8>
      offset += 4;
      memcpy(outbuffer + offset, this->strings[i], length_stringsi);
     d9a:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
     d9e:	3404      	adds	r4, #4
     da0:	1938      	adds	r0, r7, r4
     da2:	5859      	ldr	r1, [r3, r1]
     da4:	462a      	mov	r2, r5
     da6:	f003 fe6b 	bl	4a80 <memcpy>
      *(outbuffer + offset + 0) = (this->strings_length >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->strings_length >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (this->strings_length >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (this->strings_length >> (8 * 3)) & 0xFF;
      offset += sizeof(this->strings_length);
      for( uint32_t i = 0; i < strings_length; i++){
     daa:	f8d8 301c 	ldr.w	r3, [r8, #28]
     dae:	3601      	adds	r6, #1
     db0:	42b3      	cmp	r3, r6
      uint32_t length_stringsi = strlen(this->strings[i]);
      varToArr(outbuffer + offset, length_stringsi);
      offset += 4;
      memcpy(outbuffer + offset, this->strings[i], length_stringsi);
      offset += length_stringsi;
     db2:	442c      	add	r4, r5
      *(outbuffer + offset + 0) = (this->strings_length >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->strings_length >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (this->strings_length >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (this->strings_length >> (8 * 3)) & 0xFF;
      offset += sizeof(this->strings_length);
      for( uint32_t i = 0; i < strings_length; i++){
     db4:	d8e0      	bhi.n	d78 <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0xe4>
      offset += 4;
      memcpy(outbuffer + offset, this->strings[i], length_stringsi);
      offset += length_stringsi;
      }
      return offset;
    }
     db6:	4620      	mov	r0, r4
     db8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      *(outbuffer + offset + 0) = (this->ints_length >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->ints_length >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (this->ints_length >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (this->ints_length >> (8 * 3)) & 0xFF;
      offset += sizeof(this->ints_length);
      for( uint32_t i = 0; i < ints_length; i++){
     dbc:	2208      	movs	r2, #8
     dbe:	4617      	mov	r7, r2
     dc0:	240c      	movs	r4, #12
     dc2:	250b      	movs	r5, #11
     dc4:	f04f 0e0a 	mov.w	lr, #10
     dc8:	f04f 0c09 	mov.w	ip, #9
     dcc:	f04f 0807 	mov.w	r8, #7
     dd0:	f04f 0906 	mov.w	r9, #6
     dd4:	f04f 0a05 	mov.w	sl, #5
     dd8:	2604      	movs	r6, #4
     dda:	e790      	b.n	cfe <rosserial_msgs::RequestParamResponse::serialize(unsigned char*) const+0x6a>

00000ddc <rosserial_msgs::Log::serialize(unsigned char*) const>:
      level(0),
      msg("")
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
     ddc:	b570      	push	{r4, r5, r6, lr}
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
     dde:	7903      	ldrb	r3, [r0, #4]
     de0:	700b      	strb	r3, [r1, #0]
      level(0),
      msg("")
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
     de2:	4606      	mov	r6, r0
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
     de4:	6880      	ldr	r0, [r0, #8]
      level(0),
      msg("")
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
     de6:	460d      	mov	r5, r1
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
     de8:	f008 fa4a 	bl	9280 <strlen>
     dec:	462a      	mov	r2, r5
     dee:	4604      	mov	r4, r0
     df0:	2300      	movs	r3, #0
      arr[i] = (var >> (8 * i));
     df2:	fa24 f103 	lsr.w	r1, r4, r3
     df6:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
     df8:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
     dfa:	f802 1f01 	strb.w	r1, [r2, #1]!

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
     dfe:	d1f8      	bne.n	df2 <rosserial_msgs::Log::serialize(unsigned char*) const+0x16>
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
     e00:	68b1      	ldr	r1, [r6, #8]
     e02:	1d68      	adds	r0, r5, #5
     e04:	4622      	mov	r2, r4
     e06:	f003 fe3b 	bl	4a80 <memcpy>
      offset += length_msg;
      return offset;
    }
     e0a:	1d60      	adds	r0, r4, #5
     e0c:	bd70      	pop	{r4, r5, r6, pc}
     e0e:	bf00      	nop

00000e10 <rosserial_msgs::TopicInfo::serialize(unsigned char*) const>:
      md5sum(""),
      buffer_size(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
     e10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
     e12:	8883      	ldrh	r3, [r0, #4]
     e14:	700b      	strb	r3, [r1, #0]
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
     e16:	8883      	ldrh	r3, [r0, #4]
     e18:	0a1b      	lsrs	r3, r3, #8
     e1a:	704b      	strb	r3, [r1, #1]
      md5sum(""),
      buffer_size(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
     e1c:	4606      	mov	r6, r0
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
     e1e:	6880      	ldr	r0, [r0, #8]
      md5sum(""),
      buffer_size(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
     e20:	460d      	mov	r5, r1
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
     e22:	f008 fa2d 	bl	9280 <strlen>
      arr[i] = (var >> (8 * i));
     e26:	0e03      	lsrs	r3, r0, #24
     e28:	0a01      	lsrs	r1, r0, #8
     e2a:	0c02      	lsrs	r2, r0, #16
     e2c:	716b      	strb	r3, [r5, #5]
     e2e:	70a8      	strb	r0, [r5, #2]
     e30:	712a      	strb	r2, [r5, #4]
     e32:	70e9      	strb	r1, [r5, #3]
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
     e34:	4602      	mov	r2, r0
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
     e36:	4604      	mov	r4, r0
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
     e38:	68b1      	ldr	r1, [r6, #8]
     e3a:	1da8      	adds	r0, r5, #6
     e3c:	f003 fe20 	bl	4a80 <memcpy>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
     e40:	68f0      	ldr	r0, [r6, #12]
     e42:	f008 fa1d 	bl	9280 <strlen>
     e46:	1d61      	adds	r1, r4, #5
     e48:	4602      	mov	r2, r0
     e4a:	4429      	add	r1, r5
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
     e4c:	3406      	adds	r4, #6
      uint32_t length_message_type = strlen(this->message_type);
     e4e:	2300      	movs	r3, #0
     e50:	fa22 f003 	lsr.w	r0, r2, r3
     e54:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
     e56:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
     e58:	f801 0f01 	strb.w	r0, [r1, #1]!

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
     e5c:	d1f8      	bne.n	e50 <rosserial_msgs::TopicInfo::serialize(unsigned char*) const+0x40>
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
     e5e:	3404      	adds	r4, #4
     e60:	1928      	adds	r0, r5, r4
     e62:	68f1      	ldr	r1, [r6, #12]
      offset += length_message_type;
     e64:	4414      	add	r4, r2
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
     e66:	f003 fe0b 	bl	4a80 <memcpy>
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
     e6a:	6930      	ldr	r0, [r6, #16]
     e6c:	f008 fa08 	bl	9280 <strlen>
     e70:	192a      	adds	r2, r5, r4
     e72:	4607      	mov	r7, r0
     e74:	2300      	movs	r3, #0
      arr[i] = (var >> (8 * i));
     e76:	fa27 f103 	lsr.w	r1, r7, r3
     e7a:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
     e7c:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
     e7e:	f802 1b01 	strb.w	r1, [r2], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
     e82:	d1f8      	bne.n	e76 <rosserial_msgs::TopicInfo::serialize(unsigned char*) const+0x66>
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
     e84:	3404      	adds	r4, #4
     e86:	1928      	adds	r0, r5, r4
     e88:	463a      	mov	r2, r7
     e8a:	6931      	ldr	r1, [r6, #16]
     e8c:	f003 fdf8 	bl	4a80 <memcpy>
      offset += length_md5sum;
     e90:	1938      	adds	r0, r7, r4
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
     e92:	6973      	ldr	r3, [r6, #20]
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
     e94:	542b      	strb	r3, [r5, r0]
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
     e96:	4405      	add	r5, r0
     e98:	0a19      	lsrs	r1, r3, #8
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
     e9a:	0c1a      	lsrs	r2, r3, #16
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
     e9c:	0e1b      	lsrs	r3, r3, #24
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
     e9e:	7069      	strb	r1, [r5, #1]
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
     ea0:	70aa      	strb	r2, [r5, #2]
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
     ea2:	70eb      	strb	r3, [r5, #3]
      offset += sizeof(this->buffer_size);
      return offset;
    }
     ea4:	3004      	adds	r0, #4
     ea6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00000ea8 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
     ea8:	4608      	mov	r0, r1
     eaa:	4611      	mov	r1, r2
     eac:	f005 b900 	b.w	60b0 <usb_serial_write>

00000eb0 <usb_serial_class::read()>:
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
     eb0:	f005 b898 	b.w	5fe4 <usb_serial_getchar>

00000eb4 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)>:
      offset += length_stringsi;
      }
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     eb4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    {
      int offset = 0;
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
     eb8:	780a      	ldrb	r2, [r1, #0]
     eba:	784b      	ldrb	r3, [r1, #1]
     ebc:	788c      	ldrb	r4, [r1, #2]
      offset += length_stringsi;
      }
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     ebe:	4605      	mov	r5, r0
    {
      int offset = 0;
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
     ec0:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
     ec4:	78c8      	ldrb	r0, [r1, #3]
      offset += length_stringsi;
      }
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     ec6:	460e      	mov	r6, r1
    {
      int offset = 0;
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
     ec8:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
     ecc:	6869      	ldr	r1, [r5, #4]
    {
      int offset = 0;
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
     ece:	ea43 6400 	orr.w	r4, r3, r0, lsl #24
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
     ed2:	428c      	cmp	r4, r1
      offset += length_stringsi;
      }
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer) override
     ed4:	b083      	sub	sp, #12
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
     ed6:	f200 80ba 	bhi.w	104e <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x19a>
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
      ints_length = ints_lengthT;
     eda:	606c      	str	r4, [r5, #4]
      for( uint32_t i = 0; i < ints_length; i++){
     edc:	2c00      	cmp	r4, #0
     ede:	f000 80bf 	beq.w	1060 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x1ac>
     ee2:	f105 0908 	add.w	r9, r5, #8
     ee6:	4634      	mov	r4, r6
     ee8:	2700      	movs	r7, #0
     eea:	f04f 0804 	mov.w	r8, #4
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
     eee:	79a1      	ldrb	r1, [r4, #6]
     ef0:	7963      	ldrb	r3, [r4, #5]
     ef2:	7922      	ldrb	r2, [r4, #4]
     ef4:	f894 e007 	ldrb.w	lr, [r4, #7]
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
     ef8:	68e8      	ldr	r0, [r5, #12]
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
     efa:	0409      	lsls	r1, r1, #16
     efc:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
     f00:	4313      	orrs	r3, r2
     f02:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
     f06:	60ab      	str	r3, [r5, #8]
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
     f08:	eb00 0087 	add.w	r0, r0, r7, lsl #2
     f0c:	2204      	movs	r2, #4
     f0e:	4649      	mov	r1, r9
     f10:	f003 fdb6 	bl	4a80 <memcpy>
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
      ints_length = ints_lengthT;
      for( uint32_t i = 0; i < ints_length; i++){
     f14:	686b      	ldr	r3, [r5, #4]
     f16:	3701      	adds	r7, #1
     f18:	42bb      	cmp	r3, r7
     f1a:	4642      	mov	r2, r8
     f1c:	f104 0404 	add.w	r4, r4, #4
     f20:	f108 0804 	add.w	r8, r8, #4
     f24:	d8e3      	bhi.n	eee <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x3a>
     f26:	f102 0708 	add.w	r7, r2, #8
     f2a:	4641      	mov	r1, r8
     f2c:	46b9      	mov	r9, r7
     f2e:	f102 0e05 	add.w	lr, r2, #5
     f32:	1d90      	adds	r0, r2, #6
     f34:	1dd3      	adds	r3, r2, #7
     f36:	f102 0b09 	add.w	fp, r2, #9
     f3a:	f102 080a 	add.w	r8, r2, #10
     f3e:	f102 0a0b 	add.w	sl, r2, #11
     f42:	f102 040c 	add.w	r4, r2, #12
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
     f46:	5c30      	ldrb	r0, [r6, r0]
     f48:	f816 200e 	ldrb.w	r2, [r6, lr]
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
     f4c:	5c71      	ldrb	r1, [r6, r1]
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
     f4e:	f816 e003 	ldrb.w	lr, [r6, r3]
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
     f52:	692b      	ldr	r3, [r5, #16]
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
     f54:	0400      	lsls	r0, r0, #16
     f56:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
     f5a:	430a      	orrs	r2, r1
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
     f5c:	ea42 620e 	orr.w	r2, r2, lr, lsl #24
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
     f60:	429a      	cmp	r2, r3
     f62:	f200 8092 	bhi.w	108a <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x1d6>
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
      floats_length = floats_lengthT;
     f66:	612a      	str	r2, [r5, #16]
      for( uint32_t i = 0; i < floats_length; i++){
     f68:	b34a      	cbz	r2, fbe <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x10a>
     f6a:	f105 0a14 	add.w	sl, r5, #20
     f6e:	eb06 0709 	add.w	r7, r6, r9
     f72:	f04f 0800 	mov.w	r8, #0
      } u_st_floats;
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
     f76:	78b9      	ldrb	r1, [r7, #2]
     f78:	787b      	ldrb	r3, [r7, #1]
     f7a:	783a      	ldrb	r2, [r7, #0]
     f7c:	78fc      	ldrb	r4, [r7, #3]
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
     f7e:	69a8      	ldr	r0, [r5, #24]
      } u_st_floats;
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
     f80:	0409      	lsls	r1, r1, #16
     f82:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
     f86:	4313      	orrs	r3, r2
      this->st_floats = u_st_floats.real;
     f88:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
     f8c:	616b      	str	r3, [r5, #20]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
     f8e:	eb00 0088 	add.w	r0, r0, r8, lsl #2
     f92:	2204      	movs	r2, #4
     f94:	4651      	mov	r1, sl
     f96:	f003 fd73 	bl	4a80 <memcpy>
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
      floats_length = floats_lengthT;
      for( uint32_t i = 0; i < floats_length; i++){
     f9a:	692b      	ldr	r3, [r5, #16]
     f9c:	f108 0801 	add.w	r8, r8, #1
     fa0:	4543      	cmp	r3, r8
     fa2:	464c      	mov	r4, r9
     fa4:	f107 0704 	add.w	r7, r7, #4
     fa8:	f109 0904 	add.w	r9, r9, #4
     fac:	d8e3      	bhi.n	f76 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0xc2>
     fae:	f104 0b05 	add.w	fp, r4, #5
     fb2:	f104 0806 	add.w	r8, r4, #6
     fb6:	f104 0a07 	add.w	sl, r4, #7
     fba:	464f      	mov	r7, r9
     fbc:	3408      	adds	r4, #8
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
     fbe:	f816 2008 	ldrb.w	r2, [r6, r8]
     fc2:	f816 000b 	ldrb.w	r0, [r6, fp]
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
     fc6:	5df3      	ldrb	r3, [r6, r7]
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
     fc8:	f816 700a 	ldrb.w	r7, [r6, sl]
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
     fcc:	69e9      	ldr	r1, [r5, #28]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
     fce:	0412      	lsls	r2, r2, #16
     fd0:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
     fd4:	4313      	orrs	r3, r2
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
     fd6:	ea43 6707 	orr.w	r7, r3, r7, lsl #24
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
     fda:	428f      	cmp	r7, r1
     fdc:	d84f      	bhi.n	107e <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x1ca>
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      strings_length = strings_lengthT;
     fde:	61ef      	str	r7, [r5, #28]
      for( uint32_t i = 0; i < strings_length; i++){
     fe0:	b38f      	cbz	r7, 1046 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x192>
     fe2:	f04f 0900 	mov.w	r9, #0
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
     fe6:	46c8      	mov	r8, r9
     fe8:	f105 0720 	add.w	r7, r5, #32
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
      uint32_t length_st_strings;
      arrToVar(length_st_strings, (inbuffer + offset));
     fec:	2300      	movs	r3, #0

  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
     fee:	469e      	mov	lr, r3
     ff0:	1931      	adds	r1, r6, r4
    for (size_t i = 0; i < sizeof(V); i++)
      var |= (arr[i] << (8 * i));
     ff2:	f811 2b01 	ldrb.w	r2, [r1], #1
     ff6:	409a      	lsls	r2, r3
     ff8:	3308      	adds	r3, #8
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
     ffa:	2b20      	cmp	r3, #32
      var |= (arr[i] << (8 * i));
     ffc:	ea4e 0e02 	orr.w	lr, lr, r2
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
    1000:	d1f7      	bne.n	ff2 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x13e>
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
    1002:	1d20      	adds	r0, r4, #4
    1004:	4486      	add	lr, r0
    1006:	4570      	cmp	r0, lr
    1008:	d209      	bcs.n	101e <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x16a>
    100a:	1ce3      	adds	r3, r4, #3
    100c:	4433      	add	r3, r6
    100e:	4602      	mov	r2, r0
    1010:	3201      	adds	r2, #1
          inbuffer[k-1]=inbuffer[k];
    1012:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    1016:	f803 1c01 	strb.w	r1, [r3, #-1]
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
      uint32_t length_st_strings;
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
    101a:	4572      	cmp	r2, lr
    101c:	d3f8      	bcc.n	1010 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x15c>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    101e:	eb06 020e 	add.w	r2, r6, lr
      this->st_strings = (char *)(inbuffer + offset-1);
    1022:	1e43      	subs	r3, r0, #1
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    1024:	f802 8c01 	strb.w	r8, [r2, #-1]
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    1028:	6a68      	ldr	r0, [r5, #36]	; 0x24
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
    102a:	4433      	add	r3, r6
    102c:	622b      	str	r3, [r5, #32]
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    102e:	eb00 0089 	add.w	r0, r0, r9, lsl #2
    1032:	2204      	movs	r2, #4
    1034:	4639      	mov	r1, r7
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
    1036:	4674      	mov	r4, lr
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    1038:	f003 fd22 	bl	4a80 <memcpy>
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
    103c:	69eb      	ldr	r3, [r5, #28]
    103e:	f109 0901 	add.w	r9, r9, #1
    1042:	454b      	cmp	r3, r9
    1044:	d8d2      	bhi.n	fec <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x138>
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
      }
     return offset;
    }
    1046:	4620      	mov	r0, r4
    1048:	b003      	add	sp, #12
    104a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
    104e:	00a1      	lsls	r1, r4, #2
    1050:	68e8      	ldr	r0, [r5, #12]
    1052:	f007 fd2d 	bl	8ab0 <realloc>
      ints_length = ints_lengthT;
    1056:	606c      	str	r4, [r5, #4]
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
    1058:	60e8      	str	r0, [r5, #12]
      ints_length = ints_lengthT;
      for( uint32_t i = 0; i < ints_length; i++){
    105a:	2c00      	cmp	r4, #0
    105c:	f47f af41 	bne.w	ee2 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x2e>
    1060:	2708      	movs	r7, #8
    1062:	46b9      	mov	r9, r7
    1064:	240c      	movs	r4, #12
    1066:	f04f 0a0b 	mov.w	sl, #11
    106a:	f04f 080a 	mov.w	r8, #10
    106e:	f04f 0b09 	mov.w	fp, #9
    1072:	2307      	movs	r3, #7
    1074:	2006      	movs	r0, #6
    1076:	f04f 0e05 	mov.w	lr, #5
    107a:	2104      	movs	r1, #4
    107c:	e763      	b.n	f46 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x92>
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
    107e:	00b9      	lsls	r1, r7, #2
    1080:	6a68      	ldr	r0, [r5, #36]	; 0x24
    1082:	f007 fd15 	bl	8ab0 <realloc>
    1086:	6268      	str	r0, [r5, #36]	; 0x24
    1088:	e7a9      	b.n	fde <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0x12a>
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
    108a:	0091      	lsls	r1, r2, #2
    108c:	69a8      	ldr	r0, [r5, #24]
    108e:	9201      	str	r2, [sp, #4]
    1090:	f007 fd0e 	bl	8ab0 <realloc>
    1094:	9a01      	ldr	r2, [sp, #4]
    1096:	61a8      	str	r0, [r5, #24]
    1098:	e765      	b.n	f66 <rosserial_msgs::RequestParamResponse::deserialize(unsigned char*)+0xb2>
    109a:	bf00      	nop

0000109c <geometry_msgs::Twist::serialize(unsigned char*) const>:
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    109c:	6902      	ldr	r2, [r0, #16]
    109e:	6943      	ldr	r3, [r0, #20]
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
    10a0:	710b      	strb	r3, [r1, #4]
      linear(),
      angular()
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
    10a2:	b4f0      	push	{r4, r5, r6, r7}
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
    10a4:	0a14      	lsrs	r4, r2, #8
    10a6:	704c      	strb	r4, [r1, #1]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    10a8:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    10aa:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    10ac:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    10ae:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    10b0:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    10b2:	708f      	strb	r7, [r1, #2]
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    10b4:	70ce      	strb	r6, [r1, #3]
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    10b6:	714d      	strb	r5, [r1, #5]
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    10b8:	718c      	strb	r4, [r1, #6]
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    10ba:	700a      	strb	r2, [r1, #0]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    10bc:	71cb      	strb	r3, [r1, #7]
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    10be:	6982      	ldr	r2, [r0, #24]
    10c0:	69c3      	ldr	r3, [r0, #28]
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
    10c2:	730b      	strb	r3, [r1, #12]
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    10c4:	0a14      	lsrs	r4, r2, #8
    10c6:	724c      	strb	r4, [r1, #9]
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    10c8:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    10ca:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    10cc:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    10ce:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    10d0:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    10d2:	728f      	strb	r7, [r1, #10]
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    10d4:	72ce      	strb	r6, [r1, #11]
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    10d6:	734d      	strb	r5, [r1, #13]
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    10d8:	738c      	strb	r4, [r1, #14]
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    10da:	720a      	strb	r2, [r1, #8]
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    10dc:	73cb      	strb	r3, [r1, #15]
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    10de:	6a02      	ldr	r2, [r0, #32]
    10e0:	6a43      	ldr	r3, [r0, #36]	; 0x24
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
    10e2:	750b      	strb	r3, [r1, #20]
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    10e4:	0a14      	lsrs	r4, r2, #8
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    10e6:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    10e8:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    10ea:	0a1d      	lsrs	r5, r3, #8
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    10ec:	744c      	strb	r4, [r1, #17]
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    10ee:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    10f0:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    10f2:	748f      	strb	r7, [r1, #18]
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    10f4:	74ce      	strb	r6, [r1, #19]
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    10f6:	754d      	strb	r5, [r1, #21]
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    10f8:	758c      	strb	r4, [r1, #22]
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    10fa:	740a      	strb	r2, [r1, #16]
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    10fc:	75cb      	strb	r3, [r1, #23]
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    10fe:	6b03      	ldr	r3, [r0, #48]	; 0x30
    1100:	6b42      	ldr	r2, [r0, #52]	; 0x34
    1102:	760b      	strb	r3, [r1, #24]
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
    1104:	0a1c      	lsrs	r4, r3, #8
    1106:	764c      	strb	r4, [r1, #25]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    1108:	0c1f      	lsrs	r7, r3, #16
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    110a:	0a16      	lsrs	r6, r2, #8
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    110c:	0c15      	lsrs	r5, r2, #16
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    110e:	0e14      	lsrs	r4, r2, #24
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    1110:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    1112:	768f      	strb	r7, [r1, #26]
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    1114:	774e      	strb	r6, [r1, #29]
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    1116:	778d      	strb	r5, [r1, #30]
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    1118:	77cc      	strb	r4, [r1, #31]
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
    111a:	770a      	strb	r2, [r1, #28]
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    111c:	76cb      	strb	r3, [r1, #27]
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    111e:	6b82      	ldr	r2, [r0, #56]	; 0x38
    1120:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
    1122:	f881 3024 	strb.w	r3, [r1, #36]	; 0x24
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    1126:	0a14      	lsrs	r4, r2, #8
    1128:	f881 4021 	strb.w	r4, [r1, #33]	; 0x21
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    112c:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    112e:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    1130:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    1132:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    1134:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    1136:	f881 7022 	strb.w	r7, [r1, #34]	; 0x22
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    113a:	f881 6023 	strb.w	r6, [r1, #35]	; 0x23
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    113e:	f881 5025 	strb.w	r5, [r1, #37]	; 0x25
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    1142:	f881 4026 	strb.w	r4, [r1, #38]	; 0x26
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    1146:	f881 2020 	strb.w	r2, [r1, #32]
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    114a:	f881 3027 	strb.w	r3, [r1, #39]	; 0x27
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    114e:	6c02      	ldr	r2, [r0, #64]	; 0x40
    1150:	6c43      	ldr	r3, [r0, #68]	; 0x44
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
    1152:	f881 302c 	strb.w	r3, [r1, #44]	; 0x2c
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    1156:	0a1c      	lsrs	r4, r3, #8
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    1158:	0c18      	lsrs	r0, r3, #16
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    115a:	0a17      	lsrs	r7, r2, #8
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    115c:	0c16      	lsrs	r6, r2, #16
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    115e:	0e15      	lsrs	r5, r2, #24
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    1160:	0e1b      	lsrs	r3, r3, #24
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    1162:	f881 002e 	strb.w	r0, [r1, #46]	; 0x2e
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    1166:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    116a:	f881 7029 	strb.w	r7, [r1, #41]	; 0x29
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    116e:	f881 602a 	strb.w	r6, [r1, #42]	; 0x2a
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    1172:	f881 502b 	strb.w	r5, [r1, #43]	; 0x2b
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    1176:	f881 402d 	strb.w	r4, [r1, #45]	; 0x2d
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    117a:	f881 302f 	strb.w	r3, [r1, #47]	; 0x2f
    {
      int offset = 0;
      offset += this->linear.serialize(outbuffer + offset);
      offset += this->angular.serialize(outbuffer + offset);
      return offset;
    }
    117e:	2030      	movs	r0, #48	; 0x30
    1180:	bcf0      	pop	{r4, r5, r6, r7}
    1182:	4770      	bx	lr

00001184 <custom_msgs::odom_and_imu::serialize(unsigned char*) const>:
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    1184:	6902      	ldr	r2, [r0, #16]
    1186:	6943      	ldr	r3, [r0, #20]
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
    1188:	710b      	strb	r3, [r1, #4]
      omega_left(0),
      temp(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const override
    118a:	b4f0      	push	{r4, r5, r6, r7}
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
    118c:	0a14      	lsrs	r4, r2, #8
    118e:	704c      	strb	r4, [r1, #1]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    1190:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    1192:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    1194:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    1196:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    1198:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    119a:	708f      	strb	r7, [r1, #2]
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    119c:	70ce      	strb	r6, [r1, #3]
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    119e:	714d      	strb	r5, [r1, #5]
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    11a0:	718c      	strb	r4, [r1, #6]
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    11a2:	700a      	strb	r2, [r1, #0]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    11a4:	71cb      	strb	r3, [r1, #7]
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    11a6:	6982      	ldr	r2, [r0, #24]
    11a8:	69c3      	ldr	r3, [r0, #28]
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
    11aa:	730b      	strb	r3, [r1, #12]
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    11ac:	0a14      	lsrs	r4, r2, #8
    11ae:	724c      	strb	r4, [r1, #9]
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    11b0:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    11b2:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    11b4:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    11b6:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    11b8:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    11ba:	728f      	strb	r7, [r1, #10]
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    11bc:	72ce      	strb	r6, [r1, #11]
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    11be:	734d      	strb	r5, [r1, #13]
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    11c0:	738c      	strb	r4, [r1, #14]
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    11c2:	720a      	strb	r2, [r1, #8]
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    11c4:	73cb      	strb	r3, [r1, #15]
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    11c6:	6a02      	ldr	r2, [r0, #32]
    11c8:	6a43      	ldr	r3, [r0, #36]	; 0x24
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
    11ca:	750b      	strb	r3, [r1, #20]
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    11cc:	0a14      	lsrs	r4, r2, #8
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    11ce:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    11d0:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    11d2:	0a1d      	lsrs	r5, r3, #8
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    11d4:	744c      	strb	r4, [r1, #17]
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    11d6:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    11d8:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    11da:	748f      	strb	r7, [r1, #18]
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    11dc:	74ce      	strb	r6, [r1, #19]
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    11de:	754d      	strb	r5, [r1, #21]
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    11e0:	758c      	strb	r4, [r1, #22]
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    11e2:	740a      	strb	r2, [r1, #16]
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    11e4:	75cb      	strb	r3, [r1, #23]
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    11e6:	6b03      	ldr	r3, [r0, #48]	; 0x30
    11e8:	6b42      	ldr	r2, [r0, #52]	; 0x34
    11ea:	760b      	strb	r3, [r1, #24]
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
    11ec:	0a1c      	lsrs	r4, r3, #8
    11ee:	764c      	strb	r4, [r1, #25]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    11f0:	0c1f      	lsrs	r7, r3, #16
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    11f2:	0a16      	lsrs	r6, r2, #8
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    11f4:	0c15      	lsrs	r5, r2, #16
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    11f6:	0e14      	lsrs	r4, r2, #24
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    11f8:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    11fa:	768f      	strb	r7, [r1, #26]
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    11fc:	774e      	strb	r6, [r1, #29]
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    11fe:	778d      	strb	r5, [r1, #30]
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    1200:	77cc      	strb	r4, [r1, #31]
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
    1202:	770a      	strb	r2, [r1, #28]
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    1204:	76cb      	strb	r3, [r1, #27]
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    1206:	6b82      	ldr	r2, [r0, #56]	; 0x38
    1208:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
    120a:	f881 3024 	strb.w	r3, [r1, #36]	; 0x24
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    120e:	0a14      	lsrs	r4, r2, #8
    1210:	f881 4021 	strb.w	r4, [r1, #33]	; 0x21
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    1214:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    1216:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    1218:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    121a:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    121c:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    121e:	f881 7022 	strb.w	r7, [r1, #34]	; 0x22
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    1222:	f881 6023 	strb.w	r6, [r1, #35]	; 0x23
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    1226:	f881 5025 	strb.w	r5, [r1, #37]	; 0x25
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    122a:	f881 4026 	strb.w	r4, [r1, #38]	; 0x26
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    122e:	f881 2020 	strb.w	r2, [r1, #32]
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    1232:	f881 3027 	strb.w	r3, [r1, #39]	; 0x27
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    1236:	6c02      	ldr	r2, [r0, #64]	; 0x40
    1238:	6c43      	ldr	r3, [r0, #68]	; 0x44
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
    123a:	f881 302c 	strb.w	r3, [r1, #44]	; 0x2c
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    123e:	0a14      	lsrs	r4, r2, #8
    1240:	f881 4029 	strb.w	r4, [r1, #41]	; 0x29
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    1244:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    1246:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    1248:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    124a:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    124c:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    124e:	f881 702a 	strb.w	r7, [r1, #42]	; 0x2a
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    1252:	f881 602b 	strb.w	r6, [r1, #43]	; 0x2b
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    1256:	f881 502d 	strb.w	r5, [r1, #45]	; 0x2d
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    125a:	f881 402e 	strb.w	r4, [r1, #46]	; 0x2e
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    125e:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    1262:	f881 302f 	strb.w	r3, [r1, #47]	; 0x2f
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    1266:	6d03      	ldr	r3, [r0, #80]	; 0x50
    1268:	6d42      	ldr	r2, [r0, #84]	; 0x54
    126a:	f881 3030 	strb.w	r3, [r1, #48]	; 0x30
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
    126e:	0a1c      	lsrs	r4, r3, #8
    1270:	f881 4031 	strb.w	r4, [r1, #49]	; 0x31
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    1274:	0c1f      	lsrs	r7, r3, #16
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    1276:	0a16      	lsrs	r6, r2, #8
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    1278:	0c15      	lsrs	r5, r2, #16
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    127a:	0e14      	lsrs	r4, r2, #24
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    127c:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    127e:	f881 7032 	strb.w	r7, [r1, #50]	; 0x32
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    1282:	f881 6035 	strb.w	r6, [r1, #53]	; 0x35
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    1286:	f881 5036 	strb.w	r5, [r1, #54]	; 0x36
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    128a:	f881 4037 	strb.w	r4, [r1, #55]	; 0x37
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    128e:	f881 3033 	strb.w	r3, [r1, #51]	; 0x33
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
    1292:	f881 2034 	strb.w	r2, [r1, #52]	; 0x34
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    1296:	6d82      	ldr	r2, [r0, #88]	; 0x58
    1298:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
    129a:	f881 303c 	strb.w	r3, [r1, #60]	; 0x3c
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    129e:	0a14      	lsrs	r4, r2, #8
    12a0:	f881 4039 	strb.w	r4, [r1, #57]	; 0x39
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    12a4:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    12a6:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    12a8:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    12aa:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    12ac:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    12ae:	f881 703a 	strb.w	r7, [r1, #58]	; 0x3a
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    12b2:	f881 603b 	strb.w	r6, [r1, #59]	; 0x3b
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    12b6:	f881 503d 	strb.w	r5, [r1, #61]	; 0x3d
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    12ba:	f881 403e 	strb.w	r4, [r1, #62]	; 0x3e
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    12be:	f881 2038 	strb.w	r2, [r1, #56]	; 0x38
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    12c2:	f881 303f 	strb.w	r3, [r1, #63]	; 0x3f
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    12c6:	6e02      	ldr	r2, [r0, #96]	; 0x60
    12c8:	6e43      	ldr	r3, [r0, #100]	; 0x64
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
    12ca:	f881 3044 	strb.w	r3, [r1, #68]	; 0x44
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    12ce:	0a14      	lsrs	r4, r2, #8
    12d0:	f881 4041 	strb.w	r4, [r1, #65]	; 0x41
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    12d4:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    12d6:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    12d8:	0a1d      	lsrs	r5, r3, #8
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    12da:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    12dc:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    12de:	f881 7042 	strb.w	r7, [r1, #66]	; 0x42
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    12e2:	f881 6043 	strb.w	r6, [r1, #67]	; 0x43
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    12e6:	f881 5045 	strb.w	r5, [r1, #69]	; 0x45
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    12ea:	f881 4046 	strb.w	r4, [r1, #70]	; 0x46
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    12ee:	f881 2040 	strb.w	r2, [r1, #64]	; 0x40
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    12f2:	f881 3047 	strb.w	r3, [r1, #71]	; 0x47
      union {
        double real;
        uint64_t base;
      } u_omega_right;
      u_omega_right.real = this->omega_right;
      *(outbuffer + offset + 0) = (u_omega_right.base >> (8 * 0)) & 0xFF;
    12f6:	6e82      	ldr	r2, [r0, #104]	; 0x68
    12f8:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
      *(outbuffer + offset + 1) = (u_omega_right.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_omega_right.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_omega_right.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_omega_right.base >> (8 * 4)) & 0xFF;
    12fa:	f881 304c 	strb.w	r3, [r1, #76]	; 0x4c
        double real;
        uint64_t base;
      } u_omega_right;
      u_omega_right.real = this->omega_right;
      *(outbuffer + offset + 0) = (u_omega_right.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_right.base >> (8 * 1)) & 0xFF;
    12fe:	0a14      	lsrs	r4, r2, #8
      *(outbuffer + offset + 2) = (u_omega_right.base >> (8 * 2)) & 0xFF;
    1300:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_omega_right.base >> (8 * 3)) & 0xFF;
    1302:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_omega_right.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_right.base >> (8 * 5)) & 0xFF;
    1304:	0a1d      	lsrs	r5, r3, #8
        double real;
        uint64_t base;
      } u_omega_right;
      u_omega_right.real = this->omega_right;
      *(outbuffer + offset + 0) = (u_omega_right.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_right.base >> (8 * 1)) & 0xFF;
    1306:	f881 4049 	strb.w	r4, [r1, #73]	; 0x49
      *(outbuffer + offset + 2) = (u_omega_right.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_omega_right.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_omega_right.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_right.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_omega_right.base >> (8 * 6)) & 0xFF;
    130a:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_omega_right.base >> (8 * 7)) & 0xFF;
    130c:	0e1b      	lsrs	r3, r3, #24
      union {
        double real;
        uint64_t base;
      } u_omega_right;
      u_omega_right.real = this->omega_right;
      *(outbuffer + offset + 0) = (u_omega_right.base >> (8 * 0)) & 0xFF;
    130e:	f881 2048 	strb.w	r2, [r1, #72]	; 0x48
      *(outbuffer + offset + 1) = (u_omega_right.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_omega_right.base >> (8 * 2)) & 0xFF;
    1312:	f881 704a 	strb.w	r7, [r1, #74]	; 0x4a
      *(outbuffer + offset + 3) = (u_omega_right.base >> (8 * 3)) & 0xFF;
    1316:	f881 604b 	strb.w	r6, [r1, #75]	; 0x4b
      *(outbuffer + offset + 4) = (u_omega_right.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_right.base >> (8 * 5)) & 0xFF;
    131a:	f881 504d 	strb.w	r5, [r1, #77]	; 0x4d
      *(outbuffer + offset + 6) = (u_omega_right.base >> (8 * 6)) & 0xFF;
    131e:	f881 404e 	strb.w	r4, [r1, #78]	; 0x4e
      *(outbuffer + offset + 7) = (u_omega_right.base >> (8 * 7)) & 0xFF;
    1322:	f881 304f 	strb.w	r3, [r1, #79]	; 0x4f
      union {
        double real;
        uint64_t base;
      } u_omega_left;
      u_omega_left.real = this->omega_left;
      *(outbuffer + offset + 0) = (u_omega_left.base >> (8 * 0)) & 0xFF;
    1326:	6f02      	ldr	r2, [r0, #112]	; 0x70
    1328:	6f43      	ldr	r3, [r0, #116]	; 0x74
      *(outbuffer + offset + 1) = (u_omega_left.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_omega_left.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_omega_left.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_omega_left.base >> (8 * 4)) & 0xFF;
    132a:	f881 3054 	strb.w	r3, [r1, #84]	; 0x54
        double real;
        uint64_t base;
      } u_omega_left;
      u_omega_left.real = this->omega_left;
      *(outbuffer + offset + 0) = (u_omega_left.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_left.base >> (8 * 1)) & 0xFF;
    132e:	0a14      	lsrs	r4, r2, #8
      *(outbuffer + offset + 2) = (u_omega_left.base >> (8 * 2)) & 0xFF;
    1330:	0c17      	lsrs	r7, r2, #16
      *(outbuffer + offset + 3) = (u_omega_left.base >> (8 * 3)) & 0xFF;
    1332:	0e16      	lsrs	r6, r2, #24
      *(outbuffer + offset + 4) = (u_omega_left.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_left.base >> (8 * 5)) & 0xFF;
    1334:	0a1d      	lsrs	r5, r3, #8
        double real;
        uint64_t base;
      } u_omega_left;
      u_omega_left.real = this->omega_left;
      *(outbuffer + offset + 0) = (u_omega_left.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_left.base >> (8 * 1)) & 0xFF;
    1336:	f881 4051 	strb.w	r4, [r1, #81]	; 0x51
      *(outbuffer + offset + 2) = (u_omega_left.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_omega_left.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_omega_left.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_left.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_omega_left.base >> (8 * 6)) & 0xFF;
    133a:	0c1c      	lsrs	r4, r3, #16
      *(outbuffer + offset + 7) = (u_omega_left.base >> (8 * 7)) & 0xFF;
    133c:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_omega_left;
      u_omega_left.real = this->omega_left;
      *(outbuffer + offset + 0) = (u_omega_left.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_left.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_omega_left.base >> (8 * 2)) & 0xFF;
    133e:	f881 7052 	strb.w	r7, [r1, #82]	; 0x52
      *(outbuffer + offset + 3) = (u_omega_left.base >> (8 * 3)) & 0xFF;
    1342:	f881 6053 	strb.w	r6, [r1, #83]	; 0x53
      *(outbuffer + offset + 4) = (u_omega_left.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_left.base >> (8 * 5)) & 0xFF;
    1346:	f881 5055 	strb.w	r5, [r1, #85]	; 0x55
      *(outbuffer + offset + 6) = (u_omega_left.base >> (8 * 6)) & 0xFF;
    134a:	f881 4056 	strb.w	r4, [r1, #86]	; 0x56
      union {
        double real;
        uint64_t base;
      } u_omega_left;
      u_omega_left.real = this->omega_left;
      *(outbuffer + offset + 0) = (u_omega_left.base >> (8 * 0)) & 0xFF;
    134e:	f881 2050 	strb.w	r2, [r1, #80]	; 0x50
      *(outbuffer + offset + 2) = (u_omega_left.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_omega_left.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_omega_left.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_left.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_omega_left.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_omega_left.base >> (8 * 7)) & 0xFF;
    1352:	f881 3057 	strb.w	r3, [r1, #87]	; 0x57
      union {
        double real;
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
    1356:	6f82      	ldr	r2, [r0, #120]	; 0x78
    1358:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
      *(outbuffer + offset + 1) = (u_temp.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_temp.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_temp.base >> (8 * 4)) & 0xFF;
    135a:	f881 305c 	strb.w	r3, [r1, #92]	; 0x5c
      *(outbuffer + offset + 5) = (u_temp.base >> (8 * 5)) & 0xFF;
    135e:	0a1c      	lsrs	r4, r3, #8
      *(outbuffer + offset + 6) = (u_temp.base >> (8 * 6)) & 0xFF;
    1360:	0c18      	lsrs	r0, r3, #16
        double real;
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_temp.base >> (8 * 1)) & 0xFF;
    1362:	0a17      	lsrs	r7, r2, #8
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
    1364:	0c16      	lsrs	r6, r2, #16
      *(outbuffer + offset + 3) = (u_temp.base >> (8 * 3)) & 0xFF;
    1366:	0e15      	lsrs	r5, r2, #24
      *(outbuffer + offset + 4) = (u_temp.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_temp.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_temp.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_temp.base >> (8 * 7)) & 0xFF;
    1368:	0e1b      	lsrs	r3, r3, #24
        double real;
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_temp.base >> (8 * 1)) & 0xFF;
    136a:	f881 7059 	strb.w	r7, [r1, #89]	; 0x59
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
    136e:	f881 605a 	strb.w	r6, [r1, #90]	; 0x5a
      *(outbuffer + offset + 3) = (u_temp.base >> (8 * 3)) & 0xFF;
    1372:	f881 505b 	strb.w	r5, [r1, #91]	; 0x5b
      *(outbuffer + offset + 4) = (u_temp.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_temp.base >> (8 * 5)) & 0xFF;
    1376:	f881 405d 	strb.w	r4, [r1, #93]	; 0x5d
      *(outbuffer + offset + 6) = (u_temp.base >> (8 * 6)) & 0xFF;
    137a:	f881 005e 	strb.w	r0, [r1, #94]	; 0x5e
      union {
        double real;
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
    137e:	f881 2058 	strb.w	r2, [r1, #88]	; 0x58
      *(outbuffer + offset + 5) = (u_temp.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_temp.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_temp.base >> (8 * 7)) & 0xFF;
      offset += sizeof(this->temp);
      return offset;
    }
    1382:	2060      	movs	r0, #96	; 0x60
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_temp.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_temp.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_temp.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_temp.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_temp.base >> (8 * 7)) & 0xFF;
    1384:	f881 305f 	strb.w	r3, [r1, #95]	; 0x5f
      offset += sizeof(this->temp);
      return offset;
    }
    1388:	bcf0      	pop	{r4, r5, r6, r7}
    138a:	4770      	bx	lr

0000138c <ros::Subscriber<geometry_msgs::Twist, void>::callback(unsigned char*)>:
    endpoint_(endpoint)
  {
    topic_ = topic_name;
  };

  virtual void callback(unsigned char* data) override
    138c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1390:	f891 c001 	ldrb.w	ip, [r1, #1]
    1394:	f891 e000 	ldrb.w	lr, [r1]
    1398:	794a      	ldrb	r2, [r1, #5]
    139a:	f891 b002 	ldrb.w	fp, [r1, #2]
    139e:	f891 a003 	ldrb.w	sl, [r1, #3]
    13a2:	4603      	mov	r3, r0
    13a4:	7908      	ldrb	r0, [r1, #4]
    13a6:	ea4e 2e0c 	orr.w	lr, lr, ip, lsl #8
    13aa:	f891 c006 	ldrb.w	ip, [r1, #6]
    13ae:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    13b2:	79c8      	ldrb	r0, [r1, #7]
    13b4:	ea4e 4e0b 	orr.w	lr, lr, fp, lsl #16
    13b8:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
    13bc:	ea4e 680a 	orr.w	r8, lr, sl, lsl #24
    13c0:	ea42 6900 	orr.w	r9, r2, r0, lsl #24
      this->x = u_x.real;
    13c4:	e9c3 8908 	strd	r8, r9, [r3, #32]
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    13c8:	f891 c009 	ldrb.w	ip, [r1, #9]
    13cc:	f891 e008 	ldrb.w	lr, [r1, #8]
    13d0:	7b08      	ldrb	r0, [r1, #12]
    13d2:	7b4a      	ldrb	r2, [r1, #13]
    13d4:	f891 900a 	ldrb.w	r9, [r1, #10]
    13d8:	f891 800b 	ldrb.w	r8, [r1, #11]
    13dc:	ea4e 2e0c 	orr.w	lr, lr, ip, lsl #8
    13e0:	f891 c00e 	ldrb.w	ip, [r1, #14]
    13e4:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    13e8:	7bc8      	ldrb	r0, [r1, #15]
    13ea:	ea4e 4e09 	orr.w	lr, lr, r9, lsl #16
    13ee:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
    13f2:	ea4e 6608 	orr.w	r6, lr, r8, lsl #24
    13f6:	ea42 6700 	orr.w	r7, r2, r0, lsl #24
      this->y = u_y.real;
    13fa:	e9c3 670a 	strd	r6, r7, [r3, #40]	; 0x28
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    13fe:	7c4f      	ldrb	r7, [r1, #17]
    1400:	7c0e      	ldrb	r6, [r1, #16]
    1402:	7d08      	ldrb	r0, [r1, #20]
    1404:	7d4a      	ldrb	r2, [r1, #21]
    1406:	f891 c012 	ldrb.w	ip, [r1, #18]
    140a:	f891 e013 	ldrb.w	lr, [r1, #19]
    140e:	ea46 2607 	orr.w	r6, r6, r7, lsl #8
    1412:	7d8f      	ldrb	r7, [r1, #22]
    1414:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    1418:	7dc8      	ldrb	r0, [r1, #23]
    141a:	b087      	sub	sp, #28
    141c:	ea46 460c 	orr.w	r6, r6, ip, lsl #16
    1420:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
    1424:	ea46 660e 	orr.w	r6, r6, lr, lsl #24
    1428:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    142c:	9201      	str	r2, [sp, #4]
    142e:	9600      	str	r6, [sp, #0]
      this->z = u_z.real;
    1430:	e9dd 6700 	ldrd	r6, r7, [sp]
    1434:	e9c3 670c 	strd	r6, r7, [r3, #48]	; 0x30
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1438:	f891 e019 	ldrb.w	lr, [r1, #25]
    143c:	7e0e      	ldrb	r6, [r1, #24]
    143e:	7e8f      	ldrb	r7, [r1, #26]
    1440:	7f0a      	ldrb	r2, [r1, #28]
    1442:	7f48      	ldrb	r0, [r1, #29]
    1444:	f891 c01b 	ldrb.w	ip, [r1, #27]
    1448:	ea46 260e 	orr.w	r6, r6, lr, lsl #8
    144c:	f891 e01e 	ldrb.w	lr, [r1, #30]
    1450:	ea46 4607 	orr.w	r6, r6, r7, lsl #16
    1454:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
    1458:	7fcf      	ldrb	r7, [r1, #31]
  {
    msg.deserialize(data);
    this->cb_(msg);
    145a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    145c:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
    1460:	ea46 660c 	orr.w	r6, r6, ip, lsl #24
    1464:	ea40 6007 	orr.w	r0, r0, r7, lsl #24
    1468:	9003      	str	r0, [sp, #12]
    146a:	9602      	str	r6, [sp, #8]
      this->x = u_x.real;
    146c:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    1470:	e9c3 6710 	strd	r6, r7, [r3, #64]	; 0x40
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1474:	f891 e020 	ldrb.w	lr, [r1, #32]
    1478:	f891 7021 	ldrb.w	r7, [r1, #33]	; 0x21
    147c:	f891 6024 	ldrb.w	r6, [r1, #36]	; 0x24
    1480:	f891 0025 	ldrb.w	r0, [r1, #37]	; 0x25
    1484:	f891 8022 	ldrb.w	r8, [r1, #34]	; 0x22
    1488:	f891 c023 	ldrb.w	ip, [r1, #35]	; 0x23
    148c:	ea4e 2707 	orr.w	r7, lr, r7, lsl #8
    1490:	f891 e026 	ldrb.w	lr, [r1, #38]	; 0x26
    1494:	ea46 2000 	orr.w	r0, r6, r0, lsl #8
    1498:	f891 6027 	ldrb.w	r6, [r1, #39]	; 0x27
    149c:	ea47 4708 	orr.w	r7, r7, r8, lsl #16
    14a0:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
    14a4:	ea47 670c 	orr.w	r7, r7, ip, lsl #24
    14a8:	ea40 6006 	orr.w	r0, r0, r6, lsl #24
    14ac:	9005      	str	r0, [sp, #20]
    14ae:	9704      	str	r7, [sp, #16]
      this->y = u_y.real;
    14b0:	e9dd 6704 	ldrd	r6, r7, [sp, #16]
    14b4:	e9c3 6712 	strd	r6, r7, [r3, #72]	; 0x48
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    14b8:	f891 7028 	ldrb.w	r7, [r1, #40]	; 0x28
    14bc:	f891 6029 	ldrb.w	r6, [r1, #41]	; 0x29
    14c0:	f891 002c 	ldrb.w	r0, [r1, #44]	; 0x2c
    14c4:	f891 802d 	ldrb.w	r8, [r1, #45]	; 0x2d
    14c8:	f891 902a 	ldrb.w	r9, [r1, #42]	; 0x2a
    14cc:	f891 c02b 	ldrb.w	ip, [r1, #43]	; 0x2b
    14d0:	f891 e02e 	ldrb.w	lr, [r1, #46]	; 0x2e
    14d4:	ea47 2606 	orr.w	r6, r7, r6, lsl #8
    14d8:	f891 702f 	ldrb.w	r7, [r1, #47]	; 0x2f
    14dc:	ea40 2108 	orr.w	r1, r0, r8, lsl #8
    14e0:	ea46 4609 	orr.w	r6, r6, r9, lsl #16
    14e4:	ea41 410e 	orr.w	r1, r1, lr, lsl #16
    14e8:	ea46 640c 	orr.w	r4, r6, ip, lsl #24
    14ec:	ea41 6507 	orr.w	r5, r1, r7, lsl #24
    14f0:	f103 0010 	add.w	r0, r3, #16
      this->z = u_z.real;
    14f4:	e9c3 4514 	strd	r4, r5, [r3, #80]	; 0x50
  }
    14f8:	b007      	add	sp, #28
    14fa:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  };

  virtual void callback(unsigned char* data) override
  {
    msg.deserialize(data);
    this->cb_(msg);
    14fe:	4710      	bx	r2

00001500 <geometry_msgs::Twist::deserialize(unsigned char*)>:

    virtual int deserialize(unsigned char *inbuffer) override
    1500:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1504:	f891 c001 	ldrb.w	ip, [r1, #1]
    1508:	f891 e000 	ldrb.w	lr, [r1]
    150c:	794a      	ldrb	r2, [r1, #5]
    150e:	f891 b002 	ldrb.w	fp, [r1, #2]
    1512:	f891 a003 	ldrb.w	sl, [r1, #3]
    1516:	4603      	mov	r3, r0
    1518:	7908      	ldrb	r0, [r1, #4]
    151a:	ea4e 2e0c 	orr.w	lr, lr, ip, lsl #8
    151e:	f891 c006 	ldrb.w	ip, [r1, #6]
    1522:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    1526:	79c8      	ldrb	r0, [r1, #7]
    1528:	ea4e 4e0b 	orr.w	lr, lr, fp, lsl #16
    152c:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
    1530:	ea4e 680a 	orr.w	r8, lr, sl, lsl #24
    1534:	ea42 6900 	orr.w	r9, r2, r0, lsl #24
      this->x = u_x.real;
    1538:	e9c3 8904 	strd	r8, r9, [r3, #16]
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    153c:	f891 c009 	ldrb.w	ip, [r1, #9]
    1540:	f891 e008 	ldrb.w	lr, [r1, #8]
    1544:	7b08      	ldrb	r0, [r1, #12]
    1546:	7b4a      	ldrb	r2, [r1, #13]
    1548:	f891 900a 	ldrb.w	r9, [r1, #10]
    154c:	f891 800b 	ldrb.w	r8, [r1, #11]
    1550:	ea4e 2e0c 	orr.w	lr, lr, ip, lsl #8
    1554:	f891 c00e 	ldrb.w	ip, [r1, #14]
    1558:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    155c:	7bc8      	ldrb	r0, [r1, #15]
    155e:	ea4e 4e09 	orr.w	lr, lr, r9, lsl #16
    1562:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
    1566:	ea4e 6608 	orr.w	r6, lr, r8, lsl #24
    156a:	ea42 6700 	orr.w	r7, r2, r0, lsl #24
      this->y = u_y.real;
    156e:	e9c3 6706 	strd	r6, r7, [r3, #24]
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1572:	7c4f      	ldrb	r7, [r1, #17]
    1574:	7c0e      	ldrb	r6, [r1, #16]
    1576:	7d08      	ldrb	r0, [r1, #20]
    1578:	7d4a      	ldrb	r2, [r1, #21]
    157a:	f891 c012 	ldrb.w	ip, [r1, #18]
    157e:	f891 e013 	ldrb.w	lr, [r1, #19]
    1582:	ea46 2607 	orr.w	r6, r6, r7, lsl #8
    1586:	7d8f      	ldrb	r7, [r1, #22]
    1588:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    158c:	7dc8      	ldrb	r0, [r1, #23]
    158e:	b087      	sub	sp, #28
    1590:	ea46 460c 	orr.w	r6, r6, ip, lsl #16
    1594:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
    1598:	ea46 660e 	orr.w	r6, r6, lr, lsl #24
    159c:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    15a0:	9201      	str	r2, [sp, #4]
    15a2:	9600      	str	r6, [sp, #0]
      this->z = u_z.real;
    15a4:	e9dd 6700 	ldrd	r6, r7, [sp]
    15a8:	e9c3 6708 	strd	r6, r7, [r3, #32]
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    15ac:	7e4f      	ldrb	r7, [r1, #25]
    15ae:	7e0e      	ldrb	r6, [r1, #24]
    15b0:	7f08      	ldrb	r0, [r1, #28]
    15b2:	7f4a      	ldrb	r2, [r1, #29]
    15b4:	f891 c01a 	ldrb.w	ip, [r1, #26]
    15b8:	f891 e01b 	ldrb.w	lr, [r1, #27]
    15bc:	ea46 2607 	orr.w	r6, r6, r7, lsl #8
    15c0:	7f8f      	ldrb	r7, [r1, #30]
    15c2:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    15c6:	7fc8      	ldrb	r0, [r1, #31]
    15c8:	ea46 460c 	orr.w	r6, r6, ip, lsl #16
    15cc:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
    15d0:	ea46 660e 	orr.w	r6, r6, lr, lsl #24
    15d4:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    15d8:	9203      	str	r2, [sp, #12]
    15da:	9602      	str	r6, [sp, #8]
      this->x = u_x.real;
    15dc:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    15e0:	e9c3 670c 	strd	r6, r7, [r3, #48]	; 0x30
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    15e4:	f891 7020 	ldrb.w	r7, [r1, #32]
    15e8:	f891 6021 	ldrb.w	r6, [r1, #33]	; 0x21
    15ec:	f891 0024 	ldrb.w	r0, [r1, #36]	; 0x24
    15f0:	f891 2025 	ldrb.w	r2, [r1, #37]	; 0x25
    15f4:	f891 c022 	ldrb.w	ip, [r1, #34]	; 0x22
    15f8:	f891 e023 	ldrb.w	lr, [r1, #35]	; 0x23
    15fc:	ea47 2606 	orr.w	r6, r7, r6, lsl #8
    1600:	f891 7026 	ldrb.w	r7, [r1, #38]	; 0x26
    1604:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    1608:	f891 0027 	ldrb.w	r0, [r1, #39]	; 0x27
    160c:	ea46 460c 	orr.w	r6, r6, ip, lsl #16
    1610:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
    1614:	ea46 660e 	orr.w	r6, r6, lr, lsl #24
    1618:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    161c:	9205      	str	r2, [sp, #20]
    161e:	9604      	str	r6, [sp, #16]
      this->y = u_y.real;
    1620:	e9dd 6704 	ldrd	r6, r7, [sp, #16]
    1624:	e9c3 670e 	strd	r6, r7, [r3, #56]	; 0x38
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1628:	f891 7029 	ldrb.w	r7, [r1, #41]	; 0x29
    162c:	f891 002c 	ldrb.w	r0, [r1, #44]	; 0x2c
    1630:	f891 6028 	ldrb.w	r6, [r1, #40]	; 0x28
    1634:	f891 202d 	ldrb.w	r2, [r1, #45]	; 0x2d
    1638:	f891 c02b 	ldrb.w	ip, [r1, #43]	; 0x2b
    163c:	f891 802a 	ldrb.w	r8, [r1, #42]	; 0x2a
    1640:	f891 e02e 	ldrb.w	lr, [r1, #46]	; 0x2e
    1644:	ea46 2607 	orr.w	r6, r6, r7, lsl #8
    1648:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    164c:	f891 702f 	ldrb.w	r7, [r1, #47]	; 0x2f
    1650:	ea42 420e 	orr.w	r2, r2, lr, lsl #16
    1654:	ea46 4108 	orr.w	r1, r6, r8, lsl #16
    1658:	ea41 640c 	orr.w	r4, r1, ip, lsl #24
    165c:	ea42 6507 	orr.w	r5, r2, r7, lsl #24
    {
      int offset = 0;
      offset += this->linear.deserialize(inbuffer + offset);
      offset += this->angular.deserialize(inbuffer + offset);
     return offset;
    }
    1660:	2030      	movs	r0, #48	; 0x30
      this->z = u_z.real;
    1662:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
    1666:	b007      	add	sp, #28
    1668:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000166c <custom_msgs::odom_and_imu::deserialize(unsigned char*)>:

    virtual int deserialize(unsigned char *inbuffer) override
    166c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1670:	f891 c001 	ldrb.w	ip, [r1, #1]
    1674:	f891 e000 	ldrb.w	lr, [r1]
    1678:	794a      	ldrb	r2, [r1, #5]
    167a:	f891 b002 	ldrb.w	fp, [r1, #2]
    167e:	f891 a003 	ldrb.w	sl, [r1, #3]
    1682:	4603      	mov	r3, r0
    1684:	7908      	ldrb	r0, [r1, #4]
    1686:	ea4e 2e0c 	orr.w	lr, lr, ip, lsl #8
    168a:	f891 c006 	ldrb.w	ip, [r1, #6]
    168e:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    1692:	79c8      	ldrb	r0, [r1, #7]
    1694:	ea4e 4e0b 	orr.w	lr, lr, fp, lsl #16
    1698:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
    169c:	ea4e 680a 	orr.w	r8, lr, sl, lsl #24
    16a0:	ea42 6900 	orr.w	r9, r2, r0, lsl #24
      this->x = u_x.real;
    16a4:	e9c3 8904 	strd	r8, r9, [r3, #16]
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    16a8:	f891 c009 	ldrb.w	ip, [r1, #9]
    16ac:	f891 e008 	ldrb.w	lr, [r1, #8]
    16b0:	7b08      	ldrb	r0, [r1, #12]
    16b2:	7b4a      	ldrb	r2, [r1, #13]
    16b4:	f891 900a 	ldrb.w	r9, [r1, #10]
    16b8:	f891 800b 	ldrb.w	r8, [r1, #11]
    16bc:	ea4e 2e0c 	orr.w	lr, lr, ip, lsl #8
    16c0:	f891 c00e 	ldrb.w	ip, [r1, #14]
    16c4:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    16c8:	7bc8      	ldrb	r0, [r1, #15]
    16ca:	ea4e 4e09 	orr.w	lr, lr, r9, lsl #16
    16ce:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
    16d2:	ea4e 6608 	orr.w	r6, lr, r8, lsl #24
    16d6:	ea42 6700 	orr.w	r7, r2, r0, lsl #24
      this->y = u_y.real;
    16da:	e9c3 6706 	strd	r6, r7, [r3, #24]
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    16de:	7c4f      	ldrb	r7, [r1, #17]
    16e0:	7c0e      	ldrb	r6, [r1, #16]
    16e2:	f891 c012 	ldrb.w	ip, [r1, #18]
    16e6:	7d08      	ldrb	r0, [r1, #20]
    16e8:	7d4a      	ldrb	r2, [r1, #21]
    16ea:	f891 e013 	ldrb.w	lr, [r1, #19]
    16ee:	ea46 2607 	orr.w	r6, r6, r7, lsl #8
    16f2:	7d8f      	ldrb	r7, [r1, #22]
    16f4:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    16f8:	7dc8      	ldrb	r0, [r1, #23]
    16fa:	ea46 460c 	orr.w	r6, r6, ip, lsl #16
    16fe:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
    1702:	ea46 640e 	orr.w	r4, r6, lr, lsl #24
    1706:	ea42 6500 	orr.w	r5, r2, r0, lsl #24
      this->z = u_z.real;
    170a:	e9c3 4508 	strd	r4, r5, [r3, #32]
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    170e:	7e4d      	ldrb	r5, [r1, #25]
    1710:	7e0c      	ldrb	r4, [r1, #24]
    1712:	7f08      	ldrb	r0, [r1, #28]
    1714:	7f4a      	ldrb	r2, [r1, #29]
    1716:	7e8f      	ldrb	r7, [r1, #26]
    1718:	7ece      	ldrb	r6, [r1, #27]
    171a:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
    171e:	7f8d      	ldrb	r5, [r1, #30]
    1720:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    1724:	7fc8      	ldrb	r0, [r1, #31]
    1726:	b093      	sub	sp, #76	; 0x4c
    1728:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
    172c:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
    1730:	ea44 6406 	orr.w	r4, r4, r6, lsl #24
    1734:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    1738:	9201      	str	r2, [sp, #4]
    173a:	9400      	str	r4, [sp, #0]
      this->x = u_x.real;
    173c:	e9dd 4500 	ldrd	r4, r5, [sp]
    1740:	e9c3 450c 	strd	r4, r5, [r3, #48]	; 0x30
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1744:	f891 5021 	ldrb.w	r5, [r1, #33]	; 0x21
    1748:	f891 4020 	ldrb.w	r4, [r1, #32]
    174c:	f891 0024 	ldrb.w	r0, [r1, #36]	; 0x24
    1750:	f891 2025 	ldrb.w	r2, [r1, #37]	; 0x25
    1754:	f891 7022 	ldrb.w	r7, [r1, #34]	; 0x22
    1758:	f891 6023 	ldrb.w	r6, [r1, #35]	; 0x23
    175c:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
    1760:	f891 5026 	ldrb.w	r5, [r1, #38]	; 0x26
    1764:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    1768:	f891 0027 	ldrb.w	r0, [r1, #39]	; 0x27
    176c:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
    1770:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
    1774:	ea44 6406 	orr.w	r4, r4, r6, lsl #24
    1778:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    177c:	9203      	str	r2, [sp, #12]
    177e:	9402      	str	r4, [sp, #8]
      this->y = u_y.real;
    1780:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
    1784:	e9c3 450e 	strd	r4, r5, [r3, #56]	; 0x38
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1788:	f891 5029 	ldrb.w	r5, [r1, #41]	; 0x29
    178c:	f891 4028 	ldrb.w	r4, [r1, #40]	; 0x28
    1790:	f891 702a 	ldrb.w	r7, [r1, #42]	; 0x2a
    1794:	f891 002c 	ldrb.w	r0, [r1, #44]	; 0x2c
    1798:	f891 202d 	ldrb.w	r2, [r1, #45]	; 0x2d
    179c:	f891 602b 	ldrb.w	r6, [r1, #43]	; 0x2b
    17a0:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
    17a4:	f891 502e 	ldrb.w	r5, [r1, #46]	; 0x2e
    17a8:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    17ac:	f891 002f 	ldrb.w	r0, [r1, #47]	; 0x2f
    17b0:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
    17b4:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
    17b8:	ea44 6406 	orr.w	r4, r4, r6, lsl #24
    17bc:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    17c0:	9205      	str	r2, [sp, #20]
    17c2:	9404      	str	r4, [sp, #16]
      this->z = u_z.real;
    17c4:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
    17c8:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    17cc:	f891 5031 	ldrb.w	r5, [r1, #49]	; 0x31
    17d0:	f891 4030 	ldrb.w	r4, [r1, #48]	; 0x30
    17d4:	f891 0034 	ldrb.w	r0, [r1, #52]	; 0x34
    17d8:	f891 2035 	ldrb.w	r2, [r1, #53]	; 0x35
    17dc:	f891 7032 	ldrb.w	r7, [r1, #50]	; 0x32
    17e0:	f891 6033 	ldrb.w	r6, [r1, #51]	; 0x33
    17e4:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
    17e8:	f891 5036 	ldrb.w	r5, [r1, #54]	; 0x36
    17ec:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    17f0:	f891 0037 	ldrb.w	r0, [r1, #55]	; 0x37
    17f4:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
    17f8:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
    17fc:	ea44 6406 	orr.w	r4, r4, r6, lsl #24
    1800:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    1804:	9207      	str	r2, [sp, #28]
    1806:	9406      	str	r4, [sp, #24]
      this->x = u_x.real;
    1808:	e9dd 4506 	ldrd	r4, r5, [sp, #24]
    180c:	e9c3 4514 	strd	r4, r5, [r3, #80]	; 0x50
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1810:	f891 5039 	ldrb.w	r5, [r1, #57]	; 0x39
    1814:	f891 4038 	ldrb.w	r4, [r1, #56]	; 0x38
    1818:	f891 003c 	ldrb.w	r0, [r1, #60]	; 0x3c
    181c:	f891 203d 	ldrb.w	r2, [r1, #61]	; 0x3d
    1820:	f891 703a 	ldrb.w	r7, [r1, #58]	; 0x3a
    1824:	f891 603b 	ldrb.w	r6, [r1, #59]	; 0x3b
    1828:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
    182c:	f891 503e 	ldrb.w	r5, [r1, #62]	; 0x3e
    1830:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    1834:	f891 003f 	ldrb.w	r0, [r1, #63]	; 0x3f
    1838:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
    183c:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
    1840:	ea44 6406 	orr.w	r4, r4, r6, lsl #24
    1844:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    1848:	9209      	str	r2, [sp, #36]	; 0x24
    184a:	9408      	str	r4, [sp, #32]
      this->y = u_y.real;
    184c:	e9dd 4508 	ldrd	r4, r5, [sp, #32]
    1850:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1854:	f891 5041 	ldrb.w	r5, [r1, #65]	; 0x41
    1858:	f891 4040 	ldrb.w	r4, [r1, #64]	; 0x40
    185c:	f891 0044 	ldrb.w	r0, [r1, #68]	; 0x44
    1860:	f891 2045 	ldrb.w	r2, [r1, #69]	; 0x45
    1864:	f891 7042 	ldrb.w	r7, [r1, #66]	; 0x42
    1868:	f891 6043 	ldrb.w	r6, [r1, #67]	; 0x43
    186c:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
    1870:	f891 5046 	ldrb.w	r5, [r1, #70]	; 0x46
    1874:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    1878:	f891 0047 	ldrb.w	r0, [r1, #71]	; 0x47
    187c:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
    1880:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
    1884:	ea44 6406 	orr.w	r4, r4, r6, lsl #24
    1888:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    188c:	920b      	str	r2, [sp, #44]	; 0x2c
    188e:	940a      	str	r4, [sp, #40]	; 0x28
      this->z = u_z.real;
    1890:	e9dd 450a 	ldrd	r4, r5, [sp, #40]	; 0x28
    1894:	e9c3 4518 	strd	r4, r5, [r3, #96]	; 0x60
      u_omega_right.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_omega_right.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_omega_right.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_omega_right.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_omega_right.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_omega_right.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1898:	f891 5049 	ldrb.w	r5, [r1, #73]	; 0x49
    189c:	f891 4048 	ldrb.w	r4, [r1, #72]	; 0x48
    18a0:	f891 004c 	ldrb.w	r0, [r1, #76]	; 0x4c
    18a4:	f891 204d 	ldrb.w	r2, [r1, #77]	; 0x4d
    18a8:	f891 704a 	ldrb.w	r7, [r1, #74]	; 0x4a
    18ac:	f891 604b 	ldrb.w	r6, [r1, #75]	; 0x4b
    18b0:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
    18b4:	f891 504e 	ldrb.w	r5, [r1, #78]	; 0x4e
    18b8:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    18bc:	f891 004f 	ldrb.w	r0, [r1, #79]	; 0x4f
    18c0:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
    18c4:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
    18c8:	ea44 6406 	orr.w	r4, r4, r6, lsl #24
    18cc:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    18d0:	920d      	str	r2, [sp, #52]	; 0x34
    18d2:	940c      	str	r4, [sp, #48]	; 0x30
      this->omega_right = u_omega_right.real;
    18d4:	e9dd 450c 	ldrd	r4, r5, [sp, #48]	; 0x30
    18d8:	e9c3 451a 	strd	r4, r5, [r3, #104]	; 0x68
      u_omega_left.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_omega_left.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_omega_left.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_omega_left.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_omega_left.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_omega_left.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    18dc:	f891 5050 	ldrb.w	r5, [r1, #80]	; 0x50
    18e0:	f891 4051 	ldrb.w	r4, [r1, #81]	; 0x51
    18e4:	f891 0054 	ldrb.w	r0, [r1, #84]	; 0x54
    18e8:	f891 2055 	ldrb.w	r2, [r1, #85]	; 0x55
    18ec:	f891 7052 	ldrb.w	r7, [r1, #82]	; 0x52
    18f0:	f891 6053 	ldrb.w	r6, [r1, #83]	; 0x53
    18f4:	ea45 2404 	orr.w	r4, r5, r4, lsl #8
    18f8:	f891 5056 	ldrb.w	r5, [r1, #86]	; 0x56
    18fc:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    1900:	f891 0057 	ldrb.w	r0, [r1, #87]	; 0x57
    1904:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
    1908:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
    190c:	ea44 6406 	orr.w	r4, r4, r6, lsl #24
    1910:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    1914:	940e      	str	r4, [sp, #56]	; 0x38
    1916:	920f      	str	r2, [sp, #60]	; 0x3c
      this->omega_left = u_omega_left.real;
    1918:	e9dd 450e 	ldrd	r4, r5, [sp, #56]	; 0x38
    191c:	e9c3 451c 	strd	r4, r5, [r3, #112]	; 0x70
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    1920:	f891 5059 	ldrb.w	r5, [r1, #89]	; 0x59
    1924:	f891 005c 	ldrb.w	r0, [r1, #92]	; 0x5c
    1928:	f891 4058 	ldrb.w	r4, [r1, #88]	; 0x58
    192c:	f891 205d 	ldrb.w	r2, [r1, #93]	; 0x5d
    1930:	f891 605e 	ldrb.w	r6, [r1, #94]	; 0x5e
    1934:	f891 e05a 	ldrb.w	lr, [r1, #90]	; 0x5a
    1938:	f891 705b 	ldrb.w	r7, [r1, #91]	; 0x5b
    193c:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
    1940:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    1944:	f891 505f 	ldrb.w	r5, [r1, #95]	; 0x5f
    1948:	ea42 4206 	orr.w	r2, r2, r6, lsl #16
    194c:	ea44 410e 	orr.w	r1, r4, lr, lsl #16
    1950:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
    1954:	ea41 6107 	orr.w	r1, r1, r7, lsl #24
    1958:	9110      	str	r1, [sp, #64]	; 0x40
    195a:	9211      	str	r2, [sp, #68]	; 0x44
      this->temp = u_temp.real;
    195c:	e9dd 4510 	ldrd	r4, r5, [sp, #64]	; 0x40
      offset += sizeof(this->temp);
     return offset;
    }
    1960:	2060      	movs	r0, #96	; 0x60
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_temp.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
      this->temp = u_temp.real;
    1962:	e9c3 451e 	strd	r4, r5, [r3, #120]	; 0x78
      offset += sizeof(this->temp);
     return offset;
    }
    1966:	b013      	add	sp, #76	; 0x4c
    1968:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000196c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)>:
      }
    }
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
    196c:	b5f0      	push	{r4, r5, r6, r7, lr}
  {
    if (id >= 100 && !configured_)
    196e:	2963      	cmp	r1, #99	; 0x63
      }
    }
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
    1970:	b085      	sub	sp, #20
  {
    if (id >= 100 && !configured_)
    1972:	dd03      	ble.n	197c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x10>
    1974:	f890 44f8 	ldrb.w	r4, [r0, #1272]	; 0x4f8
    1978:	2c00      	cmp	r4, #0
    197a:	d046      	beq.n	1a0a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x9e>
      return 0;

    /* serialize message */
    int l = msg->serialize(message_out + 7);
    197c:	6813      	ldr	r3, [r2, #0]
    197e:	4605      	mov	r5, r0
    1980:	460f      	mov	r7, r1
    1982:	4610      	mov	r0, r2
    1984:	681b      	ldr	r3, [r3, #0]
    1986:	f205 2123 	addw	r1, r5, #547	; 0x223
    198a:	4798      	blx	r3

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    198c:	b2c2      	uxtb	r2, r0
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    198e:	f3c0 2107 	ubfx	r1, r0, #8, #8
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    1992:	1856      	adds	r6, r2, r1
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    1994:	f885 221e 	strb.w	r2, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    1998:	f347 2207 	sbfx	r2, r7, #8, #8
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    199c:	43f6      	mvns	r6, r6

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    199e:	23ff      	movs	r3, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    19a0:	f04f 0efe 	mov.w	lr, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    19a4:	b2fc      	uxtb	r4, r7
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    19a6:	f885 2222 	strb.w	r2, [r5, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    19aa:	1c42      	adds	r2, r0, #1
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    19ac:	f885 6220 	strb.w	r6, [r5, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    19b0:	f885 121f 	strb.w	r1, [r5, #543]	; 0x21f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    19b4:	f885 321c 	strb.w	r3, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    19b8:	f885 e21d 	strb.w	lr, [r5, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    19bc:	f885 4221 	strb.w	r4, [r5, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    19c0:	db0d      	blt.n	19de <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x72>
    19c2:	f200 2122 	addw	r1, r0, #546	; 0x222
    19c6:	4429      	add	r1, r5
    19c8:	f205 2321 	addw	r3, r5, #545	; 0x221
    19cc:	2200      	movs	r2, #0
    19ce:	e001      	b.n	19d4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x68>
    19d0:	f813 4f01 	ldrb.w	r4, [r3, #1]!
    19d4:	428b      	cmp	r3, r1
      chk += message_out[i];
    19d6:	4422      	add	r2, r4
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    19d8:	d1fa      	bne.n	19d0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x64>
    19da:	43d3      	mvns	r3, r2
    19dc:	b2db      	uxtb	r3, r3
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    19de:	182a      	adds	r2, r5, r0
    19e0:	f100 0408 	add.w	r4, r0, #8

    if (l <= OUTPUT_SIZE)
    19e4:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    19e8:	f882 3223 	strb.w	r3, [r2, #547]	; 0x223

    if (l <= OUTPUT_SIZE)
    19ec:	dc17      	bgt.n	1a1e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0xb2>
    19ee:	686a      	ldr	r2, [r5, #4]
    19f0:	4e35      	ldr	r6, [pc, #212]	; (1ac8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x15c>)
      iostream->begin(baud_);
    }

    int read(){return iostream->read();};
    void write(uint8_t* data, int length){
      iostream->write(data, length);
    19f2:	6813      	ldr	r3, [r2, #0]
    19f4:	685b      	ldr	r3, [r3, #4]
    19f6:	42b3      	cmp	r3, r6
    {
      hardware_.write(message_out, l);
    19f8:	f505 7007 	add.w	r0, r5, #540	; 0x21c
    19fc:	d108      	bne.n	1a10 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0xa4>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    19fe:	4621      	mov	r1, r4
    1a00:	f004 fb56 	bl	60b0 <usb_serial_write>
    1a04:	4620      	mov	r0, r4
    else
    {
      logerror("Message from device dropped: message larger than buffer.");
      return -1;
    }
  }
    1a06:	b005      	add	sp, #20
    1a08:	bdf0      	pop	{r4, r5, r6, r7, pc}
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
      return 0;
    1a0a:	4620      	mov	r0, r4
    else
    {
      logerror("Message from device dropped: message larger than buffer.");
      return -1;
    }
  }
    1a0c:	b005      	add	sp, #20
    1a0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1a10:	4601      	mov	r1, r0
    1a12:	4610      	mov	r0, r2
    1a14:	4622      	mov	r2, r4
    1a16:	4798      	blx	r3
    1a18:	4620      	mov	r0, r4
    1a1a:	b005      	add	sp, #20
    1a1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
      enum { ERROR = 3 };
      enum { FATAL = 4 };

    Log():
      level(0),
      msg("")
    1a1e:	4a2b      	ldr	r2, [pc, #172]	; (1acc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x160>)
protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    1a20:	492b      	ldr	r1, [pc, #172]	; (1ad0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x164>)
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    1a22:	682b      	ldr	r3, [r5, #0]
    1a24:	9201      	str	r2, [sp, #4]

protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    1a26:	2003      	movs	r0, #3
    1a28:	f88d 0008 	strb.w	r0, [sp, #8]
    l.msg = (char*)msg;
    1a2c:	9103      	str	r1, [sp, #12]
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    1a2e:	681b      	ldr	r3, [r3, #0]
    1a30:	4a28      	ldr	r2, [pc, #160]	; (1ad4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x168>)
    1a32:	4293      	cmp	r3, r2
    1a34:	d13f      	bne.n	1ab6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x14a>
  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
      arr[i] = (var >> (8 * i));
    1a36:	2400      	movs	r4, #0
    1a38:	2238      	movs	r2, #56	; 0x38
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    1a3a:	f885 0223 	strb.w	r0, [r5, #547]	; 0x223
    1a3e:	f885 2224 	strb.w	r2, [r5, #548]	; 0x224
    1a42:	f885 4225 	strb.w	r4, [r5, #549]	; 0x225
    1a46:	f885 4226 	strb.w	r4, [r5, #550]	; 0x226
    1a4a:	f885 4227 	strb.w	r4, [r5, #551]	; 0x227
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    1a4e:	f505 700a 	add.w	r0, r5, #552	; 0x228
    1a52:	f003 f815 	bl	4a80 <memcpy>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    1a56:	27ff      	movs	r7, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    1a58:	203d      	movs	r0, #61	; 0x3d
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    1a5a:	23c2      	movs	r3, #194	; 0xc2
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    1a5c:	26fe      	movs	r6, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    1a5e:	2107      	movs	r1, #7
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    1a60:	f885 021e 	strb.w	r0, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    1a64:	f885 3220 	strb.w	r3, [r5, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    1a68:	f885 421f 	strb.w	r4, [r5, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    1a6c:	f885 4222 	strb.w	r4, [r5, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    1a70:	4622      	mov	r2, r4

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    1a72:	f885 721c 	strb.w	r7, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    1a76:	f885 621d 	strb.w	r6, [r5, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    1a7a:	f885 1221 	strb.w	r1, [r5, #545]	; 0x221
    1a7e:	f205 2321 	addw	r3, r5, #545	; 0x221
    1a82:	f205 205f 	addw	r0, r5, #607	; 0x25f
    1a86:	e001      	b.n	1a8c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x120>
    1a88:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    1a8c:	4298      	cmp	r0, r3
      chk += message_out[i];
    1a8e:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    1a90:	d1fa      	bne.n	1a88 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x11c>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    1a92:	43d2      	mvns	r2, r2
    1a94:	6868      	ldr	r0, [r5, #4]
    1a96:	f885 2260 	strb.w	r2, [r5, #608]	; 0x260
    1a9a:	6803      	ldr	r3, [r0, #0]
    1a9c:	4a0a      	ldr	r2, [pc, #40]	; (1ac8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x15c>)
    1a9e:	685b      	ldr	r3, [r3, #4]
    1aa0:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    1aa2:	f505 7107 	add.w	r1, r5, #540	; 0x21c
    1aa6:	d10b      	bne.n	1ac0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x154>
    1aa8:	4608      	mov	r0, r1
    1aaa:	2145      	movs	r1, #69	; 0x45
    1aac:	f004 fb00 	bl	60b0 <usb_serial_write>
    1ab0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1ab4:	e7a7      	b.n	1a06 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x9a>
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    1ab6:	4628      	mov	r0, r5
    1ab8:	aa01      	add	r2, sp, #4
    1aba:	2107      	movs	r1, #7
    1abc:	4798      	blx	r3
    1abe:	e7f7      	b.n	1ab0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x144>
    1ac0:	2245      	movs	r2, #69	; 0x45
    1ac2:	4798      	blx	r3
    1ac4:	e7f4      	b.n	1ab0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::publish(int, ros::Msg const*)+0x144>
    1ac6:	bf00      	nop
    1ac8:	00000ea9 	.word	0x00000ea9
    1acc:	000096ec 	.word	0x000096ec
    1ad0:	00009a1c 	.word	0x00009a1c
    1ad4:	0000196d 	.word	0x0000196d

00001ad8 <omega_to_pwm(double)>:
  //left_tick_pub.publish(&left_tick);

  average_omega_left = averaging_array(speed_array_left);
}

int omega_to_pwm(double x){
    1ad8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    1adc:	ec55 4b10 	vmov	r4, r5, d0
    1ae0:	b082      	sub	sp, #8
  double pwm_cal;
  int sign;
  if(x < 0){
    1ae2:	2200      	movs	r2, #0
    1ae4:	2300      	movs	r3, #0
    1ae6:	ee10 0a10 	vmov	r0, s0
    1aea:	4629      	mov	r1, r5
    1aec:	f006 fb7e 	bl	81ec <__aeabi_dcmplt>
    sign = -1;
  }
  else{
    sign = 1;
  }
  if (abs(x) > change_over_point){
    1af0:	2200      	movs	r2, #0
  int sign;
  if(x < 0){
    sign = -1;
  }
  else{
    sign = 1;
    1af2:	2800      	cmp	r0, #0
  }
  if (abs(x) > change_over_point){
    1af4:	f04f 0300 	mov.w	r3, #0
    1af8:	4620      	mov	r0, r4
    1afa:	4629      	mov	r1, r5
  int sign;
  if(x < 0){
    sign = -1;
  }
  else{
    sign = 1;
    1afc:	bf14      	ite	ne
    1afe:	f04f 3aff 	movne.w	sl, #4294967295	; 0xffffffff
    1b02:	f04f 0a01 	moveq.w	sl, #1
  }
  if (abs(x) > change_over_point){
    1b06:	f006 fb8f 	bl	8228 <__aeabi_dcmpgt>
    1b0a:	2200      	movs	r2, #0
    1b0c:	2800      	cmp	r0, #0
    1b0e:	f000 80a2 	beq.w	1c56 <omega_to_pwm(double)+0x17e>
    1b12:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    1b16:	4620      	mov	r0, r4
    1b18:	4629      	mov	r1, r5
    1b1a:	f006 fb85 	bl	8228 <__aeabi_dcmpgt>
    1b1e:	b3b8      	cbz	r0, 1b90 <omega_to_pwm(double)+0xb8>
    pwm_cal = a*pow(abs(x),3)+b*pow(abs(x),2)+c*abs(x)+d;
    1b20:	ed9f 1b79 	vldr	d1, [pc, #484]	; 1d08 <omega_to_pwm(double)+0x230>
    1b24:	ec45 4b10 	vmov	d0, r4, r5
    1b28:	f004 fdfe 	bl	6728 <pow>
    1b2c:	4622      	mov	r2, r4
    1b2e:	462b      	mov	r3, r5
    1b30:	4620      	mov	r0, r4
    1b32:	4629      	mov	r1, r5
    1b34:	ed8d 0b00 	vstr	d0, [sp]
    1b38:	f006 f8e6 	bl	7d08 <__aeabi_dmul>
    1b3c:	a374      	add	r3, pc, #464	; (adr r3, 1d10 <omega_to_pwm(double)+0x238>)
    1b3e:	e9d3 2300 	ldrd	r2, r3, [r3]
    1b42:	f006 f8e1 	bl	7d08 <__aeabi_dmul>
    1b46:	ed9d 0b00 	vldr	d0, [sp]
    1b4a:	a373      	add	r3, pc, #460	; (adr r3, 1d18 <omega_to_pwm(double)+0x240>)
    1b4c:	e9d3 2300 	ldrd	r2, r3, [r3]
    1b50:	4606      	mov	r6, r0
    1b52:	460f      	mov	r7, r1
    1b54:	ec51 0b10 	vmov	r0, r1, d0
    1b58:	f006 f8d6 	bl	7d08 <__aeabi_dmul>
    1b5c:	4602      	mov	r2, r0
    1b5e:	460b      	mov	r3, r1
    1b60:	4630      	mov	r0, r6
    1b62:	4639      	mov	r1, r7
    1b64:	f005 ff1e 	bl	79a4 <__adddf3>
    1b68:	4606      	mov	r6, r0
    1b6a:	460f      	mov	r7, r1
    1b6c:	4620      	mov	r0, r4
    1b6e:	4629      	mov	r1, r5
    1b70:	a36b      	add	r3, pc, #428	; (adr r3, 1d20 <omega_to_pwm(double)+0x248>)
    1b72:	e9d3 2300 	ldrd	r2, r3, [r3]
    1b76:	f006 f8c7 	bl	7d08 <__aeabi_dmul>
    1b7a:	4632      	mov	r2, r6
    1b7c:	463b      	mov	r3, r7
    1b7e:	f005 ff11 	bl	79a4 <__adddf3>
    1b82:	a369      	add	r3, pc, #420	; (adr r3, 1d28 <omega_to_pwm(double)+0x250>)
    1b84:	e9d3 2300 	ldrd	r2, r3, [r3]
    1b88:	f005 ff0a 	bl	79a0 <__aeabi_dsub>
    1b8c:	4606      	mov	r6, r0
    1b8e:	460f      	mov	r7, r1
  }
  if (abs(x) <= change_over_point && abs(x) > 0.01){
    1b90:	2200      	movs	r2, #0
    1b92:	2300      	movs	r3, #0
    1b94:	4620      	mov	r0, r4
    1b96:	4629      	mov	r1, r5
    1b98:	f006 fb46 	bl	8228 <__aeabi_dcmpgt>
    1b9c:	2200      	movs	r2, #0
    1b9e:	b3a8      	cbz	r0, 1c0c <omega_to_pwm(double)+0x134>
    1ba0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    1ba4:	4620      	mov	r0, r4
    1ba6:	4629      	mov	r1, r5
    1ba8:	f006 fb2a 	bl	8200 <__aeabi_dcmple>
    1bac:	b9b0      	cbnz	r0, 1bdc <omega_to_pwm(double)+0x104>
    pwm_cal = a_2*abs(x) + b_2;
  }
  if (pwm_cal>opper_lim){
    1bae:	a360      	add	r3, pc, #384	; (adr r3, 1d30 <omega_to_pwm(double)+0x258>)
    1bb0:	e9d3 2300 	ldrd	r2, r3, [r3]
    1bb4:	4630      	mov	r0, r6
    1bb6:	4639      	mov	r1, r7
    1bb8:	f006 fb36 	bl	8228 <__aeabi_dcmpgt>
    1bbc:	b110      	cbz	r0, 1bc4 <omega_to_pwm(double)+0xec>
    pwm_cal = opper_lim;
    1bbe:	a75c      	add	r7, pc, #368	; (adr r7, 1d30 <omega_to_pwm(double)+0x258>)
    1bc0:	e9d7 6700 	ldrd	r6, r7, [r7]
  }
  int pwm_int = sign * pwm_cal;

  return pwm_int;
    1bc4:	4650      	mov	r0, sl
    1bc6:	f006 f839 	bl	7c3c <__aeabi_i2d>
    1bca:	4632      	mov	r2, r6
    1bcc:	463b      	mov	r3, r7
    1bce:	f006 f89b 	bl	7d08 <__aeabi_dmul>
    1bd2:	f006 fb49 	bl	8268 <__aeabi_d2iz>
}
    1bd6:	b002      	add	sp, #8
    1bd8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    sign = 1;
  }
  if (abs(x) > change_over_point){
    pwm_cal = a*pow(abs(x),3)+b*pow(abs(x),2)+c*abs(x)+d;
  }
  if (abs(x) <= change_over_point && abs(x) > 0.01){
    1bdc:	a356      	add	r3, pc, #344	; (adr r3, 1d38 <omega_to_pwm(double)+0x260>)
    1bde:	e9d3 2300 	ldrd	r2, r3, [r3]
    1be2:	4620      	mov	r0, r4
    1be4:	4629      	mov	r1, r5
    1be6:	f006 fb1f 	bl	8228 <__aeabi_dcmpgt>
    1bea:	2800      	cmp	r0, #0
    1bec:	d0df      	beq.n	1bae <omega_to_pwm(double)+0xd6>
    pwm_cal = a_2*abs(x) + b_2;
    1bee:	4620      	mov	r0, r4
    1bf0:	4629      	mov	r1, r5
    1bf2:	a353      	add	r3, pc, #332	; (adr r3, 1d40 <omega_to_pwm(double)+0x268>)
    1bf4:	e9d3 2300 	ldrd	r2, r3, [r3]
    1bf8:	f006 f886 	bl	7d08 <__aeabi_dmul>
    1bfc:	a352      	add	r3, pc, #328	; (adr r3, 1d48 <omega_to_pwm(double)+0x270>)
    1bfe:	e9d3 2300 	ldrd	r2, r3, [r3]
    1c02:	f005 fecf 	bl	79a4 <__adddf3>
    1c06:	4606      	mov	r6, r0
    1c08:	460f      	mov	r7, r1
    1c0a:	e7d0      	b.n	1bae <omega_to_pwm(double)+0xd6>
    sign = 1;
  }
  if (abs(x) > change_over_point){
    pwm_cal = a*pow(abs(x),3)+b*pow(abs(x),2)+c*abs(x)+d;
  }
  if (abs(x) <= change_over_point && abs(x) > 0.01){
    1c0c:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
    1c10:	4620      	mov	r0, r4
    1c12:	4629      	mov	r1, r5
    1c14:	f006 fafe 	bl	8214 <__aeabi_dcmpge>
    1c18:	2800      	cmp	r0, #0
    1c1a:	d0c8      	beq.n	1bae <omega_to_pwm(double)+0xd6>
    1c1c:	2200      	movs	r2, #0
    1c1e:	2300      	movs	r3, #0
    1c20:	4620      	mov	r0, r4
    1c22:	4629      	mov	r1, r5
    1c24:	f006 fb00 	bl	8228 <__aeabi_dcmpgt>
    1c28:	2800      	cmp	r0, #0
    1c2a:	d1d7      	bne.n	1bdc <omega_to_pwm(double)+0x104>
    1c2c:	a348      	add	r3, pc, #288	; (adr r3, 1d50 <omega_to_pwm(double)+0x278>)
    1c2e:	e9d3 2300 	ldrd	r2, r3, [r3]
    1c32:	4620      	mov	r0, r4
    1c34:	4629      	mov	r1, r5
    1c36:	f006 fad9 	bl	81ec <__aeabi_dcmplt>
    1c3a:	2800      	cmp	r0, #0
    1c3c:	d0b7      	beq.n	1bae <omega_to_pwm(double)+0xd6>
    pwm_cal = a_2*abs(x) + b_2;
    1c3e:	2200      	movs	r2, #0
    1c40:	2300      	movs	r3, #0
    1c42:	4620      	mov	r0, r4
    1c44:	4629      	mov	r1, r5
    1c46:	f006 faef 	bl	8228 <__aeabi_dcmpgt>
    1c4a:	2800      	cmp	r0, #0
    1c4c:	d1cf      	bne.n	1bee <omega_to_pwm(double)+0x116>
    1c4e:	4620      	mov	r0, r4
    1c50:	f105 4100 	add.w	r1, r5, #2147483648	; 0x80000000
    1c54:	e7cd      	b.n	1bf2 <omega_to_pwm(double)+0x11a>
    sign = -1;
  }
  else{
    sign = 1;
  }
  if (abs(x) > change_over_point){
    1c56:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
    1c5a:	4620      	mov	r0, r4
    1c5c:	4629      	mov	r1, r5
    1c5e:	f006 fac5 	bl	81ec <__aeabi_dcmplt>
    1c62:	2800      	cmp	r0, #0
    1c64:	d094      	beq.n	1b90 <omega_to_pwm(double)+0xb8>
    pwm_cal = a*pow(abs(x),3)+b*pow(abs(x),2)+c*abs(x)+d;
    1c66:	2200      	movs	r2, #0
    1c68:	2300      	movs	r3, #0
    1c6a:	4620      	mov	r0, r4
    1c6c:	4629      	mov	r1, r5
    1c6e:	f006 fadb 	bl	8228 <__aeabi_dcmpgt>
    1c72:	2800      	cmp	r0, #0
    1c74:	f47f af54 	bne.w	1b20 <omega_to_pwm(double)+0x48>
    1c78:	46a0      	mov	r8, r4
    1c7a:	f105 4900 	add.w	r9, r5, #2147483648	; 0x80000000
    1c7e:	ed9f 1b22 	vldr	d1, [pc, #136]	; 1d08 <omega_to_pwm(double)+0x230>
    1c82:	ec49 8b10 	vmov	d0, r8, r9
    1c86:	f004 fd4f 	bl	6728 <pow>
    1c8a:	a323      	add	r3, pc, #140	; (adr r3, 1d18 <omega_to_pwm(double)+0x240>)
    1c8c:	e9d3 2300 	ldrd	r2, r3, [r3]
    1c90:	ec51 0b10 	vmov	r0, r1, d0
    1c94:	f006 f838 	bl	7d08 <__aeabi_dmul>
    1c98:	2200      	movs	r2, #0
    1c9a:	4606      	mov	r6, r0
    1c9c:	460f      	mov	r7, r1
    1c9e:	2300      	movs	r3, #0
    1ca0:	4620      	mov	r0, r4
    1ca2:	4629      	mov	r1, r5
    1ca4:	f006 fac0 	bl	8228 <__aeabi_dcmpgt>
    1ca8:	b9d0      	cbnz	r0, 1ce0 <omega_to_pwm(double)+0x208>
    1caa:	4622      	mov	r2, r4
    1cac:	464b      	mov	r3, r9
    1cae:	4620      	mov	r0, r4
    1cb0:	4649      	mov	r1, r9
    1cb2:	f006 f829 	bl	7d08 <__aeabi_dmul>
    1cb6:	a316      	add	r3, pc, #88	; (adr r3, 1d10 <omega_to_pwm(double)+0x238>)
    1cb8:	e9d3 2300 	ldrd	r2, r3, [r3]
    1cbc:	f006 f824 	bl	7d08 <__aeabi_dmul>
    1cc0:	4632      	mov	r2, r6
    1cc2:	463b      	mov	r3, r7
    1cc4:	f005 fe6e 	bl	79a4 <__adddf3>
    1cc8:	2200      	movs	r2, #0
    1cca:	4606      	mov	r6, r0
    1ccc:	460f      	mov	r7, r1
    1cce:	2300      	movs	r3, #0
    1cd0:	4620      	mov	r0, r4
    1cd2:	4629      	mov	r1, r5
    1cd4:	f006 faa8 	bl	8228 <__aeabi_dcmpgt>
    1cd8:	b980      	cbnz	r0, 1cfc <omega_to_pwm(double)+0x224>
    1cda:	4620      	mov	r0, r4
    1cdc:	4649      	mov	r1, r9
    1cde:	e747      	b.n	1b70 <omega_to_pwm(double)+0x98>
    1ce0:	4622      	mov	r2, r4
    1ce2:	462b      	mov	r3, r5
    1ce4:	4620      	mov	r0, r4
    1ce6:	4629      	mov	r1, r5
    1ce8:	f006 f80e 	bl	7d08 <__aeabi_dmul>
    1cec:	a308      	add	r3, pc, #32	; (adr r3, 1d10 <omega_to_pwm(double)+0x238>)
    1cee:	e9d3 2300 	ldrd	r2, r3, [r3]
    1cf2:	f006 f809 	bl	7d08 <__aeabi_dmul>
    1cf6:	4632      	mov	r2, r6
    1cf8:	463b      	mov	r3, r7
    1cfa:	e733      	b.n	1b64 <omega_to_pwm(double)+0x8c>
    1cfc:	4620      	mov	r0, r4
    1cfe:	4629      	mov	r1, r5
    1d00:	e736      	b.n	1b70 <omega_to_pwm(double)+0x98>
    1d02:	bf00      	nop
    1d04:	f3af 8000 	nop.w
    1d08:	00000000 	.word	0x00000000
    1d0c:	40080000 	.word	0x40080000
    1d10:	00000000 	.word	0x00000000
    1d14:	c00bb22d 	.word	0xc00bb22d
    1d18:	a0000000 	.word	0xa0000000
    1d1c:	3fc84ea4 	.word	0x3fc84ea4
    1d20:	20000000 	.word	0x20000000
    1d24:	4037c7ae 	.word	0x4037c7ae
    1d28:	20000000 	.word	0x20000000
    1d2c:	40229d2f 	.word	0x40229d2f
    1d30:	00000000 	.word	0x00000000
    1d34:	406fe000 	.word	0x406fe000
    1d38:	40000000 	.word	0x40000000
    1d3c:	3f847ae1 	.word	0x3f847ae1
    1d40:	c0000000 	.word	0xc0000000
    1d44:	3ffb851e 	.word	0x3ffb851e
    1d48:	a0000000 	.word	0xa0000000
    1d4c:	4036e147 	.word	0x4036e147
    1d50:	40000000 	.word	0x40000000
    1d54:	bf847ae1 	.word	0xbf847ae1

00001d58 <setPWM(int, int)>:

  return pwm_int;
}


void setPWM(int pwm_right, int pwm_left) {
    1d58:	b570      	push	{r4, r5, r6, lr}
  //setting the correct direction of the motor
  direction_indicator_right = 0;
  direction_indicator_left = 0;
    1d5a:	4a1e      	ldr	r2, [pc, #120]	; (1dd4 <setPWM(int, int)+0x7c>)
}


void setPWM(int pwm_right, int pwm_left) {
  //setting the correct direction of the motor
  direction_indicator_right = 0;
    1d5c:	4e1e      	ldr	r6, [pc, #120]	; (1dd8 <setPWM(int, int)+0x80>)
    1d5e:	2300      	movs	r3, #0
  direction_indicator_left = 0;
  if(pwm_right >= 0){
    1d60:	1e05      	subs	r5, r0, #0
}


void setPWM(int pwm_right, int pwm_left) {
  //setting the correct direction of the motor
  direction_indicator_right = 0;
    1d62:	6033      	str	r3, [r6, #0]
  direction_indicator_left = 0;
    1d64:	6013      	str	r3, [r2, #0]
  if(pwm_right >= 0){
    direction_indicator_right = 1;
    1d66:	bfa8      	it	ge
    1d68:	2301      	movge	r3, #1

  return pwm_int;
}


void setPWM(int pwm_right, int pwm_left) {
    1d6a:	460c      	mov	r4, r1
  //setting the correct direction of the motor
  direction_indicator_right = 0;
  direction_indicator_left = 0;
  if(pwm_right >= 0){
    direction_indicator_right = 1;
    1d6c:	bfa8      	it	ge
    1d6e:	6033      	strge	r3, [r6, #0]
  }
  if(pwm_left >= 0){
    1d70:	2900      	cmp	r1, #0
    direction_indicator_left = 1;
  }
  digitalWrite(right_motor_ina, pwm_right >= 0);
    1d72:	ea6f 0105 	mvn.w	r1, r5
  direction_indicator_left = 0;
  if(pwm_right >= 0){
    direction_indicator_right = 1;
  }
  if(pwm_left >= 0){
    direction_indicator_left = 1;
    1d76:	bfa8      	it	ge
    1d78:	2301      	movge	r3, #1
  }
  digitalWrite(right_motor_ina, pwm_right >= 0);
    1d7a:	ea4f 71d1 	mov.w	r1, r1, lsr #31
    1d7e:	f04f 001e 	mov.w	r0, #30
  direction_indicator_left = 0;
  if(pwm_right >= 0){
    direction_indicator_right = 1;
  }
  if(pwm_left >= 0){
    direction_indicator_left = 1;
    1d82:	bfa8      	it	ge
    1d84:	6013      	strge	r3, [r2, #0]
  }
  digitalWrite(right_motor_ina, pwm_right >= 0);
    1d86:	f003 fa5b 	bl	5240 <digitalWrite>
  digitalWrite(right_motor_inb, pwm_right < 0);
    1d8a:	0fe9      	lsrs	r1, r5, #31
    1d8c:	201c      	movs	r0, #28
    1d8e:	f003 fa57 	bl	5240 <digitalWrite>
  digitalWrite(left_motor_ina, pwm_left >= 0);
    1d92:	43e1      	mvns	r1, r4
    1d94:	0fc9      	lsrs	r1, r1, #31
    1d96:	2027      	movs	r0, #39	; 0x27
    1d98:	f003 fa52 	bl	5240 <digitalWrite>
  digitalWrite(left_motor_inb, pwm_left < 0);
    1d9c:	0fe1      	lsrs	r1, r4, #31
    1d9e:	2025      	movs	r0, #37	; 0x25
    1da0:	f003 fa4e 	bl	5240 <digitalWrite>
  //setting the value of the motor
  pwm_right = abs(pwm_right);
    1da4:	ea85 71e5 	eor.w	r1, r5, r5, asr #31
    1da8:	eba1 71e5 	sub.w	r1, r1, r5, asr #31
  pwm_left = abs(pwm_left);
    1dac:	2c00      	cmp	r4, #0
    1dae:	bfb8      	it	lt
    1db0:	4264      	neglt	r4, r4
    pwm_left = 255;
  }
  if (pwm_right > 255) {
    pwm_right = 255;
  }
  analogWrite(right_motor_pwm, pwm_right);
    1db2:	29ff      	cmp	r1, #255	; 0xff
    1db4:	bfa8      	it	ge
    1db6:	21ff      	movge	r1, #255	; 0xff
    1db8:	201d      	movs	r0, #29
    1dba:	f003 f8a1 	bl	4f00 <analogWrite>
  analogWrite(left_motor_pwm, pwm_left);
    1dbe:	2cff      	cmp	r4, #255	; 0xff
    1dc0:	4621      	mov	r1, r4
    1dc2:	f04f 0026 	mov.w	r0, #38	; 0x26
    1dc6:	bfa8      	it	ge
    1dc8:	21ff      	movge	r1, #255	; 0xff
}
    1dca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  }
  if (pwm_right > 255) {
    pwm_right = 255;
  }
  analogWrite(right_motor_pwm, pwm_right);
  analogWrite(left_motor_pwm, pwm_left);
    1dce:	f003 b897 	b.w	4f00 <analogWrite>
    1dd2:	bf00      	nop
    1dd4:	1fff1d54 	.word	0x1fff1d54
    1dd8:	1fff228c 	.word	0x1fff228c

00001ddc <speed_PID_controller(double, double, double, double, double, double, double)>:
}

void speed_PID_controller(double goal_wheel_speed_r, double current_wheel_speed_r, double last_error_r, double goal_wheel_speed_l, double current_wheel_speed_l, double last_error_l, double elapsed_time){
    1ddc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1de0:	b08d      	sub	sp, #52	; 0x34
    1de2:	ec59 8b16 	vmov	r8, r9, d6
    1de6:	ed8d 2b06 	vstr	d2, [sp, #24]
    1dea:	ed8d 5b04 	vstr	d5, [sp, #16]
    1dee:	ed8d 3b02 	vstr	d3, [sp, #8]
    1df2:	ed8d 4b00 	vstr	d4, [sp]
    1df6:	ed8d 0b0a 	vstr	d0, [sp, #40]	; 0x28
    1dfa:	ed8d 1b08 	vstr	d1, [sp, #32]
  //double error_r = goal_wheel_speed_r - current_wheel_speed_r;
  previous_time = micros();
    1dfe:	f003 fa2b 	bl	5258 <micros>
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
    1e02:	ed9d 1b08 	vldr	d1, [sp, #32]
    1e06:	ed9d 0b0a 	vldr	d0, [sp, #40]	; 0x28
  analogWrite(left_motor_pwm, pwm_left);
}

void speed_PID_controller(double goal_wheel_speed_r, double current_wheel_speed_r, double last_error_r, double goal_wheel_speed_l, double current_wheel_speed_l, double last_error_l, double elapsed_time){
  //double error_r = goal_wheel_speed_r - current_wheel_speed_r;
  previous_time = micros();
    1e0a:	4b57      	ldr	r3, [pc, #348]	; (1f68 <speed_PID_controller(double, double, double, double, double, double, double)+0x18c>)
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
    1e0c:	4c57      	ldr	r4, [pc, #348]	; (1f6c <speed_PID_controller(double, double, double, double, double, double, double)+0x190>)
  analogWrite(left_motor_pwm, pwm_left);
}

void speed_PID_controller(double goal_wheel_speed_r, double current_wheel_speed_r, double last_error_r, double goal_wheel_speed_l, double current_wheel_speed_l, double last_error_l, double elapsed_time){
  //double error_r = goal_wheel_speed_r - current_wheel_speed_r;
  previous_time = micros();
    1e0e:	6018      	str	r0, [r3, #0]
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
    1e10:	ec53 2b11 	vmov	r2, r3, d1
    1e14:	ec51 0b10 	vmov	r0, r1, d0
    1e18:	f005 fdc2 	bl	79a0 <__aeabi_dsub>
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
    1e1c:	ed9d 4b00 	vldr	d4, [sp]
    1e20:	ed9d 3b02 	vldr	d3, [sp, #8]

void speed_PID_controller(double goal_wheel_speed_r, double current_wheel_speed_r, double last_error_r, double goal_wheel_speed_l, double current_wheel_speed_l, double last_error_l, double elapsed_time){
  //double error_r = goal_wheel_speed_r - current_wheel_speed_r;
  previous_time = micros();
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
    1e24:	4682      	mov	sl, r0
    1e26:	468b      	mov	fp, r1
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
    1e28:	ec53 2b14 	vmov	r2, r3, d4
    1e2c:	ec51 0b13 	vmov	r0, r1, d3

void speed_PID_controller(double goal_wheel_speed_r, double current_wheel_speed_r, double last_error_r, double goal_wheel_speed_l, double current_wheel_speed_l, double last_error_l, double elapsed_time){
  //double error_r = goal_wheel_speed_r - current_wheel_speed_r;
  previous_time = micros();
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
    1e30:	e9c4 ab00 	strd	sl, fp, [r4]
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
    1e34:	f005 fdb4 	bl	79a0 <__aeabi_dsub>
    1e38:	4604      	mov	r4, r0
    1e3a:	460d      	mov	r5, r1
    1e3c:	ec45 4b17 	vmov	d7, r4, r5
    1e40:	4f4b      	ldr	r7, [pc, #300]	; (1f70 <speed_PID_controller(double, double, double, double, double, double, double)+0x194>)
  cum_error_r += error_r * elapsed_time;
    1e42:	4e4c      	ldr	r6, [pc, #304]	; (1f74 <speed_PID_controller(double, double, double, double, double, double, double)+0x198>)
  //double error_r = goal_wheel_speed_r - current_wheel_speed_r;
  previous_time = micros();
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
    1e44:	ed87 7b00 	vstr	d7, [r7]
  cum_error_r += error_r * elapsed_time;
    1e48:	4642      	mov	r2, r8
    1e4a:	464b      	mov	r3, r9
    1e4c:	4650      	mov	r0, sl
    1e4e:	4659      	mov	r1, fp
  //double error_r = goal_wheel_speed_r - current_wheel_speed_r;
  previous_time = micros();
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
    1e50:	e9cd 4500 	strd	r4, r5, [sp]
  cum_error_r += error_r * elapsed_time;
    1e54:	f005 ff58 	bl	7d08 <__aeabi_dmul>
    1e58:	e9d6 2300 	ldrd	r2, r3, [r6]
    1e5c:	f005 fda2 	bl	79a4 <__adddf3>
    1e60:	4604      	mov	r4, r0
    1e62:	460d      	mov	r5, r1
    1e64:	ec45 4b17 	vmov	d7, r4, r5
  cum_error_l += error_l * elapsed_time;
    1e68:	4642      	mov	r2, r8
  previous_time = micros();
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
  cum_error_r += error_r * elapsed_time;
    1e6a:	ed86 7b00 	vstr	d7, [r6]
  cum_error_l += error_l * elapsed_time;
    1e6e:	464b      	mov	r3, r9
    1e70:	e9dd 0100 	ldrd	r0, r1, [sp]
  previous_time = micros();
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
  cum_error_r += error_r * elapsed_time;
    1e74:	e9cd 4502 	strd	r4, r5, [sp, #8]
  cum_error_l += error_l * elapsed_time;
    1e78:	f005 ff46 	bl	7d08 <__aeabi_dmul>
    1e7c:	4b3e      	ldr	r3, [pc, #248]	; (1f78 <speed_PID_controller(double, double, double, double, double, double, double)+0x19c>)
    1e7e:	e9d3 2300 	ldrd	r2, r3, [r3]
    1e82:	f005 fd8f 	bl	79a4 <__adddf3>
  double rate_error_r = (error_r - last_error_r) / elapsed_time;
  double rate_error_l = (error_l - last_error_l) / elapsed_time;
  double controller_output_r = error_r * p_gain + cum_error_r * i_gain + rate_error_r * d_gain;
  double controller_output_l = error_l * p_gain + cum_error_l * i_gain + rate_error_l * d_gain;
    1e86:	e9dd 4500 	ldrd	r4, r5, [sp]
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
  cum_error_r += error_r * elapsed_time;
  cum_error_l += error_l * elapsed_time;
    1e8a:	4606      	mov	r6, r0
  double rate_error_r = (error_r - last_error_r) / elapsed_time;
  double rate_error_l = (error_l - last_error_l) / elapsed_time;
  double controller_output_r = error_r * p_gain + cum_error_r * i_gain + rate_error_r * d_gain;
  double controller_output_l = error_l * p_gain + cum_error_l * i_gain + rate_error_l * d_gain;
    1e8c:	4622      	mov	r2, r4
    1e8e:	4620      	mov	r0, r4
  //temp_input_vel = goal_wheel_speed_r;
  error_r = goal_wheel_speed_r - current_wheel_speed_r;
  //double error_l = goal_wheel_speed_l - current_wheel_speed_l;
  error_l = goal_wheel_speed_l - current_wheel_speed_l;
  cum_error_r += error_r * elapsed_time;
  cum_error_l += error_l * elapsed_time;
    1e90:	4c39      	ldr	r4, [pc, #228]	; (1f78 <speed_PID_controller(double, double, double, double, double, double, double)+0x19c>)
    1e92:	460f      	mov	r7, r1
    1e94:	e9c4 6700 	strd	r6, r7, [r4]
  double rate_error_r = (error_r - last_error_r) / elapsed_time;
  double rate_error_l = (error_l - last_error_l) / elapsed_time;
  double controller_output_r = error_r * p_gain + cum_error_r * i_gain + rate_error_r * d_gain;
  double controller_output_l = error_l * p_gain + cum_error_l * i_gain + rate_error_l * d_gain;
    1e98:	462b      	mov	r3, r5
    1e9a:	4629      	mov	r1, r5
    1e9c:	f005 fd82 	bl	79a4 <__adddf3>
    1ea0:	2200      	movs	r2, #0
    1ea2:	4604      	mov	r4, r0
    1ea4:	460d      	mov	r5, r1
    1ea6:	4b35      	ldr	r3, [pc, #212]	; (1f7c <speed_PID_controller(double, double, double, double, double, double, double)+0x1a0>)
    1ea8:	4630      	mov	r0, r6
    1eaa:	4639      	mov	r1, r7
    1eac:	f005 ff2c 	bl	7d08 <__aeabi_dmul>
    1eb0:	4602      	mov	r2, r0
    1eb2:	460b      	mov	r3, r1
    1eb4:	4620      	mov	r0, r4
    1eb6:	4629      	mov	r1, r5
    1eb8:	f005 fd74 	bl	79a4 <__adddf3>
    1ebc:	ed9d 5b04 	vldr	d5, [sp, #16]
    1ec0:	4606      	mov	r6, r0
    1ec2:	ec53 2b15 	vmov	r2, r3, d5
    1ec6:	460f      	mov	r7, r1
    1ec8:	e9dd 0100 	ldrd	r0, r1, [sp]
    1ecc:	f005 fd68 	bl	79a0 <__aeabi_dsub>
    1ed0:	4642      	mov	r2, r8
    1ed2:	464b      	mov	r3, r9
    1ed4:	f006 f842 	bl	7f5c <__aeabi_ddiv>
    1ed8:	2200      	movs	r2, #0
    1eda:	2300      	movs	r3, #0
    1edc:	f005 ff14 	bl	7d08 <__aeabi_dmul>
    1ee0:	4602      	mov	r2, r0
    1ee2:	460b      	mov	r3, r1
    1ee4:	4630      	mov	r0, r6
    1ee6:	4639      	mov	r1, r7
    1ee8:	f005 fd5c 	bl	79a4 <__adddf3>
  double pwm_signal_r = omega_to_pwm(controller_output_r);
    1eec:	4652      	mov	r2, sl
  cum_error_r += error_r * elapsed_time;
  cum_error_l += error_l * elapsed_time;
  double rate_error_r = (error_r - last_error_r) / elapsed_time;
  double rate_error_l = (error_l - last_error_l) / elapsed_time;
  double controller_output_r = error_r * p_gain + cum_error_r * i_gain + rate_error_r * d_gain;
  double controller_output_l = error_l * p_gain + cum_error_l * i_gain + rate_error_l * d_gain;
    1eee:	4606      	mov	r6, r0
    1ef0:	460f      	mov	r7, r1
  double pwm_signal_r = omega_to_pwm(controller_output_r);
    1ef2:	465b      	mov	r3, fp
    1ef4:	4650      	mov	r0, sl
    1ef6:	4659      	mov	r1, fp
    1ef8:	f005 fd54 	bl	79a4 <__adddf3>
    1efc:	2200      	movs	r2, #0
    1efe:	4604      	mov	r4, r0
    1f00:	460d      	mov	r5, r1
    1f02:	4b1e      	ldr	r3, [pc, #120]	; (1f7c <speed_PID_controller(double, double, double, double, double, double, double)+0x1a0>)
    1f04:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    1f08:	f005 fefe 	bl	7d08 <__aeabi_dmul>
    1f0c:	4602      	mov	r2, r0
    1f0e:	460b      	mov	r3, r1
    1f10:	4620      	mov	r0, r4
    1f12:	4629      	mov	r1, r5
    1f14:	f005 fd46 	bl	79a4 <__adddf3>
    1f18:	ed9d 2b06 	vldr	d2, [sp, #24]
    1f1c:	4604      	mov	r4, r0
    1f1e:	ec53 2b12 	vmov	r2, r3, d2
    1f22:	460d      	mov	r5, r1
    1f24:	4650      	mov	r0, sl
    1f26:	4659      	mov	r1, fp
    1f28:	f005 fd3a 	bl	79a0 <__aeabi_dsub>
    1f2c:	4642      	mov	r2, r8
    1f2e:	464b      	mov	r3, r9
    1f30:	f006 f814 	bl	7f5c <__aeabi_ddiv>
    1f34:	2200      	movs	r2, #0
    1f36:	2300      	movs	r3, #0
    1f38:	f005 fee6 	bl	7d08 <__aeabi_dmul>
    1f3c:	4602      	mov	r2, r0
    1f3e:	460b      	mov	r3, r1
    1f40:	4620      	mov	r0, r4
    1f42:	4629      	mov	r1, r5
    1f44:	f005 fd2e 	bl	79a4 <__adddf3>
    1f48:	ec41 0b10 	vmov	d0, r0, r1
    1f4c:	f7ff fdc4 	bl	1ad8 <omega_to_pwm(double)>
  double pwm_signal_l = omega_to_pwm(controller_output_l);
    1f50:	ec47 6b10 	vmov	d0, r6, r7
  cum_error_l += error_l * elapsed_time;
  double rate_error_r = (error_r - last_error_r) / elapsed_time;
  double rate_error_l = (error_l - last_error_l) / elapsed_time;
  double controller_output_r = error_r * p_gain + cum_error_r * i_gain + rate_error_r * d_gain;
  double controller_output_l = error_l * p_gain + cum_error_l * i_gain + rate_error_l * d_gain;
  double pwm_signal_r = omega_to_pwm(controller_output_r);
    1f54:	4604      	mov	r4, r0
  double pwm_signal_l = omega_to_pwm(controller_output_l);
    1f56:	f7ff fdbf 	bl	1ad8 <omega_to_pwm(double)>
  setPWM(pwm_signal_r,pwm_signal_l);
    1f5a:	4601      	mov	r1, r0
    1f5c:	4620      	mov	r0, r4
}
    1f5e:	b00d      	add	sp, #52	; 0x34
    1f60:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  double rate_error_l = (error_l - last_error_l) / elapsed_time;
  double controller_output_r = error_r * p_gain + cum_error_r * i_gain + rate_error_r * d_gain;
  double controller_output_l = error_l * p_gain + cum_error_l * i_gain + rate_error_l * d_gain;
  double pwm_signal_r = omega_to_pwm(controller_output_r);
  double pwm_signal_l = omega_to_pwm(controller_output_l);
  setPWM(pwm_signal_r,pwm_signal_l);
    1f64:	f7ff bef8 	b.w	1d58 <setPWM(int, int)>
    1f68:	1fff2b88 	.word	0x1fff2b88
    1f6c:	1fff1460 	.word	0x1fff1460
    1f70:	1fff2b98 	.word	0x1fff2b98
    1f74:	1fff2b20 	.word	0x1fff2b20
    1f78:	1fff2a80 	.word	0x1fff2a80
    1f7c:	3fe00000 	.word	0x3fe00000

00001f80 <RGB_led_set(String const&)>:
    //output_number = map(encoder_count,-counts_per_revolution, counts_per_revolution, -2*pi, 2*pi);
  }
  return output_number;
}

void RGB_led_set(const String& color) {
    1f80:	b510      	push	{r4, lr}
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	//unsigned char equals(const __FlashStringHelper *pgmstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
    1f82:	4971      	ldr	r1, [pc, #452]	; (2148 <RGB_led_set(String const&)+0x1c8>)
    1f84:	4604      	mov	r4, r0
    1f86:	f004 fa17 	bl	63b8 <String::equals(char const*) const>
  if (color == "red" || color == "Red" || color == "RED") {
    1f8a:	2800      	cmp	r0, #0
    1f8c:	d07a      	beq.n	2084 <RGB_led_set(String const&)+0x104>
    digitalWrite(RGB_led_green, HIGH);
    1f8e:	2101      	movs	r1, #1
    1f90:	2002      	movs	r0, #2
    1f92:	f003 f955 	bl	5240 <digitalWrite>
    digitalWrite(RGB_led_blue, HIGH);
    1f96:	2101      	movs	r1, #1
    1f98:	2003      	movs	r0, #3
    1f9a:	f003 f951 	bl	5240 <digitalWrite>
    digitalWrite(RGB_led_red, LOW);
    1f9e:	2100      	movs	r1, #0
    1fa0:	2004      	movs	r0, #4
    1fa2:	f003 f94d 	bl	5240 <digitalWrite>
    1fa6:	4969      	ldr	r1, [pc, #420]	; (214c <RGB_led_set(String const&)+0x1cc>)
    1fa8:	4620      	mov	r0, r4
    1faa:	f004 fa05 	bl	63b8 <String::equals(char const*) const>
  }
  if (color == "green" || color == "Green" || color == "GREEN") {
    1fae:	2800      	cmp	r0, #0
    1fb0:	f000 80bb 	beq.w	212a <RGB_led_set(String const&)+0x1aa>
    digitalWrite(RGB_led_green, LOW);
    1fb4:	2100      	movs	r1, #0
    1fb6:	2002      	movs	r0, #2
    1fb8:	f003 f942 	bl	5240 <digitalWrite>
    digitalWrite(RGB_led_blue, HIGH);
    1fbc:	2101      	movs	r1, #1
    1fbe:	2003      	movs	r0, #3
    1fc0:	f003 f93e 	bl	5240 <digitalWrite>
    digitalWrite(RGB_led_red, HIGH);
    1fc4:	2101      	movs	r1, #1
    1fc6:	2004      	movs	r0, #4
    1fc8:	f003 f93a 	bl	5240 <digitalWrite>
    1fcc:	4960      	ldr	r1, [pc, #384]	; (2150 <RGB_led_set(String const&)+0x1d0>)
    1fce:	4620      	mov	r0, r4
    1fd0:	f004 f9f2 	bl	63b8 <String::equals(char const*) const>
  }
  if (color == "blue" || color == "Blue" || color == "BLUE") {
    1fd4:	2800      	cmp	r0, #0
    1fd6:	f000 8099 	beq.w	210c <RGB_led_set(String const&)+0x18c>
    digitalWrite(RGB_led_green, HIGH);
    1fda:	2101      	movs	r1, #1
    1fdc:	2002      	movs	r0, #2
    1fde:	f003 f92f 	bl	5240 <digitalWrite>
    digitalWrite(RGB_led_blue, LOW);
    1fe2:	2100      	movs	r1, #0
    1fe4:	2003      	movs	r0, #3
    1fe6:	f003 f92b 	bl	5240 <digitalWrite>
    digitalWrite(RGB_led_red, HIGH);
    1fea:	2101      	movs	r1, #1
    1fec:	2004      	movs	r0, #4
    1fee:	f003 f927 	bl	5240 <digitalWrite>
    1ff2:	4958      	ldr	r1, [pc, #352]	; (2154 <RGB_led_set(String const&)+0x1d4>)
    1ff4:	4620      	mov	r0, r4
    1ff6:	f004 f9df 	bl	63b8 <String::equals(char const*) const>
  }
  if (color == "cyan" || color == "Cyan" || color == "CYAN") {
    1ffa:	2800      	cmp	r0, #0
    1ffc:	d078      	beq.n	20f0 <RGB_led_set(String const&)+0x170>
    digitalWrite(RGB_led_green, LOW);
    1ffe:	2100      	movs	r1, #0
    2000:	2002      	movs	r0, #2
    2002:	f003 f91d 	bl	5240 <digitalWrite>
    digitalWrite(RGB_led_blue, LOW);
    2006:	2100      	movs	r1, #0
    2008:	2003      	movs	r0, #3
    200a:	f003 f919 	bl	5240 <digitalWrite>
    digitalWrite(RGB_led_red, HIGH);
    200e:	2101      	movs	r1, #1
    2010:	2004      	movs	r0, #4
    2012:	f003 f915 	bl	5240 <digitalWrite>
    2016:	4950      	ldr	r1, [pc, #320]	; (2158 <RGB_led_set(String const&)+0x1d8>)
    2018:	4620      	mov	r0, r4
    201a:	f004 f9cd 	bl	63b8 <String::equals(char const*) const>
  }
  if (color == "purple" || color == "Purple" || color == "PURPLE") {
    201e:	2800      	cmp	r0, #0
    2020:	d059      	beq.n	20d6 <RGB_led_set(String const&)+0x156>
    digitalWrite(RGB_led_green, HIGH);
    2022:	2101      	movs	r1, #1
    2024:	2002      	movs	r0, #2
    2026:	f003 f90b 	bl	5240 <digitalWrite>
    digitalWrite(RGB_led_blue, LOW);
    202a:	2100      	movs	r1, #0
    202c:	2003      	movs	r0, #3
    202e:	f003 f907 	bl	5240 <digitalWrite>
    digitalWrite(RGB_led_red, LOW);
    2032:	2100      	movs	r1, #0
    2034:	2004      	movs	r0, #4
    2036:	f003 f903 	bl	5240 <digitalWrite>
    203a:	4948      	ldr	r1, [pc, #288]	; (215c <RGB_led_set(String const&)+0x1dc>)
    203c:	4620      	mov	r0, r4
    203e:	f004 f9bb 	bl	63b8 <String::equals(char const*) const>
  }
  if (color == "orange" || color == "Orange" || color == "ORANGE") {
    2042:	2800      	cmp	r0, #0
    2044:	d03a      	beq.n	20bc <RGB_led_set(String const&)+0x13c>
    digitalWrite(RGB_led_green, LOW);
    2046:	2100      	movs	r1, #0
    2048:	2002      	movs	r0, #2
    204a:	f003 f8f9 	bl	5240 <digitalWrite>
    digitalWrite(RGB_led_blue, HIGH);
    204e:	2101      	movs	r1, #1
    2050:	2003      	movs	r0, #3
    2052:	f003 f8f5 	bl	5240 <digitalWrite>
    digitalWrite(RGB_led_red, LOW);
    2056:	2100      	movs	r1, #0
    2058:	2004      	movs	r0, #4
    205a:	f003 f8f1 	bl	5240 <digitalWrite>
    205e:	4940      	ldr	r1, [pc, #256]	; (2160 <RGB_led_set(String const&)+0x1e0>)
    2060:	4620      	mov	r0, r4
    2062:	f004 f9a9 	bl	63b8 <String::equals(char const*) const>
  }
  if (color == "white " || color == "White" || color == "WHITE") {
    2066:	b1e0      	cbz	r0, 20a2 <RGB_led_set(String const&)+0x122>
    digitalWrite(RGB_led_green, LOW);
    2068:	2100      	movs	r1, #0
    206a:	2002      	movs	r0, #2
    206c:	f003 f8e8 	bl	5240 <digitalWrite>
    digitalWrite(RGB_led_blue, LOW);
    2070:	2100      	movs	r1, #0
    2072:	2003      	movs	r0, #3
    2074:	f003 f8e4 	bl	5240 <digitalWrite>
    digitalWrite(RGB_led_red, LOW);
    2078:	2100      	movs	r1, #0
    207a:	2004      	movs	r0, #4
  }
}
    207c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    digitalWrite(RGB_led_red, LOW);
  }
  if (color == "white " || color == "White" || color == "WHITE") {
    digitalWrite(RGB_led_green, LOW);
    digitalWrite(RGB_led_blue, LOW);
    digitalWrite(RGB_led_red, LOW);
    2080:	f003 b8de 	b.w	5240 <digitalWrite>
    2084:	4937      	ldr	r1, [pc, #220]	; (2164 <RGB_led_set(String const&)+0x1e4>)
    2086:	4620      	mov	r0, r4
    2088:	f004 f996 	bl	63b8 <String::equals(char const*) const>
  }
  return output_number;
}

void RGB_led_set(const String& color) {
  if (color == "red" || color == "Red" || color == "RED") {
    208c:	2800      	cmp	r0, #0
    208e:	f47f af7e 	bne.w	1f8e <RGB_led_set(String const&)+0xe>
    2092:	4935      	ldr	r1, [pc, #212]	; (2168 <RGB_led_set(String const&)+0x1e8>)
    2094:	4620      	mov	r0, r4
    2096:	f004 f98f 	bl	63b8 <String::equals(char const*) const>
    209a:	2800      	cmp	r0, #0
    209c:	f47f af77 	bne.w	1f8e <RGB_led_set(String const&)+0xe>
    20a0:	e781      	b.n	1fa6 <RGB_led_set(String const&)+0x26>
    20a2:	4932      	ldr	r1, [pc, #200]	; (216c <RGB_led_set(String const&)+0x1ec>)
    20a4:	4620      	mov	r0, r4
    20a6:	f004 f987 	bl	63b8 <String::equals(char const*) const>
  if (color == "orange" || color == "Orange" || color == "ORANGE") {
    digitalWrite(RGB_led_green, LOW);
    digitalWrite(RGB_led_blue, HIGH);
    digitalWrite(RGB_led_red, LOW);
  }
  if (color == "white " || color == "White" || color == "WHITE") {
    20aa:	2800      	cmp	r0, #0
    20ac:	d1dc      	bne.n	2068 <RGB_led_set(String const&)+0xe8>
    20ae:	4620      	mov	r0, r4
    20b0:	492f      	ldr	r1, [pc, #188]	; (2170 <RGB_led_set(String const&)+0x1f0>)
    20b2:	f004 f981 	bl	63b8 <String::equals(char const*) const>
    20b6:	2800      	cmp	r0, #0
    20b8:	d1d6      	bne.n	2068 <RGB_led_set(String const&)+0xe8>
    20ba:	bd10      	pop	{r4, pc}
    20bc:	492d      	ldr	r1, [pc, #180]	; (2174 <RGB_led_set(String const&)+0x1f4>)
    20be:	4620      	mov	r0, r4
    20c0:	f004 f97a 	bl	63b8 <String::equals(char const*) const>
  if (color == "purple" || color == "Purple" || color == "PURPLE") {
    digitalWrite(RGB_led_green, HIGH);
    digitalWrite(RGB_led_blue, LOW);
    digitalWrite(RGB_led_red, LOW);
  }
  if (color == "orange" || color == "Orange" || color == "ORANGE") {
    20c4:	2800      	cmp	r0, #0
    20c6:	d1be      	bne.n	2046 <RGB_led_set(String const&)+0xc6>
    20c8:	492b      	ldr	r1, [pc, #172]	; (2178 <RGB_led_set(String const&)+0x1f8>)
    20ca:	4620      	mov	r0, r4
    20cc:	f004 f974 	bl	63b8 <String::equals(char const*) const>
    20d0:	2800      	cmp	r0, #0
    20d2:	d1b8      	bne.n	2046 <RGB_led_set(String const&)+0xc6>
    20d4:	e7c3      	b.n	205e <RGB_led_set(String const&)+0xde>
    20d6:	4929      	ldr	r1, [pc, #164]	; (217c <RGB_led_set(String const&)+0x1fc>)
    20d8:	4620      	mov	r0, r4
    20da:	f004 f96d 	bl	63b8 <String::equals(char const*) const>
  if (color == "cyan" || color == "Cyan" || color == "CYAN") {
    digitalWrite(RGB_led_green, LOW);
    digitalWrite(RGB_led_blue, LOW);
    digitalWrite(RGB_led_red, HIGH);
  }
  if (color == "purple" || color == "Purple" || color == "PURPLE") {
    20de:	2800      	cmp	r0, #0
    20e0:	d19f      	bne.n	2022 <RGB_led_set(String const&)+0xa2>
    20e2:	4927      	ldr	r1, [pc, #156]	; (2180 <RGB_led_set(String const&)+0x200>)
    20e4:	4620      	mov	r0, r4
    20e6:	f004 f967 	bl	63b8 <String::equals(char const*) const>
    20ea:	2800      	cmp	r0, #0
    20ec:	d199      	bne.n	2022 <RGB_led_set(String const&)+0xa2>
    20ee:	e7a4      	b.n	203a <RGB_led_set(String const&)+0xba>
    20f0:	4924      	ldr	r1, [pc, #144]	; (2184 <RGB_led_set(String const&)+0x204>)
    20f2:	4620      	mov	r0, r4
    20f4:	f004 f960 	bl	63b8 <String::equals(char const*) const>
  if (color == "blue" || color == "Blue" || color == "BLUE") {
    digitalWrite(RGB_led_green, HIGH);
    digitalWrite(RGB_led_blue, LOW);
    digitalWrite(RGB_led_red, HIGH);
  }
  if (color == "cyan" || color == "Cyan" || color == "CYAN") {
    20f8:	2800      	cmp	r0, #0
    20fa:	d180      	bne.n	1ffe <RGB_led_set(String const&)+0x7e>
    20fc:	4922      	ldr	r1, [pc, #136]	; (2188 <RGB_led_set(String const&)+0x208>)
    20fe:	4620      	mov	r0, r4
    2100:	f004 f95a 	bl	63b8 <String::equals(char const*) const>
    2104:	2800      	cmp	r0, #0
    2106:	f47f af7a 	bne.w	1ffe <RGB_led_set(String const&)+0x7e>
    210a:	e784      	b.n	2016 <RGB_led_set(String const&)+0x96>
    210c:	491f      	ldr	r1, [pc, #124]	; (218c <RGB_led_set(String const&)+0x20c>)
    210e:	4620      	mov	r0, r4
    2110:	f004 f952 	bl	63b8 <String::equals(char const*) const>
  if (color == "green" || color == "Green" || color == "GREEN") {
    digitalWrite(RGB_led_green, LOW);
    digitalWrite(RGB_led_blue, HIGH);
    digitalWrite(RGB_led_red, HIGH);
  }
  if (color == "blue" || color == "Blue" || color == "BLUE") {
    2114:	2800      	cmp	r0, #0
    2116:	f47f af60 	bne.w	1fda <RGB_led_set(String const&)+0x5a>
    211a:	491d      	ldr	r1, [pc, #116]	; (2190 <RGB_led_set(String const&)+0x210>)
    211c:	4620      	mov	r0, r4
    211e:	f004 f94b 	bl	63b8 <String::equals(char const*) const>
    2122:	2800      	cmp	r0, #0
    2124:	f47f af59 	bne.w	1fda <RGB_led_set(String const&)+0x5a>
    2128:	e763      	b.n	1ff2 <RGB_led_set(String const&)+0x72>
    212a:	491a      	ldr	r1, [pc, #104]	; (2194 <RGB_led_set(String const&)+0x214>)
    212c:	4620      	mov	r0, r4
    212e:	f004 f943 	bl	63b8 <String::equals(char const*) const>
  if (color == "red" || color == "Red" || color == "RED") {
    digitalWrite(RGB_led_green, HIGH);
    digitalWrite(RGB_led_blue, HIGH);
    digitalWrite(RGB_led_red, LOW);
  }
  if (color == "green" || color == "Green" || color == "GREEN") {
    2132:	2800      	cmp	r0, #0
    2134:	f47f af3e 	bne.w	1fb4 <RGB_led_set(String const&)+0x34>
    2138:	4917      	ldr	r1, [pc, #92]	; (2198 <RGB_led_set(String const&)+0x218>)
    213a:	4620      	mov	r0, r4
    213c:	f004 f93c 	bl	63b8 <String::equals(char const*) const>
    2140:	2800      	cmp	r0, #0
    2142:	f47f af37 	bne.w	1fb4 <RGB_led_set(String const&)+0x34>
    2146:	e741      	b.n	1fcc <RGB_led_set(String const&)+0x4c>
    2148:	00009a58 	.word	0x00009a58
    214c:	00009a64 	.word	0x00009a64
    2150:	00009a7c 	.word	0x00009a7c
    2154:	00009a94 	.word	0x00009a94
    2158:	00009aac 	.word	0x00009aac
    215c:	00009ac4 	.word	0x00009ac4
    2160:	00009adc 	.word	0x00009adc
    2164:	00009a5c 	.word	0x00009a5c
    2168:	00009a60 	.word	0x00009a60
    216c:	00009ae4 	.word	0x00009ae4
    2170:	00009aec 	.word	0x00009aec
    2174:	00009acc 	.word	0x00009acc
    2178:	00009ad4 	.word	0x00009ad4
    217c:	00009ab4 	.word	0x00009ab4
    2180:	00009abc 	.word	0x00009abc
    2184:	00009a9c 	.word	0x00009a9c
    2188:	00009aa4 	.word	0x00009aa4
    218c:	00009a84 	.word	0x00009a84
    2190:	00009a8c 	.word	0x00009a8c
    2194:	00009a6c 	.word	0x00009a6c
    2198:	00009a74 	.word	0x00009a74
    219c:	ffffffff 	.word	0xffffffff

000021a0 <wheel_speed_set(double, double, int)>:
  double pwm_signal_r = omega_to_pwm(controller_output_r);
  double pwm_signal_l = omega_to_pwm(controller_output_l);
  setPWM(pwm_signal_r,pwm_signal_l);
}

void wheel_speed_set(double input_vel_x, double input_omega, int tele_op){
    21a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    21a4:	ed2d 8b04 	vpush	{d8-d9}
  double vel_x_goal;
  double goal_omega;

  if (tele_op == 100){
    21a8:	2864      	cmp	r0, #100	; 0x64
  double pwm_signal_r = omega_to_pwm(controller_output_r);
  double pwm_signal_l = omega_to_pwm(controller_output_l);
  setPWM(pwm_signal_r,pwm_signal_l);
}

void wheel_speed_set(double input_vel_x, double input_omega, int tele_op){
    21aa:	b089      	sub	sp, #36	; 0x24
  double vel_x_goal;
  double goal_omega;

  if (tele_op == 100){
    21ac:	f000 8113 	beq.w	23d6 <wheel_speed_set(double, double, int)+0x236>
    21b0:	eeb0 8a40 	vmov.f32	s16, s0
    21b4:	eef0 8a60 	vmov.f32	s17, s1
    21b8:	eeb0 9a41 	vmov.f32	s18, s2
    21bc:	eef0 9a61 	vmov.f32	s19, s3
    RGB_led_set("red");
  }
  if (tele_op == 0 || tele_op == 1){//keyboard tele-op or PS4 controller tele-op
    21c0:	2801      	cmp	r0, #1
    21c2:	d906      	bls.n	21d2 <wheel_speed_set(double, double, int)+0x32>
    pwm_procent_right = int(map(goal_omega_right, 0, 100, 0, 255));
    pwm_procent_left = int(map(goal_omega_left, 0, 100, 0, 255));
    setPWM(pwm_procent_right, pwm_procent_left);
  }

  else if(tele_op == 2){//speed control with speed (PID) controller
    21c4:	2802      	cmp	r0, #2
    21c6:	d06b      	beq.n	22a0 <wheel_speed_set(double, double, int)+0x100>
  //wheel_speed.y = goal_omega;
  //wheel_speed.z = goal_omega_right;
  //wheel_speed.w = goal_omega_left;

  //speed_pub.publish(&wheel_speed);
}
    21c8:	b009      	add	sp, #36	; 0x24
    21ca:	ecbd 8b04 	vpop	{d8-d9}
    21ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

  if (tele_op == 100){
    RGB_led_set("red");
  }
  if (tele_op == 0 || tele_op == 1){//keyboard tele-op or PS4 controller tele-op
    if (tele_op == 0){ //keyboard tele-op setting indicator color
    21d2:	2800      	cmp	r0, #0
    21d4:	f000 80fc 	beq.w	23d0 <wheel_speed_set(double, double, int)+0x230>
      RGB_led_set("purple");
    }
    if (tele_op == 1){ //PS4 controller tele-op setting indicator color
      RGB_led_set("blue");
    21d8:	498b      	ldr	r1, [pc, #556]	; (2408 <wheel_speed_set(double, double, int)+0x268>)
    21da:	a804      	add	r0, sp, #16
  if (tele_op == 100){
    RGB_led_set("red");
  }
  if (tele_op == 0 || tele_op == 1){//keyboard tele-op or PS4 controller tele-op
    if (tele_op == 0){ //keyboard tele-op setting indicator color
      RGB_led_set("purple");
    21dc:	f004 f8d8 	bl	6390 <String::String(char const*)>
    21e0:	a804      	add	r0, sp, #16
    21e2:	f7ff fecd 	bl	1f80 <RGB_led_set(String const&)>
    21e6:	a804      	add	r0, sp, #16
    21e8:	f004 f892 	bl	6310 <String::~String()>
    if (tele_op == 1){ //PS4 controller tele-op setting indicator color
      RGB_led_set("blue");
    }
    // here we assume that the imput is for input_vel_x is between 0 - 1 and
    // input_omega is between 0 - 0.5
    vel_x_goal = input_vel_x * 75;
    21ec:	a382      	add	r3, pc, #520	; (adr r3, 23f8 <wheel_speed_set(double, double, int)+0x258>)
    21ee:	e9d3 2300 	ldrd	r2, r3, [r3]
    21f2:	ec51 0b18 	vmov	r0, r1, d8
    21f6:	f005 fd87 	bl	7d08 <__aeabi_dmul>
    goal_omega = input_omega * 50;
    21fa:	2200      	movs	r2, #0
    if (tele_op == 1){ //PS4 controller tele-op setting indicator color
      RGB_led_set("blue");
    }
    // here we assume that the imput is for input_vel_x is between 0 - 1 and
    // input_omega is between 0 - 0.5
    vel_x_goal = input_vel_x * 75;
    21fc:	4606      	mov	r6, r0
    21fe:	460f      	mov	r7, r1
    goal_omega = input_omega * 50;
    2200:	4b82      	ldr	r3, [pc, #520]	; (240c <wheel_speed_set(double, double, int)+0x26c>)
    2202:	ec51 0b19 	vmov	r0, r1, d9
    2206:	f005 fd7f 	bl	7d08 <__aeabi_dmul>
    220a:	4680      	mov	r8, r0
    220c:	4689      	mov	r9, r1
    goal_omega_right = vel_x_goal + goal_omega;
    220e:	4602      	mov	r2, r0
    2210:	460b      	mov	r3, r1
    2212:	4630      	mov	r0, r6
    2214:	4639      	mov	r1, r7
    2216:	f005 fbc5 	bl	79a4 <__adddf3>
    221a:	f8df e230 	ldr.w	lr, [pc, #560]	; 244c <wheel_speed_set(double, double, int)+0x2ac>
    221e:	4604      	mov	r4, r0
    2220:	460d      	mov	r5, r1
    2222:	e9ce 4500 	strd	r4, r5, [lr]
    goal_omega_left = vel_x_goal - goal_omega;
    2226:	4642      	mov	r2, r8
    2228:	464b      	mov	r3, r9
    222a:	4630      	mov	r0, r6
    222c:	4639      	mov	r1, r7
    222e:	f005 fbb7 	bl	79a0 <__aeabi_dsub>
    2232:	f8df e21c 	ldr.w	lr, [pc, #540]	; 2450 <wheel_speed_set(double, double, int)+0x2b0>
    2236:	4606      	mov	r6, r0
    2238:	460f      	mov	r7, r1
    223a:	e9ce 6700 	strd	r6, r7, [lr]
    pwm_procent_right = int(map(goal_omega_right, 0, 100, 0, 255));
    223e:	a370      	add	r3, pc, #448	; (adr r3, 2400 <wheel_speed_set(double, double, int)+0x260>)
    2240:	e9d3 2300 	ldrd	r2, r3, [r3]
    2244:	4620      	mov	r0, r4
    2246:	4629      	mov	r1, r5
    2248:	f005 fd5e 	bl	7d08 <__aeabi_dmul>
    224c:	2200      	movs	r2, #0
    224e:	4b70      	ldr	r3, [pc, #448]	; (2410 <wheel_speed_set(double, double, int)+0x270>)
    2250:	4d70      	ldr	r5, [pc, #448]	; (2414 <wheel_speed_set(double, double, int)+0x274>)
    2252:	f005 fe83 	bl	7f5c <__aeabi_ddiv>
    2256:	2200      	movs	r2, #0
    2258:	2300      	movs	r3, #0
    225a:	f005 fba3 	bl	79a4 <__adddf3>
    225e:	f006 f803 	bl	8268 <__aeabi_d2iz>
    2262:	4604      	mov	r4, r0
    pwm_procent_left = int(map(goal_omega_left, 0, 100, 0, 255));
    2264:	a366      	add	r3, pc, #408	; (adr r3, 2400 <wheel_speed_set(double, double, int)+0x260>)
    2266:	e9d3 2300 	ldrd	r2, r3, [r3]
    226a:	4630      	mov	r0, r6
    226c:	4639      	mov	r1, r7
    // input_omega is between 0 - 0.5
    vel_x_goal = input_vel_x * 75;
    goal_omega = input_omega * 50;
    goal_omega_right = vel_x_goal + goal_omega;
    goal_omega_left = vel_x_goal - goal_omega;
    pwm_procent_right = int(map(goal_omega_right, 0, 100, 0, 255));
    226e:	602c      	str	r4, [r5, #0]
    pwm_procent_left = int(map(goal_omega_left, 0, 100, 0, 255));
    2270:	f005 fd4a 	bl	7d08 <__aeabi_dmul>
    2274:	2200      	movs	r2, #0
    2276:	4b66      	ldr	r3, [pc, #408]	; (2410 <wheel_speed_set(double, double, int)+0x270>)
    2278:	f005 fe70 	bl	7f5c <__aeabi_ddiv>
    227c:	2200      	movs	r2, #0
    227e:	2300      	movs	r3, #0
    2280:	f005 fb90 	bl	79a4 <__adddf3>
    2284:	f005 fff0 	bl	8268 <__aeabi_d2iz>
    2288:	4a63      	ldr	r2, [pc, #396]	; (2418 <wheel_speed_set(double, double, int)+0x278>)
    228a:	4603      	mov	r3, r0
    setPWM(pwm_procent_right, pwm_procent_left);
    228c:	4619      	mov	r1, r3
    228e:	4620      	mov	r0, r4
    vel_x_goal = input_vel_x * 75;
    goal_omega = input_omega * 50;
    goal_omega_right = vel_x_goal + goal_omega;
    goal_omega_left = vel_x_goal - goal_omega;
    pwm_procent_right = int(map(goal_omega_right, 0, 100, 0, 255));
    pwm_procent_left = int(map(goal_omega_left, 0, 100, 0, 255));
    2290:	6013      	str	r3, [r2, #0]
    setPWM(pwm_procent_right, pwm_procent_left);
    2292:	f7ff fd61 	bl	1d58 <setPWM(int, int)>
  //wheel_speed.y = goal_omega;
  //wheel_speed.z = goal_omega_right;
  //wheel_speed.w = goal_omega_left;

  //speed_pub.publish(&wheel_speed);
}
    2296:	b009      	add	sp, #36	; 0x24
    2298:	ecbd 8b04 	vpop	{d8-d9}
    229c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    pwm_procent_left = int(map(goal_omega_left, 0, 100, 0, 255));
    setPWM(pwm_procent_right, pwm_procent_left);
  }

  else if(tele_op == 2){//speed control with speed (PID) controller
    RGB_led_set("green");
    22a0:	495e      	ldr	r1, [pc, #376]	; (241c <wheel_speed_set(double, double, int)+0x27c>)
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    22a2:	f8df b1a8 	ldr.w	fp, [pc, #424]	; 244c <wheel_speed_set(double, double, int)+0x2ac>
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    22a6:	f8df a1a8 	ldr.w	sl, [pc, #424]	; 2450 <wheel_speed_set(double, double, int)+0x2b0>
    pwm_procent_left = int(map(goal_omega_left, 0, 100, 0, 255));
    setPWM(pwm_procent_right, pwm_procent_left);
  }

  else if(tele_op == 2){//speed control with speed (PID) controller
    RGB_led_set("green");
    22aa:	a804      	add	r0, sp, #16
    22ac:	f004 f870 	bl	6390 <String::String(char const*)>
    22b0:	a804      	add	r0, sp, #16
    22b2:	f7ff fe65 	bl	1f80 <RGB_led_set(String const&)>
    22b6:	a804      	add	r0, sp, #16
    22b8:	f004 f82a 	bl	6310 <String::~String()>
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    22bc:	ec53 2b18 	vmov	r2, r3, d8
    22c0:	ee18 0a10 	vmov	r0, s16
    22c4:	4619      	mov	r1, r3
    22c6:	f005 fb6d 	bl	79a4 <__adddf3>
    22ca:	4b55      	ldr	r3, [pc, #340]	; (2420 <wheel_speed_set(double, double, int)+0x280>)
    22cc:	4606      	mov	r6, r0
    22ce:	6818      	ldr	r0, [r3, #0]
    22d0:	460f      	mov	r7, r1
    22d2:	f005 fcc5 	bl	7c60 <__aeabi_f2d>
    22d6:	ec53 2b19 	vmov	r2, r3, d9
    22da:	f005 fd15 	bl	7d08 <__aeabi_dmul>
    22de:	4b51      	ldr	r3, [pc, #324]	; (2424 <wheel_speed_set(double, double, int)+0x284>)
    22e0:	ed93 7a00 	vldr	s14, [r3]
    22e4:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
    22e8:	ee67 7a27 	vmul.f32	s15, s14, s15
    22ec:	4680      	mov	r8, r0
    22ee:	ee17 0a90 	vmov	r0, s15
    22f2:	4689      	mov	r9, r1
    22f4:	f005 fcb4 	bl	7c60 <__aeabi_f2d>
    22f8:	4642      	mov	r2, r8
    22fa:	4604      	mov	r4, r0
    22fc:	460d      	mov	r5, r1
    22fe:	464b      	mov	r3, r9
    2300:	4630      	mov	r0, r6
    2302:	4639      	mov	r1, r7
    2304:	f005 fb4e 	bl	79a4 <__adddf3>
    2308:	4622      	mov	r2, r4
    230a:	462b      	mov	r3, r5
    230c:	f005 fe26 	bl	7f5c <__aeabi_ddiv>
    2310:	e9cd 0100 	strd	r0, r1, [sp]
    2314:	ed9d 7b00 	vldr	d7, [sp]
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    2318:	4642      	mov	r2, r8
    231a:	464b      	mov	r3, r9
    231c:	4630      	mov	r0, r6
    231e:	4639      	mov	r1, r7
  else if(tele_op == 2){//speed control with speed (PID) controller
    RGB_led_set("green");
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    2320:	ed8b 7b00 	vstr	d7, [fp]
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    2324:	f005 fb3c 	bl	79a0 <__aeabi_dsub>
    2328:	4622      	mov	r2, r4
    232a:	462b      	mov	r3, r5
    232c:	f005 fe16 	bl	7f5c <__aeabi_ddiv>
    double time_elapsed = double(current_time - previous_time);
    2330:	4a3d      	ldr	r2, [pc, #244]	; (2428 <wheel_speed_set(double, double, int)+0x288>)
    2332:	4b3e      	ldr	r3, [pc, #248]	; (242c <wheel_speed_set(double, double, int)+0x28c>)
    if(goal_omega_right > 15){
    2334:	4d3e      	ldr	r5, [pc, #248]	; (2430 <wheel_speed_set(double, double, int)+0x290>)
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    double time_elapsed = double(current_time - previous_time);
    2336:	681b      	ldr	r3, [r3, #0]
    RGB_led_set("green");
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    2338:	4606      	mov	r6, r0
    double time_elapsed = double(current_time - previous_time);
    233a:	6810      	ldr	r0, [r2, #0]
    RGB_led_set("green");
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    233c:	460f      	mov	r7, r1
    double time_elapsed = double(current_time - previous_time);
    233e:	1ac0      	subs	r0, r0, r3
    RGB_led_set("green");
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    2340:	e9ca 6700 	strd	r6, r7, [sl]
    double time_elapsed = double(current_time - previous_time);
    2344:	f005 fc7a 	bl	7c3c <__aeabi_i2d>
    if(goal_omega_right > 15){
    2348:	2400      	movs	r4, #0
    // here we assume that the imput gives a goal_omega =< 15 [rad/s]
    vel_x_goal = input_vel_x;
    goal_omega = input_omega;
    goal_omega_right = (2*vel_x_goal + wheel_base*goal_omega)/(4*wheel_radius);
    goal_omega_left = (2*vel_x_goal - wheel_base*goal_omega)/(4*wheel_radius);
    double time_elapsed = double(current_time - previous_time);
    234a:	4680      	mov	r8, r0
    234c:	4689      	mov	r9, r1
    if(goal_omega_right > 15){
    234e:	4622      	mov	r2, r4
    2350:	462b      	mov	r3, r5
    2352:	e9dd 0100 	ldrd	r0, r1, [sp]
    2356:	f005 ff67 	bl	8228 <__aeabi_dcmpgt>
    235a:	b118      	cbz	r0, 2364 <wheel_speed_set(double, double, int)+0x1c4>
      goal_omega_right = 15;
    235c:	e9cb 4500 	strd	r4, r5, [fp]
    2360:	e9cd 4500 	strd	r4, r5, [sp]
    }
    if(goal_omega_left > 15){
    2364:	4d32      	ldr	r5, [pc, #200]	; (2430 <wheel_speed_set(double, double, int)+0x290>)
    2366:	2400      	movs	r4, #0
    2368:	4630      	mov	r0, r6
    236a:	4639      	mov	r1, r7
    236c:	4622      	mov	r2, r4
    236e:	462b      	mov	r3, r5
    2370:	f005 ff5a 	bl	8228 <__aeabi_dcmpgt>
    2374:	b118      	cbz	r0, 237e <wheel_speed_set(double, double, int)+0x1de>
      goal_omega_left = 15;
    2376:	e9ca 4500 	strd	r4, r5, [sl]
    237a:	4626      	mov	r6, r4
    237c:	462f      	mov	r7, r5
    }
    //temp_input_vel = goal_omega_right;
    speed_PID_controller(goal_omega_right, average_omega_right, last_error_right, goal_omega_left, average_omega_left, last_error_left, time_elapsed);
    237e:	4a2d      	ldr	r2, [pc, #180]	; (2434 <wheel_speed_set(double, double, int)+0x294>)
    2380:	4b2d      	ldr	r3, [pc, #180]	; (2438 <wheel_speed_set(double, double, int)+0x298>)
    2382:	6810      	ldr	r0, [r2, #0]
    2384:	ed93 9b00 	vldr	d9, [r3]
    2388:	f005 fc6a 	bl	7c60 <__aeabi_f2d>
    238c:	4b2b      	ldr	r3, [pc, #172]	; (243c <wheel_speed_set(double, double, int)+0x29c>)
    238e:	4a2c      	ldr	r2, [pc, #176]	; (2440 <wheel_speed_set(double, double, int)+0x2a0>)
    2390:	e9cd 0102 	strd	r0, r1, [sp, #8]
    2394:	6818      	ldr	r0, [r3, #0]
    2396:	ed92 8b00 	vldr	d8, [r2]
    239a:	f005 fc61 	bl	7c60 <__aeabi_f2d>
    239e:	eeb0 5a49 	vmov.f32	s10, s18
    23a2:	eef0 5a69 	vmov.f32	s11, s19
    23a6:	eeb0 2a48 	vmov.f32	s4, s16
    23aa:	eef0 2a68 	vmov.f32	s5, s17
    23ae:	ec49 8b16 	vmov	d6, r8, r9
    23b2:	ed9d 4b02 	vldr	d4, [sp, #8]
    23b6:	ec47 6b13 	vmov	d3, r6, r7
    23ba:	ec41 0b11 	vmov	d1, r0, r1
    23be:	ed9d 0b00 	vldr	d0, [sp]
    23c2:	f7ff fd0b 	bl	1ddc <speed_PID_controller(double, double, double, double, double, double, double)>
  //wheel_speed.y = goal_omega;
  //wheel_speed.z = goal_omega_right;
  //wheel_speed.w = goal_omega_left;

  //speed_pub.publish(&wheel_speed);
}
    23c6:	b009      	add	sp, #36	; 0x24
    23c8:	ecbd 8b04 	vpop	{d8-d9}
    23cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (tele_op == 100){
    RGB_led_set("red");
  }
  if (tele_op == 0 || tele_op == 1){//keyboard tele-op or PS4 controller tele-op
    if (tele_op == 0){ //keyboard tele-op setting indicator color
      RGB_led_set("purple");
    23d0:	a804      	add	r0, sp, #16
    23d2:	491c      	ldr	r1, [pc, #112]	; (2444 <wheel_speed_set(double, double, int)+0x2a4>)
    23d4:	e702      	b.n	21dc <wheel_speed_set(double, double, int)+0x3c>
void wheel_speed_set(double input_vel_x, double input_omega, int tele_op){
  double vel_x_goal;
  double goal_omega;

  if (tele_op == 100){
    RGB_led_set("red");
    23d6:	491c      	ldr	r1, [pc, #112]	; (2448 <wheel_speed_set(double, double, int)+0x2a8>)
    23d8:	a804      	add	r0, sp, #16
    23da:	f003 ffd9 	bl	6390 <String::String(char const*)>
    23de:	a804      	add	r0, sp, #16
    23e0:	f7ff fdce 	bl	1f80 <RGB_led_set(String const&)>
    23e4:	a804      	add	r0, sp, #16
    23e6:	f003 ff93 	bl	6310 <String::~String()>
  //wheel_speed.y = goal_omega;
  //wheel_speed.z = goal_omega_right;
  //wheel_speed.w = goal_omega_left;

  //speed_pub.publish(&wheel_speed);
}
    23ea:	b009      	add	sp, #36	; 0x24
    23ec:	ecbd 8b04 	vpop	{d8-d9}
    23f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    23f4:	f3af 8000 	nop.w
    23f8:	00000000 	.word	0x00000000
    23fc:	4052c000 	.word	0x4052c000
    2400:	00000000 	.word	0x00000000
    2404:	406fe000 	.word	0x406fe000
    2408:	00009a7c 	.word	0x00009a7c
    240c:	40490000 	.word	0x40490000
    2410:	40590000 	.word	0x40590000
    2414:	1fff1d50 	.word	0x1fff1d50
    2418:	1fff1d38 	.word	0x1fff1d38
    241c:	00009a64 	.word	0x00009a64
    2420:	1fff0814 	.word	0x1fff0814
    2424:	1fff0810 	.word	0x1fff0810
    2428:	1fff2b90 	.word	0x1fff2b90
    242c:	1fff2b88 	.word	0x1fff2b88
    2430:	402e0000 	.word	0x402e0000
    2434:	1fff1c9c 	.word	0x1fff1c9c
    2438:	1fff1488 	.word	0x1fff1488
    243c:	1fff1494 	.word	0x1fff1494
    2440:	1fff1d48 	.word	0x1fff1d48
    2444:	00009aac 	.word	0x00009aac
    2448:	00009a58 	.word	0x00009a58
    244c:	1fff2b68 	.word	0x1fff2b68
    2450:	1fff14a0 	.word	0x1fff14a0

00002454 <cmd_velocity(geometry_msgs::Twist&)>:
  if (hi == 0){
    RGB_led_set("red");
  }
}

void cmd_velocity(geometry_msgs::Twist& cmd_goal) {
    2454:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  double goal_vel_x = cmd_goal.linear.x;
  double goal_omega = cmd_goal.angular.z;
  if (cmd_goal.angular.x == 0){ // here if this is true that means that the robot is being teleoperated
    2456:	e9d0 670c 	ldrd	r6, r7, [r0, #48]	; 0x30
  if (hi == 0){
    RGB_led_set("red");
  }
}

void cmd_velocity(geometry_msgs::Twist& cmd_goal) {
    245a:	ed2d 8b04 	vpush	{d8-d9}
    245e:	4604      	mov	r4, r0
  double goal_vel_x = cmd_goal.linear.x;
  double goal_omega = cmd_goal.angular.z;
  if (cmd_goal.angular.x == 0){ // here if this is true that means that the robot is being teleoperated
    2460:	2200      	movs	r2, #0
    2462:	2300      	movs	r3, #0
    2464:	4630      	mov	r0, r6
    2466:	4639      	mov	r1, r7
    2468:	f005 feb6 	bl	81d8 <__aeabi_dcmpeq>
    RGB_led_set("red");
  }
}

void cmd_velocity(geometry_msgs::Twist& cmd_goal) {
  double goal_vel_x = cmd_goal.linear.x;
    246c:	ed94 9b04 	vldr	d9, [r4, #16]
  double goal_omega = cmd_goal.angular.z;
    2470:	ed94 8b10 	vldr	d8, [r4, #64]	; 0x40
  if (cmd_goal.angular.x == 0){ // here if this is true that means that the robot is being teleoperated
    bool_tele_op_toggel = 0;
    2474:	4d1d      	ldr	r5, [pc, #116]	; (24ec <cmd_velocity(geometry_msgs::Twist&)+0x98>)
}

void cmd_velocity(geometry_msgs::Twist& cmd_goal) {
  double goal_vel_x = cmd_goal.linear.x;
  double goal_omega = cmd_goal.angular.z;
  if (cmd_goal.angular.x == 0){ // here if this is true that means that the robot is being teleoperated
    2476:	b108      	cbz	r0, 247c <cmd_velocity(geometry_msgs::Twist&)+0x28>
    bool_tele_op_toggel = 0;
    2478:	2300      	movs	r3, #0
    247a:	602b      	str	r3, [r5, #0]
  }
  if (cmd_goal.angular.x == 5){
    247c:	2200      	movs	r2, #0
    247e:	4b1c      	ldr	r3, [pc, #112]	; (24f0 <cmd_velocity(geometry_msgs::Twist&)+0x9c>)
    2480:	4630      	mov	r0, r6
    2482:	4639      	mov	r1, r7
    2484:	f005 fea8 	bl	81d8 <__aeabi_dcmpeq>
    2488:	b188      	cbz	r0, 24ae <cmd_velocity(geometry_msgs::Twist&)+0x5a>
    bool_tele_op_toggel = 1;
    goal_omega = cmd_goal.linear.y;
    248a:	ed94 8b06 	vldr	d8, [r4, #24]
  double goal_omega = cmd_goal.angular.z;
  if (cmd_goal.angular.x == 0){ // here if this is true that means that the robot is being teleoperated
    bool_tele_op_toggel = 0;
  }
  if (cmd_goal.angular.x == 5){
    bool_tele_op_toggel = 1;
    248e:	2001      	movs	r0, #1
    2490:	6028      	str	r0, [r5, #0]
    bool_tele_op_toggel = 100;
  }
  //if(tele_op_toggel == 0.5 || tele_op_toggel == -0.5){
  //  bool_tele_op_toggel = !bool_tele_op_toggel;
  //}
  wheel_speed_set(goal_vel_x, goal_omega, bool_tele_op_toggel);
    2492:	eeb0 1a48 	vmov.f32	s2, s16
    2496:	eef0 1a68 	vmov.f32	s3, s17
    249a:	eeb0 0a49 	vmov.f32	s0, s18
    249e:	eef0 0a69 	vmov.f32	s1, s19
}
    24a2:	ecbd 8b04 	vpop	{d8-d9}
    24a6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    bool_tele_op_toggel = 100;
  }
  //if(tele_op_toggel == 0.5 || tele_op_toggel == -0.5){
  //  bool_tele_op_toggel = !bool_tele_op_toggel;
  //}
  wheel_speed_set(goal_vel_x, goal_omega, bool_tele_op_toggel);
    24aa:	f7ff be79 	b.w	21a0 <wheel_speed_set(double, double, int)>
  }
  if (cmd_goal.angular.x == 5){
    bool_tele_op_toggel = 1;
    goal_omega = cmd_goal.linear.y;
  }
  if (cmd_goal.angular.x == 90){
    24ae:	2200      	movs	r2, #0
    24b0:	4b10      	ldr	r3, [pc, #64]	; (24f4 <cmd_velocity(geometry_msgs::Twist&)+0xa0>)
    24b2:	4630      	mov	r0, r6
    24b4:	4639      	mov	r1, r7
    24b6:	f005 fe8f 	bl	81d8 <__aeabi_dcmpeq>
    24ba:	b940      	cbnz	r0, 24ce <cmd_velocity(geometry_msgs::Twist&)+0x7a>
    bool_tele_op_toggel = 2;
    cum_error_r = 0;
    cum_error_l = 0;
  }
  else if (cmd_goal.angular.x != 0 && cmd_goal.angular.x != 5 && cmd_goal.angular.x != 90){
    24bc:	4630      	mov	r0, r6
    24be:	4639      	mov	r1, r7
    24c0:	2200      	movs	r2, #0
    24c2:	2300      	movs	r3, #0
    24c4:	f005 fe88 	bl	81d8 <__aeabi_dcmpeq>
    24c8:	b160      	cbz	r0, 24e4 <cmd_velocity(geometry_msgs::Twist&)+0x90>
    24ca:	6828      	ldr	r0, [r5, #0]
    24cc:	e7e1      	b.n	2492 <cmd_velocity(geometry_msgs::Twist&)+0x3e>
    bool_tele_op_toggel = 1;
    goal_omega = cmd_goal.linear.y;
  }
  if (cmd_goal.angular.x == 90){
    bool_tele_op_toggel = 2;
    cum_error_r = 0;
    24ce:	4c0a      	ldr	r4, [pc, #40]	; (24f8 <cmd_velocity(geometry_msgs::Twist&)+0xa4>)
    cum_error_l = 0;
    24d0:	490a      	ldr	r1, [pc, #40]	; (24fc <cmd_velocity(geometry_msgs::Twist&)+0xa8>)
    bool_tele_op_toggel = 1;
    goal_omega = cmd_goal.linear.y;
  }
  if (cmd_goal.angular.x == 90){
    bool_tele_op_toggel = 2;
    cum_error_r = 0;
    24d2:	2200      	movs	r2, #0
    24d4:	2300      	movs	r3, #0
  if (cmd_goal.angular.x == 5){
    bool_tele_op_toggel = 1;
    goal_omega = cmd_goal.linear.y;
  }
  if (cmd_goal.angular.x == 90){
    bool_tele_op_toggel = 2;
    24d6:	2002      	movs	r0, #2
    cum_error_r = 0;
    24d8:	e9c4 2300 	strd	r2, r3, [r4]
    cum_error_l = 0;
    24dc:	e9c1 2300 	strd	r2, r3, [r1]
  if (cmd_goal.angular.x == 5){
    bool_tele_op_toggel = 1;
    goal_omega = cmd_goal.linear.y;
  }
  if (cmd_goal.angular.x == 90){
    bool_tele_op_toggel = 2;
    24e0:	6028      	str	r0, [r5, #0]
    24e2:	e7d6      	b.n	2492 <cmd_velocity(geometry_msgs::Twist&)+0x3e>
    cum_error_r = 0;
    cum_error_l = 0;
  }
  else if (cmd_goal.angular.x != 0 && cmd_goal.angular.x != 5 && cmd_goal.angular.x != 90){
    bool_tele_op_toggel = 100;
    24e4:	2064      	movs	r0, #100	; 0x64
    24e6:	6028      	str	r0, [r5, #0]
    24e8:	e7d3      	b.n	2492 <cmd_velocity(geometry_msgs::Twist&)+0x3e>
    24ea:	bf00      	nop
    24ec:	1fff1ca0 	.word	0x1fff1ca0
    24f0:	40140000 	.word	0x40140000
    24f4:	40568000 	.word	0x40568000
    24f8:	1fff2b20 	.word	0x1fff2b20
    24fc:	1fff2a80 	.word	0x1fff2a80

00002500 <setup>:

// Subscribers //
ros::Subscriber<geometry_msgs::Twist> sub_cmd_vel("cmd_vel", &cmd_velocity);
//ros::Subscriber<std_msgs::Int16> start_up("stat_up_done", &start_up_hi);

void setup() {
    2500:	b530      	push	{r4, r5, lr}

  /* Start serial, initialize buffers */
  void initNode()
  {
    hardware_.init();
    mode_ = 0;
    2502:	4d4a      	ldr	r5, [pc, #296]	; (262c <setup+0x12c>)
    2504:	b085      	sub	sp, #20
    2506:	2400      	movs	r4, #0
  nh.initNode();
  Serial.begin(9600);
  pinMode(RGB_led_green, OUTPUT);
    2508:	2101      	movs	r1, #1
    250a:	2002      	movs	r0, #2
    250c:	f8c5 44e4 	str.w	r4, [r5, #1252]	; 0x4e4
    bytes_ = 0;
    2510:	f8c5 44e8 	str.w	r4, [r5, #1256]	; 0x4e8
    index_ = 0;
    2514:	f8c5 44f0 	str.w	r4, [r5, #1264]	; 0x4f0
    topic_ = 0;
    2518:	f8c5 44ec 	str.w	r4, [r5, #1260]	; 0x4ec
    251c:	f002 fe96 	bl	524c <pinMode>
  pinMode(RGB_led_blue, OUTPUT);
    2520:	2101      	movs	r1, #1
    2522:	2003      	movs	r0, #3
    2524:	f002 fe92 	bl	524c <pinMode>
  pinMode(RGB_led_red, OUTPUT);
    2528:	2101      	movs	r1, #1
    252a:	2004      	movs	r0, #4
    252c:	f002 fe8e 	bl	524c <pinMode>
  RGB_led_set("white");
    2530:	493f      	ldr	r1, [pc, #252]	; (2630 <setup+0x130>)
    2532:	4668      	mov	r0, sp
    2534:	f003 ff2c 	bl	6390 <String::String(char const*)>
    2538:	4668      	mov	r0, sp
    253a:	f7ff fd21 	bl	1f80 <RGB_led_set(String const&)>
    253e:	4668      	mov	r0, sp
    2540:	f003 fee6 	bl	6310 <String::~String()>
  pinMode(right_motor_pwm, OUTPUT);
    2544:	2101      	movs	r1, #1
    2546:	201d      	movs	r0, #29
    2548:	f002 fe80 	bl	524c <pinMode>
  pinMode(right_motor_ina, OUTPUT);
    254c:	2101      	movs	r1, #1
    254e:	201e      	movs	r0, #30
    2550:	f002 fe7c 	bl	524c <pinMode>
  pinMode(right_motor_inb, OUTPUT);
    2554:	2101      	movs	r1, #1
    2556:	201c      	movs	r0, #28
    2558:	f002 fe78 	bl	524c <pinMode>
  pinMode(right_encoder_a, INPUT_PULLUP);
    255c:	2102      	movs	r1, #2
    255e:	2018      	movs	r0, #24
    2560:	f002 fe74 	bl	524c <pinMode>
  pinMode(right_encoder_b, INPUT_PULLUP);
    2564:	2102      	movs	r1, #2
    2566:	2019      	movs	r0, #25
    2568:	f002 fe70 	bl	524c <pinMode>
  pinMode(left_motor_pwm, OUTPUT);
    256c:	2101      	movs	r1, #1
    256e:	2026      	movs	r0, #38	; 0x26
    2570:	f002 fe6c 	bl	524c <pinMode>
  pinMode(left_motor_ina, OUTPUT);
    2574:	2101      	movs	r1, #1
    2576:	2027      	movs	r0, #39	; 0x27
    2578:	f002 fe68 	bl	524c <pinMode>
  pinMode(left_motor_inb, OUTPUT);
    257c:	2101      	movs	r1, #1
    257e:	2025      	movs	r0, #37	; 0x25
    2580:	f002 fe64 	bl	524c <pinMode>
  pinMode(left_encoder_a, INPUT_PULLUP);
    2584:	2102      	movs	r1, #2
    2586:	2021      	movs	r0, #33	; 0x21
    2588:	f002 fe60 	bl	524c <pinMode>
  pinMode(left_encoder_b, INPUT_PULLUP);
    258c:	2102      	movs	r1, #2
    258e:	2022      	movs	r0, #34	; 0x22
    2590:	f002 fe5c 	bl	524c <pinMode>
  attachInterrupt(digitalPinToInterrupt(right_encoder_a), encoder_count_chage_right, CHANGE);
    2594:	2204      	movs	r2, #4
    2596:	4927      	ldr	r1, [pc, #156]	; (2634 <setup+0x134>)
    2598:	2018      	movs	r0, #24
    259a:	f002 fc23 	bl	4de4 <attachInterrupt>
  attachInterrupt(digitalPinToInterrupt(right_encoder_b), encoder_count_chage_right, CHANGE);
    259e:	2204      	movs	r2, #4
    25a0:	4924      	ldr	r1, [pc, #144]	; (2634 <setup+0x134>)
    25a2:	2019      	movs	r0, #25
    25a4:	f002 fc1e 	bl	4de4 <attachInterrupt>
  attachInterrupt(digitalPinToInterrupt(left_encoder_a), encoder_count_chage_left, CHANGE);
    25a8:	2204      	movs	r2, #4
    25aa:	4923      	ldr	r1, [pc, #140]	; (2638 <setup+0x138>)
    25ac:	2021      	movs	r0, #33	; 0x21
    25ae:	f002 fc19 	bl	4de4 <attachInterrupt>
  attachInterrupt(digitalPinToInterrupt(left_encoder_b), encoder_count_chage_left, CHANGE);
    25b2:	2204      	movs	r2, #4
    25b4:	4920      	ldr	r1, [pc, #128]	; (2638 <setup+0x138>)
    25b6:	2022      	movs	r0, #34	; 0x22
    25b8:	f002 fc14 	bl	4de4 <attachInterrupt>
  }

  /* Register a new subscriber */
  bool subscribe(Subscriber_& s)
  {
    for (int i = 0; i < MAX_SUBSCRIBERS; i++)
    25bc:	4623      	mov	r3, r4
    25be:	f205 427c 	addw	r2, r5, #1148	; 0x47c
    25c2:	e002      	b.n	25ca <setup+0xca>
    25c4:	3301      	adds	r3, #1
    25c6:	2b19      	cmp	r3, #25
    25c8:	d00a      	beq.n	25e0 <setup+0xe0>
    {
      if (subscribers[i] == 0) // empty slot
    25ca:	f852 1f04 	ldr.w	r1, [r2, #4]!
    25ce:	2900      	cmp	r1, #0
    25d0:	d1f8      	bne.n	25c4 <setup+0xc4>
      {
        subscribers[i] = &s;
    25d2:	f503 7190 	add.w	r1, r3, #288	; 0x120
    25d6:	4a19      	ldr	r2, [pc, #100]	; (263c <setup+0x13c>)
    25d8:	f845 2021 	str.w	r2, [r5, r1, lsl #2]
        s.id_ = i + 100;
    25dc:	3364      	adds	r3, #100	; 0x64
    25de:	6053      	str	r3, [r2, #4]
    25e0:	4a17      	ldr	r2, [pc, #92]	; (2640 <setup+0x140>)
   */

  /* Register a new publisher */
  bool advertise(Publisher & p)
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    25e2:	2300      	movs	r3, #0
  }

  /* Register a new subscriber */
  bool subscribe(Subscriber_& s)
  {
    for (int i = 0; i < MAX_SUBSCRIBERS; i++)
    25e4:	4611      	mov	r1, r2
    25e6:	e002      	b.n	25ee <setup+0xee>
   */

  /* Register a new publisher */
  bool advertise(Publisher & p)
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    25e8:	3301      	adds	r3, #1
    25ea:	2b19      	cmp	r3, #25
    25ec:	d00b      	beq.n	2606 <setup+0x106>
    {
      if (publishers[i] == 0) // empty slot
    25ee:	f851 0f04 	ldr.w	r0, [r1, #4]!
    25f2:	2800      	cmp	r0, #0
    25f4:	d1f8      	bne.n	25e8 <setup+0xe8>
      {
        publishers[i] = &p;
    25f6:	4913      	ldr	r1, [pc, #76]	; (2644 <setup+0x144>)
    25f8:	eb05 0083 	add.w	r0, r5, r3, lsl #2
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    25fc:	337d      	adds	r3, #125	; 0x7d
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] == 0) // empty slot
      {
        publishers[i] = &p;
    25fe:	f8c0 141c 	str.w	r1, [r0, #1052]	; 0x41c
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    2602:	608b      	str	r3, [r1, #8]
        p.nh_ = this;
    2604:	60cd      	str	r5, [r1, #12]
   */

  /* Register a new publisher */
  bool advertise(Publisher & p)
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    2606:	2300      	movs	r3, #0
    2608:	e002      	b.n	2610 <setup+0x110>
    260a:	3301      	adds	r3, #1
    260c:	2b19      	cmp	r3, #25
    260e:	d00b      	beq.n	2628 <setup+0x128>
    {
      if (publishers[i] == 0) // empty slot
    2610:	f852 1f04 	ldr.w	r1, [r2, #4]!
    2614:	2900      	cmp	r1, #0
    2616:	d1f8      	bne.n	260a <setup+0x10a>
      {
        publishers[i] = &p;
    2618:	4a0b      	ldr	r2, [pc, #44]	; (2648 <setup+0x148>)
    261a:	eb05 0183 	add.w	r1, r5, r3, lsl #2
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    261e:	337d      	adds	r3, #125	; 0x7d
  {
    for (int i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] == 0) // empty slot
      {
        publishers[i] = &p;
    2620:	f8c1 241c 	str.w	r2, [r1, #1052]	; 0x41c
        p.id_ = i + 100 + MAX_SUBSCRIBERS;
    2624:	6093      	str	r3, [r2, #8]
        p.nh_ = this;
    2626:	60d5      	str	r5, [r2, #12]
  //                Adafruit_BMP280::SAMPLING_X2,     /* Temp. oversampling */
  //                Adafruit_BMP280::SAMPLING_X16,    /* Pressure oversampling */
  //                Adafruit_BMP280::FILTER_X16,      /* Filtering. */
  //                Adafruit_BMP280::STANDBY_MS_500); /* Standby time. */
  //bmp_temp->printSensorDetails();
}
    2628:	b005      	add	sp, #20
    262a:	bd30      	pop	{r4, r5, pc}
    262c:	1fff1d58 	.word	0x1fff1d58
    2630:	00009af4 	.word	0x00009af4
    2634:	00000999 	.word	0x00000999
    2638:	00000b19 	.word	0x00000b19
    263c:	1fff1cb0 	.word	0x1fff1cb0
    2640:	1fff2170 	.word	0x1fff2170
    2644:	1fff1d18 	.word	0x1fff1d18
    2648:	1fff2290 	.word	0x1fff2290
    264c:	ffffffff 	.word	0xffffffff

00002650 <loop>:




void loop() {
    2650:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int i = 0;
  if(bool_tele_op_toggel == 2){
    2654:	4bc2      	ldr	r3, [pc, #776]	; (2960 <loop+0x310>)
    2656:	681b      	ldr	r3, [r3, #0]
    2658:	2b02      	cmp	r3, #2
}




void loop() {
    265a:	b095      	sub	sp, #84	; 0x54
  int i = 0;
  if(bool_tele_op_toggel == 2){
    265c:	f000 8444 	beq.w	2ee8 <loop+0x898>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2660:	4ec0      	ldr	r6, [pc, #768]	; (2964 <loop+0x314>)
    previous_time = current_time;
    last_error_right = goal_omega_right - average_omega_right;
    last_error_left = goal_omega_left - average_omega_left;
  }

  if(millis() > time_now + period){
    2662:	4ac1      	ldr	r2, [pc, #772]	; (2968 <loop+0x318>)
    2664:	4bc1      	ldr	r3, [pc, #772]	; (296c <loop+0x31c>)
    2666:	6831      	ldr	r1, [r6, #0]
    2668:	9107      	str	r1, [sp, #28]
    266a:	6810      	ldr	r0, [r2, #0]
    266c:	681b      	ldr	r3, [r3, #0]
	return ret;
    266e:	9907      	ldr	r1, [sp, #28]
    2670:	4403      	add	r3, r0
    2672:	428b      	cmp	r3, r1
    2674:	f0c0 81b2 	bcc.w	29dc <loop+0x38c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2678:	6833      	ldr	r3, [r6, #0]

  virtual int spinOnce() override
  {
    /* restart if timed out */
    uint32_t c_time = hardware_.time();
    if ((c_time - last_sync_receive_time) > (SYNC_SECONDS * 2200))
    267a:	4cbd      	ldr	r4, [pc, #756]	; (2970 <loop+0x320>)
    267c:	9309      	str	r3, [sp, #36]	; 0x24
	return ret;
    267e:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
    2682:	f8d4 3500 	ldr.w	r3, [r4, #1280]	; 0x500
    2686:	f642 22f8 	movw	r2, #11000	; 0x2af8
    268a:	ebc3 030b 	rsb	r3, r3, fp
    268e:	4293      	cmp	r3, r2
    {
      configured_ = false;
    2690:	bf84      	itt	hi
    2692:	2300      	movhi	r3, #0
    2694:	f884 34f8 	strbhi.w	r3, [r4, #1272]	; 0x4f8
    }

    /* reset if message has timed out */
    if (mode_ != MODE_FIRST_FF)
    2698:	f8d4 34e4 	ldr.w	r3, [r4, #1252]	; 0x4e4
    269c:	4ab4      	ldr	r2, [pc, #720]	; (2970 <loop+0x320>)
    269e:	b133      	cbz	r3, 26ae <loop+0x5e>
    {
      if (c_time > last_msg_timeout_time)
    26a0:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
    26a4:	459b      	cmp	fp, r3
      {
        mode_ = MODE_FIRST_FF;
    26a6:	bf84      	itt	hi
    26a8:	2300      	movhi	r3, #0
    26aa:	f8c2 34e4 	strhi.w	r3, [r2, #1252]	; 0x4e4
        }
      }
      int data = hardware_.read();
      if (data < 0)
        break;
      checksum_ += data;
    26ae:	4db0      	ldr	r5, [pc, #704]	; (2970 <loop+0x320>)

    /* while available buffer, read data */
    while (true)
    {
      // If a timeout has been specified, check how long spinOnce has been running.
      if (spin_timeout_ > 0)
    26b0:	69a2      	ldr	r2, [r4, #24]
    26b2:	b132      	cbz	r2, 26c2 <loop+0x72>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    26b4:	6833      	ldr	r3, [r6, #0]
    26b6:	930d      	str	r3, [sp, #52]	; 0x34
	return ret;
    26b8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
      {
        // If the maximum processing timeout has been exceeded, exit with error.
        // The next spinOnce can continue where it left off, or optionally
        // based on the application in use, the hardware buffer could be flushed
        // and start fresh.
        if ((hardware_.time() - c_time) > spin_timeout_)
    26ba:	ebcb 0303 	rsb	r3, fp, r3
    26be:	429a      	cmp	r2, r3
    26c0:	d325      	bcc.n	270e <loop+0xbe>
    26c2:	6860      	ldr	r0, [r4, #4]
    26c4:	4aab      	ldr	r2, [pc, #684]	; (2974 <loop+0x324>)
      delay(3000); 
#endif
      iostream->begin(baud_);
    }

    int read(){return iostream->read();};
    26c6:	6803      	ldr	r3, [r0, #0]
    26c8:	695b      	ldr	r3, [r3, #20]
    26ca:	4293      	cmp	r3, r2
    26cc:	f040 808a 	bne.w	27e4 <loop+0x194>
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    26d0:	f003 fc88 	bl	5fe4 <usb_serial_getchar>
          // Exit the spin, processing timeout exceeded.
          return SPIN_TIMEOUT;
        }
      }
      int data = hardware_.read();
      if (data < 0)
    26d4:	2800      	cmp	r0, #0
    26d6:	f2c0 8089 	blt.w	27ec <loop+0x19c>
        break;
      checksum_ += data;
    26da:	f8d4 34f4 	ldr.w	r3, [r4, #1268]	; 0x4f4
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    26de:	f8d4 24e4 	ldr.w	r2, [r4, #1252]	; 0x4e4
        }
      }
      int data = hardware_.read();
      if (data < 0)
        break;
      checksum_ += data;
    26e2:	f8df e28c 	ldr.w	lr, [pc, #652]	; 2970 <loop+0x320>
    26e6:	4403      	add	r3, r0
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    26e8:	2a07      	cmp	r2, #7
        }
      }
      int data = hardware_.read();
      if (data < 0)
        break;
      checksum_ += data;
    26ea:	f8c4 34f4 	str.w	r3, [r4, #1268]	; 0x4f4
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    26ee:	d066      	beq.n	27be <loop+0x16e>
        message_in[index_++] = data;
        bytes_--;
        if (bytes_ == 0)                 /* is message complete? if so, checksum */
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_FIRST_FF)
    26f0:	b982      	cbnz	r2, 2714 <loop+0xc4>
      {
        if (data == 0xff)
    26f2:	28ff      	cmp	r0, #255	; 0xff
    26f4:	f000 80cc 	beq.w	2890 <loop+0x240>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    26f8:	6833      	ldr	r3, [r6, #0]
    26fa:	930c      	str	r3, [sp, #48]	; 0x30
	return ret;
    26fc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
        {
          mode_++;
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
        }
        else if (hardware_.time() - c_time > (SYNC_SECONDS * 1000))
    26fe:	f241 3188 	movw	r1, #5000	; 0x1388
    2702:	ebcb 0303 	rsb	r3, fp, r3
    2706:	428b      	cmp	r3, r1
    2708:	d9d2      	bls.n	26b0 <loop+0x60>
        {
          /* We have been stuck in spinOnce too long, return error */
          configured_ = false;
    270a:	f88e 24f8 	strb.w	r2, [lr, #1272]	; 0x4f8
    speed_pub.publish(&wheel_speed);
  }
  nh.spinOnce();
  //}
  //delay(100);
  }
    270e:	b015      	add	sp, #84	; 0x54
    2710:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          return SPIN_TIMEOUT;
        }
      }
      else if (mode_ == MODE_PROTOCOL_VER)
    2714:	2a01      	cmp	r2, #1
    2716:	f000 80c3 	beq.w	28a0 <loop+0x250>
          mode_ = MODE_FIRST_FF;
          if (configured_ == false)
            requestSyncTime();  /* send a msg back showing our protocol version */
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
    271a:	2a02      	cmp	r2, #2
    271c:	f000 810a 	beq.w	2934 <loop+0x2e4>
        bytes_ = data;
        index_ = 0;
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
    2720:	2a03      	cmp	r2, #3
    2722:	f000 8112 	beq.w	294a <loop+0x2fa>
      {
        bytes_ += data << 8;
        mode_++;
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
    2726:	2a04      	cmp	r2, #4
    2728:	f000 812e 	beq.w	2988 <loop+0x338>
        if ((checksum_ % 256) == 255)
          mode_++;
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
    272c:	2a05      	cmp	r2, #5
    272e:	f000 813b 	beq.w	29a8 <loop+0x358>
      {
        topic_ = data;
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
    2732:	2a06      	cmp	r2, #6
    2734:	f000 8140 	beq.w	29b8 <loop+0x368>
        topic_ += data << 8;
        mode_ = MODE_MESSAGE;
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
    2738:	2a08      	cmp	r2, #8
    273a:	d1b9      	bne.n	26b0 <loop+0x60>
      {
        mode_ = MODE_FIRST_FF;
        if ((checksum_ % 256) == 255)
    273c:	4a8e      	ldr	r2, [pc, #568]	; (2978 <loop+0x328>)
    273e:	401a      	ands	r2, r3
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
    2740:	2300      	movs	r3, #0
        if ((checksum_ % 256) == 255)
    2742:	429a      	cmp	r2, r3
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
    2744:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
        if ((checksum_ % 256) == 255)
    2748:	f2c0 8429 	blt.w	2f9e <loop+0x94e>
    274c:	2aff      	cmp	r2, #255	; 0xff
    274e:	d1af      	bne.n	26b0 <loop+0x60>
        {
          if (topic_ == TopicInfo::ID_PUBLISHER)
    2750:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
    2754:	f8df 9218 	ldr.w	r9, [pc, #536]	; 2970 <loop+0x320>
    2758:	2b00      	cmp	r3, #0
    275a:	f000 85a2 	beq.w	32a2 <loop+0xc52>
            negotiateTopics();
            last_sync_time = c_time;
            last_sync_receive_time = c_time;
            return SPIN_ERR;
          }
          else if (topic_ == TopicInfo::ID_TIME)
    275e:	2b0a      	cmp	r3, #10
    2760:	f000 842c 	beq.w	2fbc <loop+0x96c>
          {
            syncTime(message_in);
          }
          else if (topic_ == TopicInfo::ID_PARAMETER_REQUEST)
    2764:	2b06      	cmp	r3, #6
    2766:	f000 8483 	beq.w	3070 <loop+0xa20>
          {
            req_param_resp.deserialize(message_in);
            param_received = true;
          }
          else if (topic_ == TopicInfo::ID_TX_STOP)
    276a:	2b0b      	cmp	r3, #11
    276c:	f000 8421 	beq.w	2fb2 <loop+0x962>
          {
            configured_ = false;
          }
          else
          {
            if (subscribers[topic_ - 100])
    2770:	33bc      	adds	r3, #188	; 0xbc
    2772:	f855 0023 	ldr.w	r0, [r5, r3, lsl #2]
    2776:	2800      	cmp	r0, #0
    2778:	d09a      	beq.n	26b0 <loop+0x60>
              subscribers[topic_ - 100]->callback(message_in);
    277a:	6803      	ldr	r3, [r0, #0]
    277c:	4a7f      	ldr	r2, [pc, #508]	; (297c <loop+0x32c>)
    277e:	681b      	ldr	r3, [r3, #0]
    2780:	4293      	cmp	r3, r2
    2782:	f040 877d 	bne.w	3680 <loop+0x1030>
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    2786:	69ea      	ldr	r2, [r5, #28]
    2788:	6a2b      	ldr	r3, [r5, #32]
    278a:	6d81      	ldr	r1, [r0, #88]	; 0x58
      this->x = u_x.real;
    278c:	e9c0 2308 	strd	r2, r3, [r0, #32]
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    2790:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    2792:	6aab      	ldr	r3, [r5, #40]	; 0x28
      this->y = u_y.real;
    2794:	e9c0 230a 	strd	r2, r3, [r0, #40]	; 0x28
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    2798:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    279a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
      this->z = u_z.real;
    279c:	e9c0 230c 	strd	r2, r3, [r0, #48]	; 0x30
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    27a0:	6b6a      	ldr	r2, [r5, #52]	; 0x34
    27a2:	6bab      	ldr	r3, [r5, #56]	; 0x38
      this->x = u_x.real;
    27a4:	e9c0 2310 	strd	r2, r3, [r0, #64]	; 0x40
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    27a8:	6bea      	ldr	r2, [r5, #60]	; 0x3c
    27aa:	6c2b      	ldr	r3, [r5, #64]	; 0x40
      this->y = u_y.real;
    27ac:	e9c0 2312 	strd	r2, r3, [r0, #72]	; 0x48
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    27b0:	6c6a      	ldr	r2, [r5, #68]	; 0x44
    27b2:	6cab      	ldr	r3, [r5, #72]	; 0x48
    27b4:	3010      	adds	r0, #16
      this->z = u_z.real;
    27b6:	e9c0 2310 	strd	r2, r3, [r0, #64]	; 0x40
    27ba:	4788      	blx	r1
    27bc:	e778      	b.n	26b0 <loop+0x60>
      if (data < 0)
        break;
      checksum_ += data;
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
      {
        message_in[index_++] = data;
    27be:	f8d5 24f0 	ldr.w	r2, [r5, #1264]	; 0x4f0
        bytes_--;
    27c2:	f8d5 34e8 	ldr.w	r3, [r5, #1256]	; 0x4e8
      if (data < 0)
        break;
      checksum_ += data;
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
      {
        message_in[index_++] = data;
    27c6:	18a9      	adds	r1, r5, r2
        bytes_--;
    27c8:	3b01      	subs	r3, #1
      if (data < 0)
        break;
      checksum_ += data;
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
      {
        message_in[index_++] = data;
    27ca:	3201      	adds	r2, #1
    27cc:	7708      	strb	r0, [r1, #28]
    27ce:	f8c5 24f0 	str.w	r2, [r5, #1264]	; 0x4f0
        bytes_--;
    27d2:	f8c5 34e8 	str.w	r3, [r5, #1256]	; 0x4e8
        if (bytes_ == 0)                 /* is message complete? if so, checksum */
    27d6:	2b00      	cmp	r3, #0
    27d8:	f47f af6a 	bne.w	26b0 <loop+0x60>
          mode_ = MODE_MSG_CHECKSUM;
    27dc:	2308      	movs	r3, #8
    27de:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    27e2:	e765      	b.n	26b0 <loop+0x60>
    27e4:	4798      	blx	r3
          // Exit the spin, processing timeout exceeded.
          return SPIN_TIMEOUT;
        }
      }
      int data = hardware_.read();
      if (data < 0)
    27e6:	2800      	cmp	r0, #0
    27e8:	f6bf af77 	bge.w	26da <loop+0x8a>
        }
      }
    }

    /* occasionally sync time */
    if (configured_ && ((c_time - last_sync_time) > (SYNC_SECONDS * 500)))
    27ec:	f894 34f8 	ldrb.w	r3, [r4, #1272]	; 0x4f8
    27f0:	485f      	ldr	r0, [pc, #380]	; (2970 <loop+0x320>)
    27f2:	2b00      	cmp	r3, #0
    27f4:	d08b      	beq.n	270e <loop+0xbe>
    27f6:	f8d0 34fc 	ldr.w	r3, [r0, #1276]	; 0x4fc
    27fa:	f640 12c4 	movw	r2, #2500	; 0x9c4
    27fe:	ebc3 030b 	rsb	r3, r3, fp
    2802:	4293      	cmp	r3, r2
    2804:	d983      	bls.n	270e <loop+0xbe>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    2806:	23ff      	movs	r3, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    2808:	21fe      	movs	r1, #254	; 0xfe
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->data.sec >> (8 * 0)) & 0xFF;
    280a:	2200      	movs	r2, #0

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    280c:	f880 321c 	strb.w	r3, [r0, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    2810:	f880 121d 	strb.w	r1, [r0, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    2814:	23f7      	movs	r3, #247	; 0xf7
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    2816:	2508      	movs	r5, #8
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    2818:	210a      	movs	r1, #10
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    281a:	f880 3220 	strb.w	r3, [r0, #544]	; 0x220
    281e:	f880 2223 	strb.w	r2, [r0, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->data.sec >> (8 * 1)) & 0xFF;
    2822:	f880 2224 	strb.w	r2, [r0, #548]	; 0x224
      *(outbuffer + offset + 2) = (this->data.sec >> (8 * 2)) & 0xFF;
    2826:	f880 2225 	strb.w	r2, [r0, #549]	; 0x225
      *(outbuffer + offset + 3) = (this->data.sec >> (8 * 3)) & 0xFF;
    282a:	f880 2226 	strb.w	r2, [r0, #550]	; 0x226
      offset += sizeof(this->data.sec);
      *(outbuffer + offset + 0) = (this->data.nsec >> (8 * 0)) & 0xFF;
    282e:	f880 2227 	strb.w	r2, [r0, #551]	; 0x227
      *(outbuffer + offset + 1) = (this->data.nsec >> (8 * 1)) & 0xFF;
    2832:	f880 2228 	strb.w	r2, [r0, #552]	; 0x228
      *(outbuffer + offset + 2) = (this->data.nsec >> (8 * 2)) & 0xFF;
    2836:	f880 2229 	strb.w	r2, [r0, #553]	; 0x229
      *(outbuffer + offset + 3) = (this->data.nsec >> (8 * 3)) & 0xFF;
    283a:	f880 222a 	strb.w	r2, [r0, #554]	; 0x22a

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    283e:	f880 221f 	strb.w	r2, [r0, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    2842:	f880 2222 	strb.w	r2, [r0, #546]	; 0x222
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    2846:	f880 521e 	strb.w	r5, [r0, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    284a:	f880 1221 	strb.w	r1, [r0, #545]	; 0x221
    284e:	f200 2321 	addw	r3, r0, #545	; 0x221
    2852:	f200 202a 	addw	r0, r0, #554	; 0x22a
    2856:	e001      	b.n	285c <loop+0x20c>
    2858:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    285c:	4283      	cmp	r3, r0
      chk += message_out[i];
    285e:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    2860:	d1fa      	bne.n	2858 <loop+0x208>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    2862:	43d2      	mvns	r2, r2
    2864:	6860      	ldr	r0, [r4, #4]
    2866:	f884 222b 	strb.w	r2, [r4, #555]	; 0x22b
    void write(uint8_t* data, int length){
      iostream->write(data, length);
    286a:	6803      	ldr	r3, [r0, #0]
    286c:	4a44      	ldr	r2, [pc, #272]	; (2980 <loop+0x330>)
    286e:	685b      	ldr	r3, [r3, #4]
    2870:	4293      	cmp	r3, r2
    2872:	f040 839a 	bne.w	2faa <loop+0x95a>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    2876:	2110      	movs	r1, #16
    2878:	4842      	ldr	r0, [pc, #264]	; (2984 <loop+0x334>)
    287a:	f003 fc19 	bl	60b0 <usb_serial_write>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    287e:	6833      	ldr	r3, [r6, #0]
    2880:	9311      	str	r3, [sp, #68]	; 0x44
	return ret;
    2882:	9b11      	ldr	r3, [sp, #68]	; 0x44

    /* occasionally sync time */
    if (configured_ && ((c_time - last_sync_time) > (SYNC_SECONDS * 500)))
    {
      requestSyncTime();
      last_sync_time = c_time;
    2884:	f8c4 b4fc 	str.w	fp, [r4, #1276]	; 0x4fc

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    rt_time = hardware_.time();
    2888:	60e3      	str	r3, [r4, #12]
    288a:	b015      	add	sp, #84	; 0x54
    288c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      }
      else if (mode_ == MODE_FIRST_FF)
      {
        if (data == 0xff)
        {
          mode_++;
    2890:	2201      	movs	r2, #1
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
    2892:	f10b 0314 	add.w	r3, fp, #20
      }
      else if (mode_ == MODE_FIRST_FF)
      {
        if (data == 0xff)
        {
          mode_++;
    2896:	f8c5 24e4 	str.w	r2, [r5, #1252]	; 0x4e4
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
    289a:	f8c5 3504 	str.w	r3, [r5, #1284]	; 0x504
    289e:	e707      	b.n	26b0 <loop+0x60>
          return SPIN_TIMEOUT;
        }
      }
      else if (mode_ == MODE_PROTOCOL_VER)
      {
        if (data == PROTOCOL_VER)
    28a0:	28fe      	cmp	r0, #254	; 0xfe
    28a2:	d07d      	beq.n	29a0 <loop+0x350>
          mode_++;
        }
        else
        {
          mode_ = MODE_FIRST_FF;
          if (configured_ == false)
    28a4:	f895 24f8 	ldrb.w	r2, [r5, #1272]	; 0x4f8
        {
          mode_++;
        }
        else
        {
          mode_ = MODE_FIRST_FF;
    28a8:	2300      	movs	r3, #0
    28aa:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
          if (configured_ == false)
    28ae:	2a00      	cmp	r2, #0
    28b0:	f47f aefe 	bne.w	26b0 <loop+0x60>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    28b4:	23ff      	movs	r3, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    28b6:	21fe      	movs	r1, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    28b8:	2008      	movs	r0, #8

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    28ba:	f885 321c 	strb.w	r3, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    28be:	f885 121d 	strb.w	r1, [r5, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    28c2:	23f7      	movs	r3, #247	; 0xf7
    message_out[5] = (uint8_t)((int16_t)id & 255);
    28c4:	210a      	movs	r1, #10
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    28c6:	f885 3220 	strb.w	r3, [r5, #544]	; 0x220
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->data.sec >> (8 * 0)) & 0xFF;
    28ca:	f885 2223 	strb.w	r2, [r5, #547]	; 0x223
    28ce:	f20e 2321 	addw	r3, lr, #545	; 0x221
      *(outbuffer + offset + 1) = (this->data.sec >> (8 * 1)) & 0xFF;
    28d2:	f885 2224 	strb.w	r2, [r5, #548]	; 0x224
      *(outbuffer + offset + 2) = (this->data.sec >> (8 * 2)) & 0xFF;
    28d6:	f885 2225 	strb.w	r2, [r5, #549]	; 0x225
      *(outbuffer + offset + 3) = (this->data.sec >> (8 * 3)) & 0xFF;
    28da:	f885 2226 	strb.w	r2, [r5, #550]	; 0x226
      offset += sizeof(this->data.sec);
      *(outbuffer + offset + 0) = (this->data.nsec >> (8 * 0)) & 0xFF;
    28de:	f885 2227 	strb.w	r2, [r5, #551]	; 0x227
      *(outbuffer + offset + 1) = (this->data.nsec >> (8 * 1)) & 0xFF;
    28e2:	f885 2228 	strb.w	r2, [r5, #552]	; 0x228
      *(outbuffer + offset + 2) = (this->data.nsec >> (8 * 2)) & 0xFF;
    28e6:	f885 2229 	strb.w	r2, [r5, #553]	; 0x229
      *(outbuffer + offset + 3) = (this->data.nsec >> (8 * 3)) & 0xFF;
    28ea:	f885 222a 	strb.w	r2, [r5, #554]	; 0x22a

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    28ee:	f885 221f 	strb.w	r2, [r5, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    28f2:	f885 2222 	strb.w	r2, [r5, #546]	; 0x222
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    28f6:	f885 021e 	strb.w	r0, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    28fa:	f885 1221 	strb.w	r1, [r5, #545]	; 0x221
    28fe:	f20e 2e2a 	addw	lr, lr, #554	; 0x22a
    2902:	e001      	b.n	2908 <loop+0x2b8>
    2904:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    2908:	459e      	cmp	lr, r3
      chk += message_out[i];
    290a:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    290c:	d1fa      	bne.n	2904 <loop+0x2b4>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    290e:	43d2      	mvns	r2, r2
    2910:	6860      	ldr	r0, [r4, #4]
    2912:	f884 222b 	strb.w	r2, [r4, #555]	; 0x22b
    2916:	6803      	ldr	r3, [r0, #0]
    2918:	4a19      	ldr	r2, [pc, #100]	; (2980 <loop+0x330>)
    291a:	685b      	ldr	r3, [r3, #4]
    291c:	4293      	cmp	r3, r2
    291e:	f040 82d1 	bne.w	2ec4 <loop+0x874>
    2922:	2110      	movs	r1, #16
    2924:	4817      	ldr	r0, [pc, #92]	; (2984 <loop+0x334>)
    2926:	f003 fbc3 	bl	60b0 <usb_serial_write>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    292a:	6833      	ldr	r3, [r6, #0]
    292c:	930b      	str	r3, [sp, #44]	; 0x2c
	return ret;
    292e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    rt_time = hardware_.time();
    2930:	60e3      	str	r3, [r4, #12]
    2932:	e6bd      	b.n	26b0 <loop+0x60>
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
        index_ = 0;
    2934:	2200      	movs	r2, #0
        mode_++;
    2936:	2303      	movs	r3, #3
            requestSyncTime();  /* send a msg back showing our protocol version */
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
    2938:	f8c5 04e8 	str.w	r0, [r5, #1256]	; 0x4e8
        index_ = 0;
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
    293c:	f8c5 04f4 	str.w	r0, [r5, #1268]	; 0x4f4
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
        index_ = 0;
    2940:	f8c5 24f0 	str.w	r2, [r5, #1264]	; 0x4f0
        mode_++;
    2944:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
    2948:	e6b2      	b.n	26b0 <loop+0x60>
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
      {
        bytes_ += data << 8;
    294a:	f8d5 34e8 	ldr.w	r3, [r5, #1256]	; 0x4e8
    294e:	eb03 2000 	add.w	r0, r3, r0, lsl #8
        mode_++;
    2952:	2304      	movs	r3, #4
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
      {
        bytes_ += data << 8;
    2954:	f8c5 04e8 	str.w	r0, [r5, #1256]	; 0x4e8
        mode_++;
    2958:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
    295c:	e6a8      	b.n	26b0 <loop+0x60>
    295e:	bf00      	nop
    2960:	1fff1ca0 	.word	0x1fff1ca0
    2964:	1fff2ba4 	.word	0x1fff2ba4
    2968:	1fff2b60 	.word	0x1fff2b60
    296c:	1fff080c 	.word	0x1fff080c
    2970:	1fff1d58 	.word	0x1fff1d58
    2974:	00000eb1 	.word	0x00000eb1
    2978:	800000ff 	.word	0x800000ff
    297c:	0000138d 	.word	0x0000138d
    2980:	00000ea9 	.word	0x00000ea9
    2984:	1fff1f74 	.word	0x1fff1f74
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
      {
        if ((checksum_ % 256) == 255)
    2988:	4a13      	ldr	r2, [pc, #76]	; (29d8 <loop+0x388>)
    298a:	401a      	ands	r2, r3
    298c:	2a00      	cmp	r2, #0
    298e:	f2c0 82a6 	blt.w	2ede <loop+0x88e>
    2992:	2aff      	cmp	r2, #255	; 0xff
          mode_++;
    2994:	bf0c      	ite	eq
    2996:	2305      	moveq	r3, #5
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
    2998:	2300      	movne	r3, #0
    299a:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    299e:	e687      	b.n	26b0 <loop+0x60>
      }
      else if (mode_ == MODE_PROTOCOL_VER)
      {
        if (data == PROTOCOL_VER)
        {
          mode_++;
    29a0:	2302      	movs	r3, #2
    29a2:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
    29a6:	e683      	b.n	26b0 <loop+0x60>
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
        mode_++;
    29a8:	2306      	movs	r3, #6
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
    29aa:	f8c5 04ec 	str.w	r0, [r5, #1260]	; 0x4ec
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
    29ae:	f8c5 04f4 	str.w	r0, [r5, #1268]	; 0x4f4
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
        mode_++;
    29b2:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
    29b6:	e67b      	b.n	26b0 <loop+0x60>
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    29b8:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
        mode_ = MODE_MESSAGE;
        if (bytes_ == 0)
    29bc:	f8d5 24e8 	ldr.w	r2, [r5, #1256]	; 0x4e8
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    29c0:	eb03 2300 	add.w	r3, r3, r0, lsl #8
        mode_ = MODE_MESSAGE;
    29c4:	2107      	movs	r1, #7
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    29c6:	f8c5 34ec 	str.w	r3, [r5, #1260]	; 0x4ec
        mode_ = MODE_MESSAGE;
    29ca:	f8c5 14e4 	str.w	r1, [r5, #1252]	; 0x4e4
        if (bytes_ == 0)
    29ce:	2a00      	cmp	r2, #0
    29d0:	f43f af04 	beq.w	27dc <loop+0x18c>
    29d4:	e66c      	b.n	26b0 <loop+0x60>
    29d6:	bf00      	nop
    29d8:	800000ff 	.word	0x800000ff
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    29dc:	6833      	ldr	r3, [r6, #0]

    /*wheel_speed.x = average_omega_right;
    wheel_speed.y = average_omega_left;
    wheel_speed.z = temp_input_vel;
    wheel_speed.w = goal_vel_x;*/
    wheel_speed.x = average_omega_right;
    29de:	49d0      	ldr	r1, [pc, #832]	; (2d20 <loop+0x6d0>)
    29e0:	9308      	str	r3, [sp, #32]
	return ret;
    29e2:	9b08      	ldr	r3, [sp, #32]
    last_error_right = goal_omega_right - average_omega_right;
    last_error_left = goal_omega_left - average_omega_left;
  }

  if(millis() > time_now + period){
    time_now = millis();
    29e4:	6013      	str	r3, [r2, #0]

    /*wheel_speed.x = average_omega_right;
    wheel_speed.y = average_omega_left;
    wheel_speed.z = temp_input_vel;
    wheel_speed.w = goal_vel_x;*/
    wheel_speed.x = average_omega_right;
    29e6:	6808      	ldr	r0, [r1, #0]
    29e8:	4dce      	ldr	r5, [pc, #824]	; (2d24 <loop+0x6d4>)
    wheel_speed.y = average_omega_left;
    wheel_speed.z = error_r;
    29ea:	f8df 834c 	ldr.w	r8, [pc, #844]	; 2d38 <loop+0x6e8>
    29ee:	4cce      	ldr	r4, [pc, #824]	; (2d28 <loop+0x6d8>)

    /*wheel_speed.x = average_omega_right;
    wheel_speed.y = average_omega_left;
    wheel_speed.z = temp_input_vel;
    wheel_speed.w = goal_vel_x;*/
    wheel_speed.x = average_omega_right;
    29f0:	f005 f936 	bl	7c60 <__aeabi_f2d>
    wheel_speed.y = average_omega_left;
    29f4:	4bcd      	ldr	r3, [pc, #820]	; (2d2c <loop+0x6dc>)

    /*wheel_speed.x = average_omega_right;
    wheel_speed.y = average_omega_left;
    wheel_speed.z = temp_input_vel;
    wheel_speed.w = goal_vel_x;*/
    wheel_speed.x = average_omega_right;
    29f6:	e9c5 0102 	strd	r0, r1, [r5, #8]
    wheel_speed.y = average_omega_left;
    29fa:	6818      	ldr	r0, [r3, #0]
    29fc:	f005 f930 	bl	7c60 <__aeabi_f2d>
    2a00:	4acb      	ldr	r2, [pc, #812]	; (2d30 <loop+0x6e0>)
    wheel_speed.z = error_r;
    wheel_speed.w = cum_error_r;
    2a02:	f8df c338 	ldr.w	ip, [pc, #824]	; 2d3c <loop+0x6ec>
    2a06:	68d7      	ldr	r7, [r2, #12]
    2a08:	f8d2 e008 	ldr.w	lr, [r2, #8]
    msg_(msg),
    endpoint_(endpoint) {};

  int publish(const Msg * msg)
  {
    return nh_->publish(id_, msg);
    2a0c:	683b      	ldr	r3, [r7, #0]
    2a0e:	681b      	ldr	r3, [r3, #0]
    /*wheel_speed.x = average_omega_right;
    wheel_speed.y = average_omega_left;
    wheel_speed.z = temp_input_vel;
    wheel_speed.w = goal_vel_x;*/
    wheel_speed.x = average_omega_right;
    wheel_speed.y = average_omega_left;
    2a10:	e9c5 0104 	strd	r0, r1, [r5, #16]
    wheel_speed.z = error_r;
    2a14:	e9d8 0100 	ldrd	r0, r1, [r8]
    2a18:	e9c5 0106 	strd	r0, r1, [r5, #24]
    wheel_speed.w = cum_error_r;
    2a1c:	e9dc 0100 	ldrd	r0, r1, [ip]
    2a20:	42a3      	cmp	r3, r4
    2a22:	e9c5 0108 	strd	r0, r1, [r5, #32]
    2a26:	f040 82b5 	bne.w	2f94 <loop+0x944>
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    2a2a:	f1be 0f63 	cmp.w	lr, #99	; 0x63
    2a2e:	dd04      	ble.n	2a3a <loop+0x3ea>
    2a30:	f897 34f8 	ldrb.w	r3, [r7, #1272]	; 0x4f8
    2a34:	2b00      	cmp	r3, #0
    2a36:	f000 8198 	beq.w	2d6a <loop+0x71a>
      int offset = 0;
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
    2a3a:	4bbe      	ldr	r3, [pc, #760]	; (2d34 <loop+0x6e4>)
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    2a3c:	f8d3 8010 	ldr.w	r8, [r3, #16]
    2a40:	f8d3 c014 	ldr.w	ip, [r3, #20]
    2a44:	f887 8223 	strb.w	r8, [r7, #547]	; 0x223
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    2a48:	f103 0018 	add.w	r0, r3, #24
    2a4c:	c807      	ldmia	r0, {r0, r1, r2}
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
    2a4e:	ea4f 2918 	mov.w	r9, r8, lsr #8
    2a52:	f887 9224 	strb.w	r9, [r7, #548]	; 0x224
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    2a56:	ea4f 4918 	mov.w	r9, r8, lsr #16
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    2a5a:	ea4f 6818 	mov.w	r8, r8, lsr #24
    2a5e:	f887 8226 	strb.w	r8, [r7, #550]	; 0x226
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    2a62:	ea4f 281c 	mov.w	r8, ip, lsr #8
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
    2a66:	f887 c227 	strb.w	ip, [r7, #551]	; 0x227
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    2a6a:	f887 8228 	strb.w	r8, [r7, #552]	; 0x228
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    2a6e:	ea4f 481c 	mov.w	r8, ip, lsr #16
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    2a72:	ea4f 6c1c 	mov.w	ip, ip, lsr #24
    2a76:	f887 c22a 	strb.w	ip, [r7, #554]	; 0x22a
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    2a7a:	ea4f 2c10 	mov.w	ip, r0, lsr #8
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    2a7e:	f887 022b 	strb.w	r0, [r7, #555]	; 0x22b
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    2a82:	f887 c22c 	strb.w	ip, [r7, #556]	; 0x22c
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    2a86:	ea4f 4c10 	mov.w	ip, r0, lsr #16
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    2a8a:	0e00      	lsrs	r0, r0, #24
    2a8c:	f887 022e 	strb.w	r0, [r7, #558]	; 0x22e
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    2a90:	0a08      	lsrs	r0, r1, #8
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    2a92:	f887 8229 	strb.w	r8, [r7, #553]	; 0x229
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
    2a96:	f887 122f 	strb.w	r1, [r7, #559]	; 0x22f
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    2a9a:	f8d3 8024 	ldr.w	r8, [r3, #36]	; 0x24
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    2a9e:	f887 0230 	strb.w	r0, [r7, #560]	; 0x230
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    2aa2:	0c08      	lsrs	r0, r1, #16
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    2aa4:	0e09      	lsrs	r1, r1, #24
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    2aa6:	f887 0231 	strb.w	r0, [r7, #561]	; 0x231
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    2aaa:	f887 1232 	strb.w	r1, [r7, #562]	; 0x232
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    2aae:	0a10      	lsrs	r0, r2, #8
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    2ab0:	0c11      	lsrs	r1, r2, #16
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    2ab2:	f887 2233 	strb.w	r2, [r7, #563]	; 0x233
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    2ab6:	0e12      	lsrs	r2, r2, #24
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    2ab8:	f887 0234 	strb.w	r0, [r7, #564]	; 0x234
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    2abc:	f887 1235 	strb.w	r1, [r7, #565]	; 0x235
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    2ac0:	ea4f 2018 	mov.w	r0, r8, lsr #8
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    2ac4:	ea4f 4118 	mov.w	r1, r8, lsr #16
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    2ac8:	f887 2236 	strb.w	r2, [r7, #566]	; 0x236
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
    2acc:	f887 8237 	strb.w	r8, [r7, #567]	; 0x237
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    2ad0:	ea4f 6218 	mov.w	r2, r8, lsr #24
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    2ad4:	f8d3 8030 	ldr.w	r8, [r3, #48]	; 0x30
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    2ad8:	f887 9225 	strb.w	r9, [r7, #549]	; 0x225
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    2adc:	f887 223a 	strb.w	r2, [r7, #570]	; 0x23a
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
    2ae0:	ea4f 2918 	mov.w	r9, r8, lsr #8
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    2ae4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    2ae6:	f887 c22d 	strb.w	ip, [r7, #557]	; 0x22d
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    2aea:	f887 0238 	strb.w	r0, [r7, #568]	; 0x238
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    2aee:	f887 1239 	strb.w	r1, [r7, #569]	; 0x239
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    2af2:	f887 823b 	strb.w	r8, [r7, #571]	; 0x23b
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
    2af6:	f887 923c 	strb.w	r9, [r7, #572]	; 0x23c
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    2afa:	ea4f 4918 	mov.w	r9, r8, lsr #16
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    2afe:	ea4f 6818 	mov.w	r8, r8, lsr #24
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    2b02:	f8d3 c038 	ldr.w	ip, [r3, #56]	; 0x38
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    2b06:	f887 823e 	strb.w	r8, [r7, #574]	; 0x23e
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    2b0a:	ea4f 2812 	mov.w	r8, r2, lsr #8
    2b0e:	f887 8240 	strb.w	r8, [r7, #576]	; 0x240
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    2b12:	ea4f 6812 	mov.w	r8, r2, lsr #24
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    2b16:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    2b18:	f887 8242 	strb.w	r8, [r7, #578]	; 0x242
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    2b1c:	ea4f 281c 	mov.w	r8, ip, lsr #8
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    2b20:	f887 c243 	strb.w	ip, [r7, #579]	; 0x243
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    2b24:	f887 8244 	strb.w	r8, [r7, #580]	; 0x244
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    2b28:	ea4f 481c 	mov.w	r8, ip, lsr #16
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    2b2c:	ea4f 6c1c 	mov.w	ip, ip, lsr #24
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    2b30:	6c19      	ldr	r1, [r3, #64]	; 0x40
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    2b32:	f887 c246 	strb.w	ip, [r7, #582]	; 0x246
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    2b36:	ea4f 2c10 	mov.w	ip, r0, lsr #8
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
    2b3a:	f887 0247 	strb.w	r0, [r7, #583]	; 0x247
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    2b3e:	f887 c248 	strb.w	ip, [r7, #584]	; 0x248
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    2b42:	ea4f 4c10 	mov.w	ip, r0, lsr #16
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    2b46:	0e00      	lsrs	r0, r0, #24
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
    2b48:	f887 223f 	strb.w	r2, [r7, #575]	; 0x23f
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    2b4c:	f887 923d 	strb.w	r9, [r7, #573]	; 0x23d
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    2b50:	f887 024a 	strb.w	r0, [r7, #586]	; 0x24a
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    2b54:	ea4f 4912 	mov.w	r9, r2, lsr #16
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    2b58:	0a08      	lsrs	r0, r1, #8
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    2b5a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    2b5c:	f887 8245 	strb.w	r8, [r7, #581]	; 0x245
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    2b60:	f887 124b 	strb.w	r1, [r7, #587]	; 0x24b
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    2b64:	f8d3 8050 	ldr.w	r8, [r3, #80]	; 0x50
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    2b68:	f887 024c 	strb.w	r0, [r7, #588]	; 0x24c
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    2b6c:	0c08      	lsrs	r0, r1, #16
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    2b6e:	0e09      	lsrs	r1, r1, #24
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    2b70:	f887 024d 	strb.w	r0, [r7, #589]	; 0x24d
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    2b74:	f887 124e 	strb.w	r1, [r7, #590]	; 0x24e
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    2b78:	0a10      	lsrs	r0, r2, #8
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    2b7a:	0c11      	lsrs	r1, r2, #16
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
    2b7c:	f887 224f 	strb.w	r2, [r7, #591]	; 0x24f
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    2b80:	0e12      	lsrs	r2, r2, #24
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    2b82:	f887 0250 	strb.w	r0, [r7, #592]	; 0x250
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    2b86:	f887 1251 	strb.w	r1, [r7, #593]	; 0x251
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
    2b8a:	ea4f 2018 	mov.w	r0, r8, lsr #8
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    2b8e:	ea4f 4118 	mov.w	r1, r8, lsr #16
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    2b92:	f887 2252 	strb.w	r2, [r7, #594]	; 0x252
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    2b96:	f887 8253 	strb.w	r8, [r7, #595]	; 0x253
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    2b9a:	ea4f 6218 	mov.w	r2, r8, lsr #24
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    2b9e:	f8d3 8054 	ldr.w	r8, [r3, #84]	; 0x54
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    2ba2:	f887 9241 	strb.w	r9, [r7, #577]	; 0x241
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    2ba6:	f887 c249 	strb.w	ip, [r7, #585]	; 0x249
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    2baa:	ea4f 2918 	mov.w	r9, r8, lsr #8
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
    2bae:	f887 0254 	strb.w	r0, [r7, #596]	; 0x254
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    2bb2:	f887 1255 	strb.w	r1, [r7, #597]	; 0x255
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    2bb6:	f887 2256 	strb.w	r2, [r7, #598]	; 0x256
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    2bba:	6d9a      	ldr	r2, [r3, #88]	; 0x58
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
    2bbc:	f887 8257 	strb.w	r8, [r7, #599]	; 0x257
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    2bc0:	f887 9258 	strb.w	r9, [r7, #600]	; 0x258
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    2bc4:	ea4f 4918 	mov.w	r9, r8, lsr #16
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    2bc8:	ea4f 6818 	mov.w	r8, r8, lsr #24
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    2bcc:	6dd8      	ldr	r0, [r3, #92]	; 0x5c
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    2bce:	f887 825a 	strb.w	r8, [r7, #602]	; 0x25a
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    2bd2:	ea4f 2812 	mov.w	r8, r2, lsr #8
    2bd6:	f887 825c 	strb.w	r8, [r7, #604]	; 0x25c
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    2bda:	ea4f 6812 	mov.w	r8, r2, lsr #24
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    2bde:	f8d3 c060 	ldr.w	ip, [r3, #96]	; 0x60
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    2be2:	f887 825e 	strb.w	r8, [r7, #606]	; 0x25e
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    2be6:	ea4f 2810 	mov.w	r8, r0, lsr #8
    2bea:	f887 8260 	strb.w	r8, [r7, #608]	; 0x260
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    2bee:	ea4f 6810 	mov.w	r8, r0, lsr #24
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    2bf2:	6e59      	ldr	r1, [r3, #100]	; 0x64
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    2bf4:	f887 8262 	strb.w	r8, [r7, #610]	; 0x262
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    2bf8:	ea4f 281c 	mov.w	r8, ip, lsr #8
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    2bfc:	f887 c263 	strb.w	ip, [r7, #611]	; 0x263
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    2c00:	f887 8264 	strb.w	r8, [r7, #612]	; 0x264
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    2c04:	ea4f 481c 	mov.w	r8, ip, lsr #16
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    2c08:	ea4f 6c1c 	mov.w	ip, ip, lsr #24
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    2c0c:	f887 9259 	strb.w	r9, [r7, #601]	; 0x259
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    2c10:	f887 225b 	strb.w	r2, [r7, #603]	; 0x25b
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    2c14:	ea4f 4912 	mov.w	r9, r2, lsr #16
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    2c18:	f887 c266 	strb.w	ip, [r7, #614]	; 0x266
      union {
        double real;
        uint64_t base;
      } u_omega_right;
      u_omega_right.real = this->omega_right;
      *(outbuffer + offset + 0) = (u_omega_right.base >> (8 * 0)) & 0xFF;
    2c1c:	6e9a      	ldr	r2, [r3, #104]	; 0x68
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    2c1e:	f887 925d 	strb.w	r9, [r7, #605]	; 0x25d
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    2c22:	ea4f 2c11 	mov.w	ip, r1, lsr #8
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    2c26:	ea4f 4910 	mov.w	r9, r0, lsr #16
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
    2c2a:	f887 025f 	strb.w	r0, [r7, #607]	; 0x25f
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
    2c2e:	f887 1267 	strb.w	r1, [r7, #615]	; 0x267
    2c32:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    2c34:	f887 c268 	strb.w	ip, [r7, #616]	; 0x268
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    2c38:	ea4f 4c11 	mov.w	ip, r1, lsr #16
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    2c3c:	0e09      	lsrs	r1, r1, #24
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    2c3e:	f887 c269 	strb.w	ip, [r7, #617]	; 0x269
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    2c42:	f887 126a 	strb.w	r1, [r7, #618]	; 0x26a
      *(outbuffer + offset + 1) = (u_omega_right.base >> (8 * 1)) & 0xFF;
    2c46:	ea4f 2c12 	mov.w	ip, r2, lsr #8
      *(outbuffer + offset + 2) = (u_omega_right.base >> (8 * 2)) & 0xFF;
    2c4a:	0c11      	lsrs	r1, r2, #16
      union {
        double real;
        uint64_t base;
      } u_omega_right;
      u_omega_right.real = this->omega_right;
      *(outbuffer + offset + 0) = (u_omega_right.base >> (8 * 0)) & 0xFF;
    2c4c:	f887 226b 	strb.w	r2, [r7, #619]	; 0x26b
      *(outbuffer + offset + 1) = (u_omega_right.base >> (8 * 1)) & 0xFF;
    2c50:	f887 c26c 	strb.w	ip, [r7, #620]	; 0x26c
      *(outbuffer + offset + 2) = (u_omega_right.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_omega_right.base >> (8 * 3)) & 0xFF;
    2c54:	0e12      	lsrs	r2, r2, #24
      *(outbuffer + offset + 4) = (u_omega_right.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_right.base >> (8 * 5)) & 0xFF;
    2c56:	ea4f 2c10 	mov.w	ip, r0, lsr #8
        uint64_t base;
      } u_omega_right;
      u_omega_right.real = this->omega_right;
      *(outbuffer + offset + 0) = (u_omega_right.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_right.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_omega_right.base >> (8 * 2)) & 0xFF;
    2c5a:	f887 126d 	strb.w	r1, [r7, #621]	; 0x26d
      *(outbuffer + offset + 3) = (u_omega_right.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_omega_right.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_right.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_omega_right.base >> (8 * 6)) & 0xFF;
    2c5e:	0c01      	lsrs	r1, r0, #16
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    2c60:	f887 9261 	strb.w	r9, [r7, #609]	; 0x261
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    2c64:	f887 8265 	strb.w	r8, [r7, #613]	; 0x265
      } u_omega_right;
      u_omega_right.real = this->omega_right;
      *(outbuffer + offset + 0) = (u_omega_right.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_right.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_omega_right.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_omega_right.base >> (8 * 3)) & 0xFF;
    2c68:	f887 226e 	strb.w	r2, [r7, #622]	; 0x26e
      *(outbuffer + offset + 4) = (u_omega_right.base >> (8 * 4)) & 0xFF;
    2c6c:	f887 026f 	strb.w	r0, [r7, #623]	; 0x26f
      *(outbuffer + offset + 5) = (u_omega_right.base >> (8 * 5)) & 0xFF;
    2c70:	f887 c270 	strb.w	ip, [r7, #624]	; 0x270
      *(outbuffer + offset + 6) = (u_omega_right.base >> (8 * 6)) & 0xFF;
    2c74:	f887 1271 	strb.w	r1, [r7, #625]	; 0x271
      union {
        double real;
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
    2c78:	f103 0170 	add.w	r1, r3, #112	; 0x70
    2c7c:	e891 1006 	ldmia.w	r1, {r1, r2, ip}
      *(outbuffer + offset + 2) = (u_omega_right.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_omega_right.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_omega_right.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_right.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_omega_right.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_omega_right.base >> (8 * 7)) & 0xFF;
    2c80:	0e00      	lsrs	r0, r0, #24
    2c82:	f887 0272 	strb.w	r0, [r7, #626]	; 0x272
        double real;
        uint64_t base;
      } u_omega_left;
      u_omega_left.real = this->omega_left;
      *(outbuffer + offset + 0) = (u_omega_left.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_left.base >> (8 * 1)) & 0xFF;
    2c86:	0a08      	lsrs	r0, r1, #8
      union {
        double real;
        uint64_t base;
      } u_omega_left;
      u_omega_left.real = this->omega_left;
      *(outbuffer + offset + 0) = (u_omega_left.base >> (8 * 0)) & 0xFF;
    2c88:	f887 1273 	strb.w	r1, [r7, #627]	; 0x273
      *(outbuffer + offset + 1) = (u_omega_left.base >> (8 * 1)) & 0xFF;
    2c8c:	f887 0274 	strb.w	r0, [r7, #628]	; 0x274
      *(outbuffer + offset + 2) = (u_omega_left.base >> (8 * 2)) & 0xFF;
    2c90:	0c08      	lsrs	r0, r1, #16
      *(outbuffer + offset + 3) = (u_omega_left.base >> (8 * 3)) & 0xFF;
    2c92:	0e09      	lsrs	r1, r1, #24
      union {
        double real;
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
    2c94:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
      } u_omega_left;
      u_omega_left.real = this->omega_left;
      *(outbuffer + offset + 0) = (u_omega_left.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_left.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_omega_left.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_omega_left.base >> (8 * 3)) & 0xFF;
    2c96:	f887 1276 	strb.w	r1, [r7, #630]	; 0x276
      *(outbuffer + offset + 4) = (u_omega_left.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_left.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_omega_left.base >> (8 * 6)) & 0xFF;
    2c9a:	0c11      	lsrs	r1, r2, #16
        uint64_t base;
      } u_omega_left;
      u_omega_left.real = this->omega_left;
      *(outbuffer + offset + 0) = (u_omega_left.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_left.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_omega_left.base >> (8 * 2)) & 0xFF;
    2c9c:	f887 0275 	strb.w	r0, [r7, #629]	; 0x275
      *(outbuffer + offset + 3) = (u_omega_left.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_omega_left.base >> (8 * 4)) & 0xFF;
    2ca0:	f887 2277 	strb.w	r2, [r7, #631]	; 0x277
      *(outbuffer + offset + 5) = (u_omega_left.base >> (8 * 5)) & 0xFF;
    2ca4:	0a10      	lsrs	r0, r2, #8
      *(outbuffer + offset + 6) = (u_omega_left.base >> (8 * 6)) & 0xFF;
    2ca6:	f887 1279 	strb.w	r1, [r7, #633]	; 0x279
      *(outbuffer + offset + 7) = (u_omega_left.base >> (8 * 7)) & 0xFF;
    2caa:	0e12      	lsrs	r2, r2, #24
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_temp.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
    2cac:	ea4f 411c 	mov.w	r1, ip, lsr #16
      *(outbuffer + offset + 0) = (u_omega_left.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_omega_left.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_omega_left.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_omega_left.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_omega_left.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_omega_left.base >> (8 * 5)) & 0xFF;
    2cb0:	f887 0278 	strb.w	r0, [r7, #632]	; 0x278
      *(outbuffer + offset + 6) = (u_omega_left.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_omega_left.base >> (8 * 7)) & 0xFF;
    2cb4:	f887 227a 	strb.w	r2, [r7, #634]	; 0x27a
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_temp.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_temp.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_temp.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_temp.base >> (8 * 5)) & 0xFF;
    2cb8:	0a18      	lsrs	r0, r3, #8
      *(outbuffer + offset + 6) = (u_temp.base >> (8 * 6)) & 0xFF;
    2cba:	0c1a      	lsrs	r2, r3, #16
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_temp.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_temp.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_temp.base >> (8 * 4)) & 0xFF;
    2cbc:	f887 327f 	strb.w	r3, [r7, #639]	; 0x27f
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_temp.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
    2cc0:	f887 127d 	strb.w	r1, [r7, #637]	; 0x27d
      *(outbuffer + offset + 3) = (u_temp.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_temp.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_temp.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_temp.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_temp.base >> (8 * 7)) & 0xFF;
    2cc4:	0e1b      	lsrs	r3, r3, #24

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    2cc6:	21ff      	movs	r1, #255	; 0xff
        double real;
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_temp.base >> (8 * 1)) & 0xFF;
    2cc8:	ea4f 291c 	mov.w	r9, ip, lsr #8
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_temp.base >> (8 * 3)) & 0xFF;
    2ccc:	ea4f 681c 	mov.w	r8, ip, lsr #24
      union {
        double real;
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
    2cd0:	f887 c27b 	strb.w	ip, [r7, #635]	; 0x27b
      *(outbuffer + offset + 1) = (u_temp.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_temp.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_temp.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_temp.base >> (8 * 5)) & 0xFF;
    2cd4:	f887 0280 	strb.w	r0, [r7, #640]	; 0x280
    message_out[1] = PROTOCOL_VER;
    2cd8:	f04f 0cfe 	mov.w	ip, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    2cdc:	2060      	movs	r0, #96	; 0x60
      *(outbuffer + offset + 6) = (u_temp.base >> (8 * 6)) & 0xFF;
    2cde:	f887 2281 	strb.w	r2, [r7, #641]	; 0x281
      *(outbuffer + offset + 7) = (u_temp.base >> (8 * 7)) & 0xFF;
    2ce2:	f887 3282 	strb.w	r3, [r7, #642]	; 0x282
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    2ce6:	2200      	movs	r2, #0
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    2ce8:	239f      	movs	r3, #159	; 0x9f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    2cea:	f887 121c 	strb.w	r1, [r7, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    2cee:	fa5f f18e 	uxtb.w	r1, lr
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    2cf2:	f34e 2e07 	sbfx	lr, lr, #8, #8
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    2cf6:	f887 021e 	strb.w	r0, [r7, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    2cfa:	f887 3220 	strb.w	r3, [r7, #544]	; 0x220
        double real;
        uint64_t base;
      } u_temp;
      u_temp.real = this->temp;
      *(outbuffer + offset + 0) = (u_temp.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_temp.base >> (8 * 1)) & 0xFF;
    2cfe:	f887 927c 	strb.w	r9, [r7, #636]	; 0x27c
      *(outbuffer + offset + 2) = (u_temp.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_temp.base >> (8 * 3)) & 0xFF;
    2d02:	f887 827e 	strb.w	r8, [r7, #638]	; 0x27e
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    2d06:	f887 c21d 	strb.w	ip, [r7, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    2d0a:	f887 221f 	strb.w	r2, [r7, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    2d0e:	f887 1221 	strb.w	r1, [r7, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    2d12:	f887 e222 	strb.w	lr, [r7, #546]	; 0x222
    2d16:	f207 2321 	addw	r3, r7, #545	; 0x221
    2d1a:	f207 2082 	addw	r0, r7, #642	; 0x282
    2d1e:	e011      	b.n	2d44 <loop+0x6f4>
    2d20:	1fff1494 	.word	0x1fff1494
    2d24:	1fff2b28 	.word	0x1fff2b28
    2d28:	0000196d 	.word	0x0000196d
    2d2c:	1fff1c9c 	.word	0x1fff1c9c
    2d30:	1fff2290 	.word	0x1fff2290
    2d34:	1fff2a88 	.word	0x1fff2a88
    2d38:	1fff1460 	.word	0x1fff1460
    2d3c:	1fff2b20 	.word	0x1fff2b20
    2d40:	f813 1f01 	ldrb.w	r1, [r3, #1]!

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    2d44:	4283      	cmp	r3, r0
      chk += message_out[i];
    2d46:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    2d48:	d1fa      	bne.n	2d40 <loop+0x6f0>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    2d4a:	43d2      	mvns	r2, r2
    2d4c:	6878      	ldr	r0, [r7, #4]
    2d4e:	f887 2283 	strb.w	r2, [r7, #643]	; 0x283
    2d52:	6803      	ldr	r3, [r0, #0]
    2d54:	4ab6      	ldr	r2, [pc, #728]	; (3030 <loop+0x9e0>)
    2d56:	685b      	ldr	r3, [r3, #4]
    2d58:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    2d5a:	f507 7107 	add.w	r1, r7, #540	; 0x21c
    2d5e:	f040 80bb 	bne.w	2ed8 <loop+0x888>
    2d62:	4608      	mov	r0, r1
    2d64:	2168      	movs	r1, #104	; 0x68
    2d66:	f003 f9a3 	bl	60b0 <usb_serial_write>
    2d6a:	4bb2      	ldr	r3, [pc, #712]	; (3034 <loop+0x9e4>)
    2d6c:	68d8      	ldr	r0, [r3, #12]
    2d6e:	6899      	ldr	r1, [r3, #8]
    2d70:	6803      	ldr	r3, [r0, #0]
    2d72:	681b      	ldr	r3, [r3, #0]
    2d74:	42a3      	cmp	r3, r4
    2d76:	f040 8109 	bne.w	2f8c <loop+0x93c>
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    2d7a:	2963      	cmp	r1, #99	; 0x63
    2d7c:	dd04      	ble.n	2d88 <loop+0x738>
    2d7e:	f890 34f8 	ldrb.w	r3, [r0, #1272]	; 0x4f8
    2d82:	2b00      	cmp	r3, #0
    2d84:	f43f ac78 	beq.w	2678 <loop+0x28>
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    2d88:	f105 020c 	add.w	r2, r5, #12
    2d8c:	ca8c      	ldmia	r2, {r2, r3, r7}
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
    2d8e:	f8d5 e008 	ldr.w	lr, [r5, #8]
    2d92:	f880 e223 	strb.w	lr, [r0, #547]	; 0x223
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
    2d96:	ea4f 2c1e 	mov.w	ip, lr, lsr #8
    2d9a:	f880 c224 	strb.w	ip, [r0, #548]	; 0x224
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    2d9e:	ea4f 4c1e 	mov.w	ip, lr, lsr #16
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
    2da2:	ea4f 6e1e 	mov.w	lr, lr, lsr #24
    2da6:	f880 e226 	strb.w	lr, [r0, #550]	; 0x226
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    2daa:	ea4f 2e12 	mov.w	lr, r2, lsr #8
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
    2dae:	f880 c225 	strb.w	ip, [r0, #549]	; 0x225
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
    2db2:	f880 e228 	strb.w	lr, [r0, #552]	; 0x228
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    2db6:	ea4f 4c12 	mov.w	ip, r2, lsr #16
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    2dba:	ea4f 6e12 	mov.w	lr, r2, lsr #24
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
    2dbe:	f880 c229 	strb.w	ip, [r0, #553]	; 0x229
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
    2dc2:	f880 e22a 	strb.w	lr, [r0, #554]	; 0x22a
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    2dc6:	ea4f 4c13 	mov.w	ip, r3, lsr #16
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    2dca:	ea4f 2e13 	mov.w	lr, r3, lsr #8
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    2dce:	69ac      	ldr	r4, [r5, #24]
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
    2dd0:	f880 2227 	strb.w	r2, [r0, #551]	; 0x227
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
    2dd4:	f880 322b 	strb.w	r3, [r0, #555]	; 0x22b
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    2dd8:	69ea      	ldr	r2, [r5, #28]
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
    2dda:	f880 e22c 	strb.w	lr, [r0, #556]	; 0x22c
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
    2dde:	f880 c22d 	strb.w	ip, [r0, #557]	; 0x22d
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    2de2:	ea4f 6e13 	mov.w	lr, r3, lsr #24
      union {
        double real;
        uint64_t base;
      } u_w;
      u_w.real = this->w;
      *(outbuffer + offset + 0) = (u_w.base >> (8 * 0)) & 0xFF;
    2de6:	f8d5 c020 	ldr.w	ip, [r5, #32]
    2dea:	6a6b      	ldr	r3, [r5, #36]	; 0x24
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
    2dec:	f880 4233 	strb.w	r4, [r0, #563]	; 0x233
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
    2df0:	0a3d      	lsrs	r5, r7, #8
    2df2:	f880 5230 	strb.w	r5, [r0, #560]	; 0x230
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
    2df6:	0c3d      	lsrs	r5, r7, #16
    2df8:	f880 5231 	strb.w	r5, [r0, #561]	; 0x231
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
    2dfc:	0a25      	lsrs	r5, r4, #8
    2dfe:	f880 5234 	strb.w	r5, [r0, #564]	; 0x234
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    2e02:	0c25      	lsrs	r5, r4, #16
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
    2e04:	0e24      	lsrs	r4, r4, #24
    2e06:	f880 4236 	strb.w	r4, [r0, #566]	; 0x236
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    2e0a:	0c14      	lsrs	r4, r2, #16
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
    2e0c:	f880 722f 	strb.w	r7, [r0, #559]	; 0x22f
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
    2e10:	f880 5235 	strb.w	r5, [r0, #565]	; 0x235
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    2e14:	0e3f      	lsrs	r7, r7, #24
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    2e16:	0a15      	lsrs	r5, r2, #8
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
    2e18:	f880 2237 	strb.w	r2, [r0, #567]	; 0x237
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
    2e1c:	f880 4239 	strb.w	r4, [r0, #569]	; 0x239
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    2e20:	0e12      	lsrs	r2, r2, #24
        uint64_t base;
      } u_w;
      u_w.real = this->w;
      *(outbuffer + offset + 0) = (u_w.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_w.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_w.base >> (8 * 2)) & 0xFF;
    2e22:	ea4f 441c 	mov.w	r4, ip, lsr #16
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
    2e26:	f880 e22e 	strb.w	lr, [r0, #558]	; 0x22e
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
    2e2a:	f880 7232 	strb.w	r7, [r0, #562]	; 0x232
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
    2e2e:	f880 5238 	strb.w	r5, [r0, #568]	; 0x238
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
    2e32:	f880 223a 	strb.w	r2, [r0, #570]	; 0x23a
      *(outbuffer + offset + 0) = (u_w.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_w.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_w.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_w.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_w.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_w.base >> (8 * 5)) & 0xFF;
    2e36:	0a1d      	lsrs	r5, r3, #8
      union {
        double real;
        uint64_t base;
      } u_w;
      u_w.real = this->w;
      *(outbuffer + offset + 0) = (u_w.base >> (8 * 0)) & 0xFF;
    2e38:	f880 c23b 	strb.w	ip, [r0, #571]	; 0x23b
      *(outbuffer + offset + 1) = (u_w.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_w.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_w.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_w.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_w.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_w.base >> (8 * 6)) & 0xFF;
    2e3c:	0c1a      	lsrs	r2, r3, #16
      } u_w;
      u_w.real = this->w;
      *(outbuffer + offset + 0) = (u_w.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_w.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_w.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_w.base >> (8 * 3)) & 0xFF;
    2e3e:	ea4f 671c 	mov.w	r7, ip, lsr #24
      *(outbuffer + offset + 4) = (u_w.base >> (8 * 4)) & 0xFF;
    2e42:	f880 323f 	strb.w	r3, [r0, #575]	; 0x23f
        uint64_t base;
      } u_w;
      u_w.real = this->w;
      *(outbuffer + offset + 0) = (u_w.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_w.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_w.base >> (8 * 2)) & 0xFF;
    2e46:	f880 423d 	strb.w	r4, [r0, #573]	; 0x23d
      *(outbuffer + offset + 3) = (u_w.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_w.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_w.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_w.base >> (8 * 6)) & 0xFF;
      *(outbuffer + offset + 7) = (u_w.base >> (8 * 7)) & 0xFF;
    2e4a:	0e1b      	lsrs	r3, r3, #24

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    2e4c:	24ff      	movs	r4, #255	; 0xff
        double real;
        uint64_t base;
      } u_w;
      u_w.real = this->w;
      *(outbuffer + offset + 0) = (u_w.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_w.base >> (8 * 1)) & 0xFF;
    2e4e:	ea4f 2e1c 	mov.w	lr, ip, lsr #8
      *(outbuffer + offset + 2) = (u_w.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_w.base >> (8 * 3)) & 0xFF;
    2e52:	f880 723e 	strb.w	r7, [r0, #574]	; 0x23e
      *(outbuffer + offset + 4) = (u_w.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_w.base >> (8 * 5)) & 0xFF;
    2e56:	f880 5240 	strb.w	r5, [r0, #576]	; 0x240
    message_out[1] = PROTOCOL_VER;
    2e5a:	27fe      	movs	r7, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    2e5c:	2520      	movs	r5, #32
      *(outbuffer + offset + 6) = (u_w.base >> (8 * 6)) & 0xFF;
    2e5e:	f880 2241 	strb.w	r2, [r0, #577]	; 0x241
      *(outbuffer + offset + 7) = (u_w.base >> (8 * 7)) & 0xFF;
    2e62:	f880 3242 	strb.w	r3, [r0, #578]	; 0x242
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    2e66:	2200      	movs	r2, #0
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    2e68:	23df      	movs	r3, #223	; 0xdf

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    2e6a:	f880 421c 	strb.w	r4, [r0, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    2e6e:	b2cc      	uxtb	r4, r1
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    2e70:	f341 2107 	sbfx	r1, r1, #8, #8
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    2e74:	f880 3220 	strb.w	r3, [r0, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    2e78:	f880 1222 	strb.w	r1, [r0, #546]	; 0x222
        double real;
        uint64_t base;
      } u_w;
      u_w.real = this->w;
      *(outbuffer + offset + 0) = (u_w.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_w.base >> (8 * 1)) & 0xFF;
    2e7c:	f880 e23c 	strb.w	lr, [r0, #572]	; 0x23c
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    2e80:	f880 721d 	strb.w	r7, [r0, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    2e84:	f880 521e 	strb.w	r5, [r0, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    2e88:	f880 221f 	strb.w	r2, [r0, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    2e8c:	f880 4221 	strb.w	r4, [r0, #545]	; 0x221
    2e90:	f200 2321 	addw	r3, r0, #545	; 0x221
    2e94:	f200 2142 	addw	r1, r0, #578	; 0x242
    2e98:	e001      	b.n	2e9e <loop+0x84e>
    2e9a:	f813 4f01 	ldrb.w	r4, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    2e9e:	428b      	cmp	r3, r1
      chk += message_out[i];
    2ea0:	4422      	add	r2, r4
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    2ea2:	d1fa      	bne.n	2e9a <loop+0x84a>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    2ea4:	43d2      	mvns	r2, r2
    2ea6:	6844      	ldr	r4, [r0, #4]
    2ea8:	f880 2243 	strb.w	r2, [r0, #579]	; 0x243
    2eac:	6823      	ldr	r3, [r4, #0]
    2eae:	4a60      	ldr	r2, [pc, #384]	; (3030 <loop+0x9e0>)
    2eb0:	685b      	ldr	r3, [r3, #4]
    2eb2:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    2eb4:	f500 7007 	add.w	r0, r0, #540	; 0x21c
    2eb8:	d108      	bne.n	2ecc <loop+0x87c>
    2eba:	2128      	movs	r1, #40	; 0x28
    2ebc:	f003 f8f8 	bl	60b0 <usb_serial_write>
    2ec0:	f7ff bbda 	b.w	2678 <loop+0x28>
    2ec4:	2210      	movs	r2, #16
    2ec6:	495c      	ldr	r1, [pc, #368]	; (3038 <loop+0x9e8>)
    2ec8:	4798      	blx	r3
    2eca:	e52e      	b.n	292a <loop+0x2da>
    2ecc:	4601      	mov	r1, r0
    2ece:	2228      	movs	r2, #40	; 0x28
    2ed0:	4620      	mov	r0, r4
    2ed2:	4798      	blx	r3
    2ed4:	f7ff bbd0 	b.w	2678 <loop+0x28>
    2ed8:	2268      	movs	r2, #104	; 0x68
    2eda:	4798      	blx	r3
    2edc:	e745      	b.n	2d6a <loop+0x71a>
        bytes_ += data << 8;
        mode_++;
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
      {
        if ((checksum_ % 256) == 255)
    2ede:	3a01      	subs	r2, #1
    2ee0:	f062 02ff 	orn	r2, r2, #255	; 0xff
    2ee4:	3201      	adds	r2, #1
    2ee6:	e554      	b.n	2992 <loop+0x342>

void loop() {
  int i = 0;
  if(bool_tele_op_toggel == 2){
    current_time = micros();
    double time_elapsed = double(current_time - previous_time)*pow(10,-6);
    2ee8:	f8df 9170 	ldr.w	r9, [pc, #368]	; 305c <loop+0xa0c>


void loop() {
  int i = 0;
  if(bool_tele_op_toggel == 2){
    current_time = micros();
    2eec:	f8df b170 	ldr.w	fp, [pc, #368]	; 3060 <loop+0xa10>
    double time_elapsed = double(current_time - previous_time)*pow(10,-6);
    speed_PID_controller(goal_omega_right, average_omega_right, last_error_right, goal_omega_left, average_omega_left, last_error_left, time_elapsed);
    2ef0:	4e52      	ldr	r6, [pc, #328]	; (303c <loop+0x9ec>)
    2ef2:	f8df a170 	ldr.w	sl, [pc, #368]	; 3064 <loop+0xa14>
    2ef6:	4c52      	ldr	r4, [pc, #328]	; (3040 <loop+0x9f0>)
    2ef8:	4d52      	ldr	r5, [pc, #328]	; (3044 <loop+0x9f4>)
    2efa:	4f53      	ldr	r7, [pc, #332]	; (3048 <loop+0x9f8>)
    2efc:	f8df 8168 	ldr.w	r8, [pc, #360]	; 3068 <loop+0xa18>


void loop() {
  int i = 0;
  if(bool_tele_op_toggel == 2){
    current_time = micros();
    2f00:	f002 f9aa 	bl	5258 <micros>
    double time_elapsed = double(current_time - previous_time)*pow(10,-6);
    speed_PID_controller(goal_omega_right, average_omega_right, last_error_right, goal_omega_left, average_omega_left, last_error_left, time_elapsed);
    2f04:	f8d9 3000 	ldr.w	r3, [r9]


void loop() {
  int i = 0;
  if(bool_tele_op_toggel == 2){
    current_time = micros();
    2f08:	f8cb 0000 	str.w	r0, [fp]
    double time_elapsed = double(current_time - previous_time)*pow(10,-6);
    speed_PID_controller(goal_omega_right, average_omega_right, last_error_right, goal_omega_left, average_omega_left, last_error_left, time_elapsed);
    2f0c:	1ac0      	subs	r0, r0, r3
    2f0e:	f004 fe95 	bl	7c3c <__aeabi_i2d>
    2f12:	a345      	add	r3, pc, #276	; (adr r3, 3028 <loop+0x9d8>)
    2f14:	e9d3 2300 	ldrd	r2, r3, [r3]
    2f18:	f004 fef6 	bl	7d08 <__aeabi_dmul>
    2f1c:	e9cd 0102 	strd	r0, r1, [sp, #8]
    2f20:	6830      	ldr	r0, [r6, #0]
    2f22:	f004 fe9d 	bl	7c60 <__aeabi_f2d>
    2f26:	e9cd 0100 	strd	r0, r1, [sp]
    2f2a:	f8da 0000 	ldr.w	r0, [sl]
    2f2e:	f004 fe97 	bl	7c60 <__aeabi_f2d>
    2f32:	ed94 5b00 	vldr	d5, [r4]
    2f36:	ec41 0b11 	vmov	d1, r0, r1
    2f3a:	ed95 3b00 	vldr	d3, [r5]
    2f3e:	ed97 2b00 	vldr	d2, [r7]
    2f42:	ed9d 6b02 	vldr	d6, [sp, #8]
    2f46:	ed9d 4b00 	vldr	d4, [sp]
    2f4a:	ed98 0b00 	vldr	d0, [r8]
    2f4e:	f7fe ff45 	bl	1ddc <speed_PID_controller(double, double, double, double, double, double, double)>

    previous_time = current_time;
    2f52:	f8db 3000 	ldr.w	r3, [fp]
    2f56:	f8c9 3000 	str.w	r3, [r9]
    last_error_right = goal_omega_right - average_omega_right;
    2f5a:	f8da 0000 	ldr.w	r0, [sl]
    2f5e:	f004 fe7f 	bl	7c60 <__aeabi_f2d>
    2f62:	4602      	mov	r2, r0
    2f64:	460b      	mov	r3, r1
    2f66:	e9d8 0100 	ldrd	r0, r1, [r8]
    2f6a:	f004 fd19 	bl	79a0 <__aeabi_dsub>
    2f6e:	e9c7 0100 	strd	r0, r1, [r7]
    last_error_left = goal_omega_left - average_omega_left;
    2f72:	6830      	ldr	r0, [r6, #0]
    2f74:	f004 fe74 	bl	7c60 <__aeabi_f2d>
    2f78:	4602      	mov	r2, r0
    2f7a:	460b      	mov	r3, r1
    2f7c:	e9d5 0100 	ldrd	r0, r1, [r5]
    2f80:	f004 fd0e 	bl	79a0 <__aeabi_dsub>
    2f84:	e9c4 0100 	strd	r0, r1, [r4]
    2f88:	f7ff bb6a 	b.w	2660 <loop+0x10>
    2f8c:	4a2f      	ldr	r2, [pc, #188]	; (304c <loop+0x9fc>)
    2f8e:	4798      	blx	r3
    2f90:	f7ff bb72 	b.w	2678 <loop+0x28>
    2f94:	4671      	mov	r1, lr
    2f96:	4638      	mov	r0, r7
    2f98:	4a2d      	ldr	r2, [pc, #180]	; (3050 <loop+0xa00>)
    2f9a:	4798      	blx	r3
    2f9c:	e6e5      	b.n	2d6a <loop+0x71a>
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
        if ((checksum_ % 256) == 255)
    2f9e:	3a01      	subs	r2, #1
    2fa0:	f062 02ff 	orn	r2, r2, #255	; 0xff
    2fa4:	3201      	adds	r2, #1
    2fa6:	f7ff bbd1 	b.w	274c <loop+0xfc>
    2faa:	2210      	movs	r2, #16
    2fac:	4922      	ldr	r1, [pc, #136]	; (3038 <loop+0x9e8>)
    2fae:	4798      	blx	r3
    2fb0:	e465      	b.n	287e <loop+0x22e>
            req_param_resp.deserialize(message_in);
            param_received = true;
          }
          else if (topic_ == TopicInfo::ID_TX_STOP)
          {
            configured_ = false;
    2fb2:	2300      	movs	r3, #0
    2fb4:	f885 34f8 	strb.w	r3, [r5, #1272]	; 0x4f8
    2fb8:	f7ff bb7a 	b.w	26b0 <loop+0x60>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2fbc:	6833      	ldr	r3, [r6, #0]
    2fbe:	930e      	str	r3, [sp, #56]	; 0x38
	return ret;
    2fc0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  }

  void syncTime(uint8_t * data)
  {
    std_msgs::Time t;
    uint32_t offset = hardware_.time() - rt_time;
    2fc2:	68ea      	ldr	r2, [r5, #12]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2fc4:	6831      	ldr	r1, [r6, #0]
    2fc6:	9110      	str	r1, [sp, #64]	; 0x40
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    2fc8:	4822      	ldr	r0, [pc, #136]	; (3054 <loop+0xa04>)
	return ret;
    2fca:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    2fce:	6a29      	ldr	r1, [r5, #32]
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    2fd0:	f8df c098 	ldr.w	ip, [pc, #152]	; 306c <loop+0xa1c>
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    2fd4:	4f1f      	ldr	r7, [pc, #124]	; (3054 <loop+0xa04>)
  }

  void syncTime(uint8_t * data)
  {
    std_msgs::Time t;
    uint32_t offset = hardware_.time() - rt_time;
    2fd6:	1a9b      	subs	r3, r3, r2
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    2fd8:	fba0 0e03 	umull	r0, lr, r0, r3
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    2fdc:	69ea      	ldr	r2, [r5, #28]
    2fde:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    2fe2:	448c      	add	ip, r1
    2fe4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    2fe8:	491b      	ldr	r1, [pc, #108]	; (3058 <loop+0xa08>)
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    2fea:	fba7 7a08 	umull	r7, sl, r7, r8
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    2fee:	fb00 331e 	mls	r3, r0, lr, r3
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    2ff2:	ea4f 1a9a 	mov.w	sl, sl, lsr #6
    2ff6:	3a01      	subs	r2, #1
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    2ff8:	fb01 c303 	mla	r3, r1, r3, ip
    2ffc:	fb00 801a 	mls	r0, r0, sl, r8
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    3000:	4472      	add	r2, lr
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    3002:	fb01 3310 	mls	r3, r1, r0, r3
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    3006:	ebca 0202 	rsb	r2, sl, r2
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    normalizeSecNSec(sec_offset, nsec_offset);
    300a:	f109 0114 	add.w	r1, r9, #20
    300e:	f109 0010 	add.w	r0, r9, #16

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    3012:	616b      	str	r3, [r5, #20]
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    3014:	612a      	str	r2, [r5, #16]
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    normalizeSecNSec(sec_offset, nsec_offset);
    3016:	f001 fd1f 	bl	4a58 <ros::normalizeSecNSec(unsigned long&, unsigned long&)>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    301a:	6833      	ldr	r3, [r6, #0]
    301c:	930f      	str	r3, [sp, #60]	; 0x3c
	return ret;
    301e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    t.deserialize(data);
    t.data.sec += offset / 1000;
    t.data.nsec += (offset % 1000) * 1000000UL;

    this->setNow(t.data);
    last_sync_receive_time = hardware_.time();
    3020:	f8c5 3500 	str.w	r3, [r5, #1280]	; 0x500
    3024:	f7ff bb44 	b.w	26b0 <loop+0x60>
    3028:	a0b5ed8d 	.word	0xa0b5ed8d
    302c:	3eb0c6f7 	.word	0x3eb0c6f7
    3030:	00000ea9 	.word	0x00000ea9
    3034:	1fff1d18 	.word	0x1fff1d18
    3038:	1fff1f74 	.word	0x1fff1f74
    303c:	1fff1c9c 	.word	0x1fff1c9c
    3040:	1fff1488 	.word	0x1fff1488
    3044:	1fff14a0 	.word	0x1fff14a0
    3048:	1fff1d48 	.word	0x1fff1d48
    304c:	1fff2b28 	.word	0x1fff2b28
    3050:	1fff2a88 	.word	0x1fff2a88
    3054:	10624dd3 	.word	0x10624dd3
    3058:	000f4240 	.word	0x000f4240
    305c:	1fff2b88 	.word	0x1fff2b88
    3060:	1fff2b90 	.word	0x1fff2b90
    3064:	1fff1494 	.word	0x1fff1494
    3068:	1fff2b68 	.word	0x1fff2b68
    306c:	3b9aca00 	.word	0x3b9aca00
    {
      int offset = 0;
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    3070:	f8d5 801c 	ldr.w	r8, [r5, #28]
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
    3074:	f8d5 3510 	ldr.w	r3, [r5, #1296]	; 0x510
    3078:	4598      	cmp	r8, r3
    307a:	d907      	bls.n	308c <loop+0xa3c>
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
    307c:	ea4f 0188 	mov.w	r1, r8, lsl #2
    3080:	f8d5 0518 	ldr.w	r0, [r5, #1304]	; 0x518
    3084:	f005 fd14 	bl	8ab0 <realloc>
    3088:	f8c5 0518 	str.w	r0, [r5, #1304]	; 0x518
      ints_length = ints_lengthT;
    308c:	f8c4 8510 	str.w	r8, [r4, #1296]	; 0x510
      for( uint32_t i = 0; i < ints_length; i++){
    3090:	f1b8 0f00 	cmp.w	r8, #0
    3094:	f000 80f4 	beq.w	3280 <loop+0xc30>
    3098:	f8df 826c 	ldr.w	r8, [pc, #620]	; 3308 <loop+0xcb8>
    309c:	f04f 0904 	mov.w	r9, #4
    30a0:	f04f 0a00 	mov.w	sl, #0
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
    30a4:	f898 1022 	ldrb.w	r1, [r8, #34]	; 0x22
    30a8:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
    30ac:	f898 2020 	ldrb.w	r2, [r8, #32]
    30b0:	f898 e023 	ldrb.w	lr, [r8, #35]	; 0x23
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
    30b4:	f8d4 0518 	ldr.w	r0, [r4, #1304]	; 0x518
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
    30b8:	0409      	lsls	r1, r1, #16
    30ba:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
    30be:	4313      	orrs	r3, r2
    30c0:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
    30c4:	eb00 008a 	add.w	r0, r0, sl, lsl #2
    30c8:	498b      	ldr	r1, [pc, #556]	; (32f8 <loop+0xca8>)
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
    30ca:	f8c4 3514 	str.w	r3, [r4, #1300]	; 0x514
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
    30ce:	2204      	movs	r2, #4
    30d0:	f001 fcd6 	bl	4a80 <memcpy>
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
      ints_length = ints_lengthT;
      for( uint32_t i = 0; i < ints_length; i++){
    30d4:	f8d4 3510 	ldr.w	r3, [r4, #1296]	; 0x510
    30d8:	f10a 0a01 	add.w	sl, sl, #1
    30dc:	4553      	cmp	r3, sl
    30de:	4649      	mov	r1, r9
    30e0:	f108 0804 	add.w	r8, r8, #4
    30e4:	f109 0904 	add.w	r9, r9, #4
    30e8:	d8dc      	bhi.n	30a4 <loop+0xa54>
    30ea:	f101 0a08 	add.w	sl, r1, #8
    30ee:	f101 0e05 	add.w	lr, r1, #5
    30f2:	f101 0c06 	add.w	ip, r1, #6
    30f6:	f101 0807 	add.w	r8, r1, #7
    30fa:	f101 0309 	add.w	r3, r1, #9
    30fe:	f101 020a 	add.w	r2, r1, #10
    3102:	f101 070b 	add.w	r7, r1, #11
    3106:	310c      	adds	r1, #12
    3108:	4648      	mov	r0, r9
    310a:	9100      	str	r1, [sp, #0]
    310c:	46d1      	mov	r9, sl
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    310e:	44a4      	add	ip, r4
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
    3110:	44a6      	add	lr, r4
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    3112:	f89c c01c 	ldrb.w	ip, [ip, #28]
    3116:	f89e 101c 	ldrb.w	r1, [lr, #28]
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    311a:	4420      	add	r0, r4
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    311c:	44a0      	add	r8, r4
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    311e:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    3122:	7f00      	ldrb	r0, [r0, #28]
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    3124:	f898 e01c 	ldrb.w	lr, [r8, #28]
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    3128:	ea4c 2c01 	orr.w	ip, ip, r1, lsl #8
    312c:	ea4c 0c00 	orr.w	ip, ip, r0
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
    3130:	f8d4 151c 	ldr.w	r1, [r4, #1308]	; 0x51c
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    3134:	ea4c 680e 	orr.w	r8, ip, lr, lsl #24
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
    3138:	4588      	cmp	r8, r1
    313a:	d90b      	bls.n	3154 <loop+0xb04>
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
    313c:	ea4f 0188 	mov.w	r1, r8, lsl #2
    3140:	f8d5 0524 	ldr.w	r0, [r5, #1316]	; 0x524
    3144:	9205      	str	r2, [sp, #20]
    3146:	9302      	str	r3, [sp, #8]
    3148:	f005 fcb2 	bl	8ab0 <realloc>
    314c:	9a05      	ldr	r2, [sp, #20]
    314e:	9b02      	ldr	r3, [sp, #8]
    3150:	f8c5 0524 	str.w	r0, [r5, #1316]	; 0x524
      floats_length = floats_lengthT;
    3154:	f8c4 851c 	str.w	r8, [r4, #1308]	; 0x51c
      for( uint32_t i = 0; i < floats_length; i++){
    3158:	f1b8 0f00 	cmp.w	r8, #0
    315c:	f000 808d 	beq.w	327a <loop+0xc2a>
    3160:	eb05 0a09 	add.w	sl, r5, r9
    3164:	f04f 0800 	mov.w	r8, #0
      } u_st_floats;
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    3168:	f89a 101e 	ldrb.w	r1, [sl, #30]
    316c:	f89a 301d 	ldrb.w	r3, [sl, #29]
    3170:	f89a 201c 	ldrb.w	r2, [sl, #28]
    3174:	f89a e01f 	ldrb.w	lr, [sl, #31]
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    3178:	f8d4 0524 	ldr.w	r0, [r4, #1316]	; 0x524
      } u_st_floats;
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    317c:	0409      	lsls	r1, r1, #16
    317e:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
    3182:	4313      	orrs	r3, r2
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    3184:	495d      	ldr	r1, [pc, #372]	; (32fc <loop+0xcac>)
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
    3186:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
    318a:	600b      	str	r3, [r1, #0]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    318c:	eb00 0088 	add.w	r0, r0, r8, lsl #2
    3190:	2204      	movs	r2, #4
    3192:	f001 fc75 	bl	4a80 <memcpy>
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
      floats_length = floats_lengthT;
      for( uint32_t i = 0; i < floats_length; i++){
    3196:	f8d4 351c 	ldr.w	r3, [r4, #1308]	; 0x51c
    319a:	f108 0801 	add.w	r8, r8, #1
    319e:	4543      	cmp	r3, r8
    31a0:	4649      	mov	r1, r9
    31a2:	f10a 0a04 	add.w	sl, sl, #4
    31a6:	f109 0904 	add.w	r9, r9, #4
    31aa:	d8dd      	bhi.n	3168 <loop+0xb18>
    31ac:	1dc8      	adds	r0, r1, #7
    31ae:	46ca      	mov	sl, r9
    31b0:	1d4b      	adds	r3, r1, #5
    31b2:	1d8a      	adds	r2, r1, #6
    31b4:	4607      	mov	r7, r0
    31b6:	f101 0808 	add.w	r8, r1, #8
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    31ba:	4422      	add	r2, r4
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
    31bc:	4423      	add	r3, r4
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    31be:	7f11      	ldrb	r1, [r2, #28]
    31c0:	7f18      	ldrb	r0, [r3, #28]
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
    31c2:	f8d4 3528 	ldr.w	r3, [r4, #1320]	; 0x528
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    31c6:	463a      	mov	r2, r7
    31c8:	4422      	add	r2, r4
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    31ca:	44a2      	add	sl, r4
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    31cc:	4696      	mov	lr, r2
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    31ce:	0409      	lsls	r1, r1, #16
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    31d0:	f89a 201c 	ldrb.w	r2, [sl, #28]
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    31d4:	f89e 901c 	ldrb.w	r9, [lr, #28]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    31d8:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
    31dc:	430a      	orrs	r2, r1
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    31de:	ea42 6909 	orr.w	r9, r2, r9, lsl #24
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
    31e2:	4599      	cmp	r9, r3
    31e4:	d907      	bls.n	31f6 <loop+0xba6>
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
    31e6:	ea4f 0189 	mov.w	r1, r9, lsl #2
    31ea:	f8d5 0530 	ldr.w	r0, [r5, #1328]	; 0x530
    31ee:	f005 fc5f 	bl	8ab0 <realloc>
    31f2:	f8c5 0530 	str.w	r0, [r5, #1328]	; 0x530
      strings_length = strings_lengthT;
    31f6:	f8c4 9528 	str.w	r9, [r4, #1320]	; 0x528
      for( uint32_t i = 0; i < strings_length; i++){
    31fa:	f1b9 0f00 	cmp.w	r9, #0
    31fe:	d037      	beq.n	3270 <loop+0xc20>
    3200:	f04f 0a00 	mov.w	sl, #0
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    3204:	46d1      	mov	r9, sl
    3206:	f108 011c 	add.w	r1, r8, #28
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
      uint32_t length_st_strings;
      arrToVar(length_st_strings, (inbuffer + offset));
    320a:	2300      	movs	r3, #0
    320c:	4421      	add	r1, r4

  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    320e:	469e      	mov	lr, r3
    for (size_t i = 0; i < sizeof(V); i++)
      var |= (arr[i] << (8 * i));
    3210:	f811 2b01 	ldrb.w	r2, [r1], #1
    3214:	409a      	lsls	r2, r3
    3216:	3308      	adds	r3, #8
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
    3218:	2b20      	cmp	r3, #32
      var |= (arr[i] << (8 * i));
    321a:	ea4e 0e02 	orr.w	lr, lr, r2
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
    321e:	d1f7      	bne.n	3210 <loop+0xbc0>
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
    3220:	f108 0004 	add.w	r0, r8, #4
    3224:	4486      	add	lr, r0
    3226:	4586      	cmp	lr, r0
    3228:	d909      	bls.n	323e <loop+0xbee>
    322a:	f108 031f 	add.w	r3, r8, #31
    322e:	4423      	add	r3, r4
    3230:	4602      	mov	r2, r0
    3232:	3201      	adds	r2, #1
          inbuffer[k-1]=inbuffer[k];
    3234:	7859      	ldrb	r1, [r3, #1]
    3236:	f803 1b01 	strb.w	r1, [r3], #1
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
      uint32_t length_st_strings;
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
    323a:	4596      	cmp	lr, r2
    323c:	d8f9      	bhi.n	3232 <loop+0xbe2>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    323e:	eb04 020e 	add.w	r2, r4, lr
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    3242:	492f      	ldr	r1, [pc, #188]	; (3300 <loop+0xcb0>)
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    3244:	f882 901b 	strb.w	r9, [r2, #27]
      this->st_strings = (char *)(inbuffer + offset-1);
    3248:	1e43      	subs	r3, r0, #1
    324a:	f5a1 62a2 	sub.w	r2, r1, #1296	; 0x510
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    324e:	f8d4 0530 	ldr.w	r0, [r4, #1328]	; 0x530
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
    3252:	4413      	add	r3, r2
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    3254:	eb00 008a 	add.w	r0, r0, sl, lsl #2
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
    3258:	f8c4 352c 	str.w	r3, [r4, #1324]	; 0x52c
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    325c:	2204      	movs	r2, #4
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
    325e:	46f0      	mov	r8, lr
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    3260:	f001 fc0e 	bl	4a80 <memcpy>
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
    3264:	f8d4 3528 	ldr.w	r3, [r4, #1320]	; 0x528
    3268:	f10a 0a01 	add.w	sl, sl, #1
    326c:	4553      	cmp	r3, sl
    326e:	d8ca      	bhi.n	3206 <loop+0xbb6>
            syncTime(message_in);
          }
          else if (topic_ == TopicInfo::ID_PARAMETER_REQUEST)
          {
            req_param_resp.deserialize(message_in);
            param_received = true;
    3270:	2301      	movs	r3, #1
    3272:	f884 3508 	strb.w	r3, [r4, #1288]	; 0x508
    3276:	f7ff ba1b 	b.w	26b0 <loop+0x60>
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
      floats_length = floats_lengthT;
      for( uint32_t i = 0; i < floats_length; i++){
    327a:	f8dd 8000 	ldr.w	r8, [sp]
    327e:	e79c      	b.n	31ba <loop+0xb6a>
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
      ints_length = ints_lengthT;
      for( uint32_t i = 0; i < ints_length; i++){
    3280:	230c      	movs	r3, #12
    3282:	f04f 0a08 	mov.w	sl, #8
    3286:	9300      	str	r3, [sp, #0]
    3288:	230b      	movs	r3, #11
    328a:	461f      	mov	r7, r3
    328c:	46d1      	mov	r9, sl
    328e:	220a      	movs	r2, #10
    3290:	2309      	movs	r3, #9
    3292:	f04f 0807 	mov.w	r8, #7
    3296:	f04f 0c06 	mov.w	ip, #6
    329a:	f04f 0e05 	mov.w	lr, #5
    329e:	2004      	movs	r0, #4
    32a0:	e735      	b.n	310e <loop+0xabe>
    32a2:	469a      	mov	sl, r3
  {
    if (id >= 100 && !configured_)
      return 0;

    /* serialize message */
    int l = msg->serialize(message_out + 7);
    32a4:	f209 2123 	addw	r1, r9, #547	; 0x223
    public:
      typedef ros::Time _data_type;
      _data_type data;

    Time():
      data()
    32a8:	4b16      	ldr	r3, [pc, #88]	; (3304 <loop+0xcb4>)
    32aa:	9311      	str	r3, [sp, #68]	; 0x44
    32ac:	a811      	add	r0, sp, #68	; 0x44
    32ae:	4690      	mov	r8, r2
class Time
{
public:
  uint32_t sec, nsec;

  Time() : sec(0), nsec(0) {}
    32b0:	f8cd a048 	str.w	sl, [sp, #72]	; 0x48
    32b4:	f8cd a04c 	str.w	sl, [sp, #76]	; 0x4c
    32b8:	f7fd f8d8 	bl	46c <std_msgs::Time::serialize(unsigned char*) const>

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    32bc:	b2c2      	uxtb	r2, r0
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    32be:	f3c0 2107 	ubfx	r1, r0, #8, #8
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    32c2:	1853      	adds	r3, r2, r1
    32c4:	43db      	mvns	r3, r3
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    32c6:	f889 221e 	strb.w	r2, [r9, #542]	; 0x21e
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    32ca:	25fe      	movs	r5, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    32cc:	220a      	movs	r2, #10
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    32ce:	1c47      	adds	r7, r0, #1

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    32d0:	f889 821c 	strb.w	r8, [r9, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    32d4:	f889 a222 	strb.w	sl, [r9, #546]	; 0x222
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    32d8:	f889 3220 	strb.w	r3, [r9, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    32dc:	f889 121f 	strb.w	r1, [r9, #543]	; 0x21f
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    32e0:	f889 521d 	strb.w	r5, [r9, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    32e4:	f889 2221 	strb.w	r2, [r9, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    32e8:	db19      	blt.n	331e <loop+0xcce>
    32ea:	f200 2122 	addw	r1, r0, #546	; 0x222
    32ee:	4449      	add	r1, r9
    32f0:	4653      	mov	r3, sl
    32f2:	f209 2921 	addw	r9, r9, #545	; 0x221
    32f6:	e00b      	b.n	3310 <loop+0xcc0>
    32f8:	1fff226c 	.word	0x1fff226c
    32fc:	1fff2278 	.word	0x1fff2278
    3300:	1fff2284 	.word	0x1fff2284
    3304:	000096bc 	.word	0x000096bc
    3308:	1fff1d58 	.word	0x1fff1d58
    330c:	f819 2f01 	ldrb.w	r2, [r9, #1]!
    3310:	4589      	cmp	r9, r1
      chk += message_out[i];
    3312:	4413      	add	r3, r2
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3314:	d1fa      	bne.n	330c <loop+0xcbc>
    3316:	ea6f 0803 	mvn.w	r8, r3
    331a:	fa5f f888 	uxtb.w	r8, r8
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    331e:	1823      	adds	r3, r4, r0
    3320:	f100 0208 	add.w	r2, r0, #8

    if (l <= OUTPUT_SIZE)
    3324:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3328:	f883 8223 	strb.w	r8, [r3, #547]	; 0x223
    332c:	f8df e38c 	ldr.w	lr, [pc, #908]	; 36bc <loop+0x106c>

    if (l <= OUTPUT_SIZE)
    3330:	f300 825d 	bgt.w	37ee <loop+0x119e>
    3334:	f8de 0004 	ldr.w	r0, [lr, #4]
    3338:	6803      	ldr	r3, [r0, #0]
    333a:	f50e 7107 	add.w	r1, lr, #540	; 0x21c
    333e:	685b      	ldr	r3, [r3, #4]
    3340:	4798      	blx	r3
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3342:	6833      	ldr	r3, [r6, #0]
    3344:	930a      	str	r3, [sp, #40]	; 0x28
    3346:	4ed4      	ldr	r6, [pc, #848]	; (3698 <loop+0x1048>)
	return ret;
    3348:	9b0a      	ldr	r3, [sp, #40]	; 0x28

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    rt_time = hardware_.time();
    334a:	60e3      	str	r3, [r4, #12]
    334c:	f106 0364 	add.w	r3, r6, #100	; 0x64
    3350:	9300      	str	r3, [sp, #0]
      memcpy(outbuffer + offset, this->message_type, length_message_type);
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    3352:	f5a6 6583 	sub.w	r5, r6, #1048	; 0x418
  {
    rosserial_msgs::TopicInfo ti;
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
    3356:	f856 3f04 	ldr.w	r3, [r6, #4]!
    335a:	2b00      	cmp	r3, #0
    335c:	f000 80b5 	beq.w	34ca <loop+0xe7a>
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    3360:	6858      	ldr	r0, [r3, #4]
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
    3362:	689a      	ldr	r2, [r3, #8]
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    3364:	6801      	ldr	r1, [r0, #0]
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
    3366:	9202      	str	r2, [sp, #8]
        ti.topic_name = (char *) publishers[i]->topic_;
    3368:	f8d3 a000 	ldr.w	sl, [r3]
        ti.message_type = (char *) publishers[i]->msg_->getType();
    336c:	688b      	ldr	r3, [r1, #8]
    336e:	4798      	blx	r3
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    3370:	6833      	ldr	r3, [r6, #0]
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    3372:	4681      	mov	r9, r0
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    3374:	6858      	ldr	r0, [r3, #4]
    3376:	6803      	ldr	r3, [r0, #0]
    3378:	68db      	ldr	r3, [r3, #12]
    337a:	4798      	blx	r3
    337c:	6833      	ldr	r3, [r6, #0]
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    337e:	9a02      	ldr	r2, [sp, #8]
    3380:	691f      	ldr	r7, [r3, #16]
    3382:	2f63      	cmp	r7, #99	; 0x63
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    3384:	4680      	mov	r8, r0
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    3386:	dd04      	ble.n	3392 <loop+0xd42>
    3388:	f894 34f8 	ldrb.w	r3, [r4, #1272]	; 0x4f8
    338c:	2b00      	cmp	r3, #0
    338e:	f000 809c 	beq.w	34ca <loop+0xe7a>

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    3392:	f3c2 2307 	ubfx	r3, r2, #8, #8
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    3396:	f884 2223 	strb.w	r2, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    339a:	f884 3224 	strb.w	r3, [r4, #548]	; 0x224
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    339e:	4650      	mov	r0, sl
    33a0:	f005 ff6e 	bl	9280 <strlen>
    33a4:	4603      	mov	r3, r0
  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
      arr[i] = (var >> (8 * i));
    33a6:	ea4f 6e13 	mov.w	lr, r3, lsr #24
    33aa:	0a02      	lsrs	r2, r0, #8
    33ac:	0c00      	lsrs	r0, r0, #16
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
    33ae:	4651      	mov	r1, sl
    33b0:	f884 3225 	strb.w	r3, [r4, #549]	; 0x225
    33b4:	f884 2226 	strb.w	r2, [r4, #550]	; 0x226
    33b8:	f884 0227 	strb.w	r0, [r4, #551]	; 0x227
    33bc:	461a      	mov	r2, r3
    33be:	f884 e228 	strb.w	lr, [r4, #552]	; 0x228
    33c2:	48b6      	ldr	r0, [pc, #728]	; (369c <loop+0x104c>)
    33c4:	9302      	str	r3, [sp, #8]
    33c6:	f001 fb5b 	bl	4a80 <memcpy>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
    33ca:	4648      	mov	r0, r9
    33cc:	f005 ff58 	bl	9280 <strlen>
    33d0:	9b02      	ldr	r3, [sp, #8]
    33d2:	4602      	mov	r2, r0
    33d4:	f203 2029 	addw	r0, r3, #553	; 0x229
    33d8:	4420      	add	r0, r4
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
    33da:	3306      	adds	r3, #6
      uint32_t length_message_type = strlen(this->message_type);
    33dc:	2100      	movs	r1, #0
    33de:	fa22 fe01 	lsr.w	lr, r2, r1
    33e2:	3108      	adds	r1, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    33e4:	2920      	cmp	r1, #32
      arr[i] = (var >> (8 * i));
    33e6:	f800 eb01 	strb.w	lr, [r0], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    33ea:	d1f8      	bne.n	33de <loop+0xd8e>
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    33ec:	48ac      	ldr	r0, [pc, #688]	; (36a0 <loop+0x1050>)
    33ee:	3304      	adds	r3, #4
    33f0:	4649      	mov	r1, r9
    33f2:	4418      	add	r0, r3
      offset += length_message_type;
    33f4:	eb02 0903 	add.w	r9, r2, r3
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    33f8:	f001 fb42 	bl	4a80 <memcpy>
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
    33fc:	4640      	mov	r0, r8
    33fe:	f005 ff3f 	bl	9280 <strlen>
    3402:	f209 2223 	addw	r2, r9, #547	; 0x223
    3406:	4682      	mov	sl, r0
    3408:	4422      	add	r2, r4
    340a:	2300      	movs	r3, #0
      arr[i] = (var >> (8 * i));
    340c:	fa2a f103 	lsr.w	r1, sl, r3
    3410:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3412:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
    3414:	f802 1b01 	strb.w	r1, [r2], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3418:	d1f8      	bne.n	340c <loop+0xdbc>
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    341a:	4ba1      	ldr	r3, [pc, #644]	; (36a0 <loop+0x1050>)
    341c:	f109 0904 	add.w	r9, r9, #4
    3420:	4641      	mov	r1, r8
    3422:	eb03 0009 	add.w	r0, r3, r9
    3426:	4652      	mov	r2, sl
    3428:	f001 fb2a 	bl	4a80 <memcpy>
      offset += length_md5sum;
    342c:	eb0a 0009 	add.w	r0, sl, r9
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
    3430:	f100 0e04 	add.w	lr, r0, #4
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    3434:	1821      	adds	r1, r4, r0
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3436:	fa5f f88e 	uxtb.w	r8, lr
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    343a:	f3ce 2c07 	ubfx	ip, lr, #8, #8
    343e:	2200      	movs	r2, #0
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    3440:	2302      	movs	r3, #2
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3442:	eb08 0a0c 	add.w	sl, r8, ip
    3446:	f881 3224 	strb.w	r3, [r1, #548]	; 0x224
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    344a:	f881 2223 	strb.w	r2, [r1, #547]	; 0x223
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
    344e:	f881 2225 	strb.w	r2, [r1, #549]	; 0x225
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
    3452:	f881 2226 	strb.w	r2, [r1, #550]	; 0x226
    3456:	ea6f 0a0a 	mvn.w	sl, sl
    message_out[5] = (uint8_t)((int16_t)id & 255);
    345a:	b2f9      	uxtb	r1, r7

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    345c:	23ff      	movs	r3, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    345e:	f04f 09fe 	mov.w	r9, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3462:	f347 2707 	sbfx	r7, r7, #8, #8

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3466:	f1be 3fff 	cmp.w	lr, #4294967295	; 0xffffffff
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    346a:	f884 a220 	strb.w	sl, [r4, #544]	; 0x220
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    346e:	f884 821e 	strb.w	r8, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3472:	f884 c21f 	strb.w	ip, [r4, #543]	; 0x21f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3476:	f884 321c 	strb.w	r3, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    347a:	f884 921d 	strb.w	r9, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    347e:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3482:	f884 7222 	strb.w	r7, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3486:	db0b      	blt.n	34a0 <loop+0xe50>
    3488:	f200 2026 	addw	r0, r0, #550	; 0x226
    348c:	4b85      	ldr	r3, [pc, #532]	; (36a4 <loop+0x1054>)
    348e:	4428      	add	r0, r5
    3490:	e001      	b.n	3496 <loop+0xe46>
    3492:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    3496:	4283      	cmp	r3, r0
      chk += message_out[i];
    3498:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    349a:	d1fa      	bne.n	3492 <loop+0xe42>
    349c:	43d3      	mvns	r3, r2
    349e:	b2db      	uxtb	r3, r3
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    34a0:	eb04 010e 	add.w	r1, r4, lr
    34a4:	f10e 0208 	add.w	r2, lr, #8

    if (l <= OUTPUT_SIZE)
    34a8:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    34ac:	f881 3223 	strb.w	r3, [r1, #547]	; 0x223

    if (l <= OUTPUT_SIZE)
    34b0:	f300 8113 	bgt.w	36da <loop+0x108a>
    34b4:	6868      	ldr	r0, [r5, #4]
    34b6:	497c      	ldr	r1, [pc, #496]	; (36a8 <loop+0x1058>)
    34b8:	6803      	ldr	r3, [r0, #0]
    34ba:	685b      	ldr	r3, [r3, #4]
    34bc:	428b      	cmp	r3, r1
    34be:	f040 8105 	bne.w	36cc <loop+0x107c>
    34c2:	4611      	mov	r1, r2
    34c4:	4879      	ldr	r0, [pc, #484]	; (36ac <loop+0x105c>)
    34c6:	f002 fdf3 	bl	60b0 <usb_serial_write>

  void negotiateTopics()
  {
    rosserial_msgs::TopicInfo ti;
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    34ca:	9b00      	ldr	r3, [sp, #0]
    34cc:	429e      	cmp	r6, r3
    34ce:	f47f af42 	bne.w	3356 <loop+0xd06>
    34d2:	f8df a1f4 	ldr.w	sl, [pc, #500]	; 36c8 <loop+0x1078>
    34d6:	f8cd b008 	str.w	fp, [sp, #8]
    34da:	469b      	mov	fp, r3
        publish(publishers[i]->getEndpointType(), &ti);
      }
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
    34dc:	f85b 0f04 	ldr.w	r0, [fp, #4]!
    34e0:	2800      	cmp	r0, #0
    34e2:	f000 80bf 	beq.w	3664 <loop+0x1014>
      {
        ti.topic_id = subscribers[i]->id_;
    34e6:	e890 0208 	ldmia.w	r0, {r3, r9}
    34ea:	4971      	ldr	r1, [pc, #452]	; (36b0 <loop+0x1060>)
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
    34ec:	689a      	ldr	r2, [r3, #8]
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
    34ee:	f8d0 8008 	ldr.w	r8, [r0, #8]
    34f2:	428a      	cmp	r2, r1
    34f4:	f000 80ce 	beq.w	3694 <loop+0x1044>
        ti.message_type = (char *) subscribers[i]->getMsgType();
    34f8:	4790      	blx	r2
    34fa:	4607      	mov	r7, r0
    34fc:	f8db 0000 	ldr.w	r0, [fp]
    3500:	6803      	ldr	r3, [r0, #0]
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
    3502:	68da      	ldr	r2, [r3, #12]
    3504:	496b      	ldr	r1, [pc, #428]	; (36b4 <loop+0x1064>)
    3506:	428a      	cmp	r2, r1
    3508:	f000 80c2 	beq.w	3690 <loop+0x1040>
    350c:	4790      	blx	r2
    350e:	4606      	mov	r6, r0
    3510:	f8db 0000 	ldr.w	r0, [fp]
    3514:	6803      	ldr	r3, [r0, #0]
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
    3516:	685b      	ldr	r3, [r3, #4]
    3518:	4a67      	ldr	r2, [pc, #412]	; (36b8 <loop+0x1068>)
    351a:	4293      	cmp	r3, r2
    351c:	f040 80b5 	bne.w	368a <loop+0x103a>
  {
    return this->msg.getMD5();
  }
  virtual int getEndpointType() override
  {
    return endpoint_;
    3520:	6dc5      	ldr	r5, [r0, #92]	; 0x5c
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    3522:	2d63      	cmp	r5, #99	; 0x63
    3524:	dd04      	ble.n	3530 <loop+0xee0>
    3526:	f894 34f8 	ldrb.w	r3, [r4, #1272]	; 0x4f8
    352a:	2b00      	cmp	r3, #0
    352c:	f000 809a 	beq.w	3664 <loop+0x1014>

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    3530:	f3c9 2307 	ubfx	r3, r9, #8, #8
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    3534:	4640      	mov	r0, r8
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    3536:	f884 9223 	strb.w	r9, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    353a:	f884 3224 	strb.w	r3, [r4, #548]	; 0x224
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    353e:	f005 fe9f 	bl	9280 <strlen>
    3542:	4681      	mov	r9, r0
      arr[i] = (var >> (8 * i));
    3544:	ea4f 6319 	mov.w	r3, r9, lsr #24
    3548:	0a02      	lsrs	r2, r0, #8
    354a:	0c00      	lsrs	r0, r0, #16
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
    354c:	4641      	mov	r1, r8
    354e:	f884 3228 	strb.w	r3, [r4, #552]	; 0x228
    3552:	f884 2226 	strb.w	r2, [r4, #550]	; 0x226
    3556:	f884 0227 	strb.w	r0, [r4, #551]	; 0x227
    355a:	464a      	mov	r2, r9
    355c:	f884 9225 	strb.w	r9, [r4, #549]	; 0x225
    3560:	484e      	ldr	r0, [pc, #312]	; (369c <loop+0x104c>)
    3562:	f001 fa8d 	bl	4a80 <memcpy>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
    3566:	4638      	mov	r0, r7
    3568:	f005 fe8a 	bl	9280 <strlen>
    356c:	f209 2129 	addw	r1, r9, #553	; 0x229
    3570:	4602      	mov	r2, r0
    3572:	4421      	add	r1, r4
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
    3574:	f109 0806 	add.w	r8, r9, #6
      uint32_t length_message_type = strlen(this->message_type);
    3578:	2300      	movs	r3, #0
    357a:	fa22 f003 	lsr.w	r0, r2, r3
    357e:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3580:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
    3582:	f801 0b01 	strb.w	r0, [r1], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3586:	d1f8      	bne.n	357a <loop+0xf2a>
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    3588:	4b45      	ldr	r3, [pc, #276]	; (36a0 <loop+0x1050>)
    358a:	f108 0804 	add.w	r8, r8, #4
    358e:	eb03 0008 	add.w	r0, r3, r8
    3592:	4639      	mov	r1, r7
      offset += length_message_type;
    3594:	4490      	add	r8, r2
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    3596:	f001 fa73 	bl	4a80 <memcpy>
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
    359a:	4630      	mov	r0, r6
    359c:	f005 fe70 	bl	9280 <strlen>
    35a0:	f208 2223 	addw	r2, r8, #547	; 0x223
    35a4:	4607      	mov	r7, r0
    35a6:	4422      	add	r2, r4
    35a8:	2300      	movs	r3, #0
      arr[i] = (var >> (8 * i));
    35aa:	fa27 f103 	lsr.w	r1, r7, r3
    35ae:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    35b0:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
    35b2:	f802 1b01 	strb.w	r1, [r2], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    35b6:	d1f8      	bne.n	35aa <loop+0xf5a>
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    35b8:	4b39      	ldr	r3, [pc, #228]	; (36a0 <loop+0x1050>)
    35ba:	f108 0804 	add.w	r8, r8, #4
    35be:	463a      	mov	r2, r7
      offset += length_md5sum;
    35c0:	4447      	add	r7, r8
      memcpy(outbuffer + offset, this->message_type, length_message_type);
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    35c2:	4631      	mov	r1, r6
    35c4:	eb03 0008 	add.w	r0, r3, r8
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
    35c8:	1d3e      	adds	r6, r7, #4
      memcpy(outbuffer + offset, this->message_type, length_message_type);
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    35ca:	f001 fa59 	bl	4a80 <memcpy>
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    35ce:	fa5f fc86 	uxtb.w	ip, r6
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    35d2:	f3c6 2e07 	ubfx	lr, r6, #8, #8
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    35d6:	19e3      	adds	r3, r4, r7
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    35d8:	eb0c 000e 	add.w	r0, ip, lr
    35dc:	2200      	movs	r2, #0
    35de:	43c0      	mvns	r0, r0
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    35e0:	2102      	movs	r1, #2
    35e2:	f883 1224 	strb.w	r1, [r3, #548]	; 0x224
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    35e6:	f883 2223 	strb.w	r2, [r3, #547]	; 0x223
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
    35ea:	f883 2225 	strb.w	r2, [r3, #549]	; 0x225
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
    35ee:	f883 2226 	strb.w	r2, [r3, #550]	; 0x226
    35f2:	f884 0220 	strb.w	r0, [r4, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    35f6:	b2e8      	uxtb	r0, r5
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    35f8:	f345 2507 	sbfx	r5, r5, #8, #8
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    35fc:	23fe      	movs	r3, #254	; 0xfe

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    35fe:	21ff      	movs	r1, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3600:	f884 5222 	strb.w	r5, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3604:	1c75      	adds	r5, r6, #1
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    3606:	f884 321d 	strb.w	r3, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    360a:	f884 c21e 	strb.w	ip, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    360e:	f884 e21f 	strb.w	lr, [r4, #543]	; 0x21f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3612:	f884 121c 	strb.w	r1, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3616:	f884 0221 	strb.w	r0, [r4, #545]	; 0x221
      memcpy(outbuffer + offset, this->message_type, length_message_type);
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    361a:	4b28      	ldr	r3, [pc, #160]	; (36bc <loop+0x106c>)
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    361c:	f2c0 8129 	blt.w	3872 <loop+0x1222>
    3620:	f207 2126 	addw	r1, r7, #550	; 0x226
    3624:	4419      	add	r1, r3
    3626:	f203 2321 	addw	r3, r3, #545	; 0x221
    362a:	e001      	b.n	3630 <loop+0xfe0>
    362c:	f813 0f01 	ldrb.w	r0, [r3, #1]!
    3630:	4299      	cmp	r1, r3
      chk += message_out[i];
    3632:	4402      	add	r2, r0
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3634:	d1fa      	bne.n	362c <loop+0xfdc>
    3636:	43d3      	mvns	r3, r2
    3638:	b2db      	uxtb	r3, r3
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    363a:	19a1      	adds	r1, r4, r6
    363c:	f106 0208 	add.w	r2, r6, #8

    if (l <= OUTPUT_SIZE)
    3640:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3644:	f881 3223 	strb.w	r3, [r1, #547]	; 0x223
    3648:	4f1c      	ldr	r7, [pc, #112]	; (36bc <loop+0x106c>)

    if (l <= OUTPUT_SIZE)
    364a:	f300 808d 	bgt.w	3768 <loop+0x1118>
    364e:	6878      	ldr	r0, [r7, #4]
    3650:	4915      	ldr	r1, [pc, #84]	; (36a8 <loop+0x1058>)
    3652:	6803      	ldr	r3, [r0, #0]
    3654:	685b      	ldr	r3, [r3, #4]
    3656:	428b      	cmp	r3, r1
    3658:	d13b      	bne.n	36d2 <loop+0x1082>
    365a:	4611      	mov	r1, r2
    365c:	f507 7007 	add.w	r0, r7, #540	; 0x21c
    3660:	f002 fd26 	bl	60b0 <usb_serial_write>
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
        ti.buffer_size = OUTPUT_SIZE;
        publish(publishers[i]->getEndpointType(), &ti);
      }
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    3664:	45d3      	cmp	fp, sl
    3666:	f47f af39 	bne.w	34dc <loop+0xe8c>
    366a:	f8dd b008 	ldr.w	fp, [sp, #8]
        {
          if (topic_ == TopicInfo::ID_PUBLISHER)
          {
            requestSyncTime();
            negotiateTopics();
            last_sync_time = c_time;
    366e:	f8c4 b4fc 	str.w	fp, [r4, #1276]	; 0x4fc
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
      }
    }
    configured_ = true;
    3672:	2301      	movs	r3, #1
          if (topic_ == TopicInfo::ID_PUBLISHER)
          {
            requestSyncTime();
            negotiateTopics();
            last_sync_time = c_time;
            last_sync_receive_time = c_time;
    3674:	f8c4 b500 	str.w	fp, [r4, #1280]	; 0x500
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
      }
    }
    configured_ = true;
    3678:	f884 34f8 	strb.w	r3, [r4, #1272]	; 0x4f8
    367c:	f7ff b847 	b.w	270e <loop+0xbe>
            configured_ = false;
          }
          else
          {
            if (subscribers[topic_ - 100])
              subscribers[topic_ - 100]->callback(message_in);
    3680:	f109 011c 	add.w	r1, r9, #28
    3684:	4798      	blx	r3
    3686:	f7ff b813 	b.w	26b0 <loop+0x60>
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
    368a:	4798      	blx	r3
    368c:	4605      	mov	r5, r0
    368e:	e748      	b.n	3522 <loop+0xed2>
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
    3690:	4e0b      	ldr	r6, [pc, #44]	; (36c0 <loop+0x1070>)
    3692:	e740      	b.n	3516 <loop+0xec6>
    {
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
    3694:	4f0b      	ldr	r7, [pc, #44]	; (36c4 <loop+0x1074>)
    3696:	e734      	b.n	3502 <loop+0xeb2>
    3698:	1fff2170 	.word	0x1fff2170
    369c:	1fff1f81 	.word	0x1fff1f81
    36a0:	1fff1f7b 	.word	0x1fff1f7b
    36a4:	1fff1f79 	.word	0x1fff1f79
    36a8:	00000ea9 	.word	0x00000ea9
    36ac:	1fff1f74 	.word	0x1fff1f74
    36b0:	0000097d 	.word	0x0000097d
    36b4:	00000985 	.word	0x00000985
    36b8:	00000979 	.word	0x00000979
    36bc:	1fff1d58 	.word	0x1fff1d58
    36c0:	000099b8 	.word	0x000099b8
    36c4:	000099a4 	.word	0x000099a4
    36c8:	1fff2238 	.word	0x1fff2238
    36cc:	496a      	ldr	r1, [pc, #424]	; (3878 <loop+0x1228>)
    36ce:	4798      	blx	r3
    36d0:	e6fb      	b.n	34ca <loop+0xe7a>
    36d2:	f507 7107 	add.w	r1, r7, #540	; 0x21c
    36d6:	4798      	blx	r3
    36d8:	e7c4      	b.n	3664 <loop+0x1014>
    36da:	f8df e1a4 	ldr.w	lr, [pc, #420]	; 3880 <loop+0x1230>
    36de:	4f67      	ldr	r7, [pc, #412]	; (387c <loop+0x122c>)
    36e0:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    36e4:	c70f      	stmia	r7!, {r0, r1, r2, r3}
    36e6:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    36ea:	c70f      	stmia	r7!, {r0, r1, r2, r3}
    36ec:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    36f0:	c70f      	stmia	r7!, {r0, r1, r2, r3}
    36f2:	e89e 0003 	ldmia.w	lr, {r0, r1}
      arr[i] = (var >> (8 * i));
    36f6:	2300      	movs	r3, #0
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    36f8:	f04f 0c03 	mov.w	ip, #3
    36fc:	f04f 0e38 	mov.w	lr, #56	; 0x38

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3700:	22ff      	movs	r2, #255	; 0xff
    3702:	f885 c223 	strb.w	ip, [r5, #547]	; 0x223
    3706:	f885 e224 	strb.w	lr, [r5, #548]	; 0x224
    message_out[1] = PROTOCOL_VER;
    370a:	f04f 0cfe 	mov.w	ip, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    370e:	f04f 0e3d 	mov.w	lr, #61	; 0x3d
    3712:	f885 3225 	strb.w	r3, [r5, #549]	; 0x225
    3716:	f885 3226 	strb.w	r3, [r5, #550]	; 0x226
    371a:	f885 3227 	strb.w	r3, [r5, #551]	; 0x227
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    371e:	e887 0003 	stmia.w	r7, {r0, r1}
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3722:	20c2      	movs	r0, #194	; 0xc2

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3724:	f885 221c 	strb.w	r2, [r5, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3728:	2207      	movs	r2, #7
    372a:	f1a7 0137 	sub.w	r1, r7, #55	; 0x37

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    372e:	f885 321f 	strb.w	r3, [r5, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3732:	f885 3222 	strb.w	r3, [r5, #546]	; 0x222
    3736:	3707      	adds	r7, #7
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    3738:	f885 c21d 	strb.w	ip, [r5, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    373c:	f885 e21e 	strb.w	lr, [r5, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3740:	f885 0220 	strb.w	r0, [r5, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3744:	f885 2221 	strb.w	r2, [r5, #545]	; 0x221
    3748:	e001      	b.n	374e <loop+0x10fe>
    374a:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    374e:	428f      	cmp	r7, r1
      chk += message_out[i];
    3750:	4413      	add	r3, r2
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3752:	d1fa      	bne.n	374a <loop+0x10fa>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3754:	43db      	mvns	r3, r3
    3756:	6860      	ldr	r0, [r4, #4]
    3758:	f884 3260 	strb.w	r3, [r4, #608]	; 0x260
    375c:	6803      	ldr	r3, [r0, #0]
    375e:	4946      	ldr	r1, [pc, #280]	; (3878 <loop+0x1228>)
    3760:	685b      	ldr	r3, [r3, #4]
    3762:	2245      	movs	r2, #69	; 0x45
    3764:	4798      	blx	r3
    3766:	e6b0      	b.n	34ca <loop+0xe7a>
    3768:	4d45      	ldr	r5, [pc, #276]	; (3880 <loop+0x1230>)
    376a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    376c:	f507 760a 	add.w	r6, r7, #552	; 0x228
    3770:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    3772:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    3774:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    3776:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    3778:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    377a:	e895 0003 	ldmia.w	r5, {r0, r1}
    377e:	2200      	movs	r2, #0
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    3780:	2503      	movs	r5, #3
    3782:	2338      	movs	r3, #56	; 0x38
    3784:	f887 5223 	strb.w	r5, [r7, #547]	; 0x223
    3788:	f887 3224 	strb.w	r3, [r7, #548]	; 0x224

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    378c:	f04f 0cff 	mov.w	ip, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    3790:	f04f 0efe 	mov.w	lr, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3794:	253d      	movs	r5, #61	; 0x3d
    3796:	f887 2225 	strb.w	r2, [r7, #549]	; 0x225
    379a:	f887 2226 	strb.w	r2, [r7, #550]	; 0x226
    379e:	f887 2227 	strb.w	r2, [r7, #551]	; 0x227
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    37a2:	f04f 08c2 	mov.w	r8, #194	; 0xc2
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    37a6:	e886 0003 	stmia.w	r6, {r0, r1}
    message_out[5] = (uint8_t)((int16_t)id & 255);
    37aa:	2107      	movs	r1, #7

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    37ac:	f887 221f 	strb.w	r2, [r7, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    37b0:	f887 2222 	strb.w	r2, [r7, #546]	; 0x222
    37b4:	f1a6 0037 	sub.w	r0, r6, #55	; 0x37
    37b8:	1df3      	adds	r3, r6, #7

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    37ba:	f887 c21c 	strb.w	ip, [r7, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    37be:	f887 e21d 	strb.w	lr, [r7, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    37c2:	f887 521e 	strb.w	r5, [r7, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    37c6:	f887 8220 	strb.w	r8, [r7, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    37ca:	f887 1221 	strb.w	r1, [r7, #545]	; 0x221
    37ce:	e001      	b.n	37d4 <loop+0x1184>
    37d0:	f810 1f01 	ldrb.w	r1, [r0, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    37d4:	4283      	cmp	r3, r0
      chk += message_out[i];
    37d6:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    37d8:	d1fa      	bne.n	37d0 <loop+0x1180>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    37da:	43d2      	mvns	r2, r2
    37dc:	6860      	ldr	r0, [r4, #4]
    37de:	f884 2260 	strb.w	r2, [r4, #608]	; 0x260
    37e2:	6803      	ldr	r3, [r0, #0]
    37e4:	4924      	ldr	r1, [pc, #144]	; (3878 <loop+0x1228>)
    37e6:	685b      	ldr	r3, [r3, #4]
    37e8:	2245      	movs	r2, #69	; 0x45
    37ea:	4798      	blx	r3
    37ec:	e73a      	b.n	3664 <loop+0x1014>
    37ee:	4f24      	ldr	r7, [pc, #144]	; (3880 <loop+0x1230>)
    37f0:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    37f2:	f50e 750a 	add.w	r5, lr, #552	; 0x228
    37f6:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    37f8:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    37fa:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    37fc:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    37fe:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    3800:	e897 0003 	ldmia.w	r7, {r0, r1}
    3804:	2300      	movs	r3, #0
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    3806:	f04f 0c03 	mov.w	ip, #3
    380a:	2738      	movs	r7, #56	; 0x38

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    380c:	22ff      	movs	r2, #255	; 0xff
    380e:	f88e c223 	strb.w	ip, [lr, #547]	; 0x223
    3812:	f88e 7224 	strb.w	r7, [lr, #548]	; 0x224
    message_out[1] = PROTOCOL_VER;
    3816:	f04f 0cfe 	mov.w	ip, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    381a:	273d      	movs	r7, #61	; 0x3d
    381c:	f88e 3225 	strb.w	r3, [lr, #549]	; 0x225
    3820:	f88e 3226 	strb.w	r3, [lr, #550]	; 0x226
    3824:	f88e 3227 	strb.w	r3, [lr, #551]	; 0x227
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    3828:	e885 0003 	stmia.w	r5, {r0, r1}
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    382c:	20c2      	movs	r0, #194	; 0xc2

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    382e:	f88e 221c 	strb.w	r2, [lr, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3832:	2207      	movs	r2, #7
    3834:	f1a5 0137 	sub.w	r1, r5, #55	; 0x37

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3838:	f88e 321f 	strb.w	r3, [lr, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    383c:	f88e 3222 	strb.w	r3, [lr, #546]	; 0x222
    3840:	3507      	adds	r5, #7
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    3842:	f88e c21d 	strb.w	ip, [lr, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3846:	f88e 721e 	strb.w	r7, [lr, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    384a:	f88e 0220 	strb.w	r0, [lr, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    384e:	f88e 2221 	strb.w	r2, [lr, #545]	; 0x221
    3852:	e001      	b.n	3858 <loop+0x1208>
    3854:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3858:	42a9      	cmp	r1, r5
      chk += message_out[i];
    385a:	4413      	add	r3, r2
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    385c:	d1fa      	bne.n	3854 <loop+0x1204>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    385e:	43db      	mvns	r3, r3
    3860:	6860      	ldr	r0, [r4, #4]
    3862:	f884 3260 	strb.w	r3, [r4, #608]	; 0x260
    3866:	6803      	ldr	r3, [r0, #0]
    3868:	4903      	ldr	r1, [pc, #12]	; (3878 <loop+0x1228>)
    386a:	685b      	ldr	r3, [r3, #4]
    386c:	2245      	movs	r2, #69	; 0x45
    386e:	4798      	blx	r3
    3870:	e567      	b.n	3342 <loop+0xcf2>
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3872:	460b      	mov	r3, r1
    3874:	e6e1      	b.n	363a <loop+0xfea>
    3876:	bf00      	nop
    3878:	1fff1f74 	.word	0x1fff1f74
    387c:	1fff1f80 	.word	0x1fff1f80
    3880:	00009a1c 	.word	0x00009a1c

00003884 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()>:
    bool v = advertise(srv.pub);
    bool w = subscribe(srv);
    return v && w;
  }

  void negotiateTopics()
    3884:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3888:	b08d      	sub	sp, #52	; 0x34
    TopicInfo():
      topic_id(0),
      topic_name(""),
      message_type(""),
      md5sum(""),
      buffer_size(0)
    388a:	4acb      	ldr	r2, [pc, #812]	; (3bb8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x334>)
    388c:	4bcb      	ldr	r3, [pc, #812]	; (3bbc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x338>)
    388e:	9206      	str	r2, [sp, #24]
    3890:	2200      	movs	r2, #0
    3892:	4604      	mov	r4, r0
    3894:	f500 6583 	add.w	r5, r0, #1048	; 0x418
    3898:	f200 467c 	addw	r6, r0, #1148	; 0x47c
    389c:	f8ad 201c 	strh.w	r2, [sp, #28]
    38a0:	920b      	str	r2, [sp, #44]	; 0x2c
    38a2:	9308      	str	r3, [sp, #32]
    38a4:	9309      	str	r3, [sp, #36]	; 0x24
    38a6:	930a      	str	r3, [sp, #40]	; 0x28
  {
    rosserial_msgs::TopicInfo ti;
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
    38a8:	f855 3f04 	ldr.w	r3, [r5, #4]!
    38ac:	2b00      	cmp	r3, #0
    38ae:	f000 80c2 	beq.w	3a36 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    38b2:	6858      	ldr	r0, [r3, #4]
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
    38b4:	681f      	ldr	r7, [r3, #0]
        ti.message_type = (char *) publishers[i]->msg_->getType();
    38b6:	6801      	ldr	r1, [r0, #0]
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
    38b8:	689a      	ldr	r2, [r3, #8]
        ti.topic_name = (char *) publishers[i]->topic_;
    38ba:	9708      	str	r7, [sp, #32]
        ti.message_type = (char *) publishers[i]->msg_->getType();
    38bc:	688b      	ldr	r3, [r1, #8]
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
    38be:	f8ad 201c 	strh.w	r2, [sp, #28]
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    38c2:	4798      	blx	r3
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    38c4:	682b      	ldr	r3, [r5, #0]
    {
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
    38c6:	9009      	str	r0, [sp, #36]	; 0x24
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    38c8:	6858      	ldr	r0, [r3, #4]
    38ca:	6803      	ldr	r3, [r0, #0]
    38cc:	68db      	ldr	r3, [r3, #12]
    38ce:	4798      	blx	r3
        ti.buffer_size = OUTPUT_SIZE;
        publish(publishers[i]->getEndpointType(), &ti);
    38d0:	6823      	ldr	r3, [r4, #0]
    38d2:	6829      	ldr	r1, [r5, #0]
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    38d4:	900a      	str	r0, [sp, #40]	; 0x28
        ti.buffer_size = OUTPUT_SIZE;
    38d6:	f44f 7200 	mov.w	r2, #512	; 0x200
        publish(publishers[i]->getEndpointType(), &ti);
    38da:	681b      	ldr	r3, [r3, #0]
    38dc:	f8d1 8010 	ldr.w	r8, [r1, #16]
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
        ti.buffer_size = OUTPUT_SIZE;
    38e0:	920b      	str	r2, [sp, #44]	; 0x2c
    38e2:	4ab7      	ldr	r2, [pc, #732]	; (3bc0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x33c>)
    38e4:	4293      	cmp	r3, r2
      if (publishers[i] != 0) // non-empty slot
      {
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
    38e6:	4682      	mov	sl, r0
    38e8:	f040 81a9 	bne.w	3c3e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x3ba>
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    38ec:	f1b8 0f63 	cmp.w	r8, #99	; 0x63
    38f0:	dd04      	ble.n	38fc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x78>
    38f2:	f894 34f8 	ldrb.w	r3, [r4, #1272]	; 0x4f8
    38f6:	2b00      	cmp	r3, #0
    38f8:	f000 809d 	beq.w	3a36 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    38fc:	f8bd 301c 	ldrh.w	r3, [sp, #28]
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    3900:	f8dd 9020 	ldr.w	r9, [sp, #32]
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    3904:	f884 3223 	strb.w	r3, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    3908:	0a1b      	lsrs	r3, r3, #8
    390a:	f884 3224 	strb.w	r3, [r4, #548]	; 0x224
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    390e:	4648      	mov	r0, r9
    3910:	f005 fcb6 	bl	9280 <strlen>
    3914:	4607      	mov	r7, r0
    3916:	0e3b      	lsrs	r3, r7, #24
    3918:	0c3a      	lsrs	r2, r7, #16
    391a:	0a00      	lsrs	r0, r0, #8
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
    391c:	4649      	mov	r1, r9
    391e:	f884 3228 	strb.w	r3, [r4, #552]	; 0x228
    3922:	f884 7225 	strb.w	r7, [r4, #549]	; 0x225
    3926:	f884 0226 	strb.w	r0, [r4, #550]	; 0x226
    392a:	f884 2227 	strb.w	r2, [r4, #551]	; 0x227
    392e:	f204 2029 	addw	r0, r4, #553	; 0x229
    3932:	463a      	mov	r2, r7
    3934:	f001 f8a4 	bl	4a80 <memcpy>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
    3938:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
    393c:	4658      	mov	r0, fp
    393e:	f005 fc9f 	bl	9280 <strlen>
      return 0;

    /* serialize message */
    int l = msg->serialize(message_out + 7);
    3942:	f204 2923 	addw	r9, r4, #547	; 0x223
    3946:	1d79      	adds	r1, r7, #5
    3948:	4602      	mov	r2, r0
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
    394a:	3706      	adds	r7, #6
    394c:	4449      	add	r1, r9
      uint32_t length_message_type = strlen(this->message_type);
    394e:	2300      	movs	r3, #0
    3950:	fa22 f003 	lsr.w	r0, r2, r3
    3954:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3956:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
    3958:	f801 0f01 	strb.w	r0, [r1, #1]!

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    395c:	d1f8      	bne.n	3950 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0xcc>
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    395e:	3704      	adds	r7, #4
    3960:	4659      	mov	r1, fp
    3962:	eb09 0007 	add.w	r0, r9, r7
      offset += length_message_type;
    3966:	4417      	add	r7, r2
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    3968:	f001 f88a 	bl	4a80 <memcpy>
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
    396c:	4650      	mov	r0, sl
    396e:	f005 fc87 	bl	9280 <strlen>
    3972:	eb09 0307 	add.w	r3, r9, r7
    3976:	4683      	mov	fp, r0
    3978:	2200      	movs	r2, #0
      arr[i] = (var >> (8 * i));
    397a:	fa2b f102 	lsr.w	r1, fp, r2
    397e:	3208      	adds	r2, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3980:	2a20      	cmp	r2, #32
      arr[i] = (var >> (8 * i));
    3982:	f803 1b01 	strb.w	r1, [r3], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3986:	d1f8      	bne.n	397a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0xf6>
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    3988:	3704      	adds	r7, #4
    398a:	4651      	mov	r1, sl
    398c:	eb09 0007 	add.w	r0, r9, r7
    3990:	465a      	mov	r2, fp
    3992:	f001 f875 	bl	4a80 <memcpy>
      offset += length_md5sum;
    3996:	eb0b 0307 	add.w	r3, fp, r7
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
    399a:	1d1f      	adds	r7, r3, #4
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    399c:	eb09 0103 	add.w	r1, r9, r3

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    39a0:	fa5f fa87 	uxtb.w	sl, r7
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    39a4:	f3c7 2c07 	ubfx	ip, r7, #8, #8
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    39a8:	2200      	movs	r2, #0
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    39aa:	eb0a 0e0c 	add.w	lr, sl, ip
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    39ae:	f04f 0b02 	mov.w	fp, #2
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    39b2:	f809 2003 	strb.w	r2, [r9, r3]
    39b6:	ea6f 0e0e 	mvn.w	lr, lr
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
    39ba:	708a      	strb	r2, [r1, #2]
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
    39bc:	70ca      	strb	r2, [r1, #3]
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    39be:	f881 b001 	strb.w	fp, [r1, #1]

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    39c2:	20ff      	movs	r0, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    39c4:	fa5f f188 	uxtb.w	r1, r8
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    39c8:	f04f 09fe 	mov.w	r9, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    39cc:	f348 2807 	sbfx	r8, r8, #8, #8

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    39d0:	f1b7 3fff 	cmp.w	r7, #4294967295	; 0xffffffff
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    39d4:	f884 e220 	strb.w	lr, [r4, #544]	; 0x220
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    39d8:	f884 a21e 	strb.w	sl, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    39dc:	f884 c21f 	strb.w	ip, [r4, #543]	; 0x21f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    39e0:	f884 021c 	strb.w	r0, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    39e4:	f884 921d 	strb.w	r9, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    39e8:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    39ec:	f884 8222 	strb.w	r8, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    39f0:	f2c0 81d0 	blt.w	3d94 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x510>
    39f4:	f203 2326 	addw	r3, r3, #550	; 0x226
    39f8:	18e0      	adds	r0, r4, r3
    39fa:	f204 2321 	addw	r3, r4, #545	; 0x221
    39fe:	e001      	b.n	3a04 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x180>
    3a00:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    3a04:	4298      	cmp	r0, r3
      chk += message_out[i];
    3a06:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3a08:	d1fa      	bne.n	3a00 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x17c>
    3a0a:	43d2      	mvns	r2, r2
    3a0c:	b2d2      	uxtb	r2, r2
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3a0e:	19e3      	adds	r3, r4, r7
    3a10:	f107 0108 	add.w	r1, r7, #8

    if (l <= OUTPUT_SIZE)
    3a14:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3a18:	f883 2223 	strb.w	r2, [r3, #547]	; 0x223

    if (l <= OUTPUT_SIZE)
    3a1c:	f300 8123 	bgt.w	3c66 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x3e2>
    3a20:	6867      	ldr	r7, [r4, #4]
    3a22:	4a68      	ldr	r2, [pc, #416]	; (3bc4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x340>)
    3a24:	683b      	ldr	r3, [r7, #0]
    3a26:	685b      	ldr	r3, [r3, #4]
    3a28:	4293      	cmp	r3, r2
    {
      hardware_.write(message_out, l);
    3a2a:	f504 7007 	add.w	r0, r4, #540	; 0x21c
    3a2e:	f040 8110 	bne.w	3c52 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x3ce>
    3a32:	f002 fb3d 	bl	60b0 <usb_serial_write>

  void negotiateTopics()
  {
    rosserial_msgs::TopicInfo ti;
    int i;
    for (i = 0; i < MAX_PUBLISHERS; i++)
    3a36:	42ae      	cmp	r6, r5
    3a38:	f47f af36 	bne.w	38a8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x24>
    3a3c:	f504 699c 	add.w	r9, r4, #1248	; 0x4e0
        publish(publishers[i]->getEndpointType(), &ti);
      }
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
    3a40:	f856 0f04 	ldr.w	r0, [r6, #4]!
    3a44:	2800      	cmp	r0, #0
    3a46:	f000 80e4 	beq.w	3c12 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x38e>
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
    3a4a:	6803      	ldr	r3, [r0, #0]
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
    3a4c:	6882      	ldr	r2, [r0, #8]
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
    3a4e:	6841      	ldr	r1, [r0, #4]
        ti.topic_name = (char *) subscribers[i]->topic_;
    3a50:	9208      	str	r2, [sp, #32]
        ti.message_type = (char *) subscribers[i]->getMsgType();
    3a52:	689a      	ldr	r2, [r3, #8]
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    {
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
    3a54:	f8ad 101c 	strh.w	r1, [sp, #28]
    3a58:	495b      	ldr	r1, [pc, #364]	; (3bc8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x344>)
    3a5a:	428a      	cmp	r2, r1
    3a5c:	f040 80f4 	bne.w	3c48 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x3c4>
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
    3a60:	4a5a      	ldr	r2, [pc, #360]	; (3bcc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x348>)
    3a62:	9209      	str	r2, [sp, #36]	; 0x24
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
    3a64:	68da      	ldr	r2, [r3, #12]
    3a66:	495a      	ldr	r1, [pc, #360]	; (3bd0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x34c>)
    3a68:	428a      	cmp	r2, r1
    3a6a:	f040 80e3 	bne.w	3c34 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x3b0>
    3a6e:	4a59      	ldr	r2, [pc, #356]	; (3bd4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x350>)
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
    3a70:	6821      	ldr	r1, [r4, #0]
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
    3a72:	920a      	str	r2, [sp, #40]	; 0x28
        ti.buffer_size = INPUT_SIZE;
    3a74:	f44f 7200 	mov.w	r2, #512	; 0x200
        publish(subscribers[i]->getEndpointType(), &ti);
    3a78:	685b      	ldr	r3, [r3, #4]
    3a7a:	680d      	ldr	r5, [r1, #0]
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
    3a7c:	920b      	str	r2, [sp, #44]	; 0x2c
    3a7e:	4a56      	ldr	r2, [pc, #344]	; (3bd8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x354>)
    3a80:	4293      	cmp	r3, r2
    3a82:	f040 80d4 	bne.w	3c2e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x3aa>
    3a86:	f8d0 805c 	ldr.w	r8, [r0, #92]	; 0x5c
    3a8a:	4f4d      	ldr	r7, [pc, #308]	; (3bc0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x33c>)
    3a8c:	42bd      	cmp	r5, r7
    3a8e:	f040 80c9 	bne.w	3c24 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x3a0>
    configured_ = true;
  }

  virtual int publish(int id, const Msg * msg) override
  {
    if (id >= 100 && !configured_)
    3a92:	f1b8 0f63 	cmp.w	r8, #99	; 0x63
    3a96:	dd04      	ble.n	3aa2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x21e>
    3a98:	f894 34f8 	ldrb.w	r3, [r4, #1272]	; 0x4f8
    3a9c:	2b00      	cmp	r3, #0
    3a9e:	f000 80b8 	beq.w	3c12 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x38e>
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    3aa2:	f8bd 301c 	ldrh.w	r3, [sp, #28]
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    3aa6:	9d08      	ldr	r5, [sp, #32]
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
    3aa8:	f884 3223 	strb.w	r3, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
    3aac:	0a1b      	lsrs	r3, r3, #8
    3aae:	f884 3224 	strb.w	r3, [r4, #548]	; 0x224
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
    3ab2:	4628      	mov	r0, r5
    3ab4:	f005 fbe4 	bl	9280 <strlen>
    3ab8:	4682      	mov	sl, r0
      arr[i] = (var >> (8 * i));
    3aba:	ea4f 631a 	mov.w	r3, sl, lsr #24
    3abe:	ea4f 421a 	mov.w	r2, sl, lsr #16
    3ac2:	0a00      	lsrs	r0, r0, #8
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
    3ac4:	4629      	mov	r1, r5
    3ac6:	f884 3228 	strb.w	r3, [r4, #552]	; 0x228
    3aca:	f884 a225 	strb.w	sl, [r4, #549]	; 0x225
    3ace:	f884 0226 	strb.w	r0, [r4, #550]	; 0x226
    3ad2:	f884 2227 	strb.w	r2, [r4, #551]	; 0x227
    3ad6:	f204 2029 	addw	r0, r4, #553	; 0x229
    3ada:	4652      	mov	r2, sl
    3adc:	f000 ffd0 	bl	4a80 <memcpy>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
    3ae0:	9909      	ldr	r1, [sp, #36]	; 0x24
    3ae2:	9101      	str	r1, [sp, #4]
    3ae4:	4608      	mov	r0, r1
    3ae6:	f005 fbcb 	bl	9280 <strlen>
      return 0;

    /* serialize message */
    int l = msg->serialize(message_out + 7);
    3aea:	f204 2523 	addw	r5, r4, #547	; 0x223
    3aee:	f10a 0205 	add.w	r2, sl, #5
    3af2:	9901      	ldr	r1, [sp, #4]
    3af4:	4683      	mov	fp, r0
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
      varToArr(outbuffer + offset, length_topic_name);
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
    3af6:	f10a 0a06 	add.w	sl, sl, #6
    3afa:	442a      	add	r2, r5
      uint32_t length_message_type = strlen(this->message_type);
    3afc:	2300      	movs	r3, #0
    3afe:	fa2b f003 	lsr.w	r0, fp, r3
    3b02:	3308      	adds	r3, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3b04:	2b20      	cmp	r3, #32
      arr[i] = (var >> (8 * i));
    3b06:	f802 0f01 	strb.w	r0, [r2, #1]!

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3b0a:	d1f8      	bne.n	3afe <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x27a>
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
    3b0c:	f10a 0a04 	add.w	sl, sl, #4
    3b10:	465a      	mov	r2, fp
    3b12:	eb05 000a 	add.w	r0, r5, sl
    3b16:	f000 ffb3 	bl	4a80 <memcpy>
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
    3b1a:	990a      	ldr	r1, [sp, #40]	; 0x28
    3b1c:	9101      	str	r1, [sp, #4]
    3b1e:	4608      	mov	r0, r1
    3b20:	f005 fbae 	bl	9280 <strlen>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
      varToArr(outbuffer + offset, length_message_type);
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
      offset += length_message_type;
    3b24:	44d3      	add	fp, sl
      uint32_t length_md5sum = strlen(this->md5sum);
    3b26:	9901      	ldr	r1, [sp, #4]
    3b28:	4682      	mov	sl, r0
    3b2a:	eb05 030b 	add.w	r3, r5, fp
    3b2e:	2200      	movs	r2, #0
      arr[i] = (var >> (8 * i));
    3b30:	fa2a f002 	lsr.w	r0, sl, r2
    3b34:	3208      	adds	r2, #8

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3b36:	2a20      	cmp	r2, #32
      arr[i] = (var >> (8 * i));
    3b38:	f803 0b01 	strb.w	r0, [r3], #1

  // Copy data from variable into a byte array
  template<typename A, typename V>
  static void varToArr(A arr, const V var)
  {
    for (size_t i = 0; i < sizeof(V); i++)
    3b3c:	d1f8      	bne.n	3b30 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x2ac>
      varToArr(outbuffer + offset, length_md5sum);
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
    3b3e:	f10b 0b04 	add.w	fp, fp, #4
    3b42:	eb05 000b 	add.w	r0, r5, fp
    3b46:	4652      	mov	r2, sl
    3b48:	f000 ff9a 	bl	4a80 <memcpy>
      offset += length_md5sum;
    3b4c:	eb0a 030b 	add.w	r3, sl, fp
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
    3b50:	1d1a      	adds	r2, r3, #4
      offset += length_md5sum;
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
    3b52:	990b      	ldr	r1, [sp, #44]	; 0x2c
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
    3b54:	54e9      	strb	r1, [r5, r3]

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3b56:	fa5f fc82 	uxtb.w	ip, r2
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3b5a:	f3c2 2e07 	ubfx	lr, r2, #8, #8
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    3b5e:	441d      	add	r5, r3
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3b60:	eb0c 000e 	add.w	r0, ip, lr
    3b64:	ea4f 2b11 	mov.w	fp, r1, lsr #8
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
    3b68:	ea4f 4a11 	mov.w	sl, r1, lsr #16
    3b6c:	43c0      	mvns	r0, r0
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
    3b6e:	0e09      	lsrs	r1, r1, #24
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
    3b70:	f885 b001 	strb.w	fp, [r5, #1]
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
    3b74:	f885 a002 	strb.w	sl, [r5, #2]
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
    3b78:	70e9      	strb	r1, [r5, #3]

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3b7a:	f04f 0bff 	mov.w	fp, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3b7e:	fa5f f188 	uxtb.w	r1, r8
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    3b82:	f04f 0afe 	mov.w	sl, #254	; 0xfe
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3b86:	f348 2807 	sbfx	r8, r8, #8, #8
    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3b8a:	f884 0220 	strb.w	r0, [r4, #544]	; 0x220
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3b8e:	1c50      	adds	r0, r2, #1
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3b90:	f884 c21e 	strb.w	ip, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3b94:	f884 e21f 	strb.w	lr, [r4, #543]	; 0x21f

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3b98:	f884 b21c 	strb.w	fp, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    3b9c:	f884 a21d 	strb.w	sl, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3ba0:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3ba4:	f884 8222 	strb.w	r8, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3ba8:	db21      	blt.n	3bee <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x36a>
    3baa:	f203 2326 	addw	r3, r3, #550	; 0x226
    3bae:	18e5      	adds	r5, r4, r3
    3bb0:	2000      	movs	r0, #0
    3bb2:	f204 2321 	addw	r3, r4, #545	; 0x221
    3bb6:	e013      	b.n	3be0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x35c>
    3bb8:	000096d4 	.word	0x000096d4
    3bbc:	00009a54 	.word	0x00009a54
    3bc0:	0000196d 	.word	0x0000196d
    3bc4:	00000ea9 	.word	0x00000ea9
    3bc8:	0000097d 	.word	0x0000097d
    3bcc:	000099a4 	.word	0x000099a4
    3bd0:	00000985 	.word	0x00000985
    3bd4:	000099b8 	.word	0x000099b8
    3bd8:	00000979 	.word	0x00000979
    3bdc:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    3be0:	42ab      	cmp	r3, r5
      chk += message_out[i];
    3be2:	4408      	add	r0, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3be4:	d1fa      	bne.n	3bdc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x358>
    3be6:	ea6f 0b00 	mvn.w	fp, r0
    3bea:	fa5f fb8b 	uxtb.w	fp, fp
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3bee:	18a3      	adds	r3, r4, r2
    3bf0:	f102 0108 	add.w	r1, r2, #8

    if (l <= OUTPUT_SIZE)
    3bf4:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3bf8:	f883 b223 	strb.w	fp, [r3, #547]	; 0x223

    if (l <= OUTPUT_SIZE)
    3bfc:	dc7e      	bgt.n	3cfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x478>
    3bfe:	6865      	ldr	r5, [r4, #4]
    3c00:	4a6b      	ldr	r2, [pc, #428]	; (3db0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x52c>)
    3c02:	682b      	ldr	r3, [r5, #0]
    3c04:	685b      	ldr	r3, [r3, #4]
    3c06:	4293      	cmp	r3, r2
    {
      hardware_.write(message_out, l);
    3c08:	f504 7007 	add.w	r0, r4, #540	; 0x21c
    3c0c:	d126      	bne.n	3c5c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x3d8>
    3c0e:	f002 fa4f 	bl	60b0 <usb_serial_write>
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
        ti.buffer_size = OUTPUT_SIZE;
        publish(publishers[i]->getEndpointType(), &ti);
      }
    }
    for (i = 0; i < MAX_SUBSCRIBERS; i++)
    3c12:	45b1      	cmp	r9, r6
    3c14:	f47f af14 	bne.w	3a40 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1bc>
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
      }
    }
    configured_ = true;
    3c18:	2301      	movs	r3, #1
    3c1a:	f884 34f8 	strb.w	r3, [r4, #1272]	; 0x4f8
  }
    3c1e:	b00d      	add	sp, #52	; 0x34
    3c20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
        ti.buffer_size = INPUT_SIZE;
        publish(subscribers[i]->getEndpointType(), &ti);
    3c24:	4641      	mov	r1, r8
    3c26:	aa06      	add	r2, sp, #24
    3c28:	4620      	mov	r0, r4
    3c2a:	47a8      	blx	r5
    3c2c:	e7f1      	b.n	3c12 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x38e>
    3c2e:	4798      	blx	r3
    3c30:	4680      	mov	r8, r0
    3c32:	e72a      	b.n	3a8a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x206>
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
        ti.md5sum = (char *) subscribers[i]->getMsgMD5();
    3c34:	4790      	blx	r2
    3c36:	4602      	mov	r2, r0
    3c38:	6830      	ldr	r0, [r6, #0]
    3c3a:	6803      	ldr	r3, [r0, #0]
    3c3c:	e718      	b.n	3a70 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1ec>
        ti.topic_id = publishers[i]->id_;
        ti.topic_name = (char *) publishers[i]->topic_;
        ti.message_type = (char *) publishers[i]->msg_->getType();
        ti.md5sum = (char *) publishers[i]->msg_->getMD5();
        ti.buffer_size = OUTPUT_SIZE;
        publish(publishers[i]->getEndpointType(), &ti);
    3c3e:	4641      	mov	r1, r8
    3c40:	aa06      	add	r2, sp, #24
    3c42:	4620      	mov	r0, r4
    3c44:	4798      	blx	r3
    3c46:	e6f6      	b.n	3a36 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
    {
      if (subscribers[i] != 0) // non-empty slot
      {
        ti.topic_id = subscribers[i]->id_;
        ti.topic_name = (char *) subscribers[i]->topic_;
        ti.message_type = (char *) subscribers[i]->getMsgType();
    3c48:	4790      	blx	r2
    3c4a:	4602      	mov	r2, r0
    3c4c:	6830      	ldr	r0, [r6, #0]
    3c4e:	6803      	ldr	r3, [r0, #0]
    3c50:	e707      	b.n	3a62 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1de>
    3c52:	460a      	mov	r2, r1
    3c54:	4601      	mov	r1, r0
    3c56:	4638      	mov	r0, r7
    3c58:	4798      	blx	r3
    3c5a:	e6ec      	b.n	3a36 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
    3c5c:	460a      	mov	r2, r1
    3c5e:	4601      	mov	r1, r0
    3c60:	4628      	mov	r0, r5
    3c62:	4798      	blx	r3
    3c64:	e7d5      	b.n	3c12 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x38e>
      enum { ERROR = 3 };
      enum { FATAL = 4 };

    Log():
      level(0),
      msg("")
    3c66:	4a53      	ldr	r2, [pc, #332]	; (3db4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x530>)
    3c68:	9203      	str	r2, [sp, #12]

protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    3c6a:	2103      	movs	r1, #3
    l.msg = (char*)msg;
    3c6c:	4a52      	ldr	r2, [pc, #328]	; (3db8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x534>)
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    3c6e:	6823      	ldr	r3, [r4, #0]
protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    3c70:	9205      	str	r2, [sp, #20]

protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    3c72:	f88d 1010 	strb.w	r1, [sp, #16]
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    3c76:	681b      	ldr	r3, [r3, #0]
    3c78:	4a50      	ldr	r2, [pc, #320]	; (3dbc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x538>)
    3c7a:	4293      	cmp	r3, r2
    3c7c:	f040 8085 	bne.w	3d8a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x506>
      arr[i] = (var >> (8 * i));
    3c80:	2700      	movs	r7, #0
    3c82:	2238      	movs	r2, #56	; 0x38
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    3c84:	f884 1223 	strb.w	r1, [r4, #547]	; 0x223
    3c88:	f884 2224 	strb.w	r2, [r4, #548]	; 0x224
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    3c8c:	494a      	ldr	r1, [pc, #296]	; (3db8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x534>)
    3c8e:	f884 7225 	strb.w	r7, [r4, #549]	; 0x225
    3c92:	f884 7226 	strb.w	r7, [r4, #550]	; 0x226
    3c96:	f884 7227 	strb.w	r7, [r4, #551]	; 0x227
    3c9a:	f504 700a 	add.w	r0, r4, #552	; 0x228
    3c9e:	f000 feef 	bl	4a80 <memcpy>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3ca2:	21ff      	movs	r1, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3ca4:	203d      	movs	r0, #61	; 0x3d
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3ca6:	23c2      	movs	r3, #194	; 0xc2
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    3ca8:	f04f 0efe 	mov.w	lr, #254	; 0xfe

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3cac:	f884 121c 	strb.w	r1, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3cb0:	2107      	movs	r1, #7
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3cb2:	f884 021e 	strb.w	r0, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3cb6:	f884 3220 	strb.w	r3, [r4, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3cba:	f884 721f 	strb.w	r7, [r4, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3cbe:	f884 7222 	strb.w	r7, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    3cc2:	463a      	mov	r2, r7
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    3cc4:	f884 e21d 	strb.w	lr, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3cc8:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    3ccc:	f204 2321 	addw	r3, r4, #545	; 0x221
    3cd0:	f204 205f 	addw	r0, r4, #607	; 0x25f
    3cd4:	e001      	b.n	3cda <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x456>
    3cd6:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3cda:	4298      	cmp	r0, r3
      chk += message_out[i];
    3cdc:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3cde:	d1fa      	bne.n	3cd6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x452>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3ce0:	43d2      	mvns	r2, r2
    3ce2:	6860      	ldr	r0, [r4, #4]
    3ce4:	f884 2260 	strb.w	r2, [r4, #608]	; 0x260
    3ce8:	6803      	ldr	r3, [r0, #0]
    3cea:	4a31      	ldr	r2, [pc, #196]	; (3db0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x52c>)
    3cec:	685b      	ldr	r3, [r3, #4]
    3cee:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    3cf0:	f504 7107 	add.w	r1, r4, #540	; 0x21c
    3cf4:	d158      	bne.n	3da8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x524>
    3cf6:	4608      	mov	r0, r1
    3cf8:	2145      	movs	r1, #69	; 0x45
    3cfa:	e69a      	b.n	3a32 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1ae>
      enum { ERROR = 3 };
      enum { FATAL = 4 };

    Log():
      level(0),
      msg("")
    3cfc:	4a2d      	ldr	r2, [pc, #180]	; (3db4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x530>)
protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    3cfe:	492e      	ldr	r1, [pc, #184]	; (3db8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x534>)
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    3d00:	6823      	ldr	r3, [r4, #0]
    3d02:	9203      	str	r2, [sp, #12]

protected:
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    3d04:	2003      	movs	r0, #3
    3d06:	f88d 0010 	strb.w	r0, [sp, #16]
    l.msg = (char*)msg;
    3d0a:	9105      	str	r1, [sp, #20]
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    3d0c:	681b      	ldr	r3, [r3, #0]
    3d0e:	42bb      	cmp	r3, r7
    3d10:	d145      	bne.n	3d9e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x51a>
    3d12:	2500      	movs	r5, #0
    3d14:	2238      	movs	r2, #56	; 0x38
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
    3d16:	f884 0223 	strb.w	r0, [r4, #547]	; 0x223
    3d1a:	f884 2224 	strb.w	r2, [r4, #548]	; 0x224
    3d1e:	f884 5225 	strb.w	r5, [r4, #549]	; 0x225
    3d22:	f884 5226 	strb.w	r5, [r4, #550]	; 0x226
    3d26:	f884 5227 	strb.w	r5, [r4, #551]	; 0x227
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
      varToArr(outbuffer + offset, length_msg);
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
    3d2a:	f504 700a 	add.w	r0, r4, #552	; 0x228
    3d2e:	f000 fea7 	bl	4a80 <memcpy>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3d32:	21ff      	movs	r1, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3d34:	203d      	movs	r0, #61	; 0x3d
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3d36:	23c2      	movs	r3, #194	; 0xc2
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    3d38:	27fe      	movs	r7, #254	; 0xfe

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    3d3a:	f884 121c 	strb.w	r1, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3d3e:	2107      	movs	r1, #7
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    3d40:	f884 021e 	strb.w	r0, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    3d44:	f884 3220 	strb.w	r3, [r4, #544]	; 0x220

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    3d48:	f884 521f 	strb.w	r5, [r4, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    3d4c:	f884 5222 	strb.w	r5, [r4, #546]	; 0x222

    /* calculate checksum */
    int chk = 0;
    3d50:	462a      	mov	r2, r5
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    3d52:	f884 721d 	strb.w	r7, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    3d56:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    3d5a:	f204 2321 	addw	r3, r4, #545	; 0x221
    3d5e:	f204 205f 	addw	r0, r4, #607	; 0x25f
    3d62:	e001      	b.n	3d68 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4e4>
    3d64:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3d68:	4283      	cmp	r3, r0
      chk += message_out[i];
    3d6a:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3d6c:	d1fa      	bne.n	3d64 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x4e0>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    3d6e:	43d2      	mvns	r2, r2
    3d70:	6860      	ldr	r0, [r4, #4]
    3d72:	f884 2260 	strb.w	r2, [r4, #608]	; 0x260
    3d76:	6803      	ldr	r3, [r0, #0]
    3d78:	4a0d      	ldr	r2, [pc, #52]	; (3db0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x52c>)
    3d7a:	685b      	ldr	r3, [r3, #4]
    3d7c:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    3d7e:	f504 7107 	add.w	r1, r4, #540	; 0x21c
    3d82:	d109      	bne.n	3d98 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x514>
    3d84:	4608      	mov	r0, r1
    3d86:	2145      	movs	r1, #69	; 0x45
    3d88:	e741      	b.n	3c0e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x38a>
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    3d8a:	aa03      	add	r2, sp, #12
    3d8c:	2107      	movs	r1, #7
    3d8e:	4620      	mov	r0, r4
    3d90:	4798      	blx	r3
    3d92:	e650      	b.n	3a36 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    3d94:	4602      	mov	r2, r0
    3d96:	e63a      	b.n	3a0e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x18a>
    3d98:	2245      	movs	r2, #69	; 0x45
    3d9a:	4798      	blx	r3
    3d9c:	e739      	b.n	3c12 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x38e>
  void log(char byte, const char * msg)
  {
    rosserial_msgs::Log l;
    l.level = byte;
    l.msg = (char*)msg;
    publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
    3d9e:	aa03      	add	r2, sp, #12
    3da0:	2107      	movs	r1, #7
    3da2:	4620      	mov	r0, r4
    3da4:	4798      	blx	r3
    3da6:	e734      	b.n	3c12 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x38e>
    3da8:	2245      	movs	r2, #69	; 0x45
    3daa:	4798      	blx	r3
    3dac:	e643      	b.n	3a36 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()+0x1b2>
    3dae:	bf00      	nop
    3db0:	00000ea9 	.word	0x00000ea9
    3db4:	000096ec 	.word	0x000096ec
    3db8:	00009a1c 	.word	0x00009a1c
    3dbc:	0000196d 	.word	0x0000196d

00003dc0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()>:
  /* This function goes in your loop() function, it handles
   *  serial input and callbacks for subscribers.
   */


  virtual int spinOnce() override
    3dc0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3dc4:	4ec0      	ldr	r6, [pc, #768]	; (40c8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x308>)
    3dc6:	b097      	sub	sp, #92	; 0x5c
    3dc8:	6833      	ldr	r3, [r6, #0]
    3dca:	930a      	str	r3, [sp, #40]	; 0x28
	return ret;
    3dcc:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  {
    /* restart if timed out */
    uint32_t c_time = hardware_.time();
    if ((c_time - last_sync_receive_time) > (SYNC_SECONDS * 2200))
    3dce:	f8d0 3500 	ldr.w	r3, [r0, #1280]	; 0x500
    3dd2:	f642 22f8 	movw	r2, #11000	; 0x2af8
    3dd6:	1aeb      	subs	r3, r5, r3
    3dd8:	4293      	cmp	r3, r2
    {
      configured_ = false;
    3dda:	bf84      	itt	hi
    3ddc:	2300      	movhi	r3, #0
    3dde:	f880 34f8 	strbhi.w	r3, [r0, #1272]	; 0x4f8
    }

    /* reset if message has timed out */
    if (mode_ != MODE_FIRST_FF)
    3de2:	f8d0 34e4 	ldr.w	r3, [r0, #1252]	; 0x4e4
  /* This function goes in your loop() function, it handles
   *  serial input and callbacks for subscribers.
   */


  virtual int spinOnce() override
    3de6:	4604      	mov	r4, r0
    {
      configured_ = false;
    }

    /* reset if message has timed out */
    if (mode_ != MODE_FIRST_FF)
    3de8:	b133      	cbz	r3, 3df8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x38>
    {
      if (c_time > last_msg_timeout_time)
    3dea:	f8d0 3504 	ldr.w	r3, [r0, #1284]	; 0x504
    3dee:	42ab      	cmp	r3, r5
      {
        mode_ = MODE_FIRST_FF;
    3df0:	bf3c      	itt	cc
    3df2:	2300      	movcc	r3, #0
    3df4:	f8c0 34e4 	strcc.w	r3, [r0, #1252]	; 0x4e4
    3df8:	f8df a2d8 	ldr.w	sl, [pc, #728]	; 40d4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x314>

    /* while available buffer, read data */
    while (true)
    {
      // If a timeout has been specified, check how long spinOnce has been running.
      if (spin_timeout_ > 0)
    3dfc:	69a2      	ldr	r2, [r4, #24]
    3dfe:	b132      	cbz	r2, 3e0e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x4e>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3e00:	6833      	ldr	r3, [r6, #0]
    3e02:	930b      	str	r3, [sp, #44]	; 0x2c
	return ret;
    3e04:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
      {
        // If the maximum processing timeout has been exceeded, exit with error.
        // The next spinOnce can continue where it left off, or optionally
        // based on the application in use, the hardware buffer could be flushed
        // and start fresh.
        if ((hardware_.time() - c_time) > spin_timeout_)
    3e06:	1b5b      	subs	r3, r3, r5
    3e08:	429a      	cmp	r2, r3
    3e0a:	f0c0 81f5 	bcc.w	41f8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x438>
    3e0e:	6860      	ldr	r0, [r4, #4]
      delay(3000); 
#endif
      iostream->begin(baud_);
    }

    int read(){return iostream->read();};
    3e10:	6803      	ldr	r3, [r0, #0]
    3e12:	695b      	ldr	r3, [r3, #20]
    3e14:	4553      	cmp	r3, sl
    3e16:	f040 8139 	bne.w	408c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x2cc>
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    3e1a:	f002 f8e3 	bl	5fe4 <usb_serial_getchar>
          // Exit the spin, processing timeout exceeded.
          return SPIN_TIMEOUT;
        }
      }
      int data = hardware_.read();
      if (data < 0)
    3e1e:	2800      	cmp	r0, #0
    3e20:	f2c0 8138 	blt.w	4094 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x2d4>
        break;
      checksum_ += data;
    3e24:	f8d4 34f4 	ldr.w	r3, [r4, #1268]	; 0x4f4
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    3e28:	f8d4 24e4 	ldr.w	r2, [r4, #1252]	; 0x4e4
        }
      }
      int data = hardware_.read();
      if (data < 0)
        break;
      checksum_ += data;
    3e2c:	4403      	add	r3, r0
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    3e2e:	2a07      	cmp	r2, #7
        }
      }
      int data = hardware_.read();
      if (data < 0)
        break;
      checksum_ += data;
    3e30:	f8c4 34f4 	str.w	r3, [r4, #1268]	; 0x4f4
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
    3e34:	f000 8117 	beq.w	4066 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x2a6>
        message_in[index_++] = data;
        bytes_--;
        if (bytes_ == 0)                 /* is message complete? if so, checksum */
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_FIRST_FF)
    3e38:	b98a      	cbnz	r2, 3e5e <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x9e>
      {
        if (data == 0xff)
    3e3a:	28ff      	cmp	r0, #255	; 0xff
    3e3c:	f000 813b 	beq.w	40b6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x2f6>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3e40:	6833      	ldr	r3, [r6, #0]
    3e42:	930c      	str	r3, [sp, #48]	; 0x30
	return ret;
    3e44:	9b0c      	ldr	r3, [sp, #48]	; 0x30
        {
          mode_++;
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
        }
        else if (hardware_.time() - c_time > (SYNC_SECONDS * 1000))
    3e46:	f241 3188 	movw	r1, #5000	; 0x1388
    3e4a:	1b5b      	subs	r3, r3, r5
    3e4c:	428b      	cmp	r3, r1
    3e4e:	d9d5      	bls.n	3dfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
        {
          /* We have been stuck in spinOnce too long, return error */
          configured_ = false;
    3e50:	f884 24f8 	strb.w	r2, [r4, #1272]	; 0x4f8
          return SPIN_TIMEOUT;
    3e54:	f06f 0001 	mvn.w	r0, #1
      requestSyncTime();
      last_sync_time = c_time;
    }

    return SPIN_OK;
  }
    3e58:	b017      	add	sp, #92	; 0x5c
    3e5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          /* We have been stuck in spinOnce too long, return error */
          configured_ = false;
          return SPIN_TIMEOUT;
        }
      }
      else if (mode_ == MODE_PROTOCOL_VER)
    3e5e:	2a01      	cmp	r2, #1
    3e60:	f000 813a 	beq.w	40d8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x318>
          mode_ = MODE_FIRST_FF;
          if (configured_ == false)
            requestSyncTime();  /* send a msg back showing our protocol version */
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
    3e64:	2a02      	cmp	r2, #2
    3e66:	f000 818c 	beq.w	4182 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c2>
        bytes_ = data;
        index_ = 0;
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
    3e6a:	2a03      	cmp	r2, #3
    3e6c:	f000 8194 	beq.w	4198 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3d8>
      {
        bytes_ += data << 8;
        mode_++;
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
    3e70:	2a04      	cmp	r2, #4
    3e72:	f000 819b 	beq.w	41ac <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3ec>
        if ((checksum_ % 256) == 255)
          mode_++;
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
    3e76:	2a05      	cmp	r2, #5
    3e78:	f000 81a7 	beq.w	41ca <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x40a>
      {
        topic_ = data;
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
    3e7c:	2a06      	cmp	r2, #6
    3e7e:	f000 81ac 	beq.w	41da <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x41a>
        topic_ += data << 8;
        mode_ = MODE_MESSAGE;
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
    3e82:	2a08      	cmp	r2, #8
    3e84:	d1ba      	bne.n	3dfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
      {
        mode_ = MODE_FIRST_FF;
        if ((checksum_ % 256) == 255)
    3e86:	4a91      	ldr	r2, [pc, #580]	; (40cc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x30c>)
    3e88:	401a      	ands	r2, r3
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
    3e8a:	2300      	movs	r3, #0
        if ((checksum_ % 256) == 255)
    3e8c:	429a      	cmp	r2, r3
        if (bytes_ == 0)
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
    3e8e:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
        if ((checksum_ % 256) == 255)
    3e92:	f2c0 8214 	blt.w	42be <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x4fe>
    3e96:	2aff      	cmp	r2, #255	; 0xff
    3e98:	d1b0      	bne.n	3dfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
        {
          if (topic_ == TopicInfo::ID_PUBLISHER)
    3e9a:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
    3e9e:	2b00      	cmp	r3, #0
    3ea0:	f000 8385 	beq.w	45ae <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x7ee>
            negotiateTopics();
            last_sync_time = c_time;
            last_sync_receive_time = c_time;
            return SPIN_ERR;
          }
          else if (topic_ == TopicInfo::ID_TIME)
    3ea4:	2b0a      	cmp	r3, #10
    3ea6:	f000 8335 	beq.w	4514 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x754>
          {
            syncTime(message_in);
          }
          else if (topic_ == TopicInfo::ID_PARAMETER_REQUEST)
    3eaa:	2b06      	cmp	r3, #6
    3eac:	f000 8222 	beq.w	42f4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x534>
          {
            req_param_resp.deserialize(message_in);
            param_received = true;
          }
          else if (topic_ == TopicInfo::ID_TX_STOP)
    3eb0:	2b0b      	cmp	r3, #11
    3eb2:	f000 8209 	beq.w	42c8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x508>
          {
            configured_ = false;
          }
          else
          {
            if (subscribers[topic_ - 100])
    3eb6:	33bc      	adds	r3, #188	; 0xbc
    3eb8:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
    3ebc:	2800      	cmp	r0, #0
    3ebe:	d09d      	beq.n	3dfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
              subscribers[topic_ - 100]->callback(message_in);
    3ec0:	6803      	ldr	r3, [r0, #0]
    3ec2:	4a83      	ldr	r2, [pc, #524]	; (40d0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x310>)
    3ec4:	681b      	ldr	r3, [r3, #0]
    3ec6:	4293      	cmp	r3, r2
    3ec8:	f104 011c 	add.w	r1, r4, #28
    3ecc:	f040 836d 	bne.w	45aa <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x7ea>
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    3ed0:	f894 e01d 	ldrb.w	lr, [r4, #29]
    3ed4:	7f27      	ldrb	r7, [r4, #28]
    3ed6:	f894 901e 	ldrb.w	r9, [r4, #30]
    3eda:	f894 8021 	ldrb.w	r8, [r4, #33]	; 0x21
    3ede:	f894 1020 	ldrb.w	r1, [r4, #32]
    3ee2:	f894 c01f 	ldrb.w	ip, [r4, #31]
    3ee6:	ea47 270e 	orr.w	r7, r7, lr, lsl #8
    3eea:	f894 e022 	ldrb.w	lr, [r4, #34]	; 0x22
    3eee:	ea47 4709 	orr.w	r7, r7, r9, lsl #16
    3ef2:	ea41 2108 	orr.w	r1, r1, r8, lsl #8
    3ef6:	f894 9023 	ldrb.w	r9, [r4, #35]	; 0x23
    3efa:	ea41 410e 	orr.w	r1, r1, lr, lsl #16
    3efe:	ea47 620c 	orr.w	r2, r7, ip, lsl #24
    3f02:	ea41 6309 	orr.w	r3, r1, r9, lsl #24
      this->x = u_x.real;
    3f06:	e9c0 2308 	strd	r2, r3, [r0, #32]
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    3f0a:	f894 1025 	ldrb.w	r1, [r4, #37]	; 0x25
    3f0e:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
    3f12:	f894 c026 	ldrb.w	ip, [r4, #38]	; 0x26
    3f16:	f894 e029 	ldrb.w	lr, [r4, #41]	; 0x29
    3f1a:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
    3f1e:	f894 7027 	ldrb.w	r7, [r4, #39]	; 0x27
    3f22:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    3f26:	f894 102a 	ldrb.w	r1, [r4, #42]	; 0x2a
    3f2a:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
    3f2e:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
    3f32:	f894 c02b 	ldrb.w	ip, [r4, #43]	; 0x2b
    3f36:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    3f3a:	ea42 6207 	orr.w	r2, r2, r7, lsl #24
    3f3e:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
    3f42:	9200      	str	r2, [sp, #0]
    3f44:	9301      	str	r3, [sp, #4]
      this->y = u_y.real;
    3f46:	e9dd 2300 	ldrd	r2, r3, [sp]
    3f4a:	e9c0 230a 	strd	r2, r3, [r0, #40]	; 0x28
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    3f4e:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    3f52:	f894 102d 	ldrb.w	r1, [r4, #45]	; 0x2d
    3f56:	f894 c02e 	ldrb.w	ip, [r4, #46]	; 0x2e
    3f5a:	f894 e031 	ldrb.w	lr, [r4, #49]	; 0x31
    3f5e:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
    3f62:	f894 702f 	ldrb.w	r7, [r4, #47]	; 0x2f
    3f66:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    3f6a:	f894 1032 	ldrb.w	r1, [r4, #50]	; 0x32
    3f6e:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
    3f72:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
    3f76:	f894 c033 	ldrb.w	ip, [r4, #51]	; 0x33
    3f7a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    3f7e:	ea42 6207 	orr.w	r2, r2, r7, lsl #24
    3f82:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
    3f86:	9202      	str	r2, [sp, #8]
    3f88:	9303      	str	r3, [sp, #12]
      this->z = u_z.real;
    3f8a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    3f8e:	e9c0 230c 	strd	r2, r3, [r0, #48]	; 0x30
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    3f92:	f894 c035 	ldrb.w	ip, [r4, #53]	; 0x35
    3f96:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
    3f9a:	f894 e036 	ldrb.w	lr, [r4, #54]	; 0x36
    3f9e:	f894 7039 	ldrb.w	r7, [r4, #57]	; 0x39
    3fa2:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
    3fa6:	f894 1037 	ldrb.w	r1, [r4, #55]	; 0x37
    3faa:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
    3fae:	ea42 4e0e 	orr.w	lr, r2, lr, lsl #16
    3fb2:	f894 203a 	ldrb.w	r2, [r4, #58]	; 0x3a
    3fb6:	f894 c03b 	ldrb.w	ip, [r4, #59]	; 0x3b
    3fba:	ea43 2307 	orr.w	r3, r3, r7, lsl #8
    3fbe:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    3fc2:	ea4e 6101 	orr.w	r1, lr, r1, lsl #24
    3fc6:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
    3fca:	9104      	str	r1, [sp, #16]
    3fcc:	9305      	str	r3, [sp, #20]
      this->x = u_x.real;
    3fce:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    3fd2:	e9c0 2310 	strd	r2, r3, [r0, #64]	; 0x40
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    3fd6:	f894 103d 	ldrb.w	r1, [r4, #61]	; 0x3d
    3fda:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
    3fde:	f894 c03e 	ldrb.w	ip, [r4, #62]	; 0x3e
    3fe2:	f894 e041 	ldrb.w	lr, [r4, #65]	; 0x41
    3fe6:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
    3fea:	f894 703f 	ldrb.w	r7, [r4, #63]	; 0x3f
    3fee:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    3ff2:	f894 1042 	ldrb.w	r1, [r4, #66]	; 0x42
    3ff6:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
    3ffa:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
    3ffe:	f894 c043 	ldrb.w	ip, [r4, #67]	; 0x43
    4002:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
    4006:	ea41 630c 	orr.w	r3, r1, ip, lsl #24
    400a:	ea42 6207 	orr.w	r2, r2, r7, lsl #24
    400e:	9206      	str	r2, [sp, #24]
    4010:	9307      	str	r3, [sp, #28]
      this->y = u_y.real;
    4012:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    4016:	e9c0 2312 	strd	r2, r3, [r0, #72]	; 0x48
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
    401a:	f894 1044 	ldrb.w	r1, [r4, #68]	; 0x44
    401e:	f894 2045 	ldrb.w	r2, [r4, #69]	; 0x45
    4022:	f894 8046 	ldrb.w	r8, [r4, #70]	; 0x46
    4026:	f894 7048 	ldrb.w	r7, [r4, #72]	; 0x48
    402a:	f894 3049 	ldrb.w	r3, [r4, #73]	; 0x49
    402e:	f894 e04a 	ldrb.w	lr, [r4, #74]	; 0x4a
    4032:	f894 c047 	ldrb.w	ip, [r4, #71]	; 0x47
    4036:	ea41 2202 	orr.w	r2, r1, r2, lsl #8
    403a:	ea47 2303 	orr.w	r3, r7, r3, lsl #8
    403e:	f894 104b 	ldrb.w	r1, [r4, #75]	; 0x4b
    4042:	ea42 4208 	orr.w	r2, r2, r8, lsl #16
    4046:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
    404a:	ea42 620c 	orr.w	r2, r2, ip, lsl #24
    404e:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    4052:	9208      	str	r2, [sp, #32]
    4054:	9309      	str	r3, [sp, #36]	; 0x24
      this->z = u_z.real;
    4056:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
  };

  virtual void callback(unsigned char* data) override
  {
    msg.deserialize(data);
    this->cb_(msg);
    405a:	6d81      	ldr	r1, [r0, #88]	; 0x58
    405c:	e9c0 2314 	strd	r2, r3, [r0, #80]	; 0x50
    4060:	3010      	adds	r0, #16
    4062:	4788      	blx	r1
    4064:	e6ca      	b.n	3dfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
      if (data < 0)
        break;
      checksum_ += data;
      if (mode_ == MODE_MESSAGE)          /* message data being recieved */
      {
        message_in[index_++] = data;
    4066:	f8d4 34f0 	ldr.w	r3, [r4, #1264]	; 0x4f0
    406a:	18e2      	adds	r2, r4, r3
    406c:	3301      	adds	r3, #1
    406e:	f8c4 34f0 	str.w	r3, [r4, #1264]	; 0x4f0
    4072:	7710      	strb	r0, [r2, #28]
        bytes_--;
    4074:	f8d4 34e8 	ldr.w	r3, [r4, #1256]	; 0x4e8
    4078:	3b01      	subs	r3, #1
    407a:	f8c4 34e8 	str.w	r3, [r4, #1256]	; 0x4e8
        if (bytes_ == 0)                 /* is message complete? if so, checksum */
    407e:	2b00      	cmp	r3, #0
    4080:	f47f aebc 	bne.w	3dfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
          mode_ = MODE_MSG_CHECKSUM;
    4084:	2308      	movs	r3, #8
    4086:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    408a:	e6b7      	b.n	3dfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
    408c:	4798      	blx	r3
          // Exit the spin, processing timeout exceeded.
          return SPIN_TIMEOUT;
        }
      }
      int data = hardware_.read();
      if (data < 0)
    408e:	2800      	cmp	r0, #0
    4090:	f6bf aec8 	bge.w	3e24 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x64>
        }
      }
    }

    /* occasionally sync time */
    if (configured_ && ((c_time - last_sync_time) > (SYNC_SECONDS * 500)))
    4094:	f894 04f8 	ldrb.w	r0, [r4, #1272]	; 0x4f8
    4098:	2800      	cmp	r0, #0
    409a:	f43f aedd 	beq.w	3e58 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x98>
    409e:	f8d4 34fc 	ldr.w	r3, [r4, #1276]	; 0x4fc
    40a2:	f640 12c4 	movw	r2, #2500	; 0x9c4
    40a6:	1aeb      	subs	r3, r5, r3
    40a8:	4293      	cmp	r3, r2
    40aa:	f200 80aa 	bhi.w	4202 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x442>
    {
      requestSyncTime();
      last_sync_time = c_time;
    }

    return SPIN_OK;
    40ae:	2000      	movs	r0, #0
  }
    40b0:	b017      	add	sp, #92	; 0x5c
    40b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      }
      else if (mode_ == MODE_FIRST_FF)
      {
        if (data == 0xff)
        {
          mode_++;
    40b6:	2201      	movs	r2, #1
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
    40b8:	f105 0314 	add.w	r3, r5, #20
      }
      else if (mode_ == MODE_FIRST_FF)
      {
        if (data == 0xff)
        {
          mode_++;
    40bc:	f8c4 24e4 	str.w	r2, [r4, #1252]	; 0x4e4
          last_msg_timeout_time = c_time + SERIAL_MSG_TIMEOUT;
    40c0:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
    40c4:	e69a      	b.n	3dfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
    40c6:	bf00      	nop
    40c8:	1fff2ba4 	.word	0x1fff2ba4
    40cc:	800000ff 	.word	0x800000ff
    40d0:	0000138d 	.word	0x0000138d
    40d4:	00000eb1 	.word	0x00000eb1
          return SPIN_TIMEOUT;
        }
      }
      else if (mode_ == MODE_PROTOCOL_VER)
      {
        if (data == PROTOCOL_VER)
    40d8:	28fe      	cmp	r0, #254	; 0xfe
    40da:	d072      	beq.n	41c2 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x402>
          mode_++;
        }
        else
        {
          mode_ = MODE_FIRST_FF;
          if (configured_ == false)
    40dc:	f894 24f8 	ldrb.w	r2, [r4, #1272]	; 0x4f8
        {
          mode_++;
        }
        else
        {
          mode_ = MODE_FIRST_FF;
    40e0:	2300      	movs	r3, #0
    40e2:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
          if (configured_ == false)
    40e6:	2a00      	cmp	r2, #0
    40e8:	f47f ae88 	bne.w	3dfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
    40ec:	497d      	ldr	r1, [pc, #500]	; (42e4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x524>)
   */

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    40ee:	6823      	ldr	r3, [r4, #0]
    40f0:	9113      	str	r1, [sp, #76]	; 0x4c
    40f2:	681b      	ldr	r3, [r3, #0]
    40f4:	497c      	ldr	r1, [pc, #496]	; (42e8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x528>)
    40f6:	9214      	str	r2, [sp, #80]	; 0x50
    40f8:	428b      	cmp	r3, r1
    40fa:	9215      	str	r2, [sp, #84]	; 0x54
    40fc:	f040 80d5 	bne.w	42aa <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x4ea>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    4100:	21ff      	movs	r1, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    4102:	2008      	movs	r0, #8
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    4104:	23f7      	movs	r3, #247	; 0xf7
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    4106:	27fe      	movs	r7, #254	; 0xfe

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    4108:	f884 121c 	strb.w	r1, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    410c:	210a      	movs	r1, #10
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    410e:	f884 021e 	strb.w	r0, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    4112:	f884 3220 	strb.w	r3, [r4, #544]	; 0x220
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->data.sec >> (8 * 0)) & 0xFF;
    4116:	f884 2223 	strb.w	r2, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->data.sec >> (8 * 1)) & 0xFF;
    411a:	f884 2224 	strb.w	r2, [r4, #548]	; 0x224
      *(outbuffer + offset + 2) = (this->data.sec >> (8 * 2)) & 0xFF;
    411e:	f884 2225 	strb.w	r2, [r4, #549]	; 0x225
      *(outbuffer + offset + 3) = (this->data.sec >> (8 * 3)) & 0xFF;
    4122:	f884 2226 	strb.w	r2, [r4, #550]	; 0x226
      offset += sizeof(this->data.sec);
      *(outbuffer + offset + 0) = (this->data.nsec >> (8 * 0)) & 0xFF;
    4126:	f884 2227 	strb.w	r2, [r4, #551]	; 0x227
      *(outbuffer + offset + 1) = (this->data.nsec >> (8 * 1)) & 0xFF;
    412a:	f884 2228 	strb.w	r2, [r4, #552]	; 0x228
      *(outbuffer + offset + 2) = (this->data.nsec >> (8 * 2)) & 0xFF;
    412e:	f884 2229 	strb.w	r2, [r4, #553]	; 0x229
      *(outbuffer + offset + 3) = (this->data.nsec >> (8 * 3)) & 0xFF;
    4132:	f884 222a 	strb.w	r2, [r4, #554]	; 0x22a

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    4136:	f884 221f 	strb.w	r2, [r4, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    413a:	f884 2222 	strb.w	r2, [r4, #546]	; 0x222
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    413e:	f884 721d 	strb.w	r7, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    4142:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    4146:	f204 2321 	addw	r3, r4, #545	; 0x221
    414a:	f204 202a 	addw	r0, r4, #554	; 0x22a
    414e:	e001      	b.n	4154 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x394>
    4150:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    4154:	4298      	cmp	r0, r3
      chk += message_out[i];
    4156:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    4158:	d1fa      	bne.n	4150 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x390>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    415a:	43d2      	mvns	r2, r2
    415c:	6867      	ldr	r7, [r4, #4]
    415e:	f884 222b 	strb.w	r2, [r4, #555]	; 0x22b
    void write(uint8_t* data, int length){
      iostream->write(data, length);
    4162:	683b      	ldr	r3, [r7, #0]
    4164:	4a61      	ldr	r2, [pc, #388]	; (42ec <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x52c>)
    4166:	685b      	ldr	r3, [r3, #4]
    4168:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    416a:	f504 7007 	add.w	r0, r4, #540	; 0x21c
    416e:	f040 80a1 	bne.w	42b4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x4f4>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    4172:	2110      	movs	r1, #16
    4174:	f001 ff9c 	bl	60b0 <usb_serial_write>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4178:	6833      	ldr	r3, [r6, #0]
    417a:	930d      	str	r3, [sp, #52]	; 0x34
	return ret;
    417c:	9b0d      	ldr	r3, [sp, #52]	; 0x34

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    rt_time = hardware_.time();
    417e:	60e3      	str	r3, [r4, #12]
    4180:	e63c      	b.n	3dfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
        index_ = 0;
    4182:	2200      	movs	r2, #0
        mode_++;
    4184:	2303      	movs	r3, #3
            requestSyncTime();  /* send a msg back showing our protocol version */
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
    4186:	f8c4 04e8 	str.w	r0, [r4, #1256]	; 0x4e8
        index_ = 0;
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
    418a:	f8c4 04f4 	str.w	r0, [r4, #1268]	; 0x4f4
        }
      }
      else if (mode_ == MODE_SIZE_L)      /* bottom half of message size */
      {
        bytes_ = data;
        index_ = 0;
    418e:	f8c4 24f0 	str.w	r2, [r4, #1264]	; 0x4f0
        mode_++;
    4192:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    4196:	e631      	b.n	3dfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
      {
        bytes_ += data << 8;
    4198:	f8d4 34e8 	ldr.w	r3, [r4, #1256]	; 0x4e8
    419c:	eb03 2000 	add.w	r0, r3, r0, lsl #8
        mode_++;
    41a0:	2304      	movs	r3, #4
        mode_++;
        checksum_ = data;               /* first byte for calculating size checksum */
      }
      else if (mode_ == MODE_SIZE_H)      /* top half of message size */
      {
        bytes_ += data << 8;
    41a2:	f8c4 04e8 	str.w	r0, [r4, #1256]	; 0x4e8
        mode_++;
    41a6:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    41aa:	e627      	b.n	3dfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
      {
        if ((checksum_ % 256) == 255)
    41ac:	4a50      	ldr	r2, [pc, #320]	; (42f0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x530>)
    41ae:	401a      	ands	r2, r3
    41b0:	2a00      	cmp	r2, #0
    41b2:	db75      	blt.n	42a0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x4e0>
    41b4:	2aff      	cmp	r2, #255	; 0xff
          mode_++;
    41b6:	bf0c      	ite	eq
    41b8:	2305      	moveq	r3, #5
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
    41ba:	2300      	movne	r3, #0
    41bc:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    41c0:	e61c      	b.n	3dfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
      }
      else if (mode_ == MODE_PROTOCOL_VER)
      {
        if (data == PROTOCOL_VER)
        {
          mode_++;
    41c2:	2302      	movs	r3, #2
    41c4:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    41c8:	e618      	b.n	3dfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
        mode_++;
    41ca:	2306      	movs	r3, #6
        else
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
    41cc:	f8c4 04ec 	str.w	r0, [r4, #1260]	; 0x4ec
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
    41d0:	f8c4 04f4 	str.w	r0, [r4, #1268]	; 0x4f4
          mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
      }
      else if (mode_ == MODE_TOPIC_L)     /* bottom half of topic id */
      {
        topic_ = data;
        mode_++;
    41d4:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
    41d8:	e610      	b.n	3dfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    41da:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
        mode_ = MODE_MESSAGE;
        if (bytes_ == 0)
    41de:	f8d4 24e8 	ldr.w	r2, [r4, #1256]	; 0x4e8
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    41e2:	eb03 2300 	add.w	r3, r3, r0, lsl #8
        mode_ = MODE_MESSAGE;
    41e6:	2107      	movs	r1, #7
        mode_++;
        checksum_ = data;               /* first byte included in checksum */
      }
      else if (mode_ == MODE_TOPIC_H)     /* top half of topic id */
      {
        topic_ += data << 8;
    41e8:	f8c4 34ec 	str.w	r3, [r4, #1260]	; 0x4ec
        mode_ = MODE_MESSAGE;
    41ec:	f8c4 14e4 	str.w	r1, [r4, #1252]	; 0x4e4
        if (bytes_ == 0)
    41f0:	2a00      	cmp	r2, #0
    41f2:	f43f af47 	beq.w	4084 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x2c4>
    41f6:	e601      	b.n	3dfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
        // based on the application in use, the hardware buffer could be flushed
        // and start fresh.
        if ((hardware_.time() - c_time) > spin_timeout_)
        {
          // Exit the spin, processing timeout exceeded.
          return SPIN_TIMEOUT;
    41f8:	f06f 0001 	mvn.w	r0, #1
      requestSyncTime();
      last_sync_time = c_time;
    }

    return SPIN_OK;
  }
    41fc:	b017      	add	sp, #92	; 0x5c
    41fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    public:
      typedef ros::Time _data_type;
      _data_type data;

    Time():
      data()
    4202:	4a38      	ldr	r2, [pc, #224]	; (42e4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x524>)
   */

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    4204:	6823      	ldr	r3, [r4, #0]
    4206:	9213      	str	r2, [sp, #76]	; 0x4c
    4208:	681b      	ldr	r3, [r3, #0]
    420a:	4937      	ldr	r1, [pc, #220]	; (42e8 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x528>)
    420c:	2200      	movs	r2, #0
    420e:	428b      	cmp	r3, r1
    4210:	9214      	str	r2, [sp, #80]	; 0x50
    4212:	9215      	str	r2, [sp, #84]	; 0x54
    4214:	d15c      	bne.n	42d0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x510>

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    4216:	21ff      	movs	r1, #255	; 0xff
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    4218:	2008      	movs	r0, #8
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    421a:	23f7      	movs	r3, #247	; 0xf7
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    421c:	27fe      	movs	r7, #254	; 0xfe

    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    421e:	f884 121c 	strb.w	r1, [r4, #540]	; 0x21c
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    4222:	210a      	movs	r1, #10
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    4224:	f884 021e 	strb.w	r0, [r4, #542]	; 0x21e
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    4228:	f884 3220 	strb.w	r3, [r4, #544]	; 0x220
    }

    virtual int serialize(unsigned char *outbuffer) const override
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->data.sec >> (8 * 0)) & 0xFF;
    422c:	f884 2223 	strb.w	r2, [r4, #547]	; 0x223
      *(outbuffer + offset + 1) = (this->data.sec >> (8 * 1)) & 0xFF;
    4230:	f884 2224 	strb.w	r2, [r4, #548]	; 0x224
      *(outbuffer + offset + 2) = (this->data.sec >> (8 * 2)) & 0xFF;
    4234:	f884 2225 	strb.w	r2, [r4, #549]	; 0x225
      *(outbuffer + offset + 3) = (this->data.sec >> (8 * 3)) & 0xFF;
    4238:	f884 2226 	strb.w	r2, [r4, #550]	; 0x226
      offset += sizeof(this->data.sec);
      *(outbuffer + offset + 0) = (this->data.nsec >> (8 * 0)) & 0xFF;
    423c:	f884 2227 	strb.w	r2, [r4, #551]	; 0x227
      *(outbuffer + offset + 1) = (this->data.nsec >> (8 * 1)) & 0xFF;
    4240:	f884 2228 	strb.w	r2, [r4, #552]	; 0x228
      *(outbuffer + offset + 2) = (this->data.nsec >> (8 * 2)) & 0xFF;
    4244:	f884 2229 	strb.w	r2, [r4, #553]	; 0x229
      *(outbuffer + offset + 3) = (this->data.nsec >> (8 * 3)) & 0xFF;
    4248:	f884 222a 	strb.w	r2, [r4, #554]	; 0x22a

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    424c:	f884 221f 	strb.w	r2, [r4, #543]	; 0x21f
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);
    4250:	f884 2222 	strb.w	r2, [r4, #546]	; 0x222
    /* serialize message */
    int l = msg->serialize(message_out + 7);

    /* setup the header */
    message_out[0] = 0xff;
    message_out[1] = PROTOCOL_VER;
    4254:	f884 721d 	strb.w	r7, [r4, #541]	; 0x21d
    message_out[2] = (uint8_t)((uint16_t)l & 255);
    message_out[3] = (uint8_t)((uint16_t)l >> 8);
    message_out[4] = 255 - ((message_out[2] + message_out[3]) % 256);
    message_out[5] = (uint8_t)((int16_t)id & 255);
    4258:	f884 1221 	strb.w	r1, [r4, #545]	; 0x221
    425c:	f204 2321 	addw	r3, r4, #545	; 0x221
    4260:	f204 202a 	addw	r0, r4, #554	; 0x22a
    4264:	e001      	b.n	426a <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x4aa>
    4266:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    426a:	4283      	cmp	r3, r0
      chk += message_out[i];
    426c:	440a      	add	r2, r1
    message_out[5] = (uint8_t)((int16_t)id & 255);
    message_out[6] = (uint8_t)((int16_t)id >> 8);

    /* calculate checksum */
    int chk = 0;
    for (int i = 5; i < l + 7; i++)
    426e:	d1fa      	bne.n	4266 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x4a6>
      chk += message_out[i];
    l += 7;
    message_out[l++] = 255 - (chk % 256);
    4270:	43d2      	mvns	r2, r2
    4272:	6867      	ldr	r7, [r4, #4]
    4274:	f884 222b 	strb.w	r2, [r4, #555]	; 0x22b
    4278:	683b      	ldr	r3, [r7, #0]
    427a:	4a1c      	ldr	r2, [pc, #112]	; (42ec <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x52c>)
    427c:	685b      	ldr	r3, [r3, #4]
    427e:	4293      	cmp	r3, r2

    if (l <= OUTPUT_SIZE)
    {
      hardware_.write(message_out, l);
    4280:	f504 7007 	add.w	r0, r4, #540	; 0x21c
    4284:	d129      	bne.n	42da <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x51a>
    4286:	2110      	movs	r1, #16
    4288:	f001 ff12 	bl	60b0 <usb_serial_write>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    428c:	6833      	ldr	r3, [r6, #0]
    428e:	930f      	str	r3, [sp, #60]	; 0x3c
	return ret;
    4290:	9b0f      	ldr	r3, [sp, #60]	; 0x3c

    /* occasionally sync time */
    if (configured_ && ((c_time - last_sync_time) > (SYNC_SECONDS * 500)))
    {
      requestSyncTime();
      last_sync_time = c_time;
    4292:	f8c4 54fc 	str.w	r5, [r4, #1276]	; 0x4fc
    }

    return SPIN_OK;
    4296:	2000      	movs	r0, #0

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    rt_time = hardware_.time();
    4298:	60e3      	str	r3, [r4, #12]
      requestSyncTime();
      last_sync_time = c_time;
    }

    return SPIN_OK;
  }
    429a:	b017      	add	sp, #92	; 0x5c
    429c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        bytes_ += data << 8;
        mode_++;
      }
      else if (mode_ == MODE_SIZE_CHECKSUM)
      {
        if ((checksum_ % 256) == 255)
    42a0:	3a01      	subs	r2, #1
    42a2:	f062 02ff 	orn	r2, r2, #255	; 0xff
    42a6:	3201      	adds	r2, #1
    42a8:	e784      	b.n	41b4 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3f4>
   */

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    42aa:	aa13      	add	r2, sp, #76	; 0x4c
    42ac:	210a      	movs	r1, #10
    42ae:	4620      	mov	r0, r4
    42b0:	4798      	blx	r3
    42b2:	e761      	b.n	4178 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3b8>
    42b4:	4601      	mov	r1, r0
    42b6:	2210      	movs	r2, #16
    42b8:	4638      	mov	r0, r7
    42ba:	4798      	blx	r3
    42bc:	e75c      	b.n	4178 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3b8>
          mode_ = MODE_MSG_CHECKSUM;
      }
      else if (mode_ == MODE_MSG_CHECKSUM)    /* do checksum */
      {
        mode_ = MODE_FIRST_FF;
        if ((checksum_ % 256) == 255)
    42be:	3a01      	subs	r2, #1
    42c0:	f062 02ff 	orn	r2, r2, #255	; 0xff
    42c4:	3201      	adds	r2, #1
    42c6:	e5e6      	b.n	3e96 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0xd6>
            req_param_resp.deserialize(message_in);
            param_received = true;
          }
          else if (topic_ == TopicInfo::ID_TX_STOP)
          {
            configured_ = false;
    42c8:	2300      	movs	r3, #0
    42ca:	f884 34f8 	strb.w	r3, [r4, #1272]	; 0x4f8
    42ce:	e595      	b.n	3dfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
   */

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    42d0:	aa13      	add	r2, sp, #76	; 0x4c
    42d2:	210a      	movs	r1, #10
    42d4:	4620      	mov	r0, r4
    42d6:	4798      	blx	r3
    42d8:	e7d8      	b.n	428c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x4cc>
    42da:	4601      	mov	r1, r0
    42dc:	2210      	movs	r2, #16
    42de:	4638      	mov	r0, r7
    42e0:	4798      	blx	r3
    42e2:	e7d3      	b.n	428c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x4cc>
    42e4:	000096bc 	.word	0x000096bc
    42e8:	0000196d 	.word	0x0000196d
    42ec:	00000ea9 	.word	0x00000ea9
    42f0:	800000ff 	.word	0x800000ff
    {
      int offset = 0;
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    42f4:	7f22      	ldrb	r2, [r4, #28]
    42f6:	7f63      	ldrb	r3, [r4, #29]
    42f8:	f894 801e 	ldrb.w	r8, [r4, #30]
    42fc:	7fe1      	ldrb	r1, [r4, #31]
    42fe:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    4302:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
    4306:	f8d4 2510 	ldr.w	r2, [r4, #1296]	; 0x510
    {
      int offset = 0;
      uint32_t ints_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    430a:	ea43 6801 	orr.w	r8, r3, r1, lsl #24
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
    430e:	4590      	cmp	r8, r2
          {
            syncTime(message_in);
          }
          else if (topic_ == TopicInfo::ID_PARAMETER_REQUEST)
          {
            req_param_resp.deserialize(message_in);
    4310:	f104 071c 	add.w	r7, r4, #28
    4314:	d907      	bls.n	4326 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x566>
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
    4316:	ea4f 0188 	mov.w	r1, r8, lsl #2
    431a:	f8d4 0518 	ldr.w	r0, [r4, #1304]	; 0x518
    431e:	f004 fbc7 	bl	8ab0 <realloc>
    4322:	f8c4 0518 	str.w	r0, [r4, #1304]	; 0x518
      ints_length = ints_lengthT;
    4326:	f8c4 8510 	str.w	r8, [r4, #1296]	; 0x510
      for( uint32_t i = 0; i < ints_length; i++){
    432a:	f1b8 0f00 	cmp.w	r8, #0
    432e:	f000 8156 	beq.w	45de <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x81e>
    4332:	f204 5314 	addw	r3, r4, #1300	; 0x514
    4336:	9300      	str	r3, [sp, #0]
    4338:	46b8      	mov	r8, r7
    433a:	f04f 0904 	mov.w	r9, #4
    433e:	f04f 0b00 	mov.w	fp, #0
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
    4342:	f898 3006 	ldrb.w	r3, [r8, #6]
    4346:	f898 0005 	ldrb.w	r0, [r8, #5]
    434a:	f898 2004 	ldrb.w	r2, [r8, #4]
    434e:	f898 1007 	ldrb.w	r1, [r8, #7]
    4352:	041b      	lsls	r3, r3, #16
    4354:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
    4358:	4313      	orrs	r3, r2
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
    435a:	f8d4 0518 	ldr.w	r0, [r4, #1304]	; 0x518
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
    435e:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    4362:	f8c4 3514 	str.w	r3, [r4, #1300]	; 0x514
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
    4366:	eb00 008b 	add.w	r0, r0, fp, lsl #2
    436a:	2204      	movs	r2, #4
    436c:	9900      	ldr	r1, [sp, #0]
    436e:	f000 fb87 	bl	4a80 <memcpy>
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
      ints_length = ints_lengthT;
      for( uint32_t i = 0; i < ints_length; i++){
    4372:	f8d4 3510 	ldr.w	r3, [r4, #1296]	; 0x510
    4376:	f10b 0b01 	add.w	fp, fp, #1
    437a:	455b      	cmp	r3, fp
    437c:	464a      	mov	r2, r9
    437e:	f108 0804 	add.w	r8, r8, #4
    4382:	f109 0904 	add.w	r9, r9, #4
    4386:	d8dc      	bhi.n	4342 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x582>
    4388:	f102 0309 	add.w	r3, r2, #9
    438c:	f102 0b08 	add.w	fp, r2, #8
    4390:	f102 010b 	add.w	r1, r2, #11
    4394:	f102 0e05 	add.w	lr, r2, #5
    4398:	f102 0c06 	add.w	ip, r2, #6
    439c:	f102 0807 	add.w	r8, r2, #7
    43a0:	9300      	str	r3, [sp, #0]
    43a2:	f102 030a 	add.w	r3, r2, #10
    43a6:	320c      	adds	r2, #12
    43a8:	4648      	mov	r0, r9
    43aa:	9102      	str	r1, [sp, #8]
    43ac:	46d9      	mov	r9, fp
    43ae:	9204      	str	r2, [sp, #16]
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    43b0:	f817 200c 	ldrb.w	r2, [r7, ip]
    43b4:	f817 c00e 	ldrb.w	ip, [r7, lr]
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    43b8:	5c38      	ldrb	r0, [r7, r0]
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    43ba:	f817 e008 	ldrb.w	lr, [r7, r8]
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
    43be:	f8d4 151c 	ldr.w	r1, [r4, #1308]	; 0x51c
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint32_t floats_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    43c2:	0412      	lsls	r2, r2, #16
    43c4:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
    43c8:	4310      	orrs	r0, r2
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    43ca:	ea40 680e 	orr.w	r8, r0, lr, lsl #24
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
    43ce:	4588      	cmp	r8, r1
    43d0:	d909      	bls.n	43e6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x626>
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
    43d2:	ea4f 0188 	mov.w	r1, r8, lsl #2
    43d6:	f8d4 0524 	ldr.w	r0, [r4, #1316]	; 0x524
    43da:	9306      	str	r3, [sp, #24]
    43dc:	f004 fb68 	bl	8ab0 <realloc>
    43e0:	9b06      	ldr	r3, [sp, #24]
    43e2:	f8c4 0524 	str.w	r0, [r4, #1316]	; 0x524
      floats_length = floats_lengthT;
    43e6:	f8c4 851c 	str.w	r8, [r4, #1308]	; 0x51c
      for( uint32_t i = 0; i < floats_length; i++){
    43ea:	f1b8 0f00 	cmp.w	r8, #0
    43ee:	f000 8108 	beq.w	4602 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x842>
    43f2:	f504 63a4 	add.w	r3, r4, #1312	; 0x520
    43f6:	9300      	str	r3, [sp, #0]
    43f8:	f204 530c 	addw	r3, r4, #1292	; 0x50c
    43fc:	eb07 0809 	add.w	r8, r7, r9
    4400:	f04f 0b00 	mov.w	fp, #0
    4404:	9302      	str	r3, [sp, #8]
      } u_st_floats;
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    4406:	f898 1002 	ldrb.w	r1, [r8, #2]
    440a:	f898 3001 	ldrb.w	r3, [r8, #1]
    440e:	f898 2000 	ldrb.w	r2, [r8]
    4412:	f898 e003 	ldrb.w	lr, [r8, #3]
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    4416:	f8d4 0524 	ldr.w	r0, [r4, #1316]	; 0x524
      } u_st_floats;
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    441a:	0409      	lsls	r1, r1, #16
    441c:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
    4420:	4313      	orrs	r3, r2
      this->st_floats = u_st_floats.real;
    4422:	9a02      	ldr	r2, [sp, #8]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    4424:	9900      	ldr	r1, [sp, #0]
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
    4426:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
    442a:	6153      	str	r3, [r2, #20]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
    442c:	eb00 008b 	add.w	r0, r0, fp, lsl #2
    4430:	2204      	movs	r2, #4
    4432:	f000 fb25 	bl	4a80 <memcpy>
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
      floats_length = floats_lengthT;
      for( uint32_t i = 0; i < floats_length; i++){
    4436:	f8d4 351c 	ldr.w	r3, [r4, #1308]	; 0x51c
    443a:	f10b 0b01 	add.w	fp, fp, #1
    443e:	455b      	cmp	r3, fp
    4440:	464a      	mov	r2, r9
    4442:	f108 0804 	add.w	r8, r8, #4
    4446:	f109 0904 	add.w	r9, r9, #4
    444a:	d8dc      	bhi.n	4406 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x646>
    444c:	1d53      	adds	r3, r2, #5
    444e:	1dd1      	adds	r1, r2, #7
    4450:	9300      	str	r3, [sp, #0]
    4452:	46cb      	mov	fp, r9
    4454:	1d93      	adds	r3, r2, #6
    4456:	9102      	str	r1, [sp, #8]
    4458:	f102 0808 	add.w	r8, r2, #8
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    445c:	5cf9      	ldrb	r1, [r7, r3]
    445e:	9b00      	ldr	r3, [sp, #0]
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    4460:	9a02      	ldr	r2, [sp, #8]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    4462:	5cf8      	ldrb	r0, [r7, r3]
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
    4464:	f817 300b 	ldrb.w	r3, [r7, fp]
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    4468:	f817 9002 	ldrb.w	r9, [r7, r2]
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
    446c:	f8d4 2528 	ldr.w	r2, [r4, #1320]	; 0x528
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint32_t strings_lengthT = ((uint32_t) (*(inbuffer + offset))); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1); 
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2); 
    4470:	0409      	lsls	r1, r1, #16
    4472:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
    4476:	430b      	orrs	r3, r1
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
    4478:	ea43 6909 	orr.w	r9, r3, r9, lsl #24
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
    447c:	4591      	cmp	r9, r2
    447e:	d907      	bls.n	4490 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x6d0>
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
    4480:	ea4f 0189 	mov.w	r1, r9, lsl #2
    4484:	f8d4 0530 	ldr.w	r0, [r4, #1328]	; 0x530
    4488:	f004 fb12 	bl	8ab0 <realloc>
    448c:	f8c4 0530 	str.w	r0, [r4, #1328]	; 0x530
      strings_length = strings_lengthT;
    4490:	f8c4 9528 	str.w	r9, [r4, #1320]	; 0x528
      for( uint32_t i = 0; i < strings_length; i++){
    4494:	f1b9 0f00 	cmp.w	r9, #0
    4498:	d038      	beq.n	450c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x74c>
    449a:	f04f 0900 	mov.w	r9, #0
    449e:	f204 532c 	addw	r3, r4, #1324	; 0x52c
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    44a2:	46cb      	mov	fp, r9
    44a4:	9300      	str	r3, [sp, #0]
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
      uint32_t length_st_strings;
      arrToVar(length_st_strings, (inbuffer + offset));
    44a6:	2300      	movs	r3, #0

  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    44a8:	469e      	mov	lr, r3
    44aa:	eb07 0108 	add.w	r1, r7, r8
    for (size_t i = 0; i < sizeof(V); i++)
      var |= (arr[i] << (8 * i));
    44ae:	f811 2b01 	ldrb.w	r2, [r1], #1
    44b2:	409a      	lsls	r2, r3
    44b4:	3308      	adds	r3, #8
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
    44b6:	2b20      	cmp	r3, #32
      var |= (arr[i] << (8 * i));
    44b8:	ea4e 0e02 	orr.w	lr, lr, r2
  // Copy data from a byte array into variable
  template<typename V, typename A>
  static void arrToVar(V& var, const A arr)
  {
    var = 0;
    for (size_t i = 0; i < sizeof(V); i++)
    44bc:	d1f7      	bne.n	44ae <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x6ee>
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
    44be:	f108 0104 	add.w	r1, r8, #4
    44c2:	448e      	add	lr, r1
    44c4:	4571      	cmp	r1, lr
    44c6:	d20a      	bcs.n	44de <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x71e>
    44c8:	f108 0303 	add.w	r3, r8, #3
    44cc:	443b      	add	r3, r7
    44ce:	460a      	mov	r2, r1
    44d0:	3201      	adds	r2, #1
          inbuffer[k-1]=inbuffer[k];
    44d2:	f813 0f01 	ldrb.w	r0, [r3, #1]!
    44d6:	f803 0c01 	strb.w	r0, [r3, #-1]
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
      uint32_t length_st_strings;
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
    44da:	4572      	cmp	r2, lr
    44dc:	d3f8      	bcc.n	44d0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x710>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    44de:	eb07 020e 	add.w	r2, r7, lr
      this->st_strings = (char *)(inbuffer + offset-1);
    44e2:	1e4b      	subs	r3, r1, #1
      arrToVar(length_st_strings, (inbuffer + offset));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
    44e4:	f802 bc01 	strb.w	fp, [r2, #-1]
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    44e8:	f8d4 0530 	ldr.w	r0, [r4, #1328]	; 0x530
    44ec:	9900      	ldr	r1, [sp, #0]
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
    44ee:	443b      	add	r3, r7
    44f0:	f8c4 352c 	str.w	r3, [r4, #1324]	; 0x52c
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    44f4:	eb00 0089 	add.w	r0, r0, r9, lsl #2
    44f8:	2204      	movs	r2, #4
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
    44fa:	46f0      	mov	r8, lr
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
    44fc:	f000 fac0 	bl	4a80 <memcpy>
      strings_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->strings_length);
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      strings_length = strings_lengthT;
      for( uint32_t i = 0; i < strings_length; i++){
    4500:	f8d4 3528 	ldr.w	r3, [r4, #1320]	; 0x528
    4504:	f109 0901 	add.w	r9, r9, #1
    4508:	454b      	cmp	r3, r9
    450a:	d8cc      	bhi.n	44a6 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x6e6>
            param_received = true;
    450c:	2301      	movs	r3, #1
    450e:	f884 3508 	strb.w	r3, [r4, #1288]	; 0x508
    4512:	e473      	b.n	3dfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4514:	6833      	ldr	r3, [r6, #0]
    4516:	9310      	str	r3, [sp, #64]	; 0x40
	return ret;
    4518:	9f10      	ldr	r7, [sp, #64]	; 0x40
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    451a:	6831      	ldr	r1, [r6, #0]
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    451c:	7f23      	ldrb	r3, [r4, #28]
    451e:	9112      	str	r1, [sp, #72]	; 0x48
    4520:	7f61      	ldrb	r1, [r4, #29]
  }

  void syncTime(uint8_t * data)
  {
    std_msgs::Time t;
    uint32_t offset = hardware_.time() - rt_time;
    4522:	68e0      	ldr	r0, [r4, #12]
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    4524:	f894 c021 	ldrb.w	ip, [r4, #33]	; 0x21
    4528:	f894 2020 	ldrb.w	r2, [r4, #32]
    452c:	f894 e022 	ldrb.w	lr, [r4, #34]	; 0x22
    4530:	f894 8023 	ldrb.w	r8, [r4, #35]	; 0x23

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    4534:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 4610 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x850>
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    4538:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    453c:	4b32      	ldr	r3, [pc, #200]	; (4608 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x848>)
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    453e:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
  }

  void syncTime(uint8_t * data)
  {
    std_msgs::Time t;
    uint32_t offset = hardware_.time() - rt_time;
    4542:	1a3f      	subs	r7, r7, r0
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    4544:	f894 c01e 	ldrb.w	ip, [r4, #30]
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    4548:	fba3 3007 	umull	r3, r0, r3, r7
    454c:	7fe3      	ldrb	r3, [r4, #31]
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    454e:	ea42 4e0e 	orr.w	lr, r2, lr, lsl #16
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    4552:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
	return ret;
    4556:	9a12      	ldr	r2, [sp, #72]	; 0x48
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    4558:	ea4e 6e08 	orr.w	lr, lr, r8, lsl #24
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
    455c:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    4560:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 4614 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x854>
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    4564:	4b28      	ldr	r3, [pc, #160]	; (4608 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x848>)
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    4566:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    456a:	0980      	lsrs	r0, r0, #6
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    456c:	44f0      	add	r8, lr
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    456e:	fba3 3e02 	umull	r3, lr, r3, r2
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    4572:	fb0c 7710 	mls	r7, ip, r0, r7
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    4576:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
    457a:	3901      	subs	r1, #1
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    457c:	fb0c 221e 	mls	r2, ip, lr, r2
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    4580:	4408      	add	r0, r1
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    4582:	fb09 8707 	mla	r7, r9, r7, r8
    4586:	4621      	mov	r1, r4
    4588:	fb09 7312 	mls	r3, r9, r2, r7
  }

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    458c:	ebce 0200 	rsb	r2, lr, r0
    4590:	6122      	str	r2, [r4, #16]
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    normalizeSecNSec(sec_offset, nsec_offset);
    4592:	f104 0010 	add.w	r0, r4, #16

  void setNow(const Time & new_now)
  {
    uint32_t ms = hardware_.time();
    sec_offset = new_now.sec - ms / 1000 - 1;
    nsec_offset = new_now.nsec - (ms % 1000) * 1000000UL + 1000000000UL;
    4596:	f841 3f14 	str.w	r3, [r1, #20]!
    normalizeSecNSec(sec_offset, nsec_offset);
    459a:	f000 fa5d 	bl	4a58 <ros::normalizeSecNSec(unsigned long&, unsigned long&)>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    459e:	6833      	ldr	r3, [r6, #0]
    45a0:	9311      	str	r3, [sp, #68]	; 0x44
	return ret;
    45a2:	9b11      	ldr	r3, [sp, #68]	; 0x44
    t.deserialize(data);
    t.data.sec += offset / 1000;
    t.data.nsec += (offset % 1000) * 1000000UL;

    this->setNow(t.data);
    last_sync_receive_time = hardware_.time();
    45a4:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
    45a8:	e428      	b.n	3dfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
            configured_ = false;
          }
          else
          {
            if (subscribers[topic_ - 100])
              subscribers[topic_ - 100]->callback(message_in);
    45aa:	4798      	blx	r3
    45ac:	e426      	b.n	3dfc <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x3c>
   */

  void requestSyncTime()
  {
    std_msgs::Time t;
    publish(TopicInfo::ID_TIME, &t);
    45ae:	6822      	ldr	r2, [r4, #0]
    public:
      typedef ros::Time _data_type;
      _data_type data;

    Time():
      data()
    45b0:	4916      	ldr	r1, [pc, #88]	; (460c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x84c>)
    45b2:	9113      	str	r1, [sp, #76]	; 0x4c
    45b4:	9314      	str	r3, [sp, #80]	; 0x50
    45b6:	9315      	str	r3, [sp, #84]	; 0x54
    45b8:	210a      	movs	r1, #10
    45ba:	6813      	ldr	r3, [r2, #0]
    45bc:	4620      	mov	r0, r4
    45be:	aa13      	add	r2, sp, #76	; 0x4c
    45c0:	4798      	blx	r3
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    45c2:	6833      	ldr	r3, [r6, #0]
    45c4:	930e      	str	r3, [sp, #56]	; 0x38
	return ret;
    45c6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    rt_time = hardware_.time();
    45c8:	60e3      	str	r3, [r4, #12]
        if ((checksum_ % 256) == 255)
        {
          if (topic_ == TopicInfo::ID_PUBLISHER)
          {
            requestSyncTime();
            negotiateTopics();
    45ca:	4620      	mov	r0, r4
    45cc:	f7ff f95a 	bl	3884 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::negotiateTopics()>
            last_sync_time = c_time;
    45d0:	f8c4 54fc 	str.w	r5, [r4, #1276]	; 0x4fc
            last_sync_receive_time = c_time;
    45d4:	f8c4 5500 	str.w	r5, [r4, #1280]	; 0x500
            return SPIN_ERR;
    45d8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    45dc:	e43c      	b.n	3e58 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x98>
      ints_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->ints_length);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
      ints_length = ints_lengthT;
      for( uint32_t i = 0; i < ints_length; i++){
    45de:	230c      	movs	r3, #12
    45e0:	f04f 0b08 	mov.w	fp, #8
    45e4:	9304      	str	r3, [sp, #16]
    45e6:	2209      	movs	r2, #9
    45e8:	230b      	movs	r3, #11
    45ea:	9302      	str	r3, [sp, #8]
    45ec:	46d9      	mov	r9, fp
    45ee:	230a      	movs	r3, #10
    45f0:	9200      	str	r2, [sp, #0]
    45f2:	f04f 0807 	mov.w	r8, #7
    45f6:	f04f 0c06 	mov.w	ip, #6
    45fa:	f04f 0e05 	mov.w	lr, #5
    45fe:	2004      	movs	r0, #4
    4600:	e6d6      	b.n	43b0 <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x5f0>
      floats_lengthT |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3); 
      offset += sizeof(this->floats_length);
      if(floats_lengthT > floats_length)
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
      floats_length = floats_lengthT;
      for( uint32_t i = 0; i < floats_length; i++){
    4602:	f8dd 8010 	ldr.w	r8, [sp, #16]
    4606:	e729      	b.n	445c <ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>::spinOnce()+0x69c>
    4608:	10624dd3 	.word	0x10624dd3
    460c:	000096bc 	.word	0x000096bc
    4610:	000f4240 	.word	0x000f4240
    4614:	3b9aca00 	.word	0x3b9aca00

00004618 <_GLOBAL__sub_I_error_l>:
    speed_pub.publish(&wheel_speed);
  }
  nh.spinOnce();
  //}
  //delay(100);
  }
    4618:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
int left_count_tick;
float wheel_base = 0.229;            // needs to be updated and use the right unit (proberbly meters)
float wheel_radius = 0.04;           // needs to be updated and use the right unit (proberbly meters)
int16_t accel_X, accel_Y, accel_Z, tmp, gyro_X, gyro_Y, gyro_Z, mx, my, mz;
long publisher_timer;
MPU9250 accelgyro;
    461a:	486b      	ldr	r0, [pc, #428]	; (47c8 <_GLOBAL__sub_I_error_l+0x1b0>)
template<class Hardware,
         int MAX_SUBSCRIBERS = 25,
         int MAX_PUBLISHERS = 25,
         int INPUT_SIZE = 512,
         int OUTPUT_SIZE = 512>
class NodeHandle_ : public NodeHandleBase_
    461c:	4d6b      	ldr	r5, [pc, #428]	; (47cc <_GLOBAL__sub_I_error_l+0x1b4>)
      /* Leonardo support */
      iostream = &Serial1;
#elif defined(USE_TEENSY_HW_SERIAL) or defined(USE_STM32_HW_SERIAL)
      iostream = &Serial1;
#else
      iostream = &Serial;
    461e:	4e6c      	ldr	r6, [pc, #432]	; (47d0 <_GLOBAL__sub_I_error_l+0x1b8>)
    4620:	f000 fa16 	bl	4a50 <MPU9250::MPU9250()>
    4624:	4b6b      	ldr	r3, [pc, #428]	; (47d4 <_GLOBAL__sub_I_error_l+0x1bc>)
    4626:	602b      	str	r3, [r5, #0]
    4628:	2400      	movs	r4, #0
#endif
      baud_ = 57600;
    462a:	f44f 4361 	mov.w	r3, #57600	; 0xe100
    462e:	f44f 7700 	mov.w	r7, #512	; 0x200
    4632:	60ab      	str	r3, [r5, #8]
    4634:	4621      	mov	r1, r4
    4636:	463a      	mov	r2, r7
      /* Leonardo support */
      iostream = &Serial1;
#elif defined(USE_TEENSY_HW_SERIAL) or defined(USE_STM32_HW_SERIAL)
      iostream = &Serial1;
#else
      iostream = &Serial;
    4638:	606e      	str	r6, [r5, #4]
    463a:	f105 001c 	add.w	r0, r5, #28
    463e:	60ec      	str	r4, [r5, #12]
    4640:	612c      	str	r4, [r5, #16]
    4642:	616c      	str	r4, [r5, #20]
    4644:	61ac      	str	r4, [r5, #24]
    4646:	2664      	movs	r6, #100	; 0x64
    4648:	f004 f9e0 	bl	8a0c <memset>
    464c:	463a      	mov	r2, r7
    464e:	4621      	mov	r1, r4
    4650:	f505 7007 	add.w	r0, r5, #540	; 0x21c
    4654:	f004 f9da 	bl	8a0c <memset>
    4658:	4621      	mov	r1, r4
    465a:	4632      	mov	r2, r6
    465c:	f205 401c 	addw	r0, r5, #1052	; 0x41c
    4660:	f004 f9d4 	bl	8a0c <memset>
    4664:	4632      	mov	r2, r6
    4666:	4621      	mov	r1, r4
    4668:	f505 6090 	add.w	r0, r5, #1152	; 0x480
    466c:	f004 f9ce 	bl	8a0c <memset>
      _strings_type * strings;

    RequestParamResponse():
      ints_length(0), st_ints(), ints(nullptr),
      floats_length(0), st_floats(), floats(nullptr),
      strings_length(0), st_strings(), strings(nullptr)
    4670:	4959      	ldr	r1, [pc, #356]	; (47d8 <_GLOBAL__sub_I_error_l+0x1c0>)
    4672:	f8c5 44e4 	str.w	r4, [r5, #1252]	; 0x4e4
    4676:	f8c5 44e8 	str.w	r4, [r5, #1256]	; 0x4e8
    467a:	f8c5 44ec 	str.w	r4, [r5, #1260]	; 0x4ec
    467e:	f8c5 44f0 	str.w	r4, [r5, #1264]	; 0x4f0
    4682:	f8c5 44f4 	str.w	r4, [r5, #1268]	; 0x4f4
    4686:	f885 44f8 	strb.w	r4, [r5, #1272]	; 0x4f8
    468a:	f8c5 44fc 	str.w	r4, [r5, #1276]	; 0x4fc
    468e:	f8c5 4500 	str.w	r4, [r5, #1280]	; 0x500
    4692:	f8c5 4504 	str.w	r4, [r5, #1284]	; 0x504
    4696:	f885 4508 	strb.w	r4, [r5, #1288]	; 0x508
    469a:	f8c5 4510 	str.w	r4, [r5, #1296]	; 0x510
    469e:	f8c5 4514 	str.w	r4, [r5, #1300]	; 0x514
    46a2:	f8c5 4518 	str.w	r4, [r5, #1304]	; 0x518
    46a6:	f8c5 451c 	str.w	r4, [r5, #1308]	; 0x51c
    46aa:	f8c5 4524 	str.w	r4, [r5, #1316]	; 0x524
    46ae:	f8c5 4528 	str.w	r4, [r5, #1320]	; 0x528
    46b2:	f8c5 452c 	str.w	r4, [r5, #1324]	; 0x52c
    46b6:	f8c5 4530 	str.w	r4, [r5, #1328]	; 0x530
    46ba:	f8c5 150c 	str.w	r1, [r5, #1292]	; 0x50c
    46be:	f505 65a4 	add.w	r5, r5, #1312	; 0x520
    public:
      typedef float _data_type;
      _data_type data;

    Float32():
      data(0)
    46c2:	4f46      	ldr	r7, [pc, #280]	; (47dc <_GLOBAL__sub_I_error_l+0x1c4>)
    public:
      typedef int16_t _data_type;
      _data_type data;

    Int16():
      data(0)
    46c4:	4846      	ldr	r0, [pc, #280]	; (47e0 <_GLOBAL__sub_I_error_l+0x1c8>)
{
public:
  Publisher(const char * topic_name, Msg * msg, int endpoint = rosserial_msgs::TopicInfo::ID_PUBLISHER) :
    topic_(topic_name),
    msg_(msg),
    endpoint_(endpoint) {};
    46c6:	4947      	ldr	r1, [pc, #284]	; (47e4 <_GLOBAL__sub_I_error_l+0x1cc>)
    46c8:	f8df e170 	ldr.w	lr, [pc, #368]	; 483c <_GLOBAL__sub_I_error_l+0x224>
    46cc:	8084      	strh	r4, [r0, #4]
    46ce:	2600      	movs	r6, #0
    46d0:	602e      	str	r6, [r5, #0]
    46d2:	4d45      	ldr	r5, [pc, #276]	; (47e8 <_GLOBAL__sub_I_error_l+0x1d0>)
    46d4:	607e      	str	r6, [r7, #4]
    46d6:	603d      	str	r5, [r7, #0]
    46d8:	4e44      	ldr	r6, [pc, #272]	; (47ec <_GLOBAL__sub_I_error_l+0x1d4>)
    46da:	4d45      	ldr	r5, [pc, #276]	; (47f0 <_GLOBAL__sub_I_error_l+0x1d8>)
    46dc:	6005      	str	r5, [r0, #0]
    46de:	6048      	str	r0, [r1, #4]
    46e0:	4844      	ldr	r0, [pc, #272]	; (47f4 <_GLOBAL__sub_I_error_l+0x1dc>)
    46e2:	610c      	str	r4, [r1, #16]
    46e4:	6008      	str	r0, [r1, #0]
    46e6:	f8ce 5000 	str.w	r5, [lr]
    46ea:	4943      	ldr	r1, [pc, #268]	; (47f8 <_GLOBAL__sub_I_error_l+0x1e0>)
    46ec:	f8ae 4004 	strh.w	r4, [lr, #4]
    46f0:	f8c6 e004 	str.w	lr, [r6, #4]
    46f4:	f8df e148 	ldr.w	lr, [pc, #328]	; 4840 <_GLOBAL__sub_I_error_l+0x228>
    46f8:	4840      	ldr	r0, [pc, #256]	; (47fc <_GLOBAL__sub_I_error_l+0x1e4>)
    46fa:	6134      	str	r4, [r6, #16]
    46fc:	f8c6 e000 	str.w	lr, [r6]
    4700:	4e3f      	ldr	r6, [pc, #252]	; (4800 <_GLOBAL__sub_I_error_l+0x1e8>)
    4702:	600e      	str	r6, [r1, #0]

    Quaternion():
      x(0),
      y(0),
      z(0),
      w(0)
    4704:	4d3f      	ldr	r5, [pc, #252]	; (4804 <_GLOBAL__sub_I_error_l+0x1ec>)
    4706:	610c      	str	r4, [r1, #16]
    4708:	604f      	str	r7, [r1, #4]
    470a:	493f      	ldr	r1, [pc, #252]	; (4808 <_GLOBAL__sub_I_error_l+0x1f0>)
      _z_type z;

    Vector3():
      x(0),
      y(0),
      z(0)
    470c:	4e3f      	ldr	r6, [pc, #252]	; (480c <_GLOBAL__sub_I_error_l+0x1f4>)
    470e:	4f40      	ldr	r7, [pc, #256]	; (4810 <_GLOBAL__sub_I_error_l+0x1f8>)
    4710:	6104      	str	r4, [r0, #16]
    4712:	2200      	movs	r2, #0
    4714:	2300      	movs	r3, #0
    4716:	6001      	str	r1, [r0, #0]
    4718:	6045      	str	r5, [r0, #4]
    471a:	483e      	ldr	r0, [pc, #248]	; (4814 <_GLOBAL__sub_I_error_l+0x1fc>)
    471c:	6028      	str	r0, [r5, #0]
    471e:	e9c5 2302 	strd	r2, r3, [r5, #8]
    4722:	e9c5 2304 	strd	r2, r3, [r5, #16]
    4726:	e9c5 2306 	strd	r2, r3, [r5, #24]
    472a:	e9c5 2308 	strd	r2, r3, [r5, #32]
    472e:	4d3a      	ldr	r5, [pc, #232]	; (4818 <_GLOBAL__sub_I_error_l+0x200>)
      imu_acc(),
      imu_gyro(),
      imu_mag(),
      omega_right(0),
      omega_left(0),
      temp(0)
    4730:	493a      	ldr	r1, [pc, #232]	; (481c <_GLOBAL__sub_I_error_l+0x204>)
    4732:	607e      	str	r6, [r7, #4]
    4734:	e9c6 2302 	strd	r2, r3, [r6, #8]
    4738:	e9c6 2304 	strd	r2, r3, [r6, #16]
    473c:	e9c6 2306 	strd	r2, r3, [r6, #24]
    4740:	6035      	str	r5, [r6, #0]
    4742:	4e37      	ldr	r6, [pc, #220]	; (4820 <_GLOBAL__sub_I_error_l+0x208>)
    4744:	603e      	str	r6, [r7, #0]
    4746:	4e37      	ldr	r6, [pc, #220]	; (4824 <_GLOBAL__sub_I_error_l+0x20c>)
  typedef void(*CallbackT)(const MsgT&);
  MsgT msg;

  Subscriber(const char * topic_name, CallbackT cb, int endpoint = rosserial_msgs::TopicInfo::ID_SUBSCRIBER) :
    cb_(cb),
    endpoint_(endpoint)
    4748:	4837      	ldr	r0, [pc, #220]	; (4828 <_GLOBAL__sub_I_error_l+0x210>)
    474a:	600e      	str	r6, [r1, #0]
    474c:	4e37      	ldr	r6, [pc, #220]	; (482c <_GLOBAL__sub_I_error_l+0x214>)
    474e:	613c      	str	r4, [r7, #16]
    4750:	e9c1 2304 	strd	r2, r3, [r1, #16]
    4754:	e9c1 2306 	strd	r2, r3, [r1, #24]
    4758:	e9c1 2308 	strd	r2, r3, [r1, #32]
    475c:	e9c1 230c 	strd	r2, r3, [r1, #48]	; 0x30
    4760:	e9c1 230e 	strd	r2, r3, [r1, #56]	; 0x38
    4764:	e9c1 2310 	strd	r2, r3, [r1, #64]	; 0x40
    4768:	e9c1 2314 	strd	r2, r3, [r1, #80]	; 0x50
    476c:	e9c1 2316 	strd	r2, r3, [r1, #88]	; 0x58
    4770:	e9c1 2318 	strd	r2, r3, [r1, #96]	; 0x60
    4774:	e9c1 231a 	strd	r2, r3, [r1, #104]	; 0x68
    4778:	e9c1 231c 	strd	r2, r3, [r1, #112]	; 0x70
    477c:	608d      	str	r5, [r1, #8]
    477e:	628d      	str	r5, [r1, #40]	; 0x28
    4780:	648d      	str	r5, [r1, #72]	; 0x48
    4782:	f8df c0c0 	ldr.w	ip, [pc, #192]	; 4844 <_GLOBAL__sub_I_error_l+0x22c>
    4786:	f8df e0c0 	ldr.w	lr, [pc, #192]	; 4848 <_GLOBAL__sub_I_error_l+0x230>
      typedef geometry_msgs::Vector3 _angular_type;
      _angular_type angular;

    Twist():
      linear(),
      angular()
    478a:	4f29      	ldr	r7, [pc, #164]	; (4830 <_GLOBAL__sub_I_error_l+0x218>)
    478c:	e9c1 231e 	strd	r2, r3, [r1, #120]	; 0x78
    4790:	e9c0 2308 	strd	r2, r3, [r0, #32]
    4794:	e9c0 230a 	strd	r2, r3, [r0, #40]	; 0x28
    4798:	e9c0 230c 	strd	r2, r3, [r0, #48]	; 0x30
    479c:	e9c0 2310 	strd	r2, r3, [r0, #64]	; 0x40
    47a0:	e9c0 2312 	strd	r2, r3, [r0, #72]	; 0x48
    47a4:	e9c0 2314 	strd	r2, r3, [r0, #80]	; 0x50
    47a8:	6134      	str	r4, [r6, #16]
    47aa:	2201      	movs	r2, #1
    47ac:	4c21      	ldr	r4, [pc, #132]	; (4834 <_GLOBAL__sub_I_error_l+0x21c>)
  {
    topic_ = topic_name;
    47ae:	4b22      	ldr	r3, [pc, #136]	; (4838 <_GLOBAL__sub_I_error_l+0x220>)
    47b0:	6071      	str	r1, [r6, #4]
    47b2:	f8c6 c000 	str.w	ip, [r6]
    47b6:	6185      	str	r5, [r0, #24]
    47b8:	6385      	str	r5, [r0, #56]	; 0x38
  typedef void(*CallbackT)(const MsgT&);
  MsgT msg;

  Subscriber(const char * topic_name, CallbackT cb, int endpoint = rosserial_msgs::TopicInfo::ID_SUBSCRIBER) :
    cb_(cb),
    endpoint_(endpoint)
    47ba:	f8c0 e000 	str.w	lr, [r0]
    47be:	6107      	str	r7, [r0, #16]
    47c0:	6584      	str	r4, [r0, #88]	; 0x58
    47c2:	65c2      	str	r2, [r0, #92]	; 0x5c
  {
    topic_ = topic_name;
    47c4:	6083      	str	r3, [r0, #8]
    47c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    47c8:	1fff1c78 	.word	0x1fff1c78
    47cc:	1fff1d58 	.word	0x1fff1d58
    47d0:	1fff0b28 	.word	0x1fff0b28
    47d4:	000097ac 	.word	0x000097ac
    47d8:	00009704 	.word	0x00009704
    47dc:	1fff1ca4 	.word	0x1fff1ca4
    47e0:	1fff1d10 	.word	0x1fff1d10
    47e4:	1fff1470 	.word	0x1fff1470
    47e8:	00009734 	.word	0x00009734
    47ec:	1fff1c88 	.word	0x1fff1c88
    47f0:	0000971c 	.word	0x0000971c
    47f4:	00009afc 	.word	0x00009afc
    47f8:	1fff2b08 	.word	0x1fff2b08
    47fc:	1fff1d18 	.word	0x1fff1d18
    4800:	00009b14 	.word	0x00009b14
    4804:	1fff2b28 	.word	0x1fff2b28
    4808:	00009b20 	.word	0x00009b20
    480c:	1fff1440 	.word	0x1fff1440
    4810:	1fff2b74 	.word	0x1fff2b74
    4814:	00009764 	.word	0x00009764
    4818:	0000974c 	.word	0x0000974c
    481c:	1fff2a88 	.word	0x1fff2a88
    4820:	00009b30 	.word	0x00009b30
    4824:	00009794 	.word	0x00009794
    4828:	1fff1cb0 	.word	0x1fff1cb0
    482c:	1fff2290 	.word	0x1fff2290
    4830:	0000977c 	.word	0x0000977c
    4834:	00002455 	.word	0x00002455
    4838:	00009b54 	.word	0x00009b54
    483c:	1fff2b50 	.word	0x1fff2b50
    4840:	00009b08 	.word	0x00009b08
    4844:	00009b40 	.word	0x00009b40
    4848:	000097c0 	.word	0x000097c0

0000484c <TwoWire::available()>:
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    484c:	f890 2039 	ldrb.w	r2, [r0, #57]	; 0x39
    4850:	f890 0038 	ldrb.w	r0, [r0, #56]	; 0x38
	}
    4854:	1a10      	subs	r0, r2, r0
    4856:	4770      	bx	lr

00004858 <TwoWire::read()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    4858:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
    485c:	f890 2039 	ldrb.w	r2, [r0, #57]	; 0x39
    4860:	429a      	cmp	r2, r3
    4862:	d905      	bls.n	4870 <TwoWire::read()+0x18>
		return rxBuffer[rxBufferIndex++];
    4864:	1c5a      	adds	r2, r3, #1
    4866:	4403      	add	r3, r0
    4868:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    486c:	7e18      	ldrb	r0, [r3, #24]
    486e:	4770      	bx	lr
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    4870:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		return rxBuffer[rxBufferIndex++];
	}
    4874:	4770      	bx	lr
    4876:	bf00      	nop

00004878 <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
    4878:	2000      	movs	r0, #0
    487a:	4770      	bx	lr

0000487c <TwoWire::peek()>:
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    487c:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
    4880:	f890 2039 	ldrb.w	r2, [r0, #57]	; 0x39
    4884:	429a      	cmp	r2, r3
		return rxBuffer[rxBufferIndex];
    4886:	bf86      	itte	hi
    4888:	181b      	addhi	r3, r3, r0
    488a:	7e18      	ldrbhi	r0, [r3, #24]
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    488c:	f04f 30ff 	movls.w	r0, #4294967295	; 0xffffffff
		return rxBuffer[rxBufferIndex];
	}
    4890:	4770      	bx	lr
    4892:	bf00      	nop

00004894 <TwoWire::flush()>:
	virtual void flush(void) {
    4894:	4770      	bx	lr
    4896:	bf00      	nop

00004898 <TwoWire::write(unsigned char const*, unsigned int)>:
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    4898:	b538      	push	{r3, r4, r5, lr}
    489a:	4605      	mov	r5, r0
	if (transmitting || slave_mode) {
    489c:	f8b0 005e 	ldrh.w	r0, [r0, #94]	; 0x5e
    48a0:	b190      	cbz	r0, 48c8 <TwoWire::write(unsigned char const*, unsigned int)+0x30>
		size_t avail = BUFFER_LENGTH+1 - txBufferLength;
    48a2:	f895 305d 	ldrb.w	r3, [r5, #93]	; 0x5d
    48a6:	4614      	mov	r4, r2
    48a8:	f1c3 0221 	rsb	r2, r3, #33	; 0x21
		if (quantity > avail) {
    48ac:	4294      	cmp	r4, r2
    48ae:	d80c      	bhi.n	48ca <TwoWire::write(unsigned char const*, unsigned int)+0x32>
			quantity = avail;
			setWriteError();
		}
		memcpy(txBuffer + txBufferLength, data, quantity);
    48b0:	f105 003b 	add.w	r0, r5, #59	; 0x3b
    48b4:	4418      	add	r0, r3
    48b6:	4622      	mov	r2, r4
    48b8:	f000 f8e2 	bl	4a80 <memcpy>
		txBufferLength += quantity;
    48bc:	f895 305d 	ldrb.w	r3, [r5, #93]	; 0x5d
    48c0:	4423      	add	r3, r4
    48c2:	f885 305d 	strb.w	r3, [r5, #93]	; 0x5d
    48c6:	4620      	mov	r0, r4
		return quantity;
	}
	return 0;
}
    48c8:	bd38      	pop	{r3, r4, r5, pc}
	// format warnings are too pedantic - disable until newer toolchain offers better...
	// https://forum.pjrc.com/threads/62473?p=256873&viewfull=1#post256873
	int printf(const char *format, ...) /*__attribute__ ((format (printf, 2, 3)))*/;
	int printf(const __FlashStringHelper *format, ...);
  protected:
	void setWriteError(int err = 1) { write_error = err; }
    48ca:	2001      	movs	r0, #1
    48cc:	4614      	mov	r4, r2
    48ce:	7128      	strb	r0, [r5, #4]
    48d0:	e7ee      	b.n	48b0 <TwoWire::write(unsigned char const*, unsigned int)+0x18>
    48d2:	bf00      	nop

000048d4 <TwoWire::write(unsigned char)>:
//  I2C0_C2      // I2C Control Register 2
//  I2C0_FLT     // I2C Programmable Input Glitch Filter register

size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
    48d4:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
    48d8:	b16b      	cbz	r3, 48f6 <TwoWire::write(unsigned char)+0x22>
		if (txBufferLength >= BUFFER_LENGTH+1) {
    48da:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
    48de:	2b20      	cmp	r3, #32
    48e0:	d807      	bhi.n	48f2 <TwoWire::write(unsigned char)+0x1e>
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    48e2:	18c2      	adds	r2, r0, r3
    48e4:	3301      	adds	r3, #1
    48e6:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d
		return 1;
    48ea:	2001      	movs	r0, #1
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    48ec:	f882 103b 	strb.w	r1, [r2, #59]	; 0x3b
    48f0:	4770      	bx	lr
    48f2:	2301      	movs	r3, #1
    48f4:	7103      	strb	r3, [r0, #4]
size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
    48f6:	2000      	movs	r0, #0
    48f8:	4770      	bx	lr
    48fa:	bf00      	nop

000048fc <TwoWire::isr()>:
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    48fc:	b538      	push	{r3, r4, r5, lr}
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    48fe:	6902      	ldr	r2, [r0, #16]
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
    4900:	78d4      	ldrb	r4, [r2, #3]
    4902:	b2e4      	uxtb	r4, r4
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    4904:	06e1      	lsls	r1, r4, #27
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    4906:	4605      	mov	r5, r0
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    4908:	d524      	bpl.n	4954 <TwoWire::isr()+0x58>
		// Arbitration Lost
		port().S = I2C_S_ARBL;
    490a:	2310      	movs	r3, #16
    490c:	70d3      	strb	r3, [r2, #3]
		if (receiving && rxBufferLength > 0) {
			// TODO: does this detect the STOP condition in slave receive mode?


		}
		if (!(status & I2C_S_IAAS)) return;
    490e:	0663      	lsls	r3, r4, #25
    4910:	d51f      	bpl.n	4952 <TwoWire::isr()+0x56>
	}
	if (status & I2C_S_IAAS) {
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
    4912:	f004 0404 	and.w	r4, r4, #4
    4916:	f004 03ff 	and.w	r3, r4, #255	; 0xff
    491a:	2c00      	cmp	r4, #0
    491c:	d05a      	beq.n	49d4 <TwoWire::isr()+0xd8>
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
    491e:	4942      	ldr	r1, [pc, #264]	; (4a28 <TwoWire::isr()+0x12c>)
			txBufferLength = 0;
			if (user_onRequest != NULL) {
    4920:	6e6a      	ldr	r2, [r5, #100]	; 0x64
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
    4922:	2300      	movs	r3, #0
    4924:	700b      	strb	r3, [r1, #0]
			txBufferLength = 0;
    4926:	f885 305d 	strb.w	r3, [r5, #93]	; 0x5d
			if (user_onRequest != NULL) {
    492a:	2a00      	cmp	r2, #0
    492c:	d066      	beq.n	49fc <TwoWire::isr()+0x100>
				user_onRequest();
    492e:	4790      	blx	r2
			}
			if (txBufferLength == 0) {
    4930:	f895 305d 	ldrb.w	r3, [r5, #93]	; 0x5d
    4934:	2b00      	cmp	r3, #0
    4936:	d061      	beq.n	49fc <TwoWire::isr()+0x100>
    4938:	692b      	ldr	r3, [r5, #16]
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
				txBuffer[0] = 0;
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    493a:	22d0      	movs	r2, #208	; 0xd0
    493c:	709a      	strb	r2, [r3, #2]
    493e:	692b      	ldr	r3, [r5, #16]
			port().D = txBuffer[0];
    4940:	f895 203b 	ldrb.w	r2, [r5, #59]	; 0x3b
    4944:	711a      	strb	r2, [r3, #4]
    4946:	692b      	ldr	r3, [r5, #16]
			txBufferIndex = 1;
    4948:	2201      	movs	r2, #1
    494a:	f885 205c 	strb.w	r2, [r5, #92]	; 0x5c
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    494e:	2202      	movs	r2, #2
    4950:	70da      	strb	r2, [r3, #3]
    4952:	bd38      	pop	{r3, r4, r5, pc}


		}
		if (!(status & I2C_S_IAAS)) return;
	}
	if (status & I2C_S_IAAS) {
    4954:	f004 0340 	and.w	r3, r4, #64	; 0x40
    4958:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    495c:	2b00      	cmp	r3, #0
    495e:	d1d8      	bne.n	4912 <TwoWire::isr()+0x16>
		}
		port().S = I2C_S_IICIF;
		return;
	}
	#if defined(WIRE_HAS_STOP_INTERRUPT)
	c1 = port().FLT;
    4960:	7993      	ldrb	r3, [r2, #6]
    4962:	b2db      	uxtb	r3, r3
	if ((c1 & I2C_FLT_STOPF) && (c1 & I2C_FLT_STOPIE)) {
    4964:	f003 0160 	and.w	r1, r3, #96	; 0x60
    4968:	2960      	cmp	r1, #96	; 0x60
    496a:	d04e      	beq.n	4a0a <TwoWire::isr()+0x10e>
			rxBufferIndex = 0;
			user_onReceive(rxBufferLength);
		}
	}
	#endif
	c1 = port().C1;
    496c:	7893      	ldrb	r3, [r2, #2]
	if (c1 & I2C_C1_TX) {
    496e:	f003 0310 	and.w	r3, r3, #16
    4972:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    4976:	b1b3      	cbz	r3, 49a6 <TwoWire::isr()+0xaa>
		// Continue Slave Transmit
		//serial_print("t");
		if ((status & I2C_S_RXAK) == 0) {
    4978:	f014 0401 	ands.w	r4, r4, #1
    497c:	d137      	bne.n	49ee <TwoWire::isr()+0xf2>
			//serial_print(".");
			// Master ACK'd previous byte
			if (txBufferIndex < txBufferLength) {
    497e:	f895 305c 	ldrb.w	r3, [r5, #92]	; 0x5c
    4982:	f895 105d 	ldrb.w	r1, [r5, #93]	; 0x5d
    4986:	4299      	cmp	r1, r3
    4988:	d94b      	bls.n	4a22 <TwoWire::isr()+0x126>
				port().D = txBuffer[txBufferIndex++];
    498a:	1c59      	adds	r1, r3, #1
    498c:	442b      	add	r3, r5
    498e:	f885 105c 	strb.w	r1, [r5, #92]	; 0x5c
    4992:	f893 303b 	ldrb.w	r3, [r3, #59]	; 0x3b
    4996:	7113      	strb	r3, [r2, #4]
    4998:	692b      	ldr	r3, [r5, #16]
			} else {
				port().D = 0;
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    499a:	22d0      	movs	r2, #208	; 0xd0
    499c:	709a      	strb	r2, [r3, #2]
    499e:	692b      	ldr	r3, [r5, #16]
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    49a0:	2202      	movs	r2, #2
    49a2:	70da      	strb	r2, [r3, #3]
    49a4:	e7d5      	b.n	4952 <TwoWire::isr()+0x56>
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
			data = port().D;
		}
	} else {
		// Continue Slave Receive
		irqcount = 0;
    49a6:	f885 1060 	strb.w	r1, [r5, #96]	; 0x60
		#ifdef WIRE_HAS_STOP_INTERRUPT
		port().FLT |= I2C_FLT_STOPIE;
    49aa:	7993      	ldrb	r3, [r2, #6]
    49ac:	f043 0320 	orr.w	r3, r3, #32
    49b0:	7193      	strb	r3, [r2, #6]
    49b2:	692b      	ldr	r3, [r5, #16]
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    49b4:	f895 1039 	ldrb.w	r1, [r5, #57]	; 0x39
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    49b8:	791a      	ldrb	r2, [r3, #4]
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    49ba:	291f      	cmp	r1, #31
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    49bc:	b2d2      	uxtb	r2, r2
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    49be:	d8c6      	bhi.n	494e <TwoWire::isr()+0x52>
    49c0:	4819      	ldr	r0, [pc, #100]	; (4a28 <TwoWire::isr()+0x12c>)
    49c2:	7800      	ldrb	r0, [r0, #0]
    49c4:	2800      	cmp	r0, #0
    49c6:	d0c2      	beq.n	494e <TwoWire::isr()+0x52>
			rxBuffer[rxBufferLength++] = data;
    49c8:	1868      	adds	r0, r5, r1
    49ca:	3101      	adds	r1, #1
    49cc:	f885 1039 	strb.w	r1, [r5, #57]	; 0x39
    49d0:	7602      	strb	r2, [r0, #24]
    49d2:	e7bc      	b.n	494e <TwoWire::isr()+0x52>
    49d4:	692a      	ldr	r2, [r5, #16]
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
			rxBufferLength = 0;
    49d6:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
    49da:	23c0      	movs	r3, #192	; 0xc0
    49dc:	7093      	strb	r3, [r2, #2]
    49de:	692b      	ldr	r3, [r5, #16]
			port().D = txBuffer[0];
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
    49e0:	4a11      	ldr	r2, [pc, #68]	; (4a28 <TwoWire::isr()+0x12c>)
			rxBufferLength = 0;
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
			data = port().D;
    49e2:	7919      	ldrb	r1, [r3, #4]
			port().D = txBuffer[0];
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
    49e4:	2101      	movs	r1, #1
    49e6:	7011      	strb	r1, [r2, #0]
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    49e8:	2202      	movs	r2, #2
    49ea:	70da      	strb	r2, [r3, #3]
    49ec:	e7b1      	b.n	4952 <TwoWire::isr()+0x56>
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
		} else {
			//serial_print("*");
			// Master did not ACK previous byte
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
    49ee:	23c0      	movs	r3, #192	; 0xc0
    49f0:	7093      	strb	r3, [r2, #2]
    49f2:	692b      	ldr	r3, [r5, #16]
			data = port().D;
    49f4:	791a      	ldrb	r2, [r3, #4]
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    49f6:	2202      	movs	r2, #2
    49f8:	70da      	strb	r2, [r3, #3]
    49fa:	e7aa      	b.n	4952 <TwoWire::isr()+0x56>
			}
			if (txBufferLength == 0) {
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
    49fc:	2201      	movs	r2, #1
				txBuffer[0] = 0;
    49fe:	2300      	movs	r3, #0
			}
			if (txBufferLength == 0) {
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
    4a00:	f885 205d 	strb.w	r2, [r5, #93]	; 0x5d
				txBuffer[0] = 0;
    4a04:	f885 303b 	strb.w	r3, [r5, #59]	; 0x3b
    4a08:	e796      	b.n	4938 <TwoWire::isr()+0x3c>
		return;
	}
	#if defined(WIRE_HAS_STOP_INTERRUPT)
	c1 = port().FLT;
	if ((c1 & I2C_FLT_STOPF) && (c1 & I2C_FLT_STOPIE)) {
		port().FLT = c1 & ~I2C_FLT_STOPIE;
    4a0a:	f003 03df 	and.w	r3, r3, #223	; 0xdf
    4a0e:	7193      	strb	r3, [r2, #6]
		if (user_onReceive != NULL) {
    4a10:	6eab      	ldr	r3, [r5, #104]	; 0x68
    4a12:	b123      	cbz	r3, 4a1e <TwoWire::isr()+0x122>
			rxBufferIndex = 0;
    4a14:	f885 0038 	strb.w	r0, [r5, #56]	; 0x38
			user_onReceive(rxBufferLength);
    4a18:	f895 0039 	ldrb.w	r0, [r5, #57]	; 0x39
    4a1c:	4798      	blx	r3
    4a1e:	692a      	ldr	r2, [r5, #16]
    4a20:	e7a4      	b.n	496c <TwoWire::isr()+0x70>
			//serial_print(".");
			// Master ACK'd previous byte
			if (txBufferIndex < txBufferLength) {
				port().D = txBuffer[txBufferIndex++];
			} else {
				port().D = 0;
    4a22:	7114      	strb	r4, [r2, #4]
    4a24:	e7b8      	b.n	4998 <TwoWire::isr()+0x9c>
    4a26:	bf00      	nop
    4a28:	1fff2ba0 	.word	0x1fff2ba0

00004a2c <i2c0_isr>:
#define MAKE_CONST(x) (__builtin_constant_p(x) ? (x) : (x))

#ifdef WIRE_IMPLEMENT_WIRE
constexpr uintptr_t i2c0_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C0));
TwoWire Wire(i2c0_addr, TwoWire::i2c0_hardware);
void i2c0_isr(void) { Wire.isr(); }
    4a2c:	4801      	ldr	r0, [pc, #4]	; (4a34 <i2c0_isr+0x8>)
    4a2e:	f7ff bf65 	b.w	48fc <TwoWire::isr()>
    4a32:	bf00      	nop
    4a34:	1fff0890 	.word	0x1fff0890

00004a38 <i2c1_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE1
constexpr uintptr_t i2c1_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C1));
TwoWire Wire1(i2c1_addr, TwoWire::i2c1_hardware);
void i2c1_isr(void) { Wire1.isr(); }
    4a38:	4801      	ldr	r0, [pc, #4]	; (4a40 <i2c1_isr+0x8>)
    4a3a:	f7ff bf5f 	b.w	48fc <TwoWire::isr()>
    4a3e:	bf00      	nop
    4a40:	1fff08fc 	.word	0x1fff08fc

00004a44 <i2c2_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE2
constexpr uintptr_t i2c2_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C2));
TwoWire Wire2(i2c2_addr, TwoWire::i2c2_hardware);
void i2c2_isr(void) { Wire2.isr(); }
    4a44:	4801      	ldr	r0, [pc, #4]	; (4a4c <i2c2_isr+0x8>)
    4a46:	f7ff bf59 	b.w	48fc <TwoWire::isr()>
    4a4a:	bf00      	nop
    4a4c:	1fff0824 	.word	0x1fff0824

00004a50 <MPU9250::MPU9250()>:

/** Default constructor, uses default I2C address.
 * @see MPU9250_DEFAULT_ADDRESS
 */
MPU9250::MPU9250() {
    devAddr = MPU9250_DEFAULT_ADDRESS;
    4a50:	2368      	movs	r3, #104	; 0x68
    4a52:	7003      	strb	r3, [r0, #0]
}
    4a54:	4770      	bx	lr
    4a56:	bf00      	nop

00004a58 <ros::normalizeSecNSec(unsigned long&, unsigned long&)>:
#include "ros/time.h"

namespace ros
{
void normalizeSecNSec(uint32_t& sec, uint32_t& nsec)
{
    4a58:	b470      	push	{r4, r5, r6}
  uint32_t nsec_part = nsec % 1000000000UL;
    4a5a:	680d      	ldr	r5, [r1, #0]
  uint32_t sec_part = nsec / 1000000000UL;
  sec += sec_part;
    4a5c:	4b06      	ldr	r3, [pc, #24]	; (4a78 <ros::normalizeSecNSec(unsigned long&, unsigned long&)+0x20>)
    4a5e:	6804      	ldr	r4, [r0, #0]
  nsec = nsec_part;
    4a60:	4e06      	ldr	r6, [pc, #24]	; (4a7c <ros::normalizeSecNSec(unsigned long&, unsigned long&)+0x24>)
{
void normalizeSecNSec(uint32_t& sec, uint32_t& nsec)
{
  uint32_t nsec_part = nsec % 1000000000UL;
  uint32_t sec_part = nsec / 1000000000UL;
  sec += sec_part;
    4a62:	0a6a      	lsrs	r2, r5, #9
    4a64:	fba3 3202 	umull	r3, r2, r3, r2
    4a68:	09d3      	lsrs	r3, r2, #7
    4a6a:	441c      	add	r4, r3
  nsec = nsec_part;
    4a6c:	fb06 5313 	mls	r3, r6, r3, r5
{
void normalizeSecNSec(uint32_t& sec, uint32_t& nsec)
{
  uint32_t nsec_part = nsec % 1000000000UL;
  uint32_t sec_part = nsec / 1000000000UL;
  sec += sec_part;
    4a70:	6004      	str	r4, [r0, #0]
  nsec = nsec_part;
    4a72:	600b      	str	r3, [r1, #0]
}
    4a74:	bc70      	pop	{r4, r5, r6}
    4a76:	4770      	bx	lr
    4a78:	00044b83 	.word	0x00044b83
    4a7c:	3b9aca00 	.word	0x3b9aca00

00004a80 <memcpy>:
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
#else
	push	{r0}
    4a80:	b401      	push	{r0}
#endif
	orr	r3, r1, r0
    4a82:	ea41 0300 	orr.w	r3, r1, r0
	ands	r3, r3, #3
    4a86:	f013 0303 	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    4a8a:	d16f      	bne.n	4b6c <memcpy+0xec>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    4a8c:	3a40      	subs	r2, #64	; 0x40
	blo	.Lmid_block
    4a8e:	d341      	bcc.n	4b14 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    4a90:	f851 3b04 	ldr.w	r3, [r1], #4
    4a94:	f840 3b04 	str.w	r3, [r0], #4
    4a98:	f851 3b04 	ldr.w	r3, [r1], #4
    4a9c:	f840 3b04 	str.w	r3, [r0], #4
    4aa0:	f851 3b04 	ldr.w	r3, [r1], #4
    4aa4:	f840 3b04 	str.w	r3, [r0], #4
    4aa8:	f851 3b04 	ldr.w	r3, [r1], #4
    4aac:	f840 3b04 	str.w	r3, [r0], #4
    4ab0:	f851 3b04 	ldr.w	r3, [r1], #4
    4ab4:	f840 3b04 	str.w	r3, [r0], #4
    4ab8:	f851 3b04 	ldr.w	r3, [r1], #4
    4abc:	f840 3b04 	str.w	r3, [r0], #4
    4ac0:	f851 3b04 	ldr.w	r3, [r1], #4
    4ac4:	f840 3b04 	str.w	r3, [r0], #4
    4ac8:	f851 3b04 	ldr.w	r3, [r1], #4
    4acc:	f840 3b04 	str.w	r3, [r0], #4
    4ad0:	f851 3b04 	ldr.w	r3, [r1], #4
    4ad4:	f840 3b04 	str.w	r3, [r0], #4
    4ad8:	f851 3b04 	ldr.w	r3, [r1], #4
    4adc:	f840 3b04 	str.w	r3, [r0], #4
    4ae0:	f851 3b04 	ldr.w	r3, [r1], #4
    4ae4:	f840 3b04 	str.w	r3, [r0], #4
    4ae8:	f851 3b04 	ldr.w	r3, [r1], #4
    4aec:	f840 3b04 	str.w	r3, [r0], #4
    4af0:	f851 3b04 	ldr.w	r3, [r1], #4
    4af4:	f840 3b04 	str.w	r3, [r0], #4
    4af8:	f851 3b04 	ldr.w	r3, [r1], #4
    4afc:	f840 3b04 	str.w	r3, [r0], #4
    4b00:	f851 3b04 	ldr.w	r3, [r1], #4
    4b04:	f840 3b04 	str.w	r3, [r0], #4
    4b08:	f851 3b04 	ldr.w	r3, [r1], #4
    4b0c:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    4b10:	3a40      	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    4b12:	d2bd      	bcs.n	4a90 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    4b14:	3230      	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    4b16:	d311      	bcc.n	4b3c <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    4b18:	f851 3b04 	ldr.w	r3, [r1], #4
    4b1c:	f840 3b04 	str.w	r3, [r0], #4
    4b20:	f851 3b04 	ldr.w	r3, [r1], #4
    4b24:	f840 3b04 	str.w	r3, [r0], #4
    4b28:	f851 3b04 	ldr.w	r3, [r1], #4
    4b2c:	f840 3b04 	str.w	r3, [r0], #4
    4b30:	f851 3b04 	ldr.w	r3, [r1], #4
    4b34:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    4b38:	3a10      	subs	r2, #16
	bhs	.Lmid_block_loop
    4b3a:	d2ed      	bcs.n	4b18 <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    4b3c:	320c      	adds	r2, #12
	blo	.Lcopy_less_than_4
    4b3e:	d305      	bcc.n	4b4c <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    4b40:	f851 3b04 	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    4b44:	f840 3b04 	str.w	r3, [r0], #4
	subs	r2, #4
    4b48:	3a04      	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    4b4a:	d2f9      	bcs.n	4b40 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    4b4c:	3204      	adds	r2, #4
	beq	.Ldone
    4b4e:	d00a      	beq.n	4b66 <memcpy+0xe6>

	lsls	r2, r2, #31
    4b50:	07d2      	lsls	r2, r2, #31
	itt ne
    4b52:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    4b54:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    4b58:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc	.Ldone
    4b5c:	d303      	bcc.n	4b66 <memcpy+0xe6>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
	strh	r3, [r0]
#else
	ldrb	r3, [r1]
    4b5e:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    4b60:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    4b62:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    4b64:	7043      	strb	r3, [r0, #1]

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    4b66:	bc01      	pop	{r0}
#endif
	bx	lr
    4b68:	4770      	bx	lr
    4b6a:	bf00      	nop
	beq	.Ldst_aligned
#else
	/* if len < 12, misalignment adjustment has more overhead than
	just byte-to-byte copy.  Also, len must >=8 to guarantee code
	afterward work correctly.  */
	cmp	r2, #12
    4b6c:	2a0c      	cmp	r2, #12
	blo	.Lbyte_copy
    4b6e:	d34a      	bcc.n	4c06 <memcpy+0x186>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    4b70:	f010 0303 	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    4b74:	d011      	beq.n	4b9a <memcpy+0x11a>

	rsb	r3, #4
    4b76:	f1c3 0304 	rsb	r3, r3, #4
	subs	r2, r3
    4b7a:	1ad2      	subs	r2, r2, r3

	lsls    r3, r3, #31
    4b7c:	07db      	lsls	r3, r3, #31
	itt ne
    4b7e:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    4b80:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    4b84:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    4b88:	d307      	bcc.n	4b9a <memcpy+0x11a>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
	strh    r3, [r0], #2
	b	.Ldst_aligned
#else
	ldrb    r3, [r1], #1
    4b8a:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    4b8e:	f800 3b01 	strb.w	r3, [r0], #1
	ldrb    r3, [r1], #1
    4b92:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    4b96:	f800 3b01 	strb.w	r3, [r0], #1
	/* Now that dst is aligned */
.Ldst_aligned:
	/* if r1 is aligned now, it means r0/r1 has the same misalignment,
	and they are both aligned now.  Go aligned copy.  */
	ands	r3, r1, #3
    4b9a:	f011 0303 	ands.w	r3, r1, #3
	beq	.Lbig_block
    4b9e:	f43f af75 	beq.w	4a8c <memcpy+0xc>

	/* dst is aligned, but src isn't.  Misaligned copy.  */

	push	{r4, r5}
    4ba2:	b430      	push	{r4, r5}
	subs	r2, #4
    4ba4:	3a04      	subs	r2, #4

	/* Backward r1 by misaligned bytes, to make r1 aligned.
	Since we need to restore r1 to unaligned address after the loop,
	we need keep the offset bytes to ip and sub it from r1 afterward.  */
	subs	r1, r3
    4ba6:	1ac9      	subs	r1, r1, r3
	rsb	ip, r3, #4
    4ba8:	f1c3 0c04 	rsb	ip, r3, #4

	/* Pre-load on word */
	ldr	r4, [r1], #4
    4bac:	f851 4b04 	ldr.w	r4, [r1], #4

	cmp	r3, #2
    4bb0:	2b02      	cmp	r3, #2
	beq	.Lmisaligned_copy_2_2
    4bb2:	d019      	beq.n	4be8 <memcpy+0x168>
	cmp	r3, #3
    4bb4:	2b03      	cmp	r3, #3
	beq	.Lmisaligned_copy_3_1
    4bb6:	d00b      	beq.n	4bd0 <memcpy+0x150>
	subs	r2, #4
	bhs	1b
	.endm

.Lmisaligned_copy_1_3:
	mis_src_copy shift=8
    4bb8:	0a24      	lsrs	r4, r4, #8
    4bba:	f851 3b04 	ldr.w	r3, [r1], #4
    4bbe:	061d      	lsls	r5, r3, #24
    4bc0:	ea44 0405 	orr.w	r4, r4, r5
    4bc4:	f840 4b04 	str.w	r4, [r0], #4
    4bc8:	461c      	mov	r4, r3
    4bca:	3a04      	subs	r2, #4
    4bcc:	d2f4      	bcs.n	4bb8 <memcpy+0x138>
	b	.Lsrc_misaligned_tail
    4bce:	e016      	b.n	4bfe <memcpy+0x17e>

.Lmisaligned_copy_3_1:
	mis_src_copy shift=24
    4bd0:	0e24      	lsrs	r4, r4, #24
    4bd2:	f851 3b04 	ldr.w	r3, [r1], #4
    4bd6:	021d      	lsls	r5, r3, #8
    4bd8:	ea44 0405 	orr.w	r4, r4, r5
    4bdc:	f840 4b04 	str.w	r4, [r0], #4
    4be0:	461c      	mov	r4, r3
    4be2:	3a04      	subs	r2, #4
    4be4:	d2f4      	bcs.n	4bd0 <memcpy+0x150>
	b	.Lsrc_misaligned_tail
    4be6:	e00a      	b.n	4bfe <memcpy+0x17e>

.Lmisaligned_copy_2_2:
	/* For 2_2 misalignment, ldr is still faster than 2 x ldrh.  */
	mis_src_copy shift=16
    4be8:	0c24      	lsrs	r4, r4, #16
    4bea:	f851 3b04 	ldr.w	r3, [r1], #4
    4bee:	041d      	lsls	r5, r3, #16
    4bf0:	ea44 0405 	orr.w	r4, r4, r5
    4bf4:	f840 4b04 	str.w	r4, [r0], #4
    4bf8:	461c      	mov	r4, r3
    4bfa:	3a04      	subs	r2, #4
    4bfc:	d2f4      	bcs.n	4be8 <memcpy+0x168>

.Lsrc_misaligned_tail:
	adds	r2, #4
    4bfe:	3204      	adds	r2, #4
	subs	r1, ip
    4c00:	ebb1 010c 	subs.w	r1, r1, ip
	pop	{r4, r5}
    4c04:	bc30      	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    4c06:	3a04      	subs	r2, #4
	blo	.Lcopy_less_than_4
    4c08:	d3a0      	bcc.n	4b4c <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    4c0a:	3a01      	subs	r2, #1
	ldrb    r3, [r1], #1
    4c0c:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    4c10:	f800 3b01 	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    4c14:	d2f9      	bcs.n	4c0a <memcpy+0x18a>

	ldrb	r3, [r1]
    4c16:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    4c18:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    4c1a:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    4c1c:	7043      	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    4c1e:	788b      	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    4c20:	7083      	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    4c22:	bc01      	pop	{r0}
#endif
	bx	lr
    4c24:	4770      	bx	lr
    4c26:	bf00      	nop

00004c28 <fault_isr>:
void _init_Teensyduino_internal_(void) __attribute__((noinline));
void __libc_init_array(void);


void fault_isr(void)
{
    4c28:	b508      	push	{r3, lr}
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    4c2a:	4c10      	ldr	r4, [pc, #64]	; (4c6c <fault_isr+0x44>)
    4c2c:	e008      	b.n	4c40 <fault_isr+0x18>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    4c2e:	6823      	ldr	r3, [r4, #0]
    4c30:	0559      	lsls	r1, r3, #21
    4c32:	d40d      	bmi.n	4c50 <fault_isr+0x28>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    4c34:	6823      	ldr	r3, [r4, #0]
    4c36:	051a      	lsls	r2, r3, #20
    4c38:	d40f      	bmi.n	4c5a <fault_isr+0x32>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    4c3a:	6823      	ldr	r3, [r4, #0]
    4c3c:	04db      	lsls	r3, r3, #19
    4c3e:	d411      	bmi.n	4c64 <fault_isr+0x3c>
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    4c40:	6823      	ldr	r3, [r4, #0]
    4c42:	0358      	lsls	r0, r3, #13
    4c44:	d5f3      	bpl.n	4c2e <fault_isr+0x6>
    4c46:	f000 fceb 	bl	5620 <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    4c4a:	6823      	ldr	r3, [r4, #0]
    4c4c:	0559      	lsls	r1, r3, #21
    4c4e:	d5f1      	bpl.n	4c34 <fault_isr+0xc>
    4c50:	f000 f80e 	bl	4c70 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    4c54:	6823      	ldr	r3, [r4, #0]
    4c56:	051a      	lsls	r2, r3, #20
    4c58:	d5ef      	bpl.n	4c3a <fault_isr+0x12>
    4c5a:	f000 f809 	bl	4c70 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    4c5e:	6823      	ldr	r3, [r4, #0]
    4c60:	04db      	lsls	r3, r3, #19
    4c62:	d5ed      	bpl.n	4c40 <fault_isr+0x18>
    4c64:	f000 f804 	bl	4c70 <unused_isr>
    4c68:	e7ea      	b.n	4c40 <fault_isr+0x18>
    4c6a:	bf00      	nop
    4c6c:	40048034 	.word	0x40048034

00004c70 <unused_isr>:
	}
}

void unused_isr(void)
{
    4c70:	b508      	push	{r3, lr}
	fault_isr();
    4c72:	f7ff ffd9 	bl	4c28 <fault_isr>
    4c76:	bf00      	nop

00004c78 <startup_early_hook>:
extern void rtc_set(unsigned long t);


static void startup_default_early_hook(void) {
#if defined(KINETISK)
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    4c78:	4b01      	ldr	r3, [pc, #4]	; (4c80 <startup_early_hook+0x8>)
    4c7a:	2210      	movs	r2, #16
    4c7c:	801a      	strh	r2, [r3, #0]
    4c7e:	4770      	bx	lr
    4c80:	40052000 	.word	0x40052000

00004c84 <startup_late_hook>:
#elif defined(KINETISL)
	SIM_COPC = 0;  // disable the watchdog
#endif
}
static void startup_default_late_hook(void) {}
    4c84:	4770      	bx	lr
    4c86:	bf00      	nop

00004c88 <_sbrk>:

void * _sbrk(int incr)
{
	char *prev, *stack;

	prev = __brkval;
    4c88:	4909      	ldr	r1, [pc, #36]	; (4cb0 <_sbrk+0x28>)

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

void * _sbrk(int incr)
{
    4c8a:	b508      	push	{r3, lr}
	char *prev, *stack;

	prev = __brkval;
    4c8c:	680b      	ldr	r3, [r1, #0]
	if (incr != 0) {
    4c8e:	b130      	cbz	r0, 4c9e <_sbrk+0x16>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
    4c90:	466a      	mov	r2, sp
		if (prev + incr >= stack - STACK_MARGIN) {
    4c92:	4418      	add	r0, r3
    4c94:	f5a2 5200 	sub.w	r2, r2, #8192	; 0x2000
    4c98:	4290      	cmp	r0, r2
    4c9a:	d202      	bcs.n	4ca2 <_sbrk+0x1a>
			errno = ENOMEM;
			return (void *)-1;
		}
		__brkval = prev + incr;
    4c9c:	6008      	str	r0, [r1, #0]
	}
	return prev;
    4c9e:	4618      	mov	r0, r3
}
    4ca0:	bd08      	pop	{r3, pc}

	prev = __brkval;
	if (incr != 0) {
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
		if (prev + incr >= stack - STACK_MARGIN) {
			errno = ENOMEM;
    4ca2:	f003 fb59 	bl	8358 <__errno>
    4ca6:	230c      	movs	r3, #12
    4ca8:	6003      	str	r3, [r0, #0]
			return (void *)-1;
    4caa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    4cae:	bd08      	pop	{r3, pc}
    4cb0:	1fff0968 	.word	0x1fff0968

00004cb4 <kinetis_hsrun_disable>:


#if defined(HAS_KINETIS_HSRUN) && F_CPU > 120000000
int kinetis_hsrun_disable(void)
{
	if (SMC_PMSTAT == SMC_PMSTAT_HSRUN) {
    4cb4:	4a08      	ldr	r2, [pc, #32]	; (4cd8 <kinetis_hsrun_disable+0x24>)
    4cb6:	7813      	ldrb	r3, [r2, #0]
    4cb8:	2b80      	cmp	r3, #128	; 0x80
    4cba:	d001      	beq.n	4cc0 <kinetis_hsrun_disable+0xc>
		// Then turn off HSRUN mode
		SMC_PMCTRL = SMC_PMCTRL_RUNM(0);
		while (SMC_PMSTAT == SMC_PMSTAT_HSRUN) ; // wait
		return 1;
	}
	return 0;
    4cbc:	2000      	movs	r0, #0
}
    4cbe:	4770      	bx	lr
		#elif F_CPU == 192000000 && F_BUS == 64000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(2, 2, 2, 8); // ok
		#elif F_CPU == 192000000 && F_BUS == 96000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 7); // ok
		#elif F_CPU == 180000000 && F_BUS == 60000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(2, 2, 2, 8); // ok
    4cc0:	4906      	ldr	r1, [pc, #24]	; (4cdc <kinetis_hsrun_disable+0x28>)
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 5); // ok
		#else
			return 0;
		#endif
		// Then turn off HSRUN mode
		SMC_PMCTRL = SMC_PMCTRL_RUNM(0);
    4cc2:	4b07      	ldr	r3, [pc, #28]	; (4ce0 <kinetis_hsrun_disable+0x2c>)
		#elif F_CPU == 192000000 && F_BUS == 64000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(2, 2, 2, 8); // ok
		#elif F_CPU == 192000000 && F_BUS == 96000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 7); // ok
		#elif F_CPU == 180000000 && F_BUS == 60000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(2, 2, 2, 8); // ok
    4cc4:	4807      	ldr	r0, [pc, #28]	; (4ce4 <kinetis_hsrun_disable+0x30>)
    4cc6:	6008      	str	r0, [r1, #0]
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 5); // ok
		#else
			return 0;
		#endif
		// Then turn off HSRUN mode
		SMC_PMCTRL = SMC_PMCTRL_RUNM(0);
    4cc8:	2100      	movs	r1, #0
    4cca:	7019      	strb	r1, [r3, #0]
		while (SMC_PMSTAT == SMC_PMSTAT_HSRUN) ; // wait
    4ccc:	7813      	ldrb	r3, [r2, #0]
    4cce:	2b80      	cmp	r3, #128	; 0x80
    4cd0:	d0fc      	beq.n	4ccc <kinetis_hsrun_disable+0x18>
		return 1;
    4cd2:	2001      	movs	r0, #1
    4cd4:	4770      	bx	lr
    4cd6:	bf00      	nop
    4cd8:	4007e003 	.word	0x4007e003
    4cdc:	40048044 	.word	0x40048044
    4ce0:	4007e001 	.word	0x4007e001
    4ce4:	22280000 	.word	0x22280000

00004ce8 <kinetis_hsrun_enable>:
	return 0;
}

int kinetis_hsrun_enable(void)
{
	if (SMC_PMSTAT == SMC_PMSTAT_RUN) {
    4ce8:	4a09      	ldr	r2, [pc, #36]	; (4d10 <kinetis_hsrun_enable+0x28>)
    4cea:	7813      	ldrb	r3, [r2, #0]
    4cec:	2b01      	cmp	r3, #1
    4cee:	d001      	beq.n	4cf4 <kinetis_hsrun_enable+0xc>
		#else
			return 0;
		#endif
		return 1;
	}
	return 0;
    4cf0:	2000      	movs	r0, #0
}
    4cf2:	4770      	bx	lr

int kinetis_hsrun_enable(void)
{
	if (SMC_PMSTAT == SMC_PMSTAT_RUN) {
		// Turn HSRUN mode on
		SMC_PMCTRL = SMC_PMCTRL_RUNM(3);
    4cf4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    4cf8:	f503 23fc 	add.w	r3, r3, #516096	; 0x7e000
    4cfc:	2160      	movs	r1, #96	; 0x60
    4cfe:	7019      	strb	r1, [r3, #0]
		while (SMC_PMSTAT != SMC_PMSTAT_HSRUN) {;} // wait
    4d00:	7813      	ldrb	r3, [r2, #0]
    4d02:	2b80      	cmp	r3, #128	; 0x80
    4d04:	d1fc      	bne.n	4d00 <kinetis_hsrun_enable+0x18>
		#elif F_CPU == 192000000 && F_BUS == 64000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 2, 0, 6);
		#elif F_CPU == 192000000 && F_BUS == 96000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 1, 0, 6);
		#elif F_CPU == 180000000 && F_BUS == 60000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 2, 0, 6);
    4d06:	4b03      	ldr	r3, [pc, #12]	; (4d14 <kinetis_hsrun_enable+0x2c>)
    4d08:	4a03      	ldr	r2, [pc, #12]	; (4d18 <kinetis_hsrun_enable+0x30>)
    4d0a:	601a      	str	r2, [r3, #0]
		#elif F_CPU == 144000000 && F_BUS == 72000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 1, 0, 4);
		#else
			return 0;
		#endif
		return 1;
    4d0c:	2001      	movs	r0, #1
    4d0e:	4770      	bx	lr
    4d10:	4007e003 	.word	0x4007e003
    4d14:	40048044 	.word	0x40048044
    4d18:	02060000 	.word	0x02060000

00004d1c <dummy_isr>:
	{((volatile uint8_t *)&CORE_PIN26_PORTREG + (CORE_PIN26_BIT >> 3)), &CORE_PIN26_CONFIG, (1<<(CORE_PIN26_BIT & 7))}
};

#endif

static void dummy_isr() {};
    4d1c:	4770      	bx	lr
    4d1e:	bf00      	nop

00004d20 <digitalWrite.part.1>:



// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
    4d20:	b410      	push	{r4}
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
    4d22:	4b11      	ldr	r3, [pc, #68]	; (4d68 <digitalWrite.part.1+0x48>)
    4d24:	f853 2030 	ldr.w	r2, [r3, r0, lsl #3]
    4d28:	f892 4280 	ldrb.w	r4, [r2, #640]	; 0x280
    4d2c:	b134      	cbz	r4, 4d3c <digitalWrite.part.1+0x1c>
		if (val) {
			*portSetRegister(pin) = 1;
    4d2e:	2301      	movs	r3, #1
void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
    4d30:	b179      	cbz	r1, 4d52 <digitalWrite.part.1+0x32>
			*portSetRegister(pin) = 1;
    4d32:	f882 3080 	strb.w	r3, [r2, #128]	; 0x80
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    4d36:	f85d 4b04 	ldr.w	r4, [sp], #4
    4d3a:	4770      	bx	lr
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
    4d3c:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
    4d40:	685b      	ldr	r3, [r3, #4]
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    4d42:	681a      	ldr	r2, [r3, #0]
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
    4d44:	b951      	cbnz	r1, 4d5c <digitalWrite.part.1+0x3c>
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
			//*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else {
			// TODO use bitband for atomic read-mod-write
			*config &= ~(PORT_PCR_PE);
    4d46:	f022 0202 	bic.w	r2, r2, #2
    4d4a:	601a      	str	r2, [r3, #0]
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    4d4c:	f85d 4b04 	ldr.w	r4, [sp], #4
    4d50:	4770      	bx	lr
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
			*portSetRegister(pin) = 1;
		} else {
			*portClearRegister(pin) = 1;
    4d52:	f882 3100 	strb.w	r3, [r2, #256]	; 0x100
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    4d56:	f85d 4b04 	ldr.w	r4, [sp], #4
    4d5a:	4770      	bx	lr
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    4d5c:	f042 0203 	orr.w	r2, r2, #3
    4d60:	601a      	str	r2, [r3, #0]
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    4d62:	f85d 4b04 	ldr.w	r4, [sp], #4
    4d66:	4770      	bx	lr
    4d68:	00009be0 	.word	0x00009be0

00004d6c <pinMode.part.2>:
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    4d6c:	4a1c      	ldr	r2, [pc, #112]	; (4de0 <pinMode.part.2+0x74>)
    4d6e:	eb02 03c0 	add.w	r3, r2, r0, lsl #3

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    4d72:	2901      	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    4d74:	685b      	ldr	r3, [r3, #4]

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    4d76:	d011      	beq.n	4d9c <pinMode.part.2+0x30>
    4d78:	2904      	cmp	r1, #4
    4d7a:	d01b      	beq.n	4db4 <pinMode.part.2+0x48>
		} else {
		    *config &= ~PORT_PCR_ODE;
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
    4d7c:	f852 0030 	ldr.w	r0, [r2, r0, lsl #3]
    4d80:	2200      	movs	r2, #0
    4d82:	f880 2280 	strb.w	r2, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
    4d86:	b129      	cbz	r1, 4d94 <pinMode.part.2+0x28>
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
    4d88:	2902      	cmp	r1, #2
    4d8a:	d020      	beq.n	4dce <pinMode.part.2+0x62>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else if (mode == INPUT_PULLDOWN) {
    4d8c:	2903      	cmp	r1, #3
    4d8e:	d022      	beq.n	4dd6 <pinMode.part.2+0x6a>
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    4d90:	601a      	str	r2, [r3, #0]
    4d92:	4770      	bx	lr
		*portModeRegister(pin) = 0;
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
    4d94:	f44f 7280 	mov.w	r2, #256	; 0x100
    4d98:	601a      	str	r2, [r3, #0]
    4d9a:	4770      	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    4d9c:	f852 0030 	ldr.w	r0, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    4da0:	f44f 72a2 	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    4da4:	f880 1280 	strb.w	r1, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    4da8:	601a      	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    4daa:	681a      	ldr	r2, [r3, #0]
    4dac:	f022 0220 	bic.w	r2, r2, #32
    4db0:	601a      	str	r2, [r3, #0]
    4db2:	4770      	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    4db4:	f852 1030 	ldr.w	r1, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    4db8:	f44f 72a2 	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    4dbc:	2001      	movs	r0, #1
    4dbe:	f881 0280 	strb.w	r0, [r1, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    4dc2:	601a      	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
    4dc4:	681a      	ldr	r2, [r3, #0]
    4dc6:	f042 0220 	orr.w	r2, r2, #32
    4dca:	601a      	str	r2, [r3, #0]
    4dcc:	4770      	bx	lr
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    4dce:	f240 1203 	movw	r2, #259	; 0x103
    4dd2:	601a      	str	r2, [r3, #0]
    4dd4:	4770      	bx	lr
		} else if (mode == INPUT_PULLDOWN) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    4dd6:	f44f 7281 	mov.w	r2, #258	; 0x102
    4dda:	601a      	str	r2, [r3, #0]
    4ddc:	4770      	bx	lr
    4dde:	bf00      	nop
    4de0:	00009be0 	.word	0x00009be0

00004de4 <attachInterrupt>:
void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
    4de4:	283f      	cmp	r0, #63	; 0x3f
    4de6:	d848      	bhi.n	4e7a <attachInterrupt+0x96>
{
	_VectorsRam[irq + 16] = function;
}

void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
    4de8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	switch (mode) {
    4dea:	2a04      	cmp	r2, #4
    4dec:	d844      	bhi.n	4e78 <attachInterrupt+0x94>
    4dee:	e8df f002 	tbb	[pc, r2]
    4df2:	4b48      	.short	0x4b48
    4df4:	034e      	.short	0x034e
    4df6:	45          	.byte	0x45
    4df7:	00          	.byte	0x00
    4df8:	f44f 2610 	mov.w	r6, #589824	; 0x90000
	  case LOW:	mask = 0x08; break;
	  case HIGH:	mask = 0x0C; break;
	  default: return;
	}
	mask = (mask << 16) | 0x01000000;
	config = portConfigRegister(pin);
    4dfc:	4b2b      	ldr	r3, [pc, #172]	; (4eac <attachInterrupt+0xc8>)
    4dfe:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
    4e02:	460d      	mov	r5, r1
    4e04:	685c      	ldr	r4, [r3, #4]
	if ((*config & 0x00000700) == 0) {
    4e06:	6821      	ldr	r1, [r4, #0]
    4e08:	f411 61e0 	ands.w	r1, r1, #1792	; 0x700
    4e0c:	d048      	beq.n	4ea0 <attachInterrupt+0xbc>
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    4e0e:	4b28      	ldr	r3, [pc, #160]	; (4eb0 <attachInterrupt+0xcc>)
    4e10:	4a28      	ldr	r2, [pc, #160]	; (4eb4 <attachInterrupt+0xd0>)
    4e12:	4929      	ldr	r1, [pc, #164]	; (4eb8 <attachInterrupt+0xd4>)
    4e14:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    4e18:	f104 4240 	add.w	r2, r4, #3221225472	; 0xc0000000
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    4e1c:	4827      	ldr	r0, [pc, #156]	; (4ebc <attachInterrupt+0xd8>)
    4e1e:	f8c3 1134 	str.w	r1, [r3, #308]	; 0x134

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    4e22:	f5a2 2192 	sub.w	r1, r2, #299008	; 0x49000
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    4e26:	4f26      	ldr	r7, [pc, #152]	; (4ec0 <attachInterrupt+0xdc>)
    4e28:	f8c3 0130 	str.w	r0, [r3, #304]	; 0x130

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    4e2c:	297c      	cmp	r1, #124	; 0x7c
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    4e2e:	4825      	ldr	r0, [pc, #148]	; (4ec4 <attachInterrupt+0xe0>)
    4e30:	f8c3 7138 	str.w	r7, [r3, #312]	; 0x138
    4e34:	f8c3 013c 	str.w	r0, [r3, #316]	; 0x13c

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    4e38:	d92c      	bls.n	4e94 <attachInterrupt+0xb0>
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
    4e3a:	f5a2 2394 	sub.w	r3, r2, #303104	; 0x4a000
    4e3e:	2b7c      	cmp	r3, #124	; 0x7c
    4e40:	d92a      	bls.n	4e98 <attachInterrupt+0xb4>
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
    4e42:	f5a2 2396 	sub.w	r3, r2, #307200	; 0x4b000
    4e46:	2b7c      	cmp	r3, #124	; 0x7c
    4e48:	d928      	bls.n	4e9c <attachInterrupt+0xb8>
	else if(&PORTD_PCR0 <= config && config <= &PORTD_PCR31) isr_table = isr_table_portD;
    4e4a:	f5a2 2398 	sub.w	r3, r2, #311296	; 0x4c000
    4e4e:	2b7c      	cmp	r3, #124	; 0x7c
    4e50:	d929      	bls.n	4ea6 <attachInterrupt+0xc2>
	else if(&PORTE_PCR0 <= config && config <= &PORTE_PCR31) isr_table = isr_table_portE;
    4e52:	f5a2 229a 	sub.w	r2, r2, #315392	; 0x4d000
    4e56:	2a7c      	cmp	r2, #124	; 0x7c
    4e58:	d827      	bhi.n	4eaa <attachInterrupt+0xc6>
    4e5a:	481b      	ldr	r0, [pc, #108]	; (4ec8 <attachInterrupt+0xe4>)
	attachInterruptVector(IRQ_PORTD, port_D_isr);
	attachInterruptVector(IRQ_PORTE, port_E_isr);
	voidFuncPtr* isr_table = getIsrTable(config);
	if(!isr_table) return;
	uint32_t pin_index = getPinIndex(config);
	__disable_irq();
    4e5c:	b672      	cpsid	i
	cfg = *config;
    4e5e:	6823      	ldr	r3, [r4, #0]
	cfg &= ~0x000F0000;		// disable any previous interrupt
    4e60:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    4e64:	f043 7280 	orr.w	r2, r3, #16777216	; 0x1000000
	*config = cfg;
	isr_table[pin_index] = function;	// set the function pointer
    4e68:	f3c4 0184 	ubfx	r1, r4, #2, #5
	cfg |= mask;
    4e6c:	4316      	orrs	r6, r2
	if(!isr_table) return;
	uint32_t pin_index = getPinIndex(config);
	__disable_irq();
	cfg = *config;
	cfg &= ~0x000F0000;		// disable any previous interrupt
	*config = cfg;
    4e6e:	6023      	str	r3, [r4, #0]
	isr_table[pin_index] = function;	// set the function pointer
    4e70:	f840 5021 	str.w	r5, [r0, r1, lsl #2]
	cfg |= mask;
	*config = cfg;			// enable the new interrupt
    4e74:	6026      	str	r6, [r4, #0]
	__enable_irq();
    4e76:	b662      	cpsie	i
    4e78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    4e7a:	4770      	bx	lr
{
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	switch (mode) {
    4e7c:	f44f 2630 	mov.w	r6, #720896	; 0xb0000
    4e80:	e7bc      	b.n	4dfc <attachInterrupt+0x18>
	  case CHANGE:	mask = 0x0B; break;
	  case RISING:	mask = 0x09; break;
	  case FALLING:	mask = 0x0A; break;
	  case LOW:	mask = 0x08; break;
    4e82:	f44f 2600 	mov.w	r6, #524288	; 0x80000
    4e86:	e7b9      	b.n	4dfc <attachInterrupt+0x18>
	  case HIGH:	mask = 0x0C; break;
    4e88:	f44f 2640 	mov.w	r6, #786432	; 0xc0000
    4e8c:	e7b6      	b.n	4dfc <attachInterrupt+0x18>
{
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	switch (mode) {
    4e8e:	f44f 2620 	mov.w	r6, #655360	; 0xa0000
    4e92:	e7b3      	b.n	4dfc <attachInterrupt+0x18>

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    4e94:	480d      	ldr	r0, [pc, #52]	; (4ecc <attachInterrupt+0xe8>)
    4e96:	e7e1      	b.n	4e5c <attachInterrupt+0x78>
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
    4e98:	480d      	ldr	r0, [pc, #52]	; (4ed0 <attachInterrupt+0xec>)
    4e9a:	e7df      	b.n	4e5c <attachInterrupt+0x78>
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
    4e9c:	480d      	ldr	r0, [pc, #52]	; (4ed4 <attachInterrupt+0xf0>)
    4e9e:	e7dd      	b.n	4e5c <attachInterrupt+0x78>
    4ea0:	f7ff ff64 	bl	4d6c <pinMode.part.2>
    4ea4:	e7b3      	b.n	4e0e <attachInterrupt+0x2a>
	else if(&PORTD_PCR0 <= config && config <= &PORTD_PCR31) isr_table = isr_table_portD;
    4ea6:	480c      	ldr	r0, [pc, #48]	; (4ed8 <attachInterrupt+0xf4>)
    4ea8:	e7d8      	b.n	4e5c <attachInterrupt+0x78>
    4eaa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    4eac:	00009be0 	.word	0x00009be0
    4eb0:	1fff0200 	.word	0x1fff0200
    4eb4:	1fff07e1 	.word	0x1fff07e1
    4eb8:	1fff0789 	.word	0x1fff0789
    4ebc:	1fff07b5 	.word	0x1fff07b5
    4ec0:	1fff075d 	.word	0x1fff075d
    4ec4:	1fff0731 	.word	0x1fff0731
    4ec8:	1fff0ab4 	.word	0x1fff0ab4
    4ecc:	1fff096c 	.word	0x1fff096c
    4ed0:	1fff09e4 	.word	0x1fff09e4
    4ed4:	1fff0a44 	.word	0x1fff0a44
    4ed8:	1fff0a74 	.word	0x1fff0a74

00004edc <rtc_set>:
{
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
    4edc:	b430      	push	{r4, r5}
	RTC_SR = 0;
    4ede:	4b05      	ldr	r3, [pc, #20]	; (4ef4 <rtc_set+0x18>)
	RTC_TPR = 0;
    4ee0:	4d05      	ldr	r5, [pc, #20]	; (4ef8 <rtc_set+0x1c>)
	RTC_TSR = t;
    4ee2:	4c06      	ldr	r4, [pc, #24]	; (4efc <rtc_set+0x20>)
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    4ee4:	2200      	movs	r2, #0
	RTC_TPR = 0;
	RTC_TSR = t;
	RTC_SR = RTC_SR_TCE;
    4ee6:	2110      	movs	r1, #16
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    4ee8:	601a      	str	r2, [r3, #0]
	RTC_TPR = 0;
    4eea:	602a      	str	r2, [r5, #0]
	RTC_TSR = t;
    4eec:	6020      	str	r0, [r4, #0]
	RTC_SR = RTC_SR_TCE;
    4eee:	6019      	str	r1, [r3, #0]
}
    4ef0:	bc30      	pop	{r4, r5}
    4ef2:	4770      	bx	lr
    4ef4:	4003d014 	.word	0x4003d014
    4ef8:	4003d004 	.word	0x4003d004
    4efc:	4003d000 	.word	0x4003d000

00004f00 <analogWrite>:
// FTM is clocked by the bus clock, either 24 or 48 MHz
// input capture can be FTM1_CH0, CMP0 or CMP1 or USB start of frame
// 24 MHz with reload 49152 to match Arduino's speed = 488.28125 Hz

void analogWrite(uint8_t pin, int val)
{
    4f00:	b538      	push	{r3, r4, r5, lr}
		}
		analogWriteDAC0(val);
		return;
	}
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (pin == A21 || pin == A22) {
    4f02:	f1a0 0342 	sub.w	r3, r0, #66	; 0x42
    4f06:	2b01      	cmp	r3, #1
// FTM is clocked by the bus clock, either 24 or 48 MHz
// input capture can be FTM1_CH0, CMP0 or CMP1 or USB start of frame
// 24 MHz with reload 49152 to match Arduino's speed = 488.28125 Hz

void analogWrite(uint8_t pin, int val)
{
    4f08:	4604      	mov	r4, r0
		}
		analogWriteDAC0(val);
		return;
	}
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (pin == A21 || pin == A22) {
    4f0a:	d924      	bls.n	4f56 <analogWrite+0x56>
		return;
	}
#endif

	max = 1 << analog_write_res;
	if (val <= 0) {
    4f0c:	2900      	cmp	r1, #0
    4f0e:	dd7a      	ble.n	5006 <analogWrite+0x106>
		else analogWriteDAC1(val);
		return;
	}
#endif

	max = 1 << analog_write_res;
    4f10:	4b99      	ldr	r3, [pc, #612]	; (5178 <analogWrite+0x278>)
    4f12:	781b      	ldrb	r3, [r3, #0]
	if (val <= 0) {
		digitalWrite(pin, LOW);
		pinMode(pin, OUTPUT);	// TODO: implement OUTPUT_LOW
		return;
	} else if (val >= max) {
    4f14:	2501      	movs	r5, #1
    4f16:	fa05 f203 	lsl.w	r2, r5, r3
    4f1a:	428a      	cmp	r2, r1
    4f1c:	d802      	bhi.n	4f24 <analogWrite+0x24>

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    4f1e:	283f      	cmp	r0, #63	; 0x3f
    4f20:	d92c      	bls.n	4f7c <analogWrite+0x7c>
    4f22:	bd38      	pop	{r3, r4, r5, pc}
	//serial_phex32(val);
	//serial_print("\n");
	//serial_print("analog_write_res = ");
	//serial_phex(analog_write_res);
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
    4f24:	1ec2      	subs	r2, r0, #3
    4f26:	2a01      	cmp	r2, #1
    4f28:	d930      	bls.n	4f8c <analogWrite+0x8c>
		cval = ((uint32_t)val * (uint32_t)(FTM1_MOD + 1)) >> analog_write_res;
#if defined(FTM2_CH0_PIN)
	} else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
    4f2a:	f1a0 021d 	sub.w	r2, r0, #29
    4f2e:	2a01      	cmp	r2, #1
    4f30:	d978      	bls.n	5024 <analogWrite+0x124>
		cval = ((uint32_t)val * (uint32_t)(FTM2_MOD + 1)) >> analog_write_res;
#endif
#if defined(FTM3_CH0_PIN)
	} else if (pin == FTM3_CH0_PIN || pin == FTM3_CH1_PIN || pin == FTM3_CH2_PIN
    4f32:	280e      	cmp	r0, #14
    4f34:	d95b      	bls.n	4fee <analogWrite+0xee>
	  || pin == FTM3_CH3_PIN || pin == FTM3_CH4_PIN || pin == FTM3_CH5_PIN
    4f36:	f1a4 0223 	sub.w	r2, r4, #35	; 0x23
    4f3a:	2a03      	cmp	r2, #3
    4f3c:	d95c      	bls.n	4ff8 <analogWrite+0xf8>
	  || pin == FTM3_CH6_PIN || pin == FTM3_CH7_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM3_MOD + 1)) >> analog_write_res;
#endif
#if defined(TPM1_CH0_PIN)
	} else if (pin == TPM1_CH0_PIN || pin == TPM1_CH1_PIN) {
    4f3e:	f1a4 0210 	sub.w	r2, r4, #16
    4f42:	2a01      	cmp	r2, #1
		cval = ((uint32_t)val * (uint32_t)(TPM1_MOD + 1)) >> analog_write_res;
    4f44:	bf94      	ite	ls
    4f46:	4a8d      	ldrls	r2, [pc, #564]	; (517c <analogWrite+0x27c>)
#endif
	} else {
		cval = ((uint32_t)val * (uint32_t)(FTM0_MOD + 1)) >> analog_write_res;
    4f48:	4a8d      	ldrhi	r2, [pc, #564]	; (5180 <analogWrite+0x280>)
    4f4a:	6812      	ldr	r2, [r2, #0]
    4f4c:	fb02 1201 	mla	r2, r2, r1, r1
    4f50:	fa22 f303 	lsr.w	r3, r2, r3
    4f54:	e020      	b.n	4f98 <analogWrite+0x98>
		analogWriteDAC0(val);
		return;
	}
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (pin == A21 || pin == A22) {
		uint8_t res = analog_write_res;
    4f56:	4b88      	ldr	r3, [pc, #544]	; (5178 <analogWrite+0x278>)
    4f58:	781b      	ldrb	r3, [r3, #0]
		if (res < 12) {
    4f5a:	2b0b      	cmp	r3, #11
    4f5c:	d90a      	bls.n	4f74 <analogWrite+0x74>
			val <<= 12 - res;
		} else if (res > 12) {
    4f5e:	2b0c      	cmp	r3, #12
			val >>= res - 12;
    4f60:	bf1c      	itt	ne
    4f62:	3b0c      	subne	r3, #12
    4f64:	4119      	asrne	r1, r3
		}
		if (pin == A21) analogWriteDAC0(val);
    4f66:	2c42      	cmp	r4, #66	; 0x42
    4f68:	4608      	mov	r0, r1
    4f6a:	d057      	beq.n	501c <analogWrite+0x11c>
#endif
	  default:
		digitalWrite(pin, (val > 127) ? HIGH : LOW);
		pinMode(pin, OUTPUT);
	}
}
    4f6c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			val <<= 12 - res;
		} else if (res > 12) {
			val >>= res - 12;
		}
		if (pin == A21) analogWriteDAC0(val);
		else analogWriteDAC1(val);
    4f70:	f001 bb52 	b.w	6618 <analogWriteDAC1>
	}
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (pin == A21 || pin == A22) {
		uint8_t res = analog_write_res;
		if (res < 12) {
			val <<= 12 - res;
    4f74:	f1c3 030c 	rsb	r3, r3, #12
    4f78:	4099      	lsls	r1, r3
    4f7a:	e7f4      	b.n	4f66 <analogWrite+0x66>
    4f7c:	4629      	mov	r1, r5
    4f7e:	f7ff fecf 	bl	4d20 <digitalWrite.part.1>
    4f82:	4629      	mov	r1, r5
#endif
	  default:
		digitalWrite(pin, (val > 127) ? HIGH : LOW);
		pinMode(pin, OUTPUT);
	}
}
    4f84:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    4f88:	f7ff bef0 	b.w	4d6c <pinMode.part.2>
	//serial_print("\n");
	//serial_print("analog_write_res = ");
	//serial_phex(analog_write_res);
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM1_MOD + 1)) >> analog_write_res;
    4f8c:	4a7d      	ldr	r2, [pc, #500]	; (5184 <analogWrite+0x284>)
    4f8e:	6812      	ldr	r2, [r2, #0]
    4f90:	fb02 1201 	mla	r2, r2, r1, r1
    4f94:	fa22 f303 	lsr.w	r3, r2, r3
		cval = ((uint32_t)val * (uint32_t)(FTM0_MOD + 1)) >> analog_write_res;
	}
	//serial_print("cval = ");
	//serial_phex32(cval);
	//serial_print("\n");
	switch (pin) {
    4f98:	1ea2      	subs	r2, r4, #2
    4f9a:	2a24      	cmp	r2, #36	; 0x24
    4f9c:	f200 80e3 	bhi.w	5166 <analogWrite+0x266>
    4fa0:	e8df f012 	tbh	[pc, r2, lsl #1]
    4fa4:	00d300da 	.word	0x00d300da
    4fa8:	00c500cc 	.word	0x00c500cc
    4fac:	00b700be 	.word	0x00b700be
    4fb0:	00a900b0 	.word	0x00a900b0
    4fb4:	00e100a2 	.word	0x00e100a2
    4fb8:	00e100e1 	.word	0x00e100e1
    4fbc:	00e1009b 	.word	0x00e1009b
    4fc0:	008d0094 	.word	0x008d0094
    4fc4:	00e100e1 	.word	0x00e100e1
    4fc8:	007f0086 	.word	0x007f0086
    4fcc:	00710078 	.word	0x00710078
    4fd0:	00e100e1 	.word	0x00e100e1
    4fd4:	00e100e1 	.word	0x00e100e1
    4fd8:	006a00e1 	.word	0x006a00e1
    4fdc:	00e10063 	.word	0x00e10063
    4fe0:	00e100e1 	.word	0x00e100e1
    4fe4:	005c00e1 	.word	0x005c00e1
    4fe8:	004e0055 	.word	0x004e0055
    4fec:	0047      	.short	0x0047
#if defined(FTM2_CH0_PIN)
	} else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM2_MOD + 1)) >> analog_write_res;
#endif
#if defined(FTM3_CH0_PIN)
	} else if (pin == FTM3_CH0_PIN || pin == FTM3_CH1_PIN || pin == FTM3_CH2_PIN
    4fee:	f244 1284 	movw	r2, #16772	; 0x4184
    4ff2:	40c2      	lsrs	r2, r0
    4ff4:	07d2      	lsls	r2, r2, #31
    4ff6:	d59e      	bpl.n	4f36 <analogWrite+0x36>
	  || pin == FTM3_CH3_PIN || pin == FTM3_CH4_PIN || pin == FTM3_CH5_PIN
	  || pin == FTM3_CH6_PIN || pin == FTM3_CH7_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM3_MOD + 1)) >> analog_write_res;
    4ff8:	4a63      	ldr	r2, [pc, #396]	; (5188 <analogWrite+0x288>)
    4ffa:	6812      	ldr	r2, [r2, #0]
    4ffc:	fb02 1201 	mla	r2, r2, r1, r1
    5000:	fa22 f303 	lsr.w	r3, r2, r3
    5004:	e7c8      	b.n	4f98 <analogWrite+0x98>

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    5006:	283f      	cmp	r0, #63	; 0x3f
    5008:	d88b      	bhi.n	4f22 <analogWrite+0x22>
    500a:	2100      	movs	r1, #0
    500c:	f7ff fe88 	bl	4d20 <digitalWrite.part.1>
    5010:	4620      	mov	r0, r4
    5012:	2101      	movs	r1, #1
#endif
	  default:
		digitalWrite(pin, (val > 127) ? HIGH : LOW);
		pinMode(pin, OUTPUT);
	}
}
    5014:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    5018:	f7ff bea8 	b.w	4d6c <pinMode.part.2>
    501c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		if (res < 12) {
			val <<= 12 - res;
		} else if (res > 12) {
			val >>= res - 12;
		}
		if (pin == A21) analogWriteDAC0(val);
    5020:	f001 badc 	b.w	65dc <analogWriteDAC0>
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM1_MOD + 1)) >> analog_write_res;
#if defined(FTM2_CH0_PIN)
	} else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM2_MOD + 1)) >> analog_write_res;
    5024:	4a59      	ldr	r2, [pc, #356]	; (518c <analogWrite+0x28c>)
    5026:	6812      	ldr	r2, [r2, #0]
    5028:	fb02 1201 	mla	r2, r2, r1, r1
    502c:	fa22 f303 	lsr.w	r3, r2, r3
    5030:	e7b2      	b.n	4f98 <analogWrite+0x98>
		FTM_PINCFG(FTM3_CH6_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH7_PIN
	  case FTM3_CH7_PIN:
		FTM3_C7V = cval;
    5032:	4957      	ldr	r1, [pc, #348]	; (5190 <analogWrite+0x290>)
		FTM_PINCFG(FTM3_CH7_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5034:	4a57      	ldr	r2, [pc, #348]	; (5194 <analogWrite+0x294>)
		FTM_PINCFG(FTM3_CH6_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH7_PIN
	  case FTM3_CH7_PIN:
		FTM3_C7V = cval;
    5036:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH7_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5038:	f44f 7351 	mov.w	r3, #836	; 0x344
    503c:	6013      	str	r3, [r2, #0]
		break;
    503e:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH5_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH6_PIN
	  case FTM3_CH6_PIN:
		FTM3_C6V = cval;
    5040:	4955      	ldr	r1, [pc, #340]	; (5198 <analogWrite+0x298>)
		FTM_PINCFG(FTM3_CH6_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5042:	4a56      	ldr	r2, [pc, #344]	; (519c <analogWrite+0x29c>)
		FTM_PINCFG(FTM3_CH5_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH6_PIN
	  case FTM3_CH6_PIN:
		FTM3_C6V = cval;
    5044:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH6_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5046:	f44f 7351 	mov.w	r3, #836	; 0x344
    504a:	6013      	str	r3, [r2, #0]
		break;
    504c:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH4_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH5_PIN
	  case FTM3_CH5_PIN:
		FTM3_C5V = cval;
    504e:	4954      	ldr	r1, [pc, #336]	; (51a0 <analogWrite+0x2a0>)
		FTM_PINCFG(FTM3_CH5_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5050:	4a54      	ldr	r2, [pc, #336]	; (51a4 <analogWrite+0x2a4>)
		FTM_PINCFG(FTM3_CH4_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH5_PIN
	  case FTM3_CH5_PIN:
		FTM3_C5V = cval;
    5052:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH5_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5054:	f44f 7351 	mov.w	r3, #836	; 0x344
    5058:	6013      	str	r3, [r2, #0]
		break;
    505a:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH4_PIN
	  case FTM3_CH4_PIN:
		FTM3_C4V = cval;
    505c:	4952      	ldr	r1, [pc, #328]	; (51a8 <analogWrite+0x2a8>)
		FTM_PINCFG(FTM3_CH4_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    505e:	4a53      	ldr	r2, [pc, #332]	; (51ac <analogWrite+0x2ac>)
		FTM_PINCFG(FTM3_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH4_PIN
	  case FTM3_CH4_PIN:
		FTM3_C4V = cval;
    5060:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH4_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5062:	f44f 7351 	mov.w	r3, #836	; 0x344
    5066:	6013      	str	r3, [r2, #0]
		break;
    5068:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH1_PIN
	  case FTM2_CH1_PIN: // PTB19, FTM1_CH1
		FTM2_C1V = cval;
    506a:	4951      	ldr	r1, [pc, #324]	; (51b0 <analogWrite+0x2b0>)
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    506c:	4a51      	ldr	r2, [pc, #324]	; (51b4 <analogWrite+0x2b4>)
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH1_PIN
	  case FTM2_CH1_PIN: // PTB19, FTM1_CH1
		FTM2_C1V = cval;
    506e:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5070:	f44f 7351 	mov.w	r3, #836	; 0x344
    5074:	6013      	str	r3, [r2, #0]
		break;
    5076:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH0_PIN
	  case FTM2_CH0_PIN: // PTB18, FTM2_CH0
		FTM2_C0V = cval;
    5078:	494f      	ldr	r1, [pc, #316]	; (51b8 <analogWrite+0x2b8>)
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    507a:	4a50      	ldr	r2, [pc, #320]	; (51bc <analogWrite+0x2bc>)
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH0_PIN
	  case FTM2_CH0_PIN: // PTB18, FTM2_CH0
		FTM2_C0V = cval;
    507c:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    507e:	f44f 7351 	mov.w	r3, #836	; 0x344
    5082:	6013      	str	r3, [r2, #0]
		break;
    5084:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH1_PIN
	  case FTM0_CH1_PIN: // PTC2, FTM0_CH1
		FTM0_C1V = cval;
    5086:	494e      	ldr	r1, [pc, #312]	; (51c0 <analogWrite+0x2c0>)
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5088:	4a4e      	ldr	r2, [pc, #312]	; (51c4 <analogWrite+0x2c4>)
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH1_PIN
	  case FTM0_CH1_PIN: // PTC2, FTM0_CH1
		FTM0_C1V = cval;
    508a:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    508c:	f240 4344 	movw	r3, #1092	; 0x444
    5090:	6013      	str	r3, [r2, #0]
		break;
    5092:	bd38      	pop	{r3, r4, r5, pc}
	//serial_phex32(cval);
	//serial_print("\n");
	switch (pin) {
#ifdef FTM0_CH0_PIN
	  case FTM0_CH0_PIN: // PTC1, FTM0_CH0
		FTM0_C0V = cval;
    5094:	494c      	ldr	r1, [pc, #304]	; (51c8 <analogWrite+0x2c8>)
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5096:	4a4d      	ldr	r2, [pc, #308]	; (51cc <analogWrite+0x2cc>)
	//serial_phex32(cval);
	//serial_print("\n");
	switch (pin) {
#ifdef FTM0_CH0_PIN
	  case FTM0_CH0_PIN: // PTC1, FTM0_CH0
		FTM0_C0V = cval;
    5098:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    509a:	f240 4344 	movw	r3, #1092	; 0x444
    509e:	6013      	str	r3, [r2, #0]
		break;
    50a0:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH6_PIN
	  case FTM0_CH6_PIN: // PTD6, FTM0_CH6
		FTM0_C6V = cval;
    50a2:	494b      	ldr	r1, [pc, #300]	; (51d0 <analogWrite+0x2d0>)
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    50a4:	4a4b      	ldr	r2, [pc, #300]	; (51d4 <analogWrite+0x2d4>)
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH6_PIN
	  case FTM0_CH6_PIN: // PTD6, FTM0_CH6
		FTM0_C6V = cval;
    50a6:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    50a8:	f240 4344 	movw	r3, #1092	; 0x444
    50ac:	6013      	str	r3, [r2, #0]
		break;
    50ae:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH5_PIN
	  case FTM0_CH5_PIN: // PTD5, FTM0_CH5
		FTM0_C5V = cval;
    50b0:	4949      	ldr	r1, [pc, #292]	; (51d8 <analogWrite+0x2d8>)
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    50b2:	4a4a      	ldr	r2, [pc, #296]	; (51dc <analogWrite+0x2dc>)
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH5_PIN
	  case FTM0_CH5_PIN: // PTD5, FTM0_CH5
		FTM0_C5V = cval;
    50b4:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    50b6:	f240 4344 	movw	r3, #1092	; 0x444
    50ba:	6013      	str	r3, [r2, #0]
		break;
    50bc:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(TPM1_CH0_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef TPM1_CH1_PIN
	  case TPM1_CH1_PIN:
		TPM1_C1V = cval;
    50be:	4948      	ldr	r1, [pc, #288]	; (51e0 <analogWrite+0x2e0>)
		FTM_PINCFG(TPM1_CH1_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
    50c0:	4a48      	ldr	r2, [pc, #288]	; (51e4 <analogWrite+0x2e4>)
		FTM_PINCFG(TPM1_CH0_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef TPM1_CH1_PIN
	  case TPM1_CH1_PIN:
		TPM1_C1V = cval;
    50c2:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(TPM1_CH1_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
    50c4:	f240 6344 	movw	r3, #1604	; 0x644
    50c8:	6013      	str	r3, [r2, #0]
		break;
    50ca:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH7_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef TPM1_CH0_PIN
	  case TPM1_CH0_PIN:
		TPM1_C0V = cval;
    50cc:	4946      	ldr	r1, [pc, #280]	; (51e8 <analogWrite+0x2e8>)
		FTM_PINCFG(TPM1_CH0_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
    50ce:	4a47      	ldr	r2, [pc, #284]	; (51ec <analogWrite+0x2ec>)
		FTM_PINCFG(FTM3_CH7_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef TPM1_CH0_PIN
	  case TPM1_CH0_PIN:
		TPM1_C0V = cval;
    50d0:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(TPM1_CH0_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
    50d2:	f240 6344 	movw	r3, #1604	; 0x644
    50d6:	6013      	str	r3, [r2, #0]
		break;
    50d8:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH1_PIN
	  case FTM3_CH1_PIN:
		FTM3_C1V = cval;
    50da:	4945      	ldr	r1, [pc, #276]	; (51f0 <analogWrite+0x2f0>)
		FTM_PINCFG(FTM3_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    50dc:	4a45      	ldr	r2, [pc, #276]	; (51f4 <analogWrite+0x2f4>)
		FTM_PINCFG(FTM3_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH1_PIN
	  case FTM3_CH1_PIN:
		FTM3_C1V = cval;
    50de:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    50e0:	f240 4344 	movw	r3, #1092	; 0x444
    50e4:	6013      	str	r3, [r2, #0]
		break;
    50e6:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH3_PIN
	  case FTM0_CH3_PIN: // PTC4, FTM0_CH3
		FTM0_C3V = cval;
    50e8:	4943      	ldr	r1, [pc, #268]	; (51f8 <analogWrite+0x2f8>)
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    50ea:	4a44      	ldr	r2, [pc, #272]	; (51fc <analogWrite+0x2fc>)
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH3_PIN
	  case FTM0_CH3_PIN: // PTC4, FTM0_CH3
		FTM0_C3V = cval;
    50ec:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    50ee:	f240 4344 	movw	r3, #1092	; 0x444
    50f2:	6013      	str	r3, [r2, #0]
		break;
    50f4:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH2_PIN
	  case FTM0_CH2_PIN: // PTC3, FTM0_CH2
		FTM0_C2V = cval;
    50f6:	4942      	ldr	r1, [pc, #264]	; (5200 <analogWrite+0x300>)
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    50f8:	4a42      	ldr	r2, [pc, #264]	; (5204 <analogWrite+0x304>)
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH2_PIN
	  case FTM0_CH2_PIN: // PTC3, FTM0_CH2
		FTM0_C2V = cval;
    50fa:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    50fc:	f240 4344 	movw	r3, #1092	; 0x444
    5100:	6013      	str	r3, [r2, #0]
		break;
    5102:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH3_PIN
	  case FTM3_CH3_PIN:
		FTM3_C3V = cval;
    5104:	4940      	ldr	r1, [pc, #256]	; (5208 <analogWrite+0x308>)
		FTM_PINCFG(FTM3_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5106:	4a41      	ldr	r2, [pc, #260]	; (520c <analogWrite+0x30c>)
		FTM_PINCFG(FTM3_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH3_PIN
	  case FTM3_CH3_PIN:
		FTM3_C3V = cval;
    5108:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    510a:	f240 4344 	movw	r3, #1092	; 0x444
    510e:	6013      	str	r3, [r2, #0]
		break;
    5110:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH2_PIN
	  case FTM3_CH2_PIN:
		FTM3_C2V = cval;
    5112:	493f      	ldr	r1, [pc, #252]	; (5210 <analogWrite+0x310>)
		FTM_PINCFG(FTM3_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5114:	4a3f      	ldr	r2, [pc, #252]	; (5214 <analogWrite+0x314>)
		FTM_PINCFG(FTM3_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH2_PIN
	  case FTM3_CH2_PIN:
		FTM3_C2V = cval;
    5116:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5118:	f240 4344 	movw	r3, #1092	; 0x444
    511c:	6013      	str	r3, [r2, #0]
		break;
    511e:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH4_PIN
	  case FTM0_CH4_PIN: // PTD4, FTM0_CH4
		FTM0_C4V = cval;
    5120:	493d      	ldr	r1, [pc, #244]	; (5218 <analogWrite+0x318>)
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5122:	4a3e      	ldr	r2, [pc, #248]	; (521c <analogWrite+0x31c>)
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH4_PIN
	  case FTM0_CH4_PIN: // PTD4, FTM0_CH4
		FTM0_C4V = cval;
    5124:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5126:	f240 4344 	movw	r3, #1092	; 0x444
    512a:	6013      	str	r3, [r2, #0]
		break;
    512c:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH7_PIN
	  case FTM0_CH7_PIN: // PTD7, FTM0_CH7
		FTM0_C7V = cval;
    512e:	493c      	ldr	r1, [pc, #240]	; (5220 <analogWrite+0x320>)
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5130:	4a3c      	ldr	r2, [pc, #240]	; (5224 <analogWrite+0x324>)
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH7_PIN
	  case FTM0_CH7_PIN: // PTD7, FTM0_CH7
		FTM0_C7V = cval;
    5132:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    5134:	f240 4344 	movw	r3, #1092	; 0x444
    5138:	6013      	str	r3, [r2, #0]
		break;
    513a:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH1_PIN
	  case FTM1_CH1_PIN: // PTA13, FTM1_CH1
		FTM1_C1V = cval;
    513c:	493a      	ldr	r1, [pc, #232]	; (5228 <analogWrite+0x328>)
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    513e:	4a3b      	ldr	r2, [pc, #236]	; (522c <analogWrite+0x32c>)
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH1_PIN
	  case FTM1_CH1_PIN: // PTA13, FTM1_CH1
		FTM1_C1V = cval;
    5140:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5142:	f44f 7351 	mov.w	r3, #836	; 0x344
    5146:	6013      	str	r3, [r2, #0]
		break;
    5148:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH0_PIN
	  case FTM1_CH0_PIN: // PTA12, FTM1_CH0
		FTM1_C0V = cval;
    514a:	4939      	ldr	r1, [pc, #228]	; (5230 <analogWrite+0x330>)
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    514c:	4a39      	ldr	r2, [pc, #228]	; (5234 <analogWrite+0x334>)
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH0_PIN
	  case FTM1_CH0_PIN: // PTA12, FTM1_CH0
		FTM1_C0V = cval;
    514e:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    5150:	f44f 7351 	mov.w	r3, #836	; 0x344
    5154:	6013      	str	r3, [r2, #0]
		break;
    5156:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH0_PIN
	  case FTM3_CH0_PIN:
		FTM3_C0V = cval;
    5158:	4937      	ldr	r1, [pc, #220]	; (5238 <analogWrite+0x338>)
		FTM_PINCFG(FTM3_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    515a:	4a38      	ldr	r2, [pc, #224]	; (523c <analogWrite+0x33c>)
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH0_PIN
	  case FTM3_CH0_PIN:
		FTM3_C0V = cval;
    515c:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    515e:	f240 4344 	movw	r3, #1092	; 0x444
    5162:	6013      	str	r3, [r2, #0]
		break;
    5164:	bd38      	pop	{r3, r4, r5, pc}

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    5166:	2c3f      	cmp	r4, #63	; 0x3f
    5168:	f63f aedb 	bhi.w	4f22 <analogWrite+0x22>
    516c:	297f      	cmp	r1, #127	; 0x7f
    516e:	bfd4      	ite	le
    5170:	2100      	movle	r1, #0
    5172:	2101      	movgt	r1, #1
    5174:	4620      	mov	r0, r4
    5176:	e749      	b.n	500c <analogWrite+0x10c>
    5178:	1fff0b20 	.word	0x1fff0b20
    517c:	400c9008 	.word	0x400c9008
    5180:	40038008 	.word	0x40038008
    5184:	40039008 	.word	0x40039008
    5188:	400b9008 	.word	0x400b9008
    518c:	400b8008 	.word	0x400b8008
    5190:	400b9048 	.word	0x400b9048
    5194:	4004b02c 	.word	0x4004b02c
    5198:	400b9040 	.word	0x400b9040
    519c:	4004b028 	.word	0x4004b028
    51a0:	400b9038 	.word	0x400b9038
    51a4:	4004b024 	.word	0x4004b024
    51a8:	400b9030 	.word	0x400b9030
    51ac:	4004b020 	.word	0x4004b020
    51b0:	400b8018 	.word	0x400b8018
    51b4:	4004a04c 	.word	0x4004a04c
    51b8:	400b8010 	.word	0x400b8010
    51bc:	4004a048 	.word	0x4004a048
    51c0:	40038018 	.word	0x40038018
    51c4:	4004b008 	.word	0x4004b008
    51c8:	40038010 	.word	0x40038010
    51cc:	4004b004 	.word	0x4004b004
    51d0:	40038040 	.word	0x40038040
    51d4:	4004c018 	.word	0x4004c018
    51d8:	40038038 	.word	0x40038038
    51dc:	4004c014 	.word	0x4004c014
    51e0:	400c9018 	.word	0x400c9018
    51e4:	4004a004 	.word	0x4004a004
    51e8:	400c9010 	.word	0x400c9010
    51ec:	4004a000 	.word	0x4004a000
    51f0:	400b9018 	.word	0x400b9018
    51f4:	4004c004 	.word	0x4004c004
    51f8:	40038028 	.word	0x40038028
    51fc:	4004b010 	.word	0x4004b010
    5200:	40038020 	.word	0x40038020
    5204:	4004b00c 	.word	0x4004b00c
    5208:	400b9028 	.word	0x400b9028
    520c:	4004c00c 	.word	0x4004c00c
    5210:	400b9020 	.word	0x400b9020
    5214:	4004c008 	.word	0x4004c008
    5218:	40038030 	.word	0x40038030
    521c:	4004c010 	.word	0x4004c010
    5220:	40038048 	.word	0x40038048
    5224:	4004c01c 	.word	0x4004c01c
    5228:	40039018 	.word	0x40039018
    522c:	40049034 	.word	0x40049034
    5230:	40039010 	.word	0x40039010
    5234:	40049030 	.word	0x40049030
    5238:	400b9010 	.word	0x400b9010
    523c:	4004c000 	.word	0x4004c000

00005240 <digitalWrite>:
    5240:	283f      	cmp	r0, #63	; 0x3f
    5242:	d801      	bhi.n	5248 <digitalWrite+0x8>
    5244:	f7ff bd6c 	b.w	4d20 <digitalWrite.part.1>
    5248:	4770      	bx	lr
    524a:	bf00      	nop

0000524c <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    524c:	283f      	cmp	r0, #63	; 0x3f
    524e:	d801      	bhi.n	5254 <pinMode+0x8>
    5250:	f7ff bd8c 	b.w	4d6c <pinMode.part.2>
    5254:	4770      	bx	lr
    5256:	bf00      	nop

00005258 <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    5258:	b672      	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    525a:	490d      	ldr	r1, [pc, #52]	; (5290 <micros+0x38>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    525c:	4b0d      	ldr	r3, [pc, #52]	; (5294 <micros+0x3c>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    525e:	4a0e      	ldr	r2, [pc, #56]	; (5298 <micros+0x40>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    5260:	681b      	ldr	r3, [r3, #0]
	count = systick_millis_count;
    5262:	6808      	ldr	r0, [r1, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    5264:	6812      	ldr	r2, [r2, #0]
	__enable_irq();
    5266:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    5268:	0152      	lsls	r2, r2, #5
    526a:	d502      	bpl.n	5272 <micros+0x1a>
    526c:	2b32      	cmp	r3, #50	; 0x32
    526e:	bf88      	it	hi
    5270:	3001      	addhi	r0, #1
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    5272:	f5c3 332f 	rsb	r3, r3, #179200	; 0x2bc00
    5276:	4909      	ldr	r1, [pc, #36]	; (529c <micros+0x44>)
    5278:	f203 331f 	addw	r3, r3, #799	; 0x31f
    527c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    5280:	089b      	lsrs	r3, r3, #2
    5282:	fba1 1303 	umull	r1, r3, r1, r3
    5286:	fb02 f000 	mul.w	r0, r2, r0
}
    528a:	eb00 0093 	add.w	r0, r0, r3, lsr #2
    528e:	4770      	bx	lr
    5290:	1fff2ba4 	.word	0x1fff2ba4
    5294:	e000e018 	.word	0xe000e018
    5298:	e000ed04 	.word	0xe000ed04
    529c:	16c16c17 	.word	0x16c16c17

000052a0 <delay>:

void delay(uint32_t ms)
{
    52a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    52a4:	4605      	mov	r5, r0

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    52a6:	b672      	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    52a8:	4f22      	ldr	r7, [pc, #136]	; (5334 <delay+0x94>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    52aa:	4b23      	ldr	r3, [pc, #140]	; (5338 <delay+0x98>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    52ac:	4a23      	ldr	r2, [pc, #140]	; (533c <delay+0x9c>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    52ae:	681b      	ldr	r3, [r3, #0]
	count = systick_millis_count;
    52b0:	683c      	ldr	r4, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    52b2:	6812      	ldr	r2, [r2, #0]
	__enable_irq();
    52b4:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    52b6:	0152      	lsls	r2, r2, #5
    52b8:	d502      	bpl.n	52c0 <delay+0x20>
    52ba:	2b32      	cmp	r3, #50	; 0x32
    52bc:	bf88      	it	hi
    52be:	3401      	addhi	r4, #1

void delay(uint32_t ms)
{
	uint32_t start = micros();

	if (ms > 0) {
    52c0:	b3b5      	cbz	r5, 5330 <delay+0x90>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    52c2:	f5c3 332f 	rsb	r3, r3, #179200	; 0x2bc00
    52c6:	f203 331f 	addw	r3, r3, #799	; 0x31f
    52ca:	4e1d      	ldr	r6, [pc, #116]	; (5340 <delay+0xa0>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    52cc:	f8df 9068 	ldr.w	r9, [pc, #104]	; 5338 <delay+0x98>
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    52d0:	f8df 8068 	ldr.w	r8, [pc, #104]	; 533c <delay+0x9c>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    52d4:	089b      	lsrs	r3, r3, #2
    52d6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    52da:	fba6 1303 	umull	r1, r3, r6, r3
    52de:	fb02 f404 	mul.w	r4, r2, r4
    52e2:	eb04 0493 	add.w	r4, r4, r3, lsr #2

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    52e6:	b672      	cpsid	i
	current = SYST_CVR;
    52e8:	f8d9 1000 	ldr.w	r1, [r9]
	count = systick_millis_count;
    52ec:	683a      	ldr	r2, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    52ee:	f8d8 e000 	ldr.w	lr, [r8]
	__enable_irq();
    52f2:	b662      	cpsie	i
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    52f4:	f5c1 332f 	rsb	r3, r1, #179200	; 0x2bc00
    52f8:	f203 331f 	addw	r3, r3, #799	; 0x31f
    52fc:	089b      	lsrs	r3, r3, #2
    52fe:	fba6 0303 	umull	r0, r3, r6, r3
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    5302:	f01e 6f80 	tst.w	lr, #67108864	; 0x4000000
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    5306:	ebc4 0393 	rsb	r3, r4, r3, lsr #2
    530a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    530e:	d002      	beq.n	5316 <delay+0x76>
    5310:	2932      	cmp	r1, #50	; 0x32
    5312:	bf88      	it	hi
    5314:	3201      	addhi	r2, #1
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    5316:	fb00 3302 	mla	r3, r0, r2, r3
    531a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    531e:	d304      	bcc.n	532a <delay+0x8a>
				ms--;
				if (ms == 0) return;
    5320:	3d01      	subs	r5, #1
    5322:	d005      	beq.n	5330 <delay+0x90>
				start += 1000;
    5324:	f504 747a 	add.w	r4, r4, #1000	; 0x3e8
    5328:	e7dd      	b.n	52e6 <delay+0x46>
			}
			yield();
    532a:	f001 f871 	bl	6410 <yield>
		}
    532e:	e7da      	b.n	52e6 <delay+0x46>
    5330:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    5334:	1fff2ba4 	.word	0x1fff2ba4
    5338:	e000e018 	.word	0xe000e018
    533c:	e000ed04 	.word	0xe000ed04
    5340:	16c16c17 	.word	0x16c16c17

00005344 <_init_Teensyduino_internal_>:
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
    5344:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    5346:	4b4e      	ldr	r3, [pc, #312]	; (5480 <_init_Teensyduino_internal_+0x13c>)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    5348:	484e      	ldr	r0, [pc, #312]	; (5484 <_init_Teensyduino_internal_+0x140>)
	FTM0_MOD = DEFAULT_FTM_MOD;
    534a:	f8df c15c 	ldr.w	ip, [pc, #348]	; 54a8 <_init_Teensyduino_internal_+0x164>
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
    534e:	4c4e      	ldr	r4, [pc, #312]	; (5488 <_init_Teensyduino_internal_+0x144>)
	FTM0_C2SC = 0x28;
    5350:	494e      	ldr	r1, [pc, #312]	; (548c <_init_Teensyduino_internal_+0x148>)
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    5352:	f8df e158 	ldr.w	lr, [pc, #344]	; 54ac <_init_Teensyduino_internal_+0x168>
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
    5356:	4e4e      	ldr	r6, [pc, #312]	; (5490 <_init_Teensyduino_internal_+0x14c>)
	FTM0_C4SC = 0x28;
    5358:	4d4e      	ldr	r5, [pc, #312]	; (5494 <_init_Teensyduino_internal_+0x150>)
	FTM0_C5SC = 0x28;
    535a:	4f4f      	ldr	r7, [pc, #316]	; (5498 <_init_Teensyduino_internal_+0x154>)
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    535c:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    5360:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    5362:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    5366:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    5368:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
    536c:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    536e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    5372:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    5374:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    5378:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    537a:	2200      	movs	r2, #0
    537c:	6002      	str	r2, [r0, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    537e:	2328      	movs	r3, #40	; 0x28
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
    5380:	f64e 70ff 	movw	r0, #61439	; 0xefff
    5384:	f8cc 0000 	str.w	r0, [ip]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    5388:	f8ce 3000 	str.w	r3, [lr]
	FTM0_C1SC = 0x28;
    538c:	6023      	str	r3, [r4, #0]
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    538e:	f50e 2e01 	add.w	lr, lr, #528384	; 0x81000
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
    5392:	600b      	str	r3, [r1, #0]
	FTM0_C3SC = 0x28;
    5394:	6033      	str	r3, [r6, #0]
	FTM0_C4SC = 0x28;
    5396:	602b      	str	r3, [r5, #0]
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    5398:	f506 2600 	add.w	r6, r6, #524288	; 0x80000
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
    539c:	603b      	str	r3, [r7, #0]
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
    539e:	f505 2500 	add.w	r5, r5, #524288	; 0x80000
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
    53a2:	62a3      	str	r3, [r4, #40]	; 0x28
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
    53a4:	f507 2700 	add.w	r7, r7, #524288	; 0x80000
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
    53a8:	628b      	str	r3, [r1, #40]	; 0x28
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
    53aa:	f504 2401 	add.w	r4, r4, #528384	; 0x81000
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
    53ae:	f501 2101 	add.w	r1, r1, #528384	; 0x81000
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    53b2:	f606 76e8 	addw	r6, r6, #4072	; 0xfe8
	FTM3_C1SC = 0x28;
    53b6:	f605 75e8 	addw	r5, r5, #4072	; 0xfe8
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
    53ba:	f507 677f 	add.w	r7, r7, #4080	; 0xff0
	FTM3_C4SC = 0x28;
    53be:	3110      	adds	r1, #16
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    53c0:	f10e 0e10 	add.w	lr, lr, #16
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
    53c4:	3420      	adds	r4, #32
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    53c6:	6033      	str	r3, [r6, #0]
	FTM3_C1SC = 0x28;
    53c8:	602b      	str	r3, [r5, #0]
	FTM3_C2SC = 0x28;
    53ca:	f8ce 3000 	str.w	r3, [lr]
	FTM3_C3SC = 0x28;
    53ce:	603b      	str	r3, [r7, #0]
	FTM3_C4SC = 0x28;
    53d0:	600b      	str	r3, [r1, #0]
	FTM3_C5SC = 0x28;
    53d2:	6023      	str	r3, [r4, #0]
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    53d4:	4c31      	ldr	r4, [pc, #196]	; (549c <_init_Teensyduino_internal_+0x158>)
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
    53d6:	61bb      	str	r3, [r7, #24]
	FTM3_C7SC = 0x28;
    53d8:	618b      	str	r3, [r1, #24]
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    53da:	2109      	movs	r1, #9
    53dc:	6021      	str	r1, [r4, #0]
	FTM1_CNT = 0;
    53de:	f5a7 2700 	sub.w	r7, r7, #524288	; 0x80000
	FTM1_MOD = DEFAULT_FTM_MOD;
    53e2:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
    53e6:	3f20      	subs	r7, #32
	FTM1_MOD = DEFAULT_FTM_MOD;
    53e8:	3408      	adds	r4, #8
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
    53ea:	603a      	str	r2, [r7, #0]
	FTM1_MOD = DEFAULT_FTM_MOD;
    53ec:	6020      	str	r0, [r4, #0]
	FTM1_C0SC = 0x28;
    53ee:	60bb      	str	r3, [r7, #8]
	FTM1_C1SC = 0x28;
    53f0:	60e3      	str	r3, [r4, #12]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    53f2:	f847 1c04 	str.w	r1, [r7, #-4]
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    53f6:	f504 24fd 	add.w	r4, r4, #518144	; 0x7e800
	FTM2_MOD = DEFAULT_FTM_MOD;
    53fa:	f507 27fe 	add.w	r7, r7, #520192	; 0x7f000
    53fe:	3704      	adds	r7, #4
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    5400:	f204 74fc 	addw	r4, r4, #2044	; 0x7fc
    5404:	6022      	str	r2, [r4, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
    5406:	6038      	str	r0, [r7, #0]
	FTM2_C0SC = 0x28;
    5408:	60a3      	str	r3, [r4, #8]
	FTM2_C1SC = 0x28;
    540a:	60fb      	str	r3, [r7, #12]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    540c:	f844 1c04 	str.w	r1, [r4, #-4]
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
	FTM2_MOD = DEFAULT_FTM_MOD;
	FTM2_C0SC = 0x28;
    5410:	3408      	adds	r4, #8
	FTM2_C1SC = 0x28;
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
    5412:	f604 74fc 	addw	r4, r4, #4092	; 0xffc
	FTM2_C0SC = 0x28;
	FTM2_C1SC = 0x28;
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
    5416:	f8c7 2ffc 	str.w	r2, [r7, #4092]	; 0xffc
	FTM3_MOD = DEFAULT_FTM_MOD;
    541a:	6020      	str	r0, [r4, #0]
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    541c:	f5a4 24e1 	sub.w	r4, r4, #460800	; 0x70800
    5420:	f2a4 74dc 	subw	r4, r4, #2012	; 0x7dc
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
	FTM3_C0SC = 0x28;
    5424:	6033      	str	r3, [r6, #0]
	FTM3_C1SC = 0x28;
    5426:	602b      	str	r3, [r5, #0]
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    5428:	f8c7 1ff8 	str.w	r1, [r7, #4088]	; 0xff8
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    542c:	6821      	ldr	r1, [r4, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    542e:	481c      	ldr	r0, [pc, #112]	; (54a0 <_init_Teensyduino_internal_+0x15c>)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    5430:	f441 7100 	orr.w	r1, r1, #512	; 0x200
    5434:	6021      	str	r1, [r4, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    5436:	6801      	ldr	r1, [r0, #0]
	TPM1_CNT = 0;
	TPM1_MOD = 32767;
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    5438:	4c1a      	ldr	r4, [pc, #104]	; (54a4 <_init_Teensyduino_internal_+0x160>)
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
	TPM1_CNT = 0;
    543a:	f50e 4e7f 	add.w	lr, lr, #65280	; 0xff00
    543e:	f10e 0ee8 	add.w	lr, lr, #232	; 0xe8
	TPM1_MOD = 32767;
    5442:	f507 3788 	add.w	r7, r7, #69632	; 0x11000
	TPM1_C0SC = 0x28;
    5446:	f506 3680 	add.w	r6, r6, #65536	; 0x10000
	TPM1_C1SC = 0x28;
    544a:	f505 3580 	add.w	r5, r5, #65536	; 0x10000
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    544e:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
    5452:	6001      	str	r1, [r0, #0]
	TPM1_CNT = 0;
    5454:	f8ce 2000 	str.w	r2, [lr]
	TPM1_MOD = 32767;
    5458:	f647 71ff 	movw	r1, #32767	; 0x7fff
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    545c:	2208      	movs	r2, #8
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
	TPM1_CNT = 0;
	TPM1_MOD = 32767;
    545e:	6039      	str	r1, [r7, #0]
	TPM1_C0SC = 0x28;
    5460:	6033      	str	r3, [r6, #0]
	TPM1_C1SC = 0x28;
    5462:	602b      	str	r3, [r5, #0]
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    5464:	6022      	str	r2, [r4, #0]
#endif
	analog_init();
    5466:	f001 f849 	bl	64fc <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
    546a:	2019      	movs	r0, #25
    546c:	f7ff ff18 	bl	52a0 <delay>
	usb_init();
    5470:	f000 fd10 	bl	5e94 <usb_init>
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    5474:	f240 1013 	movw	r0, #275	; 0x113
}
    5478:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
	usb_init();
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    547c:	f7ff bf10 	b.w	52a0 <delay>
    5480:	e000e104 	.word	0xe000e104
    5484:	40038004 	.word	0x40038004
    5488:	40038014 	.word	0x40038014
    548c:	4003801c 	.word	0x4003801c
    5490:	40038024 	.word	0x40038024
    5494:	4003802c 	.word	0x4003802c
    5498:	40038034 	.word	0x40038034
    549c:	40038000 	.word	0x40038000
    54a0:	40048004 	.word	0x40048004
    54a4:	400c9000 	.word	0x400c9000
    54a8:	40038008 	.word	0x40038008
    54ac:	4003800c 	.word	0x4003800c

000054b0 <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    54b0:	1e43      	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    54b2:	2b03      	cmp	r3, #3
    54b4:	d814      	bhi.n	54e0 <usb_rx+0x30>
	__disable_irq();
    54b6:	b672      	cpsid	i
	ret = rx_first[endpoint];
    54b8:	490a      	ldr	r1, [pc, #40]	; (54e4 <usb_rx+0x34>)
    54ba:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
	if (ret) {
    54be:	b168      	cbz	r0, 54dc <usb_rx+0x2c>




usb_packet_t *usb_rx(uint32_t endpoint)
{
    54c0:	b470      	push	{r4, r5, r6}
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
    54c2:	4c09      	ldr	r4, [pc, #36]	; (54e8 <usb_rx+0x38>)
    54c4:	8805      	ldrh	r5, [r0, #0]
    54c6:	f834 2013 	ldrh.w	r2, [r4, r3, lsl #1]
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
    54ca:	6846      	ldr	r6, [r0, #4]
    54cc:	f841 6023 	str.w	r6, [r1, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    54d0:	1b52      	subs	r2, r2, r5
    54d2:	f824 2013 	strh.w	r2, [r4, r3, lsl #1]
	}
	__enable_irq();
    54d6:	b662      	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    54d8:	bc70      	pop	{r4, r5, r6}
    54da:	4770      	bx	lr
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
	}
	__enable_irq();
    54dc:	b662      	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    54de:	4770      	bx	lr

usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    54e0:	2000      	movs	r0, #0
    54e2:	4770      	bx	lr
    54e4:	1fff2c00 	.word	0x1fff2c00
    54e8:	1fff2d08 	.word	0x1fff2d08

000054ec <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    54ec:	3801      	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    54ee:	2803      	cmp	r0, #3
    54f0:	d80b      	bhi.n	550a <usb_tx_packet_count+0x1e>
	__disable_irq();
    54f2:	b672      	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    54f4:	4b07      	ldr	r3, [pc, #28]	; (5514 <usb_tx_packet_count+0x28>)
    54f6:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    54fa:	b143      	cbz	r3, 550e <usb_tx_packet_count+0x22>
    54fc:	2000      	movs	r0, #0
    54fe:	685b      	ldr	r3, [r3, #4]
    5500:	3001      	adds	r0, #1
    5502:	2b00      	cmp	r3, #0
    5504:	d1fb      	bne.n	54fe <usb_tx_packet_count+0x12>
	__enable_irq();
    5506:	b662      	cpsie	i
	return count;
    5508:	4770      	bx	lr
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
    550a:	2000      	movs	r0, #0
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
	__enable_irq();
	return count;
}
    550c:	4770      	bx	lr
// https://forum.pjrc.com/threads/58663?p=223513&viewfull=1#post223513
//
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;
    550e:	4618      	mov	r0, r3
    5510:	e7f9      	b.n	5506 <usb_tx_packet_count+0x1a>
    5512:	bf00      	nop
    5514:	1fff2c54 	.word	0x1fff2c54

00005518 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    5518:	b4f0      	push	{r4, r5, r6, r7}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    551a:	b672      	cpsid	i
void usb_rx_memory(usb_packet_t *packet)
{
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
    551c:	491a      	ldr	r1, [pc, #104]	; (5588 <usb_rx_memory+0x70>)
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
    551e:	4e1b      	ldr	r6, [pc, #108]	; (558c <usb_rx_memory+0x74>)
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    5520:	2301      	movs	r3, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    5522:	f811 4b01 	ldrb.w	r4, [r1], #1
			if (table[index(i, RX, EVEN)].desc == 0) {
    5526:	4f19      	ldr	r7, [pc, #100]	; (558c <usb_rx_memory+0x74>)
    5528:	009a      	lsls	r2, r3, #2
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    552a:	0724      	lsls	r4, r4, #28
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    552c:	f042 0501 	orr.w	r5, r2, #1
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    5530:	d505      	bpl.n	553e <usb_rx_memory+0x26>
			if (table[index(i, RX, EVEN)].desc == 0) {
    5532:	f856 4032 	ldr.w	r4, [r6, r2, lsl #3]
    5536:	b164      	cbz	r4, 5552 <usb_rx_memory+0x3a>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    5538:	f856 2035 	ldr.w	r2, [r6, r5, lsl #3]
    553c:	b1ba      	cbz	r2, 556e <usb_rx_memory+0x56>
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    553e:	3301      	adds	r3, #1
    5540:	2b05      	cmp	r3, #5
    5542:	d1ee      	bne.n	5522 <usb_rx_memory+0xa>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    5544:	b662      	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    5546:	4b12      	ldr	r3, [pc, #72]	; (5590 <usb_rx_memory+0x78>)
    5548:	2200      	movs	r2, #0
    554a:	701a      	strb	r2, [r3, #0]
	usb_free(packet);
	return;
}
    554c:	bcf0      	pop	{r4, r5, r6, r7}
	__enable_irq();
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
    554e:	f000 bd23 	b.w	5f98 <usb_free>
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    5552:	4c0f      	ldr	r4, [pc, #60]	; (5590 <usb_rx_memory+0x78>)
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    5554:	4d0f      	ldr	r5, [pc, #60]	; (5594 <usb_rx_memory+0x7c>)
				usb_rx_memory_needed--;
    5556:	7821      	ldrb	r1, [r4, #0]
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    5558:	eb07 1343 	add.w	r3, r7, r3, lsl #5
    555c:	3008      	adds	r0, #8
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    555e:	3901      	subs	r1, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    5560:	6058      	str	r0, [r3, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    5562:	7021      	strb	r1, [r4, #0]
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    5564:	f847 5032 	str.w	r5, [r7, r2, lsl #3]
				usb_rx_memory_needed--;
				__enable_irq();
    5568:	b662      	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
	return;
}
    556a:	bcf0      	pop	{r4, r5, r6, r7}
    556c:	4770      	bx	lr
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    556e:	4a08      	ldr	r2, [pc, #32]	; (5590 <usb_rx_memory+0x78>)
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    5570:	4909      	ldr	r1, [pc, #36]	; (5598 <usb_rx_memory+0x80>)
				usb_rx_memory_needed--;
    5572:	7813      	ldrb	r3, [r2, #0]
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    5574:	eb07 04c5 	add.w	r4, r7, r5, lsl #3
    5578:	3008      	adds	r0, #8
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    557a:	3b01      	subs	r3, #1
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    557c:	6060      	str	r0, [r4, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    557e:	7013      	strb	r3, [r2, #0]
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    5580:	f847 1035 	str.w	r1, [r7, r5, lsl #3]
				usb_rx_memory_needed--;
				__enable_irq();
    5584:	b662      	cpsie	i
				//serial_phex(i);
				//serial_print(",odd\n");
				return;
    5586:	e7f0      	b.n	556a <usb_rx_memory+0x52>
    5588:	00009e08 	.word	0x00009e08
    558c:	1fff0000 	.word	0x1fff0000
    5590:	1fff2c7d 	.word	0x1fff2c7d
    5594:	00400088 	.word	0x00400088
    5598:	004000c8 	.word	0x004000c8

0000559c <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    559c:	1e43      	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    559e:	2b03      	cmp	r3, #3
    55a0:	d81d      	bhi.n	55de <usb_tx+0x42>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    55a2:	4a1b      	ldr	r2, [pc, #108]	; (5610 <usb_tx+0x74>)
    55a4:	0140      	lsls	r0, r0, #5
    55a6:	f040 0010 	orr.w	r0, r0, #16

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
    55aa:	b430      	push	{r4, r5}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    55ac:	4410      	add	r0, r2
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
	__disable_irq();
    55ae:	b672      	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    55b0:	4c18      	ldr	r4, [pc, #96]	; (5614 <usb_tx+0x78>)
    55b2:	5ce2      	ldrb	r2, [r4, r3]
    55b4:	2a03      	cmp	r2, #3
    55b6:	d81b      	bhi.n	55f0 <usb_tx+0x54>
    55b8:	e8df f002 	tbb	[pc, r2]
    55bc:	17151202 	.word	0x17151202
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    55c0:	2203      	movs	r2, #3
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    55c2:	880d      	ldrh	r5, [r1, #0]
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    55c4:	54e2      	strb	r2, [r4, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    55c6:	f010 0f08 	tst.w	r0, #8
    55ca:	bf14      	ite	ne
    55cc:	23c8      	movne	r3, #200	; 0xc8
    55ce:	2388      	moveq	r3, #136	; 0x88
    55d0:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    55d4:	3108      	adds	r1, #8
    55d6:	6041      	str	r1, [r0, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    55d8:	6003      	str	r3, [r0, #0]
	__enable_irq();
    55da:	b662      	cpsie	i
}
    55dc:	bc30      	pop	{r4, r5}
    55de:	4770      	bx	lr
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    55e0:	3008      	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    55e2:	2202      	movs	r2, #2
		break;
    55e4:	e7ed      	b.n	55c2 <usb_tx+0x26>
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    55e6:	2205      	movs	r2, #5
    55e8:	e7eb      	b.n	55c2 <usb_tx+0x26>
		break;
	  case TX_STATE_ODD_FREE:
		b++;
    55ea:	3008      	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    55ec:	2204      	movs	r2, #4
		break;
    55ee:	e7e8      	b.n	55c2 <usb_tx+0x26>
	  default:
		if (tx_first[endpoint] == NULL) {
    55f0:	4a09      	ldr	r2, [pc, #36]	; (5618 <usb_tx+0x7c>)
    55f2:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    55f6:	b138      	cbz	r0, 5608 <usb_tx+0x6c>
			tx_first[endpoint] = packet;
		} else {
			tx_last[endpoint]->next = packet;
    55f8:	4a08      	ldr	r2, [pc, #32]	; (561c <usb_tx+0x80>)
    55fa:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    55fe:	6041      	str	r1, [r0, #4]
		}
		tx_last[endpoint] = packet;
    5600:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		__enable_irq();
    5604:	b662      	cpsie	i
		return;
    5606:	e7e9      	b.n	55dc <usb_tx+0x40>
		b++;
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
		break;
	  default:
		if (tx_first[endpoint] == NULL) {
			tx_first[endpoint] = packet;
    5608:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    560c:	4a03      	ldr	r2, [pc, #12]	; (561c <usb_tx+0x80>)
    560e:	e7f7      	b.n	5600 <usb_tx+0x64>
    5610:	1fff0000 	.word	0x1fff0000
    5614:	1fff2c8c 	.word	0x1fff2c8c
    5618:	1fff2c54 	.word	0x1fff2c54
    561c:	1fff2c64 	.word	0x1fff2c64

00005620 <usb_isr>:
}



void usb_isr(void)
{
    5620:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    5624:	f8df b314 	ldr.w	fp, [pc, #788]	; 593c <usb_isr+0x31c>
		USB0_ISTAT = USB_ISTAT_SOFTOK;
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
		uint8_t endpoint;
		stat = USB0_STAT;
    5628:	f8df a314 	ldr.w	sl, [pc, #788]	; 5940 <usb_isr+0x320>
}



void usb_isr(void)
{
    562c:	b087      	sub	sp, #28
    562e:	e044      	b.n	56ba <usb_isr+0x9a>
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    5630:	4fad      	ldr	r7, [pc, #692]	; (58e8 <usb_isr+0x2c8>)
    5632:	ea4f 0893 	mov.w	r8, r3, lsr #2
    5636:	eb07 09c8 	add.w	r9, r7, r8, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    563a:	3e01      	subs	r6, #1
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    563c:	f8d9 2004 	ldr.w	r2, [r9, #4]
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    5640:	f003 0308 	and.w	r3, r3, #8
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    5644:	b2f6      	uxtb	r6, r6
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    5646:	f1a2 0008 	sub.w	r0, r2, #8
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    564a:	f003 04ff 	and.w	r4, r3, #255	; 0xff
    564e:	2b00      	cmp	r3, #0
    5650:	f040 8103 	bne.w	585a <usb_isr+0x23a>
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
    5654:	f857 3038 	ldr.w	r3, [r7, r8, lsl #3]
    5658:	0c1b      	lsrs	r3, r3, #16
    565a:	b299      	uxth	r1, r3
    565c:	f822 1c08 	strh.w	r1, [r2, #-8]
				if (packet->len > 0) {
    5660:	2b00      	cmp	r3, #0
    5662:	f000 80f1 	beq.w	5848 <usb_isr+0x228>
					packet->index = 0;
					packet->next = NULL;
					if (rx_first[endpoint] == NULL) {
    5666:	4ba1      	ldr	r3, [pc, #644]	; (58ec <usb_isr+0x2cc>)
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
				if (packet->len > 0) {
					packet->index = 0;
    5668:	f822 4c06 	strh.w	r4, [r2, #-6]
					packet->next = NULL;
    566c:	f842 4c04 	str.w	r4, [r2, #-4]
					if (rx_first[endpoint] == NULL) {
    5670:	f853 2026 	ldr.w	r2, [r3, r6, lsl #2]
    5674:	2a00      	cmp	r2, #0
    5676:	f000 816c 	beq.w	5952 <usb_isr+0x332>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
    567a:	4d9d      	ldr	r5, [pc, #628]	; (58f0 <usb_isr+0x2d0>)
    567c:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
    5680:	6058      	str	r0, [r3, #4]
					}
					rx_last[endpoint] = packet;
					usb_rx_byte_count_data[endpoint] += packet->len;
    5682:	4c9c      	ldr	r4, [pc, #624]	; (58f4 <usb_isr+0x2d4>)
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
					}
					rx_last[endpoint] = packet;
    5684:	f845 0026 	str.w	r0, [r5, r6, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    5688:	f834 3016 	ldrh.w	r3, [r4, r6, lsl #1]
    568c:	4419      	add	r1, r3
    568e:	f824 1016 	strh.w	r1, [r4, r6, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
    5692:	f000 fc61 	bl	5f58 <usb_malloc>
					if (packet) {
    5696:	2800      	cmp	r0, #0
    5698:	f000 8154 	beq.w	5944 <usb_isr+0x324>
						b->addr = packet->buf;
						b->desc = BDT_DESC(64,
    569c:	4a96      	ldr	r2, [pc, #600]	; (58f8 <usb_isr+0x2d8>)
    569e:	4b97      	ldr	r3, [pc, #604]	; (58fc <usb_isr+0x2dc>)
    56a0:	f019 0f08 	tst.w	r9, #8
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    56a4:	f100 0008 	add.w	r0, r0, #8
						b->desc = BDT_DESC(64,
    56a8:	bf18      	it	ne
    56aa:	4613      	movne	r3, r2
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    56ac:	f8c9 0004 	str.w	r0, [r9, #4]
						b->desc = BDT_DESC(64,
    56b0:	f847 3038 	str.w	r3, [r7, r8, lsl #3]
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    56b4:	2308      	movs	r3, #8
    56b6:	f88b 3000 	strb.w	r3, [fp]
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    56ba:	f89b 4000 	ldrb.w	r4, [fp]
    56be:	b2e4      	uxtb	r4, r4

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    56c0:	0760      	lsls	r0, r4, #29
    56c2:	d51b      	bpl.n	56fc <usb_isr+0xdc>
		if (usb_configuration) {
    56c4:	4b8e      	ldr	r3, [pc, #568]	; (5900 <usb_isr+0x2e0>)
    56c6:	781b      	ldrb	r3, [r3, #0]
    56c8:	b1ab      	cbz	r3, 56f6 <usb_isr+0xd6>
			t = usb_reboot_timer;
    56ca:	498e      	ldr	r1, [pc, #568]	; (5904 <usb_isr+0x2e4>)
    56cc:	780a      	ldrb	r2, [r1, #0]
			if (t) {
    56ce:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    56d2:	b12a      	cbz	r2, 56e0 <usb_isr+0xc0>
				usb_reboot_timer = --t;
    56d4:	3b01      	subs	r3, #1
    56d6:	b2db      	uxtb	r3, r3
    56d8:	700b      	strb	r3, [r1, #0]
				if (!t) _reboot_Teensyduino_();
    56da:	2b00      	cmp	r3, #0
    56dc:	f000 83b5 	beq.w	5e4a <usb_isr+0x82a>
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
    56e0:	4989      	ldr	r1, [pc, #548]	; (5908 <usb_isr+0x2e8>)
    56e2:	780a      	ldrb	r2, [r1, #0]
			if (t) {
    56e4:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    56e8:	b12a      	cbz	r2, 56f6 <usb_isr+0xd6>
				usb_cdc_transmit_flush_timer = --t;
    56ea:	3b01      	subs	r3, #1
    56ec:	b2db      	uxtb	r3, r3
    56ee:	700b      	strb	r3, [r1, #0]
				if (t == 0) usb_serial_flush_callback();
    56f0:	2b00      	cmp	r3, #0
    56f2:	f000 80f6 	beq.w	58e2 <usb_isr+0x2c2>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    56f6:	2304      	movs	r3, #4
    56f8:	f88b 3000 	strb.w	r3, [fp]
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    56fc:	f004 0308 	and.w	r3, r4, #8
    5700:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    5704:	2b00      	cmp	r3, #0
    5706:	f000 80d5 	beq.w	58b4 <usb_isr+0x294>
		uint8_t endpoint;
		stat = USB0_STAT;
    570a:	f89a 3000 	ldrb.w	r3, [sl]
    570e:	b2db      	uxtb	r3, r3
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
    5710:	091e      	lsrs	r6, r3, #4
    5712:	d18d      	bne.n	5630 <usb_isr+0x10>
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    5714:	089c      	lsrs	r4, r3, #2
    5716:	4f74      	ldr	r7, [pc, #464]	; (58e8 <usb_isr+0x2c8>)
	pid = BDT_PID(b->desc);
    5718:	f857 2034 	ldr.w	r2, [r7, r4, lsl #3]
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    571c:	eb07 01c4 	add.w	r1, r7, r4, lsl #3
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    5720:	f3c2 0283 	ubfx	r2, r2, #2, #4
    5724:	3a01      	subs	r2, #1
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
	//count = b->desc >> 16;
	buf = b->addr;
    5726:	6849      	ldr	r1, [r1, #4]
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    5728:	2a0c      	cmp	r2, #12
    572a:	d87e      	bhi.n	582a <usb_isr+0x20a>
    572c:	e8df f002 	tbb	[pc, r2]
    5730:	7d7d8181 	.word	0x7d7d8181
    5734:	7d7d7d7d 	.word	0x7d7d7d7d
    5738:	7d7d7d42 	.word	0x7d7d7d42
    573c:	07          	.byte	0x07
    573d:	00          	.byte	0x00
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    573e:	6808      	ldr	r0, [r1, #0]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    5740:	4b72      	ldr	r3, [pc, #456]	; (590c <usb_isr+0x2ec>)
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    5742:	4d73      	ldr	r5, [pc, #460]	; (5910 <usb_isr+0x2f0>)
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    5744:	9301      	str	r3, [sp, #4]
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    5746:	4b6c      	ldr	r3, [pc, #432]	; (58f8 <usb_isr+0x2d8>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    5748:	684a      	ldr	r2, [r1, #4]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    574a:	4e72      	ldr	r6, [pc, #456]	; (5914 <usb_isr+0x2f4>)
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    574c:	f847 3034 	str.w	r3, [r7, r4, lsl #3]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    5750:	b281      	uxth	r1, r0
    5752:	f240 6481 	movw	r4, #1665	; 0x681
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    5756:	4b6d      	ldr	r3, [pc, #436]	; (590c <usb_isr+0x2ec>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    5758:	606a      	str	r2, [r5, #4]
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    575a:	6028      	str	r0, [r5, #0]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    575c:	2200      	movs	r2, #0
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    575e:	2001      	movs	r0, #1
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    5760:	42a1      	cmp	r1, r4
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    5762:	613a      	str	r2, [r7, #16]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    5764:	601a      	str	r2, [r3, #0]
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
    5766:	61ba      	str	r2, [r7, #24]
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    5768:	7030      	strb	r0, [r6, #0]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    576a:	f200 80f6 	bhi.w	595a <usb_isr+0x33a>
    576e:	f5b1 6fd0 	cmp.w	r1, #1664	; 0x680
    5772:	f080 82e8 	bcs.w	5d46 <usb_isr+0x726>
    5776:	f5b1 7f81 	cmp.w	r1, #258	; 0x102
    577a:	f000 82d3 	beq.w	5d24 <usb_isr+0x704>
    577e:	f200 81d8 	bhi.w	5b32 <usb_isr+0x512>
    5782:	2980      	cmp	r1, #128	; 0x80
    5784:	f000 814d 	beq.w	5a22 <usb_isr+0x402>
    5788:	2982      	cmp	r1, #130	; 0x82
    578a:	f040 8292 	bne.w	5cb2 <usb_isr+0x692>
    578e:	88a9      	ldrh	r1, [r5, #4]
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    5790:	4b61      	ldr	r3, [pc, #388]	; (5918 <usb_isr+0x2f8>)
    5792:	f001 017f 	and.w	r1, r1, #127	; 0x7f
		datalen = 2;
		data = reply_buffer;
		break;
	  case 0x0082: // GET_STATUS (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS) {
    5796:	2904      	cmp	r1, #4
    5798:	f200 828c 	bhi.w	5cb4 <usb_isr+0x694>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    579c:	4c5f      	ldr	r4, [pc, #380]	; (591c <usb_isr+0x2fc>)
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    579e:	0089      	lsls	r1, r1, #2
    57a0:	440b      	add	r3, r1
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    57a2:	7022      	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    57a4:	7062      	strb	r2, [r4, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    57a6:	781a      	ldrb	r2, [r3, #0]
    57a8:	0793      	lsls	r3, r2, #30
    57aa:	f140 8338 	bpl.w	5e1e <usb_isr+0x7fe>
    57ae:	7020      	strb	r0, [r4, #0]
		data = reply_buffer;
		datalen = 2;
    57b0:	2002      	movs	r0, #2
    57b2:	e13a      	b.n	5a2a <usb_isr+0x40a>
		//serial_print("PID=IN:");
		//serial_phex(stat);
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
    57b4:	4b55      	ldr	r3, [pc, #340]	; (590c <usb_isr+0x2ec>)
    57b6:	9301      	str	r3, [sp, #4]
    57b8:	681a      	ldr	r2, [r3, #0]
		if (data) {
    57ba:	b362      	cbz	r2, 5816 <usb_isr+0x1f6>
			size = ep0_tx_len;
    57bc:	4b58      	ldr	r3, [pc, #352]	; (5920 <usb_isr+0x300>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    57be:	4959      	ldr	r1, [pc, #356]	; (5924 <usb_isr+0x304>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    57c0:	4e54      	ldr	r6, [pc, #336]	; (5914 <usb_isr+0x2f4>)
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
    57c2:	8818      	ldrh	r0, [r3, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    57c4:	780c      	ldrb	r4, [r1, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    57c6:	f896 e000 	ldrb.w	lr, [r6]
    57ca:	2840      	cmp	r0, #64	; 0x40
    57cc:	4605      	mov	r5, r0
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    57ce:	f084 0c01 	eor.w	ip, r4, #1
    57d2:	bf28      	it	cs
    57d4:	2540      	movcs	r5, #64	; 0x40
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    57d6:	f044 0402 	orr.w	r4, r4, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    57da:	f1be 0f00 	cmp.w	lr, #0
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    57de:	f881 c000 	strb.w	ip, [r1]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    57e2:	eba0 0005 	sub.w	r0, r0, r5
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    57e6:	eb07 0cc4 	add.w	ip, r7, r4, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    57ea:	bf0c      	ite	eq
    57ec:	2188      	moveq	r1, #136	; 0x88
    57ee:	21c8      	movne	r1, #200	; 0xc8
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    57f0:	b280      	uxth	r0, r0
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    57f2:	f08e 0e01 	eor.w	lr, lr, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    57f6:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    57fa:	f8cc 2004 	str.w	r2, [ip, #4]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    57fe:	8018      	strh	r0, [r3, #0]
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    5800:	f886 e000 	strb.w	lr, [r6]
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    5804:	442a      	add	r2, r5
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5806:	f847 1034 	str.w	r1, [r7, r4, lsl #3]
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    580a:	b910      	cbnz	r0, 5812 <usb_isr+0x1f2>
    580c:	2d40      	cmp	r5, #64	; 0x40
    580e:	bf18      	it	ne
    5810:	2200      	movne	r2, #0
    5812:	9b01      	ldr	r3, [sp, #4]
    5814:	601a      	str	r2, [r3, #0]
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    5816:	4b3e      	ldr	r3, [pc, #248]	; (5910 <usb_isr+0x2f0>)
    5818:	881a      	ldrh	r2, [r3, #0]
    581a:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
    581e:	d104      	bne.n	582a <usb_isr+0x20a>
			setup.bRequest = 0;
    5820:	2100      	movs	r1, #0
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    5822:	789a      	ldrb	r2, [r3, #2]
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
			setup.bRequest = 0;
    5824:	7059      	strb	r1, [r3, #1]
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    5826:	4b40      	ldr	r3, [pc, #256]	; (5928 <usb_isr+0x308>)
    5828:	701a      	strb	r2, [r3, #0]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    582a:	4a40      	ldr	r2, [pc, #256]	; (592c <usb_isr+0x30c>)
    582c:	2301      	movs	r3, #1
    582e:	7013      	strb	r3, [r2, #0]
    5830:	e740      	b.n	56b4 <usb_isr+0x94>
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
		break;
	case 0x01:  // OUT transaction received from host
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    5832:	4a37      	ldr	r2, [pc, #220]	; (5910 <usb_isr+0x2f0>)
    5834:	8815      	ldrh	r5, [r2, #0]
    5836:	f242 0021 	movw	r0, #8225	; 0x2021
    583a:	4285      	cmp	r5, r0
    583c:	f000 8152 	beq.w	5ae4 <usb_isr+0x4c4>
		if (usb_audio_set_feature(&setup, buf)) {
			endpoint0_transmit(NULL, 0);
		}
#endif
		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    5840:	4a2d      	ldr	r2, [pc, #180]	; (58f8 <usb_isr+0x2d8>)
    5842:	f847 2034 	str.w	r2, [r7, r4, lsl #3]
    5846:	e7f0      	b.n	582a <usb_isr+0x20a>
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
					}
				} else {
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    5848:	4a2b      	ldr	r2, [pc, #172]	; (58f8 <usb_isr+0x2d8>)
    584a:	4b2c      	ldr	r3, [pc, #176]	; (58fc <usb_isr+0x2dc>)
    584c:	f019 0f08 	tst.w	r9, #8
    5850:	bf18      	it	ne
    5852:	4613      	movne	r3, r2
    5854:	f847 3038 	str.w	r3, [r7, r8, lsl #3]
    5858:	e72c      	b.n	56b4 <usb_isr+0x94>
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
    585a:	f000 fb9d 	bl	5f98 <usb_free>
				packet = tx_first[endpoint];
    585e:	4a34      	ldr	r2, [pc, #208]	; (5930 <usb_isr+0x310>)
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    5860:	4934      	ldr	r1, [pc, #208]	; (5934 <usb_isr+0x314>)
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
    5862:	f852 3026 	ldr.w	r3, [r2, r6, lsl #2]
				if (packet) {
    5866:	2b00      	cmp	r3, #0
    5868:	f000 812d 	beq.w	5ac6 <usb_isr+0x4a6>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    586c:	6858      	ldr	r0, [r3, #4]
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    586e:	5d8c      	ldrb	r4, [r1, r6]
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    5870:	f842 0026 	str.w	r0, [r2, r6, lsl #2]
					b->addr = packet->buf;
    5874:	f103 0208 	add.w	r2, r3, #8
    5878:	f8c9 2004 	str.w	r2, [r9, #4]
					switch (tx_state[endpoint]) {
    587c:	2c03      	cmp	r4, #3
    587e:	d805      	bhi.n	588c <usb_isr+0x26c>
    5880:	e8df f004 	tbb	[pc, r4]
    5884:	02150f12 	.word	0x02150f12
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    5888:	2204      	movs	r2, #4
    588a:	558a      	strb	r2, [r1, r6]
						break;
					  default:
						break;
					}
					b->desc = BDT_DESC(packet->len,
    588c:	881a      	ldrh	r2, [r3, #0]
    588e:	f019 0f08 	tst.w	r9, #8
    5892:	bf0c      	ite	eq
    5894:	2388      	moveq	r3, #136	; 0x88
    5896:	23c8      	movne	r3, #200	; 0xc8
    5898:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    589c:	f847 3038 	str.w	r3, [r7, r8, lsl #3]
    58a0:	e708      	b.n	56b4 <usb_isr+0x94>
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    58a2:	2202      	movs	r2, #2
    58a4:	558a      	strb	r2, [r1, r6]
						break;
    58a6:	e7f1      	b.n	588c <usb_isr+0x26c>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    58a8:	2203      	movs	r2, #3
    58aa:	558a      	strb	r2, [r1, r6]
						break;
    58ac:	e7ee      	b.n	588c <usb_isr+0x26c>
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    58ae:	2205      	movs	r2, #5
    58b0:	558a      	strb	r2, [r1, r6]
						break;
    58b2:	e7eb      	b.n	588c <usb_isr+0x26c>
		goto restart;
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    58b4:	07e0      	lsls	r0, r4, #31
    58b6:	f100 8178 	bmi.w	5baa <usb_isr+0x58a>
		USB0_CTL = USB_CTL_USBENSOFEN;
		return;
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    58ba:	0621      	lsls	r1, r4, #24
    58bc:	f100 81a2 	bmi.w	5c04 <usb_isr+0x5e4>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    58c0:	07a2      	lsls	r2, r4, #30
    58c2:	d506      	bpl.n	58d2 <usb_isr+0x2b2>
		uint8_t err = USB0_ERRSTAT;
    58c4:	4a1c      	ldr	r2, [pc, #112]	; (5938 <usb_isr+0x318>)
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    58c6:	491d      	ldr	r1, [pc, #116]	; (593c <usb_isr+0x31c>)
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    58c8:	7813      	ldrb	r3, [r2, #0]
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    58ca:	2002      	movs	r0, #2
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    58cc:	b2db      	uxtb	r3, r3
		USB0_ERRSTAT = err;
    58ce:	7013      	strb	r3, [r2, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    58d0:	7008      	strb	r0, [r1, #0]
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    58d2:	06e3      	lsls	r3, r4, #27
    58d4:	d502      	bpl.n	58dc <usb_isr+0x2bc>
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    58d6:	4b19      	ldr	r3, [pc, #100]	; (593c <usb_isr+0x31c>)
    58d8:	2210      	movs	r2, #16
    58da:	701a      	strb	r2, [r3, #0]
	}

}
    58dc:	b007      	add	sp, #28
    58de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
			if (t) {
				usb_cdc_transmit_flush_timer = --t;
				if (t == 0) usb_serial_flush_callback();
    58e2:	f000 fcc5 	bl	6270 <usb_serial_flush_callback>
    58e6:	e706      	b.n	56f6 <usb_isr+0xd6>
    58e8:	1fff0000 	.word	0x1fff0000
    58ec:	1fff2c00 	.word	0x1fff2c00
    58f0:	1fff2bac 	.word	0x1fff2bac
    58f4:	1fff2d08 	.word	0x1fff2d08
    58f8:	004000c8 	.word	0x004000c8
    58fc:	00400088 	.word	0x00400088
    5900:	1fff2c88 	.word	0x1fff2c88
    5904:	1fff2c11 	.word	0x1fff2c11
    5908:	1fff2c90 	.word	0x1fff2c90
    590c:	1fff2ba8 	.word	0x1fff2ba8
    5910:	1fff2c74 	.word	0x1fff2c74
    5914:	1fff2c10 	.word	0x1fff2c10
    5918:	400720c0 	.word	0x400720c0
    591c:	1fff2c80 	.word	0x1fff2c80
    5920:	1fff2bbc 	.word	0x1fff2bbc
    5924:	1fff2c7c 	.word	0x1fff2c7c
    5928:	40072098 	.word	0x40072098
    592c:	40072094 	.word	0x40072094
    5930:	1fff2c54 	.word	0x1fff2c54
    5934:	1fff2c8c 	.word	0x1fff2c8c
    5938:	40072088 	.word	0x40072088
    593c:	40072080 	.word	0x40072080
    5940:	40072090 	.word	0x40072090
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
    5944:	4ab7      	ldr	r2, [pc, #732]	; (5c24 <usb_isr+0x604>)
						b->desc = BDT_DESC(64,
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
    5946:	f847 0038 	str.w	r0, [r7, r8, lsl #3]
						usb_rx_memory_needed++;
    594a:	7813      	ldrb	r3, [r2, #0]
    594c:	3301      	adds	r3, #1
    594e:	7013      	strb	r3, [r2, #0]
    5950:	e6b0      	b.n	56b4 <usb_isr+0x94>
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[endpoint] = packet;
    5952:	f843 0026 	str.w	r0, [r3, r6, lsl #2]
    5956:	4db4      	ldr	r5, [pc, #720]	; (5c28 <usb_isr+0x608>)
    5958:	e693      	b.n	5682 <usb_isr+0x62>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    595a:	f242 0421 	movw	r4, #8225	; 0x2021
    595e:	42a1      	cmp	r1, r4
    5960:	f000 80ad 	beq.w	5abe <usb_isr+0x49e>
    5964:	f200 810e 	bhi.w	5b84 <usb_isr+0x564>
    5968:	f5b1 6f08 	cmp.w	r1, #2176	; 0x880
    596c:	f000 8154 	beq.w	5c18 <usb_isr+0x5f8>
    5970:	f5b1 6f10 	cmp.w	r1, #2304	; 0x900
    5974:	f040 819d 	bne.w	5cb2 <usb_isr+0x692>
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
    5978:	4aac      	ldr	r2, [pc, #688]	; (5c2c <usb_isr+0x60c>)
    597a:	78a9      	ldrb	r1, [r5, #2]
    597c:	7011      	strb	r1, [r2, #0]
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
			if (table[i].desc & BDT_OWN) {
    597e:	4dac      	ldr	r5, [pc, #688]	; (5c30 <usb_isr+0x610>)
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    5980:	2404      	movs	r4, #4
    5982:	e002      	b.n	598a <usb_isr+0x36a>
    5984:	3401      	adds	r4, #1
    5986:	2c14      	cmp	r4, #20
    5988:	d00c      	beq.n	59a4 <usb_isr+0x384>
			if (table[i].desc & BDT_OWN) {
    598a:	f857 3034 	ldr.w	r3, [r7, r4, lsl #3]
    598e:	0619      	lsls	r1, r3, #24
    5990:	d5f8      	bpl.n	5984 <usb_isr+0x364>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    5992:	eb05 03c4 	add.w	r3, r5, r4, lsl #3
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    5996:	3401      	adds	r4, #1
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    5998:	6858      	ldr	r0, [r3, #4]
    599a:	3808      	subs	r0, #8
    599c:	f000 fafc 	bl	5f98 <usb_free>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    59a0:	2c14      	cmp	r4, #20
    59a2:	d1f2      	bne.n	598a <usb_isr+0x36a>
    59a4:	49a3      	ldr	r1, [pc, #652]	; (5c34 <usb_isr+0x614>)
    59a6:	4ba4      	ldr	r3, [pc, #656]	; (5c38 <usb_isr+0x618>)
    59a8:	4aa4      	ldr	r2, [pc, #656]	; (5c3c <usb_isr+0x61c>)
    59aa:	9102      	str	r1, [sp, #8]
    59ac:	49a4      	ldr	r1, [pc, #656]	; (5c40 <usb_isr+0x620>)
    59ae:	4ca5      	ldr	r4, [pc, #660]	; (5c44 <usb_isr+0x624>)
    59b0:	4d9d      	ldr	r5, [pc, #628]	; (5c28 <usb_isr+0x608>)
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    59b2:	9403      	str	r4, [sp, #12]
    59b4:	9605      	str	r6, [sp, #20]
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    59b6:	f04f 0900 	mov.w	r9, #0
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    59ba:	4688      	mov	r8, r1
    59bc:	461c      	mov	r4, r3
    59be:	4616      	mov	r6, r2
    59c0:	9504      	str	r5, [sp, #16]
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    59c2:	6820      	ldr	r0, [r4, #0]
			while (p) {
    59c4:	b128      	cbz	r0, 59d2 <usb_isr+0x3b2>
				n = p->next;
    59c6:	6845      	ldr	r5, [r0, #4]
				usb_free(p);
    59c8:	f000 fae6 	bl	5f98 <usb_free>
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
			while (p) {
    59cc:	4628      	mov	r0, r5
    59ce:	2d00      	cmp	r5, #0
    59d0:	d1f9      	bne.n	59c6 <usb_isr+0x3a6>
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
    59d2:	2300      	movs	r3, #0
    59d4:	6023      	str	r3, [r4, #0]
			rx_last[i] = NULL;
    59d6:	9b04      	ldr	r3, [sp, #16]
			p = tx_first[i];
    59d8:	6830      	ldr	r0, [r6, #0]
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
    59da:	461a      	mov	r2, r3
    59dc:	2300      	movs	r3, #0
    59de:	f842 3029 	str.w	r3, [r2, r9, lsl #2]
			p = tx_first[i];
			while (p) {
    59e2:	b128      	cbz	r0, 59f0 <usb_isr+0x3d0>
				n = p->next;
    59e4:	6845      	ldr	r5, [r0, #4]
				usb_free(p);
    59e6:	f000 fad7 	bl	5f98 <usb_free>
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
			p = tx_first[i];
			while (p) {
    59ea:	4628      	mov	r0, r5
    59ec:	2d00      	cmp	r5, #0
    59ee:	d1f9      	bne.n	59e4 <usb_isr+0x3c4>
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    59f0:	2200      	movs	r2, #0
    59f2:	6032      	str	r2, [r6, #0]
			tx_last[i] = NULL;
    59f4:	9a02      	ldr	r2, [sp, #8]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    59f6:	f898 3000 	ldrb.w	r3, [r8]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    59fa:	4611      	mov	r1, r2
    59fc:	2200      	movs	r2, #0
    59fe:	f841 2b04 	str.w	r2, [r1], #4
			usb_rx_byte_count_data[i] = 0;
    5a02:	9a03      	ldr	r2, [sp, #12]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    5a04:	9102      	str	r1, [sp, #8]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    5a06:	3b02      	subs	r3, #2
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    5a08:	f04f 0100 	mov.w	r1, #0
    5a0c:	f822 1019 	strh.w	r1, [r2, r9, lsl #1]
			switch (tx_state[i]) {
    5a10:	2b03      	cmp	r3, #3
    5a12:	f200 81b4 	bhi.w	5d7e <usb_isr+0x75e>
    5a16:	e8df f013 	tbh	[pc, r3, lsl #1]
    5a1a:	01e2      	.short	0x01e2
    5a1c:	01e201ae 	.word	0x01e201ae
    5a20:	01ae      	.short	0x01ae
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    5a22:	4c89      	ldr	r4, [pc, #548]	; (5c48 <usb_isr+0x628>)
		reply_buffer[1] = 0;
		datalen = 2;
    5a24:	2002      	movs	r0, #2
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    5a26:	7022      	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    5a28:	7062      	strb	r2, [r4, #1]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    5a2a:	88ea      	ldrh	r2, [r5, #6]
    5a2c:	4282      	cmp	r2, r0
    5a2e:	f080 820d 	bcs.w	5e4c <usb_isr+0x82c>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5a32:	4986      	ldr	r1, [pc, #536]	; (5c4c <usb_isr+0x62c>)
    5a34:	780d      	ldrb	r5, [r1, #0]
    5a36:	2a40      	cmp	r2, #64	; 0x40
    5a38:	f045 0e02 	orr.w	lr, r5, #2
    5a3c:	4694      	mov	ip, r2
    5a3e:	eb07 00ce 	add.w	r0, r7, lr, lsl #3
    5a42:	bf28      	it	cs
    5a44:	f04f 0c40 	movcs.w	ip, #64	; 0x40
    5a48:	eb04 030c 	add.w	r3, r4, ip
    5a4c:	6044      	str	r4, [r0, #4]
    5a4e:	9302      	str	r3, [sp, #8]
    5a50:	ebcc 0002 	rsb	r0, ip, r2
    5a54:	ea4f 480c 	mov.w	r8, ip, lsl #16
    5a58:	f04f 0901 	mov.w	r9, #1
    5a5c:	2200      	movs	r2, #0
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5a5e:	24c8      	movs	r4, #200	; 0xc8
    5a60:	ea44 0308 	orr.w	r3, r4, r8
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    5a64:	f085 0401 	eor.w	r4, r5, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5a68:	f847 303e 	str.w	r3, [r7, lr, lsl #3]
	ep0_tx_data_toggle ^= 1;
    5a6c:	7032      	strb	r2, [r6, #0]
	ep0_tx_bdt_bank ^= 1;
    5a6e:	700c      	strb	r4, [r1, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5a70:	f8df e1bc 	ldr.w	lr, [pc, #444]	; 5c30 <usb_isr+0x610>
	ep0_tx_data_toggle ^= 1;
    5a74:	4b76      	ldr	r3, [pc, #472]	; (5c50 <usb_isr+0x630>)
	ep0_tx_bdt_bank ^= 1;
    5a76:	f8df 81d4 	ldr.w	r8, [pc, #468]	; 5c4c <usb_isr+0x62c>
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    5a7a:	2800      	cmp	r0, #0
    5a7c:	f040 8120 	bne.w	5cc0 <usb_isr+0x6a0>
    5a80:	f1bc 0f40 	cmp.w	ip, #64	; 0x40
    5a84:	d11b      	bne.n	5abe <usb_isr+0x49e>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5a86:	f044 0402 	orr.w	r4, r4, #2
    5a8a:	eb07 03c4 	add.w	r3, r7, r4, lsl #3
    5a8e:	9f02      	ldr	r7, [sp, #8]
    5a90:	f8df e19c 	ldr.w	lr, [pc, #412]	; 5c30 <usb_isr+0x610>
    5a94:	605f      	str	r7, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5a96:	2a00      	cmp	r2, #0
    5a98:	f040 8127 	bne.w	5cea <usb_isr+0x6ca>
    5a9c:	0402      	lsls	r2, r0, #16
    5a9e:	f042 0288 	orr.w	r2, r2, #136	; 0x88
	ep0_tx_data_toggle ^= 1;
    5aa2:	f886 9000 	strb.w	r9, [r6]
	ep0_tx_bdt_bank ^= 1;
    5aa6:	700d      	strb	r5, [r1, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    5aa8:	4407      	add	r7, r0
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5aaa:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    5aae:	463b      	mov	r3, r7
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    5ab0:	2840      	cmp	r0, #64	; 0x40
    5ab2:	d104      	bne.n	5abe <usb_isr+0x49e>
    5ab4:	2000      	movs	r0, #0

	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
    5ab6:	4a67      	ldr	r2, [pc, #412]	; (5c54 <usb_isr+0x634>)
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    5ab8:	9901      	ldr	r1, [sp, #4]
	ep0_tx_len = datalen;
    5aba:	8010      	strh	r0, [r2, #0]
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    5abc:	600b      	str	r3, [r1, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    5abe:	4a66      	ldr	r2, [pc, #408]	; (5c58 <usb_isr+0x638>)
    5ac0:	2301      	movs	r3, #1
    5ac2:	7013      	strb	r3, [r2, #0]
    5ac4:	e6b1      	b.n	582a <usb_isr+0x20a>
					}
					b->desc = BDT_DESC(packet->len,
						((uint32_t)b & 8) ? DATA1 : DATA0);
				} else {
					//serial_print("tx no packet\n");
					switch (tx_state[endpoint]) {
    5ac6:	5d8b      	ldrb	r3, [r1, r6]
    5ac8:	2b03      	cmp	r3, #3
    5aca:	f200 8124 	bhi.w	5d16 <usb_isr+0x6f6>
    5ace:	a201      	add	r2, pc, #4	; (adr r2, 5ad4 <usb_isr+0x4b4>)
    5ad0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    5ad4:	000056b5 	.word	0x000056b5
    5ad8:	000056b5 	.word	0x000056b5
    5adc:	00005bf9 	.word	0x00005bf9
    5ae0:	00005bff 	.word	0x00005bff
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
			int i;
			uint32_t *line_coding = NULL;
			switch (setup.wIndex) {
    5ae4:	8892      	ldrh	r2, [r2, #4]
    5ae6:	b962      	cbnz	r2, 5b02 <usb_isr+0x4e2>
    5ae8:	4a5c      	ldr	r2, [pc, #368]	; (5c5c <usb_isr+0x63c>)
    5aea:	1dcd      	adds	r5, r1, #7
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
					//serial_phex(*buf);
					*dst++ = *buf++;
    5aec:	f811 3b01 	ldrb.w	r3, [r1], #1
    5af0:	f802 3f01 	strb.w	r3, [r2, #1]!
#endif
			}
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
    5af4:	428d      	cmp	r5, r1
    5af6:	d1f9      	bne.n	5aec <usb_isr+0x4cc>
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    5af8:	4a59      	ldr	r2, [pc, #356]	; (5c60 <usb_isr+0x640>)
    5afa:	6812      	ldr	r2, [r2, #0]
    5afc:	2a86      	cmp	r2, #134	; 0x86
    5afe:	f000 80c9 	beq.w	5c94 <usb_isr+0x674>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5b02:	4952      	ldr	r1, [pc, #328]	; (5c4c <usb_isr+0x62c>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5b04:	4e52      	ldr	r6, [pc, #328]	; (5c50 <usb_isr+0x630>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5b06:	7808      	ldrb	r0, [r1, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5b08:	7832      	ldrb	r2, [r6, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5b0a:	f040 0502 	orr.w	r5, r0, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    5b0e:	f080 0001 	eor.w	r0, r0, #1
    5b12:	7008      	strb	r0, [r1, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5b14:	eb07 01c5 	add.w	r1, r7, r5, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5b18:	2a00      	cmp	r2, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5b1a:	f04f 0000 	mov.w	r0, #0
    5b1e:	6048      	str	r0, [r1, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    5b20:	f082 0201 	eor.w	r2, r2, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5b24:	bf0c      	ite	eq
    5b26:	2188      	moveq	r1, #136	; 0x88
    5b28:	21c8      	movne	r1, #200	; 0xc8
    5b2a:	f847 1035 	str.w	r1, [r7, r5, lsl #3]
	ep0_tx_data_toggle ^= 1;
    5b2e:	7032      	strb	r2, [r6, #0]
    5b30:	e686      	b.n	5840 <usb_isr+0x220>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    5b32:	f240 3202 	movw	r2, #770	; 0x302
    5b36:	4291      	cmp	r1, r2
    5b38:	f040 80b0 	bne.w	5c9c <usb_isr+0x67c>
    5b3c:	88a9      	ldrh	r1, [r5, #4]
    5b3e:	f001 017f 	and.w	r1, r1, #127	; 0x7f
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
		// TODO: do we need to clear the data toggle here?
		break;
	  case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    5b42:	2904      	cmp	r1, #4
    5b44:	f200 80b5 	bhi.w	5cb2 <usb_isr+0x692>
    5b48:	886a      	ldrh	r2, [r5, #2]
    5b4a:	2a00      	cmp	r2, #0
    5b4c:	f040 80b1 	bne.w	5cb2 <usb_isr+0x692>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    5b50:	4c44      	ldr	r4, [pc, #272]	; (5c64 <usb_isr+0x644>)
    5b52:	0089      	lsls	r1, r1, #2
    5b54:	440c      	add	r4, r1
    5b56:	4681      	mov	r9, r0
    5b58:	7821      	ldrb	r1, [r4, #0]
    5b5a:	f041 0102 	orr.w	r1, r1, #2
    5b5e:	7021      	strb	r1, [r4, #0]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    5b60:	2000      	movs	r0, #0
    5b62:	9002      	str	r0, [sp, #8]
    5b64:	4680      	mov	r8, r0
    5b66:	4684      	mov	ip, r0
    5b68:	4604      	mov	r4, r0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5b6a:	4938      	ldr	r1, [pc, #224]	; (5c4c <usb_isr+0x62c>)
    5b6c:	780d      	ldrb	r5, [r1, #0]
    5b6e:	f045 0e02 	orr.w	lr, r5, #2
    5b72:	eb07 03ce 	add.w	r3, r7, lr, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5b76:	f1b9 0f00 	cmp.w	r9, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5b7a:	605c      	str	r4, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5b7c:	bf0c      	ite	eq
    5b7e:	2488      	moveq	r4, #136	; 0x88
    5b80:	24c8      	movne	r4, #200	; 0xc8
    5b82:	e76d      	b.n	5a60 <usb_isr+0x440>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    5b84:	f242 2421 	movw	r4, #8737	; 0x2221
    5b88:	42a1      	cmp	r1, r4
    5b8a:	f040 808e 	bne.w	5caa <usb_isr+0x68a>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    5b8e:	88a9      	ldrh	r1, [r5, #4]
    5b90:	2900      	cmp	r1, #0
    5b92:	f040 8142 	bne.w	5e1a <usb_isr+0x7fa>
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    5b96:	4b34      	ldr	r3, [pc, #208]	; (5c68 <usb_isr+0x648>)
    5b98:	4a34      	ldr	r2, [pc, #208]	; (5c6c <usb_isr+0x64c>)
			usb_cdc_line_rtsdtr = setup.wValue;
    5b9a:	4c35      	ldr	r4, [pc, #212]	; (5c70 <usb_isr+0x650>)
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    5b9c:	681b      	ldr	r3, [r3, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    5b9e:	78ad      	ldrb	r5, [r5, #2]
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    5ba0:	6013      	str	r3, [r2, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    5ba2:	4681      	mov	r9, r0
    5ba4:	460a      	mov	r2, r1
    5ba6:	7025      	strb	r5, [r4, #0]
    5ba8:	e7da      	b.n	5b60 <usb_isr+0x540>

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    5baa:	492b      	ldr	r1, [pc, #172]	; (5c58 <usb_isr+0x638>)
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    5bac:	4b20      	ldr	r3, [pc, #128]	; (5c30 <usb_isr+0x610>)
    5bae:	4831      	ldr	r0, [pc, #196]	; (5c74 <usb_isr+0x654>)
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    5bb0:	4e26      	ldr	r6, [pc, #152]	; (5c4c <usb_isr+0x62c>)
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    5bb2:	f8df c0b0 	ldr.w	ip, [pc, #176]	; 5c64 <usb_isr+0x644>

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    5bb6:	4d30      	ldr	r5, [pc, #192]	; (5c78 <usb_isr+0x658>)
		USB0_ISTAT = 0xFF;
    5bb8:	f8df e0d4 	ldr.w	lr, [pc, #212]	; 5c90 <usb_isr+0x670>

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    5bbc:	4f2f      	ldr	r7, [pc, #188]	; (5c7c <usb_isr+0x65c>)

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    5bbe:	2402      	movs	r4, #2
    5bc0:	700c      	strb	r4, [r1, #0]
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    5bc2:	4c2f      	ldr	r4, [pc, #188]	; (5c80 <usb_isr+0x660>)
		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    5bc4:	6018      	str	r0, [r3, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    5bc6:	605c      	str	r4, [r3, #4]
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    5bc8:	6098      	str	r0, [r3, #8]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    5bca:	482e      	ldr	r0, [pc, #184]	; (5c84 <usb_isr+0x664>)
    5bcc:	60d8      	str	r0, [r3, #12]
		table[index(0, TX, EVEN)].desc = 0;
    5bce:	611a      	str	r2, [r3, #16]
		table[index(0, TX, ODD)].desc = 0;
    5bd0:	619a      	str	r2, [r3, #24]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    5bd2:	230d      	movs	r3, #13
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    5bd4:	7032      	strb	r2, [r6, #0]
		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    5bd6:	4c2c      	ldr	r4, [pc, #176]	; (5c88 <usb_isr+0x668>)
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    5bd8:	f88c 3000 	strb.w	r3, [ip]

		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
    5bdc:	4e2b      	ldr	r6, [pc, #172]	; (5c8c <usb_isr+0x66c>)

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    5bde:	23ff      	movs	r3, #255	; 0xff
    5be0:	702b      	strb	r3, [r5, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    5be2:	2001      	movs	r0, #1
		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    5be4:	259f      	movs	r5, #159	; 0x9f
		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
		USB0_ISTAT = 0xFF;
    5be6:	f88e 3000 	strb.w	r3, [lr]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    5bea:	703a      	strb	r2, [r7, #0]

		// enable other interrupts
		USB0_ERREN = 0xFF;
    5bec:	7033      	strb	r3, [r6, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    5bee:	7025      	strb	r5, [r4, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    5bf0:	7008      	strb	r0, [r1, #0]
	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
	}

}
    5bf2:	b007      	add	sp, #28
    5bf4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    5bf8:	2300      	movs	r3, #0
    5bfa:	558b      	strb	r3, [r1, r6]
						break;
    5bfc:	e55a      	b.n	56b4 <usb_isr+0x94>
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    5bfe:	2301      	movs	r3, #1
    5c00:	558b      	strb	r3, [r1, r6]
						break;
    5c02:	e557      	b.n	56b4 <usb_isr+0x94>
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    5c04:	4917      	ldr	r1, [pc, #92]	; (5c64 <usb_isr+0x644>)
		USB0_ISTAT = USB_ISTAT_STALL;
    5c06:	4b22      	ldr	r3, [pc, #136]	; (5c90 <usb_isr+0x670>)
    5c08:	2280      	movs	r2, #128	; 0x80
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    5c0a:	200d      	movs	r0, #13
    5c0c:	7008      	strb	r0, [r1, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    5c0e:	701a      	strb	r2, [r3, #0]
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    5c10:	07a2      	lsls	r2, r4, #30
    5c12:	f57f ae5e 	bpl.w	58d2 <usb_isr+0x2b2>
    5c16:	e655      	b.n	58c4 <usb_isr+0x2a4>
			}
#endif
		}
		break;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    5c18:	4a04      	ldr	r2, [pc, #16]	; (5c2c <usb_isr+0x60c>)
    5c1a:	4c0b      	ldr	r4, [pc, #44]	; (5c48 <usb_isr+0x628>)
    5c1c:	7812      	ldrb	r2, [r2, #0]
    5c1e:	7022      	strb	r2, [r4, #0]
    5c20:	e703      	b.n	5a2a <usb_isr+0x40a>
    5c22:	bf00      	nop
    5c24:	1fff2c7d 	.word	0x1fff2c7d
    5c28:	1fff2bac 	.word	0x1fff2bac
    5c2c:	1fff2c88 	.word	0x1fff2c88
    5c30:	1fff0000 	.word	0x1fff0000
    5c34:	1fff2c64 	.word	0x1fff2c64
    5c38:	1fff2c00 	.word	0x1fff2c00
    5c3c:	1fff2c54 	.word	0x1fff2c54
    5c40:	1fff2c8c 	.word	0x1fff2c8c
    5c44:	1fff2d08 	.word	0x1fff2d08
    5c48:	1fff2c80 	.word	0x1fff2c80
    5c4c:	1fff2c7c 	.word	0x1fff2c7c
    5c50:	1fff2c10 	.word	0x1fff2c10
    5c54:	1fff2bbc 	.word	0x1fff2bbc
    5c58:	40072094 	.word	0x40072094
    5c5c:	1fff2d0f 	.word	0x1fff2d0f
    5c60:	1fff2d10 	.word	0x1fff2d10
    5c64:	400720c0 	.word	0x400720c0
    5c68:	1fff2ba4 	.word	0x1fff2ba4
    5c6c:	1fff2d18 	.word	0x1fff2d18
    5c70:	1fff2ca0 	.word	0x1fff2ca0
    5c74:	00400088 	.word	0x00400088
    5c78:	40072088 	.word	0x40072088
    5c7c:	40072098 	.word	0x40072098
    5c80:	1fff2bc0 	.word	0x1fff2bc0
    5c84:	1fff2c14 	.word	0x1fff2c14
    5c88:	40072084 	.word	0x40072084
    5c8c:	4007208c 	.word	0x4007208c
    5c90:	40072080 	.word	0x40072080
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    5c94:	4a75      	ldr	r2, [pc, #468]	; (5e6c <usb_isr+0x84c>)
    5c96:	210f      	movs	r1, #15
    5c98:	7011      	strb	r1, [r2, #0]
    5c9a:	e732      	b.n	5b02 <usb_isr+0x4e2>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    5c9c:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
    5ca0:	d107      	bne.n	5cb2 <usb_isr+0x692>
    5ca2:	2200      	movs	r2, #0
    5ca4:	f04f 0901 	mov.w	r9, #1
    5ca8:	e75a      	b.n	5b60 <usb_isr+0x540>
    5caa:	f242 3221 	movw	r2, #8993	; 0x2321
    5cae:	4291      	cmp	r1, r2
    5cb0:	d0f7      	beq.n	5ca2 <usb_isr+0x682>
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    5cb2:	4b6f      	ldr	r3, [pc, #444]	; (5e70 <usb_isr+0x850>)
    5cb4:	220f      	movs	r2, #15
    5cb6:	701a      	strb	r2, [r3, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    5cb8:	4a6e      	ldr	r2, [pc, #440]	; (5e74 <usb_isr+0x854>)
    5cba:	2301      	movs	r3, #1
    5cbc:	7013      	strb	r3, [r2, #0]
    5cbe:	e5b4      	b.n	582a <usb_isr+0x20a>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
    5cc0:	2840      	cmp	r0, #64	; 0x40
    5cc2:	f67f aee0 	bls.w	5a86 <usb_isr+0x466>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5cc6:	f044 0402 	orr.w	r4, r4, #2
    5cca:	eb0e 01c4 	add.w	r1, lr, r4, lsl #3
    5cce:	9e02      	ldr	r6, [sp, #8]
    5cd0:	604e      	str	r6, [r1, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5cd2:	b1aa      	cbz	r2, 5d00 <usb_isr+0x6e0>
	ep0_tx_data_toggle ^= 1;
    5cd4:	f883 9000 	strb.w	r9, [r3]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5cd8:	4a67      	ldr	r2, [pc, #412]	; (5e78 <usb_isr+0x858>)
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    5cda:	f888 5000 	strb.w	r5, [r8]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    5cde:	4633      	mov	r3, r6
    5ce0:	3840      	subs	r0, #64	; 0x40
    5ce2:	3340      	adds	r3, #64	; 0x40
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5ce4:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
    5ce8:	e6e5      	b.n	5ab6 <usb_isr+0x496>
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    5cea:	9b02      	ldr	r3, [sp, #8]
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    5cec:	f886 9000 	strb.w	r9, [r6]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5cf0:	0402      	lsls	r2, r0, #16
    5cf2:	f042 02c8 	orr.w	r2, r2, #200	; 0xc8
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    5cf6:	700d      	strb	r5, [r1, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    5cf8:	4403      	add	r3, r0
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5cfa:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
    5cfe:	e6d7      	b.n	5ab0 <usb_isr+0x490>
	ep0_tx_data_toggle ^= 1;
    5d00:	f883 9000 	strb.w	r9, [r3]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    5d04:	9b02      	ldr	r3, [sp, #8]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5d06:	4a5d      	ldr	r2, [pc, #372]	; (5e7c <usb_isr+0x85c>)
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    5d08:	f888 5000 	strb.w	r5, [r8]
    5d0c:	3840      	subs	r0, #64	; 0x40
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    5d0e:	3340      	adds	r3, #64	; 0x40
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5d10:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
    5d14:	e6cf      	b.n	5ab6 <usb_isr+0x496>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
						break;
					  default:
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    5d16:	f019 0f08 	tst.w	r9, #8
    5d1a:	bf0c      	ite	eq
    5d1c:	2302      	moveq	r3, #2
    5d1e:	2303      	movne	r3, #3
    5d20:	558b      	strb	r3, [r1, r6]
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
    5d22:	e4c7      	b.n	56b4 <usb_isr+0x94>
    5d24:	88a9      	ldrh	r1, [r5, #4]
    5d26:	f001 017f 	and.w	r1, r1, #127	; 0x7f
		data = reply_buffer;
		datalen = 2;
		break;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    5d2a:	2904      	cmp	r1, #4
    5d2c:	d8c1      	bhi.n	5cb2 <usb_isr+0x692>
    5d2e:	886a      	ldrh	r2, [r5, #2]
    5d30:	2a00      	cmp	r2, #0
    5d32:	d1be      	bne.n	5cb2 <usb_isr+0x692>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    5d34:	4c4e      	ldr	r4, [pc, #312]	; (5e70 <usb_isr+0x850>)
    5d36:	0089      	lsls	r1, r1, #2
    5d38:	440c      	add	r4, r1
    5d3a:	4681      	mov	r9, r0
    5d3c:	7821      	ldrb	r1, [r4, #0]
    5d3e:	f021 0102 	bic.w	r1, r1, #2
    5d42:	7021      	strb	r1, [r4, #0]
    5d44:	e70c      	b.n	5b60 <usb_isr+0x540>
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
    5d46:	4a4e      	ldr	r2, [pc, #312]	; (5e80 <usb_isr+0x860>)
    5d48:	6854      	ldr	r4, [r2, #4]
    5d4a:	2c00      	cmp	r4, #0
    5d4c:	d0b1      	beq.n	5cb2 <usb_isr+0x692>
    5d4e:	8868      	ldrh	r0, [r5, #2]
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    5d50:	f8b5 e004 	ldrh.w	lr, [r5, #4]
    5d54:	e003      	b.n	5d5e <usb_isr+0x73e>
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
    5d56:	320c      	adds	r2, #12
			if (list->addr == NULL) break;
    5d58:	6854      	ldr	r4, [r2, #4]
    5d5a:	2c00      	cmp	r4, #0
    5d5c:	d0a9      	beq.n	5cb2 <usb_isr+0x692>
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    5d5e:	8813      	ldrh	r3, [r2, #0]
    5d60:	4283      	cmp	r3, r0
    5d62:	d1f8      	bne.n	5d56 <usb_isr+0x736>
    5d64:	8853      	ldrh	r3, [r2, #2]
    5d66:	4573      	cmp	r3, lr
    5d68:	d1f5      	bne.n	5d56 <usb_isr+0x736>
				data = list->addr;
				if ((setup.wValue >> 8) == 3) {
    5d6a:	0a00      	lsrs	r0, r0, #8
    5d6c:	2803      	cmp	r0, #3
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    5d6e:	bf0c      	ite	eq
    5d70:	7820      	ldrbeq	r0, [r4, #0]
				} else {
					datalen = list->length;
    5d72:	8910      	ldrhne	r0, [r2, #8]
    5d74:	e659      	b.n	5a2a <usb_isr+0x40a>
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    5d76:	f04f 0301 	mov.w	r3, #1
    5d7a:	f888 3000 	strb.w	r3, [r8]
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
    5d7e:	f109 0901 	add.w	r9, r9, #1
    5d82:	f1b9 0f04 	cmp.w	r9, #4
    5d86:	f104 0404 	add.w	r4, r4, #4
    5d8a:	f106 0604 	add.w	r6, r6, #4
    5d8e:	f108 0801 	add.w	r8, r8, #1
    5d92:	f47f ae16 	bne.w	59c2 <usb_isr+0x3a2>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    5d96:	4b3b      	ldr	r3, [pc, #236]	; (5e84 <usb_isr+0x864>)
    5d98:	9e05      	ldr	r6, [sp, #20]
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
    5d9a:	4d3b      	ldr	r5, [pc, #236]	; (5e88 <usb_isr+0x868>)
		cfg = usb_endpoint_config_table;
    5d9c:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 5e90 <usb_isr+0x870>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    5da0:	2000      	movs	r0, #0
    5da2:	7018      	strb	r0, [r3, #0]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    5da4:	f04f 0901 	mov.w	r9, #1
			epconf = *cfg++;
    5da8:	f818 3b01 	ldrb.w	r3, [r8], #1
			*reg = epconf;
    5dac:	f805 3b04 	strb.w	r3, [r5], #4
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    5db0:	071a      	lsls	r2, r3, #28
    5db2:	d419      	bmi.n	5de8 <usb_isr+0x7c8>
    5db4:	ea4f 0489 	mov.w	r4, r9, lsl #2
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    5db8:	f044 0202 	orr.w	r2, r4, #2
			table[index(i, TX, ODD)].desc = 0;
    5dbc:	f044 0403 	orr.w	r4, r4, #3
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    5dc0:	2300      	movs	r3, #0
    5dc2:	f847 3032 	str.w	r3, [r7, r2, lsl #3]
			table[index(i, TX, ODD)].desc = 0;
    5dc6:	f847 3034 	str.w	r3, [r7, r4, lsl #3]
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    5dca:	4b30      	ldr	r3, [pc, #192]	; (5e8c <usb_isr+0x86c>)
    5dcc:	429d      	cmp	r5, r3
    5dce:	f109 0901 	add.w	r9, r9, #1
    5dd2:	d1e9      	bne.n	5da8 <usb_isr+0x788>
    5dd4:	f896 9000 	ldrb.w	r9, [r6]
    5dd8:	f089 0201 	eor.w	r2, r9, #1
    5ddc:	e6c0      	b.n	5b60 <usb_isr+0x540>
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
			  case TX_STATE_EVEN_FREE:
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    5dde:	f04f 0300 	mov.w	r3, #0
    5de2:	f888 3000 	strb.w	r3, [r8]
    5de6:	e7ca      	b.n	5d7e <usb_isr+0x75e>
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
    5de8:	f000 f8b6 	bl	5f58 <usb_malloc>
				if (p) {
    5dec:	b318      	cbz	r0, 5e36 <usb_isr+0x816>
					table[index(i, RX, EVEN)].addr = p->buf;
    5dee:	eb07 1349 	add.w	r3, r7, r9, lsl #5
    5df2:	ea4f 0489 	mov.w	r4, r9, lsl #2
    5df6:	3008      	adds	r0, #8
    5df8:	6058      	str	r0, [r3, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    5dfa:	4b20      	ldr	r3, [pc, #128]	; (5e7c <usb_isr+0x85c>)
    5dfc:	f847 3034 	str.w	r3, [r7, r4, lsl #3]
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
    5e00:	f000 f8aa 	bl	5f58 <usb_malloc>
				if (p) {
    5e04:	b168      	cbz	r0, 5e22 <usb_isr+0x802>
					table[index(i, RX, ODD)].addr = p->buf;
    5e06:	f044 0301 	orr.w	r3, r4, #1
    5e0a:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
    5e0e:	3008      	adds	r0, #8
    5e10:	6050      	str	r0, [r2, #4]
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    5e12:	4a19      	ldr	r2, [pc, #100]	; (5e78 <usb_isr+0x858>)
    5e14:	f847 2033 	str.w	r2, [r7, r3, lsl #3]
    5e18:	e7ce      	b.n	5db8 <usb_isr+0x798>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    5e1a:	4681      	mov	r9, r0
    5e1c:	e6a0      	b.n	5b60 <usb_isr+0x540>
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
		data = reply_buffer;
		datalen = 2;
    5e1e:	2002      	movs	r0, #2
    5e20:	e603      	b.n	5a2a <usb_isr+0x40a>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
    5e22:	4b18      	ldr	r3, [pc, #96]	; (5e84 <usb_isr+0x864>)
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    5e24:	f044 0201 	orr.w	r2, r4, #1
					usb_rx_memory_needed++;
    5e28:	781b      	ldrb	r3, [r3, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    5e2a:	f847 0032 	str.w	r0, [r7, r2, lsl #3]
					usb_rx_memory_needed++;
    5e2e:	4a15      	ldr	r2, [pc, #84]	; (5e84 <usb_isr+0x864>)
    5e30:	3301      	adds	r3, #1
    5e32:	7013      	strb	r3, [r2, #0]
    5e34:	e7c0      	b.n	5db8 <usb_isr+0x798>
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
    5e36:	4b13      	ldr	r3, [pc, #76]	; (5e84 <usb_isr+0x864>)
    5e38:	4a12      	ldr	r2, [pc, #72]	; (5e84 <usb_isr+0x864>)
    5e3a:	781b      	ldrb	r3, [r3, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    5e3c:	ea4f 0489 	mov.w	r4, r9, lsl #2
					usb_rx_memory_needed++;
    5e40:	3301      	adds	r3, #1
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    5e42:	f847 0034 	str.w	r0, [r7, r4, lsl #3]
					usb_rx_memory_needed++;
    5e46:	7013      	strb	r3, [r2, #0]
    5e48:	e7da      	b.n	5e00 <usb_isr+0x7e0>


void _reboot_Teensyduino_(void)
{
	// TODO: initialize R0 with a code....
	__asm__ volatile("bkpt");
    5e4a:	be00      	bkpt	0x0000
    5e4c:	2840      	cmp	r0, #64	; 0x40
    5e4e:	4684      	mov	ip, r0
    5e50:	bf28      	it	cs
    5e52:	f04f 0c40 	movcs.w	ip, #64	; 0x40
    5e56:	eb04 030c 	add.w	r3, r4, ip
    5e5a:	ebcc 0000 	rsb	r0, ip, r0
    5e5e:	ea4f 480c 	mov.w	r8, ip, lsl #16
    5e62:	9302      	str	r3, [sp, #8]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    5e64:	2200      	movs	r2, #0
    5e66:	f04f 0901 	mov.w	r9, #1
    5e6a:	e67e      	b.n	5b6a <usb_isr+0x54a>
    5e6c:	1fff2c11 	.word	0x1fff2c11
    5e70:	400720c0 	.word	0x400720c0
    5e74:	40072094 	.word	0x40072094
    5e78:	004000c8 	.word	0x004000c8
    5e7c:	00400088 	.word	0x00400088
    5e80:	00009e0c 	.word	0x00009e0c
    5e84:	1fff2c7d 	.word	0x1fff2c7d
    5e88:	400720c4 	.word	0x400720c4
    5e8c:	400720d4 	.word	0x400720d4
    5e90:	00009e08 	.word	0x00009e08

00005e94 <usb_init>:
}



void usb_init(void)
{
    5e94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    5e96:	f000 fc03 	bl	66a0 <usb_init_serialnumber>

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    5e9a:	2300      	movs	r3, #0
    5e9c:	4924      	ldr	r1, [pc, #144]	; (5f30 <usb_init+0x9c>)
		table[i].desc = 0;
    5e9e:	461a      	mov	r2, r3
		table[i].addr = 0;
    5ea0:	eb01 00c3 	add.w	r0, r1, r3, lsl #3
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
		table[i].desc = 0;
    5ea4:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    5ea8:	3301      	adds	r3, #1
    5eaa:	2b14      	cmp	r3, #20
		table[i].desc = 0;
		table[i].addr = 0;
    5eac:	6042      	str	r2, [r0, #4]
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
		table[i].desc = 0;
    5eae:	f04f 0400 	mov.w	r4, #0
    5eb2:	481f      	ldr	r0, [pc, #124]	; (5f30 <usb_init+0x9c>)
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    5eb4:	d1f4      	bne.n	5ea0 <usb_init+0xc>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    5eb6:	491f      	ldr	r1, [pc, #124]	; (5f34 <usb_init+0xa0>)
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    5eb8:	4a1f      	ldr	r2, [pc, #124]	; (5f38 <usb_init+0xa4>)
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    5eba:	680b      	ldr	r3, [r1, #0]
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
#endif
#if F_CPU == 180000000 || F_CPU == 216000000 || F_CPU == 256000000
	// if using IRC48M, turn on the USB clock recovery hardware
	USB0_CLK_RECOVER_IRC_EN = USB_CLK_RECOVER_IRC_EN_IRC_EN | USB_CLK_RECOVER_IRC_EN_REG_EN;
    5ebc:	f8df c090 	ldr.w	ip, [pc, #144]	; 5f50 <usb_init+0xbc>
	USB0_CLK_RECOVER_CTRL = USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN |
    5ec0:	4e1e      	ldr	r6, [pc, #120]	; (5f3c <usb_init+0xa8>)
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    5ec2:	4f1f      	ldr	r7, [pc, #124]	; (5f40 <usb_init+0xac>)
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    5ec4:	4d1f      	ldr	r5, [pc, #124]	; (5f44 <usb_init+0xb0>)

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    5ec6:	f8df e08c 	ldr.w	lr, [pc, #140]	; 5f54 <usb_init+0xc0>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    5eca:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    5ece:	600b      	str	r3, [r1, #0]
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    5ed0:	6813      	ldr	r3, [r2, #0]
    5ed2:	f043 7340 	orr.w	r3, r3, #50331648	; 0x3000000
    5ed6:	6013      	str	r3, [r2, #0]
#endif
#if F_CPU == 180000000 || F_CPU == 216000000 || F_CPU == 256000000
	// if using IRC48M, turn on the USB clock recovery hardware
	USB0_CLK_RECOVER_IRC_EN = USB_CLK_RECOVER_IRC_EN_IRC_EN | USB_CLK_RECOVER_IRC_EN_REG_EN;
    5ed8:	2303      	movs	r3, #3
    5eda:	f88c 3000 	strb.w	r3, [ip]
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    5ede:	f501 3128 	add.w	r1, r1, #172032	; 0x2a000
	MPU_RGDAAC0 |= 0x03000000;
#endif
#if F_CPU == 180000000 || F_CPU == 216000000 || F_CPU == 256000000
	// if using IRC48M, turn on the USB clock recovery hardware
	USB0_CLK_RECOVER_IRC_EN = USB_CLK_RECOVER_IRC_EN_IRC_EN | USB_CLK_RECOVER_IRC_EN_REG_EN;
	USB0_CLK_RECOVER_CTRL = USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN |
    5ee2:	23a0      	movs	r3, #160	; 0xa0
    5ee4:	7033      	strb	r3, [r6, #0]
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    5ee6:	317c      	adds	r1, #124	; 0x7c
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    5ee8:	f502 22c9 	add.w	r2, r2, #411648	; 0x64800
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    5eec:	f3c0 2307 	ubfx	r3, r0, #8, #8
    5ef0:	703b      	strb	r3, [r7, #0]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    5ef2:	3210      	adds	r2, #16
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    5ef4:	f3c0 4307 	ubfx	r3, r0, #16, #8
    5ef8:	700b      	strb	r3, [r1, #0]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    5efa:	0e00      	lsrs	r0, r0, #24

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    5efc:	23ff      	movs	r3, #255	; 0xff
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    5efe:	7028      	strb	r0, [r5, #0]

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    5f00:	f88e 3000 	strb.w	r3, [lr]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    5f04:	4d10      	ldr	r5, [pc, #64]	; (5f48 <usb_init+0xb4>)
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
    5f06:	f80c 3cbc 	strb.w	r3, [ip, #-188]
	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    5f0a:	4810      	ldr	r0, [pc, #64]	; (5f4c <usb_init+0xb8>)
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    5f0c:	7013      	strb	r3, [r2, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    5f0e:	2301      	movs	r3, #1
    5f10:	f806 3cac 	strb.w	r3, [r6, #-172]
	USB0_USBCTRL = 0;
    5f14:	f881 4050 	strb.w	r4, [r1, #80]	; 0x50

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    5f18:	2670      	movs	r6, #112	; 0x70
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    5f1a:	f44f 1400 	mov.w	r4, #2097152	; 0x200000

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    5f1e:	2110      	movs	r1, #16
	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    5f20:	f807 3c18 	strb.w	r3, [r7, #-24]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    5f24:	702e      	strb	r6, [r5, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    5f26:	6004      	str	r4, [r0, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    5f28:	f882 10f8 	strb.w	r1, [r2, #248]	; 0xf8
    5f2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5f2e:	bf00      	nop
    5f30:	1fff0000 	.word	0x1fff0000
    5f34:	40048034 	.word	0x40048034
    5f38:	4000d800 	.word	0x4000d800
    5f3c:	40072140 	.word	0x40072140
    5f40:	4007209c 	.word	0x4007209c
    5f44:	400720b4 	.word	0x400720b4
    5f48:	e000e435 	.word	0xe000e435
    5f4c:	e000e104 	.word	0xe000e104
    5f50:	40072144 	.word	0x40072144
    5f54:	40072080 	.word	0x40072080

00005f58 <usb_malloc>:
usb_packet_t * usb_malloc(void)
{
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    5f58:	b672      	cpsid	i
	avail = usb_buffer_available;
    5f5a:	480d      	ldr	r0, [pc, #52]	; (5f90 <usb_malloc+0x38>)
    5f5c:	6802      	ldr	r2, [r0, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    5f5e:	fab2 f382 	clz	r3, r2
	if (n >= NUM_USB_BUFFERS) {
    5f62:	2b0b      	cmp	r3, #11
    5f64:	dc10      	bgt.n	5f88 <usb_malloc+0x30>
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    5f66:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    5f6a:	40d9      	lsrs	r1, r3
    5f6c:	ea22 0201 	bic.w	r2, r2, r1
    5f70:	6002      	str	r2, [r0, #0]
	__enable_irq();
    5f72:	b662      	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    5f74:	4807      	ldr	r0, [pc, #28]	; (5f94 <usb_malloc+0x3c>)
    5f76:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
    5f7a:	00db      	lsls	r3, r3, #3
    5f7c:	18c2      	adds	r2, r0, r3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    5f7e:	2100      	movs	r1, #0
    5f80:	50c1      	str	r1, [r0, r3]
	*(uint32_t *)(p + 4) = 0;
	return (usb_packet_t *)p;
    5f82:	4610      	mov	r0, r2
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
	*(uint32_t *)(p + 4) = 0;
    5f84:	6051      	str	r1, [r2, #4]
	return (usb_packet_t *)p;
}
    5f86:	4770      	bx	lr

	__disable_irq();
	avail = usb_buffer_available;
	n = __builtin_clz(avail); // clz = count leading zeros
	if (n >= NUM_USB_BUFFERS) {
		__enable_irq();
    5f88:	b662      	cpsie	i
		return NULL;
    5f8a:	2000      	movs	r0, #0
    5f8c:	4770      	bx	lr
    5f8e:	bf00      	nop
    5f90:	1fff0b24 	.word	0x1fff0b24
    5f94:	1fff03d0 	.word	0x1fff03d0

00005f98 <usb_free>:
void usb_free(usb_packet_t *p)
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    5f98:	4b0d      	ldr	r3, [pc, #52]	; (5fd0 <usb_free+0x38>)
    5f9a:	4a0e      	ldr	r2, [pc, #56]	; (5fd4 <usb_free+0x3c>)
    5f9c:	1ac3      	subs	r3, r0, r3
    5f9e:	fba2 2303 	umull	r2, r3, r2, r3
    5fa2:	091b      	lsrs	r3, r3, #4
	if (n >= NUM_USB_BUFFERS) return;
    5fa4:	2b0b      	cmp	r3, #11
    5fa6:	d80c      	bhi.n	5fc2 <usb_free+0x2a>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    5fa8:	4a0b      	ldr	r2, [pc, #44]	; (5fd8 <usb_free+0x40>)
    5faa:	7812      	ldrb	r2, [r2, #0]
    5fac:	b952      	cbnz	r2, 5fc4 <usb_free+0x2c>
		usb_rx_memory(p);
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    5fae:	b672      	cpsid	i
	usb_buffer_available |= mask;
    5fb0:	480a      	ldr	r0, [pc, #40]	; (5fdc <usb_free+0x44>)
    5fb2:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    5fb6:	6802      	ldr	r2, [r0, #0]
    5fb8:	fa21 f303 	lsr.w	r3, r1, r3
    5fbc:	431a      	orrs	r2, r3
    5fbe:	6002      	str	r2, [r0, #0]
	__enable_irq();
    5fc0:	b662      	cpsie	i
    5fc2:	4770      	bx	lr
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    5fc4:	4a06      	ldr	r2, [pc, #24]	; (5fe0 <usb_free+0x48>)
    5fc6:	7812      	ldrb	r2, [r2, #0]
    5fc8:	2a00      	cmp	r2, #0
    5fca:	d0f0      	beq.n	5fae <usb_free+0x16>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    5fcc:	f7ff baa4 	b.w	5518 <usb_rx_memory>
    5fd0:	1fff03d0 	.word	0x1fff03d0
    5fd4:	38e38e39 	.word	0x38e38e39
    5fd8:	1fff2c7d 	.word	0x1fff2c7d
    5fdc:	1fff0b24 	.word	0x1fff0b24
    5fe0:	1fff2c88 	.word	0x1fff2c88

00005fe4 <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    5fe4:	b538      	push	{r3, r4, r5, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    5fe6:	4d0f      	ldr	r5, [pc, #60]	; (6024 <usb_serial_getchar+0x40>)
    5fe8:	6828      	ldr	r0, [r5, #0]
    5fea:	b178      	cbz	r0, 600c <usb_serial_getchar+0x28>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    5fec:	8843      	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
    5fee:	8802      	ldrh	r2, [r0, #0]
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    5ff0:	18c1      	adds	r1, r0, r3
    5ff2:	3301      	adds	r3, #1
	if (i >= rx_packet->len) {
    5ff4:	4293      	cmp	r3, r2
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    5ff6:	7a0c      	ldrb	r4, [r1, #8]
	if (i >= rx_packet->len) {
    5ff8:	d202      	bcs.n	6000 <usb_serial_getchar+0x1c>
		usb_free(rx_packet);
		rx_packet = NULL;
	} else {
		rx_packet->index = i;
    5ffa:	8043      	strh	r3, [r0, #2]
	}
	return c;
    5ffc:	4620      	mov	r0, r4
}
    5ffe:	bd38      	pop	{r3, r4, r5, pc}
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
    6000:	f7ff ffca 	bl	5f98 <usb_free>
		rx_packet = NULL;
    6004:	2300      	movs	r3, #0
	} else {
		rx_packet->index = i;
	}
	return c;
    6006:	4620      	mov	r0, r4
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
		rx_packet = NULL;
    6008:	602b      	str	r3, [r5, #0]
    600a:	bd38      	pop	{r3, r4, r5, pc}
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    600c:	4b06      	ldr	r3, [pc, #24]	; (6028 <usb_serial_getchar+0x44>)
    600e:	781b      	ldrb	r3, [r3, #0]
    6010:	b12b      	cbz	r3, 601e <usb_serial_getchar+0x3a>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    6012:	2003      	movs	r0, #3
    6014:	f7ff fa4c 	bl	54b0 <usb_rx>
    6018:	6028      	str	r0, [r5, #0]
		if (!rx_packet) return -1;
    601a:	2800      	cmp	r0, #0
    601c:	d1e6      	bne.n	5fec <usb_serial_getchar+0x8>
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    601e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    6022:	bd38      	pop	{r3, r4, r5, pc}
    6024:	1fff2c9c 	.word	0x1fff2c9c
    6028:	1fff2c88 	.word	0x1fff2c88

0000602c <usb_serial_peekchar>:
	return c;
}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    602c:	b510      	push	{r4, lr}
	if (!rx_packet) {
    602e:	4c09      	ldr	r4, [pc, #36]	; (6054 <usb_serial_peekchar+0x28>)
    6030:	6820      	ldr	r0, [r4, #0]
    6032:	b118      	cbz	r0, 603c <usb_serial_peekchar+0x10>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
	return rx_packet->buf[rx_packet->index];
    6034:	8843      	ldrh	r3, [r0, #2]
    6036:	4418      	add	r0, r3
    6038:	7a00      	ldrb	r0, [r0, #8]
}
    603a:	bd10      	pop	{r4, pc}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    603c:	4b06      	ldr	r3, [pc, #24]	; (6058 <usb_serial_peekchar+0x2c>)
    603e:	781b      	ldrb	r3, [r3, #0]
    6040:	b12b      	cbz	r3, 604e <usb_serial_peekchar+0x22>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    6042:	2003      	movs	r0, #3
    6044:	f7ff fa34 	bl	54b0 <usb_rx>
    6048:	6020      	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    604a:	2800      	cmp	r0, #0
    604c:	d1f2      	bne.n	6034 <usb_serial_peekchar+0x8>

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    604e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    6052:	bd10      	pop	{r4, pc}
    6054:	1fff2c9c 	.word	0x1fff2c9c
    6058:	1fff2c88 	.word	0x1fff2c88

0000605c <usb_serial_available>:
// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    605c:	4b04      	ldr	r3, [pc, #16]	; (6070 <usb_serial_available+0x14>)
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    605e:	4a05      	ldr	r2, [pc, #20]	; (6074 <usb_serial_available+0x18>)
    6060:	681b      	ldr	r3, [r3, #0]

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    6062:	8890      	ldrh	r0, [r2, #4]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    6064:	b11b      	cbz	r3, 606e <usb_serial_available+0x12>
    6066:	881a      	ldrh	r2, [r3, #0]
    6068:	885b      	ldrh	r3, [r3, #2]
    606a:	1ad3      	subs	r3, r2, r3
    606c:	4418      	add	r0, r3
	return count;
}
    606e:	4770      	bx	lr
    6070:	1fff2c9c 	.word	0x1fff2c9c
    6074:	1fff2d08 	.word	0x1fff2d08

00006078 <usb_serial_flush_input>:
// discard any buffered input
void usb_serial_flush_input(void)
{
	usb_packet_t *rx;

	if (!usb_configuration) return;
    6078:	4b0b      	ldr	r3, [pc, #44]	; (60a8 <usb_serial_flush_input+0x30>)
    607a:	781b      	ldrb	r3, [r3, #0]
    607c:	b19b      	cbz	r3, 60a6 <usb_serial_flush_input+0x2e>
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    607e:	b510      	push	{r4, lr}
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
    6080:	4c0a      	ldr	r4, [pc, #40]	; (60ac <usb_serial_flush_input+0x34>)
    6082:	6820      	ldr	r0, [r4, #0]
    6084:	b148      	cbz	r0, 609a <usb_serial_flush_input+0x22>
		usb_free(rx_packet);
    6086:	f7ff ff87 	bl	5f98 <usb_free>
		rx_packet = NULL;
    608a:	2300      	movs	r3, #0
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    608c:	2003      	movs	r0, #3
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
    608e:	6023      	str	r3, [r4, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    6090:	f7ff fa0e 	bl	54b0 <usb_rx>
		if (!rx) break;
    6094:	b130      	cbz	r0, 60a4 <usb_serial_flush_input+0x2c>
		usb_free(rx);
    6096:	f7ff ff7f 	bl	5f98 <usb_free>
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    609a:	2003      	movs	r0, #3
    609c:	f7ff fa08 	bl	54b0 <usb_rx>
		if (!rx) break;
    60a0:	2800      	cmp	r0, #0
    60a2:	d1f8      	bne.n	6096 <usb_serial_flush_input+0x1e>
    60a4:	bd10      	pop	{r4, pc}
    60a6:	4770      	bx	lr
    60a8:	1fff2c88 	.word	0x1fff2c88
    60ac:	1fff2c9c 	.word	0x1fff2c9c

000060b0 <usb_serial_write>:
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    60b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    60b4:	f8df 90f8 	ldr.w	r9, [pc, #248]	; 61b0 <usb_serial_write+0x100>
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    60b8:	b083      	sub	sp, #12
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    60ba:	2201      	movs	r2, #1
    60bc:	f889 2000 	strb.w	r2, [r9]
	while (size > 0) {
    60c0:	9101      	str	r1, [sp, #4]
    60c2:	b369      	cbz	r1, 6120 <usb_serial_write+0x70>
    60c4:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 61b4 <usb_serial_write+0x104>
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    60c8:	4f35      	ldr	r7, [pc, #212]	; (61a0 <usb_serial_write+0xf0>)
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    60ca:	9e01      	ldr	r6, [sp, #4]
    60cc:	4683      	mov	fp, r0
		if (!tx_packet) {
    60ce:	f8d8 0000 	ldr.w	r0, [r8]
    60d2:	b3b0      	cbz	r0, 6142 <usb_serial_write+0x92>
    60d4:	4d33      	ldr	r5, [pc, #204]	; (61a4 <usb_serial_write+0xf4>)
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
    60d6:	8844      	ldrh	r4, [r0, #2]
    60d8:	f1c4 0140 	rsb	r1, r4, #64	; 0x40
    60dc:	42b1      	cmp	r1, r6
    60de:	bf28      	it	cs
    60e0:	4631      	movcs	r1, r6
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    60e2:	eb04 0e01 	add.w	lr, r4, r1
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    60e6:	2200      	movs	r2, #0
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    60e8:	fa1f fe8e 	uxth.w	lr, lr
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    60ec:	702a      	strb	r2, [r5, #0]
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
    60ee:	1a76      	subs	r6, r6, r1
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    60f0:	f8a0 e002 	strh.w	lr, [r0, #2]
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
    60f4:	f100 0208 	add.w	r2, r0, #8
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
    60f8:	b151      	cbz	r1, 6110 <usb_serial_write+0x60>
    60fa:	3c01      	subs	r4, #1
    60fc:	4422      	add	r2, r4
    60fe:	4459      	add	r1, fp
    6100:	f81b 4b01 	ldrb.w	r4, [fp], #1
    6104:	f802 4f01 	strb.w	r4, [r2, #1]!
    6108:	458b      	cmp	fp, r1
    610a:	d1f9      	bne.n	6100 <usb_serial_write+0x50>
    610c:	f8b0 e002 	ldrh.w	lr, [r0, #2]
		if (tx_packet->index >= CDC_TX_SIZE) {
    6110:	f1be 0f3f 	cmp.w	lr, #63	; 0x3f
    6114:	d80b      	bhi.n	612e <usb_serial_write+0x7e>
			tx_packet->len = CDC_TX_SIZE;
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    6116:	4a24      	ldr	r2, [pc, #144]	; (61a8 <usb_serial_write+0xf8>)
    6118:	2105      	movs	r1, #5
    611a:	7011      	strb	r1, [r2, #0]
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    611c:	2e00      	cmp	r6, #0
    611e:	d1d6      	bne.n	60ce <usb_serial_write+0x1e>
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
    6120:	9801      	ldr	r0, [sp, #4]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
    6122:	2300      	movs	r3, #0
    6124:	f889 3000 	strb.w	r3, [r9]
	return ret;
}
    6128:	b003      	add	sp, #12
    612a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
		if (tx_packet->index >= CDC_TX_SIZE) {
			tx_packet->len = CDC_TX_SIZE;
    612e:	2240      	movs	r2, #64	; 0x40
    6130:	8002      	strh	r2, [r0, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    6132:	4601      	mov	r1, r0
    6134:	2004      	movs	r0, #4
    6136:	f7ff fa31 	bl	559c <usb_tx>
			tx_packet = NULL;
    613a:	2200      	movs	r2, #0
    613c:	f8c8 2000 	str.w	r2, [r8]
    6140:	e7e9      	b.n	6116 <usb_serial_write+0x66>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    6142:	783a      	ldrb	r2, [r7, #0]
    6144:	b322      	cbz	r2, 6190 <usb_serial_write+0xe0>
    6146:	4c19      	ldr	r4, [pc, #100]	; (61ac <usb_serial_write+0xfc>)
    6148:	4d16      	ldr	r5, [pc, #88]	; (61a4 <usb_serial_write+0xf4>)
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
    614a:	f04f 0a01 	mov.w	sl, #1
    614e:	e007      	b.n	6160 <usb_serial_write+0xb0>
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    6150:	3c01      	subs	r4, #1
    6152:	d016      	beq.n	6182 <usb_serial_write+0xd2>
    6154:	782a      	ldrb	r2, [r5, #0]
    6156:	b9a2      	cbnz	r2, 6182 <usb_serial_write+0xd2>
					transmit_previous_timeout = 1;
					return -1;
				}
				yield();
    6158:	f000 f95a 	bl	6410 <yield>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    615c:	783a      	ldrb	r2, [r7, #0]
    615e:	b1ba      	cbz	r2, 6190 <usb_serial_write+0xe0>
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    6160:	2004      	movs	r0, #4
    6162:	f7ff f9c3 	bl	54ec <usb_tx_packet_count>
    6166:	2807      	cmp	r0, #7
    6168:	d8f2      	bhi.n	6150 <usb_serial_write+0xa0>
					tx_noautoflush = 1;
    616a:	f889 a000 	strb.w	sl, [r9]
					tx_packet = usb_malloc();
    616e:	f7ff fef3 	bl	5f58 <usb_malloc>
    6172:	f8c8 0000 	str.w	r0, [r8]
					if (tx_packet) break;
    6176:	2800      	cmp	r0, #0
    6178:	d1ad      	bne.n	60d6 <usb_serial_write+0x26>
					tx_noautoflush = 0;
    617a:	4b0d      	ldr	r3, [pc, #52]	; (61b0 <usb_serial_write+0x100>)
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    617c:	3c01      	subs	r4, #1
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
    617e:	7018      	strb	r0, [r3, #0]
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    6180:	d1e8      	bne.n	6154 <usb_serial_write+0xa4>
					transmit_previous_timeout = 1;
    6182:	2301      	movs	r3, #1
					return -1;
    6184:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
					transmit_previous_timeout = 1;
    6188:	702b      	strb	r3, [r5, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    618a:	b003      	add	sp, #12
    618c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    6190:	2300      	movs	r3, #0
					return -1;
    6192:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    6196:	f889 3000 	strb.w	r3, [r9]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    619a:	b003      	add	sp, #12
    619c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    61a0:	1fff2c88 	.word	0x1fff2c88
    61a4:	1fff2c98 	.word	0x1fff2c98
    61a8:	1fff2c90 	.word	0x1fff2c90
    61ac:	00014821 	.word	0x00014821
    61b0:	1fff2c91 	.word	0x1fff2c91
    61b4:	1fff2c94 	.word	0x1fff2c94

000061b8 <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    61b8:	b500      	push	{lr}
    61ba:	b083      	sub	sp, #12
    61bc:	ab02      	add	r3, sp, #8
	return usb_serial_write(&c, 1);
    61be:	2101      	movs	r1, #1
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    61c0:	f803 0d01 	strb.w	r0, [r3, #-1]!
	return usb_serial_write(&c, 1);
    61c4:	4618      	mov	r0, r3
    61c6:	f7ff ff73 	bl	60b0 <usb_serial_write>
}
    61ca:	b003      	add	sp, #12
    61cc:	f85d fb04 	ldr.w	pc, [sp], #4

000061d0 <usb_serial_write_buffer_free>:
	tx_noautoflush = 0;
	return ret;
}

int usb_serial_write_buffer_free(void)
{
    61d0:	b538      	push	{r3, r4, r5, lr}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
    61d2:	4d0e      	ldr	r5, [pc, #56]	; (620c <usb_serial_write_buffer_free+0x3c>)

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    61d4:	4c0e      	ldr	r4, [pc, #56]	; (6210 <usb_serial_write_buffer_free+0x40>)
	if (!tx_packet) {
    61d6:	6828      	ldr	r0, [r5, #0]

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    61d8:	2301      	movs	r3, #1
    61da:	7023      	strb	r3, [r4, #0]
	if (!tx_packet) {
    61dc:	b128      	cbz	r0, 61ea <usb_serial_write_buffer_free+0x1a>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    61de:	8840      	ldrh	r0, [r0, #2]
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    61e0:	2300      	movs	r3, #0
    61e2:	7023      	strb	r3, [r4, #0]
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    61e4:	f1c0 0040 	rsb	r0, r0, #64	; 0x40
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
	return len;
}
    61e8:	bd38      	pop	{r3, r4, r5, pc}
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    61ea:	4b0a      	ldr	r3, [pc, #40]	; (6214 <usb_serial_write_buffer_free+0x44>)
    61ec:	781b      	ldrb	r3, [r3, #0]
    61ee:	b913      	cbnz	r3, 61f6 <usb_serial_write_buffer_free+0x26>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    61f0:	2000      	movs	r0, #0
    61f2:	7020      	strb	r0, [r4, #0]
			return 0;
    61f4:	bd38      	pop	{r3, r4, r5, pc}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    61f6:	2004      	movs	r0, #4
    61f8:	f7ff f978 	bl	54ec <usb_tx_packet_count>
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    61fc:	2807      	cmp	r0, #7
    61fe:	d8f7      	bhi.n	61f0 <usb_serial_write_buffer_free+0x20>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
    6200:	f7ff feaa 	bl	5f58 <usb_malloc>
    6204:	6028      	str	r0, [r5, #0]
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    6206:	2800      	cmp	r0, #0
    6208:	d1e9      	bne.n	61de <usb_serial_write_buffer_free+0xe>
    620a:	e7f1      	b.n	61f0 <usb_serial_write_buffer_free+0x20>
    620c:	1fff2c94 	.word	0x1fff2c94
    6210:	1fff2c91 	.word	0x1fff2c91
    6214:	1fff2c88 	.word	0x1fff2c88

00006218 <usb_serial_flush_output>:
	tx_noautoflush = 0;
	return len;
}

void usb_serial_flush_output(void)
{
    6218:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!usb_configuration) return;
    621a:	4b11      	ldr	r3, [pc, #68]	; (6260 <usb_serial_flush_output+0x48>)
    621c:	781b      	ldrb	r3, [r3, #0]
    621e:	b18b      	cbz	r3, 6244 <usb_serial_flush_output+0x2c>
	tx_noautoflush = 1;
	if (tx_packet) {
    6220:	4e10      	ldr	r6, [pc, #64]	; (6264 <usb_serial_flush_output+0x4c>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    6222:	4d11      	ldr	r5, [pc, #68]	; (6268 <usb_serial_flush_output+0x50>)
	if (tx_packet) {
    6224:	6834      	ldr	r4, [r6, #0]
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    6226:	2701      	movs	r7, #1
    6228:	702f      	strb	r7, [r5, #0]
	if (tx_packet) {
    622a:	b164      	cbz	r4, 6246 <usb_serial_flush_output+0x2e>
		usb_cdc_transmit_flush_timer = 0;
    622c:	4a0f      	ldr	r2, [pc, #60]	; (626c <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
    622e:	8863      	ldrh	r3, [r4, #2]
void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
    6230:	2700      	movs	r7, #0
    6232:	7017      	strb	r7, [r2, #0]
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    6234:	4621      	mov	r1, r4
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
    6236:	8023      	strh	r3, [r4, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    6238:	2004      	movs	r0, #4
    623a:	f7ff f9af 	bl	559c <usb_tx>
		tx_packet = NULL;
    623e:	6037      	str	r7, [r6, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
	tx_noautoflush = 0;
    6240:	2300      	movs	r3, #0
    6242:	702b      	strb	r3, [r5, #0]
    6244:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    6246:	f7ff fe87 	bl	5f58 <usb_malloc>
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    624a:	4b08      	ldr	r3, [pc, #32]	; (626c <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
    624c:	b128      	cbz	r0, 625a <usb_serial_flush_output+0x42>
			usb_cdc_transmit_flush_timer = 0;
			usb_tx(CDC_TX_ENDPOINT, tx);
    624e:	4601      	mov	r1, r0
    6250:	2004      	movs	r0, #4
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    6252:	701c      	strb	r4, [r3, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    6254:	f7ff f9a2 	bl	559c <usb_tx>
    6258:	e7f2      	b.n	6240 <usb_serial_flush_output+0x28>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    625a:	701f      	strb	r7, [r3, #0]
    625c:	e7f0      	b.n	6240 <usb_serial_flush_output+0x28>
    625e:	bf00      	nop
    6260:	1fff2c88 	.word	0x1fff2c88
    6264:	1fff2c94 	.word	0x1fff2c94
    6268:	1fff2c91 	.word	0x1fff2c91
    626c:	1fff2c90 	.word	0x1fff2c90

00006270 <usb_serial_flush_callback>:
	}
	tx_noautoflush = 0;
}

void usb_serial_flush_callback(void)
{
    6270:	b538      	push	{r3, r4, r5, lr}
	if (tx_noautoflush) return;
    6272:	4b0e      	ldr	r3, [pc, #56]	; (62ac <usb_serial_flush_callback+0x3c>)
    6274:	781b      	ldrb	r3, [r3, #0]
    6276:	b973      	cbnz	r3, 6296 <usb_serial_flush_callback+0x26>
	if (tx_packet) {
    6278:	4c0d      	ldr	r4, [pc, #52]	; (62b0 <usb_serial_flush_callback+0x40>)
    627a:	6821      	ldr	r1, [r4, #0]
    627c:	b161      	cbz	r1, 6298 <usb_serial_flush_callback+0x28>
    627e:	f003 05ff 	and.w	r5, r3, #255	; 0xff
		tx_packet->len = tx_packet->index;
    6282:	884b      	ldrh	r3, [r1, #2]
    6284:	800b      	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    6286:	2004      	movs	r0, #4
    6288:	f7ff f988 	bl	559c <usb_tx>
		tx_packet = NULL;
    628c:	6025      	str	r5, [r4, #0]
    628e:	bd38      	pop	{r3, r4, r5, pc}
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
    6290:	4b08      	ldr	r3, [pc, #32]	; (62b4 <usb_serial_flush_callback+0x44>)
    6292:	2201      	movs	r2, #1
    6294:	701a      	strb	r2, [r3, #0]
    6296:	bd38      	pop	{r3, r4, r5, pc}
	if (tx_packet) {
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    6298:	f7ff fe5e 	bl	5f58 <usb_malloc>
		if (tx) {
    629c:	2800      	cmp	r0, #0
    629e:	d0f7      	beq.n	6290 <usb_serial_flush_callback+0x20>
			usb_tx(CDC_TX_ENDPOINT, tx);
    62a0:	4601      	mov	r1, r0
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    62a2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
    62a6:	2004      	movs	r0, #4
    62a8:	f7ff b978 	b.w	559c <usb_tx>
    62ac:	1fff2c91 	.word	0x1fff2c91
    62b0:	1fff2c94 	.word	0x1fff2c94
    62b4:	1fff2c90 	.word	0x1fff2c90

000062b8 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    62b8:	b570      	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    62ba:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    62be:	b672      	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    62c0:	4c0c      	ldr	r4, [pc, #48]	; (62f4 <EventResponder::runFromInterrupt()+0x3c>)
    62c2:	6820      	ldr	r0, [r4, #0]
		if (first) {
    62c4:	b180      	cbz	r0, 62e8 <EventResponder::runFromInterrupt()+0x30>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    62c6:	4e0c      	ldr	r6, [pc, #48]	; (62f8 <EventResponder::runFromInterrupt()+0x40>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    62c8:	2500      	movs	r5, #0
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
    62ca:	6943      	ldr	r3, [r0, #20]
    62cc:	6023      	str	r3, [r4, #0]
			if (firstInterrupt) {
    62ce:	b173      	cbz	r3, 62ee <EventResponder::runFromInterrupt()+0x36>
				firstInterrupt->_prev = nullptr;
    62d0:	619d      	str	r5, [r3, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    62d2:	b902      	cbnz	r2, 62d6 <EventResponder::runFromInterrupt()+0x1e>
    62d4:	b662      	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    62d6:	7745      	strb	r5, [r0, #29]
			(*(first->_function))(*first);
    62d8:	6883      	ldr	r3, [r0, #8]
    62da:	4798      	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    62dc:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    62e0:	b672      	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    62e2:	6820      	ldr	r0, [r4, #0]
		if (first) {
    62e4:	2800      	cmp	r0, #0
    62e6:	d1f0      	bne.n	62ca <EventResponder::runFromInterrupt()+0x12>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    62e8:	b902      	cbnz	r2, 62ec <EventResponder::runFromInterrupt()+0x34>
    62ea:	b662      	cpsie	i
    62ec:	bd70      	pop	{r4, r5, r6, pc}
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    62ee:	6033      	str	r3, [r6, #0]
    62f0:	e7ef      	b.n	62d2 <EventResponder::runFromInterrupt()+0x1a>
    62f2:	bf00      	nop
    62f4:	1fff2ca4 	.word	0x1fff2ca4
    62f8:	1fff2ca8 	.word	0x1fff2ca8

000062fc <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    62fc:	f7ff bfdc 	b.w	62b8 <EventResponder::runFromInterrupt()>

00006300 <systick_isr>:

extern "C" volatile uint32_t systick_millis_count;

void systick_isr(void)
{
	systick_millis_count++;
    6300:	4a02      	ldr	r2, [pc, #8]	; (630c <systick_isr+0xc>)
    6302:	6813      	ldr	r3, [r2, #0]
    6304:	3301      	adds	r3, #1
    6306:	6013      	str	r3, [r2, #0]
    6308:	4770      	bx	lr
    630a:	bf00      	nop
    630c:	1fff2ba4 	.word	0x1fff2ba4

00006310 <String::~String()>:
	init();
	char buf[40];
	*this = dtostrf(num, digits + 2, digits, buf);
}

String::~String()
    6310:	b510      	push	{r4, lr}
    6312:	4604      	mov	r4, r0
{
	free(buffer);
    6314:	6800      	ldr	r0, [r0, #0]
    6316:	f002 f855 	bl	83c4 <free>
}
    631a:	4620      	mov	r0, r4
    631c:	bd10      	pop	{r4, pc}
    631e:	bf00      	nop

00006320 <String::reserve(unsigned int)>:
	len = 0;
	flags = 0;
}

unsigned char String::reserve(unsigned int size)
{
    6320:	b538      	push	{r3, r4, r5, lr}
	if (capacity >= size) return 1;
    6322:	6843      	ldr	r3, [r0, #4]
    6324:	428b      	cmp	r3, r1
    6326:	d301      	bcc.n	632c <String::reserve(unsigned int)+0xc>
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    6328:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
    632a:	bd38      	pop	{r3, r4, r5, pc}
    632c:	460d      	mov	r5, r1
    632e:	4604      	mov	r4, r0

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
    6330:	3101      	adds	r1, #1
    6332:	6800      	ldr	r0, [r0, #0]
    6334:	f002 fbbc 	bl	8ab0 <realloc>
	if (newbuffer) {
    6338:	2800      	cmp	r0, #0
    633a:	d0f6      	beq.n	632a <String::reserve(unsigned int)+0xa>

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    633c:	68a3      	ldr	r3, [r4, #8]
unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
	if (newbuffer) {
		buffer = newbuffer;
		capacity = maxStrLen;
    633e:	e884 0021 	stmia.w	r4, {r0, r5}

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    6342:	2b00      	cmp	r3, #0
    6344:	d1f0      	bne.n	6328 <String::reserve(unsigned int)+0x8>
    6346:	7003      	strb	r3, [r0, #0]
    6348:	e7ee      	b.n	6328 <String::reserve(unsigned int)+0x8>
    634a:	bf00      	nop

0000634c <String::copy(char const*, unsigned int)>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
    634c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    634e:	4604      	mov	r4, r0
	if (length == 0) {
    6350:	4615      	mov	r5, r2
    6352:	b932      	cbnz	r2, 6362 <String::copy(char const*, unsigned int)+0x16>
		if (buffer) buffer[0] = 0;
    6354:	6803      	ldr	r3, [r0, #0]
    6356:	b103      	cbz	r3, 635a <String::copy(char const*, unsigned int)+0xe>
    6358:	701a      	strb	r2, [r3, #0]
		len = 0;
    635a:	2300      	movs	r3, #0
    635c:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    635e:	4620      	mov	r0, r4
    6360:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6362:	460e      	mov	r6, r1
	if (length == 0) {
		if (buffer) buffer[0] = 0;
		len = 0;
		return *this;
	}
	if (!reserve(length)) {
    6364:	4611      	mov	r1, r2
    6366:	f7ff ffdb 	bl	6320 <String::reserve(unsigned int)>
    636a:	4607      	mov	r7, r0
    636c:	b948      	cbnz	r0, 6382 <String::copy(char const*, unsigned int)+0x36>
		if (buffer) {
    636e:	6820      	ldr	r0, [r4, #0]
    6370:	b110      	cbz	r0, 6378 <String::copy(char const*, unsigned int)+0x2c>
			free(buffer);
    6372:	f002 f827 	bl	83c4 <free>
			buffer = NULL;
    6376:	6027      	str	r7, [r4, #0]
		}
		len = capacity = 0;
    6378:	2300      	movs	r3, #0
    637a:	6063      	str	r3, [r4, #4]
    637c:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    637e:	4620      	mov	r0, r4
    6380:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			buffer = NULL;
		}
		len = capacity = 0;
		return *this;
	}
	len = length;
    6382:	60a5      	str	r5, [r4, #8]
	strcpy(buffer, cstr);
    6384:	4631      	mov	r1, r6
    6386:	6820      	ldr	r0, [r4, #0]
    6388:	f002 ff18 	bl	91bc <strcpy>
	return *this;
    638c:	e7e7      	b.n	635e <String::copy(char const*, unsigned int)+0x12>
    638e:	bf00      	nop

00006390 <String::String(char const*)>:

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    6390:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    6392:	2300      	movs	r3, #0

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    6394:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    6396:	6003      	str	r3, [r0, #0]
	capacity = 0;
    6398:	6043      	str	r3, [r0, #4]
	len = 0;
    639a:	6083      	str	r3, [r0, #8]
	flags = 0;
    639c:	7303      	strb	r3, [r0, #12]
/*********************************************/

String::String(const char *cstr)
{
	init();
	if (cstr) copy(cstr, strlen(cstr));
    639e:	b141      	cbz	r1, 63b2 <String::String(char const*)+0x22>
    63a0:	4608      	mov	r0, r1
    63a2:	460d      	mov	r5, r1
    63a4:	f002 ff6c 	bl	9280 <strlen>
    63a8:	4629      	mov	r1, r5
    63aa:	4602      	mov	r2, r0
    63ac:	4620      	mov	r0, r4
    63ae:	f7ff ffcd 	bl	634c <String::copy(char const*, unsigned int)>
}
    63b2:	4620      	mov	r0, r4
    63b4:	bd38      	pop	{r3, r4, r5, pc}
    63b6:	bf00      	nop

000063b8 <String::equals(char const*) const>:
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    63b8:	6882      	ldr	r2, [r0, #8]
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
    63ba:	b508      	push	{r3, lr}
    63bc:	460b      	mov	r3, r1
	if (len == 0) return (cstr == NULL || *cstr == 0);
    63be:	b92a      	cbnz	r2, 63cc <String::equals(char const*) const+0x14>
    63c0:	b171      	cbz	r1, 63e0 <String::equals(char const*) const+0x28>
	if (cstr == NULL) return buffer[0] == 0;
    63c2:	7818      	ldrb	r0, [r3, #0]
    63c4:	fab0 f080 	clz	r0, r0
    63c8:	0940      	lsrs	r0, r0, #5
    63ca:	bd08      	pop	{r3, pc}
    63cc:	b131      	cbz	r1, 63dc <String::equals(char const*) const+0x24>
	return strcmp(buffer, cstr) == 0;
    63ce:	6800      	ldr	r0, [r0, #0]
    63d0:	f002 fd8a 	bl	8ee8 <strcmp>
    63d4:	fab0 f080 	clz	r0, r0
    63d8:	0940      	lsrs	r0, r0, #5
}
    63da:	bd08      	pop	{r3, pc}
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
	if (cstr == NULL) return buffer[0] == 0;
    63dc:	6803      	ldr	r3, [r0, #0]
    63de:	e7f0      	b.n	63c2 <String::equals(char const*) const+0xa>
    63e0:	2001      	movs	r0, #1
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    63e2:	bd08      	pop	{r3, pc}

000063e4 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    63e4:	b508      	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    63e6:	f7fc f88b 	bl	2500 <setup>
	while (1) {
		loop();
    63ea:	f7fc f931 	bl	2650 <loop>
		yield();
    63ee:	f000 f80f 	bl	6410 <yield>
    63f2:	e7fa      	b.n	63ea <main+0x6>

000063f4 <usb_serial_class::clear()>:
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    63f4:	f7ff be40 	b.w	6078 <usb_serial_flush_input>

000063f8 <usb_serial_class::peek()>:
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    63f8:	f7ff be18 	b.w	602c <usb_serial_peekchar>

000063fc <usb_serial_class::available()>:
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    63fc:	f7ff be2e 	b.w	605c <usb_serial_available>

00006400 <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    6400:	f7ff bf0a 	b.w	6218 <usb_serial_flush_output>

00006404 <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    6404:	f7ff bee4 	b.w	61d0 <usb_serial_write_buffer_free>

00006408 <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    6408:	4608      	mov	r0, r1
    640a:	f7ff bed5 	b.w	61b8 <usb_serial_putchar>
    640e:	bf00      	nop

00006410 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    6410:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    6414:	4e31      	ldr	r6, [pc, #196]	; (64dc <yield+0xcc>)
    6416:	7833      	ldrb	r3, [r6, #0]
    6418:	b193      	cbz	r3, 6440 <yield+0x30>
	if (running) return; // TODO: does this need to be atomic?
    641a:	4f31      	ldr	r7, [pc, #196]	; (64e0 <yield+0xd0>)
    641c:	783a      	ldrb	r2, [r7, #0]
    641e:	b97a      	cbnz	r2, 6440 <yield+0x30>
	running = 1;
    6420:	2201      	movs	r2, #1


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    6422:	07d9      	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    6424:	703a      	strb	r2, [r7, #0]


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    6426:	d436      	bmi.n	6496 <yield+0x86>
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIALUSB2) {
		if (SerialUSB2.available()) serialEventUSB2();
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    6428:	079a      	lsls	r2, r3, #30
    642a:	d419      	bmi.n	6460 <yield+0x50>
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    642c:	2200      	movs	r2, #0
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    642e:	075b      	lsls	r3, r3, #29
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    6430:	703a      	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    6432:	d505      	bpl.n	6440 <yield+0x30>
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;  
    6434:	4b2b      	ldr	r3, [pc, #172]	; (64e4 <yield+0xd4>)
    6436:	681a      	ldr	r2, [r3, #0]
    6438:	b112      	cbz	r2, 6440 <yield+0x30>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    643a:	f3ef 8205 	mrs	r2, IPSR
		if (ipsr != 0) return;
    643e:	b10a      	cbz	r2, 6444 <yield+0x34>
    6440:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    6444:	f3ef 8110 	mrs	r1, PRIMASK
		__disable_irq();
    6448:	b672      	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    644a:	6818      	ldr	r0, [r3, #0]
		if (first == nullptr) {
    644c:	b118      	cbz	r0, 6456 <yield+0x46>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    644e:	4c26      	ldr	r4, [pc, #152]	; (64e8 <yield+0xd8>)
    6450:	7822      	ldrb	r2, [r4, #0]
    6452:	2a00      	cmp	r2, #0
    6454:	d02e      	beq.n	64b4 <yield+0xa4>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    6456:	2900      	cmp	r1, #0
    6458:	d1f2      	bne.n	6440 <yield+0x30>
    645a:	b662      	cpsie	i
    645c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    6460:	f8df 8090 	ldr.w	r8, [pc, #144]	; 64f4 <yield+0xe4>
    6464:	f898 2000 	ldrb.w	r2, [r8]
    6468:	2a00      	cmp	r2, #0
    646a:	d0df      	beq.n	642c <yield+0x1c>
    646c:	f8df 9088 	ldr.w	r9, [pc, #136]	; 64f8 <yield+0xe8>
    6470:	2400      	movs	r4, #0
    6472:	e005      	b.n	6480 <yield+0x70>
    6474:	3401      	adds	r4, #1
    6476:	f898 3000 	ldrb.w	r3, [r8]
    647a:	b2e4      	uxtb	r4, r4
    647c:	42a3      	cmp	r3, r4
    647e:	d912      	bls.n	64a6 <yield+0x96>
			s_serials_with_serial_events[i]->doYieldCode();
    6480:	f859 5024 	ldr.w	r5, [r9, r4, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
	static uint8_t 			s_count_serials_with_serial_events;
	void 		(* const _serialEvent)(); 
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*_serialEvent)();
    6484:	682b      	ldr	r3, [r5, #0]
    6486:	4628      	mov	r0, r5
    6488:	691b      	ldr	r3, [r3, #16]
    648a:	4798      	blx	r3
    648c:	2800      	cmp	r0, #0
    648e:	d0f1      	beq.n	6474 <yield+0x64>
    6490:	692b      	ldr	r3, [r5, #16]
    6492:	4798      	blx	r3
    6494:	e7ee      	b.n	6474 <yield+0x64>
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    6496:	f7ff fde1 	bl	605c <usb_serial_available>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    649a:	b9c8      	cbnz	r0, 64d0 <yield+0xc0>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    649c:	4b13      	ldr	r3, [pc, #76]	; (64ec <yield+0xdc>)
    649e:	781b      	ldrb	r3, [r3, #0]
    64a0:	b91b      	cbnz	r3, 64aa <yield+0x9a>
    64a2:	7833      	ldrb	r3, [r6, #0]
    64a4:	e7c0      	b.n	6428 <yield+0x18>
    64a6:	7833      	ldrb	r3, [r6, #0]
    64a8:	e7c0      	b.n	642c <yield+0x1c>
    64aa:	7833      	ldrb	r3, [r6, #0]
    64ac:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    64b0:	7033      	strb	r3, [r6, #0]
    64b2:	e7b9      	b.n	6428 <yield+0x18>
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
		firstYield = first->_next;
    64b4:	6945      	ldr	r5, [r0, #20]
    64b6:	601d      	str	r5, [r3, #0]
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    64b8:	2301      	movs	r3, #1
    64ba:	7023      	strb	r3, [r4, #0]
		firstYield = first->_next;
		if (firstYield) {
    64bc:	b15d      	cbz	r5, 64d6 <yield+0xc6>
			firstYield->_prev = nullptr;
    64be:	61aa      	str	r2, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    64c0:	b901      	cbnz	r1, 64c4 <yield+0xb4>
    64c2:	b662      	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    64c4:	2500      	movs	r5, #0
    64c6:	7745      	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    64c8:	6883      	ldr	r3, [r0, #8]
    64ca:	4798      	blx	r3
		runningFromYield = false;
    64cc:	7025      	strb	r5, [r4, #0]
    64ce:	e7b7      	b.n	6440 <yield+0x30>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    64d0:	f000 f928 	bl	6724 <serialEvent()>
    64d4:	e7e2      	b.n	649c <yield+0x8c>
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
    64d6:	4b06      	ldr	r3, [pc, #24]	; (64f0 <yield+0xe0>)
    64d8:	601d      	str	r5, [r3, #0]
    64da:	e7f1      	b.n	64c0 <yield+0xb0>
    64dc:	1fff0b38 	.word	0x1fff0b38
    64e0:	1fff2cb5 	.word	0x1fff2cb5
    64e4:	1fff2cb0 	.word	0x1fff2cb0
    64e8:	1fff2cb4 	.word	0x1fff2cb4
    64ec:	1fff0bde 	.word	0x1fff0bde
    64f0:	1fff2cac 	.word	0x1fff2cac
    64f4:	1fff2cd0 	.word	0x1fff2cd0
    64f8:	1fff2cb8 	.word	0x1fff2cb8

000064fc <analog_init>:
#else
#error "F_BUS must be 128, 120, 108, 96, 90, 80, 72, 64, 60, 56, 54, 48, 40, 36, 24, 4 or 2 MHz"
#endif

void analog_init(void)
{
    64fc:	b430      	push	{r4, r5}
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    64fe:	4829      	ldr	r0, [pc, #164]	; (65a4 <analog_init+0xa8>)
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    6500:	4a29      	ldr	r2, [pc, #164]	; (65a8 <analog_init+0xac>)
	#endif

	if (analog_config_bits == 8) {
    6502:	4b2a      	ldr	r3, [pc, #168]	; (65ac <analog_init+0xb0>)
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    6504:	4d2a      	ldr	r5, [pc, #168]	; (65b0 <analog_init+0xb4>)
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    6506:	2460      	movs	r4, #96	; 0x60
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    6508:	21e1      	movs	r1, #225	; 0xe1
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    650a:	7004      	strb	r4, [r0, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    650c:	7011      	strb	r1, [r2, #0]
	#endif

	if (analog_config_bits == 8) {
    650e:	781b      	ldrb	r3, [r3, #0]
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    6510:	4c28      	ldr	r4, [pc, #160]	; (65b4 <analog_init+0xb8>)
	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
    6512:	2b08      	cmp	r3, #8
    6514:	d030      	beq.n	6578 <analog_init+0x7c>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    6516:	2b0a      	cmp	r3, #10
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    6518:	4827      	ldr	r0, [pc, #156]	; (65b8 <analog_init+0xbc>)
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    651a:	4928      	ldr	r1, [pc, #160]	; (65bc <analog_init+0xc0>)
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    651c:	d037      	beq.n	658e <analog_init+0x92>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    651e:	2b0c      	cmp	r3, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    6520:	bf0c      	ite	eq
    6522:	2235      	moveq	r2, #53	; 0x35
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    6524:	225d      	movne	r2, #93	; 0x5d
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    6526:	2312      	movs	r3, #18
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    6528:	602a      	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    652a:	6023      	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    652c:	6002      	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    652e:	600b      	str	r3, [r1, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    6530:	4b23      	ldr	r3, [pc, #140]	; (65c0 <analog_init+0xc4>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    6532:	4924      	ldr	r1, [pc, #144]	; (65c4 <analog_init+0xc8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    6534:	781b      	ldrb	r3, [r3, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    6536:	4a24      	ldr	r2, [pc, #144]	; (65c8 <analog_init+0xcc>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    6538:	b1bb      	cbz	r3, 656a <analog_init+0x6e>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    653a:	2301      	movs	r3, #1
    653c:	600b      	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    653e:	6013      	str	r3, [r2, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    6540:	4b22      	ldr	r3, [pc, #136]	; (65cc <analog_init+0xd0>)
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    6542:	4923      	ldr	r1, [pc, #140]	; (65d0 <analog_init+0xd4>)
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    6544:	781b      	ldrb	r3, [r3, #0]
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    6546:	4a23      	ldr	r2, [pc, #140]	; (65d4 <analog_init+0xd8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
    6548:	2b01      	cmp	r3, #1
    654a:	d926      	bls.n	659a <analog_init+0x9e>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
    654c:	2b04      	cmp	r3, #4
    654e:	d90f      	bls.n	6570 <analog_init+0x74>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
    6550:	2b08      	cmp	r3, #8
    6552:	d91e      	bls.n	6592 <analog_init+0x96>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#endif
	} else if (num <= 16) {
    6554:	2b10      	cmp	r3, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    6556:	bf94      	ite	ls
    6558:	2386      	movls	r3, #134	; 0x86
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    655a:	2387      	movhi	r3, #135	; 0x87
    655c:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    655e:	6013      	str	r3, [r2, #0]
		#endif
	}
	calibrating = 1;
    6560:	4b1d      	ldr	r3, [pc, #116]	; (65d8 <analog_init+0xdc>)
    6562:	2201      	movs	r2, #1
    6564:	701a      	strb	r2, [r3, #0]
}
    6566:	bc30      	pop	{r4, r5}
    6568:	4770      	bx	lr
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    656a:	600b      	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    656c:	6013      	str	r3, [r2, #0]
    656e:	e7e7      	b.n	6540 <analog_init+0x44>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    6570:	2384      	movs	r3, #132	; 0x84
    6572:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    6574:	6013      	str	r3, [r2, #0]
    6576:	e7f3      	b.n	6560 <analog_init+0x64>

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    6578:	f500 208e 	add.w	r0, r0, #290816	; 0x47000
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    657c:	490f      	ldr	r1, [pc, #60]	; (65bc <analog_init+0xc0>)

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    657e:	3008      	adds	r0, #8
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    6580:	2221      	movs	r2, #33	; 0x21
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    6582:	2313      	movs	r3, #19
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    6584:	602a      	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    6586:	6023      	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    6588:	6002      	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    658a:	600b      	str	r3, [r1, #0]
    658c:	e7d0      	b.n	6530 <analog_init+0x34>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    658e:	2239      	movs	r2, #57	; 0x39
    6590:	e7f7      	b.n	6582 <analog_init+0x86>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    6592:	2385      	movs	r3, #133	; 0x85
    6594:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    6596:	6013      	str	r3, [r2, #0]
    6598:	e7e2      	b.n	6560 <analog_init+0x64>
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    659a:	2380      	movs	r3, #128	; 0x80
    659c:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    659e:	6013      	str	r3, [r2, #0]
    65a0:	e7de      	b.n	6560 <analog_init+0x64>
    65a2:	bf00      	nop
    65a4:	40074000 	.word	0x40074000
    65a8:	40074001 	.word	0x40074001
    65ac:	1fff0b39 	.word	0x1fff0b39
    65b0:	4003b008 	.word	0x4003b008
    65b4:	4003b00c 	.word	0x4003b00c
    65b8:	400bb008 	.word	0x400bb008
    65bc:	400bb00c 	.word	0x400bb00c
    65c0:	1fff2cb7 	.word	0x1fff2cb7
    65c4:	4003b020 	.word	0x4003b020
    65c8:	400bb020 	.word	0x400bb020
    65cc:	1fff0b3a 	.word	0x1fff0b3a
    65d0:	4003b024 	.word	0x4003b024
    65d4:	400bb024 	.word	0x400bb024
    65d8:	1fff2cb6 	.word	0x1fff2cb6

000065dc <analogWriteDAC0>:
typedef int16_t __attribute__((__may_alias__)) aliased_int16_t;

void analogWriteDAC0(int val)
{
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_DAC0;
    65dc:	4a0a      	ldr	r2, [pc, #40]	; (6608 <analogWriteDAC0+0x2c>)
	if (analog_reference_internal) {
    65de:	490b      	ldr	r1, [pc, #44]	; (660c <analogWriteDAC0+0x30>)
typedef int16_t __attribute__((__may_alias__)) aliased_int16_t;

void analogWriteDAC0(int val)
{
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_DAC0;
    65e0:	6813      	ldr	r3, [r2, #0]
    65e2:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    65e6:	6013      	str	r3, [r2, #0]
	if (analog_reference_internal) {
    65e8:	780b      	ldrb	r3, [r1, #0]
    65ea:	b943      	cbnz	r3, 65fe <analogWriteDAC0+0x22>
		DAC0_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC0_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
    65ec:	4b08      	ldr	r3, [pc, #32]	; (6610 <analogWriteDAC0+0x34>)
    65ee:	22c0      	movs	r2, #192	; 0xc0
    65f0:	701a      	strb	r2, [r3, #0]
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095

	*(volatile aliased_int16_t *)&(DAC0_DAT0L) = val;
    65f2:	4b08      	ldr	r3, [pc, #32]	; (6614 <analogWriteDAC0+0x38>)
	if (analog_reference_internal) {
		DAC0_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC0_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095
    65f4:	f380 000c 	usat	r0, #12, r0

	*(volatile aliased_int16_t *)&(DAC0_DAT0L) = val;
    65f8:	b200      	sxth	r0, r0
    65fa:	8018      	strh	r0, [r3, #0]
    65fc:	4770      	bx	lr
void analogWriteDAC0(int val)
{
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_DAC0;
	if (analog_reference_internal) {
		DAC0_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
    65fe:	4b04      	ldr	r3, [pc, #16]	; (6610 <analogWriteDAC0+0x34>)
    6600:	2280      	movs	r2, #128	; 0x80
    6602:	701a      	strb	r2, [r3, #0]
    6604:	e7f5      	b.n	65f2 <analogWriteDAC0+0x16>
    6606:	bf00      	nop
    6608:	4004802c 	.word	0x4004802c
    660c:	1fff2cb7 	.word	0x1fff2cb7
    6610:	400cc021 	.word	0x400cc021
    6614:	400cc000 	.word	0x400cc000

00006618 <analogWriteDAC1>:


#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
void analogWriteDAC1(int val)
{
	SIM_SCGC2 |= SIM_SCGC2_DAC1;
    6618:	4a0a      	ldr	r2, [pc, #40]	; (6644 <analogWriteDAC1+0x2c>)
	if (analog_reference_internal) {
    661a:	490b      	ldr	r1, [pc, #44]	; (6648 <analogWriteDAC1+0x30>)


#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
void analogWriteDAC1(int val)
{
	SIM_SCGC2 |= SIM_SCGC2_DAC1;
    661c:	6813      	ldr	r3, [r2, #0]
    661e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    6622:	6013      	str	r3, [r2, #0]
	if (analog_reference_internal) {
    6624:	780b      	ldrb	r3, [r1, #0]
    6626:	b943      	cbnz	r3, 663a <analogWriteDAC1+0x22>
		DAC1_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC1_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
    6628:	4b08      	ldr	r3, [pc, #32]	; (664c <analogWriteDAC1+0x34>)
    662a:	22c0      	movs	r2, #192	; 0xc0
    662c:	701a      	strb	r2, [r3, #0]
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095

	*(volatile aliased_int16_t *)&(DAC1_DAT0L) = val;
    662e:	4b08      	ldr	r3, [pc, #32]	; (6650 <analogWriteDAC1+0x38>)
	if (analog_reference_internal) {
		DAC1_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC1_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095
    6630:	f380 000c 	usat	r0, #12, r0

	*(volatile aliased_int16_t *)&(DAC1_DAT0L) = val;
    6634:	b200      	sxth	r0, r0
    6636:	8018      	strh	r0, [r3, #0]
    6638:	4770      	bx	lr
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
void analogWriteDAC1(int val)
{
	SIM_SCGC2 |= SIM_SCGC2_DAC1;
	if (analog_reference_internal) {
		DAC1_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
    663a:	4b04      	ldr	r3, [pc, #16]	; (664c <analogWriteDAC1+0x34>)
    663c:	2280      	movs	r2, #128	; 0x80
    663e:	701a      	strb	r2, [r3, #0]
    6640:	e7f5      	b.n	662e <analogWriteDAC1+0x16>
    6642:	bf00      	nop
    6644:	4004802c 	.word	0x4004802c
    6648:	1fff2cb7 	.word	0x1fff2cb7
    664c:	400cd021 	.word	0x400cd021
    6650:	400cd000 	.word	0x400cd000

00006654 <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    6654:	b4f0      	push	{r4, r5, r6, r7}
    6656:	1e4d      	subs	r5, r1, #1
    6658:	462e      	mov	r6, r5
	unsigned digit;
	int i=0, j;
    665a:	2400      	movs	r4, #0
    665c:	e000      	b.n	6660 <ultoa+0xc>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    665e:	3401      	adds	r4, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
    6660:	fbb0 f3f2 	udiv	r3, r0, r2
    6664:	fb02 0013 	mls	r0, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    6668:	2809      	cmp	r0, #9
    666a:	f100 0730 	add.w	r7, r0, #48	; 0x30
    666e:	bf8a      	itet	hi
    6670:	3037      	addhi	r0, #55	; 0x37
    6672:	b2f8      	uxtbls	r0, r7
    6674:	b2c0      	uxtbhi	r0, r0
    6676:	f806 0f01 	strb.w	r0, [r6, #1]!
		val /= radix;
		if (val == 0) break;
    667a:	4618      	mov	r0, r3
    667c:	2b00      	cmp	r3, #0
    667e:	d1ee      	bne.n	665e <ultoa+0xa>
		i++;
	}
	buf[i + 1] = 0;
    6680:	190a      	adds	r2, r1, r4
    6682:	7053      	strb	r3, [r2, #1]
	for (j=0; j < i; j++, i--) {
    6684:	b14c      	cbz	r4, 669a <ultoa+0x46>
		t = buf[j];
		buf[j] = buf[i];
    6686:	7810      	ldrb	r0, [r2, #0]
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
		t = buf[j];
    6688:	f815 6f01 	ldrb.w	r6, [r5, #1]!
		buf[j] = buf[i];
    668c:	7028      	strb	r0, [r5, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    668e:	3301      	adds	r3, #1
    6690:	1ae0      	subs	r0, r4, r3
    6692:	4283      	cmp	r3, r0
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
    6694:	f802 6901 	strb.w	r6, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    6698:	dbf5      	blt.n	6686 <ultoa+0x32>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    669a:	4608      	mov	r0, r1
    669c:	bcf0      	pop	{r4, r5, r6, r7}
    669e:	4770      	bx	lr

000066a0 <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    66a0:	b510      	push	{r4, lr}
    66a2:	b084      	sub	sp, #16
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    66a4:	b672      	cpsid	i
	FTFL_FCCOB1 = 15;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
    66a6:	f7fe fb05 	bl	4cb4 <kinetis_hsrun_disable>
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    66aa:	4a18      	ldr	r2, [pc, #96]	; (670c <usb_init_serialnumber+0x6c>)
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    66ac:	4b18      	ldr	r3, [pc, #96]	; (6710 <usb_init_serialnumber+0x70>)
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    66ae:	4919      	ldr	r1, [pc, #100]	; (6714 <usb_init_serialnumber+0x74>)
    66b0:	6011      	str	r1, [r2, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    66b2:	2270      	movs	r2, #112	; 0x70
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    66b4:	2180      	movs	r1, #128	; 0x80
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    66b6:	701a      	strb	r2, [r3, #0]
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    66b8:	461a      	mov	r2, r3
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    66ba:	7019      	strb	r1, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    66bc:	7813      	ldrb	r3, [r2, #0]
    66be:	061b      	lsls	r3, r3, #24
    66c0:	d5fc      	bpl.n	66bc <usb_init_serialnumber+0x1c>
	num = *(uint32_t *)&FTFL_FCCOBB;
    66c2:	4b15      	ldr	r3, [pc, #84]	; (6718 <usb_init_serialnumber+0x78>)
    66c4:	681c      	ldr	r4, [r3, #0]
	kinetis_hsrun_enable();
    66c6:	f7fe fb0f 	bl	4ce8 <kinetis_hsrun_enable>
#endif
	__enable_irq();
    66ca:	b662      	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    66cc:	4b13      	ldr	r3, [pc, #76]	; (671c <usb_init_serialnumber+0x7c>)
    66ce:	429c      	cmp	r4, r3
    66d0:	bf9c      	itt	ls
    66d2:	eb04 0484 	addls.w	r4, r4, r4, lsl #2
    66d6:	0064      	lslls	r4, r4, #1
	ultoa(num, buf, 10);
    66d8:	4620      	mov	r0, r4
    66da:	4c11      	ldr	r4, [pc, #68]	; (6720 <usb_init_serialnumber+0x80>)
    66dc:	a901      	add	r1, sp, #4
    66de:	220a      	movs	r2, #10
    66e0:	f7ff ffb8 	bl	6654 <ultoa>
    66e4:	a901      	add	r1, sp, #4
    66e6:	4620      	mov	r0, r4
	for (i=0; i<10; i++) {
    66e8:	2300      	movs	r3, #0
		char c = buf[i];
    66ea:	f811 2b01 	ldrb.w	r2, [r1], #1
    66ee:	3301      	adds	r3, #1
		if (!c) break;
    66f0:	b13a      	cbz	r2, 6702 <usb_init_serialnumber+0x62>
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    66f2:	2b0a      	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    66f4:	f820 2f02 	strh.w	r2, [r0, #2]!
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    66f8:	d1f7      	bne.n	66ea <usb_init_serialnumber+0x4a>
    66fa:	2316      	movs	r3, #22
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    66fc:	7023      	strb	r3, [r4, #0]
}
    66fe:	b004      	add	sp, #16
    6700:	bd10      	pop	{r4, pc}
    6702:	005b      	lsls	r3, r3, #1
    6704:	b2db      	uxtb	r3, r3
	for (i=0; i<10; i++) {
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    6706:	7023      	strb	r3, [r4, #0]
}
    6708:	b004      	add	sp, #16
    670a:	bd10      	pop	{r4, pc}
    670c:	40020004 	.word	0x40020004
    6710:	40020000 	.word	0x40020000
    6714:	41070000 	.word	0x41070000
    6718:	4002000c 	.word	0x4002000c
    671c:	0098967f 	.word	0x0098967f
    6720:	1fff0bc8 	.word	0x1fff0bc8

00006724 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    6724:	4770      	bx	lr
    6726:	bf00      	nop

00006728 <pow>:
    6728:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    672c:	ed2d 8b02 	vpush	{d8}
    6730:	f8df a324 	ldr.w	sl, [pc, #804]	; 6a58 <pow+0x330>
    6734:	b08b      	sub	sp, #44	; 0x2c
    6736:	ec57 6b10 	vmov	r6, r7, d0
    673a:	ec55 4b11 	vmov	r4, r5, d1
    673e:	f000 f98f 	bl	6a60 <__ieee754_pow>
    6742:	f99a 8000 	ldrsb.w	r8, [sl]
    6746:	eeb0 8a40 	vmov.f32	s16, s0
    674a:	eef0 8a60 	vmov.f32	s17, s1
    674e:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
    6752:	d048      	beq.n	67e6 <pow+0xbe>
    6754:	4622      	mov	r2, r4
    6756:	462b      	mov	r3, r5
    6758:	4620      	mov	r0, r4
    675a:	4629      	mov	r1, r5
    675c:	f001 fd6e 	bl	823c <__aeabi_dcmpun>
    6760:	4683      	mov	fp, r0
    6762:	2800      	cmp	r0, #0
    6764:	d13f      	bne.n	67e6 <pow+0xbe>
    6766:	4632      	mov	r2, r6
    6768:	463b      	mov	r3, r7
    676a:	4630      	mov	r0, r6
    676c:	4639      	mov	r1, r7
    676e:	f001 fd65 	bl	823c <__aeabi_dcmpun>
    6772:	4681      	mov	r9, r0
    6774:	2800      	cmp	r0, #0
    6776:	f040 8090 	bne.w	689a <pow+0x172>
    677a:	4630      	mov	r0, r6
    677c:	4639      	mov	r1, r7
    677e:	2200      	movs	r2, #0
    6780:	2300      	movs	r3, #0
    6782:	f001 fd29 	bl	81d8 <__aeabi_dcmpeq>
    6786:	2800      	cmp	r0, #0
    6788:	d036      	beq.n	67f8 <pow+0xd0>
    678a:	2200      	movs	r2, #0
    678c:	2300      	movs	r3, #0
    678e:	4620      	mov	r0, r4
    6790:	4629      	mov	r1, r5
    6792:	f001 fd21 	bl	81d8 <__aeabi_dcmpeq>
    6796:	4683      	mov	fp, r0
    6798:	b1b8      	cbz	r0, 67ca <pow+0xa2>
    679a:	ed9f 7ba5 	vldr	d7, [pc, #660]	; 6a30 <pow+0x308>
    679e:	2201      	movs	r2, #1
    67a0:	4ba9      	ldr	r3, [pc, #676]	; (6a48 <pow+0x320>)
    67a2:	f8cd 9020 	str.w	r9, [sp, #32]
    67a6:	9200      	str	r2, [sp, #0]
    67a8:	e9cd 6702 	strd	r6, r7, [sp, #8]
    67ac:	e9cd 4504 	strd	r4, r5, [sp, #16]
    67b0:	ed8d 7b06 	vstr	d7, [sp, #24]
    67b4:	9301      	str	r3, [sp, #4]
    67b6:	f1b8 0f00 	cmp.w	r8, #0
    67ba:	d05b      	beq.n	6874 <pow+0x14c>
    67bc:	ed9f 0b9e 	vldr	d0, [pc, #632]	; 6a38 <pow+0x310>
    67c0:	b00b      	add	sp, #44	; 0x2c
    67c2:	ecbd 8b02 	vpop	{d8}
    67c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    67ca:	ec45 4b10 	vmov	d0, r4, r5
    67ce:	f000 ffa7 	bl	7720 <finite>
    67d2:	b140      	cbz	r0, 67e6 <pow+0xbe>
    67d4:	2200      	movs	r2, #0
    67d6:	2300      	movs	r3, #0
    67d8:	4620      	mov	r0, r4
    67da:	4629      	mov	r1, r5
    67dc:	f001 fd06 	bl	81ec <__aeabi_dcmplt>
    67e0:	2800      	cmp	r0, #0
    67e2:	f040 80c5 	bne.w	6970 <pow+0x248>
    67e6:	eeb0 0a48 	vmov.f32	s0, s16
    67ea:	eef0 0a68 	vmov.f32	s1, s17
    67ee:	b00b      	add	sp, #44	; 0x2c
    67f0:	ecbd 8b02 	vpop	{d8}
    67f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    67f8:	eeb0 0a48 	vmov.f32	s0, s16
    67fc:	eef0 0a68 	vmov.f32	s1, s17
    6800:	f000 ff8e 	bl	7720 <finite>
    6804:	4680      	mov	r8, r0
    6806:	2800      	cmp	r0, #0
    6808:	d061      	beq.n	68ce <pow+0x1a6>
    680a:	f04f 0800 	mov.w	r8, #0
    680e:	f04f 0900 	mov.w	r9, #0
    6812:	ec51 0b18 	vmov	r0, r1, d8
    6816:	4642      	mov	r2, r8
    6818:	464b      	mov	r3, r9
    681a:	f001 fcdd 	bl	81d8 <__aeabi_dcmpeq>
    681e:	2800      	cmp	r0, #0
    6820:	d0e1      	beq.n	67e6 <pow+0xbe>
    6822:	ec47 6b10 	vmov	d0, r6, r7
    6826:	f000 ff7b 	bl	7720 <finite>
    682a:	2800      	cmp	r0, #0
    682c:	d0db      	beq.n	67e6 <pow+0xbe>
    682e:	ec45 4b10 	vmov	d0, r4, r5
    6832:	f000 ff75 	bl	7720 <finite>
    6836:	2800      	cmp	r0, #0
    6838:	d0d5      	beq.n	67e6 <pow+0xbe>
    683a:	f99a 3000 	ldrsb.w	r3, [sl]
    683e:	4a82      	ldr	r2, [pc, #520]	; (6a48 <pow+0x320>)
    6840:	9201      	str	r2, [sp, #4]
    6842:	2104      	movs	r1, #4
    6844:	2200      	movs	r2, #0
    6846:	2b02      	cmp	r3, #2
    6848:	e9cd 6702 	strd	r6, r7, [sp, #8]
    684c:	e9cd 4504 	strd	r4, r5, [sp, #16]
    6850:	e9cd 8906 	strd	r8, r9, [sp, #24]
    6854:	9100      	str	r1, [sp, #0]
    6856:	9208      	str	r2, [sp, #32]
    6858:	d003      	beq.n	6862 <pow+0x13a>
    685a:	4668      	mov	r0, sp
    685c:	f000 ff68 	bl	7730 <matherr>
    6860:	b970      	cbnz	r0, 6880 <pow+0x158>
    6862:	f001 fd79 	bl	8358 <__errno>
    6866:	2322      	movs	r3, #34	; 0x22
    6868:	6003      	str	r3, [r0, #0]
    686a:	e009      	b.n	6880 <pow+0x158>
    686c:	ed9f 7b70 	vldr	d7, [pc, #448]	; 6a30 <pow+0x308>
    6870:	ed8d 7b06 	vstr	d7, [sp, #24]
    6874:	4668      	mov	r0, sp
    6876:	f000 ff5b 	bl	7730 <matherr>
    687a:	2800      	cmp	r0, #0
    687c:	f000 808e 	beq.w	699c <pow+0x274>
    6880:	9b08      	ldr	r3, [sp, #32]
    6882:	b11b      	cbz	r3, 688c <pow+0x164>
    6884:	f001 fd68 	bl	8358 <__errno>
    6888:	9b08      	ldr	r3, [sp, #32]
    688a:	6003      	str	r3, [r0, #0]
    688c:	ed9d 0b06 	vldr	d0, [sp, #24]
    6890:	b00b      	add	sp, #44	; 0x2c
    6892:	ecbd 8b02 	vpop	{d8}
    6896:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    689a:	2200      	movs	r2, #0
    689c:	2300      	movs	r3, #0
    689e:	4620      	mov	r0, r4
    68a0:	4629      	mov	r1, r5
    68a2:	f001 fc99 	bl	81d8 <__aeabi_dcmpeq>
    68a6:	2800      	cmp	r0, #0
    68a8:	d09d      	beq.n	67e6 <pow+0xbe>
    68aa:	ed9f 0b63 	vldr	d0, [pc, #396]	; 6a38 <pow+0x310>
    68ae:	4b66      	ldr	r3, [pc, #408]	; (6a48 <pow+0x320>)
    68b0:	f8cd b020 	str.w	fp, [sp, #32]
    68b4:	2201      	movs	r2, #1
    68b6:	f1b8 0f02 	cmp.w	r8, #2
    68ba:	e9cd 6702 	strd	r6, r7, [sp, #8]
    68be:	e9cd 4504 	strd	r4, r5, [sp, #16]
    68c2:	ed8d 0b06 	vstr	d0, [sp, #24]
    68c6:	e88d 000c 	stmia.w	sp, {r2, r3}
    68ca:	d1d3      	bne.n	6874 <pow+0x14c>
    68cc:	e78f      	b.n	67ee <pow+0xc6>
    68ce:	ec47 6b10 	vmov	d0, r6, r7
    68d2:	f000 ff25 	bl	7720 <finite>
    68d6:	2800      	cmp	r0, #0
    68d8:	d097      	beq.n	680a <pow+0xe2>
    68da:	ec45 4b10 	vmov	d0, r4, r5
    68de:	f000 ff1f 	bl	7720 <finite>
    68e2:	2800      	cmp	r0, #0
    68e4:	d091      	beq.n	680a <pow+0xe2>
    68e6:	ec53 2b18 	vmov	r2, r3, d8
    68ea:	ee18 0a10 	vmov	r0, s16
    68ee:	4619      	mov	r1, r3
    68f0:	f001 fca4 	bl	823c <__aeabi_dcmpun>
    68f4:	2800      	cmp	r0, #0
    68f6:	d17c      	bne.n	69f2 <pow+0x2ca>
    68f8:	2303      	movs	r3, #3
    68fa:	f99a 8000 	ldrsb.w	r8, [sl]
    68fe:	9300      	str	r3, [sp, #0]
    6900:	4b51      	ldr	r3, [pc, #324]	; (6a48 <pow+0x320>)
    6902:	9008      	str	r0, [sp, #32]
    6904:	e9cd 6702 	strd	r6, r7, [sp, #8]
    6908:	e9cd 4504 	strd	r4, r5, [sp, #16]
    690c:	9301      	str	r3, [sp, #4]
    690e:	f1b8 0f00 	cmp.w	r8, #0
    6912:	d148      	bne.n	69a6 <pow+0x27e>
    6914:	f8df 9144 	ldr.w	r9, [pc, #324]	; 6a5c <pow+0x334>
    6918:	f04f 4860 	mov.w	r8, #3758096384	; 0xe0000000
    691c:	2200      	movs	r2, #0
    691e:	2300      	movs	r3, #0
    6920:	4630      	mov	r0, r6
    6922:	4639      	mov	r1, r7
    6924:	e9cd 8906 	strd	r8, r9, [sp, #24]
    6928:	f001 fc60 	bl	81ec <__aeabi_dcmplt>
    692c:	2800      	cmp	r0, #0
    692e:	d094      	beq.n	685a <pow+0x132>
    6930:	2200      	movs	r2, #0
    6932:	4b46      	ldr	r3, [pc, #280]	; (6a4c <pow+0x324>)
    6934:	4620      	mov	r0, r4
    6936:	4629      	mov	r1, r5
    6938:	f001 f9e6 	bl	7d08 <__aeabi_dmul>
    693c:	4604      	mov	r4, r0
    693e:	460d      	mov	r5, r1
    6940:	ec45 4b10 	vmov	d0, r4, r5
    6944:	f000 ff00 	bl	7748 <rint>
    6948:	4620      	mov	r0, r4
    694a:	ec53 2b10 	vmov	r2, r3, d0
    694e:	4629      	mov	r1, r5
    6950:	f001 fc42 	bl	81d8 <__aeabi_dcmpeq>
    6954:	2800      	cmp	r0, #0
    6956:	d149      	bne.n	69ec <pow+0x2c4>
    6958:	4b3d      	ldr	r3, [pc, #244]	; (6a50 <pow+0x328>)
    695a:	f99a 8000 	ldrsb.w	r8, [sl]
    695e:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
    6962:	e9cd 2306 	strd	r2, r3, [sp, #24]
    6966:	f1b8 0f02 	cmp.w	r8, #2
    696a:	f47f af76 	bne.w	685a <pow+0x132>
    696e:	e778      	b.n	6862 <pow+0x13a>
    6970:	4a35      	ldr	r2, [pc, #212]	; (6a48 <pow+0x320>)
    6972:	f99a 3000 	ldrsb.w	r3, [sl]
    6976:	f8cd b020 	str.w	fp, [sp, #32]
    697a:	2101      	movs	r1, #1
    697c:	e9cd 6702 	strd	r6, r7, [sp, #8]
    6980:	e9cd 4504 	strd	r4, r5, [sp, #16]
    6984:	e88d 0006 	stmia.w	sp, {r1, r2}
    6988:	2b00      	cmp	r3, #0
    698a:	f43f af6f 	beq.w	686c <pow+0x144>
    698e:	4931      	ldr	r1, [pc, #196]	; (6a54 <pow+0x32c>)
    6990:	2000      	movs	r0, #0
    6992:	2b02      	cmp	r3, #2
    6994:	e9cd 0106 	strd	r0, r1, [sp, #24]
    6998:	f47f af6c 	bne.w	6874 <pow+0x14c>
    699c:	f001 fcdc 	bl	8358 <__errno>
    69a0:	2321      	movs	r3, #33	; 0x21
    69a2:	6003      	str	r3, [r0, #0]
    69a4:	e76c      	b.n	6880 <pow+0x158>
    69a6:	ed9f 7b26 	vldr	d7, [pc, #152]	; 6a40 <pow+0x318>
    69aa:	2200      	movs	r2, #0
    69ac:	2300      	movs	r3, #0
    69ae:	4630      	mov	r0, r6
    69b0:	4639      	mov	r1, r7
    69b2:	ed8d 7b06 	vstr	d7, [sp, #24]
    69b6:	f001 fc19 	bl	81ec <__aeabi_dcmplt>
    69ba:	2800      	cmp	r0, #0
    69bc:	d0d3      	beq.n	6966 <pow+0x23e>
    69be:	2200      	movs	r2, #0
    69c0:	4b22      	ldr	r3, [pc, #136]	; (6a4c <pow+0x324>)
    69c2:	4620      	mov	r0, r4
    69c4:	4629      	mov	r1, r5
    69c6:	f001 f99f 	bl	7d08 <__aeabi_dmul>
    69ca:	4604      	mov	r4, r0
    69cc:	460d      	mov	r5, r1
    69ce:	ec45 4b10 	vmov	d0, r4, r5
    69d2:	f000 feb9 	bl	7748 <rint>
    69d6:	4620      	mov	r0, r4
    69d8:	ec53 2b10 	vmov	r2, r3, d0
    69dc:	4629      	mov	r1, r5
    69de:	f001 fbfb 	bl	81d8 <__aeabi_dcmpeq>
    69e2:	b918      	cbnz	r0, 69ec <pow+0x2c4>
    69e4:	4b1b      	ldr	r3, [pc, #108]	; (6a54 <pow+0x32c>)
    69e6:	2200      	movs	r2, #0
    69e8:	e9cd 2306 	strd	r2, r3, [sp, #24]
    69ec:	f99a 8000 	ldrsb.w	r8, [sl]
    69f0:	e7b9      	b.n	6966 <pow+0x23e>
    69f2:	4b15      	ldr	r3, [pc, #84]	; (6a48 <pow+0x320>)
    69f4:	f99a 9000 	ldrsb.w	r9, [sl]
    69f8:	f8cd 8020 	str.w	r8, [sp, #32]
    69fc:	2201      	movs	r2, #1
    69fe:	e9cd 6702 	strd	r6, r7, [sp, #8]
    6a02:	e9cd 4504 	strd	r4, r5, [sp, #16]
    6a06:	e88d 000c 	stmia.w	sp, {r2, r3}
    6a0a:	f1b9 0f00 	cmp.w	r9, #0
    6a0e:	f43f af2d 	beq.w	686c <pow+0x144>
    6a12:	2200      	movs	r2, #0
    6a14:	2300      	movs	r3, #0
    6a16:	4610      	mov	r0, r2
    6a18:	4619      	mov	r1, r3
    6a1a:	f001 fa9f 	bl	7f5c <__aeabi_ddiv>
    6a1e:	f1b9 0f02 	cmp.w	r9, #2
    6a22:	e9cd 0106 	strd	r0, r1, [sp, #24]
    6a26:	d0b9      	beq.n	699c <pow+0x274>
    6a28:	e724      	b.n	6874 <pow+0x14c>
    6a2a:	bf00      	nop
    6a2c:	f3af 8000 	nop.w
	...
    6a3c:	3ff00000 	.word	0x3ff00000
    6a40:	00000000 	.word	0x00000000
    6a44:	7ff00000 	.word	0x7ff00000
    6a48:	00009e60 	.word	0x00009e60
    6a4c:	3fe00000 	.word	0x3fe00000
    6a50:	c7efffff 	.word	0xc7efffff
    6a54:	fff00000 	.word	0xfff00000
    6a58:	1fff0bdf 	.word	0x1fff0bdf
    6a5c:	47efffff 	.word	0x47efffff

00006a60 <__ieee754_pow>:
    6a60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6a64:	ec51 0b11 	vmov	r0, r1, d1
    6a68:	f021 4800 	bic.w	r8, r1, #2147483648	; 0x80000000
    6a6c:	ea58 0400 	orrs.w	r4, r8, r0
    6a70:	b093      	sub	sp, #76	; 0x4c
    6a72:	d03c      	beq.n	6aee <__ieee754_pow+0x8e>
    6a74:	ec53 2b10 	vmov	r2, r3, d0
    6a78:	4e6d      	ldr	r6, [pc, #436]	; (6c30 <__ieee754_pow+0x1d0>)
    6a7a:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
    6a7e:	42b4      	cmp	r4, r6
    6a80:	ee10 aa10 	vmov	sl, s0
    6a84:	461d      	mov	r5, r3
    6a86:	dc2b      	bgt.n	6ae0 <__ieee754_pow+0x80>
    6a88:	4689      	mov	r9, r1
    6a8a:	ee11 ea10 	vmov	lr, s2
    6a8e:	d026      	beq.n	6ade <__ieee754_pow+0x7e>
    6a90:	45b0      	cmp	r8, r6
    6a92:	dc25      	bgt.n	6ae0 <__ieee754_pow+0x80>
    6a94:	4e66      	ldr	r6, [pc, #408]	; (6c30 <__ieee754_pow+0x1d0>)
    6a96:	45b0      	cmp	r8, r6
    6a98:	d077      	beq.n	6b8a <__ieee754_pow+0x12a>
    6a9a:	2d00      	cmp	r5, #0
    6a9c:	4616      	mov	r6, r2
    6a9e:	461f      	mov	r7, r3
    6aa0:	e9cd 0100 	strd	r0, r1, [sp]
    6aa4:	db75      	blt.n	6b92 <__ieee754_pow+0x132>
    6aa6:	f04f 0b00 	mov.w	fp, #0
    6aaa:	f1be 0f00 	cmp.w	lr, #0
    6aae:	d12d      	bne.n	6b0c <__ieee754_pow+0xac>
    6ab0:	4b5f      	ldr	r3, [pc, #380]	; (6c30 <__ieee754_pow+0x1d0>)
    6ab2:	4598      	cmp	r8, r3
    6ab4:	f000 8089 	beq.w	6bca <__ieee754_pow+0x16a>
    6ab8:	4b5e      	ldr	r3, [pc, #376]	; (6c34 <__ieee754_pow+0x1d4>)
    6aba:	4598      	cmp	r8, r3
    6abc:	d05e      	beq.n	6b7c <__ieee754_pow+0x11c>
    6abe:	f1b9 4f80 	cmp.w	r9, #1073741824	; 0x40000000
    6ac2:	f000 83de 	beq.w	7282 <__ieee754_pow+0x822>
    6ac6:	4b5c      	ldr	r3, [pc, #368]	; (6c38 <__ieee754_pow+0x1d8>)
    6ac8:	4599      	cmp	r9, r3
    6aca:	d11f      	bne.n	6b0c <__ieee754_pow+0xac>
    6acc:	2d00      	cmp	r5, #0
    6ace:	db1d      	blt.n	6b0c <__ieee754_pow+0xac>
    6ad0:	ec47 6b10 	vmov	d0, r6, r7
    6ad4:	b013      	add	sp, #76	; 0x4c
    6ad6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6ada:	f000 bd49 	b.w	7570 <__ieee754_sqrt>
    6ade:	b15a      	cbz	r2, 6af8 <__ieee754_pow+0x98>
    6ae0:	f104 4440 	add.w	r4, r4, #3221225472	; 0xc0000000
    6ae4:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
    6ae8:	ea54 030a 	orrs.w	r3, r4, sl
    6aec:	d106      	bne.n	6afc <__ieee754_pow+0x9c>
    6aee:	ed9f 0b4a 	vldr	d0, [pc, #296]	; 6c18 <__ieee754_pow+0x1b8>
    6af2:	b013      	add	sp, #76	; 0x4c
    6af4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6af8:	45a0      	cmp	r8, r4
    6afa:	ddcb      	ble.n	6a94 <__ieee754_pow+0x34>
    6afc:	484f      	ldr	r0, [pc, #316]	; (6c3c <__ieee754_pow+0x1dc>)
    6afe:	b013      	add	sp, #76	; 0x4c
    6b00:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6b04:	f000 be18 	b.w	7738 <nan>
    6b08:	f04f 0b00 	mov.w	fp, #0
    6b0c:	ec47 6b10 	vmov	d0, r6, r7
    6b10:	f000 fdfe 	bl	7710 <fabs>
    6b14:	ec51 0b10 	vmov	r0, r1, d0
    6b18:	f1ba 0f00 	cmp.w	sl, #0
    6b1c:	d01e      	beq.n	6b5c <__ieee754_pow+0xfc>
    6b1e:	0fed      	lsrs	r5, r5, #31
    6b20:	f105 3aff 	add.w	sl, r5, #4294967295	; 0xffffffff
    6b24:	ea5b 030a 	orrs.w	r3, fp, sl
    6b28:	d063      	beq.n	6bf2 <__ieee754_pow+0x192>
    6b2a:	4b45      	ldr	r3, [pc, #276]	; (6c40 <__ieee754_pow+0x1e0>)
    6b2c:	4598      	cmp	r8, r3
    6b2e:	f340 808d 	ble.w	6c4c <__ieee754_pow+0x1ec>
    6b32:	f103 7304 	add.w	r3, r3, #34603008	; 0x2100000
    6b36:	4598      	cmp	r8, r3
    6b38:	f340 8438 	ble.w	73ac <__ieee754_pow+0x94c>
    6b3c:	4b41      	ldr	r3, [pc, #260]	; (6c44 <__ieee754_pow+0x1e4>)
    6b3e:	429c      	cmp	r4, r3
    6b40:	dd62      	ble.n	6c08 <__ieee754_pow+0x1a8>
    6b42:	f1b9 0f00 	cmp.w	r9, #0
    6b46:	dd62      	ble.n	6c0e <__ieee754_pow+0x1ae>
    6b48:	a335      	add	r3, pc, #212	; (adr r3, 6c20 <__ieee754_pow+0x1c0>)
    6b4a:	e9d3 2300 	ldrd	r2, r3, [r3]
    6b4e:	4610      	mov	r0, r2
    6b50:	4619      	mov	r1, r3
    6b52:	f001 f8d9 	bl	7d08 <__aeabi_dmul>
    6b56:	ec41 0b10 	vmov	d0, r0, r1
    6b5a:	e7ca      	b.n	6af2 <__ieee754_pow+0x92>
    6b5c:	b124      	cbz	r4, 6b68 <__ieee754_pow+0x108>
    6b5e:	4b35      	ldr	r3, [pc, #212]	; (6c34 <__ieee754_pow+0x1d4>)
    6b60:	f025 4240 	bic.w	r2, r5, #3221225472	; 0xc0000000
    6b64:	429a      	cmp	r2, r3
    6b66:	d1da      	bne.n	6b1e <__ieee754_pow+0xbe>
    6b68:	f1b9 0f00 	cmp.w	r9, #0
    6b6c:	f2c0 83cb 	blt.w	7306 <__ieee754_pow+0x8a6>
    6b70:	2d00      	cmp	r5, #0
    6b72:	f2c0 8374 	blt.w	725e <__ieee754_pow+0x7fe>
    6b76:	ec41 0b10 	vmov	d0, r0, r1
    6b7a:	e7ba      	b.n	6af2 <__ieee754_pow+0x92>
    6b7c:	f1b9 0f00 	cmp.w	r9, #0
    6b80:	f2c0 847a 	blt.w	7478 <__ieee754_pow+0xa18>
    6b84:	ec47 6b10 	vmov	d0, r6, r7
    6b88:	e7b3      	b.n	6af2 <__ieee754_pow+0x92>
    6b8a:	f1be 0f00 	cmp.w	lr, #0
    6b8e:	d084      	beq.n	6a9a <__ieee754_pow+0x3a>
    6b90:	e7a6      	b.n	6ae0 <__ieee754_pow+0x80>
    6b92:	4b2d      	ldr	r3, [pc, #180]	; (6c48 <__ieee754_pow+0x1e8>)
    6b94:	4598      	cmp	r8, r3
    6b96:	dc29      	bgt.n	6bec <__ieee754_pow+0x18c>
    6b98:	f1a3 7354 	sub.w	r3, r3, #55574528	; 0x3500000
    6b9c:	4598      	cmp	r8, r3
    6b9e:	dd82      	ble.n	6aa6 <__ieee754_pow+0x46>
    6ba0:	ea4f 5328 	mov.w	r3, r8, asr #20
    6ba4:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
    6ba8:	2b14      	cmp	r3, #20
    6baa:	f340 847f 	ble.w	74ac <__ieee754_pow+0xa4c>
    6bae:	f1c3 0334 	rsb	r3, r3, #52	; 0x34
    6bb2:	fa2e f203 	lsr.w	r2, lr, r3
    6bb6:	fa02 f303 	lsl.w	r3, r2, r3
    6bba:	459e      	cmp	lr, r3
    6bbc:	f47f af73 	bne.w	6aa6 <__ieee754_pow+0x46>
    6bc0:	f002 0201 	and.w	r2, r2, #1
    6bc4:	f1c2 0b02 	rsb	fp, r2, #2
    6bc8:	e76f      	b.n	6aaa <__ieee754_pow+0x4a>
    6bca:	f104 4340 	add.w	r3, r4, #3221225472	; 0xc0000000
    6bce:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
    6bd2:	ea53 030a 	orrs.w	r3, r3, sl
    6bd6:	d08a      	beq.n	6aee <__ieee754_pow+0x8e>
    6bd8:	4b1a      	ldr	r3, [pc, #104]	; (6c44 <__ieee754_pow+0x1e4>)
    6bda:	429c      	cmp	r4, r3
    6bdc:	f340 8385 	ble.w	72ea <__ieee754_pow+0x88a>
    6be0:	f1b9 0f00 	cmp.w	r9, #0
    6be4:	db13      	blt.n	6c0e <__ieee754_pow+0x1ae>
    6be6:	ed9d 0b00 	vldr	d0, [sp]
    6bea:	e782      	b.n	6af2 <__ieee754_pow+0x92>
    6bec:	f04f 0b02 	mov.w	fp, #2
    6bf0:	e75b      	b.n	6aaa <__ieee754_pow+0x4a>
    6bf2:	4632      	mov	r2, r6
    6bf4:	463b      	mov	r3, r7
    6bf6:	4610      	mov	r0, r2
    6bf8:	4619      	mov	r1, r3
    6bfa:	f000 fed1 	bl	79a0 <__aeabi_dsub>
    6bfe:	4602      	mov	r2, r0
    6c00:	460b      	mov	r3, r1
    6c02:	f001 f9ab 	bl	7f5c <__aeabi_ddiv>
    6c06:	e7b6      	b.n	6b76 <__ieee754_pow+0x116>
    6c08:	f1b9 0f00 	cmp.w	r9, #0
    6c0c:	db9c      	blt.n	6b48 <__ieee754_pow+0xe8>
    6c0e:	ed9f 0b06 	vldr	d0, [pc, #24]	; 6c28 <__ieee754_pow+0x1c8>
    6c12:	e76e      	b.n	6af2 <__ieee754_pow+0x92>
    6c14:	f3af 8000 	nop.w
    6c18:	00000000 	.word	0x00000000
    6c1c:	3ff00000 	.word	0x3ff00000
    6c20:	8800759c 	.word	0x8800759c
    6c24:	7e37e43c 	.word	0x7e37e43c
	...
    6c30:	7ff00000 	.word	0x7ff00000
    6c34:	3ff00000 	.word	0x3ff00000
    6c38:	3fe00000 	.word	0x3fe00000
    6c3c:	00009a54 	.word	0x00009a54
    6c40:	41e00000 	.word	0x41e00000
    6c44:	3fefffff 	.word	0x3fefffff
    6c48:	433fffff 	.word	0x433fffff
    6c4c:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    6c50:	f04f 0200 	mov.w	r2, #0
    6c54:	da05      	bge.n	6c62 <__ieee754_pow+0x202>
    6c56:	4bd6      	ldr	r3, [pc, #856]	; (6fb0 <__ieee754_pow+0x550>)
    6c58:	f001 f856 	bl	7d08 <__aeabi_dmul>
    6c5c:	f06f 0234 	mvn.w	r2, #52	; 0x34
    6c60:	460c      	mov	r4, r1
    6c62:	1523      	asrs	r3, r4, #20
    6c64:	4ed3      	ldr	r6, [pc, #844]	; (6fb4 <__ieee754_pow+0x554>)
    6c66:	f3c4 0413 	ubfx	r4, r4, #0, #20
    6c6a:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
    6c6e:	4413      	add	r3, r2
    6c70:	f044 557f 	orr.w	r5, r4, #1069547520	; 0x3fc00000
    6c74:	42b4      	cmp	r4, r6
    6c76:	461a      	mov	r2, r3
    6c78:	930d      	str	r3, [sp, #52]	; 0x34
    6c7a:	f445 1540 	orr.w	r5, r5, #3145728	; 0x300000
    6c7e:	f340 8349 	ble.w	7314 <__ieee754_pow+0x8b4>
    6c82:	4bcd      	ldr	r3, [pc, #820]	; (6fb8 <__ieee754_pow+0x558>)
    6c84:	429c      	cmp	r4, r3
    6c86:	f340 842d 	ble.w	74e4 <__ieee754_pow+0xa84>
    6c8a:	ed9f 7bb3 	vldr	d7, [pc, #716]	; 6f58 <__ieee754_pow+0x4f8>
    6c8e:	ed8d 7b08 	vstr	d7, [sp, #32]
    6c92:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
    6c96:	ed9f 7bb2 	vldr	d7, [pc, #712]	; 6f60 <__ieee754_pow+0x500>
    6c9a:	4613      	mov	r3, r2
    6c9c:	ed8d 7b06 	vstr	d7, [sp, #24]
    6ca0:	3301      	adds	r3, #1
    6ca2:	930d      	str	r3, [sp, #52]	; 0x34
    6ca4:	f5a5 1580 	sub.w	r5, r5, #1048576	; 0x100000
    6ca8:	f04f 0800 	mov.w	r8, #0
    6cac:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    6cb0:	4629      	mov	r1, r5
    6cb2:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
    6cb6:	f000 fe73 	bl	79a0 <__aeabi_dsub>
    6cba:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    6cbe:	4606      	mov	r6, r0
    6cc0:	460f      	mov	r7, r1
    6cc2:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    6cc6:	f000 fe6d 	bl	79a4 <__adddf3>
    6cca:	4602      	mov	r2, r0
    6ccc:	460b      	mov	r3, r1
    6cce:	2000      	movs	r0, #0
    6cd0:	49ba      	ldr	r1, [pc, #744]	; (6fbc <__ieee754_pow+0x55c>)
    6cd2:	f001 f943 	bl	7f5c <__aeabi_ddiv>
    6cd6:	4603      	mov	r3, r0
    6cd8:	460c      	mov	r4, r1
    6cda:	e9cd 3410 	strd	r3, r4, [sp, #64]	; 0x40
    6cde:	4602      	mov	r2, r0
    6ce0:	460b      	mov	r3, r1
    6ce2:	4630      	mov	r0, r6
    6ce4:	4639      	mov	r1, r7
    6ce6:	f001 f80f 	bl	7d08 <__aeabi_dmul>
    6cea:	106b      	asrs	r3, r5, #1
    6cec:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    6cf0:	f503 2300 	add.w	r3, r3, #524288	; 0x80000
    6cf4:	eb03 0508 	add.w	r5, r3, r8
    6cf8:	460a      	mov	r2, r1
    6cfa:	2300      	movs	r3, #0
    6cfc:	4601      	mov	r1, r0
    6cfe:	e9cd 1202 	strd	r1, r2, [sp, #8]
    6d02:	9302      	str	r3, [sp, #8]
    6d04:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
    6d08:	2400      	movs	r4, #0
    6d0a:	e9cd 1204 	strd	r1, r2, [sp, #16]
    6d0e:	462b      	mov	r3, r5
    6d10:	4622      	mov	r2, r4
    6d12:	4640      	mov	r0, r8
    6d14:	4649      	mov	r1, r9
    6d16:	f000 fff7 	bl	7d08 <__aeabi_dmul>
    6d1a:	4602      	mov	r2, r0
    6d1c:	460b      	mov	r3, r1
    6d1e:	4630      	mov	r0, r6
    6d20:	4639      	mov	r1, r7
    6d22:	f000 fe3d 	bl	79a0 <__aeabi_dsub>
    6d26:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    6d2a:	4606      	mov	r6, r0
    6d2c:	460f      	mov	r7, r1
    6d2e:	4620      	mov	r0, r4
    6d30:	4629      	mov	r1, r5
    6d32:	f000 fe35 	bl	79a0 <__aeabi_dsub>
    6d36:	4602      	mov	r2, r0
    6d38:	460b      	mov	r3, r1
    6d3a:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    6d3e:	f000 fe2f 	bl	79a0 <__aeabi_dsub>
    6d42:	4642      	mov	r2, r8
    6d44:	464b      	mov	r3, r9
    6d46:	f000 ffdf 	bl	7d08 <__aeabi_dmul>
    6d4a:	4602      	mov	r2, r0
    6d4c:	460b      	mov	r3, r1
    6d4e:	4630      	mov	r0, r6
    6d50:	4639      	mov	r1, r7
    6d52:	f000 fe25 	bl	79a0 <__aeabi_dsub>
    6d56:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
    6d5a:	f000 ffd5 	bl	7d08 <__aeabi_dmul>
    6d5e:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
    6d62:	e9cd 0106 	strd	r0, r1, [sp, #24]
    6d66:	4622      	mov	r2, r4
    6d68:	462b      	mov	r3, r5
    6d6a:	4620      	mov	r0, r4
    6d6c:	4629      	mov	r1, r5
    6d6e:	f000 ffcb 	bl	7d08 <__aeabi_dmul>
    6d72:	a37d      	add	r3, pc, #500	; (adr r3, 6f68 <__ieee754_pow+0x508>)
    6d74:	e9d3 2300 	ldrd	r2, r3, [r3]
    6d78:	4604      	mov	r4, r0
    6d7a:	460d      	mov	r5, r1
    6d7c:	f000 ffc4 	bl	7d08 <__aeabi_dmul>
    6d80:	a37b      	add	r3, pc, #492	; (adr r3, 6f70 <__ieee754_pow+0x510>)
    6d82:	e9d3 2300 	ldrd	r2, r3, [r3]
    6d86:	f000 fe0d 	bl	79a4 <__adddf3>
    6d8a:	4622      	mov	r2, r4
    6d8c:	462b      	mov	r3, r5
    6d8e:	f000 ffbb 	bl	7d08 <__aeabi_dmul>
    6d92:	a379      	add	r3, pc, #484	; (adr r3, 6f78 <__ieee754_pow+0x518>)
    6d94:	e9d3 2300 	ldrd	r2, r3, [r3]
    6d98:	f000 fe04 	bl	79a4 <__adddf3>
    6d9c:	4622      	mov	r2, r4
    6d9e:	462b      	mov	r3, r5
    6da0:	f000 ffb2 	bl	7d08 <__aeabi_dmul>
    6da4:	a376      	add	r3, pc, #472	; (adr r3, 6f80 <__ieee754_pow+0x520>)
    6da6:	e9d3 2300 	ldrd	r2, r3, [r3]
    6daa:	f000 fdfb 	bl	79a4 <__adddf3>
    6dae:	4622      	mov	r2, r4
    6db0:	462b      	mov	r3, r5
    6db2:	f000 ffa9 	bl	7d08 <__aeabi_dmul>
    6db6:	a374      	add	r3, pc, #464	; (adr r3, 6f88 <__ieee754_pow+0x528>)
    6db8:	e9d3 2300 	ldrd	r2, r3, [r3]
    6dbc:	f000 fdf2 	bl	79a4 <__adddf3>
    6dc0:	4622      	mov	r2, r4
    6dc2:	462b      	mov	r3, r5
    6dc4:	f000 ffa0 	bl	7d08 <__aeabi_dmul>
    6dc8:	a371      	add	r3, pc, #452	; (adr r3, 6f90 <__ieee754_pow+0x530>)
    6dca:	e9d3 2300 	ldrd	r2, r3, [r3]
    6dce:	f000 fde9 	bl	79a4 <__adddf3>
    6dd2:	4622      	mov	r2, r4
    6dd4:	4606      	mov	r6, r0
    6dd6:	460f      	mov	r7, r1
    6dd8:	462b      	mov	r3, r5
    6dda:	4620      	mov	r0, r4
    6ddc:	4629      	mov	r1, r5
    6dde:	f000 ff93 	bl	7d08 <__aeabi_dmul>
    6de2:	4602      	mov	r2, r0
    6de4:	460b      	mov	r3, r1
    6de6:	4630      	mov	r0, r6
    6de8:	4639      	mov	r1, r7
    6dea:	f000 ff8d 	bl	7d08 <__aeabi_dmul>
    6dee:	4642      	mov	r2, r8
    6df0:	4604      	mov	r4, r0
    6df2:	460d      	mov	r5, r1
    6df4:	464b      	mov	r3, r9
    6df6:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    6dfa:	f000 fdd3 	bl	79a4 <__adddf3>
    6dfe:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    6e02:	f000 ff81 	bl	7d08 <__aeabi_dmul>
    6e06:	4622      	mov	r2, r4
    6e08:	462b      	mov	r3, r5
    6e0a:	f000 fdcb 	bl	79a4 <__adddf3>
    6e0e:	4642      	mov	r2, r8
    6e10:	4606      	mov	r6, r0
    6e12:	460f      	mov	r7, r1
    6e14:	464b      	mov	r3, r9
    6e16:	4640      	mov	r0, r8
    6e18:	4649      	mov	r1, r9
    6e1a:	f000 ff75 	bl	7d08 <__aeabi_dmul>
    6e1e:	2200      	movs	r2, #0
    6e20:	4b67      	ldr	r3, [pc, #412]	; (6fc0 <__ieee754_pow+0x560>)
    6e22:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
    6e26:	f000 fdbd 	bl	79a4 <__adddf3>
    6e2a:	4632      	mov	r2, r6
    6e2c:	463b      	mov	r3, r7
    6e2e:	f000 fdb9 	bl	79a4 <__adddf3>
    6e32:	9802      	ldr	r0, [sp, #8]
    6e34:	460d      	mov	r5, r1
    6e36:	4604      	mov	r4, r0
    6e38:	4622      	mov	r2, r4
    6e3a:	462b      	mov	r3, r5
    6e3c:	4640      	mov	r0, r8
    6e3e:	4649      	mov	r1, r9
    6e40:	f000 ff62 	bl	7d08 <__aeabi_dmul>
    6e44:	2200      	movs	r2, #0
    6e46:	4680      	mov	r8, r0
    6e48:	4689      	mov	r9, r1
    6e4a:	4b5d      	ldr	r3, [pc, #372]	; (6fc0 <__ieee754_pow+0x560>)
    6e4c:	4620      	mov	r0, r4
    6e4e:	4629      	mov	r1, r5
    6e50:	f000 fda6 	bl	79a0 <__aeabi_dsub>
    6e54:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
    6e58:	f000 fda2 	bl	79a0 <__aeabi_dsub>
    6e5c:	4602      	mov	r2, r0
    6e5e:	460b      	mov	r3, r1
    6e60:	4630      	mov	r0, r6
    6e62:	4639      	mov	r1, r7
    6e64:	f000 fd9c 	bl	79a0 <__aeabi_dsub>
    6e68:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    6e6c:	f000 ff4c 	bl	7d08 <__aeabi_dmul>
    6e70:	4622      	mov	r2, r4
    6e72:	4606      	mov	r6, r0
    6e74:	460f      	mov	r7, r1
    6e76:	462b      	mov	r3, r5
    6e78:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    6e7c:	f000 ff44 	bl	7d08 <__aeabi_dmul>
    6e80:	4602      	mov	r2, r0
    6e82:	460b      	mov	r3, r1
    6e84:	4630      	mov	r0, r6
    6e86:	4639      	mov	r1, r7
    6e88:	f000 fd8c 	bl	79a4 <__adddf3>
    6e8c:	4606      	mov	r6, r0
    6e8e:	460f      	mov	r7, r1
    6e90:	4602      	mov	r2, r0
    6e92:	460b      	mov	r3, r1
    6e94:	4640      	mov	r0, r8
    6e96:	4649      	mov	r1, r9
    6e98:	e9cd 8904 	strd	r8, r9, [sp, #16]
    6e9c:	f000 fd82 	bl	79a4 <__adddf3>
    6ea0:	9802      	ldr	r0, [sp, #8]
    6ea2:	a33d      	add	r3, pc, #244	; (adr r3, 6f98 <__ieee754_pow+0x538>)
    6ea4:	e9d3 2300 	ldrd	r2, r3, [r3]
    6ea8:	4604      	mov	r4, r0
    6eaa:	460d      	mov	r5, r1
    6eac:	f000 ff2c 	bl	7d08 <__aeabi_dmul>
    6eb0:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    6eb4:	4680      	mov	r8, r0
    6eb6:	4689      	mov	r9, r1
    6eb8:	4620      	mov	r0, r4
    6eba:	4629      	mov	r1, r5
    6ebc:	f000 fd70 	bl	79a0 <__aeabi_dsub>
    6ec0:	4602      	mov	r2, r0
    6ec2:	460b      	mov	r3, r1
    6ec4:	4630      	mov	r0, r6
    6ec6:	4639      	mov	r1, r7
    6ec8:	f000 fd6a 	bl	79a0 <__aeabi_dsub>
    6ecc:	a334      	add	r3, pc, #208	; (adr r3, 6fa0 <__ieee754_pow+0x540>)
    6ece:	e9d3 2300 	ldrd	r2, r3, [r3]
    6ed2:	f000 ff19 	bl	7d08 <__aeabi_dmul>
    6ed6:	a334      	add	r3, pc, #208	; (adr r3, 6fa8 <__ieee754_pow+0x548>)
    6ed8:	e9d3 2300 	ldrd	r2, r3, [r3]
    6edc:	4606      	mov	r6, r0
    6ede:	460f      	mov	r7, r1
    6ee0:	4620      	mov	r0, r4
    6ee2:	4629      	mov	r1, r5
    6ee4:	f000 ff10 	bl	7d08 <__aeabi_dmul>
    6ee8:	4602      	mov	r2, r0
    6eea:	460b      	mov	r3, r1
    6eec:	4630      	mov	r0, r6
    6eee:	4639      	mov	r1, r7
    6ef0:	f000 fd58 	bl	79a4 <__adddf3>
    6ef4:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
    6ef8:	f000 fd54 	bl	79a4 <__adddf3>
    6efc:	4606      	mov	r6, r0
    6efe:	980d      	ldr	r0, [sp, #52]	; 0x34
    6f00:	460f      	mov	r7, r1
    6f02:	f000 fe9b 	bl	7c3c <__aeabi_i2d>
    6f06:	4632      	mov	r2, r6
    6f08:	4604      	mov	r4, r0
    6f0a:	460d      	mov	r5, r1
    6f0c:	463b      	mov	r3, r7
    6f0e:	4640      	mov	r0, r8
    6f10:	4649      	mov	r1, r9
    6f12:	f000 fd47 	bl	79a4 <__adddf3>
    6f16:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
    6f1a:	f000 fd43 	bl	79a4 <__adddf3>
    6f1e:	4622      	mov	r2, r4
    6f20:	462b      	mov	r3, r5
    6f22:	f000 fd3f 	bl	79a4 <__adddf3>
    6f26:	9802      	ldr	r0, [sp, #8]
    6f28:	4622      	mov	r2, r4
    6f2a:	462b      	mov	r3, r5
    6f2c:	e9cd 0102 	strd	r0, r1, [sp, #8]
    6f30:	f000 fd36 	bl	79a0 <__aeabi_dsub>
    6f34:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
    6f38:	f000 fd32 	bl	79a0 <__aeabi_dsub>
    6f3c:	4642      	mov	r2, r8
    6f3e:	464b      	mov	r3, r9
    6f40:	f000 fd2e 	bl	79a0 <__aeabi_dsub>
    6f44:	4602      	mov	r2, r0
    6f46:	460b      	mov	r3, r1
    6f48:	4630      	mov	r0, r6
    6f4a:	4639      	mov	r1, r7
    6f4c:	f000 fd28 	bl	79a0 <__aeabi_dsub>
    6f50:	4680      	mov	r8, r0
    6f52:	4689      	mov	r9, r1
    6f54:	e036      	b.n	6fc4 <__ieee754_pow+0x564>
    6f56:	bf00      	nop
	...
    6f64:	3ff00000 	.word	0x3ff00000
    6f68:	4a454eef 	.word	0x4a454eef
    6f6c:	3fca7e28 	.word	0x3fca7e28
    6f70:	93c9db65 	.word	0x93c9db65
    6f74:	3fcd864a 	.word	0x3fcd864a
    6f78:	a91d4101 	.word	0xa91d4101
    6f7c:	3fd17460 	.word	0x3fd17460
    6f80:	518f264d 	.word	0x518f264d
    6f84:	3fd55555 	.word	0x3fd55555
    6f88:	db6fabff 	.word	0xdb6fabff
    6f8c:	3fdb6db6 	.word	0x3fdb6db6
    6f90:	33333303 	.word	0x33333303
    6f94:	3fe33333 	.word	0x3fe33333
    6f98:	e0000000 	.word	0xe0000000
    6f9c:	3feec709 	.word	0x3feec709
    6fa0:	dc3a03fd 	.word	0xdc3a03fd
    6fa4:	3feec709 	.word	0x3feec709
    6fa8:	145b01f5 	.word	0x145b01f5
    6fac:	be3e2fe0 	.word	0xbe3e2fe0
    6fb0:	43400000 	.word	0x43400000
    6fb4:	0003988e 	.word	0x0003988e
    6fb8:	000bb679 	.word	0x000bb679
    6fbc:	3ff00000 	.word	0x3ff00000
    6fc0:	40080000 	.word	0x40080000
    6fc4:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
    6fc8:	ea53 030a 	orrs.w	r3, r3, sl
    6fcc:	f000 8188 	beq.w	72e0 <__ieee754_pow+0x880>
    6fd0:	ed9f 7bd7 	vldr	d7, [pc, #860]	; 7330 <__ieee754_pow+0x8d0>
    6fd4:	ed8d 7b06 	vstr	d7, [sp, #24]
    6fd8:	e9dd ab00 	ldrd	sl, fp, [sp]
    6fdc:	4653      	mov	r3, sl
    6fde:	465c      	mov	r4, fp
    6fe0:	e9cd 3400 	strd	r3, r4, [sp]
    6fe4:	2300      	movs	r3, #0
    6fe6:	9300      	str	r3, [sp, #0]
    6fe8:	e9dd 4500 	ldrd	r4, r5, [sp]
    6fec:	4650      	mov	r0, sl
    6fee:	4622      	mov	r2, r4
    6ff0:	462b      	mov	r3, r5
    6ff2:	4659      	mov	r1, fp
    6ff4:	f000 fcd4 	bl	79a0 <__aeabi_dsub>
    6ff8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    6ffc:	f000 fe84 	bl	7d08 <__aeabi_dmul>
    7000:	4652      	mov	r2, sl
    7002:	4606      	mov	r6, r0
    7004:	460f      	mov	r7, r1
    7006:	465b      	mov	r3, fp
    7008:	4640      	mov	r0, r8
    700a:	4649      	mov	r1, r9
    700c:	f000 fe7c 	bl	7d08 <__aeabi_dmul>
    7010:	4602      	mov	r2, r0
    7012:	460b      	mov	r3, r1
    7014:	4630      	mov	r0, r6
    7016:	4639      	mov	r1, r7
    7018:	f000 fcc4 	bl	79a4 <__adddf3>
    701c:	4622      	mov	r2, r4
    701e:	4680      	mov	r8, r0
    7020:	4689      	mov	r9, r1
    7022:	462b      	mov	r3, r5
    7024:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    7028:	e9cd 8904 	strd	r8, r9, [sp, #16]
    702c:	f000 fe6c 	bl	7d08 <__aeabi_dmul>
    7030:	460b      	mov	r3, r1
    7032:	4602      	mov	r2, r0
    7034:	4606      	mov	r6, r0
    7036:	460f      	mov	r7, r1
    7038:	4640      	mov	r0, r8
    703a:	4649      	mov	r1, r9
    703c:	f000 fcb2 	bl	79a4 <__adddf3>
    7040:	4bd5      	ldr	r3, [pc, #852]	; (7398 <__ieee754_pow+0x938>)
    7042:	4299      	cmp	r1, r3
    7044:	4604      	mov	r4, r0
    7046:	460d      	mov	r5, r1
    7048:	468a      	mov	sl, r1
    704a:	f340 8123 	ble.w	7294 <__ieee754_pow+0x834>
    704e:	f101 433f 	add.w	r3, r1, #3204448256	; 0xbf000000
    7052:	f503 03e0 	add.w	r3, r3, #7340032	; 0x700000
    7056:	4303      	orrs	r3, r0
    7058:	f040 8218 	bne.w	748c <__ieee754_pow+0xa2c>
    705c:	a3b6      	add	r3, pc, #728	; (adr r3, 7338 <__ieee754_pow+0x8d8>)
    705e:	e9d3 2300 	ldrd	r2, r3, [r3]
    7062:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    7066:	f000 fc9d 	bl	79a4 <__adddf3>
    706a:	4632      	mov	r2, r6
    706c:	4680      	mov	r8, r0
    706e:	4689      	mov	r9, r1
    7070:	463b      	mov	r3, r7
    7072:	4620      	mov	r0, r4
    7074:	4629      	mov	r1, r5
    7076:	f000 fc93 	bl	79a0 <__aeabi_dsub>
    707a:	4602      	mov	r2, r0
    707c:	460b      	mov	r3, r1
    707e:	4640      	mov	r0, r8
    7080:	4649      	mov	r1, r9
    7082:	f001 f8d1 	bl	8228 <__aeabi_dcmpgt>
    7086:	2800      	cmp	r0, #0
    7088:	f040 8200 	bne.w	748c <__ieee754_pow+0xa2c>
    708c:	46a8      	mov	r8, r5
    708e:	ea4f 5328 	mov.w	r3, r8, asr #20
    7092:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    7096:	f2a3 33fe 	subw	r3, r3, #1022	; 0x3fe
    709a:	fa42 f303 	asr.w	r3, r2, r3
    709e:	4453      	add	r3, sl
    70a0:	f3c3 520a 	ubfx	r2, r3, #20, #11
    70a4:	4dbd      	ldr	r5, [pc, #756]	; (739c <__ieee754_pow+0x93c>)
    70a6:	f2a2 32ff 	subw	r2, r2, #1023	; 0x3ff
    70aa:	4115      	asrs	r5, r2
    70ac:	f3c3 0b13 	ubfx	fp, r3, #0, #20
    70b0:	2000      	movs	r0, #0
    70b2:	f1c2 0414 	rsb	r4, r2, #20
    70b6:	ea23 0105 	bic.w	r1, r3, r5
    70ba:	f44b 1b80 	orr.w	fp, fp, #1048576	; 0x100000
    70be:	f1ba 0f00 	cmp.w	sl, #0
    70c2:	4602      	mov	r2, r0
    70c4:	460b      	mov	r3, r1
    70c6:	fa4b fb04 	asr.w	fp, fp, r4
    70ca:	4630      	mov	r0, r6
    70cc:	4639      	mov	r1, r7
    70ce:	bfb8      	it	lt
    70d0:	f1cb 0b00 	rsblt	fp, fp, #0
    70d4:	f000 fc64 	bl	79a0 <__aeabi_dsub>
    70d8:	4602      	mov	r2, r0
    70da:	460b      	mov	r3, r1
    70dc:	4606      	mov	r6, r0
    70de:	460f      	mov	r7, r1
    70e0:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    70e4:	f000 fc5e 	bl	79a4 <__adddf3>
    70e8:	ea4f 5a0b 	mov.w	sl, fp, lsl #20
    70ec:	2400      	movs	r4, #0
    70ee:	a394      	add	r3, pc, #592	; (adr r3, 7340 <__ieee754_pow+0x8e0>)
    70f0:	e9d3 2300 	ldrd	r2, r3, [r3]
    70f4:	4620      	mov	r0, r4
    70f6:	460d      	mov	r5, r1
    70f8:	f000 fe06 	bl	7d08 <__aeabi_dmul>
    70fc:	4632      	mov	r2, r6
    70fe:	4680      	mov	r8, r0
    7100:	4689      	mov	r9, r1
    7102:	463b      	mov	r3, r7
    7104:	4620      	mov	r0, r4
    7106:	4629      	mov	r1, r5
    7108:	f000 fc4a 	bl	79a0 <__aeabi_dsub>
    710c:	4602      	mov	r2, r0
    710e:	460b      	mov	r3, r1
    7110:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    7114:	f000 fc44 	bl	79a0 <__aeabi_dsub>
    7118:	a38b      	add	r3, pc, #556	; (adr r3, 7348 <__ieee754_pow+0x8e8>)
    711a:	e9d3 2300 	ldrd	r2, r3, [r3]
    711e:	f000 fdf3 	bl	7d08 <__aeabi_dmul>
    7122:	a38b      	add	r3, pc, #556	; (adr r3, 7350 <__ieee754_pow+0x8f0>)
    7124:	e9d3 2300 	ldrd	r2, r3, [r3]
    7128:	4606      	mov	r6, r0
    712a:	460f      	mov	r7, r1
    712c:	4620      	mov	r0, r4
    712e:	4629      	mov	r1, r5
    7130:	f000 fdea 	bl	7d08 <__aeabi_dmul>
    7134:	4602      	mov	r2, r0
    7136:	460b      	mov	r3, r1
    7138:	4630      	mov	r0, r6
    713a:	4639      	mov	r1, r7
    713c:	f000 fc32 	bl	79a4 <__adddf3>
    7140:	4606      	mov	r6, r0
    7142:	460f      	mov	r7, r1
    7144:	4602      	mov	r2, r0
    7146:	460b      	mov	r3, r1
    7148:	4640      	mov	r0, r8
    714a:	4649      	mov	r1, r9
    714c:	f000 fc2a 	bl	79a4 <__adddf3>
    7150:	4642      	mov	r2, r8
    7152:	464b      	mov	r3, r9
    7154:	4604      	mov	r4, r0
    7156:	460d      	mov	r5, r1
    7158:	f000 fc22 	bl	79a0 <__aeabi_dsub>
    715c:	4602      	mov	r2, r0
    715e:	460b      	mov	r3, r1
    7160:	4630      	mov	r0, r6
    7162:	4639      	mov	r1, r7
    7164:	f000 fc1c 	bl	79a0 <__aeabi_dsub>
    7168:	4622      	mov	r2, r4
    716a:	4680      	mov	r8, r0
    716c:	4689      	mov	r9, r1
    716e:	462b      	mov	r3, r5
    7170:	4620      	mov	r0, r4
    7172:	4629      	mov	r1, r5
    7174:	f000 fdc8 	bl	7d08 <__aeabi_dmul>
    7178:	a377      	add	r3, pc, #476	; (adr r3, 7358 <__ieee754_pow+0x8f8>)
    717a:	e9d3 2300 	ldrd	r2, r3, [r3]
    717e:	4606      	mov	r6, r0
    7180:	460f      	mov	r7, r1
    7182:	f000 fdc1 	bl	7d08 <__aeabi_dmul>
    7186:	a376      	add	r3, pc, #472	; (adr r3, 7360 <__ieee754_pow+0x900>)
    7188:	e9d3 2300 	ldrd	r2, r3, [r3]
    718c:	f000 fc08 	bl	79a0 <__aeabi_dsub>
    7190:	4632      	mov	r2, r6
    7192:	463b      	mov	r3, r7
    7194:	f000 fdb8 	bl	7d08 <__aeabi_dmul>
    7198:	a373      	add	r3, pc, #460	; (adr r3, 7368 <__ieee754_pow+0x908>)
    719a:	e9d3 2300 	ldrd	r2, r3, [r3]
    719e:	f000 fc01 	bl	79a4 <__adddf3>
    71a2:	4632      	mov	r2, r6
    71a4:	463b      	mov	r3, r7
    71a6:	f000 fdaf 	bl	7d08 <__aeabi_dmul>
    71aa:	a371      	add	r3, pc, #452	; (adr r3, 7370 <__ieee754_pow+0x910>)
    71ac:	e9d3 2300 	ldrd	r2, r3, [r3]
    71b0:	f000 fbf6 	bl	79a0 <__aeabi_dsub>
    71b4:	4632      	mov	r2, r6
    71b6:	463b      	mov	r3, r7
    71b8:	f000 fda6 	bl	7d08 <__aeabi_dmul>
    71bc:	a36e      	add	r3, pc, #440	; (adr r3, 7378 <__ieee754_pow+0x918>)
    71be:	e9d3 2300 	ldrd	r2, r3, [r3]
    71c2:	f000 fbef 	bl	79a4 <__adddf3>
    71c6:	4632      	mov	r2, r6
    71c8:	463b      	mov	r3, r7
    71ca:	f000 fd9d 	bl	7d08 <__aeabi_dmul>
    71ce:	4602      	mov	r2, r0
    71d0:	460b      	mov	r3, r1
    71d2:	4620      	mov	r0, r4
    71d4:	4629      	mov	r1, r5
    71d6:	f000 fbe3 	bl	79a0 <__aeabi_dsub>
    71da:	4606      	mov	r6, r0
    71dc:	460f      	mov	r7, r1
    71de:	4602      	mov	r2, r0
    71e0:	460b      	mov	r3, r1
    71e2:	4620      	mov	r0, r4
    71e4:	4629      	mov	r1, r5
    71e6:	f000 fd8f 	bl	7d08 <__aeabi_dmul>
    71ea:	2200      	movs	r2, #0
    71ec:	e9cd 0100 	strd	r0, r1, [sp]
    71f0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    71f4:	4630      	mov	r0, r6
    71f6:	4639      	mov	r1, r7
    71f8:	f000 fbd2 	bl	79a0 <__aeabi_dsub>
    71fc:	4602      	mov	r2, r0
    71fe:	460b      	mov	r3, r1
    7200:	e9dd 0100 	ldrd	r0, r1, [sp]
    7204:	f000 feaa 	bl	7f5c <__aeabi_ddiv>
    7208:	4642      	mov	r2, r8
    720a:	4606      	mov	r6, r0
    720c:	460f      	mov	r7, r1
    720e:	464b      	mov	r3, r9
    7210:	4620      	mov	r0, r4
    7212:	4629      	mov	r1, r5
    7214:	f000 fd78 	bl	7d08 <__aeabi_dmul>
    7218:	4642      	mov	r2, r8
    721a:	464b      	mov	r3, r9
    721c:	f000 fbc2 	bl	79a4 <__adddf3>
    7220:	4602      	mov	r2, r0
    7222:	460b      	mov	r3, r1
    7224:	4630      	mov	r0, r6
    7226:	4639      	mov	r1, r7
    7228:	f000 fbba 	bl	79a0 <__aeabi_dsub>
    722c:	4622      	mov	r2, r4
    722e:	462b      	mov	r3, r5
    7230:	f000 fbb6 	bl	79a0 <__aeabi_dsub>
    7234:	4602      	mov	r2, r0
    7236:	460b      	mov	r3, r1
    7238:	2000      	movs	r0, #0
    723a:	4959      	ldr	r1, [pc, #356]	; (73a0 <__ieee754_pow+0x940>)
    723c:	f000 fbb0 	bl	79a0 <__aeabi_dsub>
    7240:	448a      	add	sl, r1
    7242:	f5ba 1f80 	cmp.w	sl, #1048576	; 0x100000
    7246:	4602      	mov	r2, r0
    7248:	460b      	mov	r3, r1
    724a:	f2c0 815b 	blt.w	7504 <__ieee754_pow+0xaa4>
    724e:	4651      	mov	r1, sl
    7250:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    7254:	f000 fd58 	bl	7d08 <__aeabi_dmul>
    7258:	ec41 0b10 	vmov	d0, r0, r1
    725c:	e449      	b.n	6af2 <__ieee754_pow+0x92>
    725e:	f104 4440 	add.w	r4, r4, #3221225472	; 0xc0000000
    7262:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
    7266:	ea54 030b 	orrs.w	r3, r4, fp
    726a:	f000 8137 	beq.w	74dc <__ieee754_pow+0xa7c>
    726e:	f1bb 0f01 	cmp.w	fp, #1
    7272:	f47f ac80 	bne.w	6b76 <__ieee754_pow+0x116>
    7276:	4602      	mov	r2, r0
    7278:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
    727c:	ec43 2b10 	vmov	d0, r2, r3
    7280:	e437      	b.n	6af2 <__ieee754_pow+0x92>
    7282:	4632      	mov	r2, r6
    7284:	463b      	mov	r3, r7
    7286:	4630      	mov	r0, r6
    7288:	4639      	mov	r1, r7
    728a:	f000 fd3d 	bl	7d08 <__aeabi_dmul>
    728e:	ec41 0b10 	vmov	d0, r0, r1
    7292:	e42e      	b.n	6af2 <__ieee754_pow+0x92>
    7294:	4b43      	ldr	r3, [pc, #268]	; (73a4 <__ieee754_pow+0x944>)
    7296:	f021 4800 	bic.w	r8, r1, #2147483648	; 0x80000000
    729a:	4598      	cmp	r8, r3
    729c:	f340 8115 	ble.w	74ca <__ieee754_pow+0xa6a>
    72a0:	4b41      	ldr	r3, [pc, #260]	; (73a8 <__ieee754_pow+0x948>)
    72a2:	440b      	add	r3, r1
    72a4:	4303      	orrs	r3, r0
    72a6:	d10c      	bne.n	72c2 <__ieee754_pow+0x862>
    72a8:	4632      	mov	r2, r6
    72aa:	463b      	mov	r3, r7
    72ac:	f000 fb78 	bl	79a0 <__aeabi_dsub>
    72b0:	4602      	mov	r2, r0
    72b2:	460b      	mov	r3, r1
    72b4:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    72b8:	f000 ffa2 	bl	8200 <__aeabi_dcmple>
    72bc:	2800      	cmp	r0, #0
    72be:	f43f aee6 	beq.w	708e <__ieee754_pow+0x62e>
    72c2:	a32f      	add	r3, pc, #188	; (adr r3, 7380 <__ieee754_pow+0x920>)
    72c4:	e9d3 2300 	ldrd	r2, r3, [r3]
    72c8:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    72cc:	f000 fd1c 	bl	7d08 <__aeabi_dmul>
    72d0:	a32b      	add	r3, pc, #172	; (adr r3, 7380 <__ieee754_pow+0x920>)
    72d2:	e9d3 2300 	ldrd	r2, r3, [r3]
    72d6:	f000 fd17 	bl	7d08 <__aeabi_dmul>
    72da:	ec41 0b10 	vmov	d0, r0, r1
    72de:	e408      	b.n	6af2 <__ieee754_pow+0x92>
    72e0:	ed9f 7b29 	vldr	d7, [pc, #164]	; 7388 <__ieee754_pow+0x928>
    72e4:	ed8d 7b06 	vstr	d7, [sp, #24]
    72e8:	e676      	b.n	6fd8 <__ieee754_pow+0x578>
    72ea:	f1b9 0f00 	cmp.w	r9, #0
    72ee:	f6bf ac8e 	bge.w	6c0e <__ieee754_pow+0x1ae>
    72f2:	e9dd 3400 	ldrd	r3, r4, [sp]
    72f6:	ee00 3a10 	vmov	s0, r3
    72fa:	f104 4300 	add.w	r3, r4, #2147483648	; 0x80000000
    72fe:	ee00 3a90 	vmov	s1, r3
    7302:	f7ff bbf6 	b.w	6af2 <__ieee754_pow+0x92>
    7306:	4602      	mov	r2, r0
    7308:	460b      	mov	r3, r1
    730a:	2000      	movs	r0, #0
    730c:	4924      	ldr	r1, [pc, #144]	; (73a0 <__ieee754_pow+0x940>)
    730e:	f000 fe25 	bl	7f5c <__aeabi_ddiv>
    7312:	e42d      	b.n	6b70 <__ieee754_pow+0x110>
    7314:	ed9f 7b1e 	vldr	d7, [pc, #120]	; 7390 <__ieee754_pow+0x930>
    7318:	ed8d 7b08 	vstr	d7, [sp, #32]
    731c:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
    7320:	ed9f 7b03 	vldr	d7, [pc, #12]	; 7330 <__ieee754_pow+0x8d0>
    7324:	f04f 0800 	mov.w	r8, #0
    7328:	ed8d 7b06 	vstr	d7, [sp, #24]
    732c:	e4be      	b.n	6cac <__ieee754_pow+0x24c>
    732e:	bf00      	nop
    7330:	00000000 	.word	0x00000000
    7334:	3ff00000 	.word	0x3ff00000
    7338:	652b82fe 	.word	0x652b82fe
    733c:	3c971547 	.word	0x3c971547
    7340:	00000000 	.word	0x00000000
    7344:	3fe62e43 	.word	0x3fe62e43
    7348:	fefa39ef 	.word	0xfefa39ef
    734c:	3fe62e42 	.word	0x3fe62e42
    7350:	0ca86c39 	.word	0x0ca86c39
    7354:	be205c61 	.word	0xbe205c61
    7358:	72bea4d0 	.word	0x72bea4d0
    735c:	3e663769 	.word	0x3e663769
    7360:	c5d26bf1 	.word	0xc5d26bf1
    7364:	3ebbbd41 	.word	0x3ebbbd41
    7368:	af25de2c 	.word	0xaf25de2c
    736c:	3f11566a 	.word	0x3f11566a
    7370:	16bebd93 	.word	0x16bebd93
    7374:	3f66c16c 	.word	0x3f66c16c
    7378:	5555553e 	.word	0x5555553e
    737c:	3fc55555 	.word	0x3fc55555
    7380:	c2f8f359 	.word	0xc2f8f359
    7384:	01a56e1f 	.word	0x01a56e1f
    7388:	00000000 	.word	0x00000000
    738c:	bff00000 	.word	0xbff00000
	...
    7398:	408fffff 	.word	0x408fffff
    739c:	000fffff 	.word	0x000fffff
    73a0:	3ff00000 	.word	0x3ff00000
    73a4:	4090cbff 	.word	0x4090cbff
    73a8:	3f6f3400 	.word	0x3f6f3400
    73ac:	4b6c      	ldr	r3, [pc, #432]	; (7560 <__ieee754_pow+0xb00>)
    73ae:	429c      	cmp	r4, r3
    73b0:	f77f ac2a 	ble.w	6c08 <__ieee754_pow+0x1a8>
    73b4:	4b6b      	ldr	r3, [pc, #428]	; (7564 <__ieee754_pow+0xb04>)
    73b6:	429c      	cmp	r4, r3
    73b8:	f73f abc3 	bgt.w	6b42 <__ieee754_pow+0xe2>
    73bc:	2200      	movs	r2, #0
    73be:	4b69      	ldr	r3, [pc, #420]	; (7564 <__ieee754_pow+0xb04>)
    73c0:	f000 faee 	bl	79a0 <__aeabi_dsub>
    73c4:	a356      	add	r3, pc, #344	; (adr r3, 7520 <__ieee754_pow+0xac0>)
    73c6:	e9d3 2300 	ldrd	r2, r3, [r3]
    73ca:	4604      	mov	r4, r0
    73cc:	460d      	mov	r5, r1
    73ce:	f000 fc9b 	bl	7d08 <__aeabi_dmul>
    73d2:	a355      	add	r3, pc, #340	; (adr r3, 7528 <__ieee754_pow+0xac8>)
    73d4:	e9d3 2300 	ldrd	r2, r3, [r3]
    73d8:	4680      	mov	r8, r0
    73da:	4689      	mov	r9, r1
    73dc:	4620      	mov	r0, r4
    73de:	4629      	mov	r1, r5
    73e0:	f000 fc92 	bl	7d08 <__aeabi_dmul>
    73e4:	2200      	movs	r2, #0
    73e6:	e9cd 0102 	strd	r0, r1, [sp, #8]
    73ea:	4b5f      	ldr	r3, [pc, #380]	; (7568 <__ieee754_pow+0xb08>)
    73ec:	4620      	mov	r0, r4
    73ee:	4629      	mov	r1, r5
    73f0:	f000 fc8a 	bl	7d08 <__aeabi_dmul>
    73f4:	4602      	mov	r2, r0
    73f6:	460b      	mov	r3, r1
    73f8:	a14d      	add	r1, pc, #308	; (adr r1, 7530 <__ieee754_pow+0xad0>)
    73fa:	e9d1 0100 	ldrd	r0, r1, [r1]
    73fe:	f000 facf 	bl	79a0 <__aeabi_dsub>
    7402:	4622      	mov	r2, r4
    7404:	462b      	mov	r3, r5
    7406:	f000 fc7f 	bl	7d08 <__aeabi_dmul>
    740a:	4602      	mov	r2, r0
    740c:	460b      	mov	r3, r1
    740e:	2000      	movs	r0, #0
    7410:	4956      	ldr	r1, [pc, #344]	; (756c <__ieee754_pow+0xb0c>)
    7412:	f000 fac5 	bl	79a0 <__aeabi_dsub>
    7416:	4622      	mov	r2, r4
    7418:	462b      	mov	r3, r5
    741a:	4606      	mov	r6, r0
    741c:	460f      	mov	r7, r1
    741e:	4620      	mov	r0, r4
    7420:	4629      	mov	r1, r5
    7422:	f000 fc71 	bl	7d08 <__aeabi_dmul>
    7426:	4602      	mov	r2, r0
    7428:	460b      	mov	r3, r1
    742a:	4630      	mov	r0, r6
    742c:	4639      	mov	r1, r7
    742e:	f000 fc6b 	bl	7d08 <__aeabi_dmul>
    7432:	a341      	add	r3, pc, #260	; (adr r3, 7538 <__ieee754_pow+0xad8>)
    7434:	e9d3 2300 	ldrd	r2, r3, [r3]
    7438:	f000 fc66 	bl	7d08 <__aeabi_dmul>
    743c:	4602      	mov	r2, r0
    743e:	460b      	mov	r3, r1
    7440:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    7444:	f000 faac 	bl	79a0 <__aeabi_dsub>
    7448:	4602      	mov	r2, r0
    744a:	460b      	mov	r3, r1
    744c:	4604      	mov	r4, r0
    744e:	460d      	mov	r5, r1
    7450:	4640      	mov	r0, r8
    7452:	4649      	mov	r1, r9
    7454:	f000 faa6 	bl	79a4 <__adddf3>
    7458:	4642      	mov	r2, r8
    745a:	464b      	mov	r3, r9
    745c:	2000      	movs	r0, #0
    745e:	e9cd 0102 	strd	r0, r1, [sp, #8]
    7462:	f000 fa9d 	bl	79a0 <__aeabi_dsub>
    7466:	4602      	mov	r2, r0
    7468:	460b      	mov	r3, r1
    746a:	4620      	mov	r0, r4
    746c:	4629      	mov	r1, r5
    746e:	f000 fa97 	bl	79a0 <__aeabi_dsub>
    7472:	4680      	mov	r8, r0
    7474:	4689      	mov	r9, r1
    7476:	e5a5      	b.n	6fc4 <__ieee754_pow+0x564>
    7478:	4632      	mov	r2, r6
    747a:	463b      	mov	r3, r7
    747c:	2000      	movs	r0, #0
    747e:	4939      	ldr	r1, [pc, #228]	; (7564 <__ieee754_pow+0xb04>)
    7480:	f000 fd6c 	bl	7f5c <__aeabi_ddiv>
    7484:	ec41 0b10 	vmov	d0, r0, r1
    7488:	f7ff bb33 	b.w	6af2 <__ieee754_pow+0x92>
    748c:	a32c      	add	r3, pc, #176	; (adr r3, 7540 <__ieee754_pow+0xae0>)
    748e:	e9d3 2300 	ldrd	r2, r3, [r3]
    7492:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    7496:	f000 fc37 	bl	7d08 <__aeabi_dmul>
    749a:	a329      	add	r3, pc, #164	; (adr r3, 7540 <__ieee754_pow+0xae0>)
    749c:	e9d3 2300 	ldrd	r2, r3, [r3]
    74a0:	f000 fc32 	bl	7d08 <__aeabi_dmul>
    74a4:	ec41 0b10 	vmov	d0, r0, r1
    74a8:	f7ff bb23 	b.w	6af2 <__ieee754_pow+0x92>
    74ac:	f1be 0f00 	cmp.w	lr, #0
    74b0:	f47f ab2a 	bne.w	6b08 <__ieee754_pow+0xa8>
    74b4:	f1c3 0314 	rsb	r3, r3, #20
    74b8:	fa48 f203 	asr.w	r2, r8, r3
    74bc:	fa02 f303 	lsl.w	r3, r2, r3
    74c0:	4598      	cmp	r8, r3
    74c2:	d027      	beq.n	7514 <__ieee754_pow+0xab4>
    74c4:	46f3      	mov	fp, lr
    74c6:	f7ff baf7 	b.w	6ab8 <__ieee754_pow+0x58>
    74ca:	4b28      	ldr	r3, [pc, #160]	; (756c <__ieee754_pow+0xb0c>)
    74cc:	4598      	cmp	r8, r3
    74ce:	f73f adde 	bgt.w	708e <__ieee754_pow+0x62e>
    74d2:	e9dd 3400 	ldrd	r3, r4, [sp]
    74d6:	469a      	mov	sl, r3
    74d8:	469b      	mov	fp, r3
    74da:	e607      	b.n	70ec <__ieee754_pow+0x68c>
    74dc:	4602      	mov	r2, r0
    74de:	460b      	mov	r3, r1
    74e0:	f7ff bb89 	b.w	6bf6 <__ieee754_pow+0x196>
    74e4:	ed9f 7b18 	vldr	d7, [pc, #96]	; 7548 <__ieee754_pow+0xae8>
    74e8:	ed8d 7b08 	vstr	d7, [sp, #32]
    74ec:	ed9f 7b18 	vldr	d7, [pc, #96]	; 7550 <__ieee754_pow+0xaf0>
    74f0:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
    74f4:	ed9f 7b18 	vldr	d7, [pc, #96]	; 7558 <__ieee754_pow+0xaf8>
    74f8:	f44f 2880 	mov.w	r8, #262144	; 0x40000
    74fc:	ed8d 7b06 	vstr	d7, [sp, #24]
    7500:	f7ff bbd4 	b.w	6cac <__ieee754_pow+0x24c>
    7504:	4658      	mov	r0, fp
    7506:	ec43 2b10 	vmov	d0, r2, r3
    750a:	f000 f9b1 	bl	7870 <scalbn>
    750e:	ec51 0b10 	vmov	r0, r1, d0
    7512:	e69d      	b.n	7250 <__ieee754_pow+0x7f0>
    7514:	f002 0201 	and.w	r2, r2, #1
    7518:	f1c2 0b02 	rsb	fp, r2, #2
    751c:	f7ff bacc 	b.w	6ab8 <__ieee754_pow+0x58>
    7520:	60000000 	.word	0x60000000
    7524:	3ff71547 	.word	0x3ff71547
    7528:	f85ddf44 	.word	0xf85ddf44
    752c:	3e54ae0b 	.word	0x3e54ae0b
    7530:	55555555 	.word	0x55555555
    7534:	3fd55555 	.word	0x3fd55555
    7538:	652b82fe 	.word	0x652b82fe
    753c:	3ff71547 	.word	0x3ff71547
    7540:	8800759c 	.word	0x8800759c
    7544:	7e37e43c 	.word	0x7e37e43c
    7548:	40000000 	.word	0x40000000
    754c:	3fe2b803 	.word	0x3fe2b803
    7550:	43cfd006 	.word	0x43cfd006
    7554:	3e4cfdeb 	.word	0x3e4cfdeb
    7558:	00000000 	.word	0x00000000
    755c:	3ff80000 	.word	0x3ff80000
    7560:	3feffffe 	.word	0x3feffffe
    7564:	3ff00000 	.word	0x3ff00000
    7568:	3fd00000 	.word	0x3fd00000
    756c:	3fe00000 	.word	0x3fe00000

00007570 <__ieee754_sqrt>:
    7570:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7574:	4965      	ldr	r1, [pc, #404]	; (770c <__ieee754_sqrt+0x19c>)
    7576:	ec55 4b10 	vmov	r4, r5, d0
    757a:	460e      	mov	r6, r1
    757c:	4029      	ands	r1, r5
    757e:	42b1      	cmp	r1, r6
    7580:	f000 8097 	beq.w	76b2 <__ieee754_sqrt+0x142>
    7584:	2d00      	cmp	r5, #0
    7586:	462b      	mov	r3, r5
    7588:	ee10 2a10 	vmov	r2, s0
    758c:	dd74      	ble.n	7678 <__ieee754_sqrt+0x108>
    758e:	152f      	asrs	r7, r5, #20
    7590:	d07f      	beq.n	7692 <__ieee754_sqrt+0x122>
    7592:	f2a7 37ff 	subw	r7, r7, #1023	; 0x3ff
    7596:	f3c3 0313 	ubfx	r3, r3, #0, #20
    759a:	07f9      	lsls	r1, r7, #31
    759c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    75a0:	d465      	bmi.n	766e <__ieee754_sqrt+0xfe>
    75a2:	eb03 71d2 	add.w	r1, r3, r2, lsr #31
    75a6:	2600      	movs	r6, #0
    75a8:	440b      	add	r3, r1
    75aa:	107f      	asrs	r7, r7, #1
    75ac:	0052      	lsls	r2, r2, #1
    75ae:	46b6      	mov	lr, r6
    75b0:	2016      	movs	r0, #22
    75b2:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
    75b6:	eb0e 0401 	add.w	r4, lr, r1
    75ba:	429c      	cmp	r4, r3
    75bc:	ea4f 75d2 	mov.w	r5, r2, lsr #31
    75c0:	ea4f 0242 	mov.w	r2, r2, lsl #1
    75c4:	dc03      	bgt.n	75ce <__ieee754_sqrt+0x5e>
    75c6:	1b1b      	subs	r3, r3, r4
    75c8:	eb04 0e01 	add.w	lr, r4, r1
    75cc:	440e      	add	r6, r1
    75ce:	3801      	subs	r0, #1
    75d0:	eb05 0343 	add.w	r3, r5, r3, lsl #1
    75d4:	ea4f 0151 	mov.w	r1, r1, lsr #1
    75d8:	d1ed      	bne.n	75b6 <__ieee754_sqrt+0x46>
    75da:	4684      	mov	ip, r0
    75dc:	2420      	movs	r4, #32
    75de:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    75e2:	e009      	b.n	75f8 <__ieee754_sqrt+0x88>
    75e4:	d020      	beq.n	7628 <__ieee754_sqrt+0xb8>
    75e6:	eb03 75d2 	add.w	r5, r3, r2, lsr #31
    75ea:	3c01      	subs	r4, #1
    75ec:	ea4f 0151 	mov.w	r1, r1, lsr #1
    75f0:	442b      	add	r3, r5
    75f2:	ea4f 0242 	mov.w	r2, r2, lsl #1
    75f6:	d020      	beq.n	763a <__ieee754_sqrt+0xca>
    75f8:	459e      	cmp	lr, r3
    75fa:	eb01 050c 	add.w	r5, r1, ip
    75fe:	daf1      	bge.n	75e4 <__ieee754_sqrt+0x74>
    7600:	2d00      	cmp	r5, #0
    7602:	eb05 0c01 	add.w	ip, r5, r1
    7606:	db09      	blt.n	761c <__ieee754_sqrt+0xac>
    7608:	46f0      	mov	r8, lr
    760a:	4295      	cmp	r5, r2
    760c:	ebce 0303 	rsb	r3, lr, r3
    7610:	d900      	bls.n	7614 <__ieee754_sqrt+0xa4>
    7612:	3b01      	subs	r3, #1
    7614:	1b52      	subs	r2, r2, r5
    7616:	4408      	add	r0, r1
    7618:	46c6      	mov	lr, r8
    761a:	e7e4      	b.n	75e6 <__ieee754_sqrt+0x76>
    761c:	f1bc 0f00 	cmp.w	ip, #0
    7620:	dbf2      	blt.n	7608 <__ieee754_sqrt+0x98>
    7622:	f10e 0801 	add.w	r8, lr, #1
    7626:	e7f0      	b.n	760a <__ieee754_sqrt+0x9a>
    7628:	4295      	cmp	r5, r2
    762a:	d81e      	bhi.n	766a <__ieee754_sqrt+0xfa>
    762c:	2d00      	cmp	r5, #0
    762e:	eb05 0c01 	add.w	ip, r5, r1
    7632:	db50      	blt.n	76d6 <__ieee754_sqrt+0x166>
    7634:	4698      	mov	r8, r3
    7636:	2300      	movs	r3, #0
    7638:	e7ec      	b.n	7614 <__ieee754_sqrt+0xa4>
    763a:	4313      	orrs	r3, r2
    763c:	d004      	beq.n	7648 <__ieee754_sqrt+0xd8>
    763e:	1c42      	adds	r2, r0, #1
    7640:	d04d      	beq.n	76de <__ieee754_sqrt+0x16e>
    7642:	f000 0301 	and.w	r3, r0, #1
    7646:	4418      	add	r0, r3
    7648:	0840      	lsrs	r0, r0, #1
    764a:	1071      	asrs	r1, r6, #1
    764c:	07f3      	lsls	r3, r6, #31
    764e:	f101 517f 	add.w	r1, r1, #1069547520	; 0x3fc00000
    7652:	f501 1100 	add.w	r1, r1, #2097152	; 0x200000
    7656:	bf48      	it	mi
    7658:	f040 4000 	orrmi.w	r0, r0, #2147483648	; 0x80000000
    765c:	eb01 5307 	add.w	r3, r1, r7, lsl #20
    7660:	4602      	mov	r2, r0
    7662:	ec43 2b10 	vmov	d0, r2, r3
    7666:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    766a:	4673      	mov	r3, lr
    766c:	e7bb      	b.n	75e6 <__ieee754_sqrt+0x76>
    766e:	005b      	lsls	r3, r3, #1
    7670:	eb03 73d2 	add.w	r3, r3, r2, lsr #31
    7674:	0052      	lsls	r2, r2, #1
    7676:	e794      	b.n	75a2 <__ieee754_sqrt+0x32>
    7678:	f025 4100 	bic.w	r1, r5, #2147483648	; 0x80000000
    767c:	4321      	orrs	r1, r4
    767e:	d028      	beq.n	76d2 <__ieee754_sqrt+0x162>
    7680:	bbad      	cbnz	r5, 76ee <__ieee754_sqrt+0x17e>
    7682:	462f      	mov	r7, r5
    7684:	0ad3      	lsrs	r3, r2, #11
    7686:	3f15      	subs	r7, #21
    7688:	0552      	lsls	r2, r2, #21
    768a:	2b00      	cmp	r3, #0
    768c:	d0fa      	beq.n	7684 <__ieee754_sqrt+0x114>
    768e:	02dd      	lsls	r5, r3, #11
    7690:	d428      	bmi.n	76e4 <__ieee754_sqrt+0x174>
    7692:	2100      	movs	r1, #0
    7694:	e000      	b.n	7698 <__ieee754_sqrt+0x128>
    7696:	4601      	mov	r1, r0
    7698:	005b      	lsls	r3, r3, #1
    769a:	02dc      	lsls	r4, r3, #11
    769c:	f101 0001 	add.w	r0, r1, #1
    76a0:	d5f9      	bpl.n	7696 <__ieee754_sqrt+0x126>
    76a2:	f1c0 0420 	rsb	r4, r0, #32
    76a6:	fa22 f404 	lsr.w	r4, r2, r4
    76aa:	4323      	orrs	r3, r4
    76ac:	1a7f      	subs	r7, r7, r1
    76ae:	4082      	lsls	r2, r0
    76b0:	e76f      	b.n	7592 <__ieee754_sqrt+0x22>
    76b2:	ee10 2a10 	vmov	r2, s0
    76b6:	462b      	mov	r3, r5
    76b8:	ee10 0a10 	vmov	r0, s0
    76bc:	4629      	mov	r1, r5
    76be:	f000 fb23 	bl	7d08 <__aeabi_dmul>
    76c2:	4622      	mov	r2, r4
    76c4:	462b      	mov	r3, r5
    76c6:	f000 f96d 	bl	79a4 <__adddf3>
    76ca:	ec41 0b10 	vmov	d0, r0, r1
    76ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    76d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    76d6:	f1bc 0f00 	cmp.w	ip, #0
    76da:	daa2      	bge.n	7622 <__ieee754_sqrt+0xb2>
    76dc:	e7aa      	b.n	7634 <__ieee754_sqrt+0xc4>
    76de:	3601      	adds	r6, #1
    76e0:	4620      	mov	r0, r4
    76e2:	e7b2      	b.n	764a <__ieee754_sqrt+0xda>
    76e4:	2420      	movs	r4, #32
    76e6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    76ea:	2000      	movs	r0, #0
    76ec:	e7db      	b.n	76a6 <__ieee754_sqrt+0x136>
    76ee:	ee10 2a10 	vmov	r2, s0
    76f2:	462b      	mov	r3, r5
    76f4:	4620      	mov	r0, r4
    76f6:	4629      	mov	r1, r5
    76f8:	f000 f952 	bl	79a0 <__aeabi_dsub>
    76fc:	4602      	mov	r2, r0
    76fe:	460b      	mov	r3, r1
    7700:	f000 fc2c 	bl	7f5c <__aeabi_ddiv>
    7704:	ec41 0b10 	vmov	d0, r0, r1
    7708:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    770c:	7ff00000 	.word	0x7ff00000

00007710 <fabs>:
    7710:	ec53 2b10 	vmov	r2, r3, d0
    7714:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    7718:	ec43 2b10 	vmov	d0, r2, r3
    771c:	4770      	bx	lr
    771e:	bf00      	nop

00007720 <finite>:
    7720:	ee10 3a90 	vmov	r3, s1
    7724:	f043 4000 	orr.w	r0, r3, #2147483648	; 0x80000000
    7728:	f500 1080 	add.w	r0, r0, #1048576	; 0x100000
    772c:	0fc0      	lsrs	r0, r0, #31
    772e:	4770      	bx	lr

00007730 <matherr>:
    7730:	2000      	movs	r0, #0
    7732:	4770      	bx	lr
    7734:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

00007738 <nan>:
    7738:	ed9f 0b01 	vldr	d0, [pc, #4]	; 7740 <nan+0x8>
    773c:	4770      	bx	lr
    773e:	bf00      	nop
    7740:	00000000 	.word	0x00000000
    7744:	7ff80000 	.word	0x7ff80000

00007748 <rint>:
    7748:	b5f0      	push	{r4, r5, r6, r7, lr}
    774a:	ec53 2b10 	vmov	r2, r3, d0
    774e:	f3c3 560a 	ubfx	r6, r3, #20, #11
    7752:	f2a6 30ff 	subw	r0, r6, #1023	; 0x3ff
    7756:	2813      	cmp	r0, #19
    7758:	b083      	sub	sp, #12
    775a:	4619      	mov	r1, r3
    775c:	ea4f 74d3 	mov.w	r4, r3, lsr #31
    7760:	ee10 5a10 	vmov	r5, s0
    7764:	dc2f      	bgt.n	77c6 <rint+0x7e>
    7766:	2800      	cmp	r0, #0
    7768:	db49      	blt.n	77fe <rint+0xb6>
    776a:	4e3f      	ldr	r6, [pc, #252]	; (7868 <rint+0x120>)
    776c:	4106      	asrs	r6, r0
    776e:	ea03 0706 	and.w	r7, r3, r6
    7772:	4317      	orrs	r7, r2
    7774:	d02c      	beq.n	77d0 <rint+0x88>
    7776:	0876      	lsrs	r6, r6, #1
    7778:	4033      	ands	r3, r6
    777a:	431d      	orrs	r5, r3
    777c:	d00c      	beq.n	7798 <rint+0x50>
    777e:	f44f 2380 	mov.w	r3, #262144	; 0x40000
    7782:	2813      	cmp	r0, #19
    7784:	ea21 0606 	bic.w	r6, r1, r6
    7788:	fa43 f100 	asr.w	r1, r3, r0
    778c:	ea41 0106 	orr.w	r1, r1, r6
    7790:	bf0c      	ite	eq
    7792:	f04f 4500 	moveq.w	r5, #2147483648	; 0x80000000
    7796:	2500      	movne	r5, #0
    7798:	4834      	ldr	r0, [pc, #208]	; (786c <rint+0x124>)
    779a:	eb00 04c4 	add.w	r4, r0, r4, lsl #3
    779e:	462a      	mov	r2, r5
    77a0:	e9d4 4500 	ldrd	r4, r5, [r4]
    77a4:	4610      	mov	r0, r2
    77a6:	462b      	mov	r3, r5
    77a8:	4622      	mov	r2, r4
    77aa:	f000 f8fb 	bl	79a4 <__adddf3>
    77ae:	e9cd 0100 	strd	r0, r1, [sp]
    77b2:	4622      	mov	r2, r4
    77b4:	462b      	mov	r3, r5
    77b6:	e9dd 0100 	ldrd	r0, r1, [sp]
    77ba:	f000 f8f1 	bl	79a0 <__aeabi_dsub>
    77be:	ec41 0b10 	vmov	d0, r0, r1
    77c2:	b003      	add	sp, #12
    77c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    77c6:	2833      	cmp	r0, #51	; 0x33
    77c8:	dd06      	ble.n	77d8 <rint+0x90>
    77ca:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
    77ce:	d042      	beq.n	7856 <rint+0x10e>
    77d0:	ec43 2b10 	vmov	d0, r2, r3
    77d4:	b003      	add	sp, #12
    77d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    77d8:	f2a6 4613 	subw	r6, r6, #1043	; 0x413
    77dc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    77e0:	40f0      	lsrs	r0, r6
    77e2:	4202      	tst	r2, r0
    77e4:	d0f4      	beq.n	77d0 <rint+0x88>
    77e6:	0840      	lsrs	r0, r0, #1
    77e8:	4202      	tst	r2, r0
    77ea:	d0d5      	beq.n	7798 <rint+0x50>
    77ec:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    77f0:	ea25 0000 	bic.w	r0, r5, r0
    77f4:	fa43 f606 	asr.w	r6, r3, r6
    77f8:	ea46 0500 	orr.w	r5, r6, r0
    77fc:	e7cc      	b.n	7798 <rint+0x50>
    77fe:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
    7802:	4310      	orrs	r0, r2
    7804:	ee10 7a10 	vmov	r7, s0
    7808:	d0e2      	beq.n	77d0 <rint+0x88>
    780a:	f3c3 0013 	ubfx	r0, r3, #0, #20
    780e:	4307      	orrs	r7, r0
    7810:	4278      	negs	r0, r7
    7812:	4307      	orrs	r7, r0
    7814:	4815      	ldr	r0, [pc, #84]	; (786c <rint+0x124>)
    7816:	0c59      	lsrs	r1, r3, #17
    7818:	0b3f      	lsrs	r7, r7, #12
    781a:	0449      	lsls	r1, r1, #17
    781c:	f407 2700 	and.w	r7, r7, #524288	; 0x80000
    7820:	eb00 00c4 	add.w	r0, r0, r4, lsl #3
    7824:	ea47 0301 	orr.w	r3, r7, r1
    7828:	e9d0 6700 	ldrd	r6, r7, [r0]
    782c:	4619      	mov	r1, r3
    782e:	4610      	mov	r0, r2
    7830:	463b      	mov	r3, r7
    7832:	4632      	mov	r2, r6
    7834:	f000 f8b6 	bl	79a4 <__adddf3>
    7838:	e9cd 0100 	strd	r0, r1, [sp]
    783c:	463b      	mov	r3, r7
    783e:	4632      	mov	r2, r6
    7840:	e9dd 0100 	ldrd	r0, r1, [sp]
    7844:	f000 f8ac 	bl	79a0 <__aeabi_dsub>
    7848:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
    784c:	ea43 71c4 	orr.w	r1, r3, r4, lsl #31
    7850:	ec41 0b10 	vmov	d0, r0, r1
    7854:	e7be      	b.n	77d4 <rint+0x8c>
    7856:	ee10 0a10 	vmov	r0, s0
    785a:	4619      	mov	r1, r3
    785c:	f000 f8a2 	bl	79a4 <__adddf3>
    7860:	ec41 0b10 	vmov	d0, r0, r1
    7864:	e7b6      	b.n	77d4 <rint+0x8c>
    7866:	bf00      	nop
    7868:	000fffff 	.word	0x000fffff
    786c:	00009e68 	.word	0x00009e68

00007870 <scalbn>:
    7870:	ec53 2b10 	vmov	r2, r3, d0
    7874:	b570      	push	{r4, r5, r6, lr}
    7876:	f3c3 540a 	ubfx	r4, r3, #20, #11
    787a:	4619      	mov	r1, r3
    787c:	4605      	mov	r5, r0
    787e:	bb14      	cbnz	r4, 78c6 <scalbn+0x56>
    7880:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
    7884:	4311      	orrs	r1, r2
    7886:	d02a      	beq.n	78de <scalbn+0x6e>
    7888:	4619      	mov	r1, r3
    788a:	2200      	movs	r2, #0
    788c:	4b38      	ldr	r3, [pc, #224]	; (7970 <scalbn+0x100>)
    788e:	4e39      	ldr	r6, [pc, #228]	; (7974 <scalbn+0x104>)
    7890:	ee10 0a10 	vmov	r0, s0
    7894:	f000 fa38 	bl	7d08 <__aeabi_dmul>
    7898:	42b5      	cmp	r5, r6
    789a:	4602      	mov	r2, r0
    789c:	460b      	mov	r3, r1
    789e:	db1f      	blt.n	78e0 <scalbn+0x70>
    78a0:	f3c1 540a 	ubfx	r4, r1, #20, #11
    78a4:	3c36      	subs	r4, #54	; 0x36
    78a6:	442c      	add	r4, r5
    78a8:	f240 70fe 	movw	r0, #2046	; 0x7fe
    78ac:	4284      	cmp	r4, r0
    78ae:	dc1f      	bgt.n	78f0 <scalbn+0x80>
    78b0:	2c00      	cmp	r4, #0
    78b2:	dd2d      	ble.n	7910 <scalbn+0xa0>
    78b4:	f021 41ff 	bic.w	r1, r1, #2139095040	; 0x7f800000
    78b8:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
    78bc:	ea41 5304 	orr.w	r3, r1, r4, lsl #20
    78c0:	ec43 2b10 	vmov	d0, r2, r3
    78c4:	bd70      	pop	{r4, r5, r6, pc}
    78c6:	f240 70ff 	movw	r0, #2047	; 0x7ff
    78ca:	4284      	cmp	r4, r0
    78cc:	d1eb      	bne.n	78a6 <scalbn+0x36>
    78ce:	ee10 0a10 	vmov	r0, s0
    78d2:	4619      	mov	r1, r3
    78d4:	f000 f866 	bl	79a4 <__adddf3>
    78d8:	ec41 0b10 	vmov	d0, r0, r1
    78dc:	bd70      	pop	{r4, r5, r6, pc}
    78de:	bd70      	pop	{r4, r5, r6, pc}
    78e0:	a31f      	add	r3, pc, #124	; (adr r3, 7960 <scalbn+0xf0>)
    78e2:	e9d3 2300 	ldrd	r2, r3, [r3]
    78e6:	f000 fa0f 	bl	7d08 <__aeabi_dmul>
    78ea:	ec41 0b10 	vmov	d0, r0, r1
    78ee:	bd70      	pop	{r4, r5, r6, pc}
    78f0:	ec43 2b11 	vmov	d1, r2, r3
    78f4:	ed9f 0b1c 	vldr	d0, [pc, #112]	; 7968 <scalbn+0xf8>
    78f8:	f000 f840 	bl	797c <copysign>
    78fc:	a31a      	add	r3, pc, #104	; (adr r3, 7968 <scalbn+0xf8>)
    78fe:	e9d3 2300 	ldrd	r2, r3, [r3]
    7902:	ec51 0b10 	vmov	r0, r1, d0
    7906:	f000 f9ff 	bl	7d08 <__aeabi_dmul>
    790a:	ec41 0b10 	vmov	d0, r0, r1
    790e:	bd70      	pop	{r4, r5, r6, pc}
    7910:	f114 0f35 	cmn.w	r4, #53	; 0x35
    7914:	da13      	bge.n	793e <scalbn+0xce>
    7916:	f24c 3150 	movw	r1, #50000	; 0xc350
    791a:	428d      	cmp	r5, r1
    791c:	ec43 2b11 	vmov	d1, r2, r3
    7920:	dce8      	bgt.n	78f4 <scalbn+0x84>
    7922:	ed9f 0b0f 	vldr	d0, [pc, #60]	; 7960 <scalbn+0xf0>
    7926:	f000 f829 	bl	797c <copysign>
    792a:	a30d      	add	r3, pc, #52	; (adr r3, 7960 <scalbn+0xf0>)
    792c:	e9d3 2300 	ldrd	r2, r3, [r3]
    7930:	ec51 0b10 	vmov	r0, r1, d0
    7934:	f000 f9e8 	bl	7d08 <__aeabi_dmul>
    7938:	ec41 0b10 	vmov	d0, r0, r1
    793c:	bd70      	pop	{r4, r5, r6, pc}
    793e:	f021 41ff 	bic.w	r1, r1, #2139095040	; 0x7f800000
    7942:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
    7946:	3436      	adds	r4, #54	; 0x36
    7948:	ea41 5304 	orr.w	r3, r1, r4, lsl #20
    794c:	4610      	mov	r0, r2
    794e:	4619      	mov	r1, r3
    7950:	2200      	movs	r2, #0
    7952:	4b09      	ldr	r3, [pc, #36]	; (7978 <scalbn+0x108>)
    7954:	f000 f9d8 	bl	7d08 <__aeabi_dmul>
    7958:	ec41 0b10 	vmov	d0, r0, r1
    795c:	bd70      	pop	{r4, r5, r6, pc}
    795e:	bf00      	nop
    7960:	c2f8f359 	.word	0xc2f8f359
    7964:	01a56e1f 	.word	0x01a56e1f
    7968:	8800759c 	.word	0x8800759c
    796c:	7e37e43c 	.word	0x7e37e43c
    7970:	43500000 	.word	0x43500000
    7974:	ffff3cb0 	.word	0xffff3cb0
    7978:	3c900000 	.word	0x3c900000

0000797c <copysign>:
    797c:	ec53 2b10 	vmov	r2, r3, d0
    7980:	ee11 0a90 	vmov	r0, s3
    7984:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
    7988:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
    798c:	ea41 0300 	orr.w	r3, r1, r0
    7990:	ec43 2b10 	vmov	d0, r2, r3
    7994:	4770      	bx	lr
    7996:	bf00      	nop

00007998 <__aeabi_drsub>:
    7998:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
    799c:	e002      	b.n	79a4 <__adddf3>
    799e:	bf00      	nop

000079a0 <__aeabi_dsub>:
    79a0:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

000079a4 <__adddf3>:
    79a4:	b530      	push	{r4, r5, lr}
    79a6:	ea4f 0441 	mov.w	r4, r1, lsl #1
    79aa:	ea4f 0543 	mov.w	r5, r3, lsl #1
    79ae:	ea94 0f05 	teq	r4, r5
    79b2:	bf08      	it	eq
    79b4:	ea90 0f02 	teqeq	r0, r2
    79b8:	bf1f      	itttt	ne
    79ba:	ea54 0c00 	orrsne.w	ip, r4, r0
    79be:	ea55 0c02 	orrsne.w	ip, r5, r2
    79c2:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
    79c6:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    79ca:	f000 80e2 	beq.w	7b92 <__adddf3+0x1ee>
    79ce:	ea4f 5454 	mov.w	r4, r4, lsr #21
    79d2:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
    79d6:	bfb8      	it	lt
    79d8:	426d      	neglt	r5, r5
    79da:	dd0c      	ble.n	79f6 <__adddf3+0x52>
    79dc:	442c      	add	r4, r5
    79de:	ea80 0202 	eor.w	r2, r0, r2
    79e2:	ea81 0303 	eor.w	r3, r1, r3
    79e6:	ea82 0000 	eor.w	r0, r2, r0
    79ea:	ea83 0101 	eor.w	r1, r3, r1
    79ee:	ea80 0202 	eor.w	r2, r0, r2
    79f2:	ea81 0303 	eor.w	r3, r1, r3
    79f6:	2d36      	cmp	r5, #54	; 0x36
    79f8:	bf88      	it	hi
    79fa:	bd30      	pophi	{r4, r5, pc}
    79fc:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    7a00:	ea4f 3101 	mov.w	r1, r1, lsl #12
    7a04:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
    7a08:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
    7a0c:	d002      	beq.n	7a14 <__adddf3+0x70>
    7a0e:	4240      	negs	r0, r0
    7a10:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    7a14:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
    7a18:	ea4f 3303 	mov.w	r3, r3, lsl #12
    7a1c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
    7a20:	d002      	beq.n	7a28 <__adddf3+0x84>
    7a22:	4252      	negs	r2, r2
    7a24:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    7a28:	ea94 0f05 	teq	r4, r5
    7a2c:	f000 80a7 	beq.w	7b7e <__adddf3+0x1da>
    7a30:	f1a4 0401 	sub.w	r4, r4, #1
    7a34:	f1d5 0e20 	rsbs	lr, r5, #32
    7a38:	db0d      	blt.n	7a56 <__adddf3+0xb2>
    7a3a:	fa02 fc0e 	lsl.w	ip, r2, lr
    7a3e:	fa22 f205 	lsr.w	r2, r2, r5
    7a42:	1880      	adds	r0, r0, r2
    7a44:	f141 0100 	adc.w	r1, r1, #0
    7a48:	fa03 f20e 	lsl.w	r2, r3, lr
    7a4c:	1880      	adds	r0, r0, r2
    7a4e:	fa43 f305 	asr.w	r3, r3, r5
    7a52:	4159      	adcs	r1, r3
    7a54:	e00e      	b.n	7a74 <__adddf3+0xd0>
    7a56:	f1a5 0520 	sub.w	r5, r5, #32
    7a5a:	f10e 0e20 	add.w	lr, lr, #32
    7a5e:	2a01      	cmp	r2, #1
    7a60:	fa03 fc0e 	lsl.w	ip, r3, lr
    7a64:	bf28      	it	cs
    7a66:	f04c 0c02 	orrcs.w	ip, ip, #2
    7a6a:	fa43 f305 	asr.w	r3, r3, r5
    7a6e:	18c0      	adds	r0, r0, r3
    7a70:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
    7a74:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    7a78:	d507      	bpl.n	7a8a <__adddf3+0xe6>
    7a7a:	f04f 0e00 	mov.w	lr, #0
    7a7e:	f1dc 0c00 	rsbs	ip, ip, #0
    7a82:	eb7e 0000 	sbcs.w	r0, lr, r0
    7a86:	eb6e 0101 	sbc.w	r1, lr, r1
    7a8a:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    7a8e:	d31b      	bcc.n	7ac8 <__adddf3+0x124>
    7a90:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    7a94:	d30c      	bcc.n	7ab0 <__adddf3+0x10c>
    7a96:	0849      	lsrs	r1, r1, #1
    7a98:	ea5f 0030 	movs.w	r0, r0, rrx
    7a9c:	ea4f 0c3c 	mov.w	ip, ip, rrx
    7aa0:	f104 0401 	add.w	r4, r4, #1
    7aa4:	ea4f 5244 	mov.w	r2, r4, lsl #21
    7aa8:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
    7aac:	f080 809a 	bcs.w	7be4 <__adddf3+0x240>
    7ab0:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    7ab4:	bf08      	it	eq
    7ab6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    7aba:	f150 0000 	adcs.w	r0, r0, #0
    7abe:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    7ac2:	ea41 0105 	orr.w	r1, r1, r5
    7ac6:	bd30      	pop	{r4, r5, pc}
    7ac8:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
    7acc:	4140      	adcs	r0, r0
    7ace:	eb41 0101 	adc.w	r1, r1, r1
    7ad2:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    7ad6:	f1a4 0401 	sub.w	r4, r4, #1
    7ada:	d1e9      	bne.n	7ab0 <__adddf3+0x10c>
    7adc:	f091 0f00 	teq	r1, #0
    7ae0:	bf04      	itt	eq
    7ae2:	4601      	moveq	r1, r0
    7ae4:	2000      	moveq	r0, #0
    7ae6:	fab1 f381 	clz	r3, r1
    7aea:	bf08      	it	eq
    7aec:	3320      	addeq	r3, #32
    7aee:	f1a3 030b 	sub.w	r3, r3, #11
    7af2:	f1b3 0220 	subs.w	r2, r3, #32
    7af6:	da0c      	bge.n	7b12 <__adddf3+0x16e>
    7af8:	320c      	adds	r2, #12
    7afa:	dd08      	ble.n	7b0e <__adddf3+0x16a>
    7afc:	f102 0c14 	add.w	ip, r2, #20
    7b00:	f1c2 020c 	rsb	r2, r2, #12
    7b04:	fa01 f00c 	lsl.w	r0, r1, ip
    7b08:	fa21 f102 	lsr.w	r1, r1, r2
    7b0c:	e00c      	b.n	7b28 <__adddf3+0x184>
    7b0e:	f102 0214 	add.w	r2, r2, #20
    7b12:	bfd8      	it	le
    7b14:	f1c2 0c20 	rsble	ip, r2, #32
    7b18:	fa01 f102 	lsl.w	r1, r1, r2
    7b1c:	fa20 fc0c 	lsr.w	ip, r0, ip
    7b20:	bfdc      	itt	le
    7b22:	ea41 010c 	orrle.w	r1, r1, ip
    7b26:	4090      	lslle	r0, r2
    7b28:	1ae4      	subs	r4, r4, r3
    7b2a:	bfa2      	ittt	ge
    7b2c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
    7b30:	4329      	orrge	r1, r5
    7b32:	bd30      	popge	{r4, r5, pc}
    7b34:	ea6f 0404 	mvn.w	r4, r4
    7b38:	3c1f      	subs	r4, #31
    7b3a:	da1c      	bge.n	7b76 <__adddf3+0x1d2>
    7b3c:	340c      	adds	r4, #12
    7b3e:	dc0e      	bgt.n	7b5e <__adddf3+0x1ba>
    7b40:	f104 0414 	add.w	r4, r4, #20
    7b44:	f1c4 0220 	rsb	r2, r4, #32
    7b48:	fa20 f004 	lsr.w	r0, r0, r4
    7b4c:	fa01 f302 	lsl.w	r3, r1, r2
    7b50:	ea40 0003 	orr.w	r0, r0, r3
    7b54:	fa21 f304 	lsr.w	r3, r1, r4
    7b58:	ea45 0103 	orr.w	r1, r5, r3
    7b5c:	bd30      	pop	{r4, r5, pc}
    7b5e:	f1c4 040c 	rsb	r4, r4, #12
    7b62:	f1c4 0220 	rsb	r2, r4, #32
    7b66:	fa20 f002 	lsr.w	r0, r0, r2
    7b6a:	fa01 f304 	lsl.w	r3, r1, r4
    7b6e:	ea40 0003 	orr.w	r0, r0, r3
    7b72:	4629      	mov	r1, r5
    7b74:	bd30      	pop	{r4, r5, pc}
    7b76:	fa21 f004 	lsr.w	r0, r1, r4
    7b7a:	4629      	mov	r1, r5
    7b7c:	bd30      	pop	{r4, r5, pc}
    7b7e:	f094 0f00 	teq	r4, #0
    7b82:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
    7b86:	bf06      	itte	eq
    7b88:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
    7b8c:	3401      	addeq	r4, #1
    7b8e:	3d01      	subne	r5, #1
    7b90:	e74e      	b.n	7a30 <__adddf3+0x8c>
    7b92:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    7b96:	bf18      	it	ne
    7b98:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    7b9c:	d029      	beq.n	7bf2 <__adddf3+0x24e>
    7b9e:	ea94 0f05 	teq	r4, r5
    7ba2:	bf08      	it	eq
    7ba4:	ea90 0f02 	teqeq	r0, r2
    7ba8:	d005      	beq.n	7bb6 <__adddf3+0x212>
    7baa:	ea54 0c00 	orrs.w	ip, r4, r0
    7bae:	bf04      	itt	eq
    7bb0:	4619      	moveq	r1, r3
    7bb2:	4610      	moveq	r0, r2
    7bb4:	bd30      	pop	{r4, r5, pc}
    7bb6:	ea91 0f03 	teq	r1, r3
    7bba:	bf1e      	ittt	ne
    7bbc:	2100      	movne	r1, #0
    7bbe:	2000      	movne	r0, #0
    7bc0:	bd30      	popne	{r4, r5, pc}
    7bc2:	ea5f 5c54 	movs.w	ip, r4, lsr #21
    7bc6:	d105      	bne.n	7bd4 <__adddf3+0x230>
    7bc8:	0040      	lsls	r0, r0, #1
    7bca:	4149      	adcs	r1, r1
    7bcc:	bf28      	it	cs
    7bce:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
    7bd2:	bd30      	pop	{r4, r5, pc}
    7bd4:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
    7bd8:	bf3c      	itt	cc
    7bda:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
    7bde:	bd30      	popcc	{r4, r5, pc}
    7be0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    7be4:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
    7be8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    7bec:	f04f 0000 	mov.w	r0, #0
    7bf0:	bd30      	pop	{r4, r5, pc}
    7bf2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    7bf6:	bf1a      	itte	ne
    7bf8:	4619      	movne	r1, r3
    7bfa:	4610      	movne	r0, r2
    7bfc:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
    7c00:	bf1c      	itt	ne
    7c02:	460b      	movne	r3, r1
    7c04:	4602      	movne	r2, r0
    7c06:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    7c0a:	bf06      	itte	eq
    7c0c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
    7c10:	ea91 0f03 	teqeq	r1, r3
    7c14:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
    7c18:	bd30      	pop	{r4, r5, pc}
    7c1a:	bf00      	nop

00007c1c <__aeabi_ui2d>:
    7c1c:	f090 0f00 	teq	r0, #0
    7c20:	bf04      	itt	eq
    7c22:	2100      	moveq	r1, #0
    7c24:	4770      	bxeq	lr
    7c26:	b530      	push	{r4, r5, lr}
    7c28:	f44f 6480 	mov.w	r4, #1024	; 0x400
    7c2c:	f104 0432 	add.w	r4, r4, #50	; 0x32
    7c30:	f04f 0500 	mov.w	r5, #0
    7c34:	f04f 0100 	mov.w	r1, #0
    7c38:	e750      	b.n	7adc <__adddf3+0x138>
    7c3a:	bf00      	nop

00007c3c <__aeabi_i2d>:
    7c3c:	f090 0f00 	teq	r0, #0
    7c40:	bf04      	itt	eq
    7c42:	2100      	moveq	r1, #0
    7c44:	4770      	bxeq	lr
    7c46:	b530      	push	{r4, r5, lr}
    7c48:	f44f 6480 	mov.w	r4, #1024	; 0x400
    7c4c:	f104 0432 	add.w	r4, r4, #50	; 0x32
    7c50:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
    7c54:	bf48      	it	mi
    7c56:	4240      	negmi	r0, r0
    7c58:	f04f 0100 	mov.w	r1, #0
    7c5c:	e73e      	b.n	7adc <__adddf3+0x138>
    7c5e:	bf00      	nop

00007c60 <__aeabi_f2d>:
    7c60:	0042      	lsls	r2, r0, #1
    7c62:	ea4f 01e2 	mov.w	r1, r2, asr #3
    7c66:	ea4f 0131 	mov.w	r1, r1, rrx
    7c6a:	ea4f 7002 	mov.w	r0, r2, lsl #28
    7c6e:	bf1f      	itttt	ne
    7c70:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
    7c74:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    7c78:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
    7c7c:	4770      	bxne	lr
    7c7e:	f092 0f00 	teq	r2, #0
    7c82:	bf14      	ite	ne
    7c84:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    7c88:	4770      	bxeq	lr
    7c8a:	b530      	push	{r4, r5, lr}
    7c8c:	f44f 7460 	mov.w	r4, #896	; 0x380
    7c90:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    7c94:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    7c98:	e720      	b.n	7adc <__adddf3+0x138>
    7c9a:	bf00      	nop

00007c9c <__aeabi_ul2d>:
    7c9c:	ea50 0201 	orrs.w	r2, r0, r1
    7ca0:	bf08      	it	eq
    7ca2:	4770      	bxeq	lr
    7ca4:	b530      	push	{r4, r5, lr}
    7ca6:	f04f 0500 	mov.w	r5, #0
    7caa:	e00a      	b.n	7cc2 <__aeabi_l2d+0x16>

00007cac <__aeabi_l2d>:
    7cac:	ea50 0201 	orrs.w	r2, r0, r1
    7cb0:	bf08      	it	eq
    7cb2:	4770      	bxeq	lr
    7cb4:	b530      	push	{r4, r5, lr}
    7cb6:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
    7cba:	d502      	bpl.n	7cc2 <__aeabi_l2d+0x16>
    7cbc:	4240      	negs	r0, r0
    7cbe:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    7cc2:	f44f 6480 	mov.w	r4, #1024	; 0x400
    7cc6:	f104 0432 	add.w	r4, r4, #50	; 0x32
    7cca:	ea5f 5c91 	movs.w	ip, r1, lsr #22
    7cce:	f43f aedc 	beq.w	7a8a <__adddf3+0xe6>
    7cd2:	f04f 0203 	mov.w	r2, #3
    7cd6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    7cda:	bf18      	it	ne
    7cdc:	3203      	addne	r2, #3
    7cde:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    7ce2:	bf18      	it	ne
    7ce4:	3203      	addne	r2, #3
    7ce6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
    7cea:	f1c2 0320 	rsb	r3, r2, #32
    7cee:	fa00 fc03 	lsl.w	ip, r0, r3
    7cf2:	fa20 f002 	lsr.w	r0, r0, r2
    7cf6:	fa01 fe03 	lsl.w	lr, r1, r3
    7cfa:	ea40 000e 	orr.w	r0, r0, lr
    7cfe:	fa21 f102 	lsr.w	r1, r1, r2
    7d02:	4414      	add	r4, r2
    7d04:	e6c1      	b.n	7a8a <__adddf3+0xe6>
    7d06:	bf00      	nop

00007d08 <__aeabi_dmul>:
    7d08:	b570      	push	{r4, r5, r6, lr}
    7d0a:	f04f 0cff 	mov.w	ip, #255	; 0xff
    7d0e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    7d12:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    7d16:	bf1d      	ittte	ne
    7d18:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    7d1c:	ea94 0f0c 	teqne	r4, ip
    7d20:	ea95 0f0c 	teqne	r5, ip
    7d24:	f000 f8de 	bleq	7ee4 <__aeabi_dmul+0x1dc>
    7d28:	442c      	add	r4, r5
    7d2a:	ea81 0603 	eor.w	r6, r1, r3
    7d2e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
    7d32:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
    7d36:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
    7d3a:	bf18      	it	ne
    7d3c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
    7d40:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    7d44:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    7d48:	d038      	beq.n	7dbc <__aeabi_dmul+0xb4>
    7d4a:	fba0 ce02 	umull	ip, lr, r0, r2
    7d4e:	f04f 0500 	mov.w	r5, #0
    7d52:	fbe1 e502 	umlal	lr, r5, r1, r2
    7d56:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
    7d5a:	fbe0 e503 	umlal	lr, r5, r0, r3
    7d5e:	f04f 0600 	mov.w	r6, #0
    7d62:	fbe1 5603 	umlal	r5, r6, r1, r3
    7d66:	f09c 0f00 	teq	ip, #0
    7d6a:	bf18      	it	ne
    7d6c:	f04e 0e01 	orrne.w	lr, lr, #1
    7d70:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
    7d74:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
    7d78:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
    7d7c:	d204      	bcs.n	7d88 <__aeabi_dmul+0x80>
    7d7e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
    7d82:	416d      	adcs	r5, r5
    7d84:	eb46 0606 	adc.w	r6, r6, r6
    7d88:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
    7d8c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
    7d90:	ea4f 20c5 	mov.w	r0, r5, lsl #11
    7d94:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
    7d98:	ea4f 2ece 	mov.w	lr, lr, lsl #11
    7d9c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    7da0:	bf88      	it	hi
    7da2:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    7da6:	d81e      	bhi.n	7de6 <__aeabi_dmul+0xde>
    7da8:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
    7dac:	bf08      	it	eq
    7dae:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
    7db2:	f150 0000 	adcs.w	r0, r0, #0
    7db6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    7dba:	bd70      	pop	{r4, r5, r6, pc}
    7dbc:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
    7dc0:	ea46 0101 	orr.w	r1, r6, r1
    7dc4:	ea40 0002 	orr.w	r0, r0, r2
    7dc8:	ea81 0103 	eor.w	r1, r1, r3
    7dcc:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
    7dd0:	bfc2      	ittt	gt
    7dd2:	ebd4 050c 	rsbsgt	r5, r4, ip
    7dd6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    7dda:	bd70      	popgt	{r4, r5, r6, pc}
    7ddc:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    7de0:	f04f 0e00 	mov.w	lr, #0
    7de4:	3c01      	subs	r4, #1
    7de6:	f300 80ab 	bgt.w	7f40 <__aeabi_dmul+0x238>
    7dea:	f114 0f36 	cmn.w	r4, #54	; 0x36
    7dee:	bfde      	ittt	le
    7df0:	2000      	movle	r0, #0
    7df2:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
    7df6:	bd70      	pople	{r4, r5, r6, pc}
    7df8:	f1c4 0400 	rsb	r4, r4, #0
    7dfc:	3c20      	subs	r4, #32
    7dfe:	da35      	bge.n	7e6c <__aeabi_dmul+0x164>
    7e00:	340c      	adds	r4, #12
    7e02:	dc1b      	bgt.n	7e3c <__aeabi_dmul+0x134>
    7e04:	f104 0414 	add.w	r4, r4, #20
    7e08:	f1c4 0520 	rsb	r5, r4, #32
    7e0c:	fa00 f305 	lsl.w	r3, r0, r5
    7e10:	fa20 f004 	lsr.w	r0, r0, r4
    7e14:	fa01 f205 	lsl.w	r2, r1, r5
    7e18:	ea40 0002 	orr.w	r0, r0, r2
    7e1c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
    7e20:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    7e24:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    7e28:	fa21 f604 	lsr.w	r6, r1, r4
    7e2c:	eb42 0106 	adc.w	r1, r2, r6
    7e30:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    7e34:	bf08      	it	eq
    7e36:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    7e3a:	bd70      	pop	{r4, r5, r6, pc}
    7e3c:	f1c4 040c 	rsb	r4, r4, #12
    7e40:	f1c4 0520 	rsb	r5, r4, #32
    7e44:	fa00 f304 	lsl.w	r3, r0, r4
    7e48:	fa20 f005 	lsr.w	r0, r0, r5
    7e4c:	fa01 f204 	lsl.w	r2, r1, r4
    7e50:	ea40 0002 	orr.w	r0, r0, r2
    7e54:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    7e58:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    7e5c:	f141 0100 	adc.w	r1, r1, #0
    7e60:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    7e64:	bf08      	it	eq
    7e66:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    7e6a:	bd70      	pop	{r4, r5, r6, pc}
    7e6c:	f1c4 0520 	rsb	r5, r4, #32
    7e70:	fa00 f205 	lsl.w	r2, r0, r5
    7e74:	ea4e 0e02 	orr.w	lr, lr, r2
    7e78:	fa20 f304 	lsr.w	r3, r0, r4
    7e7c:	fa01 f205 	lsl.w	r2, r1, r5
    7e80:	ea43 0302 	orr.w	r3, r3, r2
    7e84:	fa21 f004 	lsr.w	r0, r1, r4
    7e88:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    7e8c:	fa21 f204 	lsr.w	r2, r1, r4
    7e90:	ea20 0002 	bic.w	r0, r0, r2
    7e94:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
    7e98:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    7e9c:	bf08      	it	eq
    7e9e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    7ea2:	bd70      	pop	{r4, r5, r6, pc}
    7ea4:	f094 0f00 	teq	r4, #0
    7ea8:	d10f      	bne.n	7eca <__aeabi_dmul+0x1c2>
    7eaa:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
    7eae:	0040      	lsls	r0, r0, #1
    7eb0:	eb41 0101 	adc.w	r1, r1, r1
    7eb4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    7eb8:	bf08      	it	eq
    7eba:	3c01      	subeq	r4, #1
    7ebc:	d0f7      	beq.n	7eae <__aeabi_dmul+0x1a6>
    7ebe:	ea41 0106 	orr.w	r1, r1, r6
    7ec2:	f095 0f00 	teq	r5, #0
    7ec6:	bf18      	it	ne
    7ec8:	4770      	bxne	lr
    7eca:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
    7ece:	0052      	lsls	r2, r2, #1
    7ed0:	eb43 0303 	adc.w	r3, r3, r3
    7ed4:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    7ed8:	bf08      	it	eq
    7eda:	3d01      	subeq	r5, #1
    7edc:	d0f7      	beq.n	7ece <__aeabi_dmul+0x1c6>
    7ede:	ea43 0306 	orr.w	r3, r3, r6
    7ee2:	4770      	bx	lr
    7ee4:	ea94 0f0c 	teq	r4, ip
    7ee8:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    7eec:	bf18      	it	ne
    7eee:	ea95 0f0c 	teqne	r5, ip
    7ef2:	d00c      	beq.n	7f0e <__aeabi_dmul+0x206>
    7ef4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    7ef8:	bf18      	it	ne
    7efa:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    7efe:	d1d1      	bne.n	7ea4 <__aeabi_dmul+0x19c>
    7f00:	ea81 0103 	eor.w	r1, r1, r3
    7f04:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    7f08:	f04f 0000 	mov.w	r0, #0
    7f0c:	bd70      	pop	{r4, r5, r6, pc}
    7f0e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    7f12:	bf06      	itte	eq
    7f14:	4610      	moveq	r0, r2
    7f16:	4619      	moveq	r1, r3
    7f18:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    7f1c:	d019      	beq.n	7f52 <__aeabi_dmul+0x24a>
    7f1e:	ea94 0f0c 	teq	r4, ip
    7f22:	d102      	bne.n	7f2a <__aeabi_dmul+0x222>
    7f24:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
    7f28:	d113      	bne.n	7f52 <__aeabi_dmul+0x24a>
    7f2a:	ea95 0f0c 	teq	r5, ip
    7f2e:	d105      	bne.n	7f3c <__aeabi_dmul+0x234>
    7f30:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
    7f34:	bf1c      	itt	ne
    7f36:	4610      	movne	r0, r2
    7f38:	4619      	movne	r1, r3
    7f3a:	d10a      	bne.n	7f52 <__aeabi_dmul+0x24a>
    7f3c:	ea81 0103 	eor.w	r1, r1, r3
    7f40:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    7f44:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    7f48:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    7f4c:	f04f 0000 	mov.w	r0, #0
    7f50:	bd70      	pop	{r4, r5, r6, pc}
    7f52:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    7f56:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
    7f5a:	bd70      	pop	{r4, r5, r6, pc}

00007f5c <__aeabi_ddiv>:
    7f5c:	b570      	push	{r4, r5, r6, lr}
    7f5e:	f04f 0cff 	mov.w	ip, #255	; 0xff
    7f62:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    7f66:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    7f6a:	bf1d      	ittte	ne
    7f6c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    7f70:	ea94 0f0c 	teqne	r4, ip
    7f74:	ea95 0f0c 	teqne	r5, ip
    7f78:	f000 f8a7 	bleq	80ca <__aeabi_ddiv+0x16e>
    7f7c:	eba4 0405 	sub.w	r4, r4, r5
    7f80:	ea81 0e03 	eor.w	lr, r1, r3
    7f84:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    7f88:	ea4f 3101 	mov.w	r1, r1, lsl #12
    7f8c:	f000 8088 	beq.w	80a0 <__aeabi_ddiv+0x144>
    7f90:	ea4f 3303 	mov.w	r3, r3, lsl #12
    7f94:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
    7f98:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
    7f9c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    7fa0:	ea4f 2202 	mov.w	r2, r2, lsl #8
    7fa4:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
    7fa8:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
    7fac:	ea4f 2600 	mov.w	r6, r0, lsl #8
    7fb0:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
    7fb4:	429d      	cmp	r5, r3
    7fb6:	bf08      	it	eq
    7fb8:	4296      	cmpeq	r6, r2
    7fba:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
    7fbe:	f504 7440 	add.w	r4, r4, #768	; 0x300
    7fc2:	d202      	bcs.n	7fca <__aeabi_ddiv+0x6e>
    7fc4:	085b      	lsrs	r3, r3, #1
    7fc6:	ea4f 0232 	mov.w	r2, r2, rrx
    7fca:	1ab6      	subs	r6, r6, r2
    7fcc:	eb65 0503 	sbc.w	r5, r5, r3
    7fd0:	085b      	lsrs	r3, r3, #1
    7fd2:	ea4f 0232 	mov.w	r2, r2, rrx
    7fd6:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
    7fda:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
    7fde:	ebb6 0e02 	subs.w	lr, r6, r2
    7fe2:	eb75 0e03 	sbcs.w	lr, r5, r3
    7fe6:	bf22      	ittt	cs
    7fe8:	1ab6      	subcs	r6, r6, r2
    7fea:	4675      	movcs	r5, lr
    7fec:	ea40 000c 	orrcs.w	r0, r0, ip
    7ff0:	085b      	lsrs	r3, r3, #1
    7ff2:	ea4f 0232 	mov.w	r2, r2, rrx
    7ff6:	ebb6 0e02 	subs.w	lr, r6, r2
    7ffa:	eb75 0e03 	sbcs.w	lr, r5, r3
    7ffe:	bf22      	ittt	cs
    8000:	1ab6      	subcs	r6, r6, r2
    8002:	4675      	movcs	r5, lr
    8004:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    8008:	085b      	lsrs	r3, r3, #1
    800a:	ea4f 0232 	mov.w	r2, r2, rrx
    800e:	ebb6 0e02 	subs.w	lr, r6, r2
    8012:	eb75 0e03 	sbcs.w	lr, r5, r3
    8016:	bf22      	ittt	cs
    8018:	1ab6      	subcs	r6, r6, r2
    801a:	4675      	movcs	r5, lr
    801c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    8020:	085b      	lsrs	r3, r3, #1
    8022:	ea4f 0232 	mov.w	r2, r2, rrx
    8026:	ebb6 0e02 	subs.w	lr, r6, r2
    802a:	eb75 0e03 	sbcs.w	lr, r5, r3
    802e:	bf22      	ittt	cs
    8030:	1ab6      	subcs	r6, r6, r2
    8032:	4675      	movcs	r5, lr
    8034:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    8038:	ea55 0e06 	orrs.w	lr, r5, r6
    803c:	d018      	beq.n	8070 <__aeabi_ddiv+0x114>
    803e:	ea4f 1505 	mov.w	r5, r5, lsl #4
    8042:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
    8046:	ea4f 1606 	mov.w	r6, r6, lsl #4
    804a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    804e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
    8052:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    8056:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
    805a:	d1c0      	bne.n	7fde <__aeabi_ddiv+0x82>
    805c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    8060:	d10b      	bne.n	807a <__aeabi_ddiv+0x11e>
    8062:	ea41 0100 	orr.w	r1, r1, r0
    8066:	f04f 0000 	mov.w	r0, #0
    806a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
    806e:	e7b6      	b.n	7fde <__aeabi_ddiv+0x82>
    8070:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    8074:	bf04      	itt	eq
    8076:	4301      	orreq	r1, r0
    8078:	2000      	moveq	r0, #0
    807a:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    807e:	bf88      	it	hi
    8080:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    8084:	f63f aeaf 	bhi.w	7de6 <__aeabi_dmul+0xde>
    8088:	ebb5 0c03 	subs.w	ip, r5, r3
    808c:	bf04      	itt	eq
    808e:	ebb6 0c02 	subseq.w	ip, r6, r2
    8092:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    8096:	f150 0000 	adcs.w	r0, r0, #0
    809a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    809e:	bd70      	pop	{r4, r5, r6, pc}
    80a0:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
    80a4:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
    80a8:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
    80ac:	bfc2      	ittt	gt
    80ae:	ebd4 050c 	rsbsgt	r5, r4, ip
    80b2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    80b6:	bd70      	popgt	{r4, r5, r6, pc}
    80b8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    80bc:	f04f 0e00 	mov.w	lr, #0
    80c0:	3c01      	subs	r4, #1
    80c2:	e690      	b.n	7de6 <__aeabi_dmul+0xde>
    80c4:	ea45 0e06 	orr.w	lr, r5, r6
    80c8:	e68d      	b.n	7de6 <__aeabi_dmul+0xde>
    80ca:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    80ce:	ea94 0f0c 	teq	r4, ip
    80d2:	bf08      	it	eq
    80d4:	ea95 0f0c 	teqeq	r5, ip
    80d8:	f43f af3b 	beq.w	7f52 <__aeabi_dmul+0x24a>
    80dc:	ea94 0f0c 	teq	r4, ip
    80e0:	d10a      	bne.n	80f8 <__aeabi_ddiv+0x19c>
    80e2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    80e6:	f47f af34 	bne.w	7f52 <__aeabi_dmul+0x24a>
    80ea:	ea95 0f0c 	teq	r5, ip
    80ee:	f47f af25 	bne.w	7f3c <__aeabi_dmul+0x234>
    80f2:	4610      	mov	r0, r2
    80f4:	4619      	mov	r1, r3
    80f6:	e72c      	b.n	7f52 <__aeabi_dmul+0x24a>
    80f8:	ea95 0f0c 	teq	r5, ip
    80fc:	d106      	bne.n	810c <__aeabi_ddiv+0x1b0>
    80fe:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    8102:	f43f aefd 	beq.w	7f00 <__aeabi_dmul+0x1f8>
    8106:	4610      	mov	r0, r2
    8108:	4619      	mov	r1, r3
    810a:	e722      	b.n	7f52 <__aeabi_dmul+0x24a>
    810c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    8110:	bf18      	it	ne
    8112:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    8116:	f47f aec5 	bne.w	7ea4 <__aeabi_dmul+0x19c>
    811a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
    811e:	f47f af0d 	bne.w	7f3c <__aeabi_dmul+0x234>
    8122:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
    8126:	f47f aeeb 	bne.w	7f00 <__aeabi_dmul+0x1f8>
    812a:	e712      	b.n	7f52 <__aeabi_dmul+0x24a>

0000812c <__gedf2>:
    812c:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
    8130:	e006      	b.n	8140 <__cmpdf2+0x4>
    8132:	bf00      	nop

00008134 <__ledf2>:
    8134:	f04f 0c01 	mov.w	ip, #1
    8138:	e002      	b.n	8140 <__cmpdf2+0x4>
    813a:	bf00      	nop

0000813c <__cmpdf2>:
    813c:	f04f 0c01 	mov.w	ip, #1
    8140:	f84d cd04 	str.w	ip, [sp, #-4]!
    8144:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    8148:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    814c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    8150:	bf18      	it	ne
    8152:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
    8156:	d01b      	beq.n	8190 <__cmpdf2+0x54>
    8158:	b001      	add	sp, #4
    815a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
    815e:	bf0c      	ite	eq
    8160:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
    8164:	ea91 0f03 	teqne	r1, r3
    8168:	bf02      	ittt	eq
    816a:	ea90 0f02 	teqeq	r0, r2
    816e:	2000      	moveq	r0, #0
    8170:	4770      	bxeq	lr
    8172:	f110 0f00 	cmn.w	r0, #0
    8176:	ea91 0f03 	teq	r1, r3
    817a:	bf58      	it	pl
    817c:	4299      	cmppl	r1, r3
    817e:	bf08      	it	eq
    8180:	4290      	cmpeq	r0, r2
    8182:	bf2c      	ite	cs
    8184:	17d8      	asrcs	r0, r3, #31
    8186:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
    818a:	f040 0001 	orr.w	r0, r0, #1
    818e:	4770      	bx	lr
    8190:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    8194:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    8198:	d102      	bne.n	81a0 <__cmpdf2+0x64>
    819a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    819e:	d107      	bne.n	81b0 <__cmpdf2+0x74>
    81a0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    81a4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    81a8:	d1d6      	bne.n	8158 <__cmpdf2+0x1c>
    81aa:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    81ae:	d0d3      	beq.n	8158 <__cmpdf2+0x1c>
    81b0:	f85d 0b04 	ldr.w	r0, [sp], #4
    81b4:	4770      	bx	lr
    81b6:	bf00      	nop

000081b8 <__aeabi_cdrcmple>:
    81b8:	4684      	mov	ip, r0
    81ba:	4610      	mov	r0, r2
    81bc:	4662      	mov	r2, ip
    81be:	468c      	mov	ip, r1
    81c0:	4619      	mov	r1, r3
    81c2:	4663      	mov	r3, ip
    81c4:	e000      	b.n	81c8 <__aeabi_cdcmpeq>
    81c6:	bf00      	nop

000081c8 <__aeabi_cdcmpeq>:
    81c8:	b501      	push	{r0, lr}
    81ca:	f7ff ffb7 	bl	813c <__cmpdf2>
    81ce:	2800      	cmp	r0, #0
    81d0:	bf48      	it	mi
    81d2:	f110 0f00 	cmnmi.w	r0, #0
    81d6:	bd01      	pop	{r0, pc}

000081d8 <__aeabi_dcmpeq>:
    81d8:	f84d ed08 	str.w	lr, [sp, #-8]!
    81dc:	f7ff fff4 	bl	81c8 <__aeabi_cdcmpeq>
    81e0:	bf0c      	ite	eq
    81e2:	2001      	moveq	r0, #1
    81e4:	2000      	movne	r0, #0
    81e6:	f85d fb08 	ldr.w	pc, [sp], #8
    81ea:	bf00      	nop

000081ec <__aeabi_dcmplt>:
    81ec:	f84d ed08 	str.w	lr, [sp, #-8]!
    81f0:	f7ff ffea 	bl	81c8 <__aeabi_cdcmpeq>
    81f4:	bf34      	ite	cc
    81f6:	2001      	movcc	r0, #1
    81f8:	2000      	movcs	r0, #0
    81fa:	f85d fb08 	ldr.w	pc, [sp], #8
    81fe:	bf00      	nop

00008200 <__aeabi_dcmple>:
    8200:	f84d ed08 	str.w	lr, [sp, #-8]!
    8204:	f7ff ffe0 	bl	81c8 <__aeabi_cdcmpeq>
    8208:	bf94      	ite	ls
    820a:	2001      	movls	r0, #1
    820c:	2000      	movhi	r0, #0
    820e:	f85d fb08 	ldr.w	pc, [sp], #8
    8212:	bf00      	nop

00008214 <__aeabi_dcmpge>:
    8214:	f84d ed08 	str.w	lr, [sp, #-8]!
    8218:	f7ff ffce 	bl	81b8 <__aeabi_cdrcmple>
    821c:	bf94      	ite	ls
    821e:	2001      	movls	r0, #1
    8220:	2000      	movhi	r0, #0
    8222:	f85d fb08 	ldr.w	pc, [sp], #8
    8226:	bf00      	nop

00008228 <__aeabi_dcmpgt>:
    8228:	f84d ed08 	str.w	lr, [sp, #-8]!
    822c:	f7ff ffc4 	bl	81b8 <__aeabi_cdrcmple>
    8230:	bf34      	ite	cc
    8232:	2001      	movcc	r0, #1
    8234:	2000      	movcs	r0, #0
    8236:	f85d fb08 	ldr.w	pc, [sp], #8
    823a:	bf00      	nop

0000823c <__aeabi_dcmpun>:
    823c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    8240:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    8244:	d102      	bne.n	824c <__aeabi_dcmpun+0x10>
    8246:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    824a:	d10a      	bne.n	8262 <__aeabi_dcmpun+0x26>
    824c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    8250:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    8254:	d102      	bne.n	825c <__aeabi_dcmpun+0x20>
    8256:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    825a:	d102      	bne.n	8262 <__aeabi_dcmpun+0x26>
    825c:	f04f 0000 	mov.w	r0, #0
    8260:	4770      	bx	lr
    8262:	f04f 0001 	mov.w	r0, #1
    8266:	4770      	bx	lr

00008268 <__aeabi_d2iz>:
    8268:	ea4f 0241 	mov.w	r2, r1, lsl #1
    826c:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
    8270:	d215      	bcs.n	829e <__aeabi_d2iz+0x36>
    8272:	d511      	bpl.n	8298 <__aeabi_d2iz+0x30>
    8274:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
    8278:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
    827c:	d912      	bls.n	82a4 <__aeabi_d2iz+0x3c>
    827e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    8282:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    8286:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
    828a:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    828e:	fa23 f002 	lsr.w	r0, r3, r2
    8292:	bf18      	it	ne
    8294:	4240      	negne	r0, r0
    8296:	4770      	bx	lr
    8298:	f04f 0000 	mov.w	r0, #0
    829c:	4770      	bx	lr
    829e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
    82a2:	d105      	bne.n	82b0 <__aeabi_d2iz+0x48>
    82a4:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
    82a8:	bf08      	it	eq
    82aa:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
    82ae:	4770      	bx	lr
    82b0:	f04f 0000 	mov.w	r0, #0
    82b4:	4770      	bx	lr
    82b6:	bf00      	nop

000082b8 <__aeabi_d2f>:
    82b8:	ea4f 0241 	mov.w	r2, r1, lsl #1
    82bc:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
    82c0:	bf24      	itt	cs
    82c2:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
    82c6:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
    82ca:	d90d      	bls.n	82e8 <__aeabi_d2f+0x30>
    82cc:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    82d0:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    82d4:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
    82d8:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    82dc:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
    82e0:	bf08      	it	eq
    82e2:	f020 0001 	biceq.w	r0, r0, #1
    82e6:	4770      	bx	lr
    82e8:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
    82ec:	d121      	bne.n	8332 <__aeabi_d2f+0x7a>
    82ee:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
    82f2:	bfbc      	itt	lt
    82f4:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
    82f8:	4770      	bxlt	lr
    82fa:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    82fe:	ea4f 5252 	mov.w	r2, r2, lsr #21
    8302:	f1c2 0218 	rsb	r2, r2, #24
    8306:	f1c2 0c20 	rsb	ip, r2, #32
    830a:	fa10 f30c 	lsls.w	r3, r0, ip
    830e:	fa20 f002 	lsr.w	r0, r0, r2
    8312:	bf18      	it	ne
    8314:	f040 0001 	orrne.w	r0, r0, #1
    8318:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    831c:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    8320:	fa03 fc0c 	lsl.w	ip, r3, ip
    8324:	ea40 000c 	orr.w	r0, r0, ip
    8328:	fa23 f302 	lsr.w	r3, r3, r2
    832c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    8330:	e7cc      	b.n	82cc <__aeabi_d2f+0x14>
    8332:	ea7f 5362 	mvns.w	r3, r2, asr #21
    8336:	d107      	bne.n	8348 <__aeabi_d2f+0x90>
    8338:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
    833c:	bf1e      	ittt	ne
    833e:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
    8342:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
    8346:	4770      	bxne	lr
    8348:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
    834c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    8350:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    8354:	4770      	bx	lr
    8356:	bf00      	nop

00008358 <__errno>:
    8358:	4b01      	ldr	r3, [pc, #4]	; (8360 <__errno+0x8>)
    835a:	6818      	ldr	r0, [r3, #0]
    835c:	4770      	bx	lr
    835e:	bf00      	nop
    8360:	1fff1008 	.word	0x1fff1008

00008364 <__libc_init_array>:
    8364:	b570      	push	{r4, r5, r6, lr}
    8366:	4e0f      	ldr	r6, [pc, #60]	; (83a4 <__libc_init_array+0x40>)
    8368:	4d0f      	ldr	r5, [pc, #60]	; (83a8 <__libc_init_array+0x44>)
    836a:	1b76      	subs	r6, r6, r5
    836c:	10b6      	asrs	r6, r6, #2
    836e:	bf18      	it	ne
    8370:	2400      	movne	r4, #0
    8372:	d005      	beq.n	8380 <__libc_init_array+0x1c>
    8374:	3401      	adds	r4, #1
    8376:	f855 3b04 	ldr.w	r3, [r5], #4
    837a:	4798      	blx	r3
    837c:	42a6      	cmp	r6, r4
    837e:	d1f9      	bne.n	8374 <__libc_init_array+0x10>
    8380:	4e0a      	ldr	r6, [pc, #40]	; (83ac <__libc_init_array+0x48>)
    8382:	4d0b      	ldr	r5, [pc, #44]	; (83b0 <__libc_init_array+0x4c>)
    8384:	1b76      	subs	r6, r6, r5
    8386:	f001 fd79 	bl	9e7c <_init>
    838a:	10b6      	asrs	r6, r6, #2
    838c:	bf18      	it	ne
    838e:	2400      	movne	r4, #0
    8390:	d006      	beq.n	83a0 <__libc_init_array+0x3c>
    8392:	3401      	adds	r4, #1
    8394:	f855 3b04 	ldr.w	r3, [r5], #4
    8398:	4798      	blx	r3
    839a:	42a6      	cmp	r6, r4
    839c:	d1f9      	bne.n	8392 <__libc_init_array+0x2e>
    839e:	bd70      	pop	{r4, r5, r6, pc}
    83a0:	bd70      	pop	{r4, r5, r6, pc}
    83a2:	bf00      	nop
    83a4:	00009e88 	.word	0x00009e88
    83a8:	00009e88 	.word	0x00009e88
    83ac:	00009e94 	.word	0x00009e94
    83b0:	00009e88 	.word	0x00009e88

000083b4 <malloc>:
    83b4:	4b02      	ldr	r3, [pc, #8]	; (83c0 <malloc+0xc>)
    83b6:	4601      	mov	r1, r0
    83b8:	6818      	ldr	r0, [r3, #0]
    83ba:	f000 b80b 	b.w	83d4 <_malloc_r>
    83be:	bf00      	nop
    83c0:	1fff1008 	.word	0x1fff1008

000083c4 <free>:
    83c4:	4b02      	ldr	r3, [pc, #8]	; (83d0 <free+0xc>)
    83c6:	4601      	mov	r1, r0
    83c8:	6818      	ldr	r0, [r3, #0]
    83ca:	f001 b839 	b.w	9440 <_free_r>
    83ce:	bf00      	nop
    83d0:	1fff1008 	.word	0x1fff1008

000083d4 <_malloc_r>:
    83d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    83d8:	f101 050b 	add.w	r5, r1, #11
    83dc:	2d16      	cmp	r5, #22
    83de:	b083      	sub	sp, #12
    83e0:	4606      	mov	r6, r0
    83e2:	f240 809f 	bls.w	8524 <_malloc_r+0x150>
    83e6:	f035 0507 	bics.w	r5, r5, #7
    83ea:	f100 80bf 	bmi.w	856c <_malloc_r+0x198>
    83ee:	42a9      	cmp	r1, r5
    83f0:	f200 80bc 	bhi.w	856c <_malloc_r+0x198>
    83f4:	f000 fb58 	bl	8aa8 <__malloc_lock>
    83f8:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
    83fc:	f0c0 829c 	bcc.w	8938 <_malloc_r+0x564>
    8400:	0a6b      	lsrs	r3, r5, #9
    8402:	f000 80ba 	beq.w	857a <_malloc_r+0x1a6>
    8406:	2b04      	cmp	r3, #4
    8408:	f200 8183 	bhi.w	8712 <_malloc_r+0x33e>
    840c:	09a8      	lsrs	r0, r5, #6
    840e:	f100 0e39 	add.w	lr, r0, #57	; 0x39
    8412:	ea4f 034e 	mov.w	r3, lr, lsl #1
    8416:	3038      	adds	r0, #56	; 0x38
    8418:	4fc4      	ldr	r7, [pc, #784]	; (872c <_malloc_r+0x358>)
    841a:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    841e:	f1a3 0108 	sub.w	r1, r3, #8
    8422:	685c      	ldr	r4, [r3, #4]
    8424:	42a1      	cmp	r1, r4
    8426:	d107      	bne.n	8438 <_malloc_r+0x64>
    8428:	e0ac      	b.n	8584 <_malloc_r+0x1b0>
    842a:	2a00      	cmp	r2, #0
    842c:	f280 80ac 	bge.w	8588 <_malloc_r+0x1b4>
    8430:	68e4      	ldr	r4, [r4, #12]
    8432:	42a1      	cmp	r1, r4
    8434:	f000 80a6 	beq.w	8584 <_malloc_r+0x1b0>
    8438:	6863      	ldr	r3, [r4, #4]
    843a:	f023 0303 	bic.w	r3, r3, #3
    843e:	1b5a      	subs	r2, r3, r5
    8440:	2a0f      	cmp	r2, #15
    8442:	ddf2      	ble.n	842a <_malloc_r+0x56>
    8444:	49b9      	ldr	r1, [pc, #740]	; (872c <_malloc_r+0x358>)
    8446:	693c      	ldr	r4, [r7, #16]
    8448:	f101 0e08 	add.w	lr, r1, #8
    844c:	4574      	cmp	r4, lr
    844e:	f000 81b3 	beq.w	87b8 <_malloc_r+0x3e4>
    8452:	6863      	ldr	r3, [r4, #4]
    8454:	f023 0303 	bic.w	r3, r3, #3
    8458:	1b5a      	subs	r2, r3, r5
    845a:	2a0f      	cmp	r2, #15
    845c:	f300 8199 	bgt.w	8792 <_malloc_r+0x3be>
    8460:	2a00      	cmp	r2, #0
    8462:	f8c1 e014 	str.w	lr, [r1, #20]
    8466:	f8c1 e010 	str.w	lr, [r1, #16]
    846a:	f280 809e 	bge.w	85aa <_malloc_r+0x1d6>
    846e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    8472:	f080 8167 	bcs.w	8744 <_malloc_r+0x370>
    8476:	08db      	lsrs	r3, r3, #3
    8478:	f103 0c01 	add.w	ip, r3, #1
    847c:	2201      	movs	r2, #1
    847e:	109b      	asrs	r3, r3, #2
    8480:	fa02 f303 	lsl.w	r3, r2, r3
    8484:	684a      	ldr	r2, [r1, #4]
    8486:	f851 803c 	ldr.w	r8, [r1, ip, lsl #3]
    848a:	f8c4 8008 	str.w	r8, [r4, #8]
    848e:	eb01 09cc 	add.w	r9, r1, ip, lsl #3
    8492:	431a      	orrs	r2, r3
    8494:	f1a9 0308 	sub.w	r3, r9, #8
    8498:	60e3      	str	r3, [r4, #12]
    849a:	604a      	str	r2, [r1, #4]
    849c:	f841 403c 	str.w	r4, [r1, ip, lsl #3]
    84a0:	f8c8 400c 	str.w	r4, [r8, #12]
    84a4:	1083      	asrs	r3, r0, #2
    84a6:	2401      	movs	r4, #1
    84a8:	409c      	lsls	r4, r3
    84aa:	4294      	cmp	r4, r2
    84ac:	f200 808a 	bhi.w	85c4 <_malloc_r+0x1f0>
    84b0:	4214      	tst	r4, r2
    84b2:	d106      	bne.n	84c2 <_malloc_r+0xee>
    84b4:	f020 0003 	bic.w	r0, r0, #3
    84b8:	0064      	lsls	r4, r4, #1
    84ba:	4214      	tst	r4, r2
    84bc:	f100 0004 	add.w	r0, r0, #4
    84c0:	d0fa      	beq.n	84b8 <_malloc_r+0xe4>
    84c2:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
    84c6:	46cc      	mov	ip, r9
    84c8:	4680      	mov	r8, r0
    84ca:	f8dc 100c 	ldr.w	r1, [ip, #12]
    84ce:	458c      	cmp	ip, r1
    84d0:	d107      	bne.n	84e2 <_malloc_r+0x10e>
    84d2:	e173      	b.n	87bc <_malloc_r+0x3e8>
    84d4:	2a00      	cmp	r2, #0
    84d6:	f280 8181 	bge.w	87dc <_malloc_r+0x408>
    84da:	68c9      	ldr	r1, [r1, #12]
    84dc:	458c      	cmp	ip, r1
    84de:	f000 816d 	beq.w	87bc <_malloc_r+0x3e8>
    84e2:	684b      	ldr	r3, [r1, #4]
    84e4:	f023 0303 	bic.w	r3, r3, #3
    84e8:	1b5a      	subs	r2, r3, r5
    84ea:	2a0f      	cmp	r2, #15
    84ec:	ddf2      	ble.n	84d4 <_malloc_r+0x100>
    84ee:	460c      	mov	r4, r1
    84f0:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    84f4:	f854 8f08 	ldr.w	r8, [r4, #8]!
    84f8:	194b      	adds	r3, r1, r5
    84fa:	f045 0501 	orr.w	r5, r5, #1
    84fe:	604d      	str	r5, [r1, #4]
    8500:	f042 0101 	orr.w	r1, r2, #1
    8504:	f8c8 c00c 	str.w	ip, [r8, #12]
    8508:	4630      	mov	r0, r6
    850a:	f8cc 8008 	str.w	r8, [ip, #8]
    850e:	617b      	str	r3, [r7, #20]
    8510:	613b      	str	r3, [r7, #16]
    8512:	f8c3 e00c 	str.w	lr, [r3, #12]
    8516:	f8c3 e008 	str.w	lr, [r3, #8]
    851a:	6059      	str	r1, [r3, #4]
    851c:	509a      	str	r2, [r3, r2]
    851e:	f000 fac5 	bl	8aac <__malloc_unlock>
    8522:	e01f      	b.n	8564 <_malloc_r+0x190>
    8524:	2910      	cmp	r1, #16
    8526:	d821      	bhi.n	856c <_malloc_r+0x198>
    8528:	f000 fabe 	bl	8aa8 <__malloc_lock>
    852c:	2510      	movs	r5, #16
    852e:	2306      	movs	r3, #6
    8530:	2002      	movs	r0, #2
    8532:	4f7e      	ldr	r7, [pc, #504]	; (872c <_malloc_r+0x358>)
    8534:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    8538:	f1a3 0208 	sub.w	r2, r3, #8
    853c:	685c      	ldr	r4, [r3, #4]
    853e:	4294      	cmp	r4, r2
    8540:	f000 8145 	beq.w	87ce <_malloc_r+0x3fa>
    8544:	6863      	ldr	r3, [r4, #4]
    8546:	68e1      	ldr	r1, [r4, #12]
    8548:	68a5      	ldr	r5, [r4, #8]
    854a:	f023 0303 	bic.w	r3, r3, #3
    854e:	4423      	add	r3, r4
    8550:	4630      	mov	r0, r6
    8552:	685a      	ldr	r2, [r3, #4]
    8554:	60e9      	str	r1, [r5, #12]
    8556:	f042 0201 	orr.w	r2, r2, #1
    855a:	608d      	str	r5, [r1, #8]
    855c:	605a      	str	r2, [r3, #4]
    855e:	f000 faa5 	bl	8aac <__malloc_unlock>
    8562:	3408      	adds	r4, #8
    8564:	4620      	mov	r0, r4
    8566:	b003      	add	sp, #12
    8568:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    856c:	2400      	movs	r4, #0
    856e:	230c      	movs	r3, #12
    8570:	4620      	mov	r0, r4
    8572:	6033      	str	r3, [r6, #0]
    8574:	b003      	add	sp, #12
    8576:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    857a:	2380      	movs	r3, #128	; 0x80
    857c:	f04f 0e40 	mov.w	lr, #64	; 0x40
    8580:	203f      	movs	r0, #63	; 0x3f
    8582:	e749      	b.n	8418 <_malloc_r+0x44>
    8584:	4670      	mov	r0, lr
    8586:	e75d      	b.n	8444 <_malloc_r+0x70>
    8588:	4423      	add	r3, r4
    858a:	68e1      	ldr	r1, [r4, #12]
    858c:	685a      	ldr	r2, [r3, #4]
    858e:	68a5      	ldr	r5, [r4, #8]
    8590:	f042 0201 	orr.w	r2, r2, #1
    8594:	60e9      	str	r1, [r5, #12]
    8596:	4630      	mov	r0, r6
    8598:	608d      	str	r5, [r1, #8]
    859a:	605a      	str	r2, [r3, #4]
    859c:	f000 fa86 	bl	8aac <__malloc_unlock>
    85a0:	3408      	adds	r4, #8
    85a2:	4620      	mov	r0, r4
    85a4:	b003      	add	sp, #12
    85a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    85aa:	4423      	add	r3, r4
    85ac:	4630      	mov	r0, r6
    85ae:	685a      	ldr	r2, [r3, #4]
    85b0:	f042 0201 	orr.w	r2, r2, #1
    85b4:	605a      	str	r2, [r3, #4]
    85b6:	f000 fa79 	bl	8aac <__malloc_unlock>
    85ba:	3408      	adds	r4, #8
    85bc:	4620      	mov	r0, r4
    85be:	b003      	add	sp, #12
    85c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    85c4:	68bc      	ldr	r4, [r7, #8]
    85c6:	6863      	ldr	r3, [r4, #4]
    85c8:	f023 0803 	bic.w	r8, r3, #3
    85cc:	45a8      	cmp	r8, r5
    85ce:	d304      	bcc.n	85da <_malloc_r+0x206>
    85d0:	ebc5 0308 	rsb	r3, r5, r8
    85d4:	2b0f      	cmp	r3, #15
    85d6:	f300 808c 	bgt.w	86f2 <_malloc_r+0x31e>
    85da:	4b55      	ldr	r3, [pc, #340]	; (8730 <_malloc_r+0x35c>)
    85dc:	f8df 9160 	ldr.w	r9, [pc, #352]	; 8740 <_malloc_r+0x36c>
    85e0:	681a      	ldr	r2, [r3, #0]
    85e2:	f8d9 3000 	ldr.w	r3, [r9]
    85e6:	3301      	adds	r3, #1
    85e8:	442a      	add	r2, r5
    85ea:	eb04 0a08 	add.w	sl, r4, r8
    85ee:	f000 8160 	beq.w	88b2 <_malloc_r+0x4de>
    85f2:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    85f6:	320f      	adds	r2, #15
    85f8:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
    85fc:	f022 020f 	bic.w	r2, r2, #15
    8600:	4611      	mov	r1, r2
    8602:	4630      	mov	r0, r6
    8604:	9201      	str	r2, [sp, #4]
    8606:	f000 fc4b 	bl	8ea0 <_sbrk_r>
    860a:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    860e:	4683      	mov	fp, r0
    8610:	9a01      	ldr	r2, [sp, #4]
    8612:	f000 8158 	beq.w	88c6 <_malloc_r+0x4f2>
    8616:	4582      	cmp	sl, r0
    8618:	f200 80fc 	bhi.w	8814 <_malloc_r+0x440>
    861c:	4b45      	ldr	r3, [pc, #276]	; (8734 <_malloc_r+0x360>)
    861e:	6819      	ldr	r1, [r3, #0]
    8620:	45da      	cmp	sl, fp
    8622:	4411      	add	r1, r2
    8624:	6019      	str	r1, [r3, #0]
    8626:	f000 8153 	beq.w	88d0 <_malloc_r+0x4fc>
    862a:	f8d9 0000 	ldr.w	r0, [r9]
    862e:	f8df e110 	ldr.w	lr, [pc, #272]	; 8740 <_malloc_r+0x36c>
    8632:	3001      	adds	r0, #1
    8634:	bf1b      	ittet	ne
    8636:	ebca 0a0b 	rsbne	sl, sl, fp
    863a:	4451      	addne	r1, sl
    863c:	f8ce b000 	streq.w	fp, [lr]
    8640:	6019      	strne	r1, [r3, #0]
    8642:	f01b 0107 	ands.w	r1, fp, #7
    8646:	f000 8117 	beq.w	8878 <_malloc_r+0x4a4>
    864a:	f1c1 0008 	rsb	r0, r1, #8
    864e:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
    8652:	4483      	add	fp, r0
    8654:	3108      	adds	r1, #8
    8656:	445a      	add	r2, fp
    8658:	f3c2 020b 	ubfx	r2, r2, #0, #12
    865c:	ebc2 0901 	rsb	r9, r2, r1
    8660:	4649      	mov	r1, r9
    8662:	4630      	mov	r0, r6
    8664:	9301      	str	r3, [sp, #4]
    8666:	f000 fc1b 	bl	8ea0 <_sbrk_r>
    866a:	1c43      	adds	r3, r0, #1
    866c:	9b01      	ldr	r3, [sp, #4]
    866e:	f000 813f 	beq.w	88f0 <_malloc_r+0x51c>
    8672:	ebcb 0200 	rsb	r2, fp, r0
    8676:	444a      	add	r2, r9
    8678:	f042 0201 	orr.w	r2, r2, #1
    867c:	6819      	ldr	r1, [r3, #0]
    867e:	f8c7 b008 	str.w	fp, [r7, #8]
    8682:	4449      	add	r1, r9
    8684:	42bc      	cmp	r4, r7
    8686:	f8cb 2004 	str.w	r2, [fp, #4]
    868a:	6019      	str	r1, [r3, #0]
    868c:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 8734 <_malloc_r+0x360>
    8690:	d016      	beq.n	86c0 <_malloc_r+0x2ec>
    8692:	f1b8 0f0f 	cmp.w	r8, #15
    8696:	f240 80fd 	bls.w	8894 <_malloc_r+0x4c0>
    869a:	6862      	ldr	r2, [r4, #4]
    869c:	f1a8 030c 	sub.w	r3, r8, #12
    86a0:	f023 0307 	bic.w	r3, r3, #7
    86a4:	18e0      	adds	r0, r4, r3
    86a6:	f002 0201 	and.w	r2, r2, #1
    86aa:	f04f 0e05 	mov.w	lr, #5
    86ae:	431a      	orrs	r2, r3
    86b0:	2b0f      	cmp	r3, #15
    86b2:	6062      	str	r2, [r4, #4]
    86b4:	f8c0 e004 	str.w	lr, [r0, #4]
    86b8:	f8c0 e008 	str.w	lr, [r0, #8]
    86bc:	f200 811c 	bhi.w	88f8 <_malloc_r+0x524>
    86c0:	4b1d      	ldr	r3, [pc, #116]	; (8738 <_malloc_r+0x364>)
    86c2:	68bc      	ldr	r4, [r7, #8]
    86c4:	681a      	ldr	r2, [r3, #0]
    86c6:	4291      	cmp	r1, r2
    86c8:	bf88      	it	hi
    86ca:	6019      	strhi	r1, [r3, #0]
    86cc:	4b1b      	ldr	r3, [pc, #108]	; (873c <_malloc_r+0x368>)
    86ce:	681a      	ldr	r2, [r3, #0]
    86d0:	4291      	cmp	r1, r2
    86d2:	6862      	ldr	r2, [r4, #4]
    86d4:	bf88      	it	hi
    86d6:	6019      	strhi	r1, [r3, #0]
    86d8:	f022 0203 	bic.w	r2, r2, #3
    86dc:	4295      	cmp	r5, r2
    86de:	eba2 0305 	sub.w	r3, r2, r5
    86e2:	d801      	bhi.n	86e8 <_malloc_r+0x314>
    86e4:	2b0f      	cmp	r3, #15
    86e6:	dc04      	bgt.n	86f2 <_malloc_r+0x31e>
    86e8:	4630      	mov	r0, r6
    86ea:	f000 f9df 	bl	8aac <__malloc_unlock>
    86ee:	2400      	movs	r4, #0
    86f0:	e738      	b.n	8564 <_malloc_r+0x190>
    86f2:	1962      	adds	r2, r4, r5
    86f4:	f043 0301 	orr.w	r3, r3, #1
    86f8:	f045 0501 	orr.w	r5, r5, #1
    86fc:	6065      	str	r5, [r4, #4]
    86fe:	4630      	mov	r0, r6
    8700:	60ba      	str	r2, [r7, #8]
    8702:	6053      	str	r3, [r2, #4]
    8704:	f000 f9d2 	bl	8aac <__malloc_unlock>
    8708:	3408      	adds	r4, #8
    870a:	4620      	mov	r0, r4
    870c:	b003      	add	sp, #12
    870e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8712:	2b14      	cmp	r3, #20
    8714:	d971      	bls.n	87fa <_malloc_r+0x426>
    8716:	2b54      	cmp	r3, #84	; 0x54
    8718:	f200 80a4 	bhi.w	8864 <_malloc_r+0x490>
    871c:	0b28      	lsrs	r0, r5, #12
    871e:	f100 0e6f 	add.w	lr, r0, #111	; 0x6f
    8722:	ea4f 034e 	mov.w	r3, lr, lsl #1
    8726:	306e      	adds	r0, #110	; 0x6e
    8728:	e676      	b.n	8418 <_malloc_r+0x44>
    872a:	bf00      	nop
    872c:	1fff100c 	.word	0x1fff100c
    8730:	1fff2cdc 	.word	0x1fff2cdc
    8734:	1fff2ce0 	.word	0x1fff2ce0
    8738:	1fff2cd8 	.word	0x1fff2cd8
    873c:	1fff2cd4 	.word	0x1fff2cd4
    8740:	1fff1418 	.word	0x1fff1418
    8744:	0a5a      	lsrs	r2, r3, #9
    8746:	2a04      	cmp	r2, #4
    8748:	d95e      	bls.n	8808 <_malloc_r+0x434>
    874a:	2a14      	cmp	r2, #20
    874c:	f200 80b3 	bhi.w	88b6 <_malloc_r+0x4e2>
    8750:	f102 015c 	add.w	r1, r2, #92	; 0x5c
    8754:	0049      	lsls	r1, r1, #1
    8756:	325b      	adds	r2, #91	; 0x5b
    8758:	eb07 0c81 	add.w	ip, r7, r1, lsl #2
    875c:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
    8760:	f8df 81dc 	ldr.w	r8, [pc, #476]	; 8940 <_malloc_r+0x56c>
    8764:	f1ac 0c08 	sub.w	ip, ip, #8
    8768:	458c      	cmp	ip, r1
    876a:	f000 8088 	beq.w	887e <_malloc_r+0x4aa>
    876e:	684a      	ldr	r2, [r1, #4]
    8770:	f022 0203 	bic.w	r2, r2, #3
    8774:	4293      	cmp	r3, r2
    8776:	d202      	bcs.n	877e <_malloc_r+0x3aa>
    8778:	6889      	ldr	r1, [r1, #8]
    877a:	458c      	cmp	ip, r1
    877c:	d1f7      	bne.n	876e <_malloc_r+0x39a>
    877e:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    8782:	687a      	ldr	r2, [r7, #4]
    8784:	f8c4 c00c 	str.w	ip, [r4, #12]
    8788:	60a1      	str	r1, [r4, #8]
    878a:	f8cc 4008 	str.w	r4, [ip, #8]
    878e:	60cc      	str	r4, [r1, #12]
    8790:	e688      	b.n	84a4 <_malloc_r+0xd0>
    8792:	1963      	adds	r3, r4, r5
    8794:	f042 0701 	orr.w	r7, r2, #1
    8798:	f045 0501 	orr.w	r5, r5, #1
    879c:	6065      	str	r5, [r4, #4]
    879e:	4630      	mov	r0, r6
    87a0:	614b      	str	r3, [r1, #20]
    87a2:	610b      	str	r3, [r1, #16]
    87a4:	f8c3 e00c 	str.w	lr, [r3, #12]
    87a8:	f8c3 e008 	str.w	lr, [r3, #8]
    87ac:	605f      	str	r7, [r3, #4]
    87ae:	509a      	str	r2, [r3, r2]
    87b0:	3408      	adds	r4, #8
    87b2:	f000 f97b 	bl	8aac <__malloc_unlock>
    87b6:	e6d5      	b.n	8564 <_malloc_r+0x190>
    87b8:	684a      	ldr	r2, [r1, #4]
    87ba:	e673      	b.n	84a4 <_malloc_r+0xd0>
    87bc:	f108 0801 	add.w	r8, r8, #1
    87c0:	f018 0f03 	tst.w	r8, #3
    87c4:	f10c 0c08 	add.w	ip, ip, #8
    87c8:	f47f ae7f 	bne.w	84ca <_malloc_r+0xf6>
    87cc:	e030      	b.n	8830 <_malloc_r+0x45c>
    87ce:	68dc      	ldr	r4, [r3, #12]
    87d0:	42a3      	cmp	r3, r4
    87d2:	bf08      	it	eq
    87d4:	3002      	addeq	r0, #2
    87d6:	f43f ae35 	beq.w	8444 <_malloc_r+0x70>
    87da:	e6b3      	b.n	8544 <_malloc_r+0x170>
    87dc:	440b      	add	r3, r1
    87de:	460c      	mov	r4, r1
    87e0:	685a      	ldr	r2, [r3, #4]
    87e2:	68c9      	ldr	r1, [r1, #12]
    87e4:	f854 5f08 	ldr.w	r5, [r4, #8]!
    87e8:	f042 0201 	orr.w	r2, r2, #1
    87ec:	605a      	str	r2, [r3, #4]
    87ee:	4630      	mov	r0, r6
    87f0:	60e9      	str	r1, [r5, #12]
    87f2:	608d      	str	r5, [r1, #8]
    87f4:	f000 f95a 	bl	8aac <__malloc_unlock>
    87f8:	e6b4      	b.n	8564 <_malloc_r+0x190>
    87fa:	f103 0e5c 	add.w	lr, r3, #92	; 0x5c
    87fe:	f103 005b 	add.w	r0, r3, #91	; 0x5b
    8802:	ea4f 034e 	mov.w	r3, lr, lsl #1
    8806:	e607      	b.n	8418 <_malloc_r+0x44>
    8808:	099a      	lsrs	r2, r3, #6
    880a:	f102 0139 	add.w	r1, r2, #57	; 0x39
    880e:	0049      	lsls	r1, r1, #1
    8810:	3238      	adds	r2, #56	; 0x38
    8812:	e7a1      	b.n	8758 <_malloc_r+0x384>
    8814:	42bc      	cmp	r4, r7
    8816:	4b4a      	ldr	r3, [pc, #296]	; (8940 <_malloc_r+0x56c>)
    8818:	f43f af00 	beq.w	861c <_malloc_r+0x248>
    881c:	689c      	ldr	r4, [r3, #8]
    881e:	6862      	ldr	r2, [r4, #4]
    8820:	f022 0203 	bic.w	r2, r2, #3
    8824:	e75a      	b.n	86dc <_malloc_r+0x308>
    8826:	f859 3908 	ldr.w	r3, [r9], #-8
    882a:	4599      	cmp	r9, r3
    882c:	f040 8082 	bne.w	8934 <_malloc_r+0x560>
    8830:	f010 0f03 	tst.w	r0, #3
    8834:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
    8838:	d1f5      	bne.n	8826 <_malloc_r+0x452>
    883a:	687b      	ldr	r3, [r7, #4]
    883c:	ea23 0304 	bic.w	r3, r3, r4
    8840:	607b      	str	r3, [r7, #4]
    8842:	0064      	lsls	r4, r4, #1
    8844:	429c      	cmp	r4, r3
    8846:	f63f aebd 	bhi.w	85c4 <_malloc_r+0x1f0>
    884a:	2c00      	cmp	r4, #0
    884c:	f43f aeba 	beq.w	85c4 <_malloc_r+0x1f0>
    8850:	421c      	tst	r4, r3
    8852:	4640      	mov	r0, r8
    8854:	f47f ae35 	bne.w	84c2 <_malloc_r+0xee>
    8858:	0064      	lsls	r4, r4, #1
    885a:	421c      	tst	r4, r3
    885c:	f100 0004 	add.w	r0, r0, #4
    8860:	d0fa      	beq.n	8858 <_malloc_r+0x484>
    8862:	e62e      	b.n	84c2 <_malloc_r+0xee>
    8864:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
    8868:	d818      	bhi.n	889c <_malloc_r+0x4c8>
    886a:	0be8      	lsrs	r0, r5, #15
    886c:	f100 0e78 	add.w	lr, r0, #120	; 0x78
    8870:	ea4f 034e 	mov.w	r3, lr, lsl #1
    8874:	3077      	adds	r0, #119	; 0x77
    8876:	e5cf      	b.n	8418 <_malloc_r+0x44>
    8878:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    887c:	e6eb      	b.n	8656 <_malloc_r+0x282>
    887e:	2101      	movs	r1, #1
    8880:	f8d8 3004 	ldr.w	r3, [r8, #4]
    8884:	1092      	asrs	r2, r2, #2
    8886:	fa01 f202 	lsl.w	r2, r1, r2
    888a:	431a      	orrs	r2, r3
    888c:	f8c8 2004 	str.w	r2, [r8, #4]
    8890:	4661      	mov	r1, ip
    8892:	e777      	b.n	8784 <_malloc_r+0x3b0>
    8894:	2301      	movs	r3, #1
    8896:	f8cb 3004 	str.w	r3, [fp, #4]
    889a:	e725      	b.n	86e8 <_malloc_r+0x314>
    889c:	f240 5254 	movw	r2, #1364	; 0x554
    88a0:	4293      	cmp	r3, r2
    88a2:	d820      	bhi.n	88e6 <_malloc_r+0x512>
    88a4:	0ca8      	lsrs	r0, r5, #18
    88a6:	f100 0e7d 	add.w	lr, r0, #125	; 0x7d
    88aa:	ea4f 034e 	mov.w	r3, lr, lsl #1
    88ae:	307c      	adds	r0, #124	; 0x7c
    88b0:	e5b2      	b.n	8418 <_malloc_r+0x44>
    88b2:	3210      	adds	r2, #16
    88b4:	e6a4      	b.n	8600 <_malloc_r+0x22c>
    88b6:	2a54      	cmp	r2, #84	; 0x54
    88b8:	d826      	bhi.n	8908 <_malloc_r+0x534>
    88ba:	0b1a      	lsrs	r2, r3, #12
    88bc:	f102 016f 	add.w	r1, r2, #111	; 0x6f
    88c0:	0049      	lsls	r1, r1, #1
    88c2:	326e      	adds	r2, #110	; 0x6e
    88c4:	e748      	b.n	8758 <_malloc_r+0x384>
    88c6:	68bc      	ldr	r4, [r7, #8]
    88c8:	6862      	ldr	r2, [r4, #4]
    88ca:	f022 0203 	bic.w	r2, r2, #3
    88ce:	e705      	b.n	86dc <_malloc_r+0x308>
    88d0:	f3ca 000b 	ubfx	r0, sl, #0, #12
    88d4:	2800      	cmp	r0, #0
    88d6:	f47f aea8 	bne.w	862a <_malloc_r+0x256>
    88da:	4442      	add	r2, r8
    88dc:	68bb      	ldr	r3, [r7, #8]
    88de:	f042 0201 	orr.w	r2, r2, #1
    88e2:	605a      	str	r2, [r3, #4]
    88e4:	e6ec      	b.n	86c0 <_malloc_r+0x2ec>
    88e6:	23fe      	movs	r3, #254	; 0xfe
    88e8:	f04f 0e7f 	mov.w	lr, #127	; 0x7f
    88ec:	207e      	movs	r0, #126	; 0x7e
    88ee:	e593      	b.n	8418 <_malloc_r+0x44>
    88f0:	2201      	movs	r2, #1
    88f2:	f04f 0900 	mov.w	r9, #0
    88f6:	e6c1      	b.n	867c <_malloc_r+0x2a8>
    88f8:	f104 0108 	add.w	r1, r4, #8
    88fc:	4630      	mov	r0, r6
    88fe:	f000 fd9f 	bl	9440 <_free_r>
    8902:	f8d9 1000 	ldr.w	r1, [r9]
    8906:	e6db      	b.n	86c0 <_malloc_r+0x2ec>
    8908:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    890c:	d805      	bhi.n	891a <_malloc_r+0x546>
    890e:	0bda      	lsrs	r2, r3, #15
    8910:	f102 0178 	add.w	r1, r2, #120	; 0x78
    8914:	0049      	lsls	r1, r1, #1
    8916:	3277      	adds	r2, #119	; 0x77
    8918:	e71e      	b.n	8758 <_malloc_r+0x384>
    891a:	f240 5154 	movw	r1, #1364	; 0x554
    891e:	428a      	cmp	r2, r1
    8920:	d805      	bhi.n	892e <_malloc_r+0x55a>
    8922:	0c9a      	lsrs	r2, r3, #18
    8924:	f102 017d 	add.w	r1, r2, #125	; 0x7d
    8928:	0049      	lsls	r1, r1, #1
    892a:	327c      	adds	r2, #124	; 0x7c
    892c:	e714      	b.n	8758 <_malloc_r+0x384>
    892e:	21fe      	movs	r1, #254	; 0xfe
    8930:	227e      	movs	r2, #126	; 0x7e
    8932:	e711      	b.n	8758 <_malloc_r+0x384>
    8934:	687b      	ldr	r3, [r7, #4]
    8936:	e784      	b.n	8842 <_malloc_r+0x46e>
    8938:	08e8      	lsrs	r0, r5, #3
    893a:	1c43      	adds	r3, r0, #1
    893c:	005b      	lsls	r3, r3, #1
    893e:	e5f8      	b.n	8532 <_malloc_r+0x15e>
    8940:	1fff100c 	.word	0x1fff100c

00008944 <memmove>:
    8944:	4288      	cmp	r0, r1
    8946:	b5f0      	push	{r4, r5, r6, r7, lr}
    8948:	d90d      	bls.n	8966 <memmove+0x22>
    894a:	188b      	adds	r3, r1, r2
    894c:	4298      	cmp	r0, r3
    894e:	d20a      	bcs.n	8966 <memmove+0x22>
    8950:	1881      	adds	r1, r0, r2
    8952:	2a00      	cmp	r2, #0
    8954:	d051      	beq.n	89fa <memmove+0xb6>
    8956:	1a9a      	subs	r2, r3, r2
    8958:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
    895c:	f801 4d01 	strb.w	r4, [r1, #-1]!
    8960:	4293      	cmp	r3, r2
    8962:	d1f9      	bne.n	8958 <memmove+0x14>
    8964:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8966:	2a0f      	cmp	r2, #15
    8968:	d948      	bls.n	89fc <memmove+0xb8>
    896a:	ea41 0300 	orr.w	r3, r1, r0
    896e:	079b      	lsls	r3, r3, #30
    8970:	d146      	bne.n	8a00 <memmove+0xbc>
    8972:	f100 0410 	add.w	r4, r0, #16
    8976:	f101 0310 	add.w	r3, r1, #16
    897a:	4615      	mov	r5, r2
    897c:	f853 6c10 	ldr.w	r6, [r3, #-16]
    8980:	f844 6c10 	str.w	r6, [r4, #-16]
    8984:	f853 6c0c 	ldr.w	r6, [r3, #-12]
    8988:	f844 6c0c 	str.w	r6, [r4, #-12]
    898c:	f853 6c08 	ldr.w	r6, [r3, #-8]
    8990:	f844 6c08 	str.w	r6, [r4, #-8]
    8994:	3d10      	subs	r5, #16
    8996:	f853 6c04 	ldr.w	r6, [r3, #-4]
    899a:	f844 6c04 	str.w	r6, [r4, #-4]
    899e:	2d0f      	cmp	r5, #15
    89a0:	f103 0310 	add.w	r3, r3, #16
    89a4:	f104 0410 	add.w	r4, r4, #16
    89a8:	d8e8      	bhi.n	897c <memmove+0x38>
    89aa:	f1a2 0310 	sub.w	r3, r2, #16
    89ae:	f023 030f 	bic.w	r3, r3, #15
    89b2:	f002 0e0f 	and.w	lr, r2, #15
    89b6:	3310      	adds	r3, #16
    89b8:	f1be 0f03 	cmp.w	lr, #3
    89bc:	4419      	add	r1, r3
    89be:	4403      	add	r3, r0
    89c0:	d921      	bls.n	8a06 <memmove+0xc2>
    89c2:	1f1e      	subs	r6, r3, #4
    89c4:	460d      	mov	r5, r1
    89c6:	4674      	mov	r4, lr
    89c8:	3c04      	subs	r4, #4
    89ca:	f855 7b04 	ldr.w	r7, [r5], #4
    89ce:	f846 7f04 	str.w	r7, [r6, #4]!
    89d2:	2c03      	cmp	r4, #3
    89d4:	d8f8      	bhi.n	89c8 <memmove+0x84>
    89d6:	f1ae 0404 	sub.w	r4, lr, #4
    89da:	f024 0403 	bic.w	r4, r4, #3
    89de:	3404      	adds	r4, #4
    89e0:	4423      	add	r3, r4
    89e2:	4421      	add	r1, r4
    89e4:	f002 0203 	and.w	r2, r2, #3
    89e8:	b162      	cbz	r2, 8a04 <memmove+0xc0>
    89ea:	3b01      	subs	r3, #1
    89ec:	440a      	add	r2, r1
    89ee:	f811 4b01 	ldrb.w	r4, [r1], #1
    89f2:	f803 4f01 	strb.w	r4, [r3, #1]!
    89f6:	428a      	cmp	r2, r1
    89f8:	d1f9      	bne.n	89ee <memmove+0xaa>
    89fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    89fc:	4603      	mov	r3, r0
    89fe:	e7f3      	b.n	89e8 <memmove+0xa4>
    8a00:	4603      	mov	r3, r0
    8a02:	e7f2      	b.n	89ea <memmove+0xa6>
    8a04:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8a06:	4672      	mov	r2, lr
    8a08:	e7ee      	b.n	89e8 <memmove+0xa4>
    8a0a:	bf00      	nop

00008a0c <memset>:
    8a0c:	b470      	push	{r4, r5, r6}
    8a0e:	0784      	lsls	r4, r0, #30
    8a10:	d046      	beq.n	8aa0 <memset+0x94>
    8a12:	1e54      	subs	r4, r2, #1
    8a14:	2a00      	cmp	r2, #0
    8a16:	d041      	beq.n	8a9c <memset+0x90>
    8a18:	b2cd      	uxtb	r5, r1
    8a1a:	4603      	mov	r3, r0
    8a1c:	e002      	b.n	8a24 <memset+0x18>
    8a1e:	1e62      	subs	r2, r4, #1
    8a20:	b3e4      	cbz	r4, 8a9c <memset+0x90>
    8a22:	4614      	mov	r4, r2
    8a24:	f803 5b01 	strb.w	r5, [r3], #1
    8a28:	079a      	lsls	r2, r3, #30
    8a2a:	d1f8      	bne.n	8a1e <memset+0x12>
    8a2c:	2c03      	cmp	r4, #3
    8a2e:	d92e      	bls.n	8a8e <memset+0x82>
    8a30:	b2cd      	uxtb	r5, r1
    8a32:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    8a36:	2c0f      	cmp	r4, #15
    8a38:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    8a3c:	d919      	bls.n	8a72 <memset+0x66>
    8a3e:	f103 0210 	add.w	r2, r3, #16
    8a42:	4626      	mov	r6, r4
    8a44:	3e10      	subs	r6, #16
    8a46:	2e0f      	cmp	r6, #15
    8a48:	f842 5c10 	str.w	r5, [r2, #-16]
    8a4c:	f842 5c0c 	str.w	r5, [r2, #-12]
    8a50:	f842 5c08 	str.w	r5, [r2, #-8]
    8a54:	f842 5c04 	str.w	r5, [r2, #-4]
    8a58:	f102 0210 	add.w	r2, r2, #16
    8a5c:	d8f2      	bhi.n	8a44 <memset+0x38>
    8a5e:	f1a4 0210 	sub.w	r2, r4, #16
    8a62:	f022 020f 	bic.w	r2, r2, #15
    8a66:	f004 040f 	and.w	r4, r4, #15
    8a6a:	3210      	adds	r2, #16
    8a6c:	2c03      	cmp	r4, #3
    8a6e:	4413      	add	r3, r2
    8a70:	d90d      	bls.n	8a8e <memset+0x82>
    8a72:	461e      	mov	r6, r3
    8a74:	4622      	mov	r2, r4
    8a76:	3a04      	subs	r2, #4
    8a78:	2a03      	cmp	r2, #3
    8a7a:	f846 5b04 	str.w	r5, [r6], #4
    8a7e:	d8fa      	bhi.n	8a76 <memset+0x6a>
    8a80:	1f22      	subs	r2, r4, #4
    8a82:	f022 0203 	bic.w	r2, r2, #3
    8a86:	3204      	adds	r2, #4
    8a88:	4413      	add	r3, r2
    8a8a:	f004 0403 	and.w	r4, r4, #3
    8a8e:	b12c      	cbz	r4, 8a9c <memset+0x90>
    8a90:	b2c9      	uxtb	r1, r1
    8a92:	441c      	add	r4, r3
    8a94:	f803 1b01 	strb.w	r1, [r3], #1
    8a98:	42a3      	cmp	r3, r4
    8a9a:	d1fb      	bne.n	8a94 <memset+0x88>
    8a9c:	bc70      	pop	{r4, r5, r6}
    8a9e:	4770      	bx	lr
    8aa0:	4614      	mov	r4, r2
    8aa2:	4603      	mov	r3, r0
    8aa4:	e7c2      	b.n	8a2c <memset+0x20>
    8aa6:	bf00      	nop

00008aa8 <__malloc_lock>:
    8aa8:	4770      	bx	lr
    8aaa:	bf00      	nop

00008aac <__malloc_unlock>:
    8aac:	4770      	bx	lr
    8aae:	bf00      	nop

00008ab0 <realloc>:
    8ab0:	4b02      	ldr	r3, [pc, #8]	; (8abc <realloc+0xc>)
    8ab2:	460a      	mov	r2, r1
    8ab4:	4601      	mov	r1, r0
    8ab6:	6818      	ldr	r0, [r3, #0]
    8ab8:	f000 b802 	b.w	8ac0 <_realloc_r>
    8abc:	1fff1008 	.word	0x1fff1008

00008ac0 <_realloc_r>:
    8ac0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8ac4:	4617      	mov	r7, r2
    8ac6:	b083      	sub	sp, #12
    8ac8:	2900      	cmp	r1, #0
    8aca:	f000 80c1 	beq.w	8c50 <_realloc_r+0x190>
    8ace:	460e      	mov	r6, r1
    8ad0:	4681      	mov	r9, r0
    8ad2:	f107 050b 	add.w	r5, r7, #11
    8ad6:	f7ff ffe7 	bl	8aa8 <__malloc_lock>
    8ada:	f856 ec04 	ldr.w	lr, [r6, #-4]
    8ade:	2d16      	cmp	r5, #22
    8ae0:	f02e 0403 	bic.w	r4, lr, #3
    8ae4:	f1a6 0808 	sub.w	r8, r6, #8
    8ae8:	d840      	bhi.n	8b6c <_realloc_r+0xac>
    8aea:	2210      	movs	r2, #16
    8aec:	4615      	mov	r5, r2
    8aee:	42af      	cmp	r7, r5
    8af0:	d841      	bhi.n	8b76 <_realloc_r+0xb6>
    8af2:	4294      	cmp	r4, r2
    8af4:	da75      	bge.n	8be2 <_realloc_r+0x122>
    8af6:	4bc9      	ldr	r3, [pc, #804]	; (8e1c <_realloc_r+0x35c>)
    8af8:	6899      	ldr	r1, [r3, #8]
    8afa:	eb08 0004 	add.w	r0, r8, r4
    8afe:	4288      	cmp	r0, r1
    8b00:	6841      	ldr	r1, [r0, #4]
    8b02:	f000 80d9 	beq.w	8cb8 <_realloc_r+0x1f8>
    8b06:	f021 0301 	bic.w	r3, r1, #1
    8b0a:	4403      	add	r3, r0
    8b0c:	685b      	ldr	r3, [r3, #4]
    8b0e:	07db      	lsls	r3, r3, #31
    8b10:	d57d      	bpl.n	8c0e <_realloc_r+0x14e>
    8b12:	f01e 0f01 	tst.w	lr, #1
    8b16:	d035      	beq.n	8b84 <_realloc_r+0xc4>
    8b18:	4639      	mov	r1, r7
    8b1a:	4648      	mov	r0, r9
    8b1c:	f7ff fc5a 	bl	83d4 <_malloc_r>
    8b20:	4607      	mov	r7, r0
    8b22:	b1e0      	cbz	r0, 8b5e <_realloc_r+0x9e>
    8b24:	f856 3c04 	ldr.w	r3, [r6, #-4]
    8b28:	f023 0301 	bic.w	r3, r3, #1
    8b2c:	4443      	add	r3, r8
    8b2e:	f1a0 0208 	sub.w	r2, r0, #8
    8b32:	429a      	cmp	r2, r3
    8b34:	f000 8144 	beq.w	8dc0 <_realloc_r+0x300>
    8b38:	1f22      	subs	r2, r4, #4
    8b3a:	2a24      	cmp	r2, #36	; 0x24
    8b3c:	f200 8131 	bhi.w	8da2 <_realloc_r+0x2e2>
    8b40:	2a13      	cmp	r2, #19
    8b42:	f200 8104 	bhi.w	8d4e <_realloc_r+0x28e>
    8b46:	4603      	mov	r3, r0
    8b48:	4632      	mov	r2, r6
    8b4a:	6811      	ldr	r1, [r2, #0]
    8b4c:	6019      	str	r1, [r3, #0]
    8b4e:	6851      	ldr	r1, [r2, #4]
    8b50:	6059      	str	r1, [r3, #4]
    8b52:	6892      	ldr	r2, [r2, #8]
    8b54:	609a      	str	r2, [r3, #8]
    8b56:	4631      	mov	r1, r6
    8b58:	4648      	mov	r0, r9
    8b5a:	f000 fc71 	bl	9440 <_free_r>
    8b5e:	4648      	mov	r0, r9
    8b60:	f7ff ffa4 	bl	8aac <__malloc_unlock>
    8b64:	4638      	mov	r0, r7
    8b66:	b003      	add	sp, #12
    8b68:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8b6c:	f025 0507 	bic.w	r5, r5, #7
    8b70:	2d00      	cmp	r5, #0
    8b72:	462a      	mov	r2, r5
    8b74:	dabb      	bge.n	8aee <_realloc_r+0x2e>
    8b76:	230c      	movs	r3, #12
    8b78:	2000      	movs	r0, #0
    8b7a:	f8c9 3000 	str.w	r3, [r9]
    8b7e:	b003      	add	sp, #12
    8b80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8b84:	f856 3c08 	ldr.w	r3, [r6, #-8]
    8b88:	ebc3 0a08 	rsb	sl, r3, r8
    8b8c:	f8da 3004 	ldr.w	r3, [sl, #4]
    8b90:	f023 0c03 	bic.w	ip, r3, #3
    8b94:	eb04 030c 	add.w	r3, r4, ip
    8b98:	4293      	cmp	r3, r2
    8b9a:	dbbd      	blt.n	8b18 <_realloc_r+0x58>
    8b9c:	4657      	mov	r7, sl
    8b9e:	f8da 100c 	ldr.w	r1, [sl, #12]
    8ba2:	f857 0f08 	ldr.w	r0, [r7, #8]!
    8ba6:	1f22      	subs	r2, r4, #4
    8ba8:	2a24      	cmp	r2, #36	; 0x24
    8baa:	60c1      	str	r1, [r0, #12]
    8bac:	6088      	str	r0, [r1, #8]
    8bae:	f200 8117 	bhi.w	8de0 <_realloc_r+0x320>
    8bb2:	2a13      	cmp	r2, #19
    8bb4:	f240 8112 	bls.w	8ddc <_realloc_r+0x31c>
    8bb8:	6831      	ldr	r1, [r6, #0]
    8bba:	f8ca 1008 	str.w	r1, [sl, #8]
    8bbe:	6871      	ldr	r1, [r6, #4]
    8bc0:	f8ca 100c 	str.w	r1, [sl, #12]
    8bc4:	2a1b      	cmp	r2, #27
    8bc6:	f200 812b 	bhi.w	8e20 <_realloc_r+0x360>
    8bca:	3608      	adds	r6, #8
    8bcc:	f10a 0210 	add.w	r2, sl, #16
    8bd0:	6831      	ldr	r1, [r6, #0]
    8bd2:	6011      	str	r1, [r2, #0]
    8bd4:	6871      	ldr	r1, [r6, #4]
    8bd6:	6051      	str	r1, [r2, #4]
    8bd8:	68b1      	ldr	r1, [r6, #8]
    8bda:	6091      	str	r1, [r2, #8]
    8bdc:	463e      	mov	r6, r7
    8bde:	461c      	mov	r4, r3
    8be0:	46d0      	mov	r8, sl
    8be2:	1b63      	subs	r3, r4, r5
    8be4:	2b0f      	cmp	r3, #15
    8be6:	d81d      	bhi.n	8c24 <_realloc_r+0x164>
    8be8:	f8d8 3004 	ldr.w	r3, [r8, #4]
    8bec:	f003 0301 	and.w	r3, r3, #1
    8bf0:	4323      	orrs	r3, r4
    8bf2:	4444      	add	r4, r8
    8bf4:	f8c8 3004 	str.w	r3, [r8, #4]
    8bf8:	6863      	ldr	r3, [r4, #4]
    8bfa:	f043 0301 	orr.w	r3, r3, #1
    8bfe:	6063      	str	r3, [r4, #4]
    8c00:	4648      	mov	r0, r9
    8c02:	f7ff ff53 	bl	8aac <__malloc_unlock>
    8c06:	4630      	mov	r0, r6
    8c08:	b003      	add	sp, #12
    8c0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8c0e:	f021 0103 	bic.w	r1, r1, #3
    8c12:	4421      	add	r1, r4
    8c14:	4291      	cmp	r1, r2
    8c16:	db21      	blt.n	8c5c <_realloc_r+0x19c>
    8c18:	68c3      	ldr	r3, [r0, #12]
    8c1a:	6882      	ldr	r2, [r0, #8]
    8c1c:	460c      	mov	r4, r1
    8c1e:	60d3      	str	r3, [r2, #12]
    8c20:	609a      	str	r2, [r3, #8]
    8c22:	e7de      	b.n	8be2 <_realloc_r+0x122>
    8c24:	f8d8 2004 	ldr.w	r2, [r8, #4]
    8c28:	eb08 0105 	add.w	r1, r8, r5
    8c2c:	f002 0201 	and.w	r2, r2, #1
    8c30:	4315      	orrs	r5, r2
    8c32:	f043 0201 	orr.w	r2, r3, #1
    8c36:	440b      	add	r3, r1
    8c38:	f8c8 5004 	str.w	r5, [r8, #4]
    8c3c:	604a      	str	r2, [r1, #4]
    8c3e:	685a      	ldr	r2, [r3, #4]
    8c40:	f042 0201 	orr.w	r2, r2, #1
    8c44:	3108      	adds	r1, #8
    8c46:	605a      	str	r2, [r3, #4]
    8c48:	4648      	mov	r0, r9
    8c4a:	f000 fbf9 	bl	9440 <_free_r>
    8c4e:	e7d7      	b.n	8c00 <_realloc_r+0x140>
    8c50:	4611      	mov	r1, r2
    8c52:	b003      	add	sp, #12
    8c54:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8c58:	f7ff bbbc 	b.w	83d4 <_malloc_r>
    8c5c:	f01e 0f01 	tst.w	lr, #1
    8c60:	f47f af5a 	bne.w	8b18 <_realloc_r+0x58>
    8c64:	f856 3c08 	ldr.w	r3, [r6, #-8]
    8c68:	ebc3 0a08 	rsb	sl, r3, r8
    8c6c:	f8da 3004 	ldr.w	r3, [sl, #4]
    8c70:	f023 0c03 	bic.w	ip, r3, #3
    8c74:	eb01 0e0c 	add.w	lr, r1, ip
    8c78:	4596      	cmp	lr, r2
    8c7a:	db8b      	blt.n	8b94 <_realloc_r+0xd4>
    8c7c:	68c3      	ldr	r3, [r0, #12]
    8c7e:	6882      	ldr	r2, [r0, #8]
    8c80:	4657      	mov	r7, sl
    8c82:	60d3      	str	r3, [r2, #12]
    8c84:	609a      	str	r2, [r3, #8]
    8c86:	f857 1f08 	ldr.w	r1, [r7, #8]!
    8c8a:	f8da 300c 	ldr.w	r3, [sl, #12]
    8c8e:	60cb      	str	r3, [r1, #12]
    8c90:	1f22      	subs	r2, r4, #4
    8c92:	2a24      	cmp	r2, #36	; 0x24
    8c94:	6099      	str	r1, [r3, #8]
    8c96:	f200 8099 	bhi.w	8dcc <_realloc_r+0x30c>
    8c9a:	2a13      	cmp	r2, #19
    8c9c:	d962      	bls.n	8d64 <_realloc_r+0x2a4>
    8c9e:	6833      	ldr	r3, [r6, #0]
    8ca0:	f8ca 3008 	str.w	r3, [sl, #8]
    8ca4:	6873      	ldr	r3, [r6, #4]
    8ca6:	f8ca 300c 	str.w	r3, [sl, #12]
    8caa:	2a1b      	cmp	r2, #27
    8cac:	f200 80a0 	bhi.w	8df0 <_realloc_r+0x330>
    8cb0:	3608      	adds	r6, #8
    8cb2:	f10a 0310 	add.w	r3, sl, #16
    8cb6:	e056      	b.n	8d66 <_realloc_r+0x2a6>
    8cb8:	f021 0b03 	bic.w	fp, r1, #3
    8cbc:	44a3      	add	fp, r4
    8cbe:	f105 0010 	add.w	r0, r5, #16
    8cc2:	4583      	cmp	fp, r0
    8cc4:	da59      	bge.n	8d7a <_realloc_r+0x2ba>
    8cc6:	f01e 0f01 	tst.w	lr, #1
    8cca:	f47f af25 	bne.w	8b18 <_realloc_r+0x58>
    8cce:	f856 1c08 	ldr.w	r1, [r6, #-8]
    8cd2:	ebc1 0a08 	rsb	sl, r1, r8
    8cd6:	f8da 1004 	ldr.w	r1, [sl, #4]
    8cda:	f021 0c03 	bic.w	ip, r1, #3
    8cde:	44e3      	add	fp, ip
    8ce0:	4558      	cmp	r0, fp
    8ce2:	f73f af57 	bgt.w	8b94 <_realloc_r+0xd4>
    8ce6:	4657      	mov	r7, sl
    8ce8:	f8da 100c 	ldr.w	r1, [sl, #12]
    8cec:	f857 0f08 	ldr.w	r0, [r7, #8]!
    8cf0:	1f22      	subs	r2, r4, #4
    8cf2:	2a24      	cmp	r2, #36	; 0x24
    8cf4:	60c1      	str	r1, [r0, #12]
    8cf6:	6088      	str	r0, [r1, #8]
    8cf8:	f200 80b4 	bhi.w	8e64 <_realloc_r+0x3a4>
    8cfc:	2a13      	cmp	r2, #19
    8cfe:	f240 80a5 	bls.w	8e4c <_realloc_r+0x38c>
    8d02:	6831      	ldr	r1, [r6, #0]
    8d04:	f8ca 1008 	str.w	r1, [sl, #8]
    8d08:	6871      	ldr	r1, [r6, #4]
    8d0a:	f8ca 100c 	str.w	r1, [sl, #12]
    8d0e:	2a1b      	cmp	r2, #27
    8d10:	f200 80af 	bhi.w	8e72 <_realloc_r+0x3b2>
    8d14:	3608      	adds	r6, #8
    8d16:	f10a 0210 	add.w	r2, sl, #16
    8d1a:	6831      	ldr	r1, [r6, #0]
    8d1c:	6011      	str	r1, [r2, #0]
    8d1e:	6871      	ldr	r1, [r6, #4]
    8d20:	6051      	str	r1, [r2, #4]
    8d22:	68b1      	ldr	r1, [r6, #8]
    8d24:	6091      	str	r1, [r2, #8]
    8d26:	eb0a 0105 	add.w	r1, sl, r5
    8d2a:	ebc5 020b 	rsb	r2, r5, fp
    8d2e:	f042 0201 	orr.w	r2, r2, #1
    8d32:	6099      	str	r1, [r3, #8]
    8d34:	604a      	str	r2, [r1, #4]
    8d36:	f8da 3004 	ldr.w	r3, [sl, #4]
    8d3a:	f003 0301 	and.w	r3, r3, #1
    8d3e:	431d      	orrs	r5, r3
    8d40:	4648      	mov	r0, r9
    8d42:	f8ca 5004 	str.w	r5, [sl, #4]
    8d46:	f7ff feb1 	bl	8aac <__malloc_unlock>
    8d4a:	4638      	mov	r0, r7
    8d4c:	e75c      	b.n	8c08 <_realloc_r+0x148>
    8d4e:	6833      	ldr	r3, [r6, #0]
    8d50:	6003      	str	r3, [r0, #0]
    8d52:	6873      	ldr	r3, [r6, #4]
    8d54:	6043      	str	r3, [r0, #4]
    8d56:	2a1b      	cmp	r2, #27
    8d58:	d827      	bhi.n	8daa <_realloc_r+0x2ea>
    8d5a:	f100 0308 	add.w	r3, r0, #8
    8d5e:	f106 0208 	add.w	r2, r6, #8
    8d62:	e6f2      	b.n	8b4a <_realloc_r+0x8a>
    8d64:	463b      	mov	r3, r7
    8d66:	6832      	ldr	r2, [r6, #0]
    8d68:	601a      	str	r2, [r3, #0]
    8d6a:	6872      	ldr	r2, [r6, #4]
    8d6c:	605a      	str	r2, [r3, #4]
    8d6e:	68b2      	ldr	r2, [r6, #8]
    8d70:	609a      	str	r2, [r3, #8]
    8d72:	463e      	mov	r6, r7
    8d74:	4674      	mov	r4, lr
    8d76:	46d0      	mov	r8, sl
    8d78:	e733      	b.n	8be2 <_realloc_r+0x122>
    8d7a:	eb08 0105 	add.w	r1, r8, r5
    8d7e:	ebc5 0b0b 	rsb	fp, r5, fp
    8d82:	f04b 0201 	orr.w	r2, fp, #1
    8d86:	6099      	str	r1, [r3, #8]
    8d88:	604a      	str	r2, [r1, #4]
    8d8a:	f856 3c04 	ldr.w	r3, [r6, #-4]
    8d8e:	f003 0301 	and.w	r3, r3, #1
    8d92:	431d      	orrs	r5, r3
    8d94:	4648      	mov	r0, r9
    8d96:	f846 5c04 	str.w	r5, [r6, #-4]
    8d9a:	f7ff fe87 	bl	8aac <__malloc_unlock>
    8d9e:	4630      	mov	r0, r6
    8da0:	e732      	b.n	8c08 <_realloc_r+0x148>
    8da2:	4631      	mov	r1, r6
    8da4:	f7ff fdce 	bl	8944 <memmove>
    8da8:	e6d5      	b.n	8b56 <_realloc_r+0x96>
    8daa:	68b3      	ldr	r3, [r6, #8]
    8dac:	6083      	str	r3, [r0, #8]
    8dae:	68f3      	ldr	r3, [r6, #12]
    8db0:	60c3      	str	r3, [r0, #12]
    8db2:	2a24      	cmp	r2, #36	; 0x24
    8db4:	d028      	beq.n	8e08 <_realloc_r+0x348>
    8db6:	f100 0310 	add.w	r3, r0, #16
    8dba:	f106 0210 	add.w	r2, r6, #16
    8dbe:	e6c4      	b.n	8b4a <_realloc_r+0x8a>
    8dc0:	f850 3c04 	ldr.w	r3, [r0, #-4]
    8dc4:	f023 0303 	bic.w	r3, r3, #3
    8dc8:	441c      	add	r4, r3
    8dca:	e70a      	b.n	8be2 <_realloc_r+0x122>
    8dcc:	4631      	mov	r1, r6
    8dce:	4638      	mov	r0, r7
    8dd0:	4674      	mov	r4, lr
    8dd2:	46d0      	mov	r8, sl
    8dd4:	f7ff fdb6 	bl	8944 <memmove>
    8dd8:	463e      	mov	r6, r7
    8dda:	e702      	b.n	8be2 <_realloc_r+0x122>
    8ddc:	463a      	mov	r2, r7
    8dde:	e6f7      	b.n	8bd0 <_realloc_r+0x110>
    8de0:	4631      	mov	r1, r6
    8de2:	4638      	mov	r0, r7
    8de4:	461c      	mov	r4, r3
    8de6:	46d0      	mov	r8, sl
    8de8:	f7ff fdac 	bl	8944 <memmove>
    8dec:	463e      	mov	r6, r7
    8dee:	e6f8      	b.n	8be2 <_realloc_r+0x122>
    8df0:	68b3      	ldr	r3, [r6, #8]
    8df2:	f8ca 3010 	str.w	r3, [sl, #16]
    8df6:	68f3      	ldr	r3, [r6, #12]
    8df8:	f8ca 3014 	str.w	r3, [sl, #20]
    8dfc:	2a24      	cmp	r2, #36	; 0x24
    8dfe:	d01b      	beq.n	8e38 <_realloc_r+0x378>
    8e00:	3610      	adds	r6, #16
    8e02:	f10a 0318 	add.w	r3, sl, #24
    8e06:	e7ae      	b.n	8d66 <_realloc_r+0x2a6>
    8e08:	6933      	ldr	r3, [r6, #16]
    8e0a:	6103      	str	r3, [r0, #16]
    8e0c:	6973      	ldr	r3, [r6, #20]
    8e0e:	6143      	str	r3, [r0, #20]
    8e10:	f106 0218 	add.w	r2, r6, #24
    8e14:	f100 0318 	add.w	r3, r0, #24
    8e18:	e697      	b.n	8b4a <_realloc_r+0x8a>
    8e1a:	bf00      	nop
    8e1c:	1fff100c 	.word	0x1fff100c
    8e20:	68b1      	ldr	r1, [r6, #8]
    8e22:	f8ca 1010 	str.w	r1, [sl, #16]
    8e26:	68f1      	ldr	r1, [r6, #12]
    8e28:	f8ca 1014 	str.w	r1, [sl, #20]
    8e2c:	2a24      	cmp	r2, #36	; 0x24
    8e2e:	d00f      	beq.n	8e50 <_realloc_r+0x390>
    8e30:	3610      	adds	r6, #16
    8e32:	f10a 0218 	add.w	r2, sl, #24
    8e36:	e6cb      	b.n	8bd0 <_realloc_r+0x110>
    8e38:	6933      	ldr	r3, [r6, #16]
    8e3a:	f8ca 3018 	str.w	r3, [sl, #24]
    8e3e:	6973      	ldr	r3, [r6, #20]
    8e40:	f8ca 301c 	str.w	r3, [sl, #28]
    8e44:	3618      	adds	r6, #24
    8e46:	f10a 0320 	add.w	r3, sl, #32
    8e4a:	e78c      	b.n	8d66 <_realloc_r+0x2a6>
    8e4c:	463a      	mov	r2, r7
    8e4e:	e764      	b.n	8d1a <_realloc_r+0x25a>
    8e50:	6932      	ldr	r2, [r6, #16]
    8e52:	f8ca 2018 	str.w	r2, [sl, #24]
    8e56:	6972      	ldr	r2, [r6, #20]
    8e58:	f8ca 201c 	str.w	r2, [sl, #28]
    8e5c:	3618      	adds	r6, #24
    8e5e:	f10a 0220 	add.w	r2, sl, #32
    8e62:	e6b5      	b.n	8bd0 <_realloc_r+0x110>
    8e64:	4631      	mov	r1, r6
    8e66:	4638      	mov	r0, r7
    8e68:	9301      	str	r3, [sp, #4]
    8e6a:	f7ff fd6b 	bl	8944 <memmove>
    8e6e:	9b01      	ldr	r3, [sp, #4]
    8e70:	e759      	b.n	8d26 <_realloc_r+0x266>
    8e72:	68b1      	ldr	r1, [r6, #8]
    8e74:	f8ca 1010 	str.w	r1, [sl, #16]
    8e78:	68f1      	ldr	r1, [r6, #12]
    8e7a:	f8ca 1014 	str.w	r1, [sl, #20]
    8e7e:	2a24      	cmp	r2, #36	; 0x24
    8e80:	d003      	beq.n	8e8a <_realloc_r+0x3ca>
    8e82:	3610      	adds	r6, #16
    8e84:	f10a 0218 	add.w	r2, sl, #24
    8e88:	e747      	b.n	8d1a <_realloc_r+0x25a>
    8e8a:	6932      	ldr	r2, [r6, #16]
    8e8c:	f8ca 2018 	str.w	r2, [sl, #24]
    8e90:	6972      	ldr	r2, [r6, #20]
    8e92:	f8ca 201c 	str.w	r2, [sl, #28]
    8e96:	3618      	adds	r6, #24
    8e98:	f10a 0220 	add.w	r2, sl, #32
    8e9c:	e73d      	b.n	8d1a <_realloc_r+0x25a>
    8e9e:	bf00      	nop

00008ea0 <_sbrk_r>:
    8ea0:	b538      	push	{r3, r4, r5, lr}
    8ea2:	4c07      	ldr	r4, [pc, #28]	; (8ec0 <_sbrk_r+0x20>)
    8ea4:	2300      	movs	r3, #0
    8ea6:	4605      	mov	r5, r0
    8ea8:	4608      	mov	r0, r1
    8eaa:	6023      	str	r3, [r4, #0]
    8eac:	f7fb feec 	bl	4c88 <_sbrk>
    8eb0:	1c43      	adds	r3, r0, #1
    8eb2:	d000      	beq.n	8eb6 <_sbrk_r+0x16>
    8eb4:	bd38      	pop	{r3, r4, r5, pc}
    8eb6:	6823      	ldr	r3, [r4, #0]
    8eb8:	2b00      	cmp	r3, #0
    8eba:	d0fb      	beq.n	8eb4 <_sbrk_r+0x14>
    8ebc:	602b      	str	r3, [r5, #0]
    8ebe:	bd38      	pop	{r3, r4, r5, pc}
    8ec0:	1fff2d1c 	.word	0x1fff2d1c
    8ec4:	ffffffff 	.word	0xffffffff
    8ec8:	ffffffff 	.word	0xffffffff
    8ecc:	ffffffff 	.word	0xffffffff
    8ed0:	ffffffff 	.word	0xffffffff
    8ed4:	ffffffff 	.word	0xffffffff
    8ed8:	ffffffff 	.word	0xffffffff
    8edc:	ffffffff 	.word	0xffffffff
    8ee0:	eba2 0003 	sub.w	r0, r2, r3
    8ee4:	4770      	bx	lr
    8ee6:	bf00      	nop

00008ee8 <strcmp>:
    8ee8:	7802      	ldrb	r2, [r0, #0]
    8eea:	780b      	ldrb	r3, [r1, #0]
    8eec:	2a01      	cmp	r2, #1
    8eee:	bf28      	it	cs
    8ef0:	429a      	cmpcs	r2, r3
    8ef2:	d1f5      	bne.n	8ee0 <_sbrk_r+0x40>
    8ef4:	e96d 4504 	strd	r4, r5, [sp, #-16]!
    8ef8:	ea40 0401 	orr.w	r4, r0, r1
    8efc:	e9cd 6702 	strd	r6, r7, [sp, #8]
    8f00:	f06f 0c00 	mvn.w	ip, #0
    8f04:	ea4f 7244 	mov.w	r2, r4, lsl #29
    8f08:	b312      	cbz	r2, 8f50 <strcmp+0x68>
    8f0a:	ea80 0401 	eor.w	r4, r0, r1
    8f0e:	f014 0f07 	tst.w	r4, #7
    8f12:	d16a      	bne.n	8fea <strcmp+0x102>
    8f14:	f000 0407 	and.w	r4, r0, #7
    8f18:	f020 0007 	bic.w	r0, r0, #7
    8f1c:	f004 0503 	and.w	r5, r4, #3
    8f20:	f021 0107 	bic.w	r1, r1, #7
    8f24:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    8f28:	e8f0 2304 	ldrd	r2, r3, [r0], #16
    8f2c:	f014 0f04 	tst.w	r4, #4
    8f30:	e8f1 6704 	ldrd	r6, r7, [r1], #16
    8f34:	fa0c f405 	lsl.w	r4, ip, r5
    8f38:	ea62 0204 	orn	r2, r2, r4
    8f3c:	ea66 0604 	orn	r6, r6, r4
    8f40:	d00a      	beq.n	8f58 <strcmp+0x70>
    8f42:	ea63 0304 	orn	r3, r3, r4
    8f46:	4662      	mov	r2, ip
    8f48:	ea67 0704 	orn	r7, r7, r4
    8f4c:	4666      	mov	r6, ip
    8f4e:	e003      	b.n	8f58 <strcmp+0x70>
    8f50:	e8f0 2304 	ldrd	r2, r3, [r0], #16
    8f54:	e8f1 6704 	ldrd	r6, r7, [r1], #16
    8f58:	fa82 f54c 	uadd8	r5, r2, ip
    8f5c:	ea82 0406 	eor.w	r4, r2, r6
    8f60:	faa4 f48c 	sel	r4, r4, ip
    8f64:	bb6c      	cbnz	r4, 8fc2 <strcmp+0xda>
    8f66:	fa83 f54c 	uadd8	r5, r3, ip
    8f6a:	ea83 0507 	eor.w	r5, r3, r7
    8f6e:	faa5 f58c 	sel	r5, r5, ip
    8f72:	b995      	cbnz	r5, 8f9a <strcmp+0xb2>
    8f74:	e950 2302 	ldrd	r2, r3, [r0, #-8]
    8f78:	e951 6702 	ldrd	r6, r7, [r1, #-8]
    8f7c:	fa82 f54c 	uadd8	r5, r2, ip
    8f80:	ea82 0406 	eor.w	r4, r2, r6
    8f84:	faa4 f48c 	sel	r4, r4, ip
    8f88:	fa83 f54c 	uadd8	r5, r3, ip
    8f8c:	ea83 0507 	eor.w	r5, r3, r7
    8f90:	faa5 f58c 	sel	r5, r5, ip
    8f94:	4325      	orrs	r5, r4
    8f96:	d0db      	beq.n	8f50 <strcmp+0x68>
    8f98:	b99c      	cbnz	r4, 8fc2 <strcmp+0xda>
    8f9a:	ba2d      	rev	r5, r5
    8f9c:	fab5 f485 	clz	r4, r5
    8fa0:	f024 0407 	bic.w	r4, r4, #7
    8fa4:	fa27 f104 	lsr.w	r1, r7, r4
    8fa8:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    8fac:	fa23 f304 	lsr.w	r3, r3, r4
    8fb0:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    8fb4:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    8fb8:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    8fbc:	eba0 0001 	sub.w	r0, r0, r1
    8fc0:	4770      	bx	lr
    8fc2:	ba24      	rev	r4, r4
    8fc4:	fab4 f484 	clz	r4, r4
    8fc8:	f024 0407 	bic.w	r4, r4, #7
    8fcc:	fa26 f104 	lsr.w	r1, r6, r4
    8fd0:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    8fd4:	fa22 f204 	lsr.w	r2, r2, r4
    8fd8:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    8fdc:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    8fe0:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    8fe4:	eba0 0001 	sub.w	r0, r0, r1
    8fe8:	4770      	bx	lr
    8fea:	f014 0f03 	tst.w	r4, #3
    8fee:	d13c      	bne.n	906a <strcmp+0x182>
    8ff0:	f010 0403 	ands.w	r4, r0, #3
    8ff4:	d128      	bne.n	9048 <strcmp+0x160>
    8ff6:	f850 2b08 	ldr.w	r2, [r0], #8
    8ffa:	f851 3b08 	ldr.w	r3, [r1], #8
    8ffe:	fa82 f54c 	uadd8	r5, r2, ip
    9002:	ea82 0503 	eor.w	r5, r2, r3
    9006:	faa5 f58c 	sel	r5, r5, ip
    900a:	b95d      	cbnz	r5, 9024 <strcmp+0x13c>
    900c:	f850 2c04 	ldr.w	r2, [r0, #-4]
    9010:	f851 3c04 	ldr.w	r3, [r1, #-4]
    9014:	fa82 f54c 	uadd8	r5, r2, ip
    9018:	ea82 0503 	eor.w	r5, r2, r3
    901c:	faa5 f58c 	sel	r5, r5, ip
    9020:	2d00      	cmp	r5, #0
    9022:	d0e8      	beq.n	8ff6 <strcmp+0x10e>
    9024:	ba2d      	rev	r5, r5
    9026:	fab5 f485 	clz	r4, r5
    902a:	f024 0407 	bic.w	r4, r4, #7
    902e:	fa23 f104 	lsr.w	r1, r3, r4
    9032:	fa22 f204 	lsr.w	r2, r2, r4
    9036:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    903a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    903e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    9042:	eba0 0001 	sub.w	r0, r0, r1
    9046:	4770      	bx	lr
    9048:	ea4f 04c4 	mov.w	r4, r4, lsl #3
    904c:	f020 0003 	bic.w	r0, r0, #3
    9050:	f850 2b08 	ldr.w	r2, [r0], #8
    9054:	f021 0103 	bic.w	r1, r1, #3
    9058:	f851 3b08 	ldr.w	r3, [r1], #8
    905c:	fa0c f404 	lsl.w	r4, ip, r4
    9060:	ea62 0204 	orn	r2, r2, r4
    9064:	ea63 0304 	orn	r3, r3, r4
    9068:	e7c9      	b.n	8ffe <strcmp+0x116>
    906a:	f010 0403 	ands.w	r4, r0, #3
    906e:	d01a      	beq.n	90a6 <strcmp+0x1be>
    9070:	eba1 0104 	sub.w	r1, r1, r4
    9074:	f020 0003 	bic.w	r0, r0, #3
    9078:	07e4      	lsls	r4, r4, #31
    907a:	f850 2b04 	ldr.w	r2, [r0], #4
    907e:	d006      	beq.n	908e <strcmp+0x1a6>
    9080:	d20f      	bcs.n	90a2 <strcmp+0x1ba>
    9082:	788b      	ldrb	r3, [r1, #2]
    9084:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
    9088:	1ae4      	subs	r4, r4, r3
    908a:	d106      	bne.n	909a <strcmp+0x1b2>
    908c:	b12b      	cbz	r3, 909a <strcmp+0x1b2>
    908e:	78cb      	ldrb	r3, [r1, #3]
    9090:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
    9094:	1ae4      	subs	r4, r4, r3
    9096:	d100      	bne.n	909a <strcmp+0x1b2>
    9098:	b91b      	cbnz	r3, 90a2 <strcmp+0x1ba>
    909a:	4620      	mov	r0, r4
    909c:	f85d 4b10 	ldr.w	r4, [sp], #16
    90a0:	4770      	bx	lr
    90a2:	f101 0104 	add.w	r1, r1, #4
    90a6:	f850 2b04 	ldr.w	r2, [r0], #4
    90aa:	07cc      	lsls	r4, r1, #31
    90ac:	f021 0103 	bic.w	r1, r1, #3
    90b0:	f851 3b04 	ldr.w	r3, [r1], #4
    90b4:	d848      	bhi.n	9148 <strcmp+0x260>
    90b6:	d224      	bcs.n	9102 <strcmp+0x21a>
    90b8:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
    90bc:	fa82 f54c 	uadd8	r5, r2, ip
    90c0:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
    90c4:	faa5 f58c 	sel	r5, r5, ip
    90c8:	d10a      	bne.n	90e0 <strcmp+0x1f8>
    90ca:	b965      	cbnz	r5, 90e6 <strcmp+0x1fe>
    90cc:	f851 3b04 	ldr.w	r3, [r1], #4
    90d0:	ea84 0402 	eor.w	r4, r4, r2
    90d4:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
    90d8:	d10e      	bne.n	90f8 <strcmp+0x210>
    90da:	f850 2b04 	ldr.w	r2, [r0], #4
    90de:	e7eb      	b.n	90b8 <strcmp+0x1d0>
    90e0:	ea4f 2313 	mov.w	r3, r3, lsr #8
    90e4:	e055      	b.n	9192 <strcmp+0x2aa>
    90e6:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
    90ea:	d14d      	bne.n	9188 <strcmp+0x2a0>
    90ec:	7808      	ldrb	r0, [r1, #0]
    90ee:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    90f2:	f1c0 0000 	rsb	r0, r0, #0
    90f6:	4770      	bx	lr
    90f8:	ea4f 6212 	mov.w	r2, r2, lsr #24
    90fc:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    9100:	e047      	b.n	9192 <strcmp+0x2aa>
    9102:	ea02 441c 	and.w	r4, r2, ip, lsr #16
    9106:	fa82 f54c 	uadd8	r5, r2, ip
    910a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
    910e:	faa5 f58c 	sel	r5, r5, ip
    9112:	d10a      	bne.n	912a <strcmp+0x242>
    9114:	b965      	cbnz	r5, 9130 <strcmp+0x248>
    9116:	f851 3b04 	ldr.w	r3, [r1], #4
    911a:	ea84 0402 	eor.w	r4, r4, r2
    911e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
    9122:	d10c      	bne.n	913e <strcmp+0x256>
    9124:	f850 2b04 	ldr.w	r2, [r0], #4
    9128:	e7eb      	b.n	9102 <strcmp+0x21a>
    912a:	ea4f 4313 	mov.w	r3, r3, lsr #16
    912e:	e030      	b.n	9192 <strcmp+0x2aa>
    9130:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
    9134:	d128      	bne.n	9188 <strcmp+0x2a0>
    9136:	880b      	ldrh	r3, [r1, #0]
    9138:	ea4f 4212 	mov.w	r2, r2, lsr #16
    913c:	e029      	b.n	9192 <strcmp+0x2aa>
    913e:	ea4f 4212 	mov.w	r2, r2, lsr #16
    9142:	ea03 431c 	and.w	r3, r3, ip, lsr #16
    9146:	e024      	b.n	9192 <strcmp+0x2aa>
    9148:	f002 04ff 	and.w	r4, r2, #255	; 0xff
    914c:	fa82 f54c 	uadd8	r5, r2, ip
    9150:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
    9154:	faa5 f58c 	sel	r5, r5, ip
    9158:	d10a      	bne.n	9170 <strcmp+0x288>
    915a:	b965      	cbnz	r5, 9176 <strcmp+0x28e>
    915c:	f851 3b04 	ldr.w	r3, [r1], #4
    9160:	ea84 0402 	eor.w	r4, r4, r2
    9164:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
    9168:	d109      	bne.n	917e <strcmp+0x296>
    916a:	f850 2b04 	ldr.w	r2, [r0], #4
    916e:	e7eb      	b.n	9148 <strcmp+0x260>
    9170:	ea4f 6313 	mov.w	r3, r3, lsr #24
    9174:	e00d      	b.n	9192 <strcmp+0x2aa>
    9176:	f015 0fff 	tst.w	r5, #255	; 0xff
    917a:	d105      	bne.n	9188 <strcmp+0x2a0>
    917c:	680b      	ldr	r3, [r1, #0]
    917e:	ea4f 2212 	mov.w	r2, r2, lsr #8
    9182:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    9186:	e004      	b.n	9192 <strcmp+0x2aa>
    9188:	f04f 0000 	mov.w	r0, #0
    918c:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    9190:	4770      	bx	lr
    9192:	ba12      	rev	r2, r2
    9194:	ba1b      	rev	r3, r3
    9196:	fa82 f44c 	uadd8	r4, r2, ip
    919a:	ea82 0403 	eor.w	r4, r2, r3
    919e:	faa4 f58c 	sel	r5, r4, ip
    91a2:	fab5 f485 	clz	r4, r5
    91a6:	fa02 f204 	lsl.w	r2, r2, r4
    91aa:	fa03 f304 	lsl.w	r3, r3, r4
    91ae:	ea4f 6012 	mov.w	r0, r2, lsr #24
    91b2:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    91b6:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
    91ba:	4770      	bx	lr

000091bc <strcpy>:
    91bc:	ea80 0201 	eor.w	r2, r0, r1
    91c0:	4684      	mov	ip, r0
    91c2:	f012 0f03 	tst.w	r2, #3
    91c6:	d14f      	bne.n	9268 <strcpy+0xac>
    91c8:	f011 0f03 	tst.w	r1, #3
    91cc:	d132      	bne.n	9234 <strcpy+0x78>
    91ce:	f84d 4d04 	str.w	r4, [sp, #-4]!
    91d2:	f011 0f04 	tst.w	r1, #4
    91d6:	f851 3b04 	ldr.w	r3, [r1], #4
    91da:	d00b      	beq.n	91f4 <strcpy+0x38>
    91dc:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    91e0:	439a      	bics	r2, r3
    91e2:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    91e6:	bf04      	itt	eq
    91e8:	f84c 3b04 	streq.w	r3, [ip], #4
    91ec:	f851 3b04 	ldreq.w	r3, [r1], #4
    91f0:	d116      	bne.n	9220 <strcpy+0x64>
    91f2:	bf00      	nop
    91f4:	f851 4b04 	ldr.w	r4, [r1], #4
    91f8:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    91fc:	439a      	bics	r2, r3
    91fe:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    9202:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
    9206:	d10b      	bne.n	9220 <strcpy+0x64>
    9208:	f84c 3b04 	str.w	r3, [ip], #4
    920c:	43a2      	bics	r2, r4
    920e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    9212:	bf04      	itt	eq
    9214:	f851 3b04 	ldreq.w	r3, [r1], #4
    9218:	f84c 4b04 	streq.w	r4, [ip], #4
    921c:	d0ea      	beq.n	91f4 <strcpy+0x38>
    921e:	4623      	mov	r3, r4
    9220:	f80c 3b01 	strb.w	r3, [ip], #1
    9224:	f013 0fff 	tst.w	r3, #255	; 0xff
    9228:	ea4f 2333 	mov.w	r3, r3, ror #8
    922c:	d1f8      	bne.n	9220 <strcpy+0x64>
    922e:	f85d 4b04 	ldr.w	r4, [sp], #4
    9232:	4770      	bx	lr
    9234:	f011 0f01 	tst.w	r1, #1
    9238:	d006      	beq.n	9248 <strcpy+0x8c>
    923a:	f811 2b01 	ldrb.w	r2, [r1], #1
    923e:	f80c 2b01 	strb.w	r2, [ip], #1
    9242:	2a00      	cmp	r2, #0
    9244:	bf08      	it	eq
    9246:	4770      	bxeq	lr
    9248:	f011 0f02 	tst.w	r1, #2
    924c:	d0bf      	beq.n	91ce <strcpy+0x12>
    924e:	f831 2b02 	ldrh.w	r2, [r1], #2
    9252:	f012 0fff 	tst.w	r2, #255	; 0xff
    9256:	bf16      	itet	ne
    9258:	f82c 2b02 	strhne.w	r2, [ip], #2
    925c:	f88c 2000 	strbeq.w	r2, [ip]
    9260:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
    9264:	d1b3      	bne.n	91ce <strcpy+0x12>
    9266:	4770      	bx	lr
    9268:	f811 2b01 	ldrb.w	r2, [r1], #1
    926c:	f80c 2b01 	strb.w	r2, [ip], #1
    9270:	2a00      	cmp	r2, #0
    9272:	d1f9      	bne.n	9268 <strcpy+0xac>
    9274:	4770      	bx	lr
    9276:	bf00      	nop
    9278:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    927c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

00009280 <strlen>:
    9280:	f890 f000 	pld	[r0]
    9284:	e96d 4502 	strd	r4, r5, [sp, #-8]!
    9288:	f020 0107 	bic.w	r1, r0, #7
    928c:	f06f 0c00 	mvn.w	ip, #0
    9290:	f010 0407 	ands.w	r4, r0, #7
    9294:	f891 f020 	pld	[r1, #32]
    9298:	f040 8049 	bne.w	932e <strlen+0xae>
    929c:	f04f 0400 	mov.w	r4, #0
    92a0:	f06f 0007 	mvn.w	r0, #7
    92a4:	e9d1 2300 	ldrd	r2, r3, [r1]
    92a8:	f891 f040 	pld	[r1, #64]	; 0x40
    92ac:	f100 0008 	add.w	r0, r0, #8
    92b0:	fa82 f24c 	uadd8	r2, r2, ip
    92b4:	faa4 f28c 	sel	r2, r4, ip
    92b8:	fa83 f34c 	uadd8	r3, r3, ip
    92bc:	faa2 f38c 	sel	r3, r2, ip
    92c0:	bb4b      	cbnz	r3, 9316 <strlen+0x96>
    92c2:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
    92c6:	fa82 f24c 	uadd8	r2, r2, ip
    92ca:	f100 0008 	add.w	r0, r0, #8
    92ce:	faa4 f28c 	sel	r2, r4, ip
    92d2:	fa83 f34c 	uadd8	r3, r3, ip
    92d6:	faa2 f38c 	sel	r3, r2, ip
    92da:	b9e3      	cbnz	r3, 9316 <strlen+0x96>
    92dc:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
    92e0:	fa82 f24c 	uadd8	r2, r2, ip
    92e4:	f100 0008 	add.w	r0, r0, #8
    92e8:	faa4 f28c 	sel	r2, r4, ip
    92ec:	fa83 f34c 	uadd8	r3, r3, ip
    92f0:	faa2 f38c 	sel	r3, r2, ip
    92f4:	b97b      	cbnz	r3, 9316 <strlen+0x96>
    92f6:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
    92fa:	f101 0120 	add.w	r1, r1, #32
    92fe:	fa82 f24c 	uadd8	r2, r2, ip
    9302:	f100 0008 	add.w	r0, r0, #8
    9306:	faa4 f28c 	sel	r2, r4, ip
    930a:	fa83 f34c 	uadd8	r3, r3, ip
    930e:	faa2 f38c 	sel	r3, r2, ip
    9312:	2b00      	cmp	r3, #0
    9314:	d0c6      	beq.n	92a4 <strlen+0x24>
    9316:	2a00      	cmp	r2, #0
    9318:	bf04      	itt	eq
    931a:	3004      	addeq	r0, #4
    931c:	461a      	moveq	r2, r3
    931e:	ba12      	rev	r2, r2
    9320:	fab2 f282 	clz	r2, r2
    9324:	e8fd 4502 	ldrd	r4, r5, [sp], #8
    9328:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
    932c:	4770      	bx	lr
    932e:	e9d1 2300 	ldrd	r2, r3, [r1]
    9332:	f004 0503 	and.w	r5, r4, #3
    9336:	f1c4 0000 	rsb	r0, r4, #0
    933a:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    933e:	f014 0f04 	tst.w	r4, #4
    9342:	f891 f040 	pld	[r1, #64]	; 0x40
    9346:	fa0c f505 	lsl.w	r5, ip, r5
    934a:	ea62 0205 	orn	r2, r2, r5
    934e:	bf1c      	itt	ne
    9350:	ea63 0305 	ornne	r3, r3, r5
    9354:	4662      	movne	r2, ip
    9356:	f04f 0400 	mov.w	r4, #0
    935a:	e7a9      	b.n	92b0 <strlen+0x30>

0000935c <register_fini>:
    935c:	4b02      	ldr	r3, [pc, #8]	; (9368 <register_fini+0xc>)
    935e:	b113      	cbz	r3, 9366 <register_fini+0xa>
    9360:	4802      	ldr	r0, [pc, #8]	; (936c <register_fini+0x10>)
    9362:	f000 b805 	b.w	9370 <atexit>
    9366:	4770      	bx	lr
    9368:	00000000 	.word	0x00000000
    936c:	0000937d 	.word	0x0000937d

00009370 <atexit>:
    9370:	2300      	movs	r3, #0
    9372:	4601      	mov	r1, r0
    9374:	461a      	mov	r2, r3
    9376:	4618      	mov	r0, r3
    9378:	f000 b94a 	b.w	9610 <__register_exitproc>

0000937c <__libc_fini_array>:
    937c:	b538      	push	{r3, r4, r5, lr}
    937e:	4d07      	ldr	r5, [pc, #28]	; (939c <__libc_fini_array+0x20>)
    9380:	4c07      	ldr	r4, [pc, #28]	; (93a0 <__libc_fini_array+0x24>)
    9382:	1b2c      	subs	r4, r5, r4
    9384:	10a4      	asrs	r4, r4, #2
    9386:	d005      	beq.n	9394 <__libc_fini_array+0x18>
    9388:	3c01      	subs	r4, #1
    938a:	f855 3d04 	ldr.w	r3, [r5, #-4]!
    938e:	4798      	blx	r3
    9390:	2c00      	cmp	r4, #0
    9392:	d1f9      	bne.n	9388 <__libc_fini_array+0xc>
    9394:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    9398:	f000 bd7c 	b.w	9e94 <__init_array_end>
	...

000093a4 <_malloc_trim_r>:
    93a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    93a6:	4f23      	ldr	r7, [pc, #140]	; (9434 <_malloc_trim_r+0x90>)
    93a8:	460c      	mov	r4, r1
    93aa:	4606      	mov	r6, r0
    93ac:	f7ff fb7c 	bl	8aa8 <__malloc_lock>
    93b0:	68bb      	ldr	r3, [r7, #8]
    93b2:	685d      	ldr	r5, [r3, #4]
    93b4:	f025 0503 	bic.w	r5, r5, #3
    93b8:	1b29      	subs	r1, r5, r4
    93ba:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
    93be:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
    93c2:	f021 010f 	bic.w	r1, r1, #15
    93c6:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
    93ca:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    93ce:	db07      	blt.n	93e0 <_malloc_trim_r+0x3c>
    93d0:	2100      	movs	r1, #0
    93d2:	4630      	mov	r0, r6
    93d4:	f7ff fd64 	bl	8ea0 <_sbrk_r>
    93d8:	68bb      	ldr	r3, [r7, #8]
    93da:	442b      	add	r3, r5
    93dc:	4298      	cmp	r0, r3
    93de:	d004      	beq.n	93ea <_malloc_trim_r+0x46>
    93e0:	4630      	mov	r0, r6
    93e2:	f7ff fb63 	bl	8aac <__malloc_unlock>
    93e6:	2000      	movs	r0, #0
    93e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    93ea:	4261      	negs	r1, r4
    93ec:	4630      	mov	r0, r6
    93ee:	f7ff fd57 	bl	8ea0 <_sbrk_r>
    93f2:	3001      	adds	r0, #1
    93f4:	d00d      	beq.n	9412 <_malloc_trim_r+0x6e>
    93f6:	4b10      	ldr	r3, [pc, #64]	; (9438 <_malloc_trim_r+0x94>)
    93f8:	68ba      	ldr	r2, [r7, #8]
    93fa:	6819      	ldr	r1, [r3, #0]
    93fc:	1b2d      	subs	r5, r5, r4
    93fe:	f045 0501 	orr.w	r5, r5, #1
    9402:	4630      	mov	r0, r6
    9404:	1b09      	subs	r1, r1, r4
    9406:	6055      	str	r5, [r2, #4]
    9408:	6019      	str	r1, [r3, #0]
    940a:	f7ff fb4f 	bl	8aac <__malloc_unlock>
    940e:	2001      	movs	r0, #1
    9410:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9412:	2100      	movs	r1, #0
    9414:	4630      	mov	r0, r6
    9416:	f7ff fd43 	bl	8ea0 <_sbrk_r>
    941a:	68ba      	ldr	r2, [r7, #8]
    941c:	1a83      	subs	r3, r0, r2
    941e:	2b0f      	cmp	r3, #15
    9420:	ddde      	ble.n	93e0 <_malloc_trim_r+0x3c>
    9422:	4c06      	ldr	r4, [pc, #24]	; (943c <_malloc_trim_r+0x98>)
    9424:	4904      	ldr	r1, [pc, #16]	; (9438 <_malloc_trim_r+0x94>)
    9426:	6824      	ldr	r4, [r4, #0]
    9428:	f043 0301 	orr.w	r3, r3, #1
    942c:	1b00      	subs	r0, r0, r4
    942e:	6053      	str	r3, [r2, #4]
    9430:	6008      	str	r0, [r1, #0]
    9432:	e7d5      	b.n	93e0 <_malloc_trim_r+0x3c>
    9434:	1fff100c 	.word	0x1fff100c
    9438:	1fff2ce0 	.word	0x1fff2ce0
    943c:	1fff1418 	.word	0x1fff1418

00009440 <_free_r>:
    9440:	2900      	cmp	r1, #0
    9442:	d045      	beq.n	94d0 <_free_r+0x90>
    9444:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9448:	460d      	mov	r5, r1
    944a:	4680      	mov	r8, r0
    944c:	f7ff fb2c 	bl	8aa8 <__malloc_lock>
    9450:	f855 7c04 	ldr.w	r7, [r5, #-4]
    9454:	496a      	ldr	r1, [pc, #424]	; (9600 <_free_r+0x1c0>)
    9456:	f027 0301 	bic.w	r3, r7, #1
    945a:	f1a5 0408 	sub.w	r4, r5, #8
    945e:	18e2      	adds	r2, r4, r3
    9460:	688e      	ldr	r6, [r1, #8]
    9462:	6850      	ldr	r0, [r2, #4]
    9464:	42b2      	cmp	r2, r6
    9466:	f020 0003 	bic.w	r0, r0, #3
    946a:	d062      	beq.n	9532 <_free_r+0xf2>
    946c:	07fe      	lsls	r6, r7, #31
    946e:	6050      	str	r0, [r2, #4]
    9470:	d40b      	bmi.n	948a <_free_r+0x4a>
    9472:	f855 7c08 	ldr.w	r7, [r5, #-8]
    9476:	1be4      	subs	r4, r4, r7
    9478:	f101 0e08 	add.w	lr, r1, #8
    947c:	68a5      	ldr	r5, [r4, #8]
    947e:	4575      	cmp	r5, lr
    9480:	443b      	add	r3, r7
    9482:	d06f      	beq.n	9564 <_free_r+0x124>
    9484:	68e7      	ldr	r7, [r4, #12]
    9486:	60ef      	str	r7, [r5, #12]
    9488:	60bd      	str	r5, [r7, #8]
    948a:	1815      	adds	r5, r2, r0
    948c:	686d      	ldr	r5, [r5, #4]
    948e:	07ed      	lsls	r5, r5, #31
    9490:	d542      	bpl.n	9518 <_free_r+0xd8>
    9492:	f043 0201 	orr.w	r2, r3, #1
    9496:	6062      	str	r2, [r4, #4]
    9498:	50e3      	str	r3, [r4, r3]
    949a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    949e:	d218      	bcs.n	94d2 <_free_r+0x92>
    94a0:	08db      	lsrs	r3, r3, #3
    94a2:	1c5a      	adds	r2, r3, #1
    94a4:	684d      	ldr	r5, [r1, #4]
    94a6:	f851 7032 	ldr.w	r7, [r1, r2, lsl #3]
    94aa:	60a7      	str	r7, [r4, #8]
    94ac:	2001      	movs	r0, #1
    94ae:	109b      	asrs	r3, r3, #2
    94b0:	fa00 f303 	lsl.w	r3, r0, r3
    94b4:	eb01 00c2 	add.w	r0, r1, r2, lsl #3
    94b8:	431d      	orrs	r5, r3
    94ba:	3808      	subs	r0, #8
    94bc:	60e0      	str	r0, [r4, #12]
    94be:	604d      	str	r5, [r1, #4]
    94c0:	f841 4032 	str.w	r4, [r1, r2, lsl #3]
    94c4:	60fc      	str	r4, [r7, #12]
    94c6:	4640      	mov	r0, r8
    94c8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    94cc:	f7ff baee 	b.w	8aac <__malloc_unlock>
    94d0:	4770      	bx	lr
    94d2:	0a5a      	lsrs	r2, r3, #9
    94d4:	2a04      	cmp	r2, #4
    94d6:	d853      	bhi.n	9580 <_free_r+0x140>
    94d8:	099a      	lsrs	r2, r3, #6
    94da:	f102 0739 	add.w	r7, r2, #57	; 0x39
    94de:	007f      	lsls	r7, r7, #1
    94e0:	f102 0538 	add.w	r5, r2, #56	; 0x38
    94e4:	eb01 0087 	add.w	r0, r1, r7, lsl #2
    94e8:	f851 2027 	ldr.w	r2, [r1, r7, lsl #2]
    94ec:	4944      	ldr	r1, [pc, #272]	; (9600 <_free_r+0x1c0>)
    94ee:	3808      	subs	r0, #8
    94f0:	4290      	cmp	r0, r2
    94f2:	d04d      	beq.n	9590 <_free_r+0x150>
    94f4:	6851      	ldr	r1, [r2, #4]
    94f6:	f021 0103 	bic.w	r1, r1, #3
    94fa:	428b      	cmp	r3, r1
    94fc:	d202      	bcs.n	9504 <_free_r+0xc4>
    94fe:	6892      	ldr	r2, [r2, #8]
    9500:	4290      	cmp	r0, r2
    9502:	d1f7      	bne.n	94f4 <_free_r+0xb4>
    9504:	68d0      	ldr	r0, [r2, #12]
    9506:	60e0      	str	r0, [r4, #12]
    9508:	60a2      	str	r2, [r4, #8]
    950a:	6084      	str	r4, [r0, #8]
    950c:	60d4      	str	r4, [r2, #12]
    950e:	4640      	mov	r0, r8
    9510:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    9514:	f7ff baca 	b.w	8aac <__malloc_unlock>
    9518:	6895      	ldr	r5, [r2, #8]
    951a:	4f3a      	ldr	r7, [pc, #232]	; (9604 <_free_r+0x1c4>)
    951c:	42bd      	cmp	r5, r7
    951e:	4403      	add	r3, r0
    9520:	d03f      	beq.n	95a2 <_free_r+0x162>
    9522:	68d0      	ldr	r0, [r2, #12]
    9524:	60e8      	str	r0, [r5, #12]
    9526:	f043 0201 	orr.w	r2, r3, #1
    952a:	6085      	str	r5, [r0, #8]
    952c:	6062      	str	r2, [r4, #4]
    952e:	50e3      	str	r3, [r4, r3]
    9530:	e7b3      	b.n	949a <_free_r+0x5a>
    9532:	07ff      	lsls	r7, r7, #31
    9534:	4403      	add	r3, r0
    9536:	d407      	bmi.n	9548 <_free_r+0x108>
    9538:	f855 2c08 	ldr.w	r2, [r5, #-8]
    953c:	1aa4      	subs	r4, r4, r2
    953e:	4413      	add	r3, r2
    9540:	68a0      	ldr	r0, [r4, #8]
    9542:	68e2      	ldr	r2, [r4, #12]
    9544:	60c2      	str	r2, [r0, #12]
    9546:	6090      	str	r0, [r2, #8]
    9548:	4a2f      	ldr	r2, [pc, #188]	; (9608 <_free_r+0x1c8>)
    954a:	6812      	ldr	r2, [r2, #0]
    954c:	f043 0001 	orr.w	r0, r3, #1
    9550:	4293      	cmp	r3, r2
    9552:	6060      	str	r0, [r4, #4]
    9554:	608c      	str	r4, [r1, #8]
    9556:	d3b6      	bcc.n	94c6 <_free_r+0x86>
    9558:	4b2c      	ldr	r3, [pc, #176]	; (960c <_free_r+0x1cc>)
    955a:	4640      	mov	r0, r8
    955c:	6819      	ldr	r1, [r3, #0]
    955e:	f7ff ff21 	bl	93a4 <_malloc_trim_r>
    9562:	e7b0      	b.n	94c6 <_free_r+0x86>
    9564:	1811      	adds	r1, r2, r0
    9566:	6849      	ldr	r1, [r1, #4]
    9568:	07c9      	lsls	r1, r1, #31
    956a:	d444      	bmi.n	95f6 <_free_r+0x1b6>
    956c:	6891      	ldr	r1, [r2, #8]
    956e:	68d2      	ldr	r2, [r2, #12]
    9570:	60ca      	str	r2, [r1, #12]
    9572:	4403      	add	r3, r0
    9574:	f043 0001 	orr.w	r0, r3, #1
    9578:	6091      	str	r1, [r2, #8]
    957a:	6060      	str	r0, [r4, #4]
    957c:	50e3      	str	r3, [r4, r3]
    957e:	e7a2      	b.n	94c6 <_free_r+0x86>
    9580:	2a14      	cmp	r2, #20
    9582:	d817      	bhi.n	95b4 <_free_r+0x174>
    9584:	f102 075c 	add.w	r7, r2, #92	; 0x5c
    9588:	007f      	lsls	r7, r7, #1
    958a:	f102 055b 	add.w	r5, r2, #91	; 0x5b
    958e:	e7a9      	b.n	94e4 <_free_r+0xa4>
    9590:	10aa      	asrs	r2, r5, #2
    9592:	684b      	ldr	r3, [r1, #4]
    9594:	2501      	movs	r5, #1
    9596:	fa05 f202 	lsl.w	r2, r5, r2
    959a:	4313      	orrs	r3, r2
    959c:	604b      	str	r3, [r1, #4]
    959e:	4602      	mov	r2, r0
    95a0:	e7b1      	b.n	9506 <_free_r+0xc6>
    95a2:	f043 0201 	orr.w	r2, r3, #1
    95a6:	614c      	str	r4, [r1, #20]
    95a8:	610c      	str	r4, [r1, #16]
    95aa:	60e5      	str	r5, [r4, #12]
    95ac:	60a5      	str	r5, [r4, #8]
    95ae:	6062      	str	r2, [r4, #4]
    95b0:	50e3      	str	r3, [r4, r3]
    95b2:	e788      	b.n	94c6 <_free_r+0x86>
    95b4:	2a54      	cmp	r2, #84	; 0x54
    95b6:	d806      	bhi.n	95c6 <_free_r+0x186>
    95b8:	0b1a      	lsrs	r2, r3, #12
    95ba:	f102 076f 	add.w	r7, r2, #111	; 0x6f
    95be:	007f      	lsls	r7, r7, #1
    95c0:	f102 056e 	add.w	r5, r2, #110	; 0x6e
    95c4:	e78e      	b.n	94e4 <_free_r+0xa4>
    95c6:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    95ca:	d806      	bhi.n	95da <_free_r+0x19a>
    95cc:	0bda      	lsrs	r2, r3, #15
    95ce:	f102 0778 	add.w	r7, r2, #120	; 0x78
    95d2:	007f      	lsls	r7, r7, #1
    95d4:	f102 0577 	add.w	r5, r2, #119	; 0x77
    95d8:	e784      	b.n	94e4 <_free_r+0xa4>
    95da:	f240 5054 	movw	r0, #1364	; 0x554
    95de:	4282      	cmp	r2, r0
    95e0:	d806      	bhi.n	95f0 <_free_r+0x1b0>
    95e2:	0c9a      	lsrs	r2, r3, #18
    95e4:	f102 077d 	add.w	r7, r2, #125	; 0x7d
    95e8:	007f      	lsls	r7, r7, #1
    95ea:	f102 057c 	add.w	r5, r2, #124	; 0x7c
    95ee:	e779      	b.n	94e4 <_free_r+0xa4>
    95f0:	27fe      	movs	r7, #254	; 0xfe
    95f2:	257e      	movs	r5, #126	; 0x7e
    95f4:	e776      	b.n	94e4 <_free_r+0xa4>
    95f6:	f043 0201 	orr.w	r2, r3, #1
    95fa:	6062      	str	r2, [r4, #4]
    95fc:	50e3      	str	r3, [r4, r3]
    95fe:	e762      	b.n	94c6 <_free_r+0x86>
    9600:	1fff100c 	.word	0x1fff100c
    9604:	1fff1014 	.word	0x1fff1014
    9608:	1fff1414 	.word	0x1fff1414
    960c:	1fff2cdc 	.word	0x1fff2cdc

00009610 <__register_exitproc>:
    9610:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    9614:	4c25      	ldr	r4, [pc, #148]	; (96ac <__register_exitproc+0x9c>)
    9616:	6825      	ldr	r5, [r4, #0]
    9618:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
    961c:	4606      	mov	r6, r0
    961e:	4688      	mov	r8, r1
    9620:	4692      	mov	sl, r2
    9622:	4699      	mov	r9, r3
    9624:	b3c4      	cbz	r4, 9698 <__register_exitproc+0x88>
    9626:	6860      	ldr	r0, [r4, #4]
    9628:	281f      	cmp	r0, #31
    962a:	dc17      	bgt.n	965c <__register_exitproc+0x4c>
    962c:	1c43      	adds	r3, r0, #1
    962e:	b176      	cbz	r6, 964e <__register_exitproc+0x3e>
    9630:	eb04 0580 	add.w	r5, r4, r0, lsl #2
    9634:	2201      	movs	r2, #1
    9636:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
    963a:	f8d4 1188 	ldr.w	r1, [r4, #392]	; 0x188
    963e:	4082      	lsls	r2, r0
    9640:	4311      	orrs	r1, r2
    9642:	2e02      	cmp	r6, #2
    9644:	f8c4 1188 	str.w	r1, [r4, #392]	; 0x188
    9648:	f8c5 9108 	str.w	r9, [r5, #264]	; 0x108
    964c:	d01e      	beq.n	968c <__register_exitproc+0x7c>
    964e:	3002      	adds	r0, #2
    9650:	6063      	str	r3, [r4, #4]
    9652:	f844 8020 	str.w	r8, [r4, r0, lsl #2]
    9656:	2000      	movs	r0, #0
    9658:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    965c:	4b14      	ldr	r3, [pc, #80]	; (96b0 <__register_exitproc+0xa0>)
    965e:	b303      	cbz	r3, 96a2 <__register_exitproc+0x92>
    9660:	f44f 70c8 	mov.w	r0, #400	; 0x190
    9664:	f7fe fea6 	bl	83b4 <malloc>
    9668:	4604      	mov	r4, r0
    966a:	b1d0      	cbz	r0, 96a2 <__register_exitproc+0x92>
    966c:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
    9670:	2700      	movs	r7, #0
    9672:	e880 0088 	stmia.w	r0, {r3, r7}
    9676:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    967a:	4638      	mov	r0, r7
    967c:	2301      	movs	r3, #1
    967e:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
    9682:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
    9686:	2e00      	cmp	r6, #0
    9688:	d0e1      	beq.n	964e <__register_exitproc+0x3e>
    968a:	e7d1      	b.n	9630 <__register_exitproc+0x20>
    968c:	f8d4 118c 	ldr.w	r1, [r4, #396]	; 0x18c
    9690:	430a      	orrs	r2, r1
    9692:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
    9696:	e7da      	b.n	964e <__register_exitproc+0x3e>
    9698:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
    969c:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    96a0:	e7c1      	b.n	9626 <__register_exitproc+0x16>
    96a2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    96a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    96aa:	bf00      	nop
    96ac:	00009e78 	.word	0x00009e78
    96b0:	000083b5 	.word	0x000083b5

000096b4 <vtable for std_msgs::Time>:
	...
    96bc:	0000046d 00000495 000004d1 000004d9     m...............

000096cc <vtable for rosserial_msgs::TopicInfo>:
	...
    96d4:	00000e11 000004e1 000005c9 000005d1     ................

000096e4 <vtable for rosserial_msgs::Log>:
	...
    96ec:	00000ddd 000005d9 00000621 00000629     ........!...)...

000096fc <vtable for rosserial_msgs::RequestParamResponse>:
	...
    9704:	00000c95 00000eb5 00000631 00000639     ........1...9...

00009714 <vtable for std_msgs::Int16>:
	...
    971c:	00000641 00000651 00000661 00000669     A...Q...a...i...

0000972c <vtable for std_msgs::Float32>:
	...
    9734:	00000671 0000068d 000006ad 000006b5     q...............

00009744 <vtable for geometry_msgs::Vector3>:
	...
    974c:	000006bd 00000725 000007d1 000007d9     ....%...........

0000975c <vtable for geometry_msgs::Quaternion>:
	...
    9764:	000007e1 00000869 00000949 00000951     ....i...I...Q...

00009774 <vtable for geometry_msgs::Twist>:
	...
    977c:	0000109d 00001501 00000959 00000961     ........Y...a...

0000978c <vtable for custom_msgs::odom_and_imu>:
	...
    9794:	00001185 0000166d 00000969 00000971     ....m...i...q...

000097a4 <vtable for ros::NodeHandle_<ArduinoHardware, 25, 25, 512, 512>>:
	...
    97ac:	0000196d 00003dc1 0000098d              m....=......

000097b8 <vtable for ros::Subscriber<geometry_msgs::Twist, void>>:
	...
    97c0:	0000138d 00000979 0000097d 00000985     ....y...}.......

000097d0 <rosserial_msgs::REQUESTPARAM>:
    97d0:	73736f72 61697265 736d5f6c 522f7367     rosserial_msgs/R
    97e0:	65757165 61507473 006d6172 5f647473     equestParam.std_
    97f0:	7367736d 6d69542f 00000065 31376463     msgs/Time...cd71
    9800:	37633636 35356334 31336332 63626631     66c74c552c311fbc
    9810:	65663263 62376135 39383263 00000000     c2fe5a7bc289....
    9820:	73736f72 61697265 736d5f6c 542f7367     rosserial_msgs/T
    9830:	6369706f 6f666e49 00000000 35646130     opicInfo....0ad5
    9840:	38386631 34346366 66323938 30316338     1f88fc44892f8c10
    9850:	30343836 34363737 35303036 00000000     684077646005....
    9860:	73736f72 61697265 736d5f6c 4c2f7367     rosserial_msgs/L
    9870:	0000676f 62613131 31333764 39353263     og..11abd731c259
    9880:	36323333 36646331 62333831 64323164     33261cd6183bd12d
    9890:	35393236 00000000 65306639 64623839     6295....9f0e98bd
    98a0:	39353661 38393138 66646436 66613335     a65981986ddf53af
    98b0:	34613761 39346530 00000000 5f647473     a7a40e49....std_
    98c0:	7367736d 746e492f 00003631 34323538     msgs/Int16..8524
    98d0:	65363835 62663433 62633764 38306331     586e34fbd7cb1c08
    98e0:	35663563 61633166 37356530 00000000     c5f5f1ca0e57....
    98f0:	5f647473 7367736d 6f6c462f 32337461     std_msgs/Float32
    9900:	00000000 63663337 36346662 31393462     ....73fcbf46b491
    9910:	36653139 30393237 30356538 61323438     91e672908e50842a
    9920:	34643338 00000000 6d6f6567 79727465     83d4....geometry
    9930:	67736d5f 65562f73 726f7463 00000033     _msgs/Vector3...
    9940:	34386134 35366232 33313466 64343830     4a842b65f413084d
    9950:	31623263 34626630 61653438 37316637     c2b10fb484ea7f17
    9960:	00000000 6d6f6567 79727465 67736d5f     ....geometry_msg
    9970:	75512f73 72657461 6e6f696e 00000000     s/Quaternion....
    9980:	39373761 66393738 30666461 37303631     a779879fadf01607
    9990:	39663433 38623630 63393163 34303037     34f906b8c19c7004
    99a0:	00000000 6d6f6567 79727465 67736d5f     ....geometry_msg
    99b0:	77542f73 00747369 39316639 38386635     s/Twist.9f195f88
    99c0:	36343231 61666466 38393732 33643164     1246fdfa2798d1d3
    99d0:	63626565 61343861 00000000 74737563     eebca84a....cust
    99e0:	6d5f6d6f 2f736773 6d6f646f 646e615f     om_msgs/odom_and
    99f0:	756d695f 00000000 32663061 36616232     _imu....a0f22ba6
    9a00:	64313563 39643134 61663637 62633835     c51d41d976fa58cb
    9a10:	32333338 30666335 00000000 7373654d     83325cf0....Mess
    9a20:	20656761 6d6f7266 76656420 20656369     age from device 
    9a30:	706f7264 3a646570 73656d20 65676173     dropped: message
    9a40:	72616c20 20726567 6e616874 66756220      larger than buf
    9a50:	2e726566 00000000 00646572 00646552     fer.....red.Red.
    9a60:	00444552 65657267 0000006e 65657247     RED.green...Gree
    9a70:	0000006e 45455247 0000004e 65756c62     n...GREEN...blue
    9a80:	00000000 65756c42 00000000 45554c42     ....Blue....BLUE
    9a90:	00000000 6e617963 00000000 6e617943     ....cyan....Cyan
    9aa0:	00000000 4e415943 00000000 70727570     ....CYAN....purp
    9ab0:	0000656c 70727550 0000656c 50525550     le..Purple..PURP
    9ac0:	0000454c 6e61726f 00006567 6e61724f     LE..orange..Oran
    9ad0:	00006567 4e41524f 00004547 74696877     ge..ORANGE..whit
    9ae0:	00002065 74696857 00000065 54494857     e ..White...WHIT
    9af0:	00000045 74696877 00000065 68676972     E...white...righ
    9b00:	69745f74 00006b63 7466656c 6369745f     t_tick..left_tic
    9b10:	0000006b 65656877 6e615f6c 00656c67     k...wheel_angle.
    9b20:	65657073 6e615f64 69745f64 00006b63     speed_and_tick..
    9b30:	7361656d 64657275 676e615f 0000656c     measured_angle..
    9b40:	6d6f646f 79727465 646e615f 554d495f     odometry_and_IMU
    9b50:	00000000 5f646d63 006c6576              ....cmd_vel.

00009b5c <TwoWire::i2c0_hardware>:
    9b5c:	40048034 00000040 08221112 05020230     4..@@.....".0...
    9b6c:	10130207 022f0721 02070502 00000018     ....!./.........

00009b7c <TwoWire::i2c1_hardware>:
    9b7c:	40048034 00000080 ffff3a26 000602ff     4..@....&:......
    9b8c:	3b250000 02ffffff 00000006 00000019     ..%;............

00009b9c <TwoWire::i2c2_hardware>:
    9b9c:	40048028 00000040 ffffff04 000005ff     (..@@...........
    9bac:	1a030000 05ffffff 00000005 0000004a     ............J...

00009bbc <vtable for TwoWire>:
	...
    9bc4:	000048d5 00004899 00004879 00004895     .H...H..yH...H..
    9bd4:	0000484d 00004859 0000487d              MH..YH..}H..

00009be0 <digital_pin_to_info_PGM>:
    9be0:	43fe0840 4004a040 43fe0844 4004a044     @..C@..@D..CD..@
    9bf0:	43fe1800 4004c000 43fe0030 40049030     ...C...@0..C0..@
    9c00:	43fe0034 40049034 43fe181c 4004c01c     4..C4..@...C...@
    9c10:	43fe1810 4004c010 43fe1808 4004c008     ...C...@...C...@
    9c20:	43fe180c 4004c00c 43fe100c 4004b00c     ...C...@...C...@
    9c30:	43fe1010 4004b010 43fe1018 4004b018     ...C...@...C...@
    9c40:	43fe101c 4004b01c 43fe1014 4004b014     ...C...@...C...@
    9c50:	43fe1804 4004c004 43fe1000 4004b000     ...C...@...C...@
    9c60:	43fe0800 4004a000 43fe0804 4004a004     ...C...@...C...@
    9c70:	43fe080c 4004a00c 43fe0808 4004a008     ...C...@...C...@
    9c80:	43fe1814 4004c014 43fe1818 4004c018     ...C...@...C...@
    9c90:	43fe1004 4004b004 43fe1008 4004b008     ...C...@...C...@
    9ca0:	43fe2068 4004d068 43fe0014 40049014     h .Ch..@...C...@
    9cb0:	43fe0038 40049038 43fe003c 4004903c     8..C8..@<..C<..@
    9cc0:	43fe0040 40049040 43fe0848 4004a048     @..C@..@H..CH..@
    9cd0:	43fe084c 4004a04c 43fe0828 4004a028     L..CL..@(..C(..@
    9ce0:	43fe082c 4004a02c 43fe2060 4004d060     ,..C,..@` .C`..@
    9cf0:	43fe2064 4004d064 43fe1020 4004b020     d .Cd..@ ..C ..@
    9d00:	43fe1024 4004b024 43fe1028 4004b028     $..C$..@(..C(..@
    9d10:	43fe102c 4004b02c 43fe0044 40049044     ,..C,..@D..CD..@
    9d20:	43fe0070 40049070 43fe0074 40049074     p..Cp..@t..Ct..@
    9d30:	43fe0068 40049068 43fe0850 4004a050     h..Ch..@P..CP..@
    9d40:	43fe0858 4004a058 43fe085c 4004a05c     X..CX..@\..C\..@
    9d50:	43fe0854 4004a054 43fe1820 4004c020     T..CT..@ ..C ..@
    9d60:	43fe1824 4004c024 43fe0810 4004a010     $..C$..@...C...@
    9d70:	43fe0814 4004a014 43fe1838 4004c038     ...C...@8..C8..@
    9d80:	43fe1834 4004c034 43fe1830 4004c030     4..C4..@0..C0..@
    9d90:	43fe183c 4004c03c 43fe182c 4004c02c     <..C<..@,..C,..@
    9da0:	43fe2028 4004d028 43fe202c 4004d02c     ( .C(..@, .C,..@
    9db0:	43fe2000 4004d000 43fe2004 4004d004     . .C...@. .C...@
    9dc0:	43fe2008 4004d008 43fe200c 4004d00c     . .C...@. .C...@
    9dd0:	43fe2010 4004d010 43fe2014 4004d014     . .C...@. .C...@

00009de0 <vtable for usb_serial_class>:
	...
    9de8:	00006409 00000ea9 00006405 00006401     .d.......d...d..
    9df8:	000063fd 00000eb1 000063f9 000063f5     .c.......c...c..

00009e08 <usb_endpoint_config_table>:
    9e08:	15191500                                ....

00009e0c <usb_descriptor_list>:
    9e0c:	00000100 1fff0b3c 00000012 00000200     ....<...........
    9e1c:	1fff0b68 00000043 00000300 1fff0bc4     h...C...........
    9e2c:	00000000 04090301 1fff0b50 00000000     ........P.......
    9e3c:	04090302 1fff0bac 00000000 04090303     ................
    9e4c:	1fff0bc8 00000000 00000000 00000000     ................
    9e5c:	00000000 00776f70 ffffffff              ....pow.....

00009e68 <TWO52>:
    9e68:	00000000 43300000 00000000 c3300000     ......0C......0.

00009e78 <_global_impure_ptr>:
    9e78:	1fff0be0                                ....

00009e7c <_init>:
    9e7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9e7e:	bf00      	nop
    9e80:	bcf8      	pop	{r3, r4, r5, r6, r7}
    9e82:	bc08      	pop	{r3}
    9e84:	469e      	mov	lr, r3
    9e86:	4770      	bx	lr

00009e88 <__init_array_start>:
    9e88:	0000935d 	.word	0x0000935d

00009e8c <__frame_dummy_init_array_entry>:
    9e8c:	00000435 00004619                       5....F..

Disassembly of section .fini:

00009e94 <_fini>:
    9e94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9e96:	bf00      	nop

Disassembly of section .data:

1fff0730 <port_E_isr>:
#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
PORT_ISR_FUNCTION_CLZ(C)
PORT_ISR_FUNCTION_CLZ(D)
PORT_ISR_FUNCTION_CLZ(E)
1fff0730:	b538      	push	{r3, r4, r5, lr}
1fff0732:	4b08      	ldr	r3, [pc, #32]	; (1fff0754 <port_E_isr+0x24>)
1fff0734:	681c      	ldr	r4, [r3, #0]
1fff0736:	601c      	str	r4, [r3, #0]
1fff0738:	b154      	cbz	r4, 1fff0750 <port_E_isr+0x20>
1fff073a:	4d07      	ldr	r5, [pc, #28]	; (1fff0758 <port_E_isr+0x28>)
1fff073c:	fa94 f3a4 	rbit	r3, r4
1fff0740:	fab3 f383 	clz	r3, r3
1fff0744:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff0748:	4798      	blx	r3
1fff074a:	1e63      	subs	r3, r4, #1
1fff074c:	401c      	ands	r4, r3
1fff074e:	d1f5      	bne.n	1fff073c <port_E_isr+0xc>
1fff0750:	bd38      	pop	{r3, r4, r5, pc}
1fff0752:	bf00      	nop
1fff0754:	4004d0a0 	.word	0x4004d0a0
1fff0758:	1fff0ab4 	.word	0x1fff0ab4

1fff075c <port_D_isr>:

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
PORT_ISR_FUNCTION_CLZ(C)
PORT_ISR_FUNCTION_CLZ(D)
1fff075c:	b538      	push	{r3, r4, r5, lr}
1fff075e:	4b08      	ldr	r3, [pc, #32]	; (1fff0780 <port_D_isr+0x24>)
1fff0760:	681c      	ldr	r4, [r3, #0]
1fff0762:	601c      	str	r4, [r3, #0]
1fff0764:	b154      	cbz	r4, 1fff077c <port_D_isr+0x20>
1fff0766:	4d07      	ldr	r5, [pc, #28]	; (1fff0784 <port_D_isr+0x28>)
1fff0768:	fa94 f3a4 	rbit	r3, r4
1fff076c:	fab3 f383 	clz	r3, r3
1fff0770:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff0774:	4798      	blx	r3
1fff0776:	1e63      	subs	r3, r4, #1
1fff0778:	401c      	ands	r4, r3
1fff077a:	d1f5      	bne.n	1fff0768 <port_D_isr+0xc>
1fff077c:	bd38      	pop	{r3, r4, r5, pc}
1fff077e:	bf00      	nop
1fff0780:	4004c0a0 	.word	0x4004c0a0
1fff0784:	1fff0a74 	.word	0x1fff0a74

1fff0788 <port_C_isr>:
// END PORT_ISR_FUNCTION_CLZ

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
PORT_ISR_FUNCTION_CLZ(C)
1fff0788:	b538      	push	{r3, r4, r5, lr}
1fff078a:	4b08      	ldr	r3, [pc, #32]	; (1fff07ac <port_C_isr+0x24>)
1fff078c:	681c      	ldr	r4, [r3, #0]
1fff078e:	601c      	str	r4, [r3, #0]
1fff0790:	b154      	cbz	r4, 1fff07a8 <port_C_isr+0x20>
1fff0792:	4d07      	ldr	r5, [pc, #28]	; (1fff07b0 <port_C_isr+0x28>)
1fff0794:	fa94 f3a4 	rbit	r3, r4
1fff0798:	fab3 f383 	clz	r3, r3
1fff079c:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff07a0:	4798      	blx	r3
1fff07a2:	1e63      	subs	r3, r4, #1
1fff07a4:	401c      	ands	r4, r3
1fff07a6:	d1f5      	bne.n	1fff0794 <port_C_isr+0xc>
1fff07a8:	bd38      	pop	{r3, r4, r5, pc}
1fff07aa:	bf00      	nop
1fff07ac:	4004b0a0 	.word	0x4004b0a0
1fff07b0:	1fff0a44 	.word	0x1fff0a44

1fff07b4 <port_B_isr>:
	}
// END PORT_ISR_FUNCTION_CLZ

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
1fff07b4:	b538      	push	{r3, r4, r5, lr}
1fff07b6:	4b08      	ldr	r3, [pc, #32]	; (1fff07d8 <port_B_isr+0x24>)
1fff07b8:	681c      	ldr	r4, [r3, #0]
1fff07ba:	601c      	str	r4, [r3, #0]
1fff07bc:	b154      	cbz	r4, 1fff07d4 <port_B_isr+0x20>
1fff07be:	4d07      	ldr	r5, [pc, #28]	; (1fff07dc <port_B_isr+0x28>)
1fff07c0:	fa94 f3a4 	rbit	r3, r4
1fff07c4:	fab3 f383 	clz	r3, r3
1fff07c8:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff07cc:	4798      	blx	r3
1fff07ce:	1e63      	subs	r3, r4, #1
1fff07d0:	401c      	ands	r4, r3
1fff07d2:	d1f5      	bne.n	1fff07c0 <port_B_isr+0xc>
1fff07d4:	bd38      	pop	{r3, r4, r5, pc}
1fff07d6:	bf00      	nop
1fff07d8:	4004a0a0 	.word	0x4004a0a0
1fff07dc:	1fff09e4 	.word	0x1fff09e4

1fff07e0 <port_A_isr>:
		}                                                     \
	}
// END PORT_ISR_FUNCTION_CLZ

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
1fff07e0:	b538      	push	{r3, r4, r5, lr}
1fff07e2:	4b08      	ldr	r3, [pc, #32]	; (1fff0804 <port_A_isr+0x24>)
1fff07e4:	681c      	ldr	r4, [r3, #0]
1fff07e6:	601c      	str	r4, [r3, #0]
1fff07e8:	b154      	cbz	r4, 1fff0800 <port_A_isr+0x20>
1fff07ea:	4d07      	ldr	r5, [pc, #28]	; (1fff0808 <port_A_isr+0x28>)
1fff07ec:	fa94 f3a4 	rbit	r3, r4
1fff07f0:	fab3 f383 	clz	r3, r3
1fff07f4:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff07f8:	4798      	blx	r3
1fff07fa:	1e63      	subs	r3, r4, #1
1fff07fc:	401c      	ands	r4, r3
1fff07fe:	d1f5      	bne.n	1fff07ec <port_A_isr+0xc>
1fff0800:	bd38      	pop	{r3, r4, r5, pc}
1fff0802:	bf00      	nop
1fff0804:	400490a0 	.word	0x400490a0
1fff0808:	1fff096c 	.word	0x1fff096c

1fff080c <period>:
1fff080c:	000003e8                                ....

1fff0810 <wheel_radius>:
1fff0810:	3d23d70a                                ..#=

1fff0814 <wheel_base>:
1fff0814:	3e6a7efa                                .~j>

1fff0818 <count_to_rad>:
1fff0818:	20000000 3f6aceea                       ... ..j?

1fff0820 <float_to_long_factor>:
1fff0820:	461c4000                                .@.F

1fff0824 <Wire2>:
1fff0824:	00009bc4 00000000 000003e8 00000000     ................
1fff0834:	400e6000 00009b9c 00000000 00000000     .`.@............
	...

1fff0890 <Wire>:
1fff0890:	00009bc4 00000000 000003e8 00000000     ................
1fff08a0:	40066000 00009b5c 00000000 00000000     .`.@\...........
	...

1fff08fc <Wire1>:
1fff08fc:	00009bc4 00000000 000003e8 00000000     ................
1fff090c:	40067000 00009b7c 00000000 00000000     .p.@|...........
	...

1fff0968 <__brkval>:
1fff0968:	1fff2d20                                 -..

1fff096c <isr_table_portA>:
1fff096c:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff097c:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff098c:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff099c:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff09ac:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff09bc:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff09cc:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff09dc:	00004d1d 00004d1d                       .M...M..

1fff09e4 <isr_table_portB>:
1fff09e4:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff09f4:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff0a04:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff0a14:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff0a24:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff0a34:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..

1fff0a44 <isr_table_portC>:
1fff0a44:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff0a54:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff0a64:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..

1fff0a74 <isr_table_portD>:
1fff0a74:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff0a84:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff0a94:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff0aa4:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..

1fff0ab4 <isr_table_portE>:
1fff0ab4:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff0ac4:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff0ad4:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff0ae4:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff0af4:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff0b04:	00004d1d 00004d1d 00004d1d 00004d1d     .M...M...M...M..
1fff0b14:	00004d1d 00004d1d 00004d1d              .M...M...M..

1fff0b20 <analog_write_res>:
1fff0b20:	00000008                                ....

1fff0b24 <usb_buffer_available>:
1fff0b24:	ffffffff                                ....

1fff0b28 <Serial>:
1fff0b28:	00009de8 00000000 000003e8 00000000     ................

1fff0b38 <yield_active_check_flags>:
1fff0b38:	00040a01                                         .

1fff0b39 <analog_config_bits>:
1fff0b39:	1200040a                                         .

1fff0b3a <analog_num_average>:
1fff0b3a:	01120004                                         ..

1fff0b3c <device_descriptor>:
1fff0b3c:	01100112 40000002 048316c0 02010277     .......@....w...
1fff0b4c:	00000103                                ....

1fff0b50 <usb_string_manufacturer_name_default>:
1fff0b50:	00540318 00650065 0073006e 00640079     ..T.e.e.n.s.y.d.
1fff0b60:	00690075 006f006e                       u.i.n.o.

1fff0b68 <config_descriptor>:
1fff0b68:	00430209 c0000102 00040932 02020100     ..C.....2.......
1fff0b78:	24050001 05011000 01010124 06022404     ...$....$....$..
1fff0b88:	00062405 82050701 40001003 00010409     .$.........@....
1fff0b98:	00000a02 03050700 00004002 02840507     .........@......
1fff0ba8:	00000040                                @...

1fff0bac <usb_string_product_name_default>:
1fff0bac:	00550316 00420053 00530020 00720065     ..U.S.B. .S.e.r.
1fff0bbc:	00610069 0000006c                       i.a.l...

1fff0bc4 <string0>:
1fff0bc4:	04090304                                ....

1fff0bc8 <usb_string_serial_number_default>:
1fff0bc8:	0000030c 00000000 00000000 00000000     ................
1fff0bd8:	00000000 01010000                                ......

1fff0bde <_serialEvent_default>:
1fff0bde:	00000101                                         .

1fff0bdf <__fdlib_version>:
1fff0bdf:	00000001                                         .

1fff0be0 <impure_data>:
1fff0be0:	00000000 1fff0ecc 1fff0f34 1fff0f9c     ........4.......
	...
1fff0c88:	00000001 00000000 abcd330e e66d1234     .........3..4.m.
1fff0c98:	0005deec 0000000b 00000000 00000000     ................
	...

1fff1008 <_impure_ptr>:
1fff1008:	1fff0be0                                ....

1fff100c <__malloc_av_>:
	...
1fff1014:	1fff100c 1fff100c 1fff1014 1fff1014     ................
1fff1024:	1fff101c 1fff101c 1fff1024 1fff1024     ........$...$...
1fff1034:	1fff102c 1fff102c 1fff1034 1fff1034     ,...,...4...4...
1fff1044:	1fff103c 1fff103c 1fff1044 1fff1044     <...<...D...D...
1fff1054:	1fff104c 1fff104c 1fff1054 1fff1054     L...L...T...T...
1fff1064:	1fff105c 1fff105c 1fff1064 1fff1064     \...\...d...d...
1fff1074:	1fff106c 1fff106c 1fff1074 1fff1074     l...l...t...t...
1fff1084:	1fff107c 1fff107c 1fff1084 1fff1084     |...|...........
1fff1094:	1fff108c 1fff108c 1fff1094 1fff1094     ................
1fff10a4:	1fff109c 1fff109c 1fff10a4 1fff10a4     ................
1fff10b4:	1fff10ac 1fff10ac 1fff10b4 1fff10b4     ................
1fff10c4:	1fff10bc 1fff10bc 1fff10c4 1fff10c4     ................
1fff10d4:	1fff10cc 1fff10cc 1fff10d4 1fff10d4     ................
1fff10e4:	1fff10dc 1fff10dc 1fff10e4 1fff10e4     ................
1fff10f4:	1fff10ec 1fff10ec 1fff10f4 1fff10f4     ................
1fff1104:	1fff10fc 1fff10fc 1fff1104 1fff1104     ................
1fff1114:	1fff110c 1fff110c 1fff1114 1fff1114     ................
1fff1124:	1fff111c 1fff111c 1fff1124 1fff1124     ........$...$...
1fff1134:	1fff112c 1fff112c 1fff1134 1fff1134     ,...,...4...4...
1fff1144:	1fff113c 1fff113c 1fff1144 1fff1144     <...<...D...D...
1fff1154:	1fff114c 1fff114c 1fff1154 1fff1154     L...L...T...T...
1fff1164:	1fff115c 1fff115c 1fff1164 1fff1164     \...\...d...d...
1fff1174:	1fff116c 1fff116c 1fff1174 1fff1174     l...l...t...t...
1fff1184:	1fff117c 1fff117c 1fff1184 1fff1184     |...|...........
1fff1194:	1fff118c 1fff118c 1fff1194 1fff1194     ................
1fff11a4:	1fff119c 1fff119c 1fff11a4 1fff11a4     ................
1fff11b4:	1fff11ac 1fff11ac 1fff11b4 1fff11b4     ................
1fff11c4:	1fff11bc 1fff11bc 1fff11c4 1fff11c4     ................
1fff11d4:	1fff11cc 1fff11cc 1fff11d4 1fff11d4     ................
1fff11e4:	1fff11dc 1fff11dc 1fff11e4 1fff11e4     ................
1fff11f4:	1fff11ec 1fff11ec 1fff11f4 1fff11f4     ................
1fff1204:	1fff11fc 1fff11fc 1fff1204 1fff1204     ................
1fff1214:	1fff120c 1fff120c 1fff1214 1fff1214     ................
1fff1224:	1fff121c 1fff121c 1fff1224 1fff1224     ........$...$...
1fff1234:	1fff122c 1fff122c 1fff1234 1fff1234     ,...,...4...4...
1fff1244:	1fff123c 1fff123c 1fff1244 1fff1244     <...<...D...D...
1fff1254:	1fff124c 1fff124c 1fff1254 1fff1254     L...L...T...T...
1fff1264:	1fff125c 1fff125c 1fff1264 1fff1264     \...\...d...d...
1fff1274:	1fff126c 1fff126c 1fff1274 1fff1274     l...l...t...t...
1fff1284:	1fff127c 1fff127c 1fff1284 1fff1284     |...|...........
1fff1294:	1fff128c 1fff128c 1fff1294 1fff1294     ................
1fff12a4:	1fff129c 1fff129c 1fff12a4 1fff12a4     ................
1fff12b4:	1fff12ac 1fff12ac 1fff12b4 1fff12b4     ................
1fff12c4:	1fff12bc 1fff12bc 1fff12c4 1fff12c4     ................
1fff12d4:	1fff12cc 1fff12cc 1fff12d4 1fff12d4     ................
1fff12e4:	1fff12dc 1fff12dc 1fff12e4 1fff12e4     ................
1fff12f4:	1fff12ec 1fff12ec 1fff12f4 1fff12f4     ................
1fff1304:	1fff12fc 1fff12fc 1fff1304 1fff1304     ................
1fff1314:	1fff130c 1fff130c 1fff1314 1fff1314     ................
1fff1324:	1fff131c 1fff131c 1fff1324 1fff1324     ........$...$...
1fff1334:	1fff132c 1fff132c 1fff1334 1fff1334     ,...,...4...4...
1fff1344:	1fff133c 1fff133c 1fff1344 1fff1344     <...<...D...D...
1fff1354:	1fff134c 1fff134c 1fff1354 1fff1354     L...L...T...T...
1fff1364:	1fff135c 1fff135c 1fff1364 1fff1364     \...\...d...d...
1fff1374:	1fff136c 1fff136c 1fff1374 1fff1374     l...l...t...t...
1fff1384:	1fff137c 1fff137c 1fff1384 1fff1384     |...|...........
1fff1394:	1fff138c 1fff138c 1fff1394 1fff1394     ................
1fff13a4:	1fff139c 1fff139c 1fff13a4 1fff13a4     ................
1fff13b4:	1fff13ac 1fff13ac 1fff13b4 1fff13b4     ................
1fff13c4:	1fff13bc 1fff13bc 1fff13c4 1fff13c4     ................
1fff13d4:	1fff13cc 1fff13cc 1fff13d4 1fff13d4     ................
1fff13e4:	1fff13dc 1fff13dc 1fff13e4 1fff13e4     ................
1fff13f4:	1fff13ec 1fff13ec 1fff13f4 1fff13f4     ................
1fff1404:	1fff13fc 1fff13fc 1fff1404 1fff1404     ................

1fff1414 <__malloc_trim_threshold>:
1fff1414:	00020000                                ....

1fff1418 <__malloc_sbrk_base>:
1fff1418:	ffffffff                                ....
